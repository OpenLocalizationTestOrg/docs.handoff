{"content":"---\ntitle: \"Attributed Programming Model Overview (MEF) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"MEF, attributed programming model\"\n  - \"attributed programming model [MEF]\"\nms.assetid: 49b787ff-2741-4836-ad51-c3017dc592d4\ncaps.latest.revision: 24\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Attributed Programming Model Overview (MEF)\nIn the Managed Extensibility Framework (MEF), a *programming model* is a particular method of defining the set of conceptual objects on which MEF operates. These conceptual objects include parts, imports, and exports. MEF uses these objects, but does not specify how they should be represented. Therefore, a wide variety of programming models are possible, including customized programming models.  \n  \n The default programming model used in MEF is the *attributed programming model*. In the attributed programming model parts, imports, exports, and other objects are defined with attributes that decorate ordinary .NET Framework classes. This topic explains how to use the attributes provided by the attributed programming model to create a MEF application.  \n  \n<a name=\"import_and_export_basics\"></a>   \n## Import and Export Basics  \n An *export* is a value that a part provides to other parts in the container, and an *import* is a requirement that a part expresses to the container, to be filled from the available exports. In the attributed programming model, imports and exports are declared by decorating classes or members with the `Import` and `Export` attributes. The `Export` attribute can decorate a class, field, property, or method, while the `Import` attribute can decorate a field, property, or constructor parameter.  \n  \n In order for an import to be matched with an export, the import and export must have the same *contract*. The contract consists of a string, called the *contract name*, and the type of the exported or imported object, called the *contract type*. Only if both the contract name and contract type match is an export considered to fulfill a particular import.  \n  \n Either or both of the contract parameters can be implicit or explicit. The following code shows a class that declares a basic import.  \n  \n```vb  \nPublic Class MyClass1  \n    <Import()>  \n    Public Property MyAddin As IMyAddin  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [Import]  \n    public IMyAddin MyAddin { get; set; }  \n}  \n```  \n  \n In this import, the `Import` attribute has neither a contract type nor a contract name parameter attached. Therefore, both will be inferred from the decorated property. In this case, the contract type will be `IMyAddin`, and the contract name will be a unique string created from the contract type. (In other words, the contract name will match only exports whose names are also inferred from the type `IMyAddin`.)  \n  \n The following shows an export that matches the previous import.  \n  \n```vb  \n<Export(GetType(IMyAddin))>  \nPublic Class MyLogger  \n    Implements IMyAddin  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export(typeof(IMyAddin))]  \npublic class MyLogger : IMyAddin { }  \n```  \n  \n In this export, the contract type is `IMyAddin` because it is specified as a parameter of the `Export` attribute. The exported type must be either the same as the contract type, derive from the contract type, or implement the contract type if it is an interface. In this export, the actual type `MyLogger` implements the interface `IMyAddin`. The contract name is inferred from the contract type, which means that this export will match the previous import.  \n  \n> [!NOTE]\n>  Exports and imports should usually be declared on public classes or members. Other declarations are supported, but exporting or importing a private, protected, or internal member breaks the isolation model for the part and is therefore not recommended.  \n  \n The contract type must match exactly for the export and import to be considered a match. Consider the following export.  \n  \n```vb  \n<Export()> 'WILL NOT match the previous import!  \nPublic Class MyLogger  \n    Implements IMyAddin  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export] //WILL NOT match the previous import!  \npublic class MyLogger : IMyAddin { }  \n```  \n  \n In this export, the contract type is `MyLogger` instead of `IMyAddin`. Even though `MyLogger` implements `IMyAddin`, and therefore could be cast to an `IMyAddin` object, this export will not match the previous import because the contract types are not the same.  \n  \n In general, it is not necessary to specify the contract name, and most contracts should be defined in terms of the contract type and metadata. However, under certain circumstances, it is important to specify the contract name directly. The most common case is when a class exports several values that share a common type, such as primitives. The contract name can be specified as the first parameter of the `Import` or `Export` attribute. The following code shows an import and an export with a specified contract name of `MajorRevision`.  \n  \n```vb  \nPublic Class MyExportClass  \n  \n    'This one will match  \n    <Export(\"MajorRevision\")>  \n    Public ReadOnly Property MajorRevision As Integer  \n        Get  \n            Return 4  \n        End Get  \n    End Property  \n  \n    <Export(\"MinorRevision\")>  \n    Public ReadOnly Property MinorRevision As Integer  \n        Get  \n            Return 16  \n        End Get  \n    End Property  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [Import(\"MajorRevision\")]  \n    public int MajorRevision { get; set; }  \n}  \n  \npublic class MyExportClass  \n{   \n    [Export(\"MajorRevision\")] //This one will match.  \n    public int MajorRevision = 4;  \n  \n    [Export(\"MinorRevision\")]  \n    public int MinorRevision = 16;  \n}  \n```  \n  \n If the contract type is not specified, it will still be inferred from the type of the import or export. However, even if the contract name is specified explicitly, the contract type must also match exactly for the import and export to be considered a match. For example, if the `MajorRevision` field was a string, the inferred contract types would not match and the export would not match the import, despite having the same contract name.  \n  \n### Importing and Exporting a Method  \n The `Export` attribute can also decorate a method, in the same way as a class, property, or function. Method exports must specify a contract type or contract name, as the type cannot be inferred. The specified type can be either a custom delegate or a generic type, such as `Func`. The following class exports a method named `DoSomething`.  \n  \n```vb  \nPublic Class MyAddin  \n  \n    'Explicitly specifying a generic type  \n    <Export(GetType(Func(Of Integer, String)))>  \n    Public Function DoSomething(ByVal TheParam As Integer) As String  \n        Return Nothing 'Function body goes here  \n    End Function  \n  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyAddin  \n{  \n    //Explicitly specifying a generic type.  \n    [Export(typeof(Func<int, string>)]  \n    public string DoSomething(int TheParam);  \n}  \n```  \n  \n In this class, the `DoSomething` method takes a single `int` parameter and returns a `string`. To match this export, the importing part must declare an appropriate member. The following class imports the `DoSomething` method.  \n  \n```vb  \nPublic Class MyClass1  \n  \n    'Contract name must match!  \n    <Import()>  \n    Public Property MajorRevision As Func(Of Integer, String)  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [Import] //Contract name must match!  \n    public Func<int, string> DoSomething { get; set; }  \n}  \n```  \n  \n For more information about how to use of the `Func<T, T>` object, see <xref:System.Func%602>.  \n  \n<a name=\"types_of_imports\"></a>   \n## Types of Imports  \n MEF support several import types, including dynamic, lazy, prerequisite, and optional.  \n  \n### Dynamic Imports  \n In some cases, the importing class may want to match exports of any type that have a particular contract name. In this scenario, the class can declare a *dynamic import*. The following import matches any export with contract name \"TheString\".  \n  \n```vb  \nPublic Class MyClass1  \n  \n    <Import(\"TheString\")>  \n    Public Property MyAddin  \n  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [Import(\"TheString\")]  \n    public dynamic MyAddin { get; set; }  \n}  \n```  \n  \n When the contract type is inferred from the `dynamic` keyword, it will match any contract type. In this case, an import should **always** specify a contract name to match on. (If no contract name is specified, the import will be considered to match no exports.) Both of the following exports would match the previous import.  \n  \n```vb  \n<Export(\"TheString\", GetType(IMyAddin))>  \nPublic Class MyLogger  \n    Implements IMyAddin  \n  \nEnd Class  \n  \n<Export(\"TheString\")>  \nPublic Class MyToolbar  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export(\"TheString\", typeof(IMyAddin))]  \npublic class MyLogger : IMyAddin { }  \n  \n[Export(\"TheString\")]  \npublic class MyToolbar { }  \n```  \n  \n Obviously, the importing class must be prepared to deal with an object of arbitrary type.  \n  \n### Lazy Imports  \n In some cases, the importing class may require an indirect reference to the imported object, so that the object is not instantiated immediately. In this scenario, the class can declare a *lazy import* by using a contract type of `Lazy<T>`. The following importing property declares a lazy import.  \n  \n```vb  \nPublic Class MyClass1  \n  \n    <Import()>  \n    Public Property MyAddin As Lazy(Of IMyAddin)  \n  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [Import]  \n    public Lazy<IMyAddin> MyAddin { get; set; }  \n}  \n```  \n  \n From the point of view of the composition engine, a contract type of `Lazy<T>` is considered identical to contract type of `T`. Therefore, the previous import would match the following export.  \n  \n```vb  \n<Export(GetType(IMyAddin))>  \nPublic Class MyLogger  \n    Implements IMyAddin  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export(typeof(IMyAddin))]  \npublic class MyLogger : IMyAddin { }  \n```  \n  \n The contract name and contract type can be specified in the `Import` attribute for a lazy import, as described earlier in the \"Basic Imports and Exports\" section.  \n  \n### Prerequisite Imports  \n Exported MEF parts are typically created by the composition engine, in response to a direct request or the need to fill a matched import. By default, when creating a part, the composition engine uses the parameter-less constructor. To make the engine use a different constructor, you can mark it with the `ImportingConstructor` attribute.  \n  \n Each part may have only one constructor for use by the composition engine. Providing no default constructor and no `ImportingConstructor` attribute, or providing more than one `ImportingConstructor` attribute, will produce an error.  \n  \n To fill the parameters of a constructor marked with the `ImportingConstructor` attribute, all of those parameters are automatically declared as imports. This is a convenient way to declare imports that are used during part initialization. The following class uses `ImportingConstructor` to declare an import.  \n  \n```vb  \nPublic Class MyClass1  \n  \n    Private _theAddin As IMyAddin  \n  \n    'Default constructor will NOT be used  \n    'because the ImportingConstructor  \n    'attribute is present.  \n    Public Sub New()  \n  \n    End Sub  \n  \n    'This constructor will be used.  \n    'An import with contract type IMyAddin  \n    'is declared automatically.  \n    <ImportingConstructor()>  \n    Public Sub New(ByVal MyAddin As IMyAddin)  \n        _theAddin = MyAddin  \n    End Sub  \n  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass   \n{  \n    private IMyAddin _theAddin;  \n  \n    //Default constructor will NOT be  \n    //used because the ImportingConstructor  \n    //attribute is present.  \n    public MyClass() { }  \n  \n    //This constructor will be used.  \n    //An import with contract type IMyAddin is   \n    //declared automatically.  \n    [ImportingConstructor]   \n    public MyClass(IMyAddin MyAddin)   \n    {  \n        _theAddin = MyAddin;  \n    }  \n}  \n```  \n  \n By default, the `ImportingConstructor` attribute uses inferred contract types and contract names for all of the parameter imports. It is possible to override this by decorating the parameters with `Import` attributes, which can then define the contract type and contract name explicitly. The following code demonstrates a constructor that uses this syntax to import a derived class instead of a parent class.  \n  \n```vb  \n<ImportingConstructor()>  \nPublic Sub New(<Import(GetType(IMySubAddin))> ByVal MyAddin As IMyAddin)  \n  \nEnd Sub  \n```  \n  \n```csharp  \n[ImportingConstructor]   \npublic MyClass([Import(typeof(IMySubAddin))]IMyAddin MyAddin)   \n{  \n    _theAddin = MyAddin;  \n}  \n```  \n  \n In particular, you should be careful with collection parameters. For example, if you specify `ImportingConstructor` on a constructor with a parameter of type `IEnumerable<int>`, the import will match a single export of type `IEnumerable<int>`, instead of a set of exports of type `int`. To match a set of exports of type `int`, you have to decorate the parameter with the `ImportMany` attribute.  \n  \n Parameters declared as imports by the `ImportingConstructor` attribute are also marked as *prerequisite imports*. MEF normally allows exports and imports to form a *cycle*. For example, a cycle is where object A imports object B, which in turn imports object A. Under ordinary circumstances, a cycle is not a problem, and the composition container constructs both objects normally.  \n  \n When an imported value is required by the constructor of a part, that object cannot participate in a cycle. If object A requires that object B be constructed before it can be constructed itself, and object B imports object A, then the cycle will be unable to resolve and a composition error will occur. Imports declared on constructor parameters are therefore prerequisite imports, which must all be filled before any of the exports from the object that requires them can be used.  \n  \n### Optional Imports  \n The `Import` attribute specifies a requirement for the part to function. If an import cannot be fulfilled, the composition of that part will fail and the part will not be available.  \n  \n You can specify that an import is *optional* by using the `AllowDefault` property. In this case, the composition will succeed even if the import does not match any available exports, and the importing property will be set to the default for its property type (`null` for object properties, `false` for Booleans, or zero for numeric properties.) The following class uses an optional import.  \n  \n```vb  \nPublic Class MyClass1  \n  \n    <Import(AllowDefault:=True)>  \n    Public Property thePlugin As Plugin  \n  \n    'If no matching export is available,  \n    'thePlugin will be set to null.  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [Import(AllowDefault = true)]  \n    public Plugin thePlugin { get; set; }  \n  \n    //If no matching export is avaliable,  \n    //thePlugin will be set to null.  \n}  \n```  \n  \n### Importing Multiple Objects  \n The `Import` attribute will only be successfully composed when it matches one and only one export. Other cases will produce a composition error. To import more than one export that matches the same contract, use the `ImportMany` attribute. Imports marked with this attribute are always optional. For example, composition will not fail if no matching exports are present. The following class imports any number of exports of type `IMyAddin`.  \n  \n```vb  \nPublic Class MyClass1  \n  \n    <ImportMany()>  \n    Public Property MyAddin As IEnumerable(Of IMyAddin)  \n  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [ImportMany]  \n    public IEnumerable<IMyAddin> MyAddin { get; set; }  \n}  \n```  \n  \n The imported array can be accessed by using ordinary `IEnumerable<T>` syntax and methods. It is also possible to use an ordinary array (`IMyAddin[]`) instead.  \n  \n This pattern can be very important when you use it in combination with the `Lazy<T>` syntax. For example, by using `ImportMany`, `IEnumerable<T>`, and `Lazy<T>`, you can import indirect references to any number of objects and only instantiate the ones that become necessary. The following class shows this pattern.  \n  \n```vb  \nPublic Class MyClass1  \n  \n    <ImportMany()>  \n    Public Property MyAddin As IEnumerable(Of Lazy(Of IMyAddin))  \n  \nEnd Class  \n```  \n  \n```csharp  \npublic class MyClass  \n{  \n    [ImportMany]  \n    public IEnumerable<Lazy<IMyAddin>> MyAddin { get; set; }  \n}  \n```  \n  \n<a name=\"avoiding_discovery\"></a>   \n## Avoiding Discovery  \n In some cases, you may want to prevent a part from being discovered as part of a catalog. For example, the part may be a base class intended to be inherited from, but not used. There are two ways to accomplish this. First, you can use the `abstract` keyword on the part class. Abstract classes never provide exports, although they can provide inherited exports to classes that derive from them.  \n  \n If the class cannot be made abstract, you can decorate it with the `PartNotDiscoverable` attribute. A part decorated with this attribute will not be included in any catalogs. The following example demonstrates these patterns. `DataOne` will be discovered by the catalog. Since `DataTwo` is abstract, it will not be discovered. Since `DataThree` used the `PartNotDiscoverable` attribute, it will not be discovered.  \n  \n```vb  \n<Export()>  \nPublic Class DataOne  \n    'This part will be discovered   \n    'as normal by the catalog.  \nEnd Class  \n  \n<Export()>  \nPublic MustInherit Class DataTwo  \n    'This part will not be discovered  \n    'by the catalog.  \nEnd Class  \n  \n<PartNotDiscoverable()>  \n<Export()>  \nPublic Class DataThree  \n    'This part will also not be discovered  \n    'by the catalog.  \nEnd Class  \n```  \n  \n```csharp  \n[Export]  \npublic class DataOne  \n{  \n    //This part will be discovered  \n    //as normal by the catalog.  \n}  \n  \n[Export]  \npublic abstract class DataTwo  \n{  \n    //This part will not be discovered  \n    //by the catalog.  \n}  \n  \n[PartNotDiscoverable]  \n[Export]  \npublic class DataThree  \n{  \n    //This part will also not be discovered  \n    //by the catalog.  \n}  \n```  \n  \n<a name=\"metadata_and_metadata_views\"></a>   \n## Metadata and Metadata Views  \n Exports can provide additional information about themselves known as *metadata*. Metadata can be used to convey properties of the exported object to the importing part. The importing part can use this data to decide which exports to use, or to gather information about an export without having to construct it. For this reason, an import must be lazy to use metadata.  \n  \n To use metadata, you typically declare an interface known as a *metadata view*, which declares what metadata will be available. The metadata view interface must have only properties, and those properties must have `get` accessors. The following interface is an example metadata view.  \n  \n```vb  \nPublic Interface IPluginMetadata  \n  \n    ReadOnly Property Name As String  \n  \n    <DefaultValue(1)>  \n    ReadOnly Property Version As Integer  \n  \nEnd Interface  \n```  \n  \n```csharp  \npublic interface IPluginMetadata  \n{  \n    string Name { get; }  \n  \n    [DefaultValue(1)]    \n    int Version { get; }  \n}  \n```  \n  \n It is also possible to use a generic collection, `IDictionary<string, object>`, as a metadata view, but this forfeits the benefits of type checking and should be avoided.  \n  \n Ordinarily, all of the properties named in the metadata view are required, and any exports that do not provide them will not be considered a match. The `DefaultValue` attribute specifies that a property is optional. If the property is not included, it will be assigned the default value specified as a parameter of `DefaultValue`. The following are two different classes decorated with metadata. Both of these classes would match the previous metadata view.  \n  \n```vb  \n<Export(GetType(IPlugin))>  \n<ExportMetadata(\"Name\", \"Logger\")>  \n<ExportMetadata(\"Version\", 4)>  \nPublic Class MyLogger  \n    Implements IPlugin  \n  \nEnd Class  \n  \n'Version is not required because of the DefaultValue  \n<Export(GetType(IPlugin))>  \n<ExportMetadata(\"Name\", \"Disk Writer\")>  \nPublic Class DWriter  \n    Implements IPlugin  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export(typeof(IPlugin)),  \n    ExportMetadata(\"Name\", \"Logger\"),  \n    ExportMetadata(\"Version\", 4)]  \npublic class Logger : IPlugin  \n{  \n}  \n  \n[Export(typeof(IPlugin)),  \n    ExportMetadata(\"Name\", \"Disk Writer\")]   \n    //Version is not required because of the DefaultValue  \npublic class DWriter : IPlugin  \n{  \n}  \n```  \n  \n Metadata is expressed after the `Export` attribute by using the `ExportMetadata` attribute. Each piece of metadata is composed of a name/value pair. The name portion of the metadata must match the name of the appropriate property in the metadata view, and the value will be assigned to that property.  \n  \n It is the importer that specifies what metadata view, if any, will be in use. An import with metadata is declared as a lazy import, with the metadata interface as the second type parameter to `Lazy<T,T>`. The following class imports the previous part with metadata.  \n  \n```vb  \nPublic Class Addin  \n  \n    <Import()>  \n    Public Property plugin As Lazy(Of IPlugin, IPluginMetadata)  \nEnd Class  \n```  \n  \n```csharp  \npublic class Addin  \n{  \n    [Import]  \n    public Lazy<IPlugin, IPluginMetadata> plugin;  \n}  \n```  \n  \n In many cases, you will want to combine metadata with the `ImportMany` attribute, in order to parse through the available imports and choose and instantiate only one, or filter a collection to match a certain condition. The following class instantiates only `IPlugin` objects that have the `Name` value \"Logger\".  \n  \n```vb  \nPublic Class User  \n  \n    <ImportMany()>  \n    Public Property plugins As IEnumerable(Of Lazy(Of IPlugin, IPluginMetadata))  \n  \n    Public Function InstantiateLogger() As IPlugin  \n  \n        Dim logger As IPlugin  \n        logger = Nothing  \n  \n        For Each Plugin As Lazy(Of IPlugin, IPluginMetadata) In plugins  \n            If (Plugin.Metadata.Name = \"Logger\") Then  \n                logger = Plugin.Value  \n            End If  \n        Next  \n        Return logger  \n    End Function  \n  \nEnd Class  \n```  \n  \n```csharp  \npublic class User  \n{  \n    [ImportMany]  \n    public IEnumerable<Lazy<IPlugin, IPluginMetadata>> plugins;  \n  \n    public IPlugin InstantiateLogger ()  \n    {  \n        IPlugin logger = null;  \n  \n        foreach (Lazy<IPlugin, IPluginMetadata> plugin in plugins)  \n        {  \n            if (plugin.Metadata.Name = \"Logger\") logger = plugin.Value;  \n        }  \n        return logger;  \n    }  \n}  \n```  \n  \n<a name=\"import_and_export_inheritance\"></a>   \n## Import and Export Inheritance  \n If a class inherits from a part, that class may also become a part. Imports are always inherited by subclasses. Therefore, a subclass of a part will always be a part, with the same imports as its parent class.  \n  \n Exports declared by using the `Export` attribute are not inherited by subclasses. However, a part can export itself by using the `InheritedExport` attribute. Subclasses of the part will inherit and provide the same export, including contract name and contract type. Unlike an `Export` attribute, `InheritedExport` can be applied only at the class level, and not at the member level. Therefore, member-level exports can never be inherited.  \n  \n The following four classes demonstrate the principles of import and export inheritance. `NumTwo` inherits from `NumOne`, so `NumTwo` will import `IMyData`. Ordinary exports are not inherited, so `NumTwo` will not export anything. `NumFour` inherits from `NumThree`. Because `NumThree` used `InheritedExport`, `NumFour` has one export with contract type `NumThree`. Member-level exports are never inherited, so `IMyData` is not exported.  \n  \n```vb  \n<Export()>  \nPublic Class NumOne  \n    <Import()>  \n    Public Property MyData As IMyData  \nEnd Class  \n  \nPublic Class NumTwo  \n    Inherits NumOne  \n  \n    'Imports are always inherited, so NumTwo will  \n    'Import IMyData  \n  \n    'Ordinary exports are not inherited, so  \n    'NumTwo will NOT export anything.  As a result it  \n    'will not be discovered by the catalog!  \n  \nEnd Class  \n  \n<InheritedExport()>  \nPublic Class NumThree  \n  \n    <Export()>  \n    Public Property MyData As IMyData  \n  \n    'This part provides two exports, one of  \n    'contract type NumThree, and one of   \n    'contract type IMyData.  \n  \nEnd Class  \n  \nPublic Class NumFour  \n    Inherits NumThree  \n  \n    'Because NumThree used InheritedExport,  \n    'this part has one export with contract   \n    'type NumThree.  \n  \n    'Member-level exports are never inherited,  \n    'so IMyData is not exported.  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export]  \npublic class NumOne  \n{  \n    [Import]  \n    public IMyData MyData { get; set; }  \n}  \n  \npublic class NumTwo : NumOne  \n{  \n    //Imports are always inherited, so NumTwo will   \n    //import IMyData.  \n  \n    //Ordinary exports are not inherited, so   \n    //NumTwo will NOT export anything. As a result it   \n    //will not be discovered by the catalog!  \n}  \n  \n[InheritedExport]  \npublic class NumThree  \n{  \n    [Export]  \n    Public IMyData MyData { get; set; }  \n  \n    //This part provides two exports, one of  \n    //contract type NumThree, and one of  \n    //contract type IMyData.  \n}  \n  \npublic class NumFour : NumThree  \n{  \n    //Because NumThree used InheritedExport,  \n    //this part has one export with contract  \n    //type NumThree.  \n  \n    //Member-level exports are never inherited,  \n    //so IMyData is not exported.  \n}  \n```  \n  \n If there is metadata associated with an `InheritedExport` attribute, that metadata will also be inherited. (For more information, see the earlier \"Metadata and Metadata Views\" section.) Inherited metadata cannot be modified by the subclass. However, by re-declaring the `InheritedExport` attribute with the same contract name and contract type, but with new metadata, the subclass can replace the inherited metadata with new metadata. The following class demonstrates this principle. The `MegaLogger` part inherits from `Logger` and includes the `InheritedExport` attribute. Since `MegaLogger` re-declares new metadata named Status, it does not inherit the Name and Version metadata from `Logger`.  \n  \n```vb  \n<InheritedExport(GetType(IPlugin))>  \n<ExportMetadata(\"Name\", \"Logger\")>  \n<ExportMetadata(\"Version\", 4)>  \nPublic Class Logger  \n    Implements IPlugin  \n  \n    'Exports with contract type IPlugin  \n    'and metadata \"Name\" and \"Version\".  \nEnd Class  \n  \nPublic Class SuperLogger  \n    Inherits Logger  \n  \n    'Exports with contract type IPlugin and   \n    'metadata \"Name\" and \"Version\", exactly the same  \n    'as the Logger class.  \n  \nEnd Class  \n  \n<InheritedExport(GetType(IPlugin))>  \n<ExportMetadata(\"Status\", \"Green\")>  \nPublic Class MegaLogger  \n    Inherits Logger  \n  \n    'Exports with contract type IPlugin and   \n    'metadata \"Status\" only. Re-declaring   \n    'the attribute replaces all metadata.  \n  \nEnd Class  \n```  \n  \n```csharp  \n[InheritedExport(typeof(IPlugin)),  \n    ExportMetadata(\"Name\", \"Logger\"),  \n    ExportMetadata(\"Version\", 4)]  \npublic class Logger : IPlugin  \n{  \n    //Exports with contract type IPlugin and   \n    //metadata \"Name\" and \"Version\".  \n}  \n  \npublic class SuperLogger : Logger  \n{  \n    //Exports with contract type IPlugin and   \n    //metadata \"Name\" and \"Version\", exactly the same  \n    //as the Logger class.  \n}  \n  \n[InheritedExport(typeof(IPlugin)),  \n    ExportMetadata(\"Status\", \"Green\")]  \npublic class MegaLogger : Logger        {  \n    //Exports with contract type IPlugin and   \n    //metadata \"Status\" only. Re-declaring   \n    //the attribute replaces all metadata.  \n}  \n```  \n  \n When re-declaring the `InheritedExport` attribute to override metadata, make sure that the contract types are the same. (In the previous example, `IPlugin` is the contract type.) If they differ, instead of overriding, the second attribute will create a second, independent export from the part. Generally, this means that you will have to explicitly specify the contract type when you override an `InheritedExport` attribute, as shown in the previous example.  \n  \n Since interfaces cannot be instantiated directly, they generally cannot be decorated with `Export` or `Import` attributes. However, an interface can be decorated with an `InheritedExport` attribute at the interface level, and that export along with any associated metadata will be inherited by any implementing classes. The interface itself will not be available as a part, however.  \n  \n<a name=\"custom_export_attributes\"></a>   \n## Custom Export Attributes  \n The basic export attributes, `Export` and `InheritedExport`, can be extended to include metadata as attribute properties. This technique is useful for applying similar metadata to many parts, or creating an inheritance tree of metadata attributes.  \n  \n A custom attribute can specify the contract type, the contract name, or any other metadata. In order to define a custom attribute, a class inheriting from `ExportAttribute` (or `InheritedExportAttribute`) must be decorated with the `MetadataAttribute` attribute. The following class defines a custom attribute.  \n  \n```vb  \n<MetadataAttribute()>  \n<AttributeUsage(AttributeTargets.Class, AllowMultiple:=false)>  \nPublic Class MyAttribute  \n    Inherits ExportAttribute  \n  \n    Public Property MyMetadata As String  \n  \n    Public Sub New(ByVal myMetadata As String)  \n        MyBase.New(GetType(IMyAddin))  \n  \n        myMetadata = myMetadata  \n    End Sub  \n  \nEnd Class  \n```  \n  \n```csharp  \n[MetadataAttribute]  \n[AttributeUsage(AttributeTargets.Class, AllowMultiple=false)]  \npublic class MyAttribute : ExportAttribute  \n{  \n    public MyAttribute(string myMetadata)   \n        : base(typeof(IMyAddin))  \n    {  \n        MyMetadata = myMetadata;  \n    }  \n  \n    public string MyMetadata { get; private set; }  \n}  \n```  \n  \n This class defines a custom attribute named `MyAttribute` with contract type `IMyData` and some metadata named `MyMetadata`. All properties in a class marked with the `MetadataAttribute` attribute are considered to be metadata defined in the custom attribute. The following two declarations are equivalent.  \n  \n```vb  \n<Export(GetType(IMyAddin))>  \n<ExportMetadata(\"MyMetadata\", \"theData\")>  \nPublic Property myAddin As MyAddin  \n  \n<MyAttribute(\"theData\")>  \nPublic Property myAddin As MyAddin  \n```  \n  \n```csharp  \n[Export(typeof(IMyAddin)),   \n    ExportMetadata(\"MyMetadata\", \"theData\")]  \npublic MyAddin myAddin { get; set; }  \n```  \n  \n```  \n[MyAttribute(\"theData\")]  \npublic MyAddin myAddin { get; set; }  \n```  \n  \n In the first declaration, the contract type and metadata are explicitly defined. In the second declaration, the contract type and metadata are implicit in the customized attribute. Particularly in cases where a large amount of identical metadata must be applied to many parts (for example, author or copyright information), using a custom attribute can save a lot of time and duplication. Further, inheritance trees of custom attributes can be created to allow for variations.  \n  \n To create optional metadata in a custom attribute, you can use the `DefaultValue` attribute. When this attribute is applied to a property in a custom attribute class, it specifies that the decorated property is optional and does not have to be supplied by an exporter. If a value for the property is not supplied, it will be assigned the default value for its property type (usually `null`, `false`, or 0.)  \n  \n<a name=\"creation_policies\"></a>   \n## Creation Policies  \n When a part specifies an import and composition is performed, the composition container attempts to find a matching export. If it matches the import with an export successfully, the importing member is set to an instance of the exported object. Where this instance comes from is controlled by the exporting part's *creation policy*.  \n  \n The two possible creation policies are *shared* and *non-shared*. A part with a creation policy of shared will be shared between every import in the container for a part with that contract. When the composition engine finds a match and has to set an importing property, it will instantiate a new copy of the part only if one does not already exist; otherwise, it will supply the existing copy. This means that many objects may have references to the same part. Such parts should not rely on internal state that might be changed from many places. This policy is appropriate for static parts, parts that provide services, and parts that consume a lot of memory or other resources.  \n  \n A part with the creation policy of non-shared will be created every time a matching import for one of its exports is found. A new copy will therefore be instantiated for every import in the container that matches one of the part's exported contracts. The internal state of these copies will not be shared. This policy is appropriate for parts where each import requires its own internal state.  \n  \n Both the import and the export can specify the creation policy of a part, from among the values `Shared`, `NonShared`, or `Any`. The default is `Any` for both imports and exports. An export that specifies `Shared` or `NonShared` will only match an import that specifies the same, or that specifies `Any`. Similarly, an import that specifies `Shared` or `NonShared` will only match an export that specifies the same, or that specifies `Any`. Imports and exports with incompatible creation policies are not considered a match, in the same way as an import and export whose contract name or contract type are not a match. If both import and export specify `Any`, or do not specify a creation policy and default to `Any`, the creation policy will default to shared.  \n  \n The following example shows both imports and exports specifying creation policies. `PartOne` does not specify a creation policy, so the default is `Any`. `PartTwo` does not specify a creation policy, so the default is `Any`. Since both import and export default to `Any`, `PartOne` will be shared. `PartThree` specifies a `Shared` creation policy, so `PartTwo` and `PartThree` will share the same copy of `PartOne`. `PartFour` specifies a `NonShared` creation policy, so `PartFour` will be non-shared in `PartFive`. `PartSix` specifies a `NonShared` creation policy. `PartFive` and `PartSix` will each receive separate copies of `PartFour`. `PartSeven` specifies a `Shared` creation policy. Because there is no exported `PartFour` with a creation policy of `Shared`, the `PartSeven` import does not match anything and will not be filled.  \n  \n```vb  \n<Export()>  \nPublic Class PartOne  \n    'The default creation policy for an export is Any.  \nEnd Class  \n  \nPublic Class PartTwo  \n  \n    <Import()>  \n    Public Property partOne As PartOne  \n  \n    'The default creation policy for an import is Any.  \n    'If both policies are Any, the part will be shared.  \n  \nEnd Class  \n  \nPublic Class PartThree  \n  \n    <Import(RequiredCreationPolicy:=CreationPolicy.Shared)>  \n    Public Property partOne As PartOne  \n  \n    'The Shared creation policy is explicitly specified.  \n    'PartTwo and PartThree will receive references to the  \n    'SAME copy of PartOne.  \n  \nEnd Class  \n  \n<Export()>  \n<PartCreationPolicy(CreationPolicy.NonShared)>  \nPublic Class PartFour  \n    'The NonShared creation policy is explicitly specified.  \nEnd Class  \n  \nPublic Class PartFive  \n  \n    <Import()>  \n    Public Property partFour As PartFour  \n  \n    'The default creation policy for an import is Any.  \n    'Since the export's creation policy was explictly  \n    'defined, the creation policy for this property will  \n    'be non-shared.  \n  \nEnd Class  \n  \nPublic Class PartSix  \n  \n    <Import(RequiredCreationPolicy:=CreationPolicy.NonShared)>  \n    Public Property partFour As PartFour  \n  \n    'Both import and export specify matching creation   \n    'policies.  PartFive and PartSix will each receive   \n    'SEPARATE copies of PartFour, each with its own  \n    'internal state.  \n  \nEnd Class  \n  \nPublic Class PartSeven  \n  \n    <Import(RequiredCreationPolicy:=CreationPolicy.Shared)>  \n    Public Property partFour As PartFour  \n  \n    'A creation policy mismatch.  Because there is no   \n    'exported PartFour with a creation policy of Shared,  \n    'this import does not match anything and will not be  \n    'filled.  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export]  \npublic class PartOne  \n{  \n    //The default creation policy for an export is Any.  \n}  \n  \npublic class PartTwo  \n{  \n    [Import]  \n    public PartOne partOne { get; set; }  \n  \n    //The default creation policy for an import is Any.  \n    //If both policies are Any, the part will be shared.  \n}  \n  \npublic class PartThree  \n{  \n    [Import(RequiredCreationPolicy = CreationPolicy.Shared)]  \n    public PartOne partOne { get; set; }  \n  \n    //The Shared creation policy is explicitly specified.  \n    //PartTwo and PartThree will receive references to the  \n    //SAME copy of PartOne.  \n}  \n  \n[Export]  \n[PartCreationPolicy(CreationPolicy.NonShared)]  \npublic class PartFour  \n{  \n    //The NonShared creation policy is explicitly specified.  \n}  \n  \npublic class PartFive  \n{  \n    [Import]  \n    public PartFour partFour { get; set; }  \n  \n    //The default creation policy for an import is Any.  \n    //Since the export's creation policy was explictly  \n    //defined, the creation policy for this property will  \n    //be non-shared.  \n}  \n  \npublic class PartSix  \n{  \n    [Import(RequiredCreationPolicy = CreationPolicy.NonShared)]  \n    public PartFour partFour { get; set; }  \n  \n    //Both import and export specify matching creation   \n    //policies.  PartFive and PartSix will each receive   \n    //SEPARATE copies of PartFour, each with its own  \n    //internal state.  \n}  \n  \npublic class PartSeven  \n{  \n    [Import(RequiredCreationPolicy = CreationPolicy.Shared)]  \n    public PartFour partFour { get; set; }  \n  \n    //A creation policy mismatch.  Because there is no   \n    //exported PartFour with a creation policy of Shared,  \n    //this import does not match anything and will not be  \n    //filled.  \n}  \n```  \n  \n<a name=\"life_cycle_and_disposing\"></a>   \n## Life Cycle and Disposing  \n Because parts are hosted in the composition container, their life cycle can be more complex than ordinary objects. Parts can implement two important life cycle-related interfaces: `IDisposable` and `IPartImportsSatisfiedNotification`.  \n  \n Parts that require work to be performed at shut down or that need to release resources should implement `IDisposable`, as usual for .NET Framework objects. However, since the container creates and maintains references to parts, only the container that owns a part should call the `Dispose` method on it. The container itself implements `IDisposable`, and as portion of its cleanup in `Dispose` it will call `Dispose` on all the parts that it owns. For this reason, you should always dispose the composition container when it and any parts it owns are no longer needed.  \n  \n For long-lived composition containers, memory consumption by parts with a creation policy of non-shared can become a problem. These non-shared parts can be created multiple times and will not be disposed until the container itself is disposed. To deal with this, the container provides the `ReleaseExport` method. Calling this method on a non-shared export removes that export from the composition container and disposes it. Parts that are used only by the removed export, and so on down the tree, are also removed and disposed. In this way, resources can be reclaimed without disposing the composition container itself.  \n  \n `IPartImportsSatisfiedNotification` contains one method named `OnImportsSatisfied`. This method is called by the composition container on any parts that implement the interface when composition has been completed and the part's imports are ready for use. Parts are created by the composition engine to fill the imports of other parts. Before the imports of a part have been set, you cannot perform any initialization that relies on or manipulates imported values in the part constructor unless those values have been specified as prerequisites by using the `ImportingConstructor` attribute. This is normally the preferred method, but in some cases, constructor injection may not be available. In those cases, initialization can be performed in `OnImportsSatisfied`, and the part should implement `IPartImportsSatisfiedNotification`.  \n  \n## See Also  \n [Channel 9 Video: Open Up Your Applications with the Managed Extensibility Framework](http://channel9.msdn.com/events/TechEd/NorthAmerica/2009/DTL328)   \n [Channel 9 Video: Mnaaged Extensibility Framework (MEF) 2.0](http://channel9.msdn.com/posts/NET-45-Oleg-Lvovitch-and-Kevin-Ransom-Managed-Extensibility-Framework-MEF-20)","nodes":[{"pos":[4,472],"nodes":[{"content":"Attributed Programming Model Overview (MEF) | Microsoft Docs","nodes":[{"pos":[0,60],"content":"Attributed Programming Model Overview (MEF) | Microsoft Docs","nodes":[{"content":"Attributed Programming Model Overview (MEF) | Microsoft Docs","pos":[0,60]}]}],"pos":[6,69],"yaml":true}],"content":"title: \"Attributed Programming Model Overview (MEF) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"MEF, attributed programming model\"\n  - \"attributed programming model [MEF]\"\nms.assetid: 49b787ff-2741-4836-ad51-c3017dc592d4\ncaps.latest.revision: 24\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","yamlblock":true},{"pos":[479,522],"content":"Attributed Programming Model Overview (MEF)","linkify":"Attributed Programming Model Overview (MEF)","nodes":[{"content":"Attributed Programming Model Overview (MEF)","pos":[0,43]}]},{"content":"In the Managed Extensibility Framework (MEF), a <bpt id=\"p1\">*</bpt>programming model<ept id=\"p1\">*</ept> is a particular method of defining the set of conceptual objects on which MEF operates.","pos":[523,678],"source":"In the Managed Extensibility Framework (MEF), a *programming model* is a particular method of defining the set of conceptual objects on which MEF operates."},{"content":"These conceptual objects include parts, imports, and exports.","pos":[679,740]},{"content":"MEF uses these objects, but does not specify how they should be represented.","pos":[741,817]},{"content":"Therefore, a wide variety of programming models are possible, including customized programming models.","pos":[818,920]},{"content":"The default programming model used in MEF is the <bpt id=\"p1\">*</bpt>attributed programming model<ept id=\"p1\">*</ept>.","pos":[927,1007],"source":"The default programming model used in MEF is the *attributed programming model*."},{"content":"In the attributed programming model parts, imports, exports, and other objects are defined with attributes that decorate ordinary .NET Framework classes.","pos":[1008,1161]},{"content":"This topic explains how to use the attributes provided by the attributed programming model to create a MEF application.","pos":[1162,1281]},{"pos":[1333,1357],"content":"Import and Export Basics","linkify":"Import and Export Basics","nodes":[{"content":"Import and Export Basics","pos":[0,24]}]},{"content":"An <bpt id=\"p1\">*</bpt>export<ept id=\"p1\">*</ept> is a value that a part provides to other parts in the container, and an <bpt id=\"p2\">*</bpt>import<ept id=\"p2\">*</ept> is a requirement that a part expresses to the container, to be filled from the available exports.","pos":[1361,1551],"source":"An *export* is a value that a part provides to other parts in the container, and an *import* is a requirement that a part expresses to the container, to be filled from the available exports."},{"content":"In the attributed programming model, imports and exports are declared by decorating classes or members with the <ph id=\"ph1\">`Import`</ph> and <ph id=\"ph2\">`Export`</ph> attributes.","pos":[1552,1697],"source":" In the attributed programming model, imports and exports are declared by decorating classes or members with the `Import` and `Export` attributes."},{"content":"The <ph id=\"ph1\">`Export`</ph> attribute can decorate a class, field, property, or method, while the <ph id=\"ph2\">`Import`</ph> attribute can decorate a field, property, or constructor parameter.","pos":[1698,1857],"source":" The `Export` attribute can decorate a class, field, property, or method, while the `Import` attribute can decorate a field, property, or constructor parameter."},{"content":"In order for an import to be matched with an export, the import and export must have the same <bpt id=\"p1\">*</bpt>contract<ept id=\"p1\">*</ept>.","pos":[1864,1969],"source":"In order for an import to be matched with an export, the import and export must have the same *contract*."},{"content":"The contract consists of a string, called the <bpt id=\"p1\">*</bpt>contract name<ept id=\"p1\">*</ept>, and the type of the exported or imported object, called the <bpt id=\"p2\">*</bpt>contract type<ept id=\"p2\">*</ept>.","pos":[1970,2109],"source":" The contract consists of a string, called the *contract name*, and the type of the exported or imported object, called the *contract type*."},{"content":"Only if both the contract name and contract type match is an export considered to fulfill a particular import.","pos":[2110,2220]},{"content":"Either or both of the contract parameters can be implicit or explicit.","pos":[2227,2297]},{"content":"The following code shows a class that declares a basic import.","pos":[2298,2360]},{"content":"In this import, the <ph id=\"ph1\">`Import`</ph> attribute has neither a contract type nor a contract name parameter attached.","pos":[2590,2696],"source":"In this import, the `Import` attribute has neither a contract type nor a contract name parameter attached."},{"content":"Therefore, both will be inferred from the decorated property.","pos":[2697,2758]},{"content":"In this case, the contract type will be <ph id=\"ph1\">`IMyAddin`</ph>, and the contract name will be a unique string created from the contract type.","pos":[2759,2888],"source":" In this case, the contract type will be `IMyAddin`, and the contract name will be a unique string created from the contract type."},{"content":"(In other words, the contract name will match only exports whose names are also inferred from the type <ph id=\"ph1\">`IMyAddin`</ph>.)","pos":[2889,3004],"source":" (In other words, the contract name will match only exports whose names are also inferred from the type `IMyAddin`.)"},{"content":"The following shows an export that matches the previous import.","pos":[3011,3074]},{"content":"In this export, the contract type is <ph id=\"ph1\">`IMyAddin`</ph> because it is specified as a parameter of the <ph id=\"ph2\">`Export`</ph> attribute.","pos":[3282,3395],"source":"In this export, the contract type is `IMyAddin` because it is specified as a parameter of the `Export` attribute."},{"content":"The exported type must be either the same as the contract type, derive from the contract type, or implement the contract type if it is an interface.","pos":[3396,3544]},{"content":"In this export, the actual type <ph id=\"ph1\">`MyLogger`</ph> implements the interface <ph id=\"ph2\">`IMyAddin`</ph>.","pos":[3545,3624],"source":" In this export, the actual type `MyLogger` implements the interface `IMyAddin`."},{"content":"The contract name is inferred from the contract type, which means that this export will match the previous import.","pos":[3625,3739]},{"pos":[3747,4010],"content":"[!NOTE]\n Exports and imports should usually be declared on public classes or members. Other declarations are supported, but exporting or importing a private, protected, or internal member breaks the isolation model for the part and is therefore not recommended.","leadings":["","> "],"nodes":[{"content":"Exports and imports should usually be declared on public classes or members. Other declarations are supported, but exporting or importing a private, protected, or internal member breaks the isolation model for the part and is therefore not recommended.","pos":[9,261],"nodes":[{"content":"Exports and imports should usually be declared on public classes or members.","pos":[0,76]},{"content":"Other declarations are supported, but exporting or importing a private, protected, or internal member breaks the isolation model for the part and is therefore not recommended.","pos":[77,252]}]}]},{"content":"The contract type must match exactly for the export and import to be considered a match.","pos":[4017,4105]},{"content":"Consider the following export.","pos":[4106,4136]},{"content":"In this export, the contract type is <ph id=\"ph1\">`MyLogger`</ph> instead of <ph id=\"ph2\">`IMyAddin`</ph>.","pos":[4384,4454],"source":"In this export, the contract type is `MyLogger` instead of `IMyAddin`."},{"content":"Even though <ph id=\"ph1\">`MyLogger`</ph> implements <ph id=\"ph2\">`IMyAddin`</ph>, and therefore could be cast to an <ph id=\"ph3\">`IMyAddin`</ph> object, this export will not match the previous import because the contract types are not the same.","pos":[4455,4645],"source":" Even though `MyLogger` implements `IMyAddin`, and therefore could be cast to an `IMyAddin` object, this export will not match the previous import because the contract types are not the same."},{"content":"In general, it is not necessary to specify the contract name, and most contracts should be defined in terms of the contract type and metadata.","pos":[4652,4794]},{"content":"However, under certain circumstances, it is important to specify the contract name directly.","pos":[4795,4887]},{"content":"The most common case is when a class exports several values that share a common type, such as primitives.","pos":[4888,4993]},{"content":"The contract name can be specified as the first parameter of the <ph id=\"ph1\">`Import`</ph> or <ph id=\"ph2\">`Export`</ph> attribute.","pos":[4994,5090],"source":" The contract name can be specified as the first parameter of the `Import` or `Export` attribute."},{"content":"The following code shows an import and an export with a specified contract name of <ph id=\"ph1\">`MajorRevision`</ph>.","pos":[5091,5190],"source":" The following code shows an import and an export with a specified contract name of `MajorRevision`."},{"content":"If the contract type is not specified, it will still be inferred from the type of the import or export.","pos":[5946,6049]},{"content":"However, even if the contract name is specified explicitly, the contract type must also match exactly for the import and export to be considered a match.","pos":[6050,6203]},{"content":"For example, if the <ph id=\"ph1\">`MajorRevision`</ph> field was a string, the inferred contract types would not match and the export would not match the import, despite having the same contract name.","pos":[6204,6385],"source":" For example, if the `MajorRevision` field was a string, the inferred contract types would not match and the export would not match the import, despite having the same contract name."},{"pos":[6395,6427],"content":"Importing and Exporting a Method","linkify":"Importing and Exporting a Method","nodes":[{"content":"Importing and Exporting a Method","pos":[0,32]}]},{"content":"The <ph id=\"ph1\">`Export`</ph> attribute can also decorate a method, in the same way as a class, property, or function.","pos":[6431,6532],"source":"The `Export` attribute can also decorate a method, in the same way as a class, property, or function."},{"content":"Method exports must specify a contract type or contract name, as the type cannot be inferred.","pos":[6533,6626]},{"content":"The specified type can be either a custom delegate or a generic type, such as <ph id=\"ph1\">`Func`</ph>.","pos":[6627,6712],"source":" The specified type can be either a custom delegate or a generic type, such as `Func`."},{"content":"The following class exports a method named <ph id=\"ph1\">`DoSomething`</ph>.","pos":[6713,6770],"source":" The following class exports a method named `DoSomething`."},{"content":"In this class, the <ph id=\"ph1\">`DoSomething`</ph> method takes a single <ph id=\"ph2\">`int`</ph> parameter and returns a <ph id=\"ph3\">`string`</ph>.","pos":[7255,7349],"source":"In this class, the `DoSomething` method takes a single `int` parameter and returns a `string`."},{"content":"To match this export, the importing part must declare an appropriate member.","pos":[7350,7426]},{"content":"The following class imports the <ph id=\"ph1\">`DoSomething`</ph> method.","pos":[7427,7480],"source":" The following class imports the `DoSomething` method."},{"pos":[7809,7902],"content":"For more information about how to use of the <ph id=\"ph1\">`Func&lt;T, T&gt;`</ph> object, see <ph id=\"ph2\">&lt;xref:System.Func%602&gt;</ph>.","source":"For more information about how to use of the `Func<T, T>` object, see <xref:System.Func%602>."},{"pos":[7946,7962],"content":"Types of Imports","linkify":"Types of Imports","nodes":[{"content":"Types of Imports","pos":[0,16]}]},{"content":"MEF support several import types, including dynamic, lazy, prerequisite, and optional.","pos":[7966,8052]},{"pos":[8062,8077],"content":"Dynamic Imports","linkify":"Dynamic Imports","nodes":[{"content":"Dynamic Imports","pos":[0,15]}]},{"content":"In some cases, the importing class may want to match exports of any type that have a particular contract name.","pos":[8081,8191]},{"content":"In this scenario, the class can declare a <bpt id=\"p1\">*</bpt>dynamic import<ept id=\"p1\">*</ept>.","pos":[8192,8251],"source":" In this scenario, the class can declare a *dynamic import*."},{"content":"The following import matches any export with contract name \"TheString\".","pos":[8252,8323]},{"content":"When the contract type is inferred from the <ph id=\"ph1\">`dynamic`</ph> keyword, it will match any contract type.","pos":[8570,8665],"source":"When the contract type is inferred from the `dynamic` keyword, it will match any contract type."},{"content":"In this case, an import should <bpt id=\"p1\">**</bpt>always<ept id=\"p1\">**</ept> specify a contract name to match on.","pos":[8666,8744],"source":" In this case, an import should **always** specify a contract name to match on."},{"content":"(If no contract name is specified, the import will be considered to match no exports.) Both of the following exports would match the previous import.","pos":[8745,8894]},{"content":"Obviously, the importing class must be prepared to deal with an object of arbitrary type.","pos":[9251,9340]},{"pos":[9350,9362],"content":"Lazy Imports","linkify":"Lazy Imports","nodes":[{"content":"Lazy Imports","pos":[0,12]}]},{"content":"In some cases, the importing class may require an indirect reference to the imported object, so that the object is not instantiated immediately.","pos":[9366,9510]},{"content":"In this scenario, the class can declare a <bpt id=\"p1\">*</bpt>lazy import<ept id=\"p1\">*</ept> by using a contract type of <ph id=\"ph1\">`Lazy&lt;T&gt;`</ph>.","pos":[9511,9605],"source":" In this scenario, the class can declare a *lazy import* by using a contract type of `Lazy<T>`."},{"content":"The following importing property declares a lazy import.","pos":[9606,9662]},{"content":"From the point of view of the composition engine, a contract type of <ph id=\"ph1\">`Lazy&lt;T&gt;`</ph> is considered identical to contract type of <ph id=\"ph2\">`T`</ph>.","pos":[9913,10040],"source":"From the point of view of the composition engine, a contract type of `Lazy<T>` is considered identical to contract type of `T`."},{"content":"Therefore, the previous import would match the following export.","pos":[10041,10105]},{"pos":[10313,10475],"content":"The contract name and contract type can be specified in the <ph id=\"ph1\">`Import`</ph> attribute for a lazy import, as described earlier in the \"Basic Imports and Exports\" section.","source":"The contract name and contract type can be specified in the `Import` attribute for a lazy import, as described earlier in the \"Basic Imports and Exports\" section."},{"pos":[10485,10505],"content":"Prerequisite Imports","linkify":"Prerequisite Imports","nodes":[{"content":"Prerequisite Imports","pos":[0,20]}]},{"content":"Exported MEF parts are typically created by the composition engine, in response to a direct request or the need to fill a matched import.","pos":[10509,10646]},{"content":"By default, when creating a part, the composition engine uses the parameter-less constructor.","pos":[10647,10740]},{"content":"To make the engine use a different constructor, you can mark it with the <ph id=\"ph1\">`ImportingConstructor`</ph> attribute.","pos":[10741,10847],"source":" To make the engine use a different constructor, you can mark it with the `ImportingConstructor` attribute."},{"content":"Each part may have only one constructor for use by the composition engine.","pos":[10854,10928]},{"content":"Providing no default constructor and no <ph id=\"ph1\">`ImportingConstructor`</ph> attribute, or providing more than one <ph id=\"ph2\">`ImportingConstructor`</ph> attribute, will produce an error.","pos":[10929,11086],"source":" Providing no default constructor and no `ImportingConstructor` attribute, or providing more than one `ImportingConstructor` attribute, will produce an error."},{"content":"To fill the parameters of a constructor marked with the <ph id=\"ph1\">`ImportingConstructor`</ph> attribute, all of those parameters are automatically declared as imports.","pos":[11093,11245],"source":"To fill the parameters of a constructor marked with the `ImportingConstructor` attribute, all of those parameters are automatically declared as imports."},{"content":"This is a convenient way to declare imports that are used during part initialization.","pos":[11246,11331]},{"content":"The following class uses <ph id=\"ph1\">`ImportingConstructor`</ph> to declare an import.","pos":[11332,11401],"source":" The following class uses `ImportingConstructor` to declare an import."},{"content":"By default, the <ph id=\"ph1\">`ImportingConstructor`</ph> attribute uses inferred contract types and contract names for all of the parameter imports.","pos":[12376,12506],"source":"By default, the `ImportingConstructor` attribute uses inferred contract types and contract names for all of the parameter imports."},{"content":"It is possible to override this by decorating the parameters with <ph id=\"ph1\">`Import`</ph> attributes, which can then define the contract type and contract name explicitly.","pos":[12507,12663],"source":" It is possible to override this by decorating the parameters with `Import` attributes, which can then define the contract type and contract name explicitly."},{"content":"The following code demonstrates a constructor that uses this syntax to import a derived class instead of a parent class.","pos":[12664,12784]},{"content":"In particular, you should be careful with collection parameters.","pos":[13070,13134]},{"content":"For example, if you specify <ph id=\"ph1\">`ImportingConstructor`</ph> on a constructor with a parameter of type <ph id=\"ph2\">`IEnumerable&lt;int&gt;`</ph>, the import will match a single export of type <ph id=\"ph3\">`IEnumerable&lt;int&gt;`</ph>, instead of a set of exports of type <ph id=\"ph4\">`int`</ph>.","pos":[13135,13356],"source":" For example, if you specify `ImportingConstructor` on a constructor with a parameter of type `IEnumerable<int>`, the import will match a single export of type `IEnumerable<int>`, instead of a set of exports of type `int`."},{"content":"To match a set of exports of type <ph id=\"ph1\">`int`</ph>, you have to decorate the parameter with the <ph id=\"ph2\">`ImportMany`</ph> attribute.","pos":[13357,13465],"source":" To match a set of exports of type `int`, you have to decorate the parameter with the `ImportMany` attribute."},{"content":"Parameters declared as imports by the <ph id=\"ph1\">`ImportingConstructor`</ph> attribute are also marked as <bpt id=\"p1\">*</bpt>prerequisite imports<ept id=\"p1\">*</ept>.","pos":[13472,13585],"source":"Parameters declared as imports by the `ImportingConstructor` attribute are also marked as *prerequisite imports*."},{"content":"MEF normally allows exports and imports to form a <bpt id=\"p1\">*</bpt>cycle<ept id=\"p1\">*</ept>.","pos":[13586,13644],"source":" MEF normally allows exports and imports to form a *cycle*."},{"content":"For example, a cycle is where object A imports object B, which in turn imports object A. Under ordinary circumstances, a cycle is not a problem, and the composition container constructs both objects normally.","pos":[13645,13853]},{"content":"When an imported value is required by the constructor of a part, that object cannot participate in a cycle.","pos":[13860,13967]},{"content":"If object A requires that object B be constructed before it can be constructed itself, and object B imports object A, then the cycle will be unable to resolve and a composition error will occur.","pos":[13968,14162]},{"content":"Imports declared on constructor parameters are therefore prerequisite imports, which must all be filled before any of the exports from the object that requires them can be used.","pos":[14163,14340]},{"pos":[14350,14366],"content":"Optional Imports","linkify":"Optional Imports","nodes":[{"content":"Optional Imports","pos":[0,16]}]},{"content":"The <ph id=\"ph1\">`Import`</ph> attribute specifies a requirement for the part to function.","pos":[14370,14442],"source":"The `Import` attribute specifies a requirement for the part to function."},{"content":"If an import cannot be fulfilled, the composition of that part will fail and the part will not be available.","pos":[14443,14551]},{"content":"You can specify that an import is <bpt id=\"p1\">*</bpt>optional<ept id=\"p1\">*</ept> by using the <ph id=\"ph1\">`AllowDefault`</ph> property.","pos":[14558,14640],"source":"You can specify that an import is *optional* by using the `AllowDefault` property."},{"content":"In this case, the composition will succeed even if the import does not match any available exports, and the importing property will be set to the default for its property type (<ph id=\"ph1\">`null`</ph> for object properties, <ph id=\"ph2\">`false`</ph> for Booleans, or zero for numeric properties.) The following class uses an optional import.","pos":[14641,14947],"source":" In this case, the composition will succeed even if the import does not match any available exports, and the importing property will be set to the default for its property type (`null` for object properties, `false` for Booleans, or zero for numeric properties.) The following class uses an optional import."},{"pos":[15392,15418],"content":"Importing Multiple Objects","linkify":"Importing Multiple Objects","nodes":[{"content":"Importing Multiple Objects","pos":[0,26]}]},{"content":"The <ph id=\"ph1\">`Import`</ph> attribute will only be successfully composed when it matches one and only one export.","pos":[15422,15520],"source":"The `Import` attribute will only be successfully composed when it matches one and only one export."},{"content":"Other cases will produce a composition error.","pos":[15521,15566]},{"content":"To import more than one export that matches the same contract, use the <ph id=\"ph1\">`ImportMany`</ph> attribute.","pos":[15567,15661],"source":" To import more than one export that matches the same contract, use the `ImportMany` attribute."},{"content":"Imports marked with this attribute are always optional.","pos":[15662,15717]},{"content":"For example, composition will not fail if no matching exports are present.","pos":[15718,15792]},{"content":"The following class imports any number of exports of type <ph id=\"ph1\">`IMyAddin`</ph>.","pos":[15793,15862],"source":" The following class imports any number of exports of type `IMyAddin`."},{"content":"The imported array can be accessed by using ordinary <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> syntax and methods.","pos":[16135,16224],"source":"The imported array can be accessed by using ordinary `IEnumerable<T>` syntax and methods."},{"content":"It is also possible to use an ordinary array (<ph id=\"ph1\">`IMyAddin[]`</ph>) instead.","pos":[16225,16293],"source":" It is also possible to use an ordinary array (`IMyAddin[]`) instead."},{"content":"This pattern can be very important when you use it in combination with the <ph id=\"ph1\">`Lazy&lt;T&gt;`</ph> syntax.","pos":[16300,16392],"source":"This pattern can be very important when you use it in combination with the `Lazy<T>` syntax."},{"content":"For example, by using <ph id=\"ph1\">`ImportMany`</ph>, <ph id=\"ph2\">`IEnumerable&lt;T&gt;`</ph>, and <ph id=\"ph3\">`Lazy&lt;T&gt;`</ph>, you can import indirect references to any number of objects and only instantiate the ones that become necessary.","pos":[16393,16574],"source":" For example, by using `ImportMany`, `IEnumerable<T>`, and `Lazy<T>`, you can import indirect references to any number of objects and only instantiate the ones that become necessary."},{"content":"The following class shows this pattern.","pos":[16575,16614]},{"pos":[16941,16959],"content":"Avoiding Discovery","linkify":"Avoiding Discovery","nodes":[{"content":"Avoiding Discovery","pos":[0,18]}]},{"content":"In some cases, you may want to prevent a part from being discovered as part of a catalog.","pos":[16963,17052]},{"content":"For example, the part may be a base class intended to be inherited from, but not used.","pos":[17053,17139]},{"content":"There are two ways to accomplish this.","pos":[17140,17178]},{"content":"First, you can use the <ph id=\"ph1\">`abstract`</ph> keyword on the part class.","pos":[17179,17239],"source":" First, you can use the `abstract` keyword on the part class."},{"content":"Abstract classes never provide exports, although they can provide inherited exports to classes that derive from them.","pos":[17240,17357]},{"content":"If the class cannot be made abstract, you can decorate it with the <ph id=\"ph1\">`PartNotDiscoverable`</ph> attribute.","pos":[17364,17463],"source":"If the class cannot be made abstract, you can decorate it with the `PartNotDiscoverable` attribute."},{"content":"A part decorated with this attribute will not be included in any catalogs.","pos":[17464,17538]},{"content":"The following example demonstrates these patterns.","pos":[17539,17589]},{"content":"<ph id=\"ph1\">`DataOne`</ph> will be discovered by the catalog.","pos":[17590,17634],"source":"`DataOne` will be discovered by the catalog."},{"content":"Since <ph id=\"ph1\">`DataTwo`</ph> is abstract, it will not be discovered.","pos":[17635,17690],"source":" Since `DataTwo` is abstract, it will not be discovered."},{"content":"Since <ph id=\"ph1\">`DataThree`</ph> used the <ph id=\"ph2\">`PartNotDiscoverable`</ph> attribute, it will not be discovered.","pos":[17691,17777],"source":" Since `DataThree` used the `PartNotDiscoverable` attribute, it will not be discovered."},{"pos":[18634,18661],"content":"Metadata and Metadata Views","linkify":"Metadata and Metadata Views","nodes":[{"content":"Metadata and Metadata Views","pos":[0,27]}]},{"content":"Exports can provide additional information about themselves known as <bpt id=\"p1\">*</bpt>metadata<ept id=\"p1\">*</ept>.","pos":[18665,18745],"source":"Exports can provide additional information about themselves known as *metadata*."},{"content":"Metadata can be used to convey properties of the exported object to the importing part.","pos":[18746,18833]},{"content":"The importing part can use this data to decide which exports to use, or to gather information about an export without having to construct it.","pos":[18834,18975]},{"content":"For this reason, an import must be lazy to use metadata.","pos":[18976,19032]},{"content":"To use metadata, you typically declare an interface known as a <bpt id=\"p1\">*</bpt>metadata view<ept id=\"p1\">*</ept>, which declares what metadata will be available.","pos":[19039,19166],"source":"To use metadata, you typically declare an interface known as a *metadata view*, which declares what metadata will be available."},{"content":"The metadata view interface must have only properties, and those properties must have <ph id=\"ph1\">`get`</ph> accessors.","pos":[19167,19269],"source":" The metadata view interface must have only properties, and those properties must have `get` accessors."},{"content":"The following interface is an example metadata view.","pos":[19270,19322]},{"pos":[19659,19829],"content":"It is also possible to use a generic collection, <ph id=\"ph1\">`IDictionary&lt;string, object&gt;`</ph>, as a metadata view, but this forfeits the benefits of type checking and should be avoided.","source":"It is also possible to use a generic collection, `IDictionary<string, object>`, as a metadata view, but this forfeits the benefits of type checking and should be avoided."},{"content":"Ordinarily, all of the properties named in the metadata view are required, and any exports that do not provide them will not be considered a match.","pos":[19836,19983]},{"content":"The <ph id=\"ph1\">`DefaultValue`</ph> attribute specifies that a property is optional.","pos":[19984,20051],"source":" The `DefaultValue` attribute specifies that a property is optional."},{"content":"If the property is not included, it will be assigned the default value specified as a parameter of <ph id=\"ph1\">`DefaultValue`</ph>.","pos":[20052,20166],"source":" If the property is not included, it will be assigned the default value specified as a parameter of `DefaultValue`."},{"content":"The following are two different classes decorated with metadata.","pos":[20167,20231]},{"content":"Both of these classes would match the previous metadata view.","pos":[20232,20293]},{"content":"Metadata is expressed after the <ph id=\"ph1\">`Export`</ph> attribute by using the <ph id=\"ph2\">`ExportMetadata`</ph> attribute.","pos":[21015,21106],"source":"Metadata is expressed after the `Export` attribute by using the `ExportMetadata` attribute."},{"content":"Each piece of metadata is composed of a name/value pair.","pos":[21107,21163]},{"content":"The name portion of the metadata must match the name of the appropriate property in the metadata view, and the value will be assigned to that property.","pos":[21164,21315]},{"content":"It is the importer that specifies what metadata view, if any, will be in use.","pos":[21322,21399]},{"content":"An import with metadata is declared as a lazy import, with the metadata interface as the second type parameter to <ph id=\"ph1\">`Lazy&lt;T,T&gt;`</ph>.","pos":[21400,21526],"source":" An import with metadata is declared as a lazy import, with the metadata interface as the second type parameter to `Lazy<T,T>`."},{"content":"The following class imports the previous part with metadata.","pos":[21527,21587]},{"content":"In many cases, you will want to combine metadata with the <ph id=\"ph1\">`ImportMany`</ph> attribute, in order to parse through the available imports and choose and instantiate only one, or filter a collection to match a certain condition.","pos":[21847,22066],"source":"In many cases, you will want to combine metadata with the `ImportMany` attribute, in order to parse through the available imports and choose and instantiate only one, or filter a collection to match a certain condition."},{"content":"The following class instantiates only <ph id=\"ph1\">`IPlugin`</ph> objects that have the <ph id=\"ph2\">`Name`</ph> value \"Logger\".","pos":[22067,22159],"source":" The following class instantiates only `IPlugin` objects that have the `Name` value \"Logger\"."},{"pos":[23168,23197],"content":"Import and Export Inheritance","linkify":"Import and Export Inheritance","nodes":[{"content":"Import and Export Inheritance","pos":[0,29]}]},{"content":"If a class inherits from a part, that class may also become a part.","pos":[23201,23268]},{"content":"Imports are always inherited by subclasses.","pos":[23269,23312]},{"content":"Therefore, a subclass of a part will always be a part, with the same imports as its parent class.","pos":[23313,23410]},{"content":"Exports declared by using the <ph id=\"ph1\">`Export`</ph> attribute are not inherited by subclasses.","pos":[23417,23498],"source":"Exports declared by using the `Export` attribute are not inherited by subclasses."},{"content":"However, a part can export itself by using the <ph id=\"ph1\">`InheritedExport`</ph> attribute.","pos":[23499,23574],"source":" However, a part can export itself by using the `InheritedExport` attribute."},{"content":"Subclasses of the part will inherit and provide the same export, including contract name and contract type.","pos":[23575,23682]},{"content":"Unlike an <ph id=\"ph1\">`Export`</ph> attribute, <ph id=\"ph2\">`InheritedExport`</ph> can be applied only at the class level, and not at the member level.","pos":[23683,23799],"source":" Unlike an `Export` attribute, `InheritedExport` can be applied only at the class level, and not at the member level."},{"content":"Therefore, member-level exports can never be inherited.","pos":[23800,23855]},{"content":"The following four classes demonstrate the principles of import and export inheritance.","pos":[23862,23949]},{"content":"<ph id=\"ph1\">`NumTwo`</ph> inherits from <ph id=\"ph2\">`NumOne`</ph>, so <ph id=\"ph3\">`NumTwo`</ph> will import <ph id=\"ph4\">`IMyData`</ph>.","pos":[23950,24017],"source":"`NumTwo` inherits from `NumOne`, so `NumTwo` will import `IMyData`."},{"content":"Ordinary exports are not inherited, so <ph id=\"ph1\">`NumTwo`</ph> will not export anything.","pos":[24018,24091],"source":" Ordinary exports are not inherited, so `NumTwo` will not export anything."},{"content":"<ph id=\"ph1\">`NumFour`</ph> inherits from <ph id=\"ph2\">`NumThree`</ph>.","pos":[24092,24127],"source":"`NumFour` inherits from `NumThree`."},{"content":"Because <ph id=\"ph1\">`NumThree`</ph> used <ph id=\"ph2\">`InheritedExport`</ph>, <ph id=\"ph3\">`NumFour`</ph> has one export with contract type <ph id=\"ph4\">`NumThree`</ph>.","pos":[24128,24226],"source":" Because `NumThree` used `InheritedExport`, `NumFour` has one export with contract type `NumThree`."},{"content":"Member-level exports are never inherited, so <ph id=\"ph1\">`IMyData`</ph> is not exported.","pos":[24227,24298],"source":" Member-level exports are never inherited, so `IMyData` is not exported."},{"content":"If there is metadata associated with an <ph id=\"ph1\">`InheritedExport`</ph> attribute, that metadata will also be inherited.","pos":[26113,26219],"source":"If there is metadata associated with an `InheritedExport` attribute, that metadata will also be inherited."},{"content":"(For more information, see the earlier \"Metadata and Metadata Views\" section.) Inherited metadata cannot be modified by the subclass.","pos":[26220,26353]},{"content":"However, by re-declaring the <ph id=\"ph1\">`InheritedExport`</ph> attribute with the same contract name and contract type, but with new metadata, the subclass can replace the inherited metadata with new metadata.","pos":[26354,26547],"source":" However, by re-declaring the `InheritedExport` attribute with the same contract name and contract type, but with new metadata, the subclass can replace the inherited metadata with new metadata."},{"content":"The following class demonstrates this principle.","pos":[26548,26596]},{"content":"The <ph id=\"ph1\">`MegaLogger`</ph> part inherits from <ph id=\"ph2\">`Logger`</ph> and includes the <ph id=\"ph3\">`InheritedExport`</ph> attribute.","pos":[26597,26687],"source":" The `MegaLogger` part inherits from `Logger` and includes the `InheritedExport` attribute."},{"content":"Since <ph id=\"ph1\">`MegaLogger`</ph> re-declares new metadata named Status, it does not inherit the Name and Version metadata from <ph id=\"ph2\">`Logger`</ph>.","pos":[26688,26810],"source":" Since `MegaLogger` re-declares new metadata named Status, it does not inherit the Name and Version metadata from `Logger`."},{"content":"When re-declaring the <ph id=\"ph1\">`InheritedExport`</ph> attribute to override metadata, make sure that the contract types are the same.","pos":[28278,28397],"source":"When re-declaring the `InheritedExport` attribute to override metadata, make sure that the contract types are the same."},{"content":"(In the previous example, <ph id=\"ph1\">`IPlugin`</ph> is the contract type.) If they differ, instead of overriding, the second attribute will create a second, independent export from the part.","pos":[28398,28572],"source":" (In the previous example, `IPlugin` is the contract type.) If they differ, instead of overriding, the second attribute will create a second, independent export from the part."},{"content":"Generally, this means that you will have to explicitly specify the contract type when you override an <ph id=\"ph1\">`InheritedExport`</ph> attribute, as shown in the previous example.","pos":[28573,28737],"source":" Generally, this means that you will have to explicitly specify the contract type when you override an `InheritedExport` attribute, as shown in the previous example."},{"content":"Since interfaces cannot be instantiated directly, they generally cannot be decorated with <ph id=\"ph1\">`Export`</ph> or <ph id=\"ph2\">`Import`</ph> attributes.","pos":[28744,28866],"source":"Since interfaces cannot be instantiated directly, they generally cannot be decorated with `Export` or `Import` attributes."},{"content":"However, an interface can be decorated with an <ph id=\"ph1\">`InheritedExport`</ph> attribute at the interface level, and that export along with any associated metadata will be inherited by any implementing classes.","pos":[28867,29063],"source":" However, an interface can be decorated with an `InheritedExport` attribute at the interface level, and that export along with any associated metadata will be inherited by any implementing classes."},{"content":"The interface itself will not be available as a part, however.","pos":[29064,29126]},{"pos":[29178,29202],"content":"Custom Export Attributes","linkify":"Custom Export Attributes","nodes":[{"content":"Custom Export Attributes","pos":[0,24]}]},{"content":"The basic export attributes, <ph id=\"ph1\">`Export`</ph> and <ph id=\"ph2\">`InheritedExport`</ph>, can be extended to include metadata as attribute properties.","pos":[29206,29327],"source":"The basic export attributes, `Export` and `InheritedExport`, can be extended to include metadata as attribute properties."},{"content":"This technique is useful for applying similar metadata to many parts, or creating an inheritance tree of metadata attributes.","pos":[29328,29453]},{"content":"A custom attribute can specify the contract type, the contract name, or any other metadata.","pos":[29460,29551]},{"content":"In order to define a custom attribute, a class inheriting from <ph id=\"ph1\">`ExportAttribute`</ph> (or <ph id=\"ph2\">`InheritedExportAttribute`</ph>) must be decorated with the <ph id=\"ph3\">`MetadataAttribute`</ph> attribute.","pos":[29552,29722],"source":" In order to define a custom attribute, a class inheriting from `ExportAttribute` (or `InheritedExportAttribute`) must be decorated with the `MetadataAttribute` attribute."},{"content":"The following class defines a custom attribute.","pos":[29723,29770]},{"content":"This class defines a custom attribute named <ph id=\"ph1\">`MyAttribute`</ph> with contract type <ph id=\"ph2\">`IMyData`</ph> and some metadata named <ph id=\"ph3\">`MyMetadata`</ph>.","pos":[30492,30616],"source":"This class defines a custom attribute named `MyAttribute` with contract type `IMyData` and some metadata named `MyMetadata`."},{"content":"All properties in a class marked with the <ph id=\"ph1\">`MetadataAttribute`</ph> attribute are considered to be metadata defined in the custom attribute.","pos":[30617,30751],"source":" All properties in a class marked with the `MetadataAttribute` attribute are considered to be metadata defined in the custom attribute."},{"content":"The following two declarations are equivalent.","pos":[30752,30798]},{"content":"In the first declaration, the contract type and metadata are explicitly defined.","pos":[31218,31298]},{"content":"In the second declaration, the contract type and metadata are implicit in the customized attribute.","pos":[31299,31398]},{"content":"Particularly in cases where a large amount of identical metadata must be applied to many parts (for example, author or copyright information), using a custom attribute can save a lot of time and duplication.","pos":[31399,31606]},{"content":"Further, inheritance trees of custom attributes can be created to allow for variations.","pos":[31607,31694]},{"content":"To create optional metadata in a custom attribute, you can use the <ph id=\"ph1\">`DefaultValue`</ph> attribute.","pos":[31701,31793],"source":"To create optional metadata in a custom attribute, you can use the `DefaultValue` attribute."},{"content":"When this attribute is applied to a property in a custom attribute class, it specifies that the decorated property is optional and does not have to be supplied by an exporter.","pos":[31794,31969]},{"content":"If a value for the property is not supplied, it will be assigned the default value for its property type (usually <ph id=\"ph1\">`null`</ph>, <ph id=\"ph2\">`false`</ph>, or 0.)","pos":[31970,32107],"source":" If a value for the property is not supplied, it will be assigned the default value for its property type (usually `null`, `false`, or 0.)"},{"pos":[32152,32169],"content":"Creation Policies","linkify":"Creation Policies","nodes":[{"content":"Creation Policies","pos":[0,17]}]},{"content":"When a part specifies an import and composition is performed, the composition container attempts to find a matching export.","pos":[32173,32296]},{"content":"If it matches the import with an export successfully, the importing member is set to an instance of the exported object.","pos":[32297,32417]},{"content":"Where this instance comes from is controlled by the exporting part's <bpt id=\"p1\">*</bpt>creation policy<ept id=\"p1\">*</ept>.","pos":[32418,32505],"source":" Where this instance comes from is controlled by the exporting part's *creation policy*."},{"content":"The two possible creation policies are <bpt id=\"p1\">*</bpt>shared<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>non-shared<ept id=\"p2\">*</ept>.","pos":[32512,32577],"source":"The two possible creation policies are *shared* and *non-shared*."},{"content":"A part with a creation policy of shared will be shared between every import in the container for a part with that contract.","pos":[32578,32701]},{"content":"When the composition engine finds a match and has to set an importing property, it will instantiate a new copy of the part only if one does not already exist; otherwise, it will supply the existing copy.","pos":[32702,32905]},{"content":"This means that many objects may have references to the same part.","pos":[32906,32972]},{"content":"Such parts should not rely on internal state that might be changed from many places.","pos":[32973,33057]},{"content":"This policy is appropriate for static parts, parts that provide services, and parts that consume a lot of memory or other resources.","pos":[33058,33190]},{"content":"A part with the creation policy of non-shared will be created every time a matching import for one of its exports is found.","pos":[33197,33320]},{"content":"A new copy will therefore be instantiated for every import in the container that matches one of the part's exported contracts.","pos":[33321,33447]},{"content":"The internal state of these copies will not be shared.","pos":[33448,33502]},{"content":"This policy is appropriate for parts where each import requires its own internal state.","pos":[33503,33590]},{"content":"Both the import and the export can specify the creation policy of a part, from among the values <ph id=\"ph1\">`Shared`</ph>, <ph id=\"ph2\">`NonShared`</ph>, or <ph id=\"ph3\">`Any`</ph>.","pos":[33597,33725],"source":"Both the import and the export can specify the creation policy of a part, from among the values `Shared`, `NonShared`, or `Any`."},{"content":"The default is <ph id=\"ph1\">`Any`</ph> for both imports and exports.","pos":[33726,33776],"source":" The default is `Any` for both imports and exports."},{"content":"An export that specifies <ph id=\"ph1\">`Shared`</ph> or <ph id=\"ph2\">`NonShared`</ph> will only match an import that specifies the same, or that specifies <ph id=\"ph3\">`Any`</ph>.","pos":[33777,33901],"source":" An export that specifies `Shared` or `NonShared` will only match an import that specifies the same, or that specifies `Any`."},{"content":"Similarly, an import that specifies <ph id=\"ph1\">`Shared`</ph> or <ph id=\"ph2\">`NonShared`</ph> will only match an export that specifies the same, or that specifies <ph id=\"ph3\">`Any`</ph>.","pos":[33902,34037],"source":" Similarly, an import that specifies `Shared` or `NonShared` will only match an export that specifies the same, or that specifies `Any`."},{"content":"Imports and exports with incompatible creation policies are not considered a match, in the same way as an import and export whose contract name or contract type are not a match.","pos":[34038,34215]},{"content":"If both import and export specify <ph id=\"ph1\">`Any`</ph>, or do not specify a creation policy and default to <ph id=\"ph2\">`Any`</ph>, the creation policy will default to shared.","pos":[34216,34358],"source":" If both import and export specify `Any`, or do not specify a creation policy and default to `Any`, the creation policy will default to shared."},{"content":"The following example shows both imports and exports specifying creation policies.","pos":[34365,34447]},{"content":"<ph id=\"ph1\">`PartOne`</ph> does not specify a creation policy, so the default is <ph id=\"ph2\">`Any`</ph>.","pos":[34448,34518],"source":"`PartOne` does not specify a creation policy, so the default is `Any`."},{"content":"<ph id=\"ph1\">`PartTwo`</ph> does not specify a creation policy, so the default is <ph id=\"ph2\">`Any`</ph>.","pos":[34519,34589],"source":"`PartTwo` does not specify a creation policy, so the default is `Any`."},{"content":"Since both import and export default to <ph id=\"ph1\">`Any`</ph>, <ph id=\"ph2\">`PartOne`</ph> will be shared.","pos":[34590,34662],"source":" Since both import and export default to `Any`, `PartOne` will be shared."},{"content":"<ph id=\"ph1\">`PartThree`</ph> specifies a <ph id=\"ph2\">`Shared`</ph> creation policy, so <ph id=\"ph3\">`PartTwo`</ph> and <ph id=\"ph4\">`PartThree`</ph> will share the same copy of <ph id=\"ph5\">`PartOne`</ph>.","pos":[34663,34780],"source":"`PartThree` specifies a `Shared` creation policy, so `PartTwo` and `PartThree` will share the same copy of `PartOne`."},{"content":"<ph id=\"ph1\">`PartFour`</ph> specifies a <ph id=\"ph2\">`NonShared`</ph> creation policy, so <ph id=\"ph3\">`PartFour`</ph> will be non-shared in <ph id=\"ph4\">`PartFive`</ph>.","pos":[34781,34880],"source":"`PartFour` specifies a `NonShared` creation policy, so `PartFour` will be non-shared in `PartFive`."},{"content":"<ph id=\"ph1\">`PartSix`</ph> specifies a <ph id=\"ph2\">`NonShared`</ph> creation policy.","pos":[34881,34931],"source":"`PartSix` specifies a `NonShared` creation policy."},{"content":"<ph id=\"ph1\">`PartFive`</ph> and <ph id=\"ph2\">`PartSix`</ph> will each receive separate copies of <ph id=\"ph3\">`PartFour`</ph>.","pos":[34932,35005],"source":"`PartFive` and `PartSix` will each receive separate copies of `PartFour`."},{"content":"<ph id=\"ph1\">`PartSeven`</ph> specifies a <ph id=\"ph2\">`Shared`</ph> creation policy.","pos":[35006,35055],"source":"`PartSeven` specifies a `Shared` creation policy."},{"content":"Because there is no exported <ph id=\"ph1\">`PartFour`</ph> with a creation policy of <ph id=\"ph2\">`Shared`</ph>, the <ph id=\"ph3\">`PartSeven`</ph> import does not match anything and will not be filled.","pos":[35056,35202],"source":" Because there is no exported `PartFour` with a creation policy of `Shared`, the `PartSeven` import does not match anything and will not be filled."},{"pos":[38820,38844],"content":"Life Cycle and Disposing","linkify":"Life Cycle and Disposing","nodes":[{"content":"Life Cycle and Disposing","pos":[0,24]}]},{"content":"Because parts are hosted in the composition container, their life cycle can be more complex than ordinary objects.","pos":[38848,38962]},{"content":"Parts can implement two important life cycle-related interfaces: <ph id=\"ph1\">`IDisposable`</ph> and <ph id=\"ph2\">`IPartImportsSatisfiedNotification`</ph>.","pos":[38963,39082],"source":" Parts can implement two important life cycle-related interfaces: `IDisposable` and `IPartImportsSatisfiedNotification`."},{"content":"Parts that require work to be performed at shut down or that need to release resources should implement <ph id=\"ph1\">`IDisposable`</ph>, as usual for .NET Framework objects.","pos":[39089,39244],"source":"Parts that require work to be performed at shut down or that need to release resources should implement `IDisposable`, as usual for .NET Framework objects."},{"content":"However, since the container creates and maintains references to parts, only the container that owns a part should call the <ph id=\"ph1\">`Dispose`</ph> method on it.","pos":[39245,39392],"source":" However, since the container creates and maintains references to parts, only the container that owns a part should call the `Dispose` method on it."},{"content":"The container itself implements <ph id=\"ph1\">`IDisposable`</ph>, and as portion of its cleanup in <ph id=\"ph2\">`Dispose`</ph> it will call <ph id=\"ph3\">`Dispose`</ph> on all the parts that it owns.","pos":[39393,39536],"source":" The container itself implements `IDisposable`, and as portion of its cleanup in `Dispose` it will call `Dispose` on all the parts that it owns."},{"content":"For this reason, you should always dispose the composition container when it and any parts it owns are no longer needed.","pos":[39537,39657]},{"content":"For long-lived composition containers, memory consumption by parts with a creation policy of non-shared can become a problem.","pos":[39664,39789]},{"content":"These non-shared parts can be created multiple times and will not be disposed until the container itself is disposed.","pos":[39790,39907]},{"content":"To deal with this, the container provides the <ph id=\"ph1\">`ReleaseExport`</ph> method.","pos":[39908,39977],"source":" To deal with this, the container provides the `ReleaseExport` method."},{"content":"Calling this method on a non-shared export removes that export from the composition container and disposes it.","pos":[39978,40088]},{"content":"Parts that are used only by the removed export, and so on down the tree, are also removed and disposed.","pos":[40089,40192]},{"content":"In this way, resources can be reclaimed without disposing the composition container itself.","pos":[40193,40284]},{"content":"<ph id=\"ph1\">`IPartImportsSatisfiedNotification`</ph> contains one method named <ph id=\"ph2\">`OnImportsSatisfied`</ph>.","pos":[40291,40374],"source":"`IPartImportsSatisfiedNotification` contains one method named `OnImportsSatisfied`."},{"content":"This method is called by the composition container on any parts that implement the interface when composition has been completed and the part's imports are ready for use.","pos":[40375,40545]},{"content":"Parts are created by the composition engine to fill the imports of other parts.","pos":[40546,40625]},{"content":"Before the imports of a part have been set, you cannot perform any initialization that relies on or manipulates imported values in the part constructor unless those values have been specified as prerequisites by using the <ph id=\"ph1\">`ImportingConstructor`</ph> attribute.","pos":[40626,40881],"source":" Before the imports of a part have been set, you cannot perform any initialization that relies on or manipulates imported values in the part constructor unless those values have been specified as prerequisites by using the `ImportingConstructor` attribute."},{"content":"This is normally the preferred method, but in some cases, constructor injection may not be available.","pos":[40882,40983]},{"content":"In those cases, initialization can be performed in <ph id=\"ph1\">`OnImportsSatisfied`</ph>, and the part should implement <ph id=\"ph2\">`IPartImportsSatisfiedNotification`</ph>.","pos":[40984,41123],"source":" In those cases, initialization can be performed in `OnImportsSatisfied`, and the part should implement `IPartImportsSatisfiedNotification`."},{"pos":[41132,41140],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Channel 9 Video: Open Up Your Applications with the Managed Extensibility Framework<ept id=\"p1\">](http://channel9.msdn.com/events/TechEd/NorthAmerica/2009/DTL328)</ept><ph id=\"ph1\"> </ph>","pos":[41144,41295],"source":"[Channel 9 Video: Open Up Your Applications with the Managed Extensibility Framework](http://channel9.msdn.com/events/TechEd/NorthAmerica/2009/DTL328) "},{"content":"<bpt id=\"p1\">[</bpt>Channel 9 Video: Mnaaged Extensibility Framework (MEF) 2.0<ept id=\"p1\">](http://channel9.msdn.com/posts/NET-45-Oleg-Lvovitch-and-Kevin-Ransom-Managed-Extensibility-Framework-MEF-20)</ept>","pos":[41299,41468],"source":"[Channel 9 Video: Mnaaged Extensibility Framework (MEF) 2.0](http://channel9.msdn.com/posts/NET-45-Oleg-Lvovitch-and-Kevin-Ransom-Managed-Extensibility-Framework-MEF-20)"}]}