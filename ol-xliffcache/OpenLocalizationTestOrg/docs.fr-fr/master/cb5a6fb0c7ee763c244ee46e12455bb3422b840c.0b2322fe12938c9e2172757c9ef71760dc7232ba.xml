{"content":"---\ntitle: \"Dependency Property Callbacks and Validation | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"dependency properties, validation\"\n  - \"coerce value callbacks\"\n  - \"callbacks, validation\"\n  - \"dependency properties, callbacks\"\n  - \"validation of dependency properties\"\nms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825\ncaps.latest.revision: 17\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Dependency Property Callbacks and Validation\nThis topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination. This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.  \n  \n  \n  \n<a name=\"prerequisites\"></a>   \n## Prerequisites  \n This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property. See [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for context.  \n  \n<a name=\"Validation_Callbacks\"></a>   \n## Validation Callbacks  \n Validation callbacks can be assigned to a dependency property when you first register it. The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method. Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.  \n  \n [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  \n  \n The callbacks are implemented such that they are provided an object value. They return `true` if the provided value is valid for the property; otherwise, they return `false`. It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done. The callbacks are used by the property system in a variety of different operations. This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided. If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised. Application writers must be prepared to handle these exceptions. A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.  \n  \n Validation callbacks specifically are intended to be class validators, not instance validators. The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set. Therefore the validation callbacks are not useful for enforcing the possible \"dependencies\" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.  \n  \n The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.  \n  \n [!code-csharp[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]\n [!code-vb[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  \n  \n<a name=\"Coerce_Value_Callbacks_and_Property_Changed_Events\"></a>   \n## Coerce Value Callbacks and Property Changed Events  \n Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes. Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.  \n  \n A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value. Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.  \n  \n The following is very brief example code for just one of the three dependency properties that illustrate this relationship. The example shows how the `CurrentReading` property of a Min/Max/Current set of related *Reading properties is registered. It uses the validation as shown in the previous section.  \n  \n [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  \n  \n The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:  \n  \n [!code-csharp[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]\n [!code-vb[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  \n  \n The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:  \n  \n [!code-csharp[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]\n [!code-vb[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  \n  \n> [!NOTE]\n>  Default values of properties are not coerced. A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.  \n  \n The coerce value and property changed callbacks are part of property metadata. Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.  \n  \n<a name=\"Advanced\"></a>   \n## Advanced Coercion and Callback Scenarios  \n  \n### Constraints and Desired Values  \n The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a \"desired value\" internally. If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints. The value will become the desired value if all constraints are lifted. You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner. For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable. If so, you might need to coerce that Maximum is always greater than Minimum and vice versa. But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero. Then, if Maximum or Minimum are adjusted, Current will seem to \"follow\" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.  \n  \n There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly. Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not \"overconstrain\".  \n  \n### Using CoerceValue to Cancel Value Changes  \n The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case. This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had. This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not. Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported. To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.  \n  \n## See Also  \n [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)   \n [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)   \n [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)","nodes":[{"pos":[12,73],"content":"Dependency Property Callbacks and Validation | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Dependency Property Callbacks and Validation | Microsoft Docs","pos":[0,61]}]},{"pos":[581,625],"content":"Dependency Property Callbacks and Validation","linkify":"Dependency Property Callbacks and Validation","nodes":[{"content":"Dependency Property Callbacks and Validation","pos":[0,44]}]},{"content":"This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.","pos":[626,933]},{"content":"This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.","pos":[934,1068]},{"pos":[1115,1128],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.","pos":[1132,1290]},{"content":"See <bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> and <bpt id=\"p2\">[</bpt>Dependency Property Metadata<ept id=\"p2\">](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> for context.","pos":[1291,1519],"source":" See [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for context."},{"pos":[1567,1587],"content":"Validation Callbacks","linkify":"Validation Callbacks","nodes":[{"content":"Validation Callbacks","pos":[0,20]}]},{"content":"Validation callbacks can be assigned to a dependency property when you first register it.","pos":[1591,1680]},{"content":"The validation callback is not part of property metadata; it is a direct input of the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method.","pos":[1681,1827],"source":" The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method."},{"content":"Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.","pos":[1828,1952]},{"pos":[1959,2363],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DPCallbackOverride#CurrentDefinitionWithWrapper<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>DPCallbackOverride#CurrentDefinitionWithWrapper<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"},{"content":"The callbacks are implemented such that they are provided an object value.","pos":[2370,2444]},{"content":"They return <ph id=\"ph1\">`true`</ph> if the provided value is valid for the property; otherwise, they return <ph id=\"ph2\">`false`</ph>.","pos":[2445,2544],"source":" They return `true` if the provided value is valid for the property; otherwise, they return `false`."},{"content":"It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.","pos":[2545,2711]},{"content":"The callbacks are used by the property system in a variety of different operations.","pos":[2712,2795]},{"content":"This includes the initial type initialization by default value, programmatic change by invoking <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>, or attempts to override metadata with new default value provided.","pos":[2796,3009],"source":" This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided."},{"content":"If the validation callback is invoked by any of these operations, and returns <ph id=\"ph1\">`false`</ph>, then an exception will be raised.","pos":[3010,3130],"source":" If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised."},{"content":"Application writers must be prepared to handle these exceptions.","pos":[3131,3195]},{"content":"A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.","pos":[3196,3378]},{"content":"Validation callbacks specifically are intended to be class validators, not instance validators.","pos":[3385,3480]},{"content":"The parameters of the callback do not communicate a specific <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> on which the properties to validate are set.","pos":[3481,3625],"source":" The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set."},{"content":"Therefore the validation callbacks are not useful for enforcing the possible \"dependencies\" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.","pos":[3626,3901]},{"content":"The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <ph id=\"ph1\">&lt;xref:System.Double&gt;</ph> primitive is not <ph id=\"ph2\">&lt;xref:System.Double.PositiveInfinity&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.","pos":[3908,4151],"source":"The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>."},{"pos":[4158,4534],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DPCallbackOverride#ValidateValueCallback<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>DPCallbackOverride#ValidateValueCallback<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]\n [!code-vb[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]"},{"pos":[4612,4662],"content":"Coerce Value Callbacks and Property Changed Events","linkify":"Coerce Value Callbacks and Property Changed Events","nodes":[{"content":"Coerce Value Callbacks and Property Changed Events","pos":[0,50]}]},{"content":"Coerce value callbacks do pass the specific <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance for properties, as do <ph id=\"ph2\">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> implementations that are invoked by the property system whenever the value of a dependency property changes.","pos":[4666,4934],"source":"Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes."},{"content":"Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.","pos":[4935,5115]},{"content":"A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.","pos":[5122,5366]},{"content":"Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.","pos":[5367,5596]},{"content":"The following is very brief example code for just one of the three dependency properties that illustrate this relationship.","pos":[5603,5726]},{"content":"The example shows how the <ph id=\"ph1\">`CurrentReading`</ph> property of a Min/Max/Current set of related *Reading properties is registered.","pos":[5727,5849],"source":" The example shows how the `CurrentReading` property of a Min/Max/Current set of related *Reading properties is registered."},{"content":"It uses the validation as shown in the previous section.","pos":[5850,5906]},{"pos":[5913,6317],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DPCallbackOverride#CurrentDefinitionWithWrapper<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>DPCallbackOverride#CurrentDefinitionWithWrapper<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"},{"content":"The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:","pos":[6324,6524]},{"pos":[6531,6867],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DPCallbackOverride#OnPCCurrent<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>DPCallbackOverride#OnPCCurrent<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]\n [!code-vb[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]"},{"content":"The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:","pos":[6874,7032]},{"pos":[7039,7383],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DPCallbackOverride#CoerceCurrent<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>DPCallbackOverride#CoerceCurrent<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]\n [!code-vb[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]"},{"pos":[7391,7646],"content":"[!NOTE]\n Default values of properties are not coerced. A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.","leadings":["","> "],"nodes":[{"content":" Default values of properties are not coerced. A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.","pos":[8,253],"nodes":[{"content":"Default values of properties are not coerced.","pos":[1,46]},{"content":"A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>.","pos":[47,245],"source":" A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>."}]}]},{"content":"The coerce value and property changed callbacks are part of property metadata.","pos":[7653,7731]},{"content":"Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.","pos":[7732,7955]},{"pos":[7991,8031],"content":"Advanced Coercion and Callback Scenarios","linkify":"Advanced Coercion and Callback Scenarios","nodes":[{"content":"Advanced Coercion and Callback Scenarios","pos":[0,40]}]},{"pos":[8041,8071],"content":"Constraints and Desired Values","linkify":"Constraints and Desired Values","nodes":[{"content":"Constraints and Desired Values","pos":[0,30]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a \"desired value\" internally.","pos":[8075,8338],"source":"The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a \"desired value\" internally."},{"content":"If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.","pos":[8339,8634]},{"content":"The value will become the desired value if all constraints are lifted.","pos":[8635,8705]},{"content":"You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.","pos":[8706,8868]},{"content":"For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.","pos":[8869,8978]},{"content":"If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.","pos":[8979,9070]},{"content":"But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.","pos":[9071,9275]},{"content":"Then, if Maximum or Minimum are adjusted, Current will seem to \"follow\" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.","pos":[9276,9497]},{"content":"There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.","pos":[9504,9727]},{"content":"Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not \"overconstrain\".","pos":[9728,9910]},{"pos":[9920,9961],"content":"Using CoerceValue to Cancel Value Changes","linkify":"Using CoerceValue to Cancel Value Changes","nodes":[{"content":"Using CoerceValue to Cancel Value Changes","pos":[0,41]}]},{"content":"The property system will treat any <ph id=\"ph1\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> that returns the value <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> as a special case.","pos":[9965,10135],"source":"The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case."},{"content":"This special case means that the property change that resulted in the <ph id=\"ph1\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.","pos":[10136,10396],"source":" This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had."},{"content":"This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.","pos":[10397,10575]},{"content":"Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.","pos":[10576,10752]},{"content":"To do this, you can use the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> passed in the callback and the property identifier as input for <ph id=\"ph2\">&lt;xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A&gt;</ph>, and then process the <ph id=\"ph3\">&lt;xref:System.Windows.ValueSource&gt;</ph>.","pos":[10753,11007],"source":" To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>."},{"pos":[11016,11024],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept><ph id=\"ph1\"> </ph>","pos":[11028,11136],"source":"[Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Dependency Property Metadata<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)</ept><ph id=\"ph1\"> </ph>","pos":[11139,11244],"source":" [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Custom Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>","pos":[11247,11351],"source":" [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)"}]}