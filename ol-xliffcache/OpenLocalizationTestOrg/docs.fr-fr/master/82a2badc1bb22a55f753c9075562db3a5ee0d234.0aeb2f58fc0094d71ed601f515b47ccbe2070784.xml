{"content":"---\ntitle: \"ULong Data Type (Visual Basic)\"\nms.date: 01/31/2018\nf1_keywords: \n  - \"vb.ulong\"\nhelpviewer_keywords: \n  - \"numbers [Visual Basic], whole\"\n  - \"whole numbers\"\n  - \"integral data types [Visual Basic]\"\n  - \"integer numbers\"\n  - \"numbers [Visual Basic], integer\"\n  - \"integers [Visual Basic], data types\"\n  - \"integers [Visual Basic], types\"\n  - \"data types [Visual Basic], integral\"\n  - \"literal type characters [Visual Basic], UL\"\n  - \"ULong data type\"\n  - \"UL literal type characters [Visual Basic]\"\nms.assetid: 017e0702-774e-44ae-bedc-786b424ca84e\n---\n# ULong data type (Visual Basic)\n\nHolds unsigned 64-bit (8-byte) integers ranging in value from 0 through 18,446,744,073,709,551,615 (more than 1.84 times 10 ^ 19).  \n  \n## Remarks\n\nUse the `ULong` data type to contain binary data too large for `UInteger`, or the largest possible unsigned integer values.  \n  \nThe default value of `ULong` is 0.\n\n## Literal assignments\n\nYou can declare and initialize a `ULong` variable by assigning it a decimal literal, a hexadecimal literal, an octal literal, or (starting with Visual Basic 2017) a binary literal. If the integer literal is outside the range of `ULong` (that is, if it is less than <xref:System.UInt64.MinValue?displayProperty=nameWithType> or greater than <xref:System.UInt64.MaxValue?displayProperty=nameWithType>, a compilation error occurs.\n\nIn the following example, integers equal to 7,934,076,125 that are represented as decimal, hexadecimal, and binary literals are assigned to `ULong` values.\n  \n[!code-vb[ULong](../../../../samples/snippets/visualbasic/language-reference/data-types/numeric-literals.vb#ULong)]\n\n> [!NOTE] \n> You use the prefix `&h` or `&H` to denote a hexadecimal literal, the prefix `&b` or `&B` to denote a binary literal, and the prefix `&o` or `&O` to denote an octal literal. Decimal literals have no prefix.\n\nStarting with Visual Basic 2017, you can also use the underscore character, `_`, as a digit separator to enhance readability, as the following example shows.\n\n[!code-vb[ULong](../../../../samples/snippets/visualbasic/language-reference/data-types/numeric-literals.vb#LongS)]\n\nStarting with Visual Basic 15.5, you can also use the underscore character (`_`) as a leading separator between the prefix and the hexadecimal, binary, or octal digits. For example:\n\n```vb\nDim number As ULong = &H_F9AC_0326_1489_D68C\n```\n\n[!INCLUDE [supporting-underscores](../../../../includes/vb-separator-langversion.md)]\n\nNumeric literals can also include the `UL` or `ul` [type character](../../programming-guide/language-features/data-types/type-characters.md) to denote the `ULong` data type, as the following example shows.\n\n```vb\nDim number = &H_00_00_0A_96_2F_AC_14_D7ul\n```\n\n## Programming tips\n  \n-   **Negative Numbers.** Because `ULong` is an unsigned type, it cannot represent a negative number. If you use the unary minus (`-`) operator on an expression that evaluates to type `ULong`, Visual Basic converts the expression to `Decimal` first.  \n  \n-   **CLS Compliance.** The `ULong` data type is not part of the [Common Language Specification](https://www.ecma-international.org/publications/standards/Ecma-335.htm) (CLS), so CLS-compliant code cannot consume a component that uses it.  \n  \n-   **Interop Considerations.** If you are interfacing with components not written for the .NET Framework, for example Automation or COM objects, keep in mind that types such as `ulong` can have a different data width (32 bits) in other environments. If you are passing a 32-bit argument to such a component, declare it as `UInteger` instead of `ULong` in your managed Visual Basic code.  \n  \n     Furthermore, Automation does not support 64-bit integers on Windows 95, Windows 98, Windows ME, or Windows 2000. You cannot pass a Visual Basic `ULong` argument to an Automation component on these platforms.  \n  \n-   **Widening.** The `ULong` data type widens to `Decimal`, `Single`, and `Double`. This means you can convert `ULong` to any of these types without encountering a <xref:System.OverflowException?displayProperty=nameWithType> error.  \n  \n-   **Type Characters.** Appending the literal type characters `UL` to a literal forces it to the `ULong` data type. `ULong` has no identifier type character.\n  \n-   **Framework Type.** The corresponding type in the .NET Framework is the <xref:System.UInt64?displayProperty=nameWithType> structure.  \n  \n## See also\n\n- <xref:System.UInt64>\n- [Data Types](../../../visual-basic/language-reference/data-types/index.md)\n- [Type Conversion Functions](../../../visual-basic/language-reference/functions/type-conversion-functions.md)\n- [Conversion Summary](../../../visual-basic/language-reference/keywords/conversion-summary.md)\n- [How to: Call a Windows Function that Takes Unsigned Types](../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)\n- [Efficient Use of Data Types](../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)\n","nodes":[{"pos":[4,560],"embed":true,"restype":"x-metadata","content":"title: \"ULong Data Type (Visual Basic)\"\nms.date: 01/31/2018\nf1_keywords: \n  - \"vb.ulong\"\nhelpviewer_keywords: \n  - \"numbers [Visual Basic], whole\"\n  - \"whole numbers\"\n  - \"integral data types [Visual Basic]\"\n  - \"integer numbers\"\n  - \"numbers [Visual Basic], integer\"\n  - \"integers [Visual Basic], data types\"\n  - \"integers [Visual Basic], types\"\n  - \"data types [Visual Basic], integral\"\n  - \"literal type characters [Visual Basic], UL\"\n  - \"ULong data type\"\n  - \"UL literal type characters [Visual Basic]\"\nms.assetid: 017e0702-774e-44ae-bedc-786b424ca84e","nodes":[{"content":"ULong Data Type (Visual Basic)","nodes":[{"pos":[0,30],"content":"ULong Data Type (Visual Basic)","nodes":[{"content":"ULong Data Type (Visual Basic)","pos":[0,30]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[567,597],"content":"ULong data type (Visual Basic)","linkify":"ULong data type (Visual Basic)","nodes":[{"content":"ULong data type (Visual Basic)","pos":[0,30]}]},{"content":"Holds unsigned 64-bit (8-byte) integers ranging in value from 0 through 18,446,744,073,709,551,615 (more than 1.84 times 10 ^ 19).","pos":[599,729]},{"pos":[738,745],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[747,870],"content":"Use the <ph id=\"ph1\">`ULong`</ph> data type to contain binary data too large for <ph id=\"ph2\">`UInteger`</ph>, or the largest possible unsigned integer values.","source":"Use the `ULong` data type to contain binary data too large for `UInteger`, or the largest possible unsigned integer values."},{"pos":[876,910],"content":"The default value of <ph id=\"ph1\">`ULong`</ph> is 0.","source":"The default value of `ULong` is 0."},{"pos":[915,934],"content":"Literal assignments","linkify":"Literal assignments","nodes":[{"content":"Literal assignments","pos":[0,19]}]},{"content":"You can declare and initialize a <ph id=\"ph1\">`ULong`</ph> variable by assigning it a decimal literal, a hexadecimal literal, an octal literal, or (starting with Visual Basic 2017) a binary literal.","pos":[936,1116],"source":"You can declare and initialize a `ULong` variable by assigning it a decimal literal, a hexadecimal literal, an octal literal, or (starting with Visual Basic 2017) a binary literal."},{"content":"If the integer literal is outside the range of <ph id=\"ph1\">`ULong`</ph> (that is, if it is less than <ph id=\"ph2\">&lt;xref:System.UInt64.MinValue?displayProperty=nameWithType&gt;</ph> or greater than <ph id=\"ph3\">&lt;xref:System.UInt64.MaxValue?displayProperty=nameWithType&gt;</ph>, a compilation error occurs.","pos":[1117,1363],"source":" If the integer literal is outside the range of `ULong` (that is, if it is less than <xref:System.UInt64.MinValue?displayProperty=nameWithType> or greater than <xref:System.UInt64.MaxValue?displayProperty=nameWithType>, a compilation error occurs."},{"pos":[1365,1520],"content":"In the following example, integers equal to 7,934,076,125 that are represented as decimal, hexadecimal, and binary literals are assigned to <ph id=\"ph1\">`ULong`</ph> values.","source":"In the following example, integers equal to 7,934,076,125 that are represented as decimal, hexadecimal, and binary literals are assigned to `ULong` values."},{"pos":[1643,1859],"content":"[!NOTE] \nYou use the prefix `&h` or `&H` to denote a hexadecimal literal, the prefix `&b` or `&B` to denote a binary literal, and the prefix `&o` or `&O` to denote an octal literal. Decimal literals have no prefix.","leadings":["","> "],"nodes":[{"content":"You use the prefix `&h` or `&H` to denote a hexadecimal literal, the prefix `&b` or `&B` to denote a binary literal, and the prefix `&o` or `&O` to denote an octal literal. Decimal literals have no prefix.","pos":[9,214],"nodes":[{"content":"You use the prefix <ph id=\"ph1\">`&amp;h`</ph> or <ph id=\"ph2\">`&amp;H`</ph> to denote a hexadecimal literal, the prefix <ph id=\"ph3\">`&amp;b`</ph> or <ph id=\"ph4\">`&amp;B`</ph> to denote a binary literal, and the prefix <ph id=\"ph5\">`&amp;o`</ph> or <ph id=\"ph6\">`&amp;O`</ph> to denote an octal literal.","pos":[0,172],"source":"You use the prefix `&h` or `&H` to denote a hexadecimal literal, the prefix `&b` or `&B` to denote a binary literal, and the prefix `&o` or `&O` to denote an octal literal."},{"content":"Decimal literals have no prefix.","pos":[173,205]}]}]},{"pos":[1861,2018],"content":"Starting with Visual Basic 2017, you can also use the underscore character, <ph id=\"ph1\">`_`</ph>, as a digit separator to enhance readability, as the following example shows.","source":"Starting with Visual Basic 2017, you can also use the underscore character, `_`, as a digit separator to enhance readability, as the following example shows."},{"content":"Starting with Visual Basic 15.5, you can also use the underscore character (<ph id=\"ph1\">`_`</ph>) as a leading separator between the prefix and the hexadecimal, binary, or octal digits.","pos":[2137,2305],"source":"Starting with Visual Basic 15.5, you can also use the underscore character (`_`) as a leading separator between the prefix and the hexadecimal, binary, or octal digits."},{"content":"For example:","pos":[2306,2318]},{"pos":[2463,2668],"content":"Numeric literals can also include the <ph id=\"ph1\">`UL`</ph> or <ph id=\"ph2\">`ul`</ph> <bpt id=\"p1\">[</bpt>type character<ept id=\"p1\">](../../programming-guide/language-features/data-types/type-characters.md)</ept> to denote the <ph id=\"ph3\">`ULong`</ph> data type, as the following example shows.","source":"Numeric literals can also include the `UL` or `ul` [type character](../../programming-guide/language-features/data-types/type-characters.md) to denote the `ULong` data type, as the following example shows."},{"pos":[2726,2742],"content":"Programming tips","linkify":"Programming tips","nodes":[{"content":"Programming tips","pos":[0,16]}]},{"content":"<bpt id=\"p1\">**</bpt>Negative Numbers.<ept id=\"p1\">**</ept>","pos":[2750,2771],"source":"**Negative Numbers.**"},{"content":"Because <ph id=\"ph1\">`ULong`</ph> is an unsigned type, it cannot represent a negative number.","pos":[2772,2847],"source":" Because `ULong` is an unsigned type, it cannot represent a negative number."},{"content":"If you use the unary minus (<ph id=\"ph1\">`-`</ph>) operator on an expression that evaluates to type <ph id=\"ph2\">`ULong`</ph>, Visual Basic converts the expression to <ph id=\"ph3\">`Decimal`</ph> first.","pos":[2848,2995],"source":" If you use the unary minus (`-`) operator on an expression that evaluates to type `ULong`, Visual Basic converts the expression to `Decimal` first."},{"content":"<bpt id=\"p1\">**</bpt>CLS Compliance.<ept id=\"p1\">**</ept>","pos":[3005,3024],"source":"**CLS Compliance.**"},{"content":"The <ph id=\"ph1\">`ULong`</ph> data type is not part of the <bpt id=\"p1\">[</bpt>Common Language Specification<ept id=\"p1\">](https://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept> (CLS), so CLS-compliant code cannot consume a component that uses it.","pos":[3025,3239],"source":" The `ULong` data type is not part of the [Common Language Specification](https://www.ecma-international.org/publications/standards/Ecma-335.htm) (CLS), so CLS-compliant code cannot consume a component that uses it."},{"content":"<bpt id=\"p1\">**</bpt>Interop Considerations.<ept id=\"p1\">**</ept>","pos":[3249,3276],"source":"**Interop Considerations.**"},{"content":"If you are interfacing with components not written for the .NET Framework, for example Automation or COM objects, keep in mind that types such as <ph id=\"ph1\">`ulong`</ph> can have a different data width (32 bits) in other environments.","pos":[3277,3495],"source":" If you are interfacing with components not written for the .NET Framework, for example Automation or COM objects, keep in mind that types such as `ulong` can have a different data width (32 bits) in other environments."},{"content":"If you are passing a 32-bit argument to such a component, declare it as <ph id=\"ph1\">`UInteger`</ph> instead of <ph id=\"ph2\">`ULong`</ph> in your managed Visual Basic code.","pos":[3496,3632],"source":" If you are passing a 32-bit argument to such a component, declare it as `UInteger` instead of `ULong` in your managed Visual Basic code."},{"content":"Furthermore, Automation does not support 64-bit integers on Windows 95, Windows 98, Windows ME, or Windows 2000.","pos":[3643,3755]},{"content":"You cannot pass a Visual Basic <ph id=\"ph1\">`ULong`</ph> argument to an Automation component on these platforms.","pos":[3756,3850],"source":" You cannot pass a Visual Basic `ULong` argument to an Automation component on these platforms."},{"content":"<bpt id=\"p1\">**</bpt>Widening.<ept id=\"p1\">**</ept>","pos":[3860,3873],"source":"**Widening.**"},{"content":"The <ph id=\"ph1\">`ULong`</ph> data type widens to <ph id=\"ph2\">`Decimal`</ph>, <ph id=\"ph3\">`Single`</ph>, and <ph id=\"ph4\">`Double`</ph>.","pos":[3874,3940],"source":" The `ULong` data type widens to `Decimal`, `Single`, and `Double`."},{"content":"This means you can convert <ph id=\"ph1\">`ULong`</ph> to any of these types without encountering a <ph id=\"ph2\">&lt;xref:System.OverflowException?displayProperty=nameWithType&gt;</ph> error.","pos":[3941,4088],"source":" This means you can convert `ULong` to any of these types without encountering a <xref:System.OverflowException?displayProperty=nameWithType> error."},{"content":"<bpt id=\"p1\">**</bpt>Type Characters.<ept id=\"p1\">**</ept>","pos":[4098,4118],"source":"**Type Characters.**"},{"content":"Appending the literal type characters <ph id=\"ph1\">`UL`</ph> to a literal forces it to the <ph id=\"ph2\">`ULong`</ph> data type.","pos":[4119,4210],"source":" Appending the literal type characters `UL` to a literal forces it to the `ULong` data type."},{"content":"<ph id=\"ph1\">`ULong`</ph> has no identifier type character.","pos":[4211,4252],"source":"`ULong` has no identifier type character."},{"content":"<bpt id=\"p1\">**</bpt>Framework Type.<ept id=\"p1\">**</ept>","pos":[4260,4279],"source":"**Framework Type.**"},{"content":"The corresponding type in the .NET Framework is the <ph id=\"ph1\">&lt;xref:System.UInt64?displayProperty=nameWithType&gt;</ph> structure.","pos":[4280,4392],"source":" The corresponding type in the .NET Framework is the <xref:System.UInt64?displayProperty=nameWithType> structure."},{"pos":[4401,4409],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4436,4510],"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../visual-basic/language-reference/data-types/index.md)</ept>","source":"[Data Types](../../../visual-basic/language-reference/data-types/index.md)"},{"pos":[4513,4621],"content":"<bpt id=\"p1\">[</bpt>Type Conversion Functions<ept id=\"p1\">](../../../visual-basic/language-reference/functions/type-conversion-functions.md)</ept>","source":"[Type Conversion Functions](../../../visual-basic/language-reference/functions/type-conversion-functions.md)"},{"pos":[4624,4717],"content":"<bpt id=\"p1\">[</bpt>Conversion Summary<ept id=\"p1\">](../../../visual-basic/language-reference/keywords/conversion-summary.md)</ept>","source":"[Conversion Summary](../../../visual-basic/language-reference/keywords/conversion-summary.md)"},{"pos":[4720,4892],"content":"<bpt id=\"p1\">[</bpt>How to: Call a Windows Function that Takes Unsigned Types<ept id=\"p1\">](../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)</ept>","source":"[How to: Call a Windows Function that Takes Unsigned Types](../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)"},{"pos":[4895,5025],"content":"<bpt id=\"p1\">[</bpt>Efficient Use of Data Types<ept id=\"p1\">](../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)</ept>","source":"[Efficient Use of Data Types](../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)"}]}