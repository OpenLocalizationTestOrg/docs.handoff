{"content":"---\ntitle: .NET Compiler Platform SDK concepts and object model\ndescription: This overview provides the background you need to work effectively with the .NET compiler SDK. You'll learn the API layers, the major types involved, and the overall object model.\nms.date: 10/10/2017\nms.custom: mvc\n---\n\n# Understand the .NET Compiler Platform SDK model\n\nCompilers process the code you write following structured rules that often\ndiffer from the way humans read and understand code. A basic understanding\nof the model used by compilers is essential to understanding the APIs\nyou use when building Roslyn-based tools. \n\n## Compiler pipeline functional areas\n\nThe .NET Compiler Platform SDK exposes the C# and Visual Basic compilers' code analysis to you\nas a consumer by providing an API layer that mirrors a traditional compiler\npipeline.\n\n![steps of the compiler pipeline processing source code to object code](media/compiler-api-model/compiler-pipeline.png)\n\nEach phase of this pipeline is a separate component. First, the\nparse phase tokenizes and parses source text into syntax that follows\nthe language grammar. Second, the declaration phase analyzes source and\nimported metadata to form named symbols. Next, the bind phase matches identifiers\nin the code to symbols. Finally, the emit phase emits an assembly with\nall the information built up by the compiler.\n\n![compiler pipeline api provides access to each step that is part of the compiler pipeline](media/compiler-api-model/compiler-pipeline-api.png)\n\nCorresponding to each of those phases, the .NET Compiler Platform SDK exposes an\nobject model that allows access to the information at that phase. The parsing\nphase exposes a syntax tree, the declaration phase exposes a hierarchical\nsymbol table, the binding phase exposes the result of the compiler’s semantic\nanalysis, and the emit phase is an API that produces IL byte codes.\n\n![the language services available from the compiler api at each step of the compiler pipeline](media/compiler-api-model/compiler-pipeline-lang-svc.png)\n\nEach compiler combines these components together as a single end-to-end whole.\n\nThese APIs are the same ones used by Visual Studio. For instance, the code\noutlining and formatting features use the syntax trees, the Object Browser\nand navigation features use the symbol table, refactorings\nand Go to Definition use the semantic model, and Edit and Continue uses all of\nthese, including the Emit API. \n\n## API layers\n\nThe .NET compiler SDK consists of two main layers of APIs: compiler\nAPIs and workspaces APIs.\n\n![the api layers represented by the compiler pipeline apis](media/compiler-api-model/api-layers.png)\n\n### Compiler APIs\n\nThe compiler layer contains the object models that correspond to\ninformation exposed at each phase of the compiler pipeline, both syntactic\nand semantic. The compiler layer also contains an immutable snapshot of a\nsingle invocation of a compiler, including assembly references, compiler\noptions, and source code files. There are two distinct APIs that represent\nthe C# language and the Visual Basic language. These two APIs are similar\nin shape but tailored for high-fidelity to each individual language. This\nlayer has no dependencies on Visual Studio components.\n\n### Diagnostic APIs\n\nAs part of its analysis the compiler may produce a set of diagnostics\ncovering everything from syntax, semantic, and definite assignment errors\nto various warnings and informational diagnostics. The Compiler API layer\nexposes diagnostics through an extensible API that allows user-defined\nanalyzers to be plugged into the compilation process. It allows user-defined\ndiagnostics, such as those produced by tools like StyleCop or FxCop, to be\nproduced alongside compiler-defined diagnostics. Producing diagnostics in this\nway has the benefit of integrating naturally with tools such as MSBuild\nand Visual Studio which depend on diagnostics for experiences such as\nhalting a build based on policy and showing live squiggles in the editor\nand suggesting code fixes.\n\n### Scripting APIs\n\nHosting and scripting APIs are part of the compiler layer. You can use them\nfor executing code snippets and accumulating a runtime execution context.\nThe C# interactive REPL (Read-Evaluate-Print Loop) uses these APIs. The REPL\nenables you to use C# as a scripting language, executing the code interactively\nas you write it.\n\n### Workspaces APIs\n\nThe Workspaces layer contains the Workspace API, which is the starting\npoint for doing code analysis and refactoring over entire solutions. It\nassists you in organizing all the information about the projects in a\nsolution into single object model, offering you direct access to the compiler\nlayer object models without needing to parse files, configure options, or\nmanage project-to-project dependencies.\n\nIn addition, the Workspaces layer surfaces a set of APIs used\nwhen implementing code analysis and refactoring tools that function within\na host environment like the Visual Studio IDE. Examples include the Find All References,\nFormatting, and Code Generation APIs.\n\nThis layer has no dependencies on Visual Studio components.\n","nodes":[{"pos":[4,291],"embed":true,"restype":"x-metadata","content":"title: .NET Compiler Platform SDK concepts and object model\ndescription: This overview provides the background you need to work effectively with the .NET compiler SDK. You'll learn the API layers, the major types involved, and the overall object model.\nms.date: 10/10/2017\nms.custom: mvc","nodes":[{"content":".NET Compiler Platform SDK concepts and object model","nodes":[{"pos":[0,52],"content":".NET Compiler Platform SDK concepts and object model","nodes":[{"content":".NET Compiler Platform SDK concepts and object model","pos":[0,52]}]}],"path":["title"],"nosxs":false},{"content":"This overview provides the background you need to work effectively with the .NET compiler SDK. You'll learn the API layers, the major types involved, and the overall object model.","nodes":[{"pos":[0,179],"content":"This overview provides the background you need to work effectively with the .NET compiler SDK. You'll learn the API layers, the major types involved, and the overall object model.","nodes":[{"content":"This overview provides the background you need to work effectively with the .NET compiler SDK. You'll learn the API layers, the major types involved, and the overall object model.","pos":[0,179],"nodes":[{"content":"This overview provides the background you need to work effectively with the .NET compiler SDK.","pos":[0,94]},{"content":"You'll learn the API layers, the major types involved, and the overall object model.","pos":[95,179]}]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[299,346],"content":"Understand the .NET Compiler Platform SDK model","linkify":"Understand the .NET Compiler Platform SDK model","nodes":[{"content":"Understand the .NET Compiler Platform SDK model","pos":[0,47]}]},{"content":"Compilers process the code you write following structured rules that often differ from the way humans read and understand code.","pos":[348,475],"source":"Compilers process the code you write following structured rules that often\ndiffer from the way humans read and understand code."},{"content":"A basic understanding of the model used by compilers is essential to understanding the APIs you use when building Roslyn-based tools.","pos":[476,609],"source":" A basic understanding\nof the model used by compilers is essential to understanding the APIs\nyou use when building Roslyn-based tools."},{"pos":[615,649],"content":"Compiler pipeline functional areas","linkify":"Compiler pipeline functional areas","nodes":[{"content":"Compiler pipeline functional areas","pos":[0,34]}]},{"pos":[651,831],"content":"The .NET Compiler Platform SDK exposes the C# and Visual Basic compilers' code analysis to you as a consumer by providing an API layer that mirrors a traditional compiler pipeline.","source":"The .NET Compiler Platform SDK exposes the C# and Visual Basic compilers' code analysis to you\nas a consumer by providing an API layer that mirrors a traditional compiler\npipeline."},{"content":"steps of the compiler pipeline processing source code to object code","pos":[835,903]},{"content":"Each phase of this pipeline is a separate component.","pos":[954,1006]},{"content":"First, the parse phase tokenizes and parses source text into syntax that follows the language grammar.","pos":[1007,1109],"source":" First, the\nparse phase tokenizes and parses source text into syntax that follows\nthe language grammar."},{"content":"Second, the declaration phase analyzes source and imported metadata to form named symbols.","pos":[1110,1200],"source":" Second, the declaration phase analyzes source and\nimported metadata to form named symbols."},{"content":"Next, the bind phase matches identifiers in the code to symbols.","pos":[1201,1265],"source":" Next, the bind phase matches identifiers\nin the code to symbols."},{"content":"Finally, the emit phase emits an assembly with all the information built up by the compiler.","pos":[1266,1358],"source":" Finally, the emit phase emits an assembly with\nall the information built up by the compiler."},{"content":"compiler pipeline api provides access to each step that is part of the compiler pipeline","pos":[1362,1450]},{"content":"Corresponding to each of those phases, the .NET Compiler Platform SDK exposes an object model that allows access to the information at that phase.","pos":[1505,1651],"source":"Corresponding to each of those phases, the .NET Compiler Platform SDK exposes an\nobject model that allows access to the information at that phase."},{"content":"The parsing phase exposes a syntax tree, the declaration phase exposes a hierarchical symbol table, the binding phase exposes the result of the compiler’s semantic analysis, and the emit phase is an API that produces IL byte codes.","pos":[1652,1883],"source":" The parsing\nphase exposes a syntax tree, the declaration phase exposes a hierarchical\nsymbol table, the binding phase exposes the result of the compiler’s semantic\nanalysis, and the emit phase is an API that produces IL byte codes."},{"content":"the language services available from the compiler api at each step of the compiler pipeline","pos":[1887,1978]},{"content":"Each compiler combines these components together as a single end-to-end whole.","pos":[2038,2116]},{"content":"These APIs are the same ones used by Visual Studio.","pos":[2118,2169]},{"content":"For instance, the code outlining and formatting features use the syntax trees, the Object Browser and navigation features use the symbol table, refactorings and Go to Definition use the semantic model, and Edit and Continue uses all of these, including the Emit API.","pos":[2170,2436],"source":" For instance, the code\noutlining and formatting features use the syntax trees, the Object Browser\nand navigation features use the symbol table, refactorings\nand Go to Definition use the semantic model, and Edit and Continue uses all of\nthese, including the Emit API."},{"pos":[2442,2452],"content":"API layers","linkify":"API layers","nodes":[{"content":"API layers","pos":[0,10]}]},{"pos":[2454,2547],"content":"The .NET compiler SDK consists of two main layers of APIs: compiler APIs and workspaces APIs.","source":"The .NET compiler SDK consists of two main layers of APIs: compiler\nAPIs and workspaces APIs."},{"content":"the api layers represented by the compiler pipeline apis","pos":[2551,2607]},{"pos":[2655,2668],"content":"Compiler APIs","linkify":"Compiler APIs","nodes":[{"content":"Compiler APIs","pos":[0,13]}]},{"content":"The compiler layer contains the object models that correspond to information exposed at each phase of the compiler pipeline, both syntactic and semantic.","pos":[2670,2823],"source":"The compiler layer contains the object models that correspond to\ninformation exposed at each phase of the compiler pipeline, both syntactic\nand semantic."},{"content":"The compiler layer also contains an immutable snapshot of a single invocation of a compiler, including assembly references, compiler options, and source code files.","pos":[2824,2988],"source":" The compiler layer also contains an immutable snapshot of a\nsingle invocation of a compiler, including assembly references, compiler\noptions, and source code files."},{"content":"There are two distinct APIs that represent the C# language and the Visual Basic language.","pos":[2989,3078],"source":" There are two distinct APIs that represent\nthe C# language and the Visual Basic language."},{"content":"These two APIs are similar in shape but tailored for high-fidelity to each individual language.","pos":[3079,3174],"source":" These two APIs are similar\nin shape but tailored for high-fidelity to each individual language."},{"content":"This layer has no dependencies on Visual Studio components.","pos":[3175,3234],"source":" This\nlayer has no dependencies on Visual Studio components."},{"pos":[3240,3255],"content":"Diagnostic APIs","linkify":"Diagnostic APIs","nodes":[{"content":"Diagnostic APIs","pos":[0,15]}]},{"content":"As part of its analysis the compiler may produce a set of diagnostics covering everything from syntax, semantic, and definite assignment errors to various warnings and informational diagnostics.","pos":[3257,3451],"source":"As part of its analysis the compiler may produce a set of diagnostics\ncovering everything from syntax, semantic, and definite assignment errors\nto various warnings and informational diagnostics."},{"content":"The Compiler API layer exposes diagnostics through an extensible API that allows user-defined analyzers to be plugged into the compilation process.","pos":[3452,3599],"source":" The Compiler API layer\nexposes diagnostics through an extensible API that allows user-defined\nanalyzers to be plugged into the compilation process."},{"content":"It allows user-defined diagnostics, such as those produced by tools like StyleCop or FxCop, to be produced alongside compiler-defined diagnostics.","pos":[3600,3746],"source":" It allows user-defined\ndiagnostics, such as those produced by tools like StyleCop or FxCop, to be\nproduced alongside compiler-defined diagnostics."},{"content":"Producing diagnostics in this way has the benefit of integrating naturally with tools such as MSBuild and Visual Studio which depend on diagnostics for experiences such as halting a build based on policy and showing live squiggles in the editor and suggesting code fixes.","pos":[3747,4018],"source":" Producing diagnostics in this\nway has the benefit of integrating naturally with tools such as MSBuild\nand Visual Studio which depend on diagnostics for experiences such as\nhalting a build based on policy and showing live squiggles in the editor\nand suggesting code fixes."},{"pos":[4024,4038],"content":"Scripting APIs","linkify":"Scripting APIs","nodes":[{"content":"Scripting APIs","pos":[0,14]}]},{"content":"Hosting and scripting APIs are part of the compiler layer.","pos":[4040,4098]},{"content":"You can use them for executing code snippets and accumulating a runtime execution context.","pos":[4099,4189],"source":" You can use them\nfor executing code snippets and accumulating a runtime execution context."},{"content":"The C# interactive REPL (Read-Evaluate-Print Loop) uses these APIs.","pos":[4190,4257],"source":"\nThe C# interactive REPL (Read-Evaluate-Print Loop) uses these APIs."},{"content":"The REPL enables you to use C# as a scripting language, executing the code interactively as you write it.","pos":[4258,4363],"source":" The REPL\nenables you to use C# as a scripting language, executing the code interactively\nas you write it."},{"pos":[4369,4384],"content":"Workspaces APIs","linkify":"Workspaces APIs","nodes":[{"content":"Workspaces APIs","pos":[0,15]}]},{"content":"The Workspaces layer contains the Workspace API, which is the starting point for doing code analysis and refactoring over entire solutions.","pos":[4386,4525],"source":"The Workspaces layer contains the Workspace API, which is the starting\npoint for doing code analysis and refactoring over entire solutions."},{"content":"It assists you in organizing all the information about the projects in a solution into single object model, offering you direct access to the compiler layer object models without needing to parse files, configure options, or manage project-to-project dependencies.","pos":[4526,4790],"source":" It\nassists you in organizing all the information about the projects in a\nsolution into single object model, offering you direct access to the compiler\nlayer object models without needing to parse files, configure options, or\nmanage project-to-project dependencies."},{"content":"In addition, the Workspaces layer surfaces a set of APIs used when implementing code analysis and refactoring tools that function within a host environment like the Visual Studio IDE.","pos":[4792,4975],"source":"In addition, the Workspaces layer surfaces a set of APIs used\nwhen implementing code analysis and refactoring tools that function within\na host environment like the Visual Studio IDE."},{"content":"Examples include the Find All References, Formatting, and Code Generation APIs.","pos":[4976,5055],"source":" Examples include the Find All References,\nFormatting, and Code Generation APIs."},{"content":"This layer has no dependencies on Visual Studio components.","pos":[5057,5116]}]}