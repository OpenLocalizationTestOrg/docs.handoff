{"content":"---\ntitle: Console Application\ndescription: This tutorial teaches you a number of features in .NET Core and the C# language.\nkeywords: .NET, .NET Core\nauthor: BillWagner\nms.author: wiwagn\nms.date: 03/06/2017\nms.topic: article\nms.prod: .net-core\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 883cd93d-50ce-4144-b7c9-2df28d9c11a0\n---\n\n# Console Application\n\n## Introduction\nThis tutorial teaches you a number of features in .NET Core and the C# language. You’ll learn:\n*    The basics of the .NET Core Command Line Interface (CLI)\n*    The structure of a C# Console Application\n*    Console I/O\n*    The basics of File I/O APIs in .NET Core\n*    The basics of the Task Asynchronous Programming Model in .NET Core\n\nYou’ll build an application that reads a text file, and echoes the\ncontents of that text file to the console. The output to the console will\nbe paced to match reading it aloud. You can speed up or slow down the pace\nby pressing the ‘<’ or ‘>’ keys.\n\nThere are a lot of features in this tutorial. Let’s build them one by one. \n## Prerequisites\nYou’ll need to setup your machine to run .NET core. You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage. You can run this\napplication on Windows, Linux, macOS or in a Docker container. \nYou’ll need to install your favorite code editor. \n## Create the Application\nThe first step is to create a new application. Open a command prompt and\ncreate a new directory for your application. Make that the current\ndirectory. Type the command `dotnet new console` at the command prompt. This\ncreates the starter files for a basic \"Hello World\" application.\n\nBefore you start making modifications, let’s go through the steps to run\nthe simple Hello World application. After creating the application, type\n`dotnet restore` at the command prompt. This command runs the NuGet\npackage restore process. NuGet is a .NET package manager. This command\ndownloads any of the missing dependencies for your project. As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework. After this initial step, you will only\nneed to run `dotnet restore` when you add new dependent packages, or update\nthe versions of any of your dependencies. This process also creates the\nproject lock file (project.lock.json) in your project directory. This file\nhelps to manage the project dependencies. It contains the local location\nof all the project dependencies. You do not need to put the file in source\ncontrol; it will be generated when you run `dotnet restore`. \n\nAfter restoring packages, you run `dotnet build`. This executes the build\nengine and creates your application executable. Finally, you execute `dotnet run` to\nrun your application.  \n\nThe simple Hello World application code is all in Program.cs. Open that\nfile with your favorite text editor. We’re about to make our first changes.\nAt the top of the file, see a using statement:\n\n```csharp\nusing System;\n```\n\nThis statement tells the compiler that any types from the `System` namespace\nare in scope. Like other Object Oriented languages you may have used, C#\nuses namespaces to organize types. This hello world program is no\ndifferent. You can see that the program is enclosed in the\n`ConsoleApplication` namespace. That’s not a very descriptive name, so\nchange it to `TeleprompterConsole`:\n\n```csharp\nnamespace TeleprompterConsole\n```\n\n## Reading and Echoing the File\nThe first feature to add is the ability to read a text file and display all that text to the console. First, let’s add a text file. Copy the [sampleQuotes.txt](https://raw.githubusercontent.com/dotnet/docs/master/samples/csharp/getting-started/console-teleprompter/sampleQuotes.txt) file from the GitHub repository for this [sample](https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/console-teleprompter) into your project directory. This will serve as the script for your application. If you would like information on how to download the sample app for this topic, see the instructions in the [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples) topic.\n\nNext, add the following method in your Program class (right below the `Main` method):\n\n```csharp\nstatic IEnumerable<string> ReadFrom(string file)\n{\n    string line;\n    using (var reader = File.OpenText(file))\n    {\n        while ((line = reader.ReadLine()) != null)\n        {\n            yield return line;\n        }\n    }\n}\n```\n\nThis method uses types from two new namespaces. For this to compile you’ll \nneed to add the following two lines to the top of the file:\n\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\n```\n\nThe `IEnumerable<T>` interface is defined in the \n`System.Collections.Generic` namespace. The @System.IO.File class is defined in the\n`System.IO` namespace.\n\nThis method is a special type of C# method called an *Enumerator method*. \nEnumerator methods return sequences that are evaluated lazily. That means \neach item in the sequence is generated as it is requested by the code \nconsuming the sequence. Enumerator methods are methods that contain one or \nmore `yield return` statements. The object returned by the `ReadFrom` \nmethod contains the code to generate each item in the sequence. In this \nexample, that involves reading the next line of text from the source file, \nand returning that string. Each time the calling code requests the next \nitem from the sequence, the code reads the next line of text from the file\nand returns it. When the file has been completely read, the sequence \nindicates that there are no more items.\n\nThere are two other C# syntax elements that may be new to you. The `using` \nstatement in this method manages resource cleanup. The variable that is\ninitialized in the `using` statement (`reader`, in this example) must\nimplement the `IDisposable` interface. The @System.IDisposable interface\ndefines a single method, `Dispose`, that should be called when the\nresource should be released. The compiler generates that call when\nexecution reaches the closing brace of the `using` statement. The\ncompiler-generated code ensures that the resource is released even if an\nexception is thrown from the code in the block defined by the using\nstatement.\n\nThe `reader` variable is defined using the `var` keyword. `var` defines an\n*implicitly typed local variable*. That means the type of the variable is\ndetermined by the compile time type of the object assigned to the\nvariable. Here, that is the return value from @System.IO.File.OpenText, which is\na @System.IO.StreamReader object.\n \nNow, let’s fill in the code to read the file in the `Main` method: \n\n```csharp\nvar lines = ReadFrom(\"sampleQuotes.txt\");\nforeach (var line in lines)\n{\n    Console.WriteLine(line); \n}\n```\n\nRun the program (using `dotnet run` and you can see every line printed out\nto the console).  \n\n## Adding Delays and Formatting output\nWhat you have is being displayed far too fast to read aloud. Now you need\nto add the delays in the output. As you start, you’ll be building some of\nthe core code that enables asynchronous processing. However, these first\nsteps will follow a few anti-patterns. The anti-patterns are pointed out\nin comments as you add the code, and the code will be updated in later\nsteps.\n\nThere are two steps to this section. First, you’ll update the iterator\nmethod to return single words instead of entire lines. That’s done with\nthese modifications. Replace the `yield return line;` statement with the\nfollowing code:\n\n```csharp\nvar words = line.Split(' ');\nforeach (var word in words)\n{\n    yield return word + \" \";\n}\nyield return Environment.NewLine;\n```\n\nNext, you need to modify how you consume the lines of the file, and add a\ndelay after writing each word. Replace the `Console.WriteLine(line)` statement\nin the `Main` method with the following block:\n\n```csharp\nConsole.Write(line);\nif (!string.IsNullOrWhiteSpace(line))\n{\n    var pause = Task.Delay(200);\n    // Synchronously waiting on a task is an\n    // anti-pattern. This will get fixed in later\n    // steps.\n    pause.Wait();\n}\n```\n\nThe `Task` class is in the `System.Threading.Tasks` namespace, so you need\nto add that `using` statement at the top of file:\n\n```csharp\nusing System.Threading.Tasks;\n```\n\nRun the sample, and check the output. Now, each single word is printed,\nfollowed by a 200 ms delay. However, the displayed output shows some\nissues because the source text file has several lines that have more than\n80 characters without a line break. That can be hard to read while it's\nscrolling by. That’s easy to fix. You’ll just keep track of the length of\neach line, and generate a new line whenever the line length reaches a\ncertain threshold. Declare a local variable after the declaration of\n`words` that holds the line length:\n\n```csharp\nvar lineLength = 0;\n```\n \nThen, add the following code after the `yield return word + \" \";` statement\n(before the closing brace):\n\n```csharp\nlineLength += word.Length + 1;\nif (lineLength > 70)\n{\n    yield return Environment.NewLine;\n    lineLength = 0;\n}\n```\n \nRun the sample, and you’ll be able to read aloud at its pre-configured\npace.\n\n## Async Tasks\nIn this final step, you’ll add the code to write the output asynchronously\nin one task, while also running another task to read input from the user\nif they want to speed up or slow down the text display. This has a few\nsteps in it and by the end, you’ll have all the updates that you need.\nThe first step is to create an asynchronous @System.Threading.Tasks.Task returning method that\nrepresents the code you’ve created so far to read and display the file.\n\nAdd this method to your `Program` class (it’s taken from the body of your\n`Main` method):\n\n```csharp\nprivate static async Task ShowTeleprompter()\n{\n    var words = ReadFrom(\"sampleQuotes.txt\");\n    foreach (var line in words)\n    {\n        Console.Write(line);\n        if (!string.IsNullOrWhiteSpace(line))\n        {\n            await Task.Delay(200);\n        }\n    }\n}\n```\n\nYou’ll notice two changes. First, in the body of the method, instead of\ncalling @System.Threading.Tasks.Task.Wait to synchronously wait for a task to finish, this version\nuses the `await` keyword. In order to do that, you need to add the `async`\nmodifier to the method signature. This method returns a `Task`. Notice that\nthere are no return statements that return a `Task` object. Instead, that\n`Task` object is created by code the compiler generates when you use the\n`await` operator. You can imagine that this method returns when it reaches\nan `await`. The returned `Task` indicates that the work has not completed.\nThe method resumes when the awaited task completes. When it has executed\nto completion, the returned `Task` indicates that it is complete.\nCalling code can\nmonitor that returned `Task` to determine when it has completed.\n\nYou can call this new method in your `Main` method:\n\n```csharp\nShowTeleprompter().Wait();\n```\n\nHere, in `Main`, the code does synchronously wait. You should use the\n`await` operator instead of synchronously waiting whenever possible. But,\nin a console application’s `Main` method, you cannot use the `await`\noperator. That would result in the application exiting before all tasks\nhave completed.\n\nNext, you need to write the second asynchronous method to read from the\nConsole and watch for the ‘<’ and ‘>’ keys. Here’s the method you add for\nthat task:\n\n```csharp\nprivate static async Task GetInput()\n{\n    var delay = 200;\n    Action work = () =>\n    {\n        do {\n            var key = Console.ReadKey(true);\n            if (key.KeyChar == '>')\n            {\n                delay -= 10;\n            }\n            else if (key.KeyChar == '<')\n            {\n                delay += 10;\n            }\n        } while (true);\n    };\n    await Task.Run(work);\n}\n```\n\nThis creates a lambda expression to represent an @System.Action delegate that reads a key\nfrom the Console and modifies a local variable representing the delay when\nthe user presses the ‘<’ or ‘>’ keys. This method uses @System.Console.ReadKey\nto block and wait for the user to press a key.\n\nTo finish this feature, you need to create a new `async Task` returning\nmethod that starts both of these tasks (`GetInput` and \n`ShowTeleprompter`), and also manages the shared data between these two\ntasks.\n \nIt’s time to create a class that can handle the shared data between these\ntwo tasks. This class contains two public properties: the delay, and a\nflag to indicate that the file has been completely read:\n\n```csharp\nnamespace TeleprompterConsole\n{\n    internal class TelePrompterConfig\n    {\n        private object lockHandle = new object();\n        public int DelayInMilliseconds { get; private set; } = 200;\n\n        public void UpdateDelay(int increment) // negative to speed up\n        {\n            var newDelay = Min(DelayInMilliseconds + increment, 1000);\n            newDelay = Max(newDelay, 20);\n            lock (lockHandle)\n            {\n                DelayInMilliseconds = newDelay;\n            }\n        }\n    }\n}\n```\n\nPut that class in a new file, and enclose that class in the\n`TeleprompterConsole` namespace as shown above. You’ll also need to add a `using static`\nstatement so that you can reference the `Min` and `Max` method without the\nenclosing class or namespace names. A `using static` statement imports the\nmethods from one class. This is in contrast with the `using` statements used\nup to this point that have imported all classes from a namespace.\n\n```csharp\nusing static System.Math;\n```\n\nThe other language feature that’s new is the `lock` statement. This\nstatement ensures that only a single thread can be in that code at any\ngiven time. If one thread is in the locked section, other threads must\nwait for the first thread to exit that section. The `lock` statement uses an\nobject that guards the lock section. This class follows a standard idiom\nto lock a private object in the class.\n\nNext, you need to update the `ShowTeleprompter` and `GetInput` methods to\nuse the new `config` object. Write one final `Task` returning `async` method to\nstart both tasks and exit when the first task finishes:\n\n```csharp\nprivate static async Task RunTeleprompter()\n{\n    var config = new TelePrompterConfig();\n    var displayTask = ShowTeleprompter(config);\n\n    var speedTask = GetInput(config);\n    await Task.WhenAny(displayTask, speedTask);\n}\n```\n\nThe one new method here is the @System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[]) call. That creates a `Task`\nthat finishes as soon as any of the tasks in its argument list completes.\n\nNext, you need to update both the `ShowTeleprompter` and `GetInput` methods to\nuse the `config` object for the delay:\n\n```csharp\nprivate static async Task ShowTeleprompter(TelePrompterConfig config)\n{\n    var words = ReadFrom(\"sampleQuotes.txt\");\n    foreach (var line in words)\n    {\n        Console.Write(line);\n        if (!string.IsNullOrWhiteSpace(line))\n        {\n            await Task.Delay(config.DelayInMilliseconds);\n        }\n    }\n    config.SetDone();\n}\n\nprivate static async Task GetInput(TelePrompterConfig config)\n{\n\n    Action work = () =>\n    {\n        do {\n            var key = Console.ReadKey(true);\n            if (key.KeyChar == '>')\n                config.UpdateDelay(-10);\n            else if (key.KeyChar == '<')\n                config.UpdateDelay(10);\n        } while (!config.Done);\n    };\n    await Task.Run(work);\n}\n```\n\nThis new version of `ShowTeleprompter` calls a new method in the\n`TeleprompterConfig` class. Now, you need to update `Main` to call \n`RunTeleprompter` instead of `ShowTeleprompter`:\n\n```csharp\nRunTeleprompter().Wait();\n```\n\nTo finish, you'll need to add the\n`SetDone` method, and the `Done` property to the `TelePrompterConfig` class:\n\n```csharp\npublic bool Done => done;\n\nprivate bool done;\n\npublic void SetDone()\n{\n    done = true;    \n}\n```\n\n## Conclusion\nThis tutorial showed you a number of the features around the C# language\nand the .NET Core libraries related to working in Console applications.\nYou can build on this knowledge to explore more about the language, and\nthe classes introduced here. You’ve seen the basics of File and Console\nI/O, blocking and non-blocking use of the Task based Asynchronous\nprogramming model, a tour of the C# language and how C# programs are\norganized and the .NET Core Command Line Interface and tools.\n \n","nodes":[{"pos":[11,30],"content":"Console Application","needQuote":true,"needEscape":true,"nodes":[{"content":"Console Application","pos":[0,19]}]},{"pos":[44,124],"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","needQuote":true,"needEscape":true,"nodes":[{"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","pos":[0,80]}]},{"pos":[135,150],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[350,369],"content":"Console Application","linkify":"Console Application","nodes":[{"content":"Console Application","pos":[0,19]}]},{"pos":[374,386],"content":"Introduction","linkify":"Introduction","nodes":[{"content":"Introduction","pos":[0,12]}]},{"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","pos":[387,467]},{"content":"You’ll learn:","pos":[468,481]},{"content":"The basics of the .NET Core Command Line Interface (CLI)","pos":[487,543]},{"content":"The structure of a C# Console Application","pos":[549,590]},{"content":"Console I/O","pos":[596,607]},{"content":"The basics of File I/O APIs in .NET Core","pos":[613,653]},{"content":"The basics of the Task Asynchronous Programming Model in .NET Core","pos":[659,725]},{"content":"You’ll build an application that reads a text file, and echoes the contents of that text file to the console.","pos":[727,836],"source":"You’ll build an application that reads a text file, and echoes the\ncontents of that text file to the console."},{"content":"The output to the console will be paced to match reading it aloud.","pos":[837,903],"source":" The output to the console will\nbe paced to match reading it aloud."},{"content":"You can speed up or slow down the pace by pressing the ‘&lt;’ or ‘&gt;’ keys.","pos":[904,975],"source":" You can speed up or slow down the pace\nby pressing the ‘<’ or ‘>’ keys."},{"content":"There are a lot of features in this tutorial.","pos":[977,1022]},{"content":"Let’s build them one by one.","pos":[1023,1051]},{"pos":[1056,1069],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"You’ll need to setup your machine to run .NET core.","pos":[1070,1121]},{"content":"You can find the installation instructions on the <bpt id=\"p1\">[</bpt>.NET Core<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> page.","pos":[1122,1225],"source":" You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage."},{"content":"You can run this application on Windows, Linux, macOS or in a Docker container.","pos":[1226,1305],"source":" You can run this\napplication on Windows, Linux, macOS or in a Docker container."},{"content":"You’ll need to install your favorite code editor.","pos":[1306,1356],"source":" \nYou’ll need to install your favorite code editor."},{"pos":[1361,1383],"content":"Create the Application","linkify":"Create the Application","nodes":[{"content":"Create the Application","pos":[0,22]}]},{"content":"The first step is to create a new application.","pos":[1384,1430]},{"content":"Open a command prompt and create a new directory for your application.","pos":[1431,1501],"source":" Open a command prompt and\ncreate a new directory for your application."},{"content":"Make that the current directory.","pos":[1502,1534],"source":" Make that the current\ndirectory."},{"content":"Type the command <ph id=\"ph1\">`dotnet new console`</ph> at the command prompt.","pos":[1535,1595],"source":" Type the command `dotnet new console` at the command prompt."},{"content":"This creates the starter files for a basic \"Hello World\" application.","pos":[1596,1665],"source":" This\ncreates the starter files for a basic \"Hello World\" application."},{"content":"Before you start making modifications, let’s go through the steps to run the simple Hello World application.","pos":[1667,1775],"source":"Before you start making modifications, let’s go through the steps to run\nthe simple Hello World application."},{"content":"After creating the application, type <ph id=\"ph1\">`dotnet restore`</ph> at the command prompt.","pos":[1776,1852],"source":" After creating the application, type\n`dotnet restore` at the command prompt."},{"content":"This command runs the NuGet package restore process.","pos":[1853,1905],"source":" This command runs the NuGet\npackage restore process."},{"content":"NuGet is a .NET package manager.","pos":[1906,1938]},{"content":"This command downloads any of the missing dependencies for your project.","pos":[1939,2011],"source":" This command\ndownloads any of the missing dependencies for your project."},{"content":"As this is a new project, none of the dependencies are in place, so the first run will download the .NET Core framework.","pos":[2012,2132],"source":" As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework."},{"content":"After this initial step, you will only need to run <ph id=\"ph1\">`dotnet restore`</ph> when you add new dependent packages, or update the versions of any of your dependencies.","pos":[2133,2289],"source":" After this initial step, you will only\nneed to run `dotnet restore` when you add new dependent packages, or update\nthe versions of any of your dependencies."},{"content":"This process also creates the project lock file (project.lock.json) in your project directory.","pos":[2290,2384],"source":" This process also creates the\nproject lock file (project.lock.json) in your project directory."},{"content":"This file helps to manage the project dependencies.","pos":[2385,2436],"source":" This file\nhelps to manage the project dependencies."},{"content":"It contains the local location of all the project dependencies.","pos":[2437,2500],"source":" It contains the local location\nof all the project dependencies."},{"content":"You do not need to put the file in source control; it will be generated when you run <ph id=\"ph1\">`dotnet restore`</ph>.","pos":[2501,2603],"source":" You do not need to put the file in source\ncontrol; it will be generated when you run `dotnet restore`."},{"content":"After restoring packages, you run <ph id=\"ph1\">`dotnet build`</ph>.","pos":[2606,2655],"source":"After restoring packages, you run `dotnet build`."},{"content":"This executes the build engine and creates your application executable.","pos":[2656,2727],"source":" This executes the build\nengine and creates your application executable."},{"content":"Finally, you execute <ph id=\"ph1\">`dotnet run`</ph> to run your application.","pos":[2728,2786],"source":" Finally, you execute `dotnet run` to\nrun your application."},{"content":"The simple Hello World application code is all in Program.cs.","pos":[2790,2851]},{"content":"Open that file with your favorite text editor.","pos":[2852,2898],"source":" Open that\nfile with your favorite text editor."},{"content":"We’re about to make our first changes.","pos":[2899,2937]},{"content":"At the top of the file, see a using statement:","pos":[2938,2984],"source":"\nAt the top of the file, see a using statement:"},{"content":"This statement tells the compiler that any types from the <ph id=\"ph1\">`System`</ph> namespace are in scope.","pos":[3015,3105],"source":"This statement tells the compiler that any types from the `System` namespace\nare in scope."},{"content":"Like other Object Oriented languages you may have used, C# uses namespaces to organize types.","pos":[3106,3199],"source":" Like other Object Oriented languages you may have used, C#\nuses namespaces to organize types."},{"content":"This hello world program is no different.","pos":[3200,3241],"source":" This hello world program is no\ndifferent."},{"content":"You can see that the program is enclosed in the <ph id=\"ph1\">`ConsoleApplication`</ph> namespace.","pos":[3242,3321],"source":" You can see that the program is enclosed in the\n`ConsoleApplication` namespace."},{"content":"That’s not a very descriptive name, so change it to <ph id=\"ph1\">`TeleprompterConsole`</ph>:","pos":[3322,3396],"source":" That’s not a very descriptive name, so\nchange it to `TeleprompterConsole`:"},{"pos":[3446,3474],"content":"Reading and Echoing the File","linkify":"Reading and Echoing the File","nodes":[{"content":"Reading and Echoing the File","pos":[0,28]}]},{"content":"The first feature to add is the ability to read a text file and display all that text to the console.","pos":[3475,3576]},{"content":"First, let’s add a text file.","pos":[3577,3606]},{"content":"Copy the <bpt id=\"p1\">[</bpt>sampleQuotes.txt<ept id=\"p1\">](https://raw.githubusercontent.com/dotnet/docs/master/samples/csharp/getting-started/console-teleprompter/sampleQuotes.txt)</ept> file from the GitHub repository for this <bpt id=\"p2\">[</bpt>sample<ept id=\"p2\">](https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/console-teleprompter)</ept> into your project directory.","pos":[3607,3932],"source":" Copy the [sampleQuotes.txt](https://raw.githubusercontent.com/dotnet/docs/master/samples/csharp/getting-started/console-teleprompter/sampleQuotes.txt) file from the GitHub repository for this [sample](https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/console-teleprompter) into your project directory."},{"content":"This will serve as the script for your application.","pos":[3933,3984]},{"content":"If you would like information on how to download the sample app for this topic, see the instructions in the <bpt id=\"p1\">[</bpt>Samples and Tutorials<ept id=\"p1\">](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)</ept> topic.","pos":[3985,4193],"source":" If you would like information on how to download the sample app for this topic, see the instructions in the [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples) topic."},{"pos":[4195,4280],"content":"Next, add the following method in your Program class (right below the <ph id=\"ph1\">`Main`</ph> method):","source":"Next, add the following method in your Program class (right below the `Main` method):"},{"content":"This method uses types from two new namespaces.","pos":[4526,4573]},{"content":"For this to compile you’ll need to add the following two lines to the top of the file:","pos":[4574,4661],"source":" For this to compile you’ll \nneed to add the following two lines to the top of the file:"},{"content":"The <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> interface is defined in the <ph id=\"ph2\">`System.Collections.Generic`</ph> namespace.","pos":[4729,4818],"source":"The `IEnumerable<T>` interface is defined in the \n`System.Collections.Generic` namespace."},{"content":"The <ph id=\"ph1\">@System.IO.File</ph> class is defined in the <ph id=\"ph2\">`System.IO`</ph> namespace.","pos":[4819,4885],"source":" The @System.IO.File class is defined in the\n`System.IO` namespace."},{"content":"This method is a special type of C# method called an <bpt id=\"p1\">*</bpt>Enumerator method<ept id=\"p1\">*</ept>.","pos":[4887,4960],"source":"This method is a special type of C# method called an *Enumerator method*."},{"content":"Enumerator methods return sequences that are evaluated lazily.","pos":[4961,5024],"source":" \nEnumerator methods return sequences that are evaluated lazily."},{"content":"That means each item in the sequence is generated as it is requested by the code consuming the sequence.","pos":[5025,5131],"source":" That means \neach item in the sequence is generated as it is requested by the code \nconsuming the sequence."},{"content":"Enumerator methods are methods that contain one or more <ph id=\"ph1\">`yield return`</ph> statements.","pos":[5132,5215],"source":" Enumerator methods are methods that contain one or \nmore `yield return` statements."},{"content":"The object returned by the <ph id=\"ph1\">`ReadFrom`</ph> method contains the code to generate each item in the sequence.","pos":[5216,5318],"source":" The object returned by the `ReadFrom` \nmethod contains the code to generate each item in the sequence."},{"content":"In this example, that involves reading the next line of text from the source file, and returning that string.","pos":[5319,5430],"source":" In this \nexample, that involves reading the next line of text from the source file, \nand returning that string."},{"content":"Each time the calling code requests the next item from the sequence, the code reads the next line of text from the file and returns it.","pos":[5431,5567],"source":" Each time the calling code requests the next \nitem from the sequence, the code reads the next line of text from the file\nand returns it."},{"content":"When the file has been completely read, the sequence indicates that there are no more items.","pos":[5568,5661],"source":" When the file has been completely read, the sequence \nindicates that there are no more items."},{"content":"There are two other C# syntax elements that may be new to you.","pos":[5663,5725]},{"content":"The <ph id=\"ph1\">`using`</ph> statement in this method manages resource cleanup.","pos":[5726,5789],"source":" The `using` \nstatement in this method manages resource cleanup."},{"content":"The variable that is initialized in the <ph id=\"ph1\">`using`</ph> statement (<ph id=\"ph2\">`reader`</ph>, in this example) must implement the <ph id=\"ph3\">`IDisposable`</ph> interface.","pos":[5790,5919],"source":" The variable that is\ninitialized in the `using` statement (`reader`, in this example) must\nimplement the `IDisposable` interface."},{"content":"The <ph id=\"ph1\">@System.IDisposable</ph> interface defines a single method, <ph id=\"ph2\">`Dispose`</ph>, that should be called when the resource should be released.","pos":[5920,6049],"source":" The @System.IDisposable interface\ndefines a single method, `Dispose`, that should be called when the\nresource should be released."},{"content":"The compiler generates that call when execution reaches the closing brace of the <ph id=\"ph1\">`using`</ph> statement.","pos":[6050,6149],"source":" The compiler generates that call when\nexecution reaches the closing brace of the `using` statement."},{"content":"The compiler-generated code ensures that the resource is released even if an exception is thrown from the code in the block defined by the using statement.","pos":[6150,6305],"source":" The\ncompiler-generated code ensures that the resource is released even if an\nexception is thrown from the code in the block defined by the using\nstatement."},{"content":"The <ph id=\"ph1\">`reader`</ph> variable is defined using the <ph id=\"ph2\">`var`</ph> keyword.","pos":[6307,6364],"source":"The `reader` variable is defined using the `var` keyword."},{"content":"<ph id=\"ph1\">`var`</ph> defines an <bpt id=\"p1\">*</bpt>implicitly typed local variable<ept id=\"p1\">*</ept>.","pos":[6365,6416],"source":"`var` defines an\n*implicitly typed local variable*."},{"content":"That means the type of the variable is determined by the compile time type of the object assigned to the variable.","pos":[6417,6531],"source":" That means the type of the variable is\ndetermined by the compile time type of the object assigned to the\nvariable."},{"content":"Here, that is the return value from <ph id=\"ph1\">@System.IO.File.OpenText</ph>, which is a <ph id=\"ph2\">@System.IO.StreamReader</ph> object.","pos":[6532,6636],"source":" Here, that is the return value from @System.IO.File.OpenText, which is\na @System.IO.StreamReader object."},{"pos":[6639,6705],"content":"Now, let’s fill in the code to read the file in the <ph id=\"ph1\">`Main`</ph> method:","source":"Now, let’s fill in the code to read the file in the `Main` method:"},{"pos":[6827,6918],"content":"Run the program (using <ph id=\"ph1\">`dotnet run`</ph> and you can see every line printed out to the console).","source":"Run the program (using `dotnet run` and you can see every line printed out\nto the console)."},{"pos":[6925,6960],"content":"Adding Delays and Formatting output","linkify":"Adding Delays and Formatting output","nodes":[{"content":"Adding Delays and Formatting output","pos":[0,35]}]},{"content":"What you have is being displayed far too fast to read aloud.","pos":[6961,7021]},{"content":"Now you need to add the delays in the output.","pos":[7022,7067],"source":" Now you need\nto add the delays in the output."},{"content":"As you start, you’ll be building some of the core code that enables asynchronous processing.","pos":[7068,7160],"source":" As you start, you’ll be building some of\nthe core code that enables asynchronous processing."},{"content":"However, these first steps will follow a few anti-patterns.","pos":[7161,7220],"source":" However, these first\nsteps will follow a few anti-patterns."},{"content":"The anti-patterns are pointed out in comments as you add the code, and the code will be updated in later steps.","pos":[7221,7332],"source":" The anti-patterns are pointed out\nin comments as you add the code, and the code will be updated in later\nsteps."},{"content":"There are two steps to this section.","pos":[7334,7370]},{"content":"First, you’ll update the iterator method to return single words instead of entire lines.","pos":[7371,7459],"source":" First, you’ll update the iterator\nmethod to return single words instead of entire lines."},{"content":"That’s done with these modifications.","pos":[7460,7497],"source":" That’s done with\nthese modifications."},{"content":"Replace the <ph id=\"ph1\">`yield return line;`</ph> statement with the following code:","pos":[7498,7565],"source":" Replace the `yield return line;` statement with the\nfollowing code:"},{"content":"Next, you need to modify how you consume the lines of the file, and add a delay after writing each word.","pos":[7706,7810],"source":"Next, you need to modify how you consume the lines of the file, and add a\ndelay after writing each word."},{"content":"Replace the <ph id=\"ph1\">`Console.WriteLine(line)`</ph> statement in the <ph id=\"ph2\">`Main`</ph> method with the following block:","pos":[7811,7905],"source":" Replace the `Console.WriteLine(line)` statement\nin the `Main` method with the following block:"},{"pos":[8145,8269],"content":"The <ph id=\"ph1\">`Task`</ph> class is in the <ph id=\"ph2\">`System.Threading.Tasks`</ph> namespace, so you need to add that <ph id=\"ph3\">`using`</ph> statement at the top of file:","source":"The `Task` class is in the `System.Threading.Tasks` namespace, so you need\nto add that `using` statement at the top of file:"},{"content":"Run the sample, and check the output.","pos":[8316,8353]},{"content":"Now, each single word is printed, followed by a 200 ms delay.","pos":[8354,8415],"source":" Now, each single word is printed,\nfollowed by a 200 ms delay."},{"content":"However, the displayed output shows some issues because the source text file has several lines that have more than 80 characters without a line break.","pos":[8416,8566],"source":" However, the displayed output shows some\nissues because the source text file has several lines that have more than\n80 characters without a line break."},{"content":"That can be hard to read while it's scrolling by.","pos":[8567,8616],"source":" That can be hard to read while it's\nscrolling by."},{"content":"That’s easy to fix.","pos":[8617,8636]},{"content":"You’ll just keep track of the length of each line, and generate a new line whenever the line length reaches a certain threshold.","pos":[8637,8765],"source":" You’ll just keep track of the length of\neach line, and generate a new line whenever the line length reaches a\ncertain threshold."},{"content":"Declare a local variable after the declaration of <ph id=\"ph1\">`words`</ph> that holds the line length:","pos":[8766,8851],"source":" Declare a local variable after the declaration of\n`words` that holds the line length:"},{"pos":[8889,8992],"content":"Then, add the following code after the <ph id=\"ph1\">`yield return word + \" \";`</ph> statement (before the closing brace):","source":"Then, add the following code after the `yield return word + \" \";` statement\n(before the closing brace):"},{"pos":[9124,9200],"content":"Run the sample, and you’ll be able to read aloud at its pre-configured pace.","source":"Run the sample, and you’ll be able to read aloud at its pre-configured\npace."},{"pos":[9205,9216],"content":"Async Tasks","linkify":"Async Tasks","nodes":[{"content":"Async Tasks","pos":[0,11]}]},{"content":"In this final step, you’ll add the code to write the output asynchronously in one task, while also running another task to read input from the user if they want to speed up or slow down the text display.","pos":[9217,9420],"source":"In this final step, you’ll add the code to write the output asynchronously\nin one task, while also running another task to read input from the user\nif they want to speed up or slow down the text display."},{"content":"This has a few steps in it and by the end, you’ll have all the updates that you need.","pos":[9421,9506],"source":" This has a few\nsteps in it and by the end, you’ll have all the updates that you need."},{"content":"The first step is to create an asynchronous <ph id=\"ph1\">@System.Threading.Tasks.Task</ph> returning method that represents the code you’ve created so far to read and display the file.","pos":[9507,9673],"source":"\nThe first step is to create an asynchronous @System.Threading.Tasks.Task returning method that\nrepresents the code you’ve created so far to read and display the file."},{"pos":[9675,9764],"content":"Add this method to your <ph id=\"ph1\">`Program`</ph> class (it’s taken from the body of your <ph id=\"ph2\">`Main`</ph> method):","source":"Add this method to your `Program` class (it’s taken from the body of your\n`Main` method):"},{"content":"You’ll notice two changes.","pos":[10050,10076]},{"content":"First, in the body of the method, instead of calling <ph id=\"ph1\">@System.Threading.Tasks.Task.Wait</ph> to synchronously wait for a task to finish, this version uses the <ph id=\"ph2\">`await`</ph> keyword.","pos":[10077,10246],"source":" First, in the body of the method, instead of\ncalling @System.Threading.Tasks.Task.Wait to synchronously wait for a task to finish, this version\nuses the `await` keyword."},{"content":"In order to do that, you need to add the <ph id=\"ph1\">`async`</ph> modifier to the method signature.","pos":[10247,10329],"source":" In order to do that, you need to add the `async`\nmodifier to the method signature."},{"content":"This method returns a <ph id=\"ph1\">`Task`</ph>.","pos":[10330,10359],"source":" This method returns a `Task`."},{"content":"Notice that there are no return statements that return a <ph id=\"ph1\">`Task`</ph> object.","pos":[10360,10431],"source":" Notice that\nthere are no return statements that return a `Task` object."},{"content":"Instead, that <ph id=\"ph1\">`Task`</ph> object is created by code the compiler generates when you use the <ph id=\"ph2\">`await`</ph> operator.","pos":[10432,10536],"source":" Instead, that\n`Task` object is created by code the compiler generates when you use the\n`await` operator."},{"content":"You can imagine that this method returns when it reaches an <ph id=\"ph1\">`await`</ph>.","pos":[10537,10605],"source":" You can imagine that this method returns when it reaches\nan `await`."},{"content":"The returned <ph id=\"ph1\">`Task`</ph> indicates that the work has not completed.","pos":[10606,10668],"source":" The returned `Task` indicates that the work has not completed."},{"content":"The method resumes when the awaited task completes.","pos":[10669,10720],"source":"\nThe method resumes when the awaited task completes."},{"content":"When it has executed to completion, the returned <ph id=\"ph1\">`Task`</ph> indicates that it is complete.","pos":[10721,10807],"source":" When it has executed\nto completion, the returned `Task` indicates that it is complete."},{"content":"Calling code can monitor that returned <ph id=\"ph1\">`Task`</ph> to determine when it has completed.","pos":[10808,10889],"source":"\nCalling code can\nmonitor that returned `Task` to determine when it has completed."},{"pos":[10891,10942],"content":"You can call this new method in your <ph id=\"ph1\">`Main`</ph> method:","source":"You can call this new method in your `Main` method:"},{"content":"Here, in <ph id=\"ph1\">`Main`</ph>, the code does synchronously wait.","pos":[10986,11036],"source":"Here, in `Main`, the code does synchronously wait."},{"content":"You should use the <ph id=\"ph1\">`await`</ph> operator instead of synchronously waiting whenever possible.","pos":[11037,11124],"source":" You should use the\n`await` operator instead of synchronously waiting whenever possible."},{"content":"But, in a console application’s <ph id=\"ph1\">`Main`</ph> method, you cannot use the <ph id=\"ph2\">`await`</ph> operator.","pos":[11125,11208],"source":" But,\nin a console application’s `Main` method, you cannot use the `await`\noperator."},{"content":"That would result in the application exiting before all tasks have completed.","pos":[11209,11286],"source":" That would result in the application exiting before all tasks\nhave completed."},{"content":"Next, you need to write the second asynchronous method to read from the Console and watch for the ‘&lt;’ and ‘&gt;’ keys.","pos":[11288,11403],"source":"Next, you need to write the second asynchronous method to read from the\nConsole and watch for the ‘<’ and ‘>’ keys."},{"content":"Here’s the method you add for that task:","pos":[11404,11444],"source":" Here’s the method you add for\nthat task:"},{"content":"This creates a lambda expression to represent an <ph id=\"ph1\">@System.Action</ph> delegate that reads a key from the Console and modifies a local variable representing the delay when the user presses the ‘&lt;’ or ‘&gt;’ keys.","pos":[11859,12061],"source":"This creates a lambda expression to represent an @System.Action delegate that reads a key\nfrom the Console and modifies a local variable representing the delay when\nthe user presses the ‘<’ or ‘>’ keys."},{"content":"This method uses <ph id=\"ph1\">@System.Console.ReadKey</ph> to block and wait for the user to press a key.","pos":[12062,12149],"source":" This method uses @System.Console.ReadKey\nto block and wait for the user to press a key."},{"pos":[12151,12357],"content":"To finish this feature, you need to create a new <ph id=\"ph1\">`async Task`</ph> returning method that starts both of these tasks (<ph id=\"ph2\">`GetInput`</ph> and <ph id=\"ph3\">`ShowTeleprompter`</ph>), and also manages the shared data between these two tasks.","source":"To finish this feature, you need to create a new `async Task` returning\nmethod that starts both of these tasks (`GetInput` and \n`ShowTeleprompter`), and also manages the shared data between these two\ntasks."},{"content":"It’s time to create a class that can handle the shared data between these two tasks.","pos":[12360,12444],"source":"It’s time to create a class that can handle the shared data between these\ntwo tasks."},{"content":"This class contains two public properties: the delay, and a flag to indicate that the file has been completely read:","pos":[12445,12561],"source":" This class contains two public properties: the delay, and a\nflag to indicate that the file has been completely read:"},{"content":"Put that class in a new file, and enclose that class in the <ph id=\"ph1\">`TeleprompterConsole`</ph> namespace as shown above.","pos":[13091,13198],"source":"Put that class in a new file, and enclose that class in the\n`TeleprompterConsole` namespace as shown above."},{"content":"You’ll also need to add a <ph id=\"ph1\">`using static`</ph> statement so that you can reference the <ph id=\"ph2\">`Min`</ph> and <ph id=\"ph3\">`Max`</ph> method without the enclosing class or namespace names.","pos":[13199,13350],"source":" You’ll also need to add a `using static`\nstatement so that you can reference the `Min` and `Max` method without the\nenclosing class or namespace names."},{"content":"A <ph id=\"ph1\">`using static`</ph> statement imports the methods from one class.","pos":[13351,13413],"source":" A `using static` statement imports the\nmethods from one class."},{"content":"This is in contrast with the <ph id=\"ph1\">`using`</ph> statements used up to this point that have imported all classes from a namespace.","pos":[13414,13532],"source":" This is in contrast with the `using` statements used\nup to this point that have imported all classes from a namespace."},{"content":"The other language feature that’s new is the <ph id=\"ph1\">`lock`</ph> statement.","pos":[13575,13637],"source":"The other language feature that’s new is the `lock` statement."},{"content":"This statement ensures that only a single thread can be in that code at any given time.","pos":[13638,13725],"source":" This\nstatement ensures that only a single thread can be in that code at any\ngiven time."},{"content":"If one thread is in the locked section, other threads must wait for the first thread to exit that section.","pos":[13726,13832],"source":" If one thread is in the locked section, other threads must\nwait for the first thread to exit that section."},{"content":"The <ph id=\"ph1\">`lock`</ph> statement uses an object that guards the lock section.","pos":[13833,13898],"source":" The `lock` statement uses an\nobject that guards the lock section."},{"content":"This class follows a standard idiom to lock a private object in the class.","pos":[13899,13973],"source":" This class follows a standard idiom\nto lock a private object in the class."},{"content":"Next, you need to update the <ph id=\"ph1\">`ShowTeleprompter`</ph> and <ph id=\"ph2\">`GetInput`</ph> methods to use the new <ph id=\"ph3\">`config`</ph> object.","pos":[13975,14077],"source":"Next, you need to update the `ShowTeleprompter` and `GetInput` methods to\nuse the new `config` object."},{"content":"Write one final <ph id=\"ph1\">`Task`</ph> returning <ph id=\"ph2\">`async`</ph> method to start both tasks and exit when the first task finishes:","pos":[14078,14184],"source":" Write one final `Task` returning `async` method to\nstart both tasks and exit when the first task finishes:"},{"content":"The one new method here is the <ph id=\"ph1\">@System.Threading.Tasks.Task.WhenAny</ph>(System.Threading.Tasks.Task[]) call.","pos":[14427,14531],"source":"The one new method here is the @System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[]) call."},{"content":"That creates a <ph id=\"ph1\">`Task`</ph> that finishes as soon as any of the tasks in its argument list completes.","pos":[14532,14627],"source":" That creates a `Task`\nthat finishes as soon as any of the tasks in its argument list completes."},{"pos":[14629,14746],"content":"Next, you need to update both the <ph id=\"ph1\">`ShowTeleprompter`</ph> and <ph id=\"ph2\">`GetInput`</ph> methods to use the <ph id=\"ph3\">`config`</ph> object for the delay:","source":"Next, you need to update both the `ShowTeleprompter` and `GetInput` methods to\nuse the `config` object for the delay:"},{"content":"This new version of <ph id=\"ph1\">`ShowTeleprompter`</ph> calls a new method in the <ph id=\"ph2\">`TeleprompterConfig`</ph> class.","pos":[15481,15573],"source":"This new version of `ShowTeleprompter` calls a new method in the\n`TeleprompterConfig` class."},{"content":"Now, you need to update <ph id=\"ph1\">`Main`</ph> to call <ph id=\"ph2\">`RunTeleprompter`</ph> instead of <ph id=\"ph3\">`ShowTeleprompter`</ph>:","pos":[15574,15662],"source":" Now, you need to update `Main` to call \n`RunTeleprompter` instead of `ShowTeleprompter`:"},{"pos":[15705,15815],"content":"To finish, you'll need to add the <ph id=\"ph1\">`SetDone`</ph> method, and the <ph id=\"ph2\">`Done`</ph> property to the <ph id=\"ph3\">`TelePrompterConfig`</ph> class:","source":"To finish, you'll need to add the\n`SetDone` method, and the `Done` property to the `TelePrompterConfig` class:"},{"pos":[15929,15939],"content":"Conclusion","linkify":"Conclusion","nodes":[{"content":"Conclusion","pos":[0,10]}]},{"content":"This tutorial showed you a number of the features around the C# language and the .NET Core libraries related to working in Console applications.","pos":[15940,16084],"source":"This tutorial showed you a number of the features around the C# language\nand the .NET Core libraries related to working in Console applications."},{"content":"You can build on this knowledge to explore more about the language, and the classes introduced here.","pos":[16085,16185],"source":"\nYou can build on this knowledge to explore more about the language, and\nthe classes introduced here."},{"content":"You’ve seen the basics of File and Console I/O, blocking and non-blocking use of the Task based Asynchronous programming model, a tour of the C# language and how C# programs are organized and the .NET Core Command Line Interface and tools.","pos":[16186,16425],"source":" You’ve seen the basics of File and Console\nI/O, blocking and non-blocking use of the Task based Asynchronous\nprogramming model, a tour of the C# language and how C# programs are\norganized and the .NET Core Command Line Interface and tools."}]}