{"content":"---\ntitle: \"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe\"\nms.date: \"03/30/2017\"\nms.assetid: a4d62402-43a4-48a4-9ced-220633ebc4ce\n---\n# Asynchronous Scenarios using HTTP, TCP, or Named-Pipe\nThis topic describes the activities and transfers for different asynchronous request/reply scenarios, with multithreaded requests using HTTP, TCP, or named pipe.  \n  \n## Asynchronous Request/Reply without Errors  \n This section describes the activities and transfers for an asynchronous request/reply scenario, with multithreaded clients.  \n  \n The caller activity terminates when `beginCall` returns, and `endCall` returns. If a callback is called, the callback returns.  \n  \n The called activity terminates when `beginCall` returns, `endCall` returns, or when the callback returns if it was called from that activity.  \n  \n### Asynchronous Client without Callback  \n  \n#### Propagation is Enabled on Both Sides, using HTTP  \n ![Asynchronous scenarios](../../../../../docs/framework/wcf/diagnostics/tracing/media/asyn1.gif \"Asyn1\")  \n  \n Figure 1. Asynchronous client, no callback, `propagateActivity`=`true` on both sides, HTTP  \n  \n If `propagateActivity`=`true`, ProcessMessage indicates which ProcessAction activity to transfer to.  \n  \n For HTTP-based scenarios, ReceiveBytes is invoked on the first message to send, and exists for the lifetime of the request.  \n  \n#### Propagation is Disabled on Either Sides, using HTTP  \n If `propagateActivity`=`false` on either side, ProcessMessage does not indicate which ProcessAction activity to transfer to. Therefore, a new temporary ProcessAction activity with a new ID is invoked. When the asynchronous response is matched to the request in ServiceModel code, the Activity ID can be retrieved from the local context. The actual ProcessAction activity can be transferred to with that ID.  \n  \n ![Asynchronous scenarios using HTTP&#47;TCP&#47;Named Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/media/async2.gif \"Async2\")  \n  \n Figure 2. Asynchronous client, no callback, `propagateActivity`=`false` on either side, HTTP  \n  \n For HTTP-based scenarios, ReceiveBytes is invoked on the first message to send, and exists for the lifetime of the request.  \n  \n A Process Action activity is created on an asynchronous client when `propagateActivity`=`false` at the caller or callee, and when the response message does not include an Action header.  \n  \n#### Propagation is Enabled on Both Sides, using TCP or Named Pipe  \n ![Asynchronous scenarios using HTTP&#47;TCP&#47;Named Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/media/async3.gif \"Async3\")  \n  \n Figure 3. Asynchronous client, no callback, `propagateActivity`=`true` on both sides, Named-Pipe/TCP  \n  \n For a Named-Pipe or TCP-based scenario, ReceiveBytes is invoked when the client is opened, and exists for the lifetime of the connection.  \n  \n Similar to Figure 1, if `propagateActivity`=`true`, ProcessMessage indicates which ProcessAction activity to transfer to.  \n  \n#### Propagation is Disabled on Either Sides, using TCP or Named Pipe  \n For a Named-Pipe or TCP-based scenario, ReceiveBytes is invoked when the client is opened, and exists for the lifetime of the connection.  \n  \n Similar to Fig.2, If `propagateActivity`=`false` on either side, ProcessMessage does not indicate which ProcessAction activity to transfer to. Therefore, a new temporary ProcessAction activity with a new ID is invoked. When the asynchronous response is matched to the request in ServiceModel code, the Activity ID can be retrieved from the local context. The actual ProcessAction activity can be transferred to with that ID.  \n  \n ![Asynchronous scenarios using HTTP&#47;TCP&#47; Named Pipes](../../../../../docs/framework/wcf/diagnostics/tracing/media/async4.gif \"Async4\")  \n  \n Figure 4. Asynchronous client, no callback, `propagateActivity`=`false` on either side, Named-Pipe/TCP  \n  \n### Asynchronous client with Callback  \n This scenario adds activities G and A’, for the callback and `endCall`, and their transfers in/out.  \n  \n This section only demonstrates using HTTP with `propragateActivity`=`true`. However, the additional activities and transfers also apply to the other cases (that is, `propagateActivity`=`false`, using TCP or Named-Pipe).  \n  \n The callback creates a new activity (G) when the client calls user code to notify that results are ready. User code then calls `endCall` within the callback (as shown in Figure 5) or outside the callback (Figure 6). Because it is not known which user activity `endCall` is being called from, this activity is labeled `A’`. It is possible that A’ can be identical to or different from A.  \n  \n ![Asynchronous scenarios](../../../../../docs/framework/wcf/diagnostics/tracing/media/asynccallback1.gif \"AsyncCallback1\")  \n  \n Figure 5. Asynchronous client with callback, `endCall` in Callback  \n  \n ![Asynchronous Scenarios](../../../../../docs/framework/wcf/diagnostics/tracing/media/asynccallback2.gif \"AsyncCallback2\")  \n  \n Figure 6. Asynchronous client with callback, `endCall` outside of Callback  \n  \n### Asynchronous Server with Callback  \n ![Asynchronous scenarios using HTTP&#47;TCP&#47; Named&#45;Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/media/aynchserver.gif \"AynchServer\")  \n  \n Figure 7. Asynchronous server, with callback  \n  \n The channel stack calls back the client on Message Receive: traces for this processing are emitted in the ProcessRequest activity itself.  \n  \n## Asynchronous Request/Reply with Errors  \n Fault message errors are received during `endCall`. Otherwise, activities and transfers are similar to previous scenarios.  \n  \n## Asynchronous One-Way with or without Errors  \n No response or fault is returned to the client.\n","nodes":[{"pos":[4,137],"embed":true,"restype":"x-metadata","content":"title: \"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe\"\nms.date: \"03/30/2017\"\nms.assetid: a4d62402-43a4-48a4-9ced-220633ebc4ce","nodes":[{"content":"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe","nodes":[{"pos":[0,53],"content":"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe","nodes":[{"content":"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe","pos":[0,53]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[144,197],"content":"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe","linkify":"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe","nodes":[{"content":"Asynchronous Scenarios using HTTP, TCP, or Named-Pipe","pos":[0,53]}]},{"content":"This topic describes the activities and transfers for different asynchronous request/reply scenarios, with multithreaded requests using HTTP, TCP, or named pipe.","pos":[198,359]},{"pos":[368,409],"content":"Asynchronous Request/Reply without Errors","linkify":"Asynchronous Request/Reply without Errors","nodes":[{"content":"Asynchronous Request/Reply without Errors","pos":[0,41]}]},{"content":"This section describes the activities and transfers for an asynchronous request/reply scenario, with multithreaded clients.","pos":[413,536]},{"content":"The caller activity terminates when <ph id=\"ph1\">`beginCall`</ph> returns, and <ph id=\"ph2\">`endCall`</ph> returns.","pos":[543,622],"source":"The caller activity terminates when `beginCall` returns, and `endCall` returns."},{"content":"If a callback is called, the callback returns.","pos":[623,669]},{"pos":[676,817],"content":"The called activity terminates when <ph id=\"ph1\">`beginCall`</ph> returns, <ph id=\"ph2\">`endCall`</ph> returns, or when the callback returns if it was called from that activity.","source":"The called activity terminates when `beginCall` returns, `endCall` returns, or when the callback returns if it was called from that activity."},{"pos":[827,863],"content":"Asynchronous Client without Callback","linkify":"Asynchronous Client without Callback","nodes":[{"content":"Asynchronous Client without Callback","pos":[0,36]}]},{"pos":[874,922],"content":"Propagation is Enabled on Both Sides, using HTTP","linkify":"Propagation is Enabled on Both Sides, using HTTP","nodes":[{"content":"Propagation is Enabled on Both Sides, using HTTP","pos":[0,48]}]},{"pos":[926,1030],"content":"<bpt id=\"p1\">![</bpt>Asynchronous scenarios<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/wcf/diagnostics/tracing/media/asyn1.gif \"</bpt>Asyn1<ept id=\"p2\">\")</ept>","source":"![Asynchronous scenarios](../../../../../docs/framework/wcf/diagnostics/tracing/media/asyn1.gif \"Asyn1\")"},{"content":"Figure 1.","pos":[1037,1046]},{"content":"Asynchronous client, no callback, <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`true`</ph> on both sides, HTTP","pos":[1047,1127],"source":" Asynchronous client, no callback, `propagateActivity`=`true` on both sides, HTTP"},{"pos":[1134,1234],"content":"If <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`true`</ph>, ProcessMessage indicates which ProcessAction activity to transfer to.","source":"If `propagateActivity`=`true`, ProcessMessage indicates which ProcessAction activity to transfer to."},{"content":"For HTTP-based scenarios, ReceiveBytes is invoked on the first message to send, and exists for the lifetime of the request.","pos":[1241,1364]},{"pos":[1375,1426],"content":"Propagation is Disabled on Either Sides, using HTTP","linkify":"Propagation is Disabled on Either Sides, using HTTP","nodes":[{"content":"Propagation is Disabled on Either Sides, using HTTP","pos":[0,51]}]},{"content":"If <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`false`</ph> on either side, ProcessMessage does not indicate which ProcessAction activity to transfer to.","pos":[1430,1554],"source":"If `propagateActivity`=`false` on either side, ProcessMessage does not indicate which ProcessAction activity to transfer to."},{"content":"Therefore, a new temporary ProcessAction activity with a new ID is invoked.","pos":[1555,1630]},{"content":"When the asynchronous response is matched to the request in ServiceModel code, the Activity ID can be retrieved from the local context.","pos":[1631,1766]},{"content":"The actual ProcessAction activity can be transferred to with that ID.","pos":[1767,1836]},{"pos":[1843,1983],"content":"<bpt id=\"p1\">![</bpt>Asynchronous scenarios using HTTP&amp;#47;TCP&amp;#47;Named Pipe<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/wcf/diagnostics/tracing/media/async2.gif \"</bpt>Async2<ept id=\"p2\">\")</ept>","source":"![Asynchronous scenarios using HTTP&#47;TCP&#47;Named Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/media/async2.gif \"Async2\")"},{"content":"Figure 2.","pos":[1990,1999]},{"content":"Asynchronous client, no callback, <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`false`</ph> on either side, HTTP","pos":[2000,2082],"source":" Asynchronous client, no callback, `propagateActivity`=`false` on either side, HTTP"},{"content":"For HTTP-based scenarios, ReceiveBytes is invoked on the first message to send, and exists for the lifetime of the request.","pos":[2089,2212]},{"pos":[2219,2404],"content":"A Process Action activity is created on an asynchronous client when <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`false`</ph> at the caller or callee, and when the response message does not include an Action header.","source":"A Process Action activity is created on an asynchronous client when `propagateActivity`=`false` at the caller or callee, and when the response message does not include an Action header."},{"pos":[2415,2476],"content":"Propagation is Enabled on Both Sides, using TCP or Named Pipe","linkify":"Propagation is Enabled on Both Sides, using TCP or Named Pipe","nodes":[{"content":"Propagation is Enabled on Both Sides, using TCP or Named Pipe","pos":[0,61]}]},{"pos":[2480,2620],"content":"<bpt id=\"p1\">![</bpt>Asynchronous scenarios using HTTP&amp;#47;TCP&amp;#47;Named Pipe<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/wcf/diagnostics/tracing/media/async3.gif \"</bpt>Async3<ept id=\"p2\">\")</ept>","source":"![Asynchronous scenarios using HTTP&#47;TCP&#47;Named Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/media/async3.gif \"Async3\")"},{"content":"Figure 3.","pos":[2627,2636]},{"content":"Asynchronous client, no callback, <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`true`</ph> on both sides, Named-Pipe/TCP","pos":[2637,2727],"source":" Asynchronous client, no callback, `propagateActivity`=`true` on both sides, Named-Pipe/TCP"},{"content":"For a Named-Pipe or TCP-based scenario, ReceiveBytes is invoked when the client is opened, and exists for the lifetime of the connection.","pos":[2734,2871]},{"pos":[2878,2999],"content":"Similar to Figure 1, if <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`true`</ph>, ProcessMessage indicates which ProcessAction activity to transfer to.","source":"Similar to Figure 1, if `propagateActivity`=`true`, ProcessMessage indicates which ProcessAction activity to transfer to."},{"pos":[3010,3074],"content":"Propagation is Disabled on Either Sides, using TCP or Named Pipe","linkify":"Propagation is Disabled on Either Sides, using TCP or Named Pipe","nodes":[{"content":"Propagation is Disabled on Either Sides, using TCP or Named Pipe","pos":[0,64]}]},{"content":"For a Named-Pipe or TCP-based scenario, ReceiveBytes is invoked when the client is opened, and exists for the lifetime of the connection.","pos":[3078,3215]},{"content":"Similar to Fig.2, If <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`false`</ph> on either side, ProcessMessage does not indicate which ProcessAction activity to transfer to.","pos":[3222,3364],"source":"Similar to Fig.2, If `propagateActivity`=`false` on either side, ProcessMessage does not indicate which ProcessAction activity to transfer to."},{"content":"Therefore, a new temporary ProcessAction activity with a new ID is invoked.","pos":[3365,3440]},{"content":"When the asynchronous response is matched to the request in ServiceModel code, the Activity ID can be retrieved from the local context.","pos":[3441,3576]},{"content":"The actual ProcessAction activity can be transferred to with that ID.","pos":[3577,3646]},{"pos":[3653,3795],"content":"<bpt id=\"p1\">![</bpt>Asynchronous scenarios using HTTP&amp;#47;TCP&amp;#47; Named Pipes<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/wcf/diagnostics/tracing/media/async4.gif \"</bpt>Async4<ept id=\"p2\">\")</ept>","source":"![Asynchronous scenarios using HTTP&#47;TCP&#47; Named Pipes](../../../../../docs/framework/wcf/diagnostics/tracing/media/async4.gif \"Async4\")"},{"content":"Figure 4.","pos":[3802,3811]},{"content":"Asynchronous client, no callback, <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`false`</ph> on either side, Named-Pipe/TCP","pos":[3812,3904],"source":" Asynchronous client, no callback, `propagateActivity`=`false` on either side, Named-Pipe/TCP"},{"pos":[3914,3947],"content":"Asynchronous client with Callback","linkify":"Asynchronous client with Callback","nodes":[{"content":"Asynchronous client with Callback","pos":[0,33]}]},{"pos":[3951,4050],"content":"This scenario adds activities G and A’, for the callback and <ph id=\"ph1\">`endCall`</ph>, and their transfers in/out.","source":"This scenario adds activities G and A’, for the callback and `endCall`, and their transfers in/out."},{"content":"This section only demonstrates using HTTP with <ph id=\"ph1\">`propragateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`true`</ph>.","pos":[4057,4132],"source":"This section only demonstrates using HTTP with `propragateActivity`=`true`."},{"content":"However, the additional activities and transfers also apply to the other cases (that is, <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`false`</ph>, using TCP or Named-Pipe).","pos":[4133,4276],"source":" However, the additional activities and transfers also apply to the other cases (that is, `propagateActivity`=`false`, using TCP or Named-Pipe)."},{"content":"The callback creates a new activity (G) when the client calls user code to notify that results are ready.","pos":[4283,4388]},{"content":"User code then calls <ph id=\"ph1\">`endCall`</ph> within the callback (as shown in Figure 5) or outside the callback (Figure 6).","pos":[4389,4498],"source":" User code then calls `endCall` within the callback (as shown in Figure 5) or outside the callback (Figure 6)."},{"content":"Because it is not known which user activity <ph id=\"ph1\">`endCall`</ph> is being called from, this activity is labeled <ph id=\"ph2\">`A’`</ph>.","pos":[4499,4605],"source":" Because it is not known which user activity `endCall` is being called from, this activity is labeled `A’`."},{"content":"It is possible that A’ can be identical to or different from A.","pos":[4606,4669]},{"pos":[4676,4798],"content":"<bpt id=\"p1\">![</bpt>Asynchronous scenarios<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/wcf/diagnostics/tracing/media/asynccallback1.gif \"</bpt>AsyncCallback1<ept id=\"p2\">\")</ept>","source":"![Asynchronous scenarios](../../../../../docs/framework/wcf/diagnostics/tracing/media/asynccallback1.gif \"AsyncCallback1\")"},{"content":"Figure 5.","pos":[4805,4814]},{"content":"Asynchronous client with callback, <ph id=\"ph1\">`endCall`</ph> in Callback","pos":[4815,4871],"source":" Asynchronous client with callback, `endCall` in Callback"},{"pos":[4878,5000],"content":"<bpt id=\"p1\">![</bpt>Asynchronous Scenarios<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/wcf/diagnostics/tracing/media/asynccallback2.gif \"</bpt>AsyncCallback2<ept id=\"p2\">\")</ept>","source":"![Asynchronous Scenarios](../../../../../docs/framework/wcf/diagnostics/tracing/media/asynccallback2.gif \"AsyncCallback2\")"},{"content":"Figure 6.","pos":[5007,5016]},{"content":"Asynchronous client with callback, <ph id=\"ph1\">`endCall`</ph> outside of Callback","pos":[5017,5081],"source":" Asynchronous client with callback, `endCall` outside of Callback"},{"pos":[5091,5124],"content":"Asynchronous Server with Callback","linkify":"Asynchronous Server with Callback","nodes":[{"content":"Asynchronous Server with Callback","pos":[0,33]}]},{"pos":[5128,5283],"content":"<bpt id=\"p1\">![</bpt>Asynchronous scenarios using HTTP&amp;#47;TCP&amp;#47; Named&amp;#45;Pipe<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/wcf/diagnostics/tracing/media/aynchserver.gif \"</bpt>AynchServer<ept id=\"p2\">\")</ept>","source":"![Asynchronous scenarios using HTTP&#47;TCP&#47; Named&#45;Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/media/aynchserver.gif \"AynchServer\")"},{"content":"Figure 7.","pos":[5290,5299]},{"content":"Asynchronous server, with callback","pos":[5300,5334]},{"content":"The channel stack calls back the client on Message Receive: traces for this processing are emitted in the ProcessRequest activity itself.","pos":[5341,5478]},{"pos":[5487,5525],"content":"Asynchronous Request/Reply with Errors","linkify":"Asynchronous Request/Reply with Errors","nodes":[{"content":"Asynchronous Request/Reply with Errors","pos":[0,38]}]},{"content":"Fault message errors are received during <ph id=\"ph1\">`endCall`</ph>.","pos":[5529,5580],"source":"Fault message errors are received during `endCall`."},{"content":"Otherwise, activities and transfers are similar to previous scenarios.","pos":[5581,5651]},{"pos":[5660,5703],"content":"Asynchronous One-Way with or without Errors","linkify":"Asynchronous One-Way with or without Errors","nodes":[{"content":"Asynchronous One-Way with or without Errors","pos":[0,43]}]},{"content":"No response or fault is returned to the client.","pos":[5707,5754]}]}