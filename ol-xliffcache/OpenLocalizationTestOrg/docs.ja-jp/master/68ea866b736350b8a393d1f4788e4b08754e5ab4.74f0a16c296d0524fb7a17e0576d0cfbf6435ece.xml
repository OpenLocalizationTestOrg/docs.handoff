{"content":"---\ntitle: \"Designing Service Contracts\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"service contracts [WCF]\"\nms.assetid: 8e89cbb9-ac84-4f0d-85ef-0eb6be0022fd\n---\n# Designing Service Contracts\nThis topic describes what service contracts are, how they are defined, what operations are available (and the implications for the underlying message exchanges), what data types are used, and other issues that help you design operations that satisfy the requirements of your scenario.  \n  \n## Creating a Service Contract  \n Services expose a number of operations. In Windows Communication Foundation (WCF) applications, define the operations by creating a method and marking it with the <xref:System.ServiceModel.OperationContractAttribute> attribute. Then, to create a service contract, group together your operations, either by declaring them within an interface marked with the <xref:System.ServiceModel.ServiceContractAttribute> attribute, or by defining them in a class marked with the same attribute. (For a basic example, see [How to: Define a Service Contract](../../../docs/framework/wcf/how-to-define-a-wcf-service-contract.md).)  \n  \n Any methods that do not have a <xref:System.ServiceModel.OperationContractAttribute> attribute are not service operations and are not exposed by WCF services.  \n  \n This topic describes the following decision points when designing a service contract:  \n  \n-   Whether to use classes or interfaces.  \n  \n-   How to specify the data types you want to exchange.  \n  \n-   The types of exchange patterns you can use.  \n  \n-   Whether you can make explicit security requirements part of the contract.  \n  \n-   The restrictions for operation inputs and outputs.  \n  \n## Classes or Interfaces  \n Both classes and interfaces represent a grouping of functionality and, therefore, both can be used to define a WCF service contract. However, it is recommended that you use interfaces because they directly model service contracts. Without an implementation, interfaces do no more than define a grouping of methods with certain signatures. Implement a service contract interface and you have implemented a WCF service.  \n  \n All the benefits of managed interfaces apply to service contract interfaces:  \n  \n-   Service contract interfaces can extend any number of other service contract interfaces.  \n  \n-   A single class can implement any number of service contracts by implementing those service contract interfaces.  \n  \n-   You can modify the implementation of a service contract by changing the interface implementation, while the service contract remains the same.  \n  \n-   You can version your service by implementing the old interface and the new one. Old clients connect to the original version, while newer clients can connect to the newer version.  \n  \n> [!NOTE]\n>  When inheriting from other service contract interfaces, you cannot override operation properties, such as the name or namespace. If you attempt to do so, you create a new operation in the current service contract.  \n  \n For an example of using an interface to create a service contract, see [How to: Create a Service with a Contract Interface](../../../docs/framework/wcf/feature-details/how-to-create-a-service-with-a-contract-interface.md).  \n  \n You can, however, use a class to define a service contract and implement that contract at the same time. The advantage of creating your services by applying <xref:System.ServiceModel.ServiceContractAttribute> and <xref:System.ServiceModel.OperationContractAttribute> directly to the class and the methods on the class, respectively, is speed and simplicity. The disadvantages are that managed classes do not support multiple inheritance, and as a result they can only implement one service contract at a time. In addition, any modification to the class or method signatures modifies the public contract for that service, which can prevent unmodified clients from using your service. For more information, see [Implementing Service Contracts](../../../docs/framework/wcf/implementing-service-contracts.md).  \n  \n For an example that uses a class to create a service contract and implements it at the same time, see [How to: Create a Service with a Contract Class](../../../docs/framework/wcf/feature-details/how-to-create-a-wcf-contract-with-a-class.md).  \n  \n At this point, you should understand the difference between defining your service contract by using an interface and by using a class. The next step is deciding what data can be passed back and forth between a service and its clients.  \n  \n## Parameters and Return Values  \n Each operation has a return value and a parameter, even if these are `void`. However, unlike a local method, in which you can pass references to objects from one object to another, service operations do not pass references to objects. Instead, they pass copies of the objects.  \n  \n This is significant because each type used in a parameter or return value must be serializable; that is, it must be possible to convert an object of that type into a stream of bytes and from a stream of bytes into an object.  \n  \n Primitive types are serializable by default, as are many types in the .NET Framework.  \n  \n> [!NOTE]\n>  The value of the parameter names in the operation signature are part of the contract and are case sensitive. If you want to use the same parameter name locally but modify the name in the published metadata, see the <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.  \n  \n#### Data Contracts  \n Service-oriented applications like Windows Communication Foundation (WCF) applications are designed to interoperate with the widest possible number of client applications on both Microsoft and non-Microsoft platforms. For the widest possible interoperability, it is recommended that you mark your types with the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create a data contract, which is the portion of the service contract that describes the data that your service operations exchange.  \n  \n Data contracts are opt-in style contracts: No type or data member is serialized unless you explicitly apply the data contract attribute. Data contracts are unrelated to the access scope of the managed code: Private data members can be serialized and sent elsewhere to be accessed publicly. (For a basic example of a data contract, see [How to: Create a Basic Data Contract for a Class or Structure](../../../docs/framework/wcf/feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md).) WCF handles the definition of the underlying SOAP messages that enable the operation's functionality as well as the serialization of your data types into and out of the body of the messages. As long as your data types are serializable, you do not need to think about the underlying message exchange infrastructure when designing your operations.  \n  \n Although the typical WCF application uses the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create data contracts for operations, you can use other serialization mechanisms. The standard <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> and <xref:System.Xml.Serialization.IXmlSerializable> mechanisms all work to handle the serialization of your data types into the underlying SOAP messages that carry them from one application to another. You can employ more serialization strategies if your data types require special support. For more information about the choices for serialization of data types in WCF applications, see [Specifying Data Transfer in Service Contracts](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).  \n  \n#### Mapping Parameters and Return Values to Message Exchanges  \n Service operations are supported by an underlying exchange of SOAP messages that transfer application data back and forth, in addition to the data required by the application to support certain standard security, transaction, and session-related features. Because this is the case, the signature of a service operation dictates a certain underlying *message exchange pattern* (MEP) that can support the data transfer and the features an operation requires. You can specify three patterns in the WCF programming model: request/reply, one-way, and duplex message patterns.  \n  \n##### Request/Reply  \n A request/reply pattern is one in which a request sender (a client application) receives a reply with which the request is correlated. This is the default MEP because it supports an operation in which one or more parameters are passed to the operation and a return value is passed back to the caller. For example, the following C# code example shows a basic service operation that takes one string and returns a string.  \n  \n```csharp  \n[OperationContractAttribute]  \nstring Hello(string greeting);  \n```  \n  \n The following is the equivalent Visual Basic code.  \n  \n```vb  \n<OperationContractAttribute()>  \nFunction Hello (ByVal greeting As String) As String  \n```  \n  \n This operation signature dictates the form of underlying message exchange. If no correlation existed, WCF cannot determine for which operation the return value is intended.  \n  \n Note that unless you specify a different underlying message pattern, even service operations that return `void` (`Nothing` in Visual Basic) are request/reply message exchanges. The result for your operation is that unless a client invokes the operation asynchronously, the client stops processing until the return message is received, even though that message is empty in the normal case. The following C# code example shows an operation that does not return until the client has received an empty message in response.  \n  \n```csharp  \n[OperationContractAttribute]  \nvoid Hello(string greeting);  \n```  \n  \n The following is the equivalent Visual Basic code.  \n  \n```vb  \n<OperationContractAttribute()>  \nSub Hello (ByVal greeting As String)  \n```  \n  \n The preceding example can slow client performance and responsiveness if the operation takes a long time to perform, but there are advantages to request/reply operations even when they return `void`. The most obvious one is that SOAP faults can be returned in the response message, which indicates that some service-related error condition has occurred, whether in communication or processing. SOAP faults that are specified in a service contract are passed to the client application as a <xref:System.ServiceModel.FaultException%601> object, where the type parameter is the type specified in the service contract. This makes notifying clients about error conditions in WCF services easy. For more information about exceptions, SOAP faults, and error handling, see [Specifying and Handling Faults in Contracts and Services](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md). To see an example of a request/reply service and client, see [How to: Create a Request-Reply Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md). For more information about issues with the request-reply pattern, see [Request-Reply Services](../../../docs/framework/wcf/feature-details/request-reply-services.md).  \n  \n##### One-way  \n If the client of a WCF service application should not wait for the operation to complete and does not process SOAP faults, the operation can specify a one-way message pattern. A one-way operation is one in which a client invokes an operation and continues processing after WCF writes the message to the network. Typically this means that unless the data being sent in the outbound message is extremely large the client continues running almost immediately (unless there is an error sending the data). This type of message exchange pattern supports event-like behavior from a client to a service application.  \n  \n A message exchange in which one message is sent and none are received cannot support a service operation that specifies a return value other than `void`; in this case an <xref:System.InvalidOperationException> exception is thrown.  \n  \n No return message also means that there can be no SOAP fault returned to indicate any errors in processing or communication. (Communicating error information when operations are one-way operations requires a duplex message exchange pattern.)  \n  \n To specify a one-way message exchange for an operation that returns `void`, set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as in the following C# code example.  \n  \n```csharp  \n[OperationContractAttribute(IsOneWay=true)]  \nvoid Hello(string greeting);  \n```  \n  \n The following is the equivalent Visual Basic code.  \n  \n```vb  \n<OperationContractAttribute(IsOneWay := True)>  \nSub Hello (ByVal greeting As String)  \n```  \n  \n This method is identical to the preceding request/reply example, but setting the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true` means that although the method is identical, the service operation does not send a return message and clients return immediately once the outbound message has been handed to the channel layer. For an example, see [How to: Create a One-Way Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md). For more information about the one-way pattern, see [One-Way Services](../../../docs/framework/wcf/feature-details/one-way-services.md).  \n  \n##### Duplex  \n A duplex pattern is characterized by the ability of both the service and the client to send messages to each other independently whether using one-way or request/reply messaging. This form of two-way communication is useful for services that must communicate directly to the client or for providing an asynchronous experience to either side of a message exchange, including event-like behavior.  \n  \n The duplex pattern is slightly more complex than the request/reply or one-way patterns because of the additional mechanism for communicating with the client.  \n  \n To design a duplex contract, you must also design a callback contract and assign the type of that callback contract to the <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> property of the <xref:System.ServiceModel.ServiceContractAttribute> attribute that marks your service contract.  \n  \n To implement a duplex pattern, you must create a second interface that contains the method declarations that are called on the client.  \n  \n For an example of creating a service, and a client that accesses that service, see [How to: Create a Duplex Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md) and [How to: Access Services with a Duplex Contract](../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md). For a working sample, see [Duplex](../../../docs/framework/wcf/samples/duplex.md). For more information about issues using duplex contracts, see [Duplex Services](../../../docs/framework/wcf/feature-details/duplex-services.md).  \n  \n> [!CAUTION]\n>  When a service receives a duplex message, it looks at the `ReplyTo` element in that incoming message to determine where to send the reply. If the channel that is used to receive the message is not secured, then an untrusted client could send a malicious message with a target machine's `ReplyTo`, leading to a denial of service (DOS) of that target machine.  \n  \n##### Out and Ref Parameters  \n In most cases, you can use `in` parameters (`ByVal` in Visual Basic) and `out` and `ref` parameters (`ByRef` in Visual Basic). Because both `out` and `ref` parameters indicate that data is returned from an operation, an operation signature such as the following specifies that a request/reply operation is required even though the operation signature returns `void`.  \n  \n```csharp  \n[ServiceContractAttribute]  \npublic interface IMyContract  \n{  \n  [OperationContractAttribute]  \n  public void PopulateData(ref CustomDataType data);  \n}  \n```  \n  \n The following is the equivalent Visual Basic code.  \n  \n```vb  \n<ServiceContractAttribute()> _  \nPublic Interface IMyContract  \n  <OperationContractAttribute()> _  \n  Public Sub PopulateData(ByRef data As CustomDataType)  \nEnd Interface  \n```  \n  \n The only exceptions are those cases in which your signature has a particular structure. For example, you can use the <xref:System.ServiceModel.NetMsmqBinding> binding to communicate with clients only if the method used to declare an operation returns `void`; there can be no output value, whether it is a return value, `ref`, or `out` parameter.  \n  \n In addition, using `out` or `ref` parameters requires that the operation have an underlying response message to carry back the modified object. If your operation is a one-way operation, an <xref:System.InvalidOperationException> exception is thrown at runtime.  \n  \n### Specify Message Protection Level on the Contract  \n When designing your contract, you must also decide the message protection level of services that implement your contract. This is necessary only if message security is applied to the binding in the contract's endpoint. If the binding has security turned off (that is, if the system-provided binding sets the <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> to the value <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>) then you do not have to decide on the message protection level for the contract. In most cases, system-provided bindings with message-level security applied provide a sufficient protection level and you do not have to consider the protection level for each operation or for each message.  \n  \n The protection level is a value that specifies whether the messages (or message parts) that support a service are signed, signed and encrypted, or sent without signatures or encryption. The protection level can be set at various scopes: At the service level, for a particular operation, for a message within that operation, or a message part. Values set at one scope become the default value for smaller scopes unless explicitly overridden. If a binding configuration cannot provide the required minimum protection level for the contract, an exception is thrown. And when no protection level values are explicitly set on the contract, the binding configuration controls the protection level for all messages if the binding has message security. This is the default behavior.  \n  \n> [!IMPORTANT]\n>  Deciding whether to explicitly set various scopes of a contract to less than the full protection level of <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> is generally a decision that trades some degree of security for increased performance. In these cases, your decisions must revolve around your operations and the value of the data they exchange. For more information, see [Securing Services](../../../docs/framework/wcf/securing-services.md).  \n  \n For example, the following code example does not set either the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> or the <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> property on the contract.  \n  \n```csharp  \n[ServiceContract]  \npublic interface ISampleService  \n{  \n  [OperationContractAttribute]  \n  public string GetString();  \n  \n  [OperationContractAttribute]  \n  public int GetInt();    \n}  \n```  \n  \n The following is the equivalent Visual Basic code.  \n  \n```vb  \n<ServiceContractAttribute()> _  \nPublic Interface ISampleService  \n  \n  <OperationContractAttribute()> _  \n  Public Function GetString()As String  \n  \n  <OperationContractAttribute()> _  \n  Public Function GetData() As Integer  \n  \nEnd Interface  \n```  \n  \n When interacting with an `ISampleService` implementation in an endpoint with a default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>), all messages are encrypted and signed because this is the default protection level. However, when an `ISampleService` service is used with a default <xref:System.ServiceModel.BasicHttpBinding> (the default <xref:System.ServiceModel.SecurityMode>, which is <xref:System.ServiceModel.SecurityMode.None>), all messages are sent as text because there is no security for this binding and so the protection level is ignored (that is, the messages are neither encrypted nor signed). If the <xref:System.ServiceModel.SecurityMode> was changed to <xref:System.ServiceModel.SecurityMode.Message>, then these messages would be encrypted and signed (because that would now be the binding's default protection level).  \n  \n If you want to explicitly specify or adjust the protection requirements for your contract, set the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> property (or any of the `ProtectionLevel` properties at a smaller scope) to the level your service contract requires. In this case, using an explicit setting requires the binding to support that setting at a minimum for the scope used. For example, the following code example specifies one <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> value explicitly, for the `GetGuid` operation.  \n  \n```csharp  \n[ServiceContract]  \npublic interface IExplicitProtectionLevelSampleService  \n{  \n  [OperationContractAttribute]  \n  public string GetString();  \n  \n  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.None)]  \n  public int GetInt();    \n  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.EncryptAndSign)]  \n  public int GetGuid();    \n}  \n```  \n  \n The following is the equivalent Visual Basic code.  \n  \n```vb  \n<ServiceContract()> _   \nPublic Interface IExplicitProtectionLevelSampleService   \n    <OperationContract()> _   \n    Public Function GetString() As String   \n    End Function   \n  \n    <OperationContract(ProtectionLevel := ProtectionLevel.None)> _   \n    Public Function GetInt() As Integer   \n    End Function   \n  \n    <OperationContractAttribute(ProtectionLevel := ProtectionLevel.EncryptAndSign)> _   \n    Public Function GetGuid() As Integer   \n    End Function   \n  \nEnd Interface  \n```  \n  \n A service that implements this `IExplicitProtectionLevelSampleService` contract and has an endpoint that uses the default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>) has the following behavior:  \n  \n-   The `GetString` operation messages are encrypted and signed.  \n  \n-   The `GetInt` operation messages are sent as unencrypted and unsigned (that is, plain) text.  \n  \n-   The `GetGuid` operation <xref:System.Guid?displayProperty=nameWithType> is returned in a message that is encrypted and signed.  \n  \n For more information about protection levels and how to use them, see [Understanding Protection Level](../../../docs/framework/wcf/understanding-protection-level.md). For more information about security, see [Securing Services](../../../docs/framework/wcf/securing-services.md).  \n  \n##### Other Operation Signature Requirements  \n Some application features require a particular kind of operation signature. For example, the <xref:System.ServiceModel.NetMsmqBinding> binding supports durable services and clients, in which an application can restart in the middle of communication and pick up where it left off without missing any messages. (For more information, see [Queues in WCF](../../../docs/framework/wcf/feature-details/queues-in-wcf.md).) However, durable operations must take only one `in` parameter and have no return value.  \n  \n Another example is the use of <xref:System.IO.Stream> types in operations. Because the <xref:System.IO.Stream> parameter includes the entire message body, if an input or an output (that is, `ref` parameter, `out` parameter, or return value) is of type <xref:System.IO.Stream>, then it must be the only input or output specified in your operation. In addition, the parameter or return type must be either <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType>, or <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>. For more information about streams, see [Large Data and Streaming](../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  \n  \n##### Names, Namespaces, and Obfuscation  \n The names and namespaces of the .NET types in the definition of contracts and operations are significant when contracts are converted into WSDL and when contract messages are created and sent. Therefore, it is strongly recommended that service contract names and namespaces are explicitly set using the `Name` and `Namespace` properties of all supporting contract attributes such as the <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>,  <xref:System.Runtime.Serialization.DataMemberAttribute>, and other contract attributes.  \n  \n One result of this is that if the names and namespaces are not explicitly set, the use of IL obfuscation on the assembly alters the contract type names and namespaces and results in modified WSDL and wire exchanges that typically fail. If you do not set the contract names and namespaces explicitly but do intend to use obfuscation, use the <xref:System.Reflection.ObfuscationAttribute> and <xref:System.Reflection.ObfuscateAssemblyAttribute> attributes to prevent the modification of the contract type names and namespaces.  \n  \n## See also\n\n- [How to: Create a Request-Reply Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md)\n- [How to: Create a One-Way Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md)\n- [How to: Create a Duplex Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md)\n- [Specifying Data Transfer in Service Contracts](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)\n- [Specifying and Handling Faults in Contracts and Services](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)\n- [Using Sessions](../../../docs/framework/wcf/using-sessions.md)\n- [Synchronous and Asynchronous Operations](../../../docs/framework/wcf/synchronous-and-asynchronous-operations.md)\n- [Reliable Services](../../../docs/framework/wcf/reliable-services.md)\n- [Services and Transactions](../../../docs/framework/wcf/services-and-transactions.md)\n","nodes":[{"pos":[4,197],"embed":true,"restype":"x-metadata","content":"title: \"Designing Service Contracts\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"service contracts [WCF]\"\nms.assetid: 8e89cbb9-ac84-4f0d-85ef-0eb6be0022fd","nodes":[{"content":"Designing Service Contracts","nodes":[{"pos":[0,27],"content":"Designing Service Contracts","nodes":[{"content":"Designing Service Contracts","pos":[0,27]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[204,231],"content":"Designing Service Contracts","linkify":"Designing Service Contracts","nodes":[{"content":"Designing Service Contracts","pos":[0,27]}]},{"content":"This topic describes what service contracts are, how they are defined, what operations are available (and the implications for the underlying message exchanges), what data types are used, and other issues that help you design operations that satisfy the requirements of your scenario.","pos":[232,516]},{"pos":[525,552],"content":"Creating a Service Contract","linkify":"Creating a Service Contract","nodes":[{"content":"Creating a Service Contract","pos":[0,27]}]},{"content":"Services expose a number of operations.","pos":[556,595]},{"content":"In Windows Communication Foundation (WCF) applications, define the operations by creating a method and marking it with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> attribute.","pos":[596,783],"source":" In Windows Communication Foundation (WCF) applications, define the operations by creating a method and marking it with the <xref:System.ServiceModel.OperationContractAttribute> attribute."},{"content":"Then, to create a service contract, group together your operations, either by declaring them within an interface marked with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceContractAttribute&gt;</ph> attribute, or by defining them in a class marked with the same attribute.","pos":[784,1038],"source":" Then, to create a service contract, group together your operations, either by declaring them within an interface marked with the <xref:System.ServiceModel.ServiceContractAttribute> attribute, or by defining them in a class marked with the same attribute."},{"content":"(For a basic example, see <bpt id=\"p1\">[</bpt>How to: Define a Service Contract<ept id=\"p1\">](../../../docs/framework/wcf/how-to-define-a-wcf-service-contract.md)</ept>.)","pos":[1039,1171],"source":" (For a basic example, see [How to: Define a Service Contract](../../../docs/framework/wcf/how-to-define-a-wcf-service-contract.md).)"},{"pos":[1178,1336],"content":"Any methods that do not have a <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> attribute are not service operations and are not exposed by WCF services.","source":"Any methods that do not have a <xref:System.ServiceModel.OperationContractAttribute> attribute are not service operations and are not exposed by WCF services."},{"content":"This topic describes the following decision points when designing a service contract:","pos":[1343,1428]},{"content":"Whether to use classes or interfaces.","pos":[1438,1475]},{"content":"How to specify the data types you want to exchange.","pos":[1485,1536]},{"content":"The types of exchange patterns you can use.","pos":[1546,1589]},{"content":"Whether you can make explicit security requirements part of the contract.","pos":[1599,1672]},{"content":"The restrictions for operation inputs and outputs.","pos":[1682,1732]},{"pos":[1741,1762],"content":"Classes or Interfaces","linkify":"Classes or Interfaces","nodes":[{"content":"Classes or Interfaces","pos":[0,21]}]},{"content":"Both classes and interfaces represent a grouping of functionality and, therefore, both can be used to define a WCF service contract.","pos":[1766,1898]},{"content":"However, it is recommended that you use interfaces because they directly model service contracts.","pos":[1899,1996]},{"content":"Without an implementation, interfaces do no more than define a grouping of methods with certain signatures.","pos":[1997,2104]},{"content":"Implement a service contract interface and you have implemented a WCF service.","pos":[2105,2183]},{"content":"All the benefits of managed interfaces apply to service contract interfaces:","pos":[2190,2266]},{"content":"Service contract interfaces can extend any number of other service contract interfaces.","pos":[2276,2363]},{"content":"A single class can implement any number of service contracts by implementing those service contract interfaces.","pos":[2373,2484]},{"content":"You can modify the implementation of a service contract by changing the interface implementation, while the service contract remains the same.","pos":[2494,2636]},{"content":"You can version your service by implementing the old interface and the new one.","pos":[2646,2725]},{"content":"Old clients connect to the original version, while newer clients can connect to the newer version.","pos":[2726,2824]},{"pos":[2832,3056],"content":"[!NOTE]\n When inheriting from other service contract interfaces, you cannot override operation properties, such as the name or namespace. If you attempt to do so, you create a new operation in the current service contract.","leadings":["","> "],"nodes":[{"content":"When inheriting from other service contract interfaces, you cannot override operation properties, such as the name or namespace. If you attempt to do so, you create a new operation in the current service contract.","pos":[9,222],"nodes":[{"content":"When inheriting from other service contract interfaces, you cannot override operation properties, such as the name or namespace.","pos":[0,128]},{"content":"If you attempt to do so, you create a new operation in the current service contract.","pos":[129,213]}]}]},{"pos":[3063,3285],"content":"For an example of using an interface to create a service contract, see <bpt id=\"p1\">[</bpt>How to: Create a Service with a Contract Interface<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-service-with-a-contract-interface.md)</ept>.","source":"For an example of using an interface to create a service contract, see [How to: Create a Service with a Contract Interface](../../../docs/framework/wcf/feature-details/how-to-create-a-service-with-a-contract-interface.md)."},{"content":"You can, however, use a class to define a service contract and implement that contract at the same time.","pos":[3292,3396]},{"content":"The advantage of creating your services by applying <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceContractAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> directly to the class and the methods on the class, respectively, is speed and simplicity.","pos":[3397,3649],"source":" The advantage of creating your services by applying <xref:System.ServiceModel.ServiceContractAttribute> and <xref:System.ServiceModel.OperationContractAttribute> directly to the class and the methods on the class, respectively, is speed and simplicity."},{"content":"The disadvantages are that managed classes do not support multiple inheritance, and as a result they can only implement one service contract at a time.","pos":[3650,3801]},{"content":"In addition, any modification to the class or method signatures modifies the public contract for that service, which can prevent unmodified clients from using your service.","pos":[3802,3974]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Implementing Service Contracts<ept id=\"p1\">](../../../docs/framework/wcf/implementing-service-contracts.md)</ept>.","pos":[3975,4097],"source":" For more information, see [Implementing Service Contracts](../../../docs/framework/wcf/implementing-service-contracts.md)."},{"pos":[4104,4345],"content":"For an example that uses a class to create a service contract and implements it at the same time, see <bpt id=\"p1\">[</bpt>How to: Create a Service with a Contract Class<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-wcf-contract-with-a-class.md)</ept>.","source":"For an example that uses a class to create a service contract and implements it at the same time, see [How to: Create a Service with a Contract Class](../../../docs/framework/wcf/feature-details/how-to-create-a-wcf-contract-with-a-class.md)."},{"content":"At this point, you should understand the difference between defining your service contract by using an interface and by using a class.","pos":[4352,4486]},{"content":"The next step is deciding what data can be passed back and forth between a service and its clients.","pos":[4487,4586]},{"pos":[4595,4623],"content":"Parameters and Return Values","linkify":"Parameters and Return Values","nodes":[{"content":"Parameters and Return Values","pos":[0,28]}]},{"content":"Each operation has a return value and a parameter, even if these are <ph id=\"ph1\">`void`</ph>.","pos":[4627,4703],"source":"Each operation has a return value and a parameter, even if these are `void`."},{"content":"However, unlike a local method, in which you can pass references to objects from one object to another, service operations do not pass references to objects.","pos":[4704,4861]},{"content":"Instead, they pass copies of the objects.","pos":[4862,4903]},{"content":"This is significant because each type used in a parameter or return value must be serializable; that is, it must be possible to convert an object of that type into a stream of bytes and from a stream of bytes into an object.","pos":[4910,5134]},{"content":"Primitive types are serializable by default, as are many types in the .NET Framework.","pos":[5141,5226]},{"pos":[5234,5542],"content":"[!NOTE]\n The value of the parameter names in the operation signature are part of the contract and are case sensitive. If you want to use the same parameter name locally but modify the name in the published metadata, see the <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.","leadings":["","> "],"nodes":[{"content":"The value of the parameter names in the operation signature are part of the contract and are case sensitive. If you want to use the same parameter name locally but modify the name in the published metadata, see the <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.","pos":[9,306],"nodes":[{"content":"The value of the parameter names in the operation signature are part of the contract and are case sensitive.","pos":[0,108]},{"content":"If you want to use the same parameter name locally but modify the name in the published metadata, see the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType&gt;</ph>.","pos":[109,297],"source":" If you want to use the same parameter name locally but modify the name in the published metadata, see the <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>."}]}]},{"pos":[5553,5567],"content":"Data Contracts","linkify":"Data Contracts","nodes":[{"content":"Data Contracts","pos":[0,14]}]},{"content":"Service-oriented applications like Windows Communication Foundation (WCF) applications are designed to interoperate with the widest possible number of client applications on both Microsoft and non-Microsoft platforms.","pos":[5571,5788]},{"content":"For the widest possible interoperability, it is recommended that you mark your types with the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attributes to create a data contract, which is the portion of the service contract that describes the data that your service operations exchange.","pos":[5789,6146],"source":" For the widest possible interoperability, it is recommended that you mark your types with the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create a data contract, which is the portion of the service contract that describes the data that your service operations exchange."},{"content":"Data contracts are opt-in style contracts: No type or data member is serialized unless you explicitly apply the data contract attribute.","pos":[6153,6289]},{"content":"Data contracts are unrelated to the access scope of the managed code: Private data members can be serialized and sent elsewhere to be accessed publicly.","pos":[6290,6442]},{"content":"(For a basic example of a data contract, see <bpt id=\"p1\">[</bpt>How to: Create a Basic Data Contract for a Class or Structure<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md)</ept>.) WCF handles the definition of the underlying SOAP messages that enable the operation's functionality as well as the serialization of your data types into and out of the body of the messages.","pos":[6443,6853],"source":" (For a basic example of a data contract, see [How to: Create a Basic Data Contract for a Class or Structure](../../../docs/framework/wcf/feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md).) WCF handles the definition of the underlying SOAP messages that enable the operation's functionality as well as the serialization of your data types into and out of the body of the messages."},{"content":"As long as your data types are serializable, you do not need to think about the underlying message exchange infrastructure when designing your operations.","pos":[6854,7008]},{"content":"Although the typical WCF application uses the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attributes to create data contracts for operations, you can use other serialization mechanisms.","pos":[7015,7274],"source":"Although the typical WCF application uses the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create data contracts for operations, you can use other serialization mechanisms."},{"content":"The standard <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.SerializableAttribute&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> mechanisms all work to handle the serialization of your data types into the underlying SOAP messages that carry them from one application to another.","pos":[7275,7577],"source":" The standard <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> and <xref:System.Xml.Serialization.IXmlSerializable> mechanisms all work to handle the serialization of your data types into the underlying SOAP messages that carry them from one application to another."},{"content":"You can employ more serialization strategies if your data types require special support.","pos":[7578,7666]},{"content":"For more information about the choices for serialization of data types in WCF applications, see <bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>.","pos":[7667,7905],"source":" For more information about the choices for serialization of data types in WCF applications, see [Specifying Data Transfer in Service Contracts](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)."},{"pos":[7916,7973],"content":"Mapping Parameters and Return Values to Message Exchanges","linkify":"Mapping Parameters and Return Values to Message Exchanges","nodes":[{"content":"Mapping Parameters and Return Values to Message Exchanges","pos":[0,57]}]},{"content":"Service operations are supported by an underlying exchange of SOAP messages that transfer application data back and forth, in addition to the data required by the application to support certain standard security, transaction, and session-related features.","pos":[7977,8232]},{"content":"Because this is the case, the signature of a service operation dictates a certain underlying <bpt id=\"p1\">*</bpt>message exchange pattern<ept id=\"p1\">*</ept> (MEP) that can support the data transfer and the features an operation requires.","pos":[8233,8433],"source":" Because this is the case, the signature of a service operation dictates a certain underlying *message exchange pattern* (MEP) that can support the data transfer and the features an operation requires."},{"content":"You can specify three patterns in the WCF programming model: request/reply, one-way, and duplex message patterns.","pos":[8434,8547]},{"pos":[8559,8572],"content":"Request/Reply","linkify":"Request/Reply","nodes":[{"content":"Request/Reply","pos":[0,13]}]},{"content":"A request/reply pattern is one in which a request sender (a client application) receives a reply with which the request is correlated.","pos":[8576,8710]},{"content":"This is the default MEP because it supports an operation in which one or more parameters are passed to the operation and a return value is passed back to the caller.","pos":[8711,8876]},{"content":"For example, the following C# code example shows a basic service operation that takes one string and returns a string.","pos":[8877,8995]},{"content":"The following is the equivalent Visual Basic code.","pos":[9087,9137]},{"content":"This operation signature dictates the form of underlying message exchange.","pos":[9248,9322]},{"content":"If no correlation existed, WCF cannot determine for which operation the return value is intended.","pos":[9323,9420]},{"content":"Note that unless you specify a different underlying message pattern, even service operations that return <ph id=\"ph1\">`void`</ph> (<ph id=\"ph2\">`Nothing`</ph> in Visual Basic) are request/reply message exchanges.","pos":[9427,9603],"source":"Note that unless you specify a different underlying message pattern, even service operations that return `void` (`Nothing` in Visual Basic) are request/reply message exchanges."},{"content":"The result for your operation is that unless a client invokes the operation asynchronously, the client stops processing until the return message is received, even though that message is empty in the normal case.","pos":[9604,9815]},{"content":"The following C# code example shows an operation that does not return until the client has received an empty message in response.","pos":[9816,9945]},{"content":"The following is the equivalent Visual Basic code.","pos":[10035,10085]},{"content":"The preceding example can slow client performance and responsiveness if the operation takes a long time to perform, but there are advantages to request/reply operations even when they return <ph id=\"ph1\">`void`</ph>.","pos":[10181,10379],"source":"The preceding example can slow client performance and responsiveness if the operation takes a long time to perform, but there are advantages to request/reply operations even when they return `void`."},{"content":"The most obvious one is that SOAP faults can be returned in the response message, which indicates that some service-related error condition has occurred, whether in communication or processing.","pos":[10380,10573]},{"content":"SOAP faults that are specified in a service contract are passed to the client application as a <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException%601&gt;</ph> object, where the type parameter is the type specified in the service contract.","pos":[10574,10794],"source":" SOAP faults that are specified in a service contract are passed to the client application as a <xref:System.ServiceModel.FaultException%601> object, where the type parameter is the type specified in the service contract."},{"content":"This makes notifying clients about error conditions in WCF services easy.","pos":[10795,10868]},{"content":"For more information about exceptions, SOAP faults, and error handling, see <bpt id=\"p1\">[</bpt>Specifying and Handling Faults in Contracts and Services<ept id=\"p1\">](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)</ept>.","pos":[10869,11093],"source":" For more information about exceptions, SOAP faults, and error handling, see [Specifying and Handling Faults in Contracts and Services](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)."},{"content":"To see an example of a request/reply service and client, see <bpt id=\"p1\">[</bpt>How to: Create a Request-Reply Contract<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md)</ept>.","pos":[11094,11284],"source":" To see an example of a request/reply service and client, see [How to: Create a Request-Reply Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md)."},{"content":"For more information about issues with the request-reply pattern, see <bpt id=\"p1\">[</bpt>Request-Reply Services<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/request-reply-services.md)</ept>.","pos":[11285,11451],"source":" For more information about issues with the request-reply pattern, see [Request-Reply Services](../../../docs/framework/wcf/feature-details/request-reply-services.md)."},{"pos":[11463,11470],"content":"One-way","linkify":"One-way","nodes":[{"content":"One-way","pos":[0,7]}]},{"content":"If the client of a WCF service application should not wait for the operation to complete and does not process SOAP faults, the operation can specify a one-way message pattern.","pos":[11474,11649]},{"content":"A one-way operation is one in which a client invokes an operation and continues processing after WCF writes the message to the network.","pos":[11650,11785]},{"content":"Typically this means that unless the data being sent in the outbound message is extremely large the client continues running almost immediately (unless there is an error sending the data).","pos":[11786,11974]},{"content":"This type of message exchange pattern supports event-like behavior from a client to a service application.","pos":[11975,12081]},{"pos":[12088,12318],"content":"A message exchange in which one message is sent and none are received cannot support a service operation that specifies a return value other than <ph id=\"ph1\">`void`</ph>; in this case an <ph id=\"ph2\">&lt;xref:System.InvalidOperationException&gt;</ph> exception is thrown.","source":"A message exchange in which one message is sent and none are received cannot support a service operation that specifies a return value other than `void`; in this case an <xref:System.InvalidOperationException> exception is thrown."},{"content":"No return message also means that there can be no SOAP fault returned to indicate any errors in processing or communication.","pos":[12325,12449]},{"content":"(Communicating error information when operations are one-way operations requires a duplex message exchange pattern.)","pos":[12450,12566]},{"pos":[12573,12779],"content":"To specify a one-way message exchange for an operation that returns <ph id=\"ph1\">`void`</ph>, set the <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A&gt;</ph> property to <ph id=\"ph3\">`true`</ph>, as in the following C# code example.","source":"To specify a one-way message exchange for an operation that returns `void`, set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as in the following C# code example."},{"content":"The following is the equivalent Visual Basic code.","pos":[12884,12934]},{"content":"This method is identical to the preceding request/reply example, but setting the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A&gt;</ph> property to <ph id=\"ph2\">`true`</ph> means that although the method is identical, the service operation does not send a return message and clients return immediately once the outbound message has been handed to the channel layer.","pos":[13046,13404],"source":"This method is identical to the preceding request/reply example, but setting the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true` means that although the method is identical, the service operation does not send a return message and clients return immediately once the outbound message has been handed to the channel layer."},{"content":"For an example, see <bpt id=\"p1\">[</bpt>How to: Create a One-Way Contract<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md)</ept>.","pos":[13405,13542],"source":" For an example, see [How to: Create a One-Way Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md)."},{"content":"For more information about the one-way pattern, see <bpt id=\"p1\">[</bpt>One-Way Services<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/one-way-services.md)</ept>.","pos":[13543,13679],"source":" For more information about the one-way pattern, see [One-Way Services](../../../docs/framework/wcf/feature-details/one-way-services.md)."},{"pos":[13691,13697],"content":"Duplex","linkify":"Duplex","nodes":[{"content":"Duplex","pos":[0,6]}]},{"content":"A duplex pattern is characterized by the ability of both the service and the client to send messages to each other independently whether using one-way or request/reply messaging.","pos":[13701,13879]},{"content":"This form of two-way communication is useful for services that must communicate directly to the client or for providing an asynchronous experience to either side of a message exchange, including event-like behavior.","pos":[13880,14095]},{"content":"The duplex pattern is slightly more complex than the request/reply or one-way patterns because of the additional mechanism for communicating with the client.","pos":[14102,14259]},{"pos":[14266,14572],"content":"To design a duplex contract, you must also design a callback contract and assign the type of that callback contract to the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceContractAttribute&gt;</ph> attribute that marks your service contract.","source":"To design a duplex contract, you must also design a callback contract and assign the type of that callback contract to the <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> property of the <xref:System.ServiceModel.ServiceContractAttribute> attribute that marks your service contract."},{"content":"To implement a duplex pattern, you must create a second interface that contains the method declarations that are called on the client.","pos":[14579,14713]},{"content":"For an example of creating a service, and a client that accesses that service, see <bpt id=\"p1\">[</bpt>How to: Create a Duplex Contract<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Access Services with a Duplex Contract<ept id=\"p2\">](../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md)</ept>.","pos":[14720,15065],"source":"For an example of creating a service, and a client that accesses that service, see [How to: Create a Duplex Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md) and [How to: Access Services with a Duplex Contract](../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md)."},{"content":"For a working sample, see <bpt id=\"p1\">[</bpt>Duplex<ept id=\"p1\">](../../../docs/framework/wcf/samples/duplex.md)</ept>.","pos":[15066,15148],"source":" For a working sample, see [Duplex](../../../docs/framework/wcf/samples/duplex.md)."},{"content":"For more information about issues using duplex contracts, see <bpt id=\"p1\">[</bpt>Duplex Services<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/duplex-services.md)</ept>.","pos":[15149,15293],"source":" For more information about issues using duplex contracts, see [Duplex Services](../../../docs/framework/wcf/feature-details/duplex-services.md)."},{"pos":[15301,15672],"content":"[!CAUTION]\n When a service receives a duplex message, it looks at the `ReplyTo` element in that incoming message to determine where to send the reply. If the channel that is used to receive the message is not secured, then an untrusted client could send a malicious message with a target machine's `ReplyTo`, leading to a denial of service (DOS) of that target machine.","leadings":["","> "],"nodes":[{"content":"When a service receives a duplex message, it looks at the `ReplyTo` element in that incoming message to determine where to send the reply. If the channel that is used to receive the message is not secured, then an untrusted client could send a malicious message with a target machine's `ReplyTo`, leading to a denial of service (DOS) of that target machine.","pos":[12,369],"nodes":[{"content":"When a service receives a duplex message, it looks at the <ph id=\"ph1\">`ReplyTo`</ph> element in that incoming message to determine where to send the reply.","pos":[0,138],"source":"When a service receives a duplex message, it looks at the `ReplyTo` element in that incoming message to determine where to send the reply."},{"content":"If the channel that is used to receive the message is not secured, then an untrusted client could send a malicious message with a target machine's <ph id=\"ph1\">`ReplyTo`</ph>, leading to a denial of service (DOS) of that target machine.","pos":[139,357],"source":" If the channel that is used to receive the message is not secured, then an untrusted client could send a malicious message with a target machine's `ReplyTo`, leading to a denial of service (DOS) of that target machine."}]}]},{"pos":[15684,15706],"content":"Out and Ref Parameters","linkify":"Out and Ref Parameters","nodes":[{"content":"Out and Ref Parameters","pos":[0,22]}]},{"content":"In most cases, you can use <ph id=\"ph1\">`in`</ph> parameters (<ph id=\"ph2\">`ByVal`</ph> in Visual Basic) and <ph id=\"ph3\">`out`</ph> and <ph id=\"ph4\">`ref`</ph> parameters (<ph id=\"ph5\">`ByRef`</ph> in Visual Basic).","pos":[15710,15836],"source":"In most cases, you can use `in` parameters (`ByVal` in Visual Basic) and `out` and `ref` parameters (`ByRef` in Visual Basic)."},{"content":"Because both <ph id=\"ph1\">`out`</ph> and <ph id=\"ph2\">`ref`</ph> parameters indicate that data is returned from an operation, an operation signature such as the following specifies that a request/reply operation is required even though the operation signature returns <ph id=\"ph3\">`void`</ph>.","pos":[15837,16076],"source":" Because both `out` and `ref` parameters indicate that data is returned from an operation, an operation signature such as the following specifies that a request/reply operation is required even though the operation signature returns `void`."},{"content":"The following is the equivalent Visual Basic code.","pos":[16260,16310]},{"content":"The only exceptions are those cases in which your signature has a particular structure.","pos":[16509,16596]},{"content":"For example, you can use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.NetMsmqBinding&gt;</ph> binding to communicate with clients only if the method used to declare an operation returns <ph id=\"ph2\">`void`</ph>; there can be no output value, whether it is a return value, <ph id=\"ph3\">`ref`</ph>, or <ph id=\"ph4\">`out`</ph> parameter.","pos":[16597,16854],"source":" For example, you can use the <xref:System.ServiceModel.NetMsmqBinding> binding to communicate with clients only if the method used to declare an operation returns `void`; there can be no output value, whether it is a return value, `ref`, or `out` parameter."},{"content":"In addition, using <ph id=\"ph1\">`out`</ph> or <ph id=\"ph2\">`ref`</ph> parameters requires that the operation have an underlying response message to carry back the modified object.","pos":[16861,17004],"source":"In addition, using `out` or `ref` parameters requires that the operation have an underlying response message to carry back the modified object."},{"content":"If your operation is a one-way operation, an <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> exception is thrown at runtime.","pos":[17005,17121],"source":" If your operation is a one-way operation, an <xref:System.InvalidOperationException> exception is thrown at runtime."},{"pos":[17131,17179],"content":"Specify Message Protection Level on the Contract","linkify":"Specify Message Protection Level on the Contract","nodes":[{"content":"Specify Message Protection Level on the Contract","pos":[0,48]}]},{"content":"When designing your contract, you must also decide the message protection level of services that implement your contract.","pos":[17183,17304]},{"content":"This is necessary only if message security is applied to the binding in the contract's endpoint.","pos":[17305,17401]},{"content":"If the binding has security turned off (that is, if the system-provided binding sets the <ph id=\"ph1\">&lt;xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType&gt;</ph> to the value <ph id=\"ph2\">&lt;xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType&gt;</ph>) then you do not have to decide on the message protection level for the contract.","pos":[17402,17728],"source":" If the binding has security turned off (that is, if the system-provided binding sets the <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> to the value <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>) then you do not have to decide on the message protection level for the contract."},{"content":"In most cases, system-provided bindings with message-level security applied provide a sufficient protection level and you do not have to consider the protection level for each operation or for each message.","pos":[17729,17935]},{"content":"The protection level is a value that specifies whether the messages (or message parts) that support a service are signed, signed and encrypted, or sent without signatures or encryption.","pos":[17942,18127]},{"content":"The protection level can be set at various scopes: At the service level, for a particular operation, for a message within that operation, or a message part.","pos":[18128,18284]},{"content":"Values set at one scope become the default value for smaller scopes unless explicitly overridden.","pos":[18285,18382]},{"content":"If a binding configuration cannot provide the required minimum protection level for the contract, an exception is thrown.","pos":[18383,18504]},{"content":"And when no protection level values are explicitly set on the contract, the binding configuration controls the protection level for all messages if the binding has message security.","pos":[18505,18686]},{"content":"This is the default behavior.","pos":[18687,18716]},{"pos":[18724,19224],"content":"[!IMPORTANT]\n Deciding whether to explicitly set various scopes of a contract to less than the full protection level of <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> is generally a decision that trades some degree of security for increased performance. In these cases, your decisions must revolve around your operations and the value of the data they exchange. For more information, see [Securing Services](../../../docs/framework/wcf/securing-services.md).","leadings":["","> "],"nodes":[{"content":"Deciding whether to explicitly set various scopes of a contract to less than the full protection level of <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> is generally a decision that trades some degree of security for increased performance. In these cases, your decisions must revolve around your operations and the value of the data they exchange. For more information, see [Securing Services](../../../docs/framework/wcf/securing-services.md).","pos":[14,498],"nodes":[{"content":"Deciding whether to explicitly set various scopes of a contract to less than the full protection level of <ph id=\"ph1\">&lt;xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType&gt;</ph> is generally a decision that trades some degree of security for increased performance.","pos":[0,279],"source":"Deciding whether to explicitly set various scopes of a contract to less than the full protection level of <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> is generally a decision that trades some degree of security for increased performance."},{"content":"In these cases, your decisions must revolve around your operations and the value of the data they exchange.","pos":[280,387]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Securing Services<ept id=\"p1\">](../../../docs/framework/wcf/securing-services.md)</ept>.","pos":[388,484],"source":" For more information, see [Securing Services](../../../docs/framework/wcf/securing-services.md)."}]}]},{"pos":[19231,19471],"content":"For example, the following code example does not set either the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A&gt;</ph> property on the contract.","source":"For example, the following code example does not set either the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> or the <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> property on the contract."},{"content":"The following is the equivalent Visual Basic code.","pos":[19688,19738]},{"content":"When interacting with an <ph id=\"ph1\">`ISampleService`</ph> implementation in an endpoint with a default <ph id=\"ph2\">&lt;xref:System.ServiceModel.WSHttpBinding&gt;</ph> (the default <ph id=\"ph3\">&lt;xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType&gt;</ph>, which is <ph id=\"ph4\">&lt;xref:System.ServiceModel.SecurityMode.Message&gt;</ph>), all messages are encrypted and signed because this is the default protection level.","pos":[20010,20363],"source":"When interacting with an `ISampleService` implementation in an endpoint with a default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>), all messages are encrypted and signed because this is the default protection level."},{"content":"However, when an <ph id=\"ph1\">`ISampleService`</ph> service is used with a default <ph id=\"ph2\">&lt;xref:System.ServiceModel.BasicHttpBinding&gt;</ph> (the default <ph id=\"ph3\">&lt;xref:System.ServiceModel.SecurityMode&gt;</ph>, which is <ph id=\"ph4\">&lt;xref:System.ServiceModel.SecurityMode.None&gt;</ph>), all messages are sent as text because there is no security for this binding and so the protection level is ignored (that is, the messages are neither encrypted nor signed).","pos":[20364,20755],"source":" However, when an `ISampleService` service is used with a default <xref:System.ServiceModel.BasicHttpBinding> (the default <xref:System.ServiceModel.SecurityMode>, which is <xref:System.ServiceModel.SecurityMode.None>), all messages are sent as text because there is no security for this binding and so the protection level is ignored (that is, the messages are neither encrypted nor signed)."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.ServiceModel.SecurityMode&gt;</ph> was changed to <ph id=\"ph2\">&lt;xref:System.ServiceModel.SecurityMode.Message&gt;</ph>, then these messages would be encrypted and signed (because that would now be the binding's default protection level).","pos":[20756,20984],"source":" If the <xref:System.ServiceModel.SecurityMode> was changed to <xref:System.ServiceModel.SecurityMode.Message>, then these messages would be encrypted and signed (because that would now be the binding's default protection level)."},{"content":"If you want to explicitly specify or adjust the protection requirements for your contract, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A&gt;</ph> property (or any of the <ph id=\"ph2\">`ProtectionLevel`</ph> properties at a smaller scope) to the level your service contract requires.","pos":[20991,21278],"source":"If you want to explicitly specify or adjust the protection requirements for your contract, set the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> property (or any of the `ProtectionLevel` properties at a smaller scope) to the level your service contract requires."},{"content":"In this case, using an explicit setting requires the binding to support that setting at a minimum for the scope used.","pos":[21279,21396]},{"content":"For example, the following code example specifies one <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A&gt;</ph> value explicitly, for the <ph id=\"ph2\">`GetGuid`</ph> operation.","pos":[21397,21570],"source":" For example, the following code example specifies one <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> value explicitly, for the `GetGuid` operation."},{"content":"The following is the equivalent Visual Basic code.","pos":[21957,22007]},{"pos":[22521,22852],"content":"A service that implements this <ph id=\"ph1\">`IExplicitProtectionLevelSampleService`</ph> contract and has an endpoint that uses the default <ph id=\"ph2\">&lt;xref:System.ServiceModel.WSHttpBinding&gt;</ph> (the default <ph id=\"ph3\">&lt;xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType&gt;</ph>, which is <ph id=\"ph4\">&lt;xref:System.ServiceModel.SecurityMode.Message&gt;</ph>) has the following behavior:","source":"A service that implements this `IExplicitProtectionLevelSampleService` contract and has an endpoint that uses the default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>) has the following behavior:"},{"pos":[22862,22922],"content":"The <ph id=\"ph1\">`GetString`</ph> operation messages are encrypted and signed.","source":"The `GetString` operation messages are encrypted and signed."},{"pos":[22932,23023],"content":"The <ph id=\"ph1\">`GetInt`</ph> operation messages are sent as unencrypted and unsigned (that is, plain) text.","source":"The `GetInt` operation messages are sent as unencrypted and unsigned (that is, plain) text."},{"pos":[23033,23159],"content":"The <ph id=\"ph1\">`GetGuid`</ph> operation <ph id=\"ph2\">&lt;xref:System.Guid?displayProperty=nameWithType&gt;</ph> is returned in a message that is encrypted and signed.","source":"The `GetGuid` operation <xref:System.Guid?displayProperty=nameWithType> is returned in a message that is encrypted and signed."},{"content":"For more information about protection levels and how to use them, see <bpt id=\"p1\">[</bpt>Understanding Protection Level<ept id=\"p1\">](../../../docs/framework/wcf/understanding-protection-level.md)</ept>.","pos":[23166,23332],"source":"For more information about protection levels and how to use them, see [Understanding Protection Level](../../../docs/framework/wcf/understanding-protection-level.md)."},{"content":"For more information about security, see <bpt id=\"p1\">[</bpt>Securing Services<ept id=\"p1\">](../../../docs/framework/wcf/securing-services.md)</ept>.","pos":[23333,23444],"source":" For more information about security, see [Securing Services](../../../docs/framework/wcf/securing-services.md)."},{"pos":[23456,23494],"content":"Other Operation Signature Requirements","linkify":"Other Operation Signature Requirements","nodes":[{"content":"Other Operation Signature Requirements","pos":[0,38]}]},{"content":"Some application features require a particular kind of operation signature.","pos":[23498,23573]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.NetMsmqBinding&gt;</ph> binding supports durable services and clients, in which an application can restart in the middle of communication and pick up where it left off without missing any messages.","pos":[23574,23806],"source":" For example, the <xref:System.ServiceModel.NetMsmqBinding> binding supports durable services and clients, in which an application can restart in the middle of communication and pick up where it left off without missing any messages."},{"content":"(For more information, see <bpt id=\"p1\">[</bpt>Queues in WCF<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/queues-in-wcf.md)</ept>.) However, durable operations must take only one <ph id=\"ph1\">`in`</ph> parameter and have no return value.","pos":[23807,24001],"source":" (For more information, see [Queues in WCF](../../../docs/framework/wcf/feature-details/queues-in-wcf.md).) However, durable operations must take only one `in` parameter and have no return value."},{"content":"Another example is the use of <ph id=\"ph1\">&lt;xref:System.IO.Stream&gt;</ph> types in operations.","pos":[24008,24082],"source":"Another example is the use of <xref:System.IO.Stream> types in operations."},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.IO.Stream&gt;</ph> parameter includes the entire message body, if an input or an output (that is, <ph id=\"ph2\">`ref`</ph> parameter, <ph id=\"ph3\">`out`</ph> parameter, or return value) is of type <ph id=\"ph4\">&lt;xref:System.IO.Stream&gt;</ph>, then it must be the only input or output specified in your operation.","pos":[24083,24354],"source":" Because the <xref:System.IO.Stream> parameter includes the entire message body, if an input or an output (that is, `ref` parameter, `out` parameter, or return value) is of type <xref:System.IO.Stream>, then it must be the only input or output specified in your operation."},{"content":"In addition, the parameter or return type must be either <ph id=\"ph1\">&lt;xref:System.IO.Stream&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType&gt;</ph>.","pos":[24355,24592],"source":" In addition, the parameter or return type must be either <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType>, or <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>."},{"content":"For more information about streams, see <bpt id=\"p1\">[</bpt>Large Data and Streaming<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)</ept>.","pos":[24593,24733],"source":" For more information about streams, see [Large Data and Streaming](../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)."},{"pos":[24745,24779],"content":"Names, Namespaces, and Obfuscation","linkify":"Names, Namespaces, and Obfuscation","nodes":[{"content":"Names, Namespaces, and Obfuscation","pos":[0,34]}]},{"content":"The names and namespaces of the .NET types in the definition of contracts and operations are significant when contracts are converted into WSDL and when contract messages are created and sent.","pos":[24783,24975]},{"content":"Therefore, it is strongly recommended that service contract names and namespaces are explicitly set using the <ph id=\"ph1\">`Name`</ph> and <ph id=\"ph2\">`Namespace`</ph> properties of all supporting contract attributes such as the <ph id=\"ph3\">&lt;xref:System.ServiceModel.ServiceContractAttribute&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph>,  <ph id=\"ph6\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph>, and other contract attributes.","pos":[24976,25425],"source":" Therefore, it is strongly recommended that service contract names and namespaces are explicitly set using the `Name` and `Namespace` properties of all supporting contract attributes such as the <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>,  <xref:System.Runtime.Serialization.DataMemberAttribute>, and other contract attributes."},{"content":"One result of this is that if the names and namespaces are not explicitly set, the use of IL obfuscation on the assembly alters the contract type names and namespaces and results in modified WSDL and wire exchanges that typically fail.","pos":[25432,25667]},{"content":"If you do not set the contract names and namespaces explicitly but do intend to use obfuscation, use the <ph id=\"ph1\">&lt;xref:System.Reflection.ObfuscationAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.ObfuscateAssemblyAttribute&gt;</ph> attributes to prevent the modification of the contract type names and namespaces.","pos":[25668,25956],"source":" If you do not set the contract names and namespaces explicitly but do intend to use obfuscation, use the <xref:System.Reflection.ObfuscationAttribute> and <xref:System.Reflection.ObfuscateAssemblyAttribute> attributes to prevent the modification of the contract type names and namespaces."},{"pos":[25965,25973],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[25977,26105],"content":"<bpt id=\"p1\">[</bpt>How to: Create a Request-Reply Contract<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md)</ept>","source":"[How to: Create a Request-Reply Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md)"},{"pos":[26108,26224],"content":"<bpt id=\"p1\">[</bpt>How to: Create a One-Way Contract<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md)</ept>","source":"[How to: Create a One-Way Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md)"},{"pos":[26227,26341],"content":"<bpt id=\"p1\">[</bpt>How to: Create a Duplex Contract<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md)</ept>","source":"[How to: Create a Duplex Contract](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md)"},{"pos":[26344,26485],"content":"<bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>","source":"[Specifying Data Transfer in Service Contracts](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)"},{"pos":[26488,26635],"content":"<bpt id=\"p1\">[</bpt>Specifying and Handling Faults in Contracts and Services<ept id=\"p1\">](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)</ept>","source":"[Specifying and Handling Faults in Contracts and Services](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)"},{"pos":[26638,26701],"content":"<bpt id=\"p1\">[</bpt>Using Sessions<ept id=\"p1\">](../../../docs/framework/wcf/using-sessions.md)</ept>","source":"[Using Sessions](../../../docs/framework/wcf/using-sessions.md)"},{"pos":[26704,26817],"content":"<bpt id=\"p1\">[</bpt>Synchronous and Asynchronous Operations<ept id=\"p1\">](../../../docs/framework/wcf/synchronous-and-asynchronous-operations.md)</ept>","source":"[Synchronous and Asynchronous Operations](../../../docs/framework/wcf/synchronous-and-asynchronous-operations.md)"},{"pos":[26820,26889],"content":"<bpt id=\"p1\">[</bpt>Reliable Services<ept id=\"p1\">](../../../docs/framework/wcf/reliable-services.md)</ept>","source":"[Reliable Services](../../../docs/framework/wcf/reliable-services.md)"},{"pos":[26892,26977],"content":"<bpt id=\"p1\">[</bpt>Services and Transactions<ept id=\"p1\">](../../../docs/framework/wcf/services-and-transactions.md)</ept>","source":"[Services and Transactions](../../../docs/framework/wcf/services-and-transactions.md)"}]}