{"content":"---\ntitle: \"Using the Message Class\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed\n---\n# Using the Message Class\nThe <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF). All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.  \n  \n You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly. Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages. However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly. For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:  \n  \n-   When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.  \n  \n-   When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.  \n  \n-   When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).  \n  \n Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).  \n  \n A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol. Just like in SOAP, a message has both a message body and headers. The message body contains the actual payload data, while the headers contain additional named data containers. The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed. Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.  \n  \n## Using the Message Class in Operations  \n You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both. If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:  \n  \n-   The operation cannot have any `out` or `ref` parameters.  \n  \n-   There cannot be more than one `input` parameter. If the parameter is present, it must be either Message or a message contract type.  \n  \n-   The return type must be either `void`, `Message`, or a message contract type.  \n  \n The following code example contains a valid operation contract.  \n  \n [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]\n [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  \n  \n## Creating Basic Messages  \n The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.  \n  \n All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message. If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property. Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message. Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.  \n  \n## Creating Messages from Objects  \n The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body. Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object. Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization. If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.  \n  \n For example, to return an object in a message, you can use the following code.  \n  \n [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]\n [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  \n  \n## Creating Messages from XML Readers  \n There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object. In this case, the body of the message contains the XML that results from reading from the passed XML reader. For example, the following code returns a message with body contents read from an XML file.  \n  \n [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]\n [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  \n  \n Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body. These overloads also take an integer `maxSizeOfHeaders` parameter. Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place. It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack. The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.  \n  \n## Creating Messages with BodyWriter  \n One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message. A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created. You can create your own `BodyWriter` derived class to describe message bodies in a custom way. You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.  \n  \n Body writers can be buffered or non-buffered (streamed). Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once. The `IsBuffered` property indicates whether a body writer is buffered or not. You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter. Body writers support creating a buffered body writer from a non-buffered body writer. You can override the `OnCreateBufferedCopy` method to customize this process. By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used. `OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.  \n  \n The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively. These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once. These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.  \n  \n## Creating Fault Messages  \n You can use certain `CreateMessage` overloads to create SOAP fault messages. The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault. Other overloads are provided for convenience. The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information. The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason. For example, the following operation returns a fault.  \n  \n [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]\n [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  \n  \n## Extracting Message Body Data  \n The `Message` class supports multiple ways of extracting information from its body. These can be classified into the following categories:  \n  \n-   Getting the entire message body written out at once to an XML writer. This is referred to as *writing a message*.  \n  \n-   Getting an XML reader over the message body. This enables you to later access the message body piece-by-piece as required. This is referred to as *reading a message*.  \n  \n-   The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type. This is referred to as *copying a message*.  \n  \n You can access the body of a `Message` only once, regardless of how it is accessed. A message object has a `State` property, which is initially set to Created. The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively. Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required. The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.  \n  \n## Writing Messages  \n The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer. The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>). Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers. If SOAP is turned off (<xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>), all three methods do the same thing: they write out the message body contents.  \n  \n For example, the following code writes out the body of an incoming message to a file.  \n  \n [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]\n [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  \n  \n Two additional helper methods write out certain SOAP start element tags. These methods do not access the message body and so they do not change the message state. These include:  \n  \n-   <xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.  \n  \n-   <xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.  \n  \n To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer. These methods are rarely called directly.  \n  \n## Reading Messages  \n The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>. You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body. Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.  \n  \n The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object. Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).  \n  \n It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>. Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.  \n  \n The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled. If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.  \n  \n For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.  \n  \n [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]\n [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  \n  \n## Copying a Message into a Buffer  \n Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system. In this case, it is necessary to buffer the entire message (including the body) in memory. You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>. This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size. It is important to set this to a safe value if the message is coming from an untrusted source.  \n  \n The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance. You can access data in the buffer in several ways. The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.  \n  \n Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly. Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited. This helps prevent denial of service attacks based on lengthy processing time. This quote is disabled by default. Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.  \n  \n A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.  \n  \n The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file. Without buffering, this is not possible, because the message body can then be accessed only once.  \n  \n [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]\n [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  \n  \n The `MessageBuffer` class has other members worth noting. The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required. The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer. The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.  \n  \n## Accessing the Message Body for Debugging  \n For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string. This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability. The one exception to this is the message body. The body can be read only once, and `ToString` does not change the message state. Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, \"…\" or three dots) instead of the message body. Therefore, do not use `ToString` to log messages if the body content of the messages is important.  \n  \n## Accessing Other Message Parts  \n Various properties are provided to access information about the message other than its body contents. However, these cannot be called once the message has been closed:  \n  \n-   The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers. See the section on \"Working with Headers\" later in this topic.  \n  \n-   The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent. See the section on \"Working with Properties\" later in this topic.  \n  \n-   The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.  \n  \n-   The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.  \n  \n-   The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.  \n  \n You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace. If such an attribute is not found, `null` is returned. This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).  \n  \n## Working with Headers  \n A `Message` can contain any number of named XML fragments, called *headers*. Each fragment normally maps to a SOAP header. Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>. <xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer. For example, the following code lists the names of all the headers in a `Message`.  \n  \n [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]\n [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  \n  \n#### Adding, Removing, Finding Headers  \n You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method. You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index. Existing headers are shifted for the inserted item. Headers are ordered according to their index, and the first available index is 0. You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance. Some overloads copy one individual header, while others copy all of them. The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers. The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it). The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.  \n  \n Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method. This method takes the name and namespace of the header to find, and returns its index. If the header occurs more than once, an exception is thrown. If the header is not found, it returns -1.  \n  \n In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header. The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message. However, another overload enables you to specify which `Actor` values are included in the search. For more information, see the SOAP specification.  \n  \n A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.  \n  \n To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index. If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads. The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way. If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`. There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.  \n  \n## Working with Properties  \n A `Message` instance can contain an arbitrary number of named objects of arbitrary types. This collection is accessed through the `Properties` property of type `MessageProperties`. The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>. Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework. For an example, see [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).  \n  \n## Inheriting from the Message Class  \n If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.  \n  \n### Defining the Message Body Contents  \n Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer. These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`. The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once. The base class also ensures that the methods are not called on a closed message. There is no need to track the message state in your implementation.  \n  \n <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented. The most basic way to define the body contents of your message is to write using this method. For example, the following message contains 100,000 random numbers from 1 to 20.  \n  \n [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]\n [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  \n  \n The <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods have default implementations that work for most cases. The default implementations call <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, buffer the results, and work with the resulting buffer. However, in some cases this may not be enough. In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable. You might want to override <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> to return a custom <xref:System.Xml.XmlDictionaryReader> derived class that serves up random numbers. You can then override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> to use the reader that the <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> method returns, as shown in the following example.  \n  \n [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]\n [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  \n  \n Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.  \n  \n In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.  \n  \n Note that if you create a copy of a message, the copy uses the message headers from the original.  \n  \n### Other Members that Can Be Overridden  \n You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`. These methods should normally not write anything out if the <xref:System.ServiceModel.Channels.Message.Version> property returns <xref:System.ServiceModel.Channels.MessageVersion.None>.  \n  \n> [!NOTE]\n>  The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results. Headers are not written out.  \n  \n Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces. The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation. Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice. It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.  \n  \n Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging. The default is to represent it as three dots (\"…\"). Note that this method can be called multiple times when the message state is anything other than Closed. An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).  \n  \n Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element. This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state. It is not required to check the state in an implementation. The default implementation always returns `null`, which indicates that there are no attributes on the body element.  \n  \n If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>. The default implementation does nothing.  \n  \n The `IsEmpty` and `IsFault` properties can be overridden. By default, both return `false`.\n","nodes":[{"pos":[4,141],"embed":true,"restype":"x-metadata","content":"title: \"Using the Message Class\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed","nodes":[{"content":"Using the Message Class","nodes":[{"pos":[0,23],"content":"Using the Message Class","nodes":[{"content":"Using the Message Class","pos":[0,23]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[148,171],"content":"Using the Message Class","linkify":"Using the Message Class","nodes":[{"content":"Using the Message Class","pos":[0,23]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class is fundamental to Windows Communication Foundation (WCF).","pos":[172,283],"source":"The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF)."},{"content":"All communication between clients and services ultimately results in <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instances being sent and received.","pos":[284,431],"source":" All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received."},{"content":"You would not usually interact with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class directly.","pos":[438,537],"source":"You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly."},{"content":"Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.","pos":[538,697]},{"content":"However, in some advanced scenarios you can program using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class directly.","pos":[698,819],"source":" However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly."},{"content":"For example, you might want to use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class:","pos":[820,909],"source":" For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:"},{"pos":[919,1148],"content":"When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> objects.","source":"When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects."},{"pos":[1158,1413],"content":"When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> objects.","source":"When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects."},{"content":"When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).","pos":[1423,1627]},{"pos":[1634,1893],"content":"Before using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class, familiarize yourself with the WCF data transfer architecture in <bpt id=\"p1\">[</bpt>Data Transfer Architectural Overview<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)</ept>.","source":"Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)."},{"content":"A <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.","pos":[1900,2063],"source":"A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol."},{"content":"Just like in SOAP, a message has both a message body and headers.","pos":[2064,2129]},{"content":"The message body contains the actual payload data, while the headers contain additional named data containers.","pos":[2130,2240]},{"content":"The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.","pos":[2241,2481]},{"content":"Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.","pos":[2482,2608]},{"pos":[2617,2654],"content":"Using the Message Class in Operations","linkify":"Using the Message Class in Operations","nodes":[{"content":"Using the Message Class in Operations","pos":[0,37]}]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class as an input parameter of an operation, the return value of an operation, or both.","pos":[2658,2805],"source":"You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both."},{"content":"If <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> is used anywhere in an operation, the following restrictions apply:","pos":[2806,2920],"source":" If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:"},{"pos":[2930,2986],"content":"The operation cannot have any <ph id=\"ph1\">`out`</ph> or <ph id=\"ph2\">`ref`</ph> parameters.","source":"The operation cannot have any `out` or `ref` parameters."},{"content":"There cannot be more than one <ph id=\"ph1\">`input`</ph> parameter.","pos":[2996,3044],"source":"There cannot be more than one `input` parameter."},{"content":"If the parameter is present, it must be either Message or a message contract type.","pos":[3045,3127]},{"pos":[3137,3214],"content":"The return type must be either <ph id=\"ph1\">`void`</ph>, <ph id=\"ph2\">`Message`</ph>, or a message contract type.","source":"The return type must be either `void`, `Message`, or a message contract type."},{"content":"The following code example contains a valid operation contract.","pos":[3221,3284]},{"pos":[3291,3556],"content":"[!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]\n[!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]","leadings":[""," "],"nodes":[]},{"pos":[3565,3588],"content":"Creating Basic Messages","linkify":"Creating Basic Messages","nodes":[{"content":"Creating Basic Messages","pos":[0,23]}]},{"pos":[3592,3736],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class provides static <ph id=\"ph2\">`CreateMessage`</ph> factory methods that you can use to create basic messages.","source":"The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages."},{"content":"All <ph id=\"ph1\">`CreateMessage`</ph> overloads take a version parameter of type <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageVersion&gt;</ph> that indicates the SOAP and WS-Addressing versions to use for the message.","pos":[3743,3931],"source":"All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message."},{"content":"If you want to use the same protocol versions as the incoming message, you can use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A&gt;</ph> property on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContext&gt;</ph> instance obtained from the <ph id=\"ph3\">&lt;xref:System.ServiceModel.OperationContext.Current%2A&gt;</ph> property.","pos":[3932,4240],"source":" If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property."},{"content":"Most <ph id=\"ph1\">`CreateMessage`</ph> overloads also have a string parameter that indicates the SOAP action to use for the message.","pos":[4241,4355],"source":" Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message."},{"content":"Version can be set to <ph id=\"ph1\">`None`</ph> to disable SOAP envelope generation; the message consists of only the body.","pos":[4356,4460],"source":" Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body."},{"pos":[4469,4499],"content":"Creating Messages from Objects","linkify":"Creating Messages from Objects","nodes":[{"content":"Creating Messages from Objects","pos":[0,30]}]},{"content":"The most basic <ph id=\"ph1\">`CreateMessage`</ph> overload that takes only a version and an action creates a message with an empty body.","pos":[4503,4620],"source":"The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body."},{"content":"Another overload takes an additional <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> parameter; this creates a message whose body is the serialized representation of the given object.","pos":[4621,4777],"source":" Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> with default settings for serialization.","pos":[4778,4885],"source":" Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization."},{"content":"If you want to use a different serializer, or you want the <ph id=\"ph1\">`DataContractSerializer`</ph> configured differently, use the <ph id=\"ph2\">`CreateMessage`</ph> overload that also takes an <ph id=\"ph3\">`XmlObjectSerializer`</ph> parameter.","pos":[4886,5078],"source":" If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter."},{"content":"For example, to return an object in a message, you can use the following code.","pos":[5085,5163]},{"pos":[5444,5478],"content":"Creating Messages from XML Readers","linkify":"Creating Messages from XML Readers","nodes":[{"content":"Creating Messages from XML Readers","pos":[0,34]}]},{"content":"There are <ph id=\"ph1\">`CreateMessage`</ph> overloads that take an <ph id=\"ph2\">&lt;xref:System.Xml.XmlReader&gt;</ph> or an <ph id=\"ph3\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> for the body instead of an object.","pos":[5482,5637],"source":"There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object."},{"content":"In this case, the body of the message contains the XML that results from reading from the passed XML reader.","pos":[5638,5746]},{"content":"For example, the following code returns a message with body contents read from an XML file.","pos":[5747,5838]},{"content":"Additionally, there are <ph id=\"ph1\">`CreateMessage`</ph> overloads that take an <ph id=\"ph2\">&lt;xref:System.Xml.XmlReader&gt;</ph> or an <ph id=\"ph3\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> that represents the entire message and not just the body.","pos":[6117,6309],"source":"Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body."},{"content":"These overloads also take an integer <ph id=\"ph1\">`maxSizeOfHeaders`</ph> parameter.","pos":[6310,6376],"source":" These overloads also take an integer `maxSizeOfHeaders` parameter."},{"content":"Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.","pos":[6377,6519]},{"content":"It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.","pos":[6520,6678]},{"content":"The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.","pos":[6679,6818]},{"pos":[6827,6860],"content":"Creating Messages with BodyWriter","linkify":"Creating Messages with BodyWriter","nodes":[{"content":"Creating Messages with BodyWriter","pos":[0,33]}]},{"content":"One <ph id=\"ph1\">`CreateMessage`</ph> overload takes a <ph id=\"ph2\">`BodyWriter`</ph> instance to describe the body of the message.","pos":[6864,6959],"source":"One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message."},{"content":"A <ph id=\"ph1\">`BodyWriter`</ph> is an abstract class that can be derived to customize how message bodies are created.","pos":[6960,7060],"source":" A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created."},{"content":"You can create your own <ph id=\"ph1\">`BodyWriter`</ph> derived class to describe message bodies in a custom way.","pos":[7061,7155],"source":" You can create your own `BodyWriter` derived class to describe message bodies in a custom way."},{"content":"You must override the <ph id=\"ph1\">`BodyWriter.OnWriteBodyContents`</ph> method that takes an <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph>; this method is responsible for writing out the body.","pos":[7156,7323],"source":" You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body."},{"content":"Body writers can be buffered or non-buffered (streamed).","pos":[7330,7386]},{"content":"Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.","pos":[7387,7518]},{"content":"The <ph id=\"ph1\">`IsBuffered`</ph> property indicates whether a body writer is buffered or not.","pos":[7519,7596],"source":" The `IsBuffered` property indicates whether a body writer is buffered or not."},{"content":"You can set this for your body writer by calling the protected <ph id=\"ph1\">`BodyWriter`</ph> constructor that takes an <ph id=\"ph2\">`isBuffered`</ph> boolean parameter.","pos":[7597,7730],"source":" You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter."},{"content":"Body writers support creating a buffered body writer from a non-buffered body writer.","pos":[7731,7816]},{"content":"You can override the <ph id=\"ph1\">`OnCreateBufferedCopy`</ph> method to customize this process.","pos":[7817,7894],"source":" You can override the `OnCreateBufferedCopy` method to customize this process."},{"content":"By default, an in-memory buffer that contains the XML returned by <ph id=\"ph1\">`OnWriteBodyContents`</ph> is used.","pos":[7895,7991],"source":" By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used."},{"content":"<ph id=\"ph1\">`OnCreateBufferedCopy`</ph> takes a <ph id=\"ph2\">`maxBufferSize`</ph> integer parameter; if you override this method, you must not create buffers larger than this maximum size.","pos":[7992,8145],"source":"`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size."},{"content":"The <ph id=\"ph1\">`BodyWriter`</ph> class provides the <ph id=\"ph2\">`WriteBodyContents`</ph> and <ph id=\"ph3\">`CreateBufferedCopy`</ph> methods, which are essentially thin wrappers around <ph id=\"ph4\">`OnWriteBodyContents`</ph> and <ph id=\"ph5\">`OnCreateBufferedCopy`</ph> methods, respectively.","pos":[8152,8356],"source":"The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively."},{"content":"These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.","pos":[8357,8467]},{"content":"These methods are called directly only when creating custom <ph id=\"ph1\">`Message`</ph> derived classes based on <ph id=\"ph2\">`BodyWriters`</ph>.","pos":[8468,8577],"source":" These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`."},{"pos":[8586,8609],"content":"Creating Fault Messages","linkify":"Creating Fault Messages","nodes":[{"content":"Creating Fault Messages","pos":[0,23]}]},{"content":"You can use certain <ph id=\"ph1\">`CreateMessage`</ph> overloads to create SOAP fault messages.","pos":[8613,8689],"source":"You can use certain `CreateMessage` overloads to create SOAP fault messages."},{"content":"The most basic of these takes a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageFault&gt;</ph> object that describes the fault.","pos":[8690,8803],"source":" The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault."},{"content":"Other overloads are provided for convenience.","pos":[8804,8849]},{"content":"The first such overload takes a <ph id=\"ph1\">`FaultCode`</ph> and a reason string and creates a <ph id=\"ph2\">`MessageFault`</ph> using <ph id=\"ph3\">`MessageFault.CreateFault`</ph> using this information.","pos":[8850,8999],"source":" The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information."},{"content":"The other overload takes a detail object and also passes it to <ph id=\"ph1\">`CreateFault`</ph> together with the fault code and the reason.","pos":[9000,9121],"source":" The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason."},{"content":"For example, the following operation returns a fault.","pos":[9122,9175]},{"pos":[9456,9484],"content":"Extracting Message Body Data","linkify":"Extracting Message Body Data","nodes":[{"content":"Extracting Message Body Data","pos":[0,28]}]},{"content":"The <ph id=\"ph1\">`Message`</ph> class supports multiple ways of extracting information from its body.","pos":[9488,9571],"source":"The `Message` class supports multiple ways of extracting information from its body."},{"content":"These can be classified into the following categories:","pos":[9572,9626]},{"content":"Getting the entire message body written out at once to an XML writer.","pos":[9636,9705]},{"content":"This is referred to as <bpt id=\"p1\">*</bpt>writing a message<ept id=\"p1\">*</ept>.","pos":[9706,9749],"source":" This is referred to as *writing a message*."},{"content":"Getting an XML reader over the message body.","pos":[9759,9803]},{"content":"This enables you to later access the message body piece-by-piece as required.","pos":[9804,9881]},{"content":"This is referred to as <bpt id=\"p1\">*</bpt>reading a message<ept id=\"p1\">*</ept>.","pos":[9882,9925],"source":" This is referred to as *reading a message*."},{"content":"The entire message, including its body, can be copied to an in-memory buffer of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageBuffer&gt;</ph> type.","pos":[9935,10074],"source":"The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type."},{"content":"This is referred to as <bpt id=\"p1\">*</bpt>copying a message<ept id=\"p1\">*</ept>.","pos":[10075,10118],"source":" This is referred to as *copying a message*."},{"content":"You can access the body of a <ph id=\"ph1\">`Message`</ph> only once, regardless of how it is accessed.","pos":[10125,10208],"source":"You can access the body of a `Message` only once, regardless of how it is accessed."},{"content":"A message object has a <ph id=\"ph1\">`State`</ph> property, which is initially set to Created.","pos":[10209,10284],"source":" A message object has a `State` property, which is initially set to Created."},{"content":"The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.","pos":[10285,10399]},{"content":"Additionally, a <ph id=\"ph1\">`Close`</ph> method can set the state to Closed when the message body contents are no longer required.","pos":[10400,10513],"source":" Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required."},{"content":"The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.","pos":[10514,10654]},{"pos":[10663,10679],"content":"Writing Messages","linkify":"Writing Messages","nodes":[{"content":"Writing Messages","pos":[0,16]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29&gt;</ph> method writes out the body contents of a given <ph id=\"ph2\">`Message`</ph> instance to a given XML writer.","pos":[10683,10873],"source":"The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteBody%2A&gt;</ph> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, &lt;<ph id=\"ph2\">`soap:body`</ph>&gt;).","pos":[10874,11063],"source":" The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>)."},{"content":"Finally, <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteMessage%2A&gt;</ph> writes out the entire message, including the wrapping SOAP envelope and the headers.","pos":[11064,11217],"source":" Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers."},{"content":"If SOAP is turned off (<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.Version&gt;</ph> is <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType&gt;</ph>), all three methods do the same thing: they write out the message body contents.","pos":[11218,11461],"source":" If SOAP is turned off (<xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>), all three methods do the same thing: they write out the message body contents."},{"content":"For example, the following code writes out the body of an incoming message to a file.","pos":[11468,11553]},{"content":"Two additional helper methods write out certain SOAP start element tags.","pos":[11832,11904]},{"content":"These methods do not access the message body and so they do not change the message state.","pos":[11905,11994]},{"content":"These include:","pos":[11995,12009]},{"pos":[12019,12139],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteStartBody%2A&gt;</ph> writes the start body element, for example, <ph id=\"ph2\">`&lt;soap:Body&gt;`</ph>.","source":"<xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`."},{"pos":[12149,12281],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A&gt;</ph> writes the start envelope element, for example, <ph id=\"ph2\">`&lt;soap:Envelope&gt;`</ph>.","source":"<xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`."},{"content":"To write the corresponding end element tags, call <ph id=\"ph1\">`WriteEndElement`</ph> on the corresponding XML writer.","pos":[12288,12388],"source":"To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer."},{"content":"These methods are rarely called directly.","pos":[12389,12430]},{"pos":[12439,12455],"content":"Reading Messages","linkify":"Reading Messages","nodes":[{"content":"Reading Messages","pos":[0,16]}]},{"content":"The primary way to read a message body is to call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A&gt;</ph>.","pos":[12459,12580],"source":"The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>."},{"content":"You get back an <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> that you can use to read the message body.","pos":[12581,12677],"source":" You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body."},{"content":"Note that the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> transitions to the Read state as soon as <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A&gt;</ph> is called, and not when you use the returned XML reader.","pos":[12678,12904],"source":" Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.GetBody%2A&gt;</ph> method also enables you to access the message body as a typed object.","pos":[12911,13039],"source":"The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object."},{"content":"Internally, this method uses <ph id=\"ph1\">`GetReaderAtBodyContents`</ph>, and so it also transitions the message state to the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageState.Read&gt;</ph> state (see the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message.State%2A&gt;</ph> property).","pos":[13040,13280],"source":" Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property)."},{"content":"It is good practice to check the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.IsEmpty%2A&gt;</ph> property, in which case the message body is empty and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A&gt;</ph> throws an <ph id=\"ph3\">&lt;xref:System.InvalidOperationException&gt;</ph>.","pos":[13287,13550],"source":"It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>."},{"content":"Also, if it is a received message (for example, the reply), you may also want to check <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.IsFault%2A&gt;</ph>, which indicates whether the message contains a fault.","pos":[13551,13747],"source":" Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault."},{"content":"The most basic overload of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.GetBody%2A&gt;</ph> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> configured with the default settings and with the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A&gt;</ph> quota disabled.","pos":[13754,14146],"source":"The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled."},{"content":"If you want to use a different serialization engine, or configure the <ph id=\"ph1\">`DataContractSerializer`</ph> in a non-default way, use the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.GetBody%2A&gt;</ph> overload that takes an <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph>.","pos":[14147,14406],"source":" If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>."},{"pos":[14413,14555],"content":"For example, the following code extracts data from a message body that contains a serialized <ph id=\"ph1\">`Person`</ph> object and prints out the person’s name.","source":"For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name."},{"pos":[14836,14867],"content":"Copying a Message into a Buffer","linkify":"Copying a Message into a Buffer","nodes":[{"content":"Copying a Message into a Buffer","pos":[0,31]}]},{"content":"Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.","pos":[14871,15047]},{"content":"In this case, it is necessary to buffer the entire message (including the body) in memory.","pos":[15048,15138]},{"content":"You can do this by calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29&gt;</ph>.","pos":[15139,15247],"source":" You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>."},{"content":"This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.","pos":[15248,15375]},{"content":"It is important to set this to a safe value if the message is coming from an untrusted source.","pos":[15376,15470]},{"content":"The buffer is returned as a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageBuffer&gt;</ph> instance.","pos":[15477,15564],"source":"The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance."},{"content":"You can access data in the buffer in several ways.","pos":[15565,15615]},{"content":"The primary way is to call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.CreateMessage%2A&gt;</ph> to create <ph id=\"ph2\">`Message`</ph> instances from the buffer.","pos":[15616,15750],"source":" The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer."},{"content":"Another way to access the data in the buffer is to implement the <ph id=\"ph1\">&lt;xref:System.Xml.XPath.IXPathNavigable&gt;</ph> interface that the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageBuffer&gt;</ph> class implements to access the underlying XML directly.","pos":[15757,15986],"source":"Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly."},{"content":"Some <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A&gt;</ph> overloads allow you to create <ph id=\"ph2\">&lt;xref:System.Xml.XPath&gt;</ph> navigators protected by a node quota, limiting the number of XML nodes that can be visited.","pos":[15987,16206],"source":" Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited."},{"content":"This helps prevent denial of service attacks based on lengthy processing time.","pos":[16207,16285]},{"content":"This quote is disabled by default.","pos":[16286,16320]},{"content":"Some <ph id=\"ph1\">`CreateNavigator`</ph> overloads allow you to specify how white space should be handled in the XML using the <ph id=\"ph2\">&lt;xref:System.Xml.XmlSpace&gt;</ph> enumeration, with the default being <ph id=\"ph3\">`XmlSpace.None`</ph>.","pos":[16321,16509],"source":" Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`."},{"pos":[16516,16678],"content":"A final way to access the contents of a message buffer is to write out its contents to a stream using <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteMessage%2A&gt;</ph>.","source":"A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>."},{"content":"The following example demonstrates the process of working with a <ph id=\"ph1\">`MessageBuffer`</ph>: an incoming message is forwarded to multiple recipients, and then logged to a file.","pos":[16685,16850],"source":"The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file."},{"content":"Without buffering, this is not possible, because the message body can then be accessed only once.","pos":[16851,16948]},{"content":"The <ph id=\"ph1\">`MessageBuffer`</ph> class has other members worth noting.","pos":[17227,17284],"source":"The `MessageBuffer` class has other members worth noting."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageBuffer.Close%2A&gt;</ph> method can be called to free resources when the buffer contents are no longer required.","pos":[17285,17435],"source":" The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A&gt;</ph> property returns the size of the allocated buffer.","pos":[17436,17554],"source":" The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A&gt;</ph> property returns the MIME content type of the message.","pos":[17555,17685],"source":" The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message."},{"pos":[17694,17734],"content":"Accessing the Message Body for Debugging","linkify":"Accessing the Message Body for Debugging","nodes":[{"content":"Accessing the Message Body for Debugging","pos":[0,40]}]},{"content":"For debugging purposes, you can call the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.ToString%2A&gt;</ph> method to get a representation of the message as a string.","pos":[17738,17893],"source":"For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string."},{"content":"This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.","pos":[17894,18083]},{"content":"The one exception to this is the message body.","pos":[18084,18130]},{"content":"The body can be read only once, and <ph id=\"ph1\">`ToString`</ph> does not change the message state.","pos":[18131,18212],"source":" The body can be read only once, and `ToString` does not change the message state."},{"content":"Therefore, the <ph id=\"ph1\">`ToString`</ph> method might not be able to access the body and might substitute a placeholder (for example, \"…\" or three dots) instead of the message body.","pos":[18213,18379],"source":" Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, \"…\" or three dots) instead of the message body."},{"content":"Therefore, do not use <ph id=\"ph1\">`ToString`</ph> to log messages if the body content of the messages is important.","pos":[18380,18478],"source":" Therefore, do not use `ToString` to log messages if the body content of the messages is important."},{"pos":[18487,18516],"content":"Accessing Other Message Parts","linkify":"Accessing Other Message Parts","nodes":[{"content":"Accessing Other Message Parts","pos":[0,29]}]},{"content":"Various properties are provided to access information about the message other than its body contents.","pos":[18520,18621]},{"content":"However, these cannot be called once the message has been closed:","pos":[18622,18687]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.Headers%2A&gt;</ph> property represents the message headers.","pos":[18697,18796],"source":"The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers."},{"content":"See the section on \"Working with Headers\" later in this topic.","pos":[18797,18859]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.Properties%2A&gt;</ph> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.","pos":[18869,19089],"source":"The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent."},{"content":"See the section on \"Working with Properties\" later in this topic.","pos":[19090,19155]},{"pos":[19165,19337],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.Version%2A&gt;</ph> property indicates the SOAP and WS-Addressing version associated with the message, or <ph id=\"ph2\">`None`</ph> if SOAP is disabled.","source":"The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled."},{"pos":[19347,19469],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.IsFault%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph> if the message is a SOAP fault message.","source":"The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message."},{"pos":[19479,19586],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.IsEmpty%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph> if the message is empty.","source":"The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29&gt;</ph> method to access a particular attribute on the body wrapper element (for example, <ph id=\"ph2\">`&lt;soap:Body&gt;`</ph>) identified by a particular name and namespace.","pos":[19593,19848],"source":"You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace."},{"content":"If such an attribute is not found, <ph id=\"ph1\">`null`</ph> is returned.","pos":[19849,19903],"source":" If such an attribute is not found, `null` is returned."},{"content":"This method can be called only when the <ph id=\"ph1\">`Message`</ph> is in the Created state (when the message body has not yet been accessed).","pos":[19904,20028],"source":" This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed)."},{"pos":[20037,20057],"content":"Working with Headers","linkify":"Working with Headers","nodes":[{"content":"Working with Headers","pos":[0,20]}]},{"content":"A <ph id=\"ph1\">`Message`</ph> can contain any number of named XML fragments, called <bpt id=\"p1\">*</bpt>headers<ept id=\"p1\">*</ept>.","pos":[20061,20137],"source":"A `Message` can contain any number of named XML fragments, called *headers*."},{"content":"Each fragment normally maps to a SOAP header.","pos":[20138,20183]},{"content":"Headers are accessed through the <ph id=\"ph1\">`Headers`</ph> property of type <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageHeaders&gt;</ph>.","pos":[20184,20295],"source":" Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders&gt;</ph> is a collection of <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageHeaderInfo&gt;</ph> objects, and individual headers can be accessed through its <ph id=\"ph3\">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface or through its indexer.","pos":[20296,20551],"source":"<xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer."},{"content":"For example, the following code lists the names of all the headers in a <ph id=\"ph1\">`Message`</ph>.","pos":[20552,20634],"source":" For example, the following code lists the names of all the headers in a `Message`."},{"pos":[20917,20950],"content":"Adding, Removing, Finding Headers","linkify":"Adding, Removing, Finding Headers","nodes":[{"content":"Adding, Removing, Finding Headers","pos":[0,33]}]},{"content":"You can add a new header at the end of all existing headers using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.Add%2A&gt;</ph> method.","pos":[20954,21089],"source":"You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A&gt;</ph> method to insert a header at a particular index.","pos":[21090,21215],"source":" You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index."},{"content":"Existing headers are shifted for the inserted item.","pos":[21216,21267]},{"content":"Headers are ordered according to their index, and the first available index is 0.","pos":[21268,21349]},{"content":"You can use the various <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A&gt;</ph> method overloads to add headers from a different <ph id=\"ph2\">`Message`</ph> or <ph id=\"ph3\">`MessageHeaders`</ph> instance.","pos":[21350,21532],"source":" You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance."},{"content":"Some overloads copy one individual header, while others copy all of them.","pos":[21533,21606]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A&gt;</ph> method removes all headers.","pos":[21607,21698],"source":" The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A&gt;</ph> method removes a header at a particular index (shifting all headers after it).","pos":[21699,21844],"source":" The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it)."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A&gt;</ph> method removes all headers with a particular name and namespace.","pos":[21845,21977],"source":" The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace."},{"content":"Retrieve a particular header using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A&gt;</ph> method.","pos":[21984,22095],"source":"Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method."},{"content":"This method takes the name and namespace of the header to find, and returns its index.","pos":[22096,22182]},{"content":"If the header occurs more than once, an exception is thrown.","pos":[22183,22243]},{"content":"If the header is not found, it returns -1.","pos":[22244,22286]},{"content":"In the SOAP header model, headers can have an <ph id=\"ph1\">`Actor`</ph> value that specifies the intended recipient of the header.","pos":[22293,22405],"source":"In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header."},{"content":"The most basic <ph id=\"ph1\">`FindHeader`</ph> overload searches only headers intended for the ultimate receiver of the message.","pos":[22406,22515],"source":" The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message."},{"content":"However, another overload enables you to specify which <ph id=\"ph1\">`Actor`</ph> values are included in the search.","pos":[22516,22613],"source":" However, another overload enables you to specify which `Actor` values are included in the search."},{"content":"For more information, see the SOAP specification.","pos":[22614,22663]},{"pos":[22670,22984],"content":"A <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29&gt;</ph> method is provided to copy headers from a <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageHeaders&gt;</ph> collection to an array of <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.MessageHeaderInfo&gt;</ph> objects.","source":"A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects."},{"content":"To access the XML data in a header, you can call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A&gt;</ph> and return an XML reader for the specific header index.","pos":[22991,23167],"source":"To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index."},{"content":"If you want to deserialize the header contents into an object, use <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29&gt;</ph> or one of the other overloads.","pos":[23168,23351],"source":" If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads."},{"content":"The most basic overloads deserialize headers using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> configured in the default way.","pos":[23352,23496],"source":" The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way."},{"content":"If you want to use a different serializer or a different configuration of the <ph id=\"ph1\">`DataContractSerializer`</ph>, use one of the overloads that take an <ph id=\"ph2\">`XmlObjectSerializer`</ph>.","pos":[23497,23661],"source":" If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`."},{"content":"There are also overloads that take the header name, namespace, and optionally a list of <ph id=\"ph1\">`Actor`</ph> values instead of an index; this is a combination of <ph id=\"ph2\">`FindHeader`</ph> and <ph id=\"ph3\">`GetHeader`</ph>.","pos":[23662,23840],"source":" There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`."},{"pos":[23849,23872],"content":"Working with Properties","linkify":"Working with Properties","nodes":[{"content":"Working with Properties","pos":[0,23]}]},{"content":"A <ph id=\"ph1\">`Message`</ph> instance can contain an arbitrary number of named objects of arbitrary types.","pos":[23876,23965],"source":"A `Message` instance can contain an arbitrary number of named objects of arbitrary types."},{"content":"This collection is accessed through the <ph id=\"ph1\">`Properties`</ph> property of type <ph id=\"ph2\">`MessageProperties`</ph>.","pos":[23966,24056],"source":" This collection is accessed through the `Properties` property of type `MessageProperties`."},{"content":"The collection implements the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> interface and acts as a mapping from <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> to <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>.","pos":[24057,24219],"source":" The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>."},{"content":"Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29&gt;</ph> service framework.","pos":[24220,24566],"source":" Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework."},{"content":"For an example, see <bpt id=\"p1\">[</bpt>Data Transfer Architectural Overview<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)</ept>.","pos":[24567,24714],"source":" For an example, see [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)."},{"pos":[24723,24756],"content":"Inheriting from the Message Class","linkify":"Inheriting from the Message Class","nodes":[{"content":"Inheriting from the Message Class","pos":[0,33]}]},{"pos":[24760,24904],"content":"If the built-in message types created using <ph id=\"ph1\">`CreateMessage`</ph> do not meet your requirements, create a class that derives from the <ph id=\"ph2\">`Message`</ph> class.","source":"If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class."},{"pos":[24914,24948],"content":"Defining the Message Body Contents","linkify":"Defining the Message Body Contents","nodes":[{"content":"Defining the Message Body Contents","pos":[0,34]}]},{"content":"Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.","pos":[24952,25070]},{"content":"These operations ultimately result in the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A&gt;</ph> methods being called, respectively, on your derived class of <ph id=\"ph4\">`Message`</ph>.","pos":[25071,25398],"source":" These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`."},{"content":"The base <ph id=\"ph1\">`Message`</ph> class guarantees that only one of these methods is called for each <ph id=\"ph2\">`Message`</ph> instance, and that it is not called more than once.","pos":[25399,25546],"source":" The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once."},{"content":"The base class also ensures that the methods are not called on a closed message.","pos":[25547,25627]},{"content":"There is no need to track the message state in your implementation.","pos":[25628,25695]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A&gt;</ph> is an abstract method and must be implemented.","pos":[25702,25815],"source":"<xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented."},{"content":"The most basic way to define the body contents of your message is to write using this method.","pos":[25816,25909]},{"content":"For example, the following message contains 100,000 random numbers from 1 to 20.","pos":[25910,25990]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A&gt;</ph> methods have default implementations that work for most cases.","pos":[26269,26477],"source":"The <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods have default implementations that work for most cases."},{"content":"The default implementations call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A&gt;</ph>, buffer the results, and work with the resulting buffer.","pos":[26478,26634],"source":" The default implementations call <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, buffer the results, and work with the resulting buffer."},{"content":"However, in some cases this may not be enough.","pos":[26635,26681]},{"content":"In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.","pos":[26682,26805]},{"content":"You might want to override <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents&gt;</ph> to return a custom <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> derived class that serves up random numbers.","pos":[26806,27004],"source":" You might want to override <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> to return a custom <xref:System.Xml.XmlDictionaryReader> derived class that serves up random numbers."},{"content":"You can then override <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A&gt;</ph> to use the reader that the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents&gt;</ph> method returns, as shown in the following example.","pos":[27005,27241],"source":" You can then override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> to use the reader that the <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> method returns, as shown in the following example."},{"pos":[27524,27634],"content":"Similarly, you might want to override <ph id=\"ph1\">`OnCreateBufferedCopy`</ph> to return your own <ph id=\"ph2\">`MessageBuffer`</ph> derived class.","source":"Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class."},{"pos":[27641,27789],"content":"In addition to providing message body contents, your message derived class must also override the <ph id=\"ph1\">`Version`</ph>, <ph id=\"ph2\">`Headers`</ph>, and <ph id=\"ph3\">`Properties`</ph> properties.","source":"In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties."},{"content":"Note that if you create a copy of a message, the copy uses the message headers from the original.","pos":[27796,27893]},{"pos":[27903,27939],"content":"Other Members that Can Be Overridden","linkify":"Other Members that Can Be Overridden","nodes":[{"content":"Other Members that Can Be Overridden","pos":[0,36]}]},{"content":"You can override the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A&gt;</ph> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to <ph id=\"ph4\">`&lt;soap:Envelope&gt;`</ph>, <ph id=\"ph5\">`&lt;soap:Header&gt;`</ph>, and <ph id=\"ph6\">`&lt;soap:Body&gt;`</ph>.","pos":[27943,28358],"source":"You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`."},{"content":"These methods should normally not write anything out if the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.Version&gt;</ph> property returns <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageVersion.None&gt;</ph>.","pos":[28359,28544],"source":" These methods should normally not write anything out if the <xref:System.ServiceModel.Channels.Message.Version> property returns <xref:System.ServiceModel.Channels.MessageVersion.None>."},{"pos":[28552,28765],"content":"[!NOTE]\n The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results. Headers are not written out.","leadings":["","> "],"nodes":[{"content":"The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results. Headers are not written out.","pos":[9,211],"nodes":[{"content":"The default implementation of <ph id=\"ph1\">`OnGetReaderAtBodyContents`</ph> calls <ph id=\"ph2\">`OnWriteStartEnvelope`</ph> and <ph id=\"ph3\">`OnWriteStartBody`</ph> before calling <ph id=\"ph4\">`OnWriteBodyContents`</ph> and buffering the results.","pos":[0,173],"source":"The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results."},{"content":"Headers are not written out.","pos":[174,202]}]}]},{"content":"Override the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A&gt;</ph> method to change the way the entire message is constructed from its various pieces.","pos":[28772,28930],"source":"Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces."},{"content":"The <ph id=\"ph1\">`OnWriteMessage`</ph> method is called from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.WriteMessage%2A&gt;</ph> and from the default <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A&gt;</ph> implementation.","pos":[28931,29138],"source":" The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation."},{"content":"Note that overriding <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteMessage%2A&gt;</ph> is not a best practice.","pos":[29139,29243],"source":" Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice."},{"content":"It is better to override the appropriate <ph id=\"ph1\">`On`</ph> methods (for example, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A&gt;</ph>.","pos":[29244,29523],"source":" It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>."},{"content":"Override <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnBodyToString%2A&gt;</ph> to override how your message body is represented during debugging.","pos":[29530,29667],"source":"Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging."},{"content":"The default is to represent it as three dots (\"…\").","pos":[29668,29719]},{"content":"Note that this method can be called multiple times when the message state is anything other than Closed.","pos":[29720,29824]},{"content":"An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).","pos":[29825,29966]},{"content":"Override the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A&gt;</ph> method to allow access to attributes on the SOAP body element.","pos":[29973,30114],"source":"Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element."},{"content":"This method can be called any number of times, but the <ph id=\"ph1\">`Message`</ph> base type guarantees that it is only called when the message is in the Created state.","pos":[30115,30265],"source":" This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state."},{"content":"It is not required to check the state in an implementation.","pos":[30266,30325]},{"content":"The default implementation always returns <ph id=\"ph1\">`null`</ph>, which indicates that there are no attributes on the body element.","pos":[30326,30441],"source":" The default implementation always returns `null`, which indicates that there are no attributes on the body element."},{"content":"If your <ph id=\"ph1\">`Message`</ph> object must do any special cleanup when the message body is no longer required, you can override <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnClose%2A&gt;</ph>.","pos":[30448,30618],"source":"If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>."},{"content":"The default implementation does nothing.","pos":[30619,30659]},{"content":"The <ph id=\"ph1\">`IsEmpty`</ph> and <ph id=\"ph2\">`IsFault`</ph> properties can be overridden.","pos":[30666,30723],"source":"The `IsEmpty` and `IsFault` properties can be overridden."},{"content":"By default, both return <ph id=\"ph1\">`false`</ph>.","pos":[30724,30756],"source":" By default, both return `false`."}]}