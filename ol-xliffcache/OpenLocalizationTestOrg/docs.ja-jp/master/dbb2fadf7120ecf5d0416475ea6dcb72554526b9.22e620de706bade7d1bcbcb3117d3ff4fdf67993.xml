{"content":"---\ntitle: \"Attributes (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: f148f13f-a0d5-4f22-9c87-4b73d5dde270\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Attributes (C#)\nAttributes provide a powerful method of associating metadata, or declarative information, with code (assemblies, types, methods, properties, and so forth). After an attribute is associated with a program entity, the attribute can be queried at run time by using a technique called *reflection*. For more information, see [Reflection (C#)](../../../../csharp/programming-guide/concepts/reflection.md).  \n  \n Attributes have the following properties:  \n  \n-   Attributes add metadata to your program. *Metadata* is information about the types defined in a program. All .NET assemblies contain a specified set of metadata that describes the types and type members defined in the assembly. You can add custom attributes to specify any additional information that is required. For more information, see, [Creating Custom Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/creating-custom-attributes.md).  \n  \n-   You can apply one or more attributes to entire assemblies, modules, or smaller program elements such as classes and properties.  \n  \n-   Attributes can accept arguments in the same way as methods and properties.  \n  \n-   Your program can examine its own metadata or the metadata in other programs by using reflection. For more information, see [Accessing Attributes by Using Reflection (C#)](../../../../csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection.md).  \n  \n## Using Attributes  \n Attributes can be placed on most any declaration, though a specific attribute might restrict the types of declarations on which it is valid. In C#, you specify an attribute by placing the name of the attribute, enclosed in square brackets ([]), above the declaration of the entity to which it applies.  \n  \n In this example, the <xref:System.SerializableAttribute> attribute is used to apply a specific characteristic to a class:  \n  \n```csharp  \n[System.Serializable]  \npublic class SampleClass  \n{  \n    // Objects of this type can be serialized.  \n}  \n```  \n  \n A method with the attribute <xref:System.Runtime.InteropServices.DllImportAttribute> is declared like this:  \n  \n```csharp  \nusing System.Runtime.InteropServices;  \n```  \n  \n```csharp  \n[System.Runtime.InteropServices.DllImport(\"user32.dll\")]  \nextern static void SampleMethod();  \n```  \n  \n More than one attribute can be placed on a declaration:  \n  \n```csharp  \nusing System.Runtime.InteropServices;  \n```  \n  \n```csharp  \nvoid MethodA([In][Out] ref double x) { }  \nvoid MethodB([Out][In] ref double x) { }  \nvoid MethodC([In, Out] ref double x) { }  \n```  \n  \n Some attributes can be specified more than once for a given entity. An example of such a multiuse attribute is <xref:System.Diagnostics.ConditionalAttribute>:  \n  \n```csharp  \n[Conditional(\"DEBUG\"), Conditional(\"TEST1\")]  \nvoid TraceMethod()  \n{  \n    // ...  \n}  \n```  \n  \n> [!NOTE]\n>  By convention, all attribute names end with the word \"Attribute\" to distinguish them from other items in the .NET Framework. However, you do not need to specify the attribute suffix when using attributes in code. For example, `[DllImport]` is equivalent to `[DllImportAttribute]`, but `DllImportAttribute` is the attribute's actual name in the .NET Framework.  \n  \n### Attribute Parameters  \n Many attributes have parameters, which can be positional, unnamed, or named. Any positional parameters must be specified in a certain order and cannot be omitted; named parameters are optional and can be specified in any order. Positional parameters are specified first. For example, these three attributes are equivalent:  \n  \n```csharp  \n[DllImport(\"user32.dll\")]  \n[DllImport(\"user32.dll\", SetLastError=false, ExactSpelling=false)]  \n[DllImport(\"user32.dll\", ExactSpelling=false, SetLastError=false)]  \n```  \n  \n The first parameter, the DLL name, is positional and always comes first; the others are named. In this case, both named parameters default to false, so they can be omitted. Refer to the individual attribute's documentation for information on default parameter values.  \n  \n### Attribute Targets  \n The *target* of an attribute is the entity to which the attribute applies. For example, an attribute may apply to a class, a particular method, or an entire assembly. By default, an attribute applies to the element that it precedes. But you can also explicitly identify, for example, whether an attribute is applied to a method, or to its parameter, or to its return value.  \n  \n To explicitly identify an attribute target, use the following syntax:  \n  \n```csharp  \n[target : attribute-list]  \n```  \n  \n The list of possible `target` values is shown in the following table.  \n  \n|Target value|Applies to|  \n|------------------|----------------|  \n|`assembly`|Entire assembly|  \n|`module`|Current assembly module|  \n|`field`|Field in a class or a struct|  \n|`event`|Event|  \n|`method`|Method or `get` and `set` property accessors|  \n|`param`|Method parameters or `set` property accessor parameters|  \n|`property`|Property|  \n|`return`|Return value of a method, property indexer, or `get` property accessor|  \n|`type`|Struct, class, interface, enum, or delegate|  \n  \n The following example shows how to apply attributes to assemblies and modules. For more information, see [Common Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/common-attributes.md).  \n  \n```csharp  \nusing System;  \nusing System.Reflection;  \n[assembly: AssemblyTitleAttribute(\"Production assembly 4\")]  \n[module: CLSCompliant(true)]  \n```  \n  \n The following example shows how to apply attributes to methods, method parameters, and method return values in C#.  \n  \n```csharp  \n// default: applies to method  \n[SomeAttr]  \nint Method1() { return 0; }  \n  \n// applies to method  \n[method: SomeAttr]  \nint Method2() { return 0; }  \n  \n// applies to return value  \n[return: SomeAttr]  \nint Method3() { return 0; }  \n```  \n  \n> [!NOTE]\n>  Regardless of the targets on which `SomeAttr` is defined to be valid, the `return` target has to be specified, even if `SomeAttr` were defined to apply only to return values. In other words, the compiler will not use `AttributeUsage` information to resolve ambiguous attribute targets. For more information, see [AttributeUsage (C#)](../../../../csharp/programming-guide/concepts/attributes/attributeusage.md).  \n  \n## Common Uses for Attributes  \n The following list includes a few of the common uses of attributes in code:  \n  \n-   Marking methods using the `WebMethod` attribute in Web services to indicate that the method should be callable over the SOAP protocol. For more information, see <xref:System.Web.Services.WebMethodAttribute>.  \n  \n-   Describing how to marshal method parameters when interoperating with native code. For more information, see <xref:System.Runtime.InteropServices.MarshalAsAttribute>.  \n  \n-   Describing the COM properties for classes, methods, and interfaces.  \n  \n-   Calling unmanaged code using the <xref:System.Runtime.InteropServices.DllImportAttribute> class.  \n  \n-   Describing your assembly in terms of title, version, description, or trademark.  \n  \n-   Describing which members of a class to serialize for persistence.  \n  \n-   Describing how to map between class members and XML nodes for XML serialization.  \n  \n-   Describing the security requirements for methods.  \n  \n-   Specifying characteristics used to enforce security.  \n  \n-   Controlling optimizations by the just-in-time (JIT) compiler so the code remains easy to debug.  \n  \n-   Obtaining information about the caller to a method.  \n  \n## Related Sections  \n For more information, see:  \n  \n-   [Creating Custom Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/creating-custom-attributes.md)  \n  \n-   [Accessing Attributes by Using Reflection (C#)](../../../../csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection.md)  \n  \n-   [How to: Create a C/C++ Union by Using Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/how-to-create-a-c-cpp-union-by-using-attributes.md)  \n  \n-   [Common Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/common-attributes.md)  \n  \n-   [Caller Information (C#)](../../../../csharp/programming-guide/concepts/caller-information.md)  \n  \n## See Also  \n [C# Programming Guide](../../../../csharp/programming-guide/index.md)   \n [Reflection (C#)](../../../../csharp/programming-guide/concepts/reflection.md)   \n [Attributes](https://msdn.microsoft.com/library/5x6cd29c)","nodes":[{"pos":[4,396],"nodes":[{"content":"Attributes (C#) | Microsoft Docs","nodes":[{"pos":[0,32],"content":"Attributes (C#) | Microsoft Docs","nodes":[{"content":"Attributes (C#) | Microsoft Docs","pos":[0,32]}]}],"pos":[6,41],"yaml":true}],"content":"title: \"Attributes (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: f148f13f-a0d5-4f22-9c87-4b73d5dde270\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","yamlblock":true},{"pos":[403,418],"content":"Attributes (C#)","linkify":"Attributes (C#)","nodes":[{"content":"Attributes (C#)","pos":[0,15]}]},{"content":"Attributes provide a powerful method of associating metadata, or declarative information, with code (assemblies, types, methods, properties, and so forth).","pos":[419,574]},{"content":"After an attribute is associated with a program entity, the attribute can be queried at run time by using a technique called <bpt id=\"p1\">*</bpt>reflection<ept id=\"p1\">*</ept>.","pos":[575,713],"source":" After an attribute is associated with a program entity, the attribute can be queried at run time by using a technique called *reflection*."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Reflection (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/reflection.md)</ept>.","pos":[714,819],"source":" For more information, see [Reflection (C#)](../../../../csharp/programming-guide/concepts/reflection.md)."},{"content":"Attributes have the following properties:","pos":[826,867]},{"content":"Attributes add metadata to your program.","pos":[877,917]},{"content":"<bpt id=\"p1\">*</bpt>Metadata<ept id=\"p1\">*</ept> is information about the types defined in a program.","pos":[918,981],"source":"*Metadata* is information about the types defined in a program."},{"content":"All .NET assemblies contain a specified set of metadata that describes the types and type members defined in the assembly.","pos":[982,1104]},{"content":"You can add custom attributes to specify any additional information that is required.","pos":[1105,1190]},{"content":"For more information, see, <bpt id=\"p1\">[</bpt>Creating Custom Attributes (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/creating-custom-attributes.md)</ept>.","pos":[1191,1340],"source":" For more information, see, [Creating Custom Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/creating-custom-attributes.md)."},{"content":"You can apply one or more attributes to entire assemblies, modules, or smaller program elements such as classes and properties.","pos":[1350,1477]},{"content":"Attributes can accept arguments in the same way as methods and properties.","pos":[1487,1561]},{"content":"Your program can examine its own metadata or the metadata in other programs by using reflection.","pos":[1571,1667]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Accessing Attributes by Using Reflection (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection.md)</ept>.","pos":[1668,1844],"source":" For more information, see [Accessing Attributes by Using Reflection (C#)](../../../../csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection.md)."},{"pos":[1853,1869],"content":"Using Attributes","linkify":"Using Attributes","nodes":[{"content":"Using Attributes","pos":[0,16]}]},{"content":"Attributes can be placed on most any declaration, though a specific attribute might restrict the types of declarations on which it is valid.","pos":[1873,2013]},{"content":"In C#, you specify an attribute by placing the name of the attribute, enclosed in square brackets ([]), above the declaration of the entity to which it applies.","pos":[2014,2174]},{"content":"In this example, the <ph id=\"ph1\">&lt;xref:System.SerializableAttribute&gt;</ph> attribute is used to apply a specific characteristic to a class:","pos":[2181,2302],"source":"In this example, the <xref:System.SerializableAttribute> attribute is used to apply a specific characteristic to a class:"},{"content":"A method with the attribute <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> is declared like this:","pos":[2438,2545],"source":"A method with the attribute <xref:System.Runtime.InteropServices.DllImportAttribute> is declared like this:"},{"content":"More than one attribute can be placed on a declaration:","pos":[2730,2785]},{"content":"Some attributes can be specified more than once for a given entity.","pos":[3003,3070]},{"content":"An example of such a multiuse attribute is <ph id=\"ph1\">&lt;xref:System.Diagnostics.ConditionalAttribute&gt;</ph>:","pos":[3071,3161],"source":" An example of such a multiuse attribute is <xref:System.Diagnostics.ConditionalAttribute>:"},{"pos":[3279,3649],"content":"[!NOTE]\n By convention, all attribute names end with the word \"Attribute\" to distinguish them from other items in the .NET Framework. However, you do not need to specify the attribute suffix when using attributes in code. For example, `[DllImport]` is equivalent to `[DllImportAttribute]`, but `DllImportAttribute` is the attribute's actual name in the .NET Framework.","leadings":["","> "],"nodes":[{"content":"By convention, all attribute names end with the word \"Attribute\" to distinguish them from other items in the .NET Framework. However, you do not need to specify the attribute suffix when using attributes in code. For example, `[DllImport]` is equivalent to `[DllImportAttribute]`, but `DllImportAttribute` is the attribute's actual name in the .NET Framework.","pos":[9,368],"nodes":[{"content":"By convention, all attribute names end with the word \"Attribute\" to distinguish them from other items in the .NET Framework.","pos":[0,124]},{"content":"However, you do not need to specify the attribute suffix when using attributes in code.","pos":[125,212]},{"content":"For example, <ph id=\"ph1\">`[DllImport]`</ph> is equivalent to <ph id=\"ph2\">`[DllImportAttribute]`</ph>, but <ph id=\"ph3\">`DllImportAttribute`</ph> is the attribute's actual name in the .NET Framework.","pos":[213,359],"source":" For example, `[DllImport]` is equivalent to `[DllImportAttribute]`, but `DllImportAttribute` is the attribute's actual name in the .NET Framework."}]}]},{"pos":[3659,3679],"content":"Attribute Parameters","linkify":"Attribute Parameters","nodes":[{"content":"Attribute Parameters","pos":[0,20]}]},{"content":"Many attributes have parameters, which can be positional, unnamed, or named.","pos":[3683,3759]},{"content":"Any positional parameters must be specified in a certain order and cannot be omitted; named parameters are optional and can be specified in any order.","pos":[3760,3910]},{"content":"Positional parameters are specified first.","pos":[3911,3953]},{"content":"For example, these three attributes are equivalent:","pos":[3954,4005]},{"content":"The first parameter, the DLL name, is positional and always comes first; the others are named.","pos":[4199,4293]},{"content":"In this case, both named parameters default to false, so they can be omitted.","pos":[4294,4371]},{"content":"Refer to the individual attribute's documentation for information on default parameter values.","pos":[4372,4466]},{"pos":[4476,4493],"content":"Attribute Targets","linkify":"Attribute Targets","nodes":[{"content":"Attribute Targets","pos":[0,17]}]},{"content":"The <bpt id=\"p1\">*</bpt>target<ept id=\"p1\">*</ept> of an attribute is the entity to which the attribute applies.","pos":[4497,4571],"source":"The *target* of an attribute is the entity to which the attribute applies."},{"content":"For example, an attribute may apply to a class, a particular method, or an entire assembly.","pos":[4572,4663]},{"content":"By default, an attribute applies to the element that it precedes.","pos":[4664,4729]},{"content":"But you can also explicitly identify, for example, whether an attribute is applied to a method, or to its parameter, or to its return value.","pos":[4730,4870]},{"content":"To explicitly identify an attribute target, use the following syntax:","pos":[4877,4946]},{"pos":[5002,5071],"content":"The list of possible <ph id=\"ph1\">`target`</ph> values is shown in the following table.","source":"The list of possible `target` values is shown in the following table."},{"content":"Target value","pos":[5078,5090]},{"content":"Applies to","pos":[5091,5101]},{"content":"Entire assembly","pos":[5157,5172]},{"content":"Current assembly module","pos":[5186,5209]},{"content":"Field in a class or a struct","pos":[5222,5250]},{"content":"Event","pos":[5263,5268]},{"pos":[5282,5326],"content":"Method or <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> property accessors","source":"Method or `get` and `set` property accessors"},{"pos":[5339,5394],"content":"Method parameters or <ph id=\"ph1\">`set`</ph> property accessor parameters","source":"Method parameters or `set` property accessor parameters"},{"content":"Property","pos":[5410,5418]},{"pos":[5432,5502],"content":"Return value of a method, property indexer, or <ph id=\"ph1\">`get`</ph> property accessor","source":"Return value of a method, property indexer, or `get` property accessor"},{"content":"Struct, class, interface, enum, or delegate","pos":[5514,5557]},{"content":"The following example shows how to apply attributes to assemblies and modules.","pos":[5565,5643]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Common Attributes (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/common-attributes.md)</ept>.","pos":[5644,5774],"source":" For more information, see [Common Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/common-attributes.md)."},{"content":"The following example shows how to apply attributes to methods, method parameters, and method return values in C#.","pos":[5938,6052]},{"pos":[6316,6737],"content":"[!NOTE]\n Regardless of the targets on which `SomeAttr` is defined to be valid, the `return` target has to be specified, even if `SomeAttr` were defined to apply only to return values. In other words, the compiler will not use `AttributeUsage` information to resolve ambiguous attribute targets. For more information, see [AttributeUsage (C#)](../../../../csharp/programming-guide/concepts/attributes/attributeusage.md).","leadings":["","> "],"nodes":[{"content":"Regardless of the targets on which `SomeAttr` is defined to be valid, the `return` target has to be specified, even if `SomeAttr` were defined to apply only to return values. In other words, the compiler will not use `AttributeUsage` information to resolve ambiguous attribute targets. For more information, see [AttributeUsage (C#)](../../../../csharp/programming-guide/concepts/attributes/attributeusage.md).","pos":[9,419],"nodes":[{"content":"Regardless of the targets on which <ph id=\"ph1\">`SomeAttr`</ph> is defined to be valid, the <ph id=\"ph2\">`return`</ph> target has to be specified, even if <ph id=\"ph3\">`SomeAttr`</ph> were defined to apply only to return values.","pos":[0,174],"source":"Regardless of the targets on which `SomeAttr` is defined to be valid, the `return` target has to be specified, even if `SomeAttr` were defined to apply only to return values."},{"content":"In other words, the compiler will not use <ph id=\"ph1\">`AttributeUsage`</ph> information to resolve ambiguous attribute targets.","pos":[175,285],"source":" In other words, the compiler will not use `AttributeUsage` information to resolve ambiguous attribute targets."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>AttributeUsage (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/attributeusage.md)</ept>.","pos":[286,410],"source":" For more information, see [AttributeUsage (C#)](../../../../csharp/programming-guide/concepts/attributes/attributeusage.md)."}]}]},{"pos":[6746,6772],"content":"Common Uses for Attributes","linkify":"Common Uses for Attributes","nodes":[{"content":"Common Uses for Attributes","pos":[0,26]}]},{"content":"The following list includes a few of the common uses of attributes in code:","pos":[6776,6851]},{"content":"Marking methods using the <ph id=\"ph1\">`WebMethod`</ph> attribute in Web services to indicate that the method should be callable over the SOAP protocol.","pos":[6861,6995],"source":"Marking methods using the `WebMethod` attribute in Web services to indicate that the method should be callable over the SOAP protocol."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Web.Services.WebMethodAttribute&gt;</ph>.","pos":[6996,7068],"source":" For more information, see <xref:System.Web.Services.WebMethodAttribute>."},{"content":"Describing how to marshal method parameters when interoperating with native code.","pos":[7078,7159]},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph>.","pos":[7160,7243],"source":" For more information, see <xref:System.Runtime.InteropServices.MarshalAsAttribute>."},{"content":"Describing the COM properties for classes, methods, and interfaces.","pos":[7253,7320]},{"content":"Calling unmanaged code using the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> class.","pos":[7330,7426],"source":"Calling unmanaged code using the <xref:System.Runtime.InteropServices.DllImportAttribute> class."},{"content":"Describing your assembly in terms of title, version, description, or trademark.","pos":[7436,7515]},{"content":"Describing which members of a class to serialize for persistence.","pos":[7525,7590]},{"content":"Describing how to map between class members and XML nodes for XML serialization.","pos":[7600,7680]},{"content":"Describing the security requirements for methods.","pos":[7690,7739]},{"content":"Specifying characteristics used to enforce security.","pos":[7749,7801]},{"content":"Controlling optimizations by the just-in-time (JIT) compiler so the code remains easy to debug.","pos":[7811,7906]},{"content":"Obtaining information about the caller to a method.","pos":[7916,7967]},{"pos":[7976,7992],"content":"Related Sections","linkify":"Related Sections","nodes":[{"content":"Related Sections","pos":[0,16]}]},{"content":"For more information, see:","pos":[7996,8022]},{"pos":[8032,8153],"content":"<bpt id=\"p1\">[</bpt>Creating Custom Attributes (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/creating-custom-attributes.md)</ept>","source":"[Creating Custom Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/creating-custom-attributes.md)"},{"pos":[8163,8312],"content":"<bpt id=\"p1\">[</bpt>Accessing Attributes by Using Reflection (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection.md)</ept>","source":"[Accessing Attributes by Using Reflection (C#)](../../../../csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection.md)"},{"pos":[8322,8486],"content":"<bpt id=\"p1\">[</bpt>How to: Create a C/C++ Union by Using Attributes (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/how-to-create-a-c-cpp-union-by-using-attributes.md)</ept>","source":"[How to: Create a C/C++ Union by Using Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/how-to-create-a-c-cpp-union-by-using-attributes.md)"},{"pos":[8496,8599],"content":"<bpt id=\"p1\">[</bpt>Common Attributes (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/attributes/common-attributes.md)</ept>","source":"[Common Attributes (C#)](../../../../csharp/programming-guide/concepts/attributes/common-attributes.md)"},{"pos":[8609,8703],"content":"<bpt id=\"p1\">[</bpt>Caller Information (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/caller-information.md)</ept>","source":"[Caller Information (C#)](../../../../csharp/programming-guide/concepts/caller-information.md)"},{"pos":[8712,8720],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[8724,8794],"source":"[C# Programming Guide](../../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Reflection (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/reflection.md)</ept><ph id=\"ph1\"> </ph>","pos":[8798,8877],"source":"[Reflection (C#)](../../../../csharp/programming-guide/concepts/reflection.md) "},{"content":"<bpt id=\"p1\">[</bpt>Attributes<ept id=\"p1\">](https://msdn.microsoft.com/library/5x6cd29c)</ept>","pos":[8881,8938],"source":"[Attributes](https://msdn.microsoft.com/library/5x6cd29c)"}]}