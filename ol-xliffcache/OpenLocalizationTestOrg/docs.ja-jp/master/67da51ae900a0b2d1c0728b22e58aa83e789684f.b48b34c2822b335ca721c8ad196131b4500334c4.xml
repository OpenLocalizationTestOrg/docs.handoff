{"content":"---\ntitle: \"Writing Large, Responsive .NET Framework Apps\"\nms.date: \"03/30/2017\"\nms.assetid: 123457ac-4223-4273-bb58-3bc0e4957e9d\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n---\n# Writing Large, Responsive .NET Framework Apps\nThis article provides tips for improving the performance of large .NET Framework apps, or apps that process a large amount of data such as files or databases. These tips come from rewriting the C# and Visual Basic compilers in managed code, and this article includes several real examples from the C# compiler. \n  \n The .NET Framework is highly productive for building apps. Powerful and safe languages and a rich collection of libraries make app building highly fruitful. However, with great productivity comes responsibility. You should use all the power of the .NET Framework, but be prepared to tune your code’s performance when needed. \n  \n## Why the new compiler performance applies to your app  \n The .NET Compiler Platform (\"Roslyn\") team rewrote the C# and Visual Basic compilers in managed code to provide new APIs for modeling and analyzing code, building tools, and enabling much richer, code-aware experiences in Visual Studio. Rewriting the compilers and building Visual Studio experiences on the new compilers revealed useful performance insights that are applicable to any large .NET Framework app or any app that processes a lot of data. You don't need to know about compilers to take advantage of the insights and examples from the C# compiler. \n  \n Visual Studio uses the compiler APIs to build all the IntelliSense features that users love, such as colorization of identifiers and keywords, syntax completion lists, squiggles for errors, parameter tips, code issues, and code actions. Visual Studio provides this help while developers are typing and changing their code, and Visual Studio must remain responsive while the compiler continually models the code developers edit. \n  \n When your end users interact with your app, they expect it to be responsive. Typing or command handling should never be blocked. Help should pop up quickly or give up if the user continues typing. Your app should avoid blocking the UI thread with long computations that make the app feel sluggish. \n  \n For more information about Roslyn compilers, see [The .NET Compiler Platform SDK](../../csharp/roslyn-sdk/index.md).\n  \n## Just the Facts  \n Consider these facts when tuning performance and creating responsive .NET Framework apps. \n  \n### Fact 1: Don’t prematurely optimize  \n Writing code that is more complex than it needs to be incurs maintenance, debugging, and polishing costs. Experienced programmers have an intuitive grasp of how to solve coding problems and write more efficient code. However, they sometimes prematurely optimize their code. For example, they use a hash table when a simple array would suffice, or use complicated caching that may leak memory instead of simply recomputing values. Even if you’re an experience programmer, you should test for performance and analyze your code when you find issues. \n  \n### Fact 2: If you’re not measuring, you’re guessing  \n Profiles and measurements don’t lie. Profiles show you whether the CPU is fully loaded or whether you’re blocked on disk I/O. Profiles tell you what kind and how much memory you’re allocating and whether your CPU is spending a lot of time in [garbage collection](../../../docs/standard/garbage-collection/index.md) (GC). \n  \n You should set performance goals for key customer experiences or scenarios in your app and write tests to measure performance. Investigate failing tests by applying the scientific method: use profiles to guide you, hypothesize what the issue might be, and test your hypothesis with an experiment or code change. Establish baseline performance measurements over time with regular testing, so you can isolate changes that cause regressions in performance. By approaching performance work in a rigorous way, you’ll avoid wasting time with code updates you don’t need. \n  \n### Fact 3: Good tools make all the difference  \n Good tools let you drill quickly into the biggest performance issues (CPU, memory, or disk) and help you locate the code that causes those bottlenecks. Microsoft ships a variety of performance tools such as [Visual Studio Profiler](/visualstudio/profiling/beginners-guide-to-performance-profiling) and [PerfView](https://www.microsoft.com/download/details.aspx?id=28567). \n  \n PerfView is a free and amazingly powerful tool that helps you focus on deep issues such as disk I/O, GC events, and memory. You can capture performance-related [Event Tracing for Windows](../../../docs/framework/wcf/samples/etw-tracing.md) (ETW) events and view easily per app, per process, per stack, and per thread information. PerfView shows you how much and what kind of memory your app allocates, and which functions or call stacks contribute how much to the memory allocations. For details, see the rich help topics, demos, and videos included with the tool (such as the [PerfView tutorials](https://channel9.msdn.com/Series/PerfView-Tutorial) on Channel 9). \n  \n### Fact 4: It’s all about allocations  \n You might think that building a responsive .NET Framework app is all about algorithms, such as using quick sort instead of bubble sort, but that's not the case. The biggest factor in building a responsive app is allocating memory, especially when your app is very large or processes large amounts of data. \n  \n Almost all the work to build responsive IDE experiences with the new compiler APIs involved avoiding allocations and managing caching strategies. PerfView traces show that the performance of the new C# and Visual Basic compilers is rarely CPU bound. The compilers can be I/O bound when reading hundreds of thousands or millions of lines of code, reading metadata, or emitting generated code. The UI thread delays are nearly all due to garbage collection. The .NET Framework GC is highly tuned for performance and does much of its work concurrently while app code executes. However, a single allocation can trigger an expensive [gen2](../../../docs/standard/garbage-collection/fundamentals.md) collection, stopping all threads. \n  \n## Common allocations and examples  \n The example expressions in this section have hidden allocations that appear small. However, if a large app executes the expressions enough times, they can causes hundreds of megabytes, even gigabytes, of allocations. For example, one-minute tests that simulated a developer’s typing in the editor allocated gigabytes of memory and led the performance team to focus on typing scenarios. \n  \n### Boxing  \n [Boxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md) occurs when value types that normally live on the stack or in data structures are wrapped in an object. That is, you allocate an object to hold the data, and then return a pointer to the object. The .NET Framework sometimes boxes values due to the signature of a method or the type of a storage location. Wrapping a value type in an object causes memory allocation. Many boxing operations can contribute megabytes or gigabytes of allocations to your app, which means that your app will cause more GCs. The .NET Framework and the language compilers avoid boxing when possible, but sometimes it happens when you least expect it. \n  \n To see boxing in PerfView, open a trace and look at GC Heap Alloc Stacks under your app’s process name (remember, PerfView reports on all processes). If you see types like <xref:System.Int32?displayProperty=nameWithType> and <xref:System.Char?displayProperty=nameWithType> under allocations, you are boxing value types. Choosing one of these types will show the stacks and functions in which they are boxed. \n  \n **Example 1: string methods and value type arguments**  \n  \n This sample code illustrates potentially unnecessary and excessive boxing:  \n  \n```csharp  \npublic class Logger  \n{  \n    public static void WriteLine(string s) { /*...*/ }  \n}  \n  \npublic class BoxingExample  \n{  \n    public void Log(int id, int size)  \n    {  \n        var s = string.Format(\"{0}:{1}\", id, size);  \n        Logger.WriteLine(s);  \n    }  \n}  \n```  \n  \n This code provides logging functionality, so an app may call the `Log` function frequently, maybe millions of times. The problem is that the call to `string.Format` resolves to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> overload. \n  \n This overload requires the .NET Framework to box the `int` values into objects to pass them to this method call. A partial fix is to call `id.ToString()` and `size.ToString()` and pass all strings (which are objects) to the `string.Format` call. Calling `ToString()` does allocate a string, but that allocation will happen anyway inside `string.Format`. \n  \n You might consider that this basic call to `string.Format` is just string concatenation, so you might write this code instead:  \n  \n```csharp  \nvar s = id.ToString() + ':' + size.ToString();  \n```  \n  \n However, that line of code introduces a boxing allocation because it compiles to <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%29>. The .NET Framework must box the character literal to invoke `Concat`  \n  \n **Fix for example 1**  \n  \n The complete fix is simple. Just replace the character literal with a string literal, which incurs no boxing because strings are already objects:  \n  \n```csharp  \nvar s = id.ToString() + \":\" + size.ToString();  \n```  \n  \n **Example 2: enum boxing**  \n  \n This example was responsible for a huge amount of allocation in the new C# and Visual Basic compilers due to frequent use of enumeration types, especially in dictionary lookup operations. \n  \n```csharp  \npublic enum Color  \n{  \n    Red, Green, Blue  \n}  \n  \npublic class BoxingExample  \n{  \n    private string name;  \n    private Color color;  \n    public override int GetHashCode()  \n    {  \n        return name.GetHashCode() ^ color.GetHashCode();  \n    }  \n}  \n```  \n  \n This problem is very subtle. PerfView would report this as <xref:System.Enum.GetHashCode> boxing because the method boxes the underlying representation of the enumeration type, for implementation reasons. If you look closely in PerfView, you may see two boxing allocations for each call to <xref:System.Enum.GetHashCode>. The compiler inserts one, and the .NET Framework inserts the other. \n  \n **Fix for example 2**  \n  \n You can easily avoid both allocations by casting to the underlying representation before calling <xref:System.Enum.GetHashCode>:  \n  \n```csharp  \n((int)color).GetHashCode()  \n```  \n  \n Another common source of boxing on enumeration types is the <xref:System.Enum.HasFlag%28System.Enum%29?displayProperty=nameWithType> method. The argument passed to <xref:System.Enum.HasFlag%28System.Enum%29> has to be boxed. In most cases, replacing calls to <xref:System.Enum.HasFlag%28System.Enum%29?displayProperty=nameWithType> with a bitwise test is simpler and allocation-free. \n  \n Keep the first performance fact in mind (that is, don’t prematurely optimize) and don’t start rewriting all your code in this way. Be aware of these boxing costs, but change your code only after profiling your app and finding the hot spots. \n  \n### Strings  \n String manipulations are some of the biggest culprits for allocations, and they often show up in PerfView in the top five allocations. Programs use strings for serialization, JSON, and REST APIs. You can use strings as programmatic constants for interoperating with systems when you can’t use enumeration types. When your profiling shows that strings are highly affecting performance, look for calls to <xref:System.String> methods such as <xref:System.String.Format%2A>, <xref:System.String.Concat%2A>, <xref:System.String.Split%2A>, <xref:System.String.Join%2A>, <xref:System.String.Substring%2A>, and so on. Using <xref:System.Text.StringBuilder> to avoid the cost of creating one string from many pieces helps, but even allocating the <xref:System.Text.StringBuilder> object might become a bottleneck that you need to manage. \n  \n **Example 3: string operations**  \n  \n The C# compiler had this code that writes the text of a formatted XML doc comment:  \n  \n```csharp  \npublic void WriteFormattedDocComment(string text)  \n{  \n    string[] lines = text.Split(new[] { \"\\r\\n\", \"\\r\", \"\\n\" },  \n                                StringSplitOptions.None);  \n    int numLines = lines.Length;  \n    bool skipSpace = true;  \n    if (lines[0].TrimStart().StartsWith(\"///\"))  \n    {  \n        for (int i = 0; i < numLines; i++)  \n        {  \n            string trimmed = lines[i].TrimStart();  \n            if (trimmed.Length < 4 || !char.IsWhiteSpace(trimmed[3]))  \n            {  \n                skipSpace = false;  \n                break;  \n            }  \n        }  \n        int substringStart = skipSpace ? 4 : 3;  \n        for (int i = 0; i < numLines; i++)  \n            WriteLine(lines[i].TrimStart().Substring(substringStart));  \n    }  \n    else { /* ... */ }  \n```  \n  \n You can see that this code does a lot of string manipulation. The code uses library methods to split lines into separate strings, to trim white space, to check whether the argument `text` is an XML documentation comment, and to extract substrings from lines. \n  \n On the first line inside `WriteFormattedDocComment`, the `text.Split` call allocates a new three-element array as the argument every time it’s called. The compiler has to emit code to allocate this array each time. That’s because the compiler doesn’t know if <xref:System.String.Split%2A> stores the array somewhere where the array might be modified by other code, which would affect later calls to `WriteFormattedDocComment`. The call to <xref:System.String.Split%2A> also allocates a string for every line in `text` and allocates other memory to perform the operation. \n  \n `WriteFormattedDocComment` has three calls to the <xref:System.String.TrimStart%2A> method. Two are in inner loops that duplicate work and allocations. To make matters worse, calling the <xref:System.String.TrimStart%2A> method with no arguments allocates an empty array (for the `params` parameter) in addition to the string result. \n  \n Lastly, there is a call to the <xref:System.String.Substring%2A> method, which usually allocates a new string. \n  \n **Fix for example 3**  \n  \n Unlike the earlier examples, small edits cannot fix these allocations. You need to step back, look at the problem, and approach it differently. For example, you'll notice that the argument to `WriteFormattedDocComment()` is a string that has all the information that the method needs, so the code could do more indexing instead of allocating many partial strings. \n  \n The compiler’s performance team tackled all these allocations with code like this:  \n  \n```csharp  \nprivate int IndexOfFirstNonWhiteSpaceChar(string text, int start) {  \n    while (start < text.Length && char.IsWhiteSpace(text[start])) start++;  \n    return start;  \n}  \n  \nprivate bool TrimmedStringStartsWith(string text, int start, string prefix) {  \n    start = IndexOfFirstNonWhiteSpaceChar(text, start);  \n    int len = text.Length - start;  \n    if (len < prefix.Length) return false;  \n    for (int i = 0; i < len; i++)  \n    {  \n        if (prefix[i] != text[start + i]) return false;  \n    }  \n    return true;  \n}  \n  \n// etc... \n```  \n  \n The first version of `WriteFormattedDocComment()` allocated an array, several substrings, and a trimmed substring along with an empty `params` array. It also checked for \"///\". The revised code uses only indexing and allocates nothing. It finds the first character that is not white space, and then checks character by character to see if the string starts with \"///\". The new code uses `IndexOfFirstNonWhiteSpaceChar` instead of <xref:System.String.TrimStart%2A> to return the first index (after a specified start index) where a non-white-space character occurs. The fix is not complete, but you can see how to apply similar fixes for a complete solution. By applying this approach throughout the code, you can remove all allocations in `WriteFormattedDocComment()`. \n  \n **Example 4: StringBuilder**  \n  \n This example uses a <xref:System.Text.StringBuilder> object. The following function generates a full type name for generic types:  \n  \n```csharp  \npublic class Example  \n{  \n    // Constructs a name like \"SomeType<T1, T2, T3>\"  \n    public string GenerateFullTypeName(string name, int arity)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n  \n        sb.Append(name);  \n        if (arity != 0)  \n        {  \n            sb.Append(\"<\");  \n            for (int i = 1; i < arity; i++)  \n            {  \n                sb.Append(\"T\"); sb.Append(i.ToString()); sb.Append(\", \");  \n            }  \n            sb.Append(\"T\"); sb.Append(i.ToString()); sb.Append(\">\");  \n        }  \n  \n        return sb.ToString();  \n    }  \n}  \n```  \n  \n The focus is on the line that creates a new <xref:System.Text.StringBuilder> instance. The code causes an allocation for `sb.ToString()` and internal allocations within the <xref:System.Text.StringBuilder> implementation, but you cannot control those allocations if you want the string result. \n  \n **Fix for example 4**  \n  \n To fix the `StringBuilder` object allocation, cache the  object. Even caching a single instance that might get thrown away can improve performance significantly. This is the function’s new implementation, omitting all the code except for the new first and last lines:  \n  \n```csharp  \n// Constructs a name like \"MyType<T1, T2, T3>\"  \npublic string GenerateFullTypeName(string name, int arity)  \n{  \n    StringBuilder sb = AcquireBuilder();  \n    /* Use sb as before */  \n    return GetStringAndReleaseBuilder(sb);  \n}  \n```  \n  \n The key parts are the new `AcquireBuilder()` and `GetStringAndReleaseBuilder()` functions:  \n  \n```csharp  \n[ThreadStatic]  \nprivate static StringBuilder cachedStringBuilder;  \n  \nprivate static StringBuilder AcquireBuilder()  \n{  \n    StringBuilder result = cachedStringBuilder;  \n    if (result == null)  \n    {  \n        return new StringBuilder();  \n    }  \n    result.Clear();  \n    cachedStringBuilder = null;  \n    return result;  \n}  \n  \nprivate static string GetStringAndReleaseBuilder(StringBuilder sb)  \n{  \n    string result = sb.ToString();  \n    cachedStringBuilder = sb;  \n    return result;  \n}  \n```  \n  \n Because the new compilers use threading, these implementations use a thread-static field (<xref:System.ThreadStaticAttribute> attribute) to cache the <xref:System.Text.StringBuilder>, and you likely can forgo the `ThreadStatic` declaration. The thread-static field holds a unique value for each thread that executes this code. \n  \n `AcquireBuilder()` returns the cached <xref:System.Text.StringBuilder> instance if there is one, after clearing it and setting the field or cache to null. Otherwise, `AcquireBuilder()` creates a new instance and returns it, leaving the field or cache set to null. \n  \n When you’re done with <xref:System.Text.StringBuilder> , you call `GetStringAndReleaseBuilder()` to get the string result, save the <xref:System.Text.StringBuilder> instance in the field or cache, and then return the result. It is possible for execution to re-enter this code and to create multiple <xref:System.Text.StringBuilder> objects (although that rarely happens). The code saves only the last released <xref:System.Text.StringBuilder> instance for later use. This simple caching strategy significantly reduced allocations in the new compilers. Parts of the .NET Framework and MSBuild (\"MSBuild\") use a similar technique to improve performance. \n  \n This simple caching strategy adheres to good cache design because it has a size cap. However, there is more code now than in the original, which means more maintenance costs. You should adopt the caching strategy only if you’ve found a performance problem, and PerfView has shown that <xref:System.Text.StringBuilder> allocations are a significant contributor. \n  \n### LINQ and lambdas  \nLanguage-Integrated Query (LINQ), in conjunction with lambda expressions, is an example of a productivity feature. However, its use may have a significant impact on performance over time, and you might find you need to rewrite your code.\n  \n **Example 5: Lambdas, List\\<T>, and IEnumerable\\<T>**  \n  \n This example uses [LINQ and functional style code](https://blogs.msdn.com/b/charlie/archive/2007/01/26/anders-hejlsberg-on-linq-and-functional-programming.aspx) to find a symbol in the compiler’s model, given a name string:  \n  \n```csharp  \nclass Symbol {  \n    public string Name { get; private set; }  \n    /*...*/  \n}  \n  \nclass Compiler {  \n    private List<Symbol> symbols;  \n    public Symbol FindMatchingSymbol(string name)  \n    {  \n        return symbols.FirstOrDefault(s => s.Name == name);  \n    }  \n}  \n```  \n  \n The new compiler and the IDE experiences built on it call `FindMatchingSymbol()` very frequently, and there are several hidden allocations in this function’s single line of code. To examine those allocations, first split the function’s single line of code into two lines:  \n  \n```csharp  \nFunc<Symbol, bool> predicate = s => s.Name == name;  \n     return symbols.FirstOrDefault(predicate);  \n```  \n  \n In the first line, the [lambda expression](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) `s => s.Name == name` [closes over](https://blogs.msdn.com/b/ericlippert/archive/2003/09/17/53028.aspx) the local variable `name`. This means that in addition to allocating an object for the [delegate](~/docs/csharp/language-reference/keywords/delegate.md) that `predicate` holds, the code allocates a static class to hold the environment that captures the value of `name`. The compiler generates code like the following:  \n  \n```csharp  \n// Compiler-generated class to hold environment state for lambda  \nprivate class Lambda1Environment  \n{  \n    public string capturedName;  \n    public bool Evaluate(Symbol s)  \n    {  \n        return s.Name == this.capturedName;  \n    }  \n}  \n  \n// Expanded Func<Symbol, bool> predicate = s => s.Name == name;  \nLambda1Environment l = new Lambda1Environment() { capturedName = name };  \nvar predicate = new Func<Symbol, bool>(l.Evaluate);  \n```  \n  \n The two `new` allocations (one for the environment class and one for the delegate) are explicit now. \n  \n Now look at the call to `FirstOrDefault`. This extension method on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> type incurs an allocation too. Because `FirstOrDefault` takes an <xref:System.Collections.Generic.IEnumerable%601> object as its first argument, you can expand the call to the following code (simplified a bit for discussion):  \n  \n```csharp  \n// Expanded return symbols.FirstOrDefault(predicate) ... \n     IEnumerable<Symbol> enumerable = symbols;  \n     IEnumerator<Symbol> enumerator = enumerable.GetEnumerator();  \n     while(enumerator.MoveNext())  \n     {  \n         if (predicate(enumerator.Current))  \n             return enumerator.Current;  \n     }  \n     return default(Symbol);  \n```  \n  \n The `symbols` variable has type <xref:System.Collections.Generic.List%601>. The <xref:System.Collections.Generic.List%601> collection type implements <xref:System.Collections.Generic.IEnumerable%601> and cleverly defines an enumerator (<xref:System.Collections.Generic.IEnumerator%601> interface) that <xref:System.Collections.Generic.List%601> implements with a `struct`. Using a structure instead of a class means that you usually avoid any heap allocations, which, in turn, can affect garbage collection performance. Enumerators are typically used with the language’s `foreach` loop, which uses the enumerator structure as it is returned on the call stack. Incrementing the call stack pointer to make room for an object does not affect GC the way a heap allocation does. \n  \n In the case of the expanded `FirstOrDefault` call, the code needs to call `GetEnumerator()` on an <xref:System.Collections.Generic.IEnumerable%601>. Assigning `symbols` to the `enumerable` variable of type `IEnumerable<Symbol>` loses the information that the actual object is a <xref:System.Collections.Generic.List%601>. This means that when the code fetches the enumerator with `enumerable.GetEnumerator()`, the .NET Framework has to box the returned structure to assign it to the `enumerator` variable. \n  \n **Fix for example 5**  \n  \n The fix is to rewrite `FindMatchingSymbol` as follows, replacing its single line of code with six lines of code that are still concise, easy to read and understand, and easy to maintain:  \n  \n```csharp  \npublic Symbol FindMatchingSymbol(string name)  \n    {  \n        foreach (Symbol s in symbols)  \n        {  \n            if (s.Name == name)  \n                return s;  \n        }  \n        return null;  \n    }  \n```  \n  \n This code doesn’t use LINQ extension methods, lambdas, or enumerators, and it incurs no allocations. There are no allocations because the compiler can see that the `symbols` collection is a <xref:System.Collections.Generic.List%601> and can bind the resulting enumerator (a structure) to a local variable with the right type to avoid boxing. The original version of this function was a great example of the expressive power of C# and the productivity of the .NET Framework. This new and more efficient version preserves those qualities without adding any complex code to maintain. \n  \n### Async method caching  \n\nThe next example shows a common problem when you try to use cached results in an [async](../../csharp/programming-guide/concepts/async/index.md) method.\n  \n **Example 6: caching in async methods**  \n  \n The Visual Studio IDE features built on the new C# and Visual Basic compilers frequently fetch syntax trees, and the compilers use async when doing so to keep Visual Studio responsive. Here’s the first version of the code you might write to get a syntax tree:  \n  \n```csharp  \nclass SyntaxTree { /*...*/ }  \n  \nclass Parser { /*...*/  \n    public SyntaxTree Syntax { get; }  \n    public Task ParseSourceCode() { /*...*/ }  \n}  \n  \nclass Compilation { /*...*/  \n    public async Task<SyntaxTree> GetSyntaxTreeAsync()  \n    {  \n        var parser = new Parser(); // allocation  \n        await parser.ParseSourceCode(); // expensive  \n        return parser.Syntax;  \n    }  \n}  \n```  \n  \n You can see that calling `GetSyntaxTreeAsync()` instantiates a `Parser`, parses the code, and then returns a <xref:System.Threading.Tasks.Task> object, `Task<SyntaxTree>`. The expensive part is allocating the `Parser` instance and parsing the code. The function returns a <xref:System.Threading.Tasks.Task> so that callers can await the parsing work and free the UI thread to be responsive to user input. \n  \n Several Visual Studio features might try to get the same syntax tree, so you might write the following code to cache the parsing result to save time and allocations. However, this code incurs an allocation:  \n  \n```csharp  \nclass Compilation { /*...*/  \n  \n    private SyntaxTree cachedResult;  \n  \n    public async Task<SyntaxTree> GetSyntaxTreeAsync()  \n    {  \n        if (this.cachedResult == null)  \n        {  \n            var parser = new Parser(); // allocation  \n            await parser.ParseSourceCode(); // expensive  \n            this.cachedResult = parser.Syntax;  \n        }  \n        return this.cachedResult;  \n    }  \n}  \n```  \n  \n You see that the new code with caching has a `SyntaxTree` field named `cachedResult`. When this field is null, `GetSyntaxTreeAsync()` does the work and saves the result in the cache. `GetSyntaxTreeAsync()` returns the `SyntaxTree` object. The problem is that when you have an `async` function of type `Task<SyntaxTree>`, and you return a value of type `SyntaxTree`, the compiler emits code to allocate a Task to hold the result (by using `Task<SyntaxTree>.FromResult()`). The Task is marked as completed, and the result is immediately available. In the code for the new compilers, <xref:System.Threading.Tasks.Task> objects that were already completed occurred so often that fixing these allocations improved responsiveness noticeably. \n  \n **Fix for example 6**  \n  \n To remove the completed <xref:System.Threading.Tasks.Task> allocation, you can cache the Task object with the completed result:  \n  \n```csharp  \nclass Compilation { /*...*/  \n  \n    private Task<SyntaxTree> cachedResult;  \n  \n    public Task<SyntaxTree> GetSyntaxTreeAsync()  \n    {  \n        return this.cachedResult ??   \n               (this.cachedResult = GetSyntaxTreeUncachedAsync());  \n    }  \n  \n    private async Task<SyntaxTree> GetSyntaxTreeUncachedAsync()  \n    {  \n        var parser = new Parser(); // allocation  \n        await parser.ParseSourceCode(); // expensive  \n        return parser.Syntax;  \n    }  \n}  \n```  \n  \n This code changes the type of `cachedResult` to `Task<SyntaxTree>` and employs an `async` helper function that holds the original code from `GetSyntaxTreeAsync()`. `GetSyntaxTreeAsync()` now uses the [null coalescing operator](../../csharp/language-reference/operators/null-coalescing-operator.md) to return `cachedResult` if it isn't null. If `cachedResult` is null, then `GetSyntaxTreeAsync()` calls `GetSyntaxTreeUncachedAsync()` and caches the result. Notice that `GetSyntaxTreeAsync()` doesn’t await the call to `GetSyntaxTreeUncachedAsync()` as the code would normally. Not using await means that when `GetSyntaxTreeUncachedAsync()` returns its <xref:System.Threading.Tasks.Task> object, `GetSyntaxTreeAsync()` immediately returns the <xref:System.Threading.Tasks.Task>. Now, the cached result is a <xref:System.Threading.Tasks.Task>, so there are no allocations to return the cached result. \n  \n### Additional considerations  \n Here are a few more points about potential problems in large apps or apps that process a lot of data. \n  \n **Dictionaries**  \n  \n Dictionaries are used ubiquitously in many programs, and though dictionaries are very convenient and inherently efficient. However, they’re often used inappropriately. In Visual Studio and the new compilers, analysis shows that many of the dictionaries contained a single element or were empty. An empty <xref:System.Collections.Generic.Dictionary%602> has ten fields and occupies 48 bytes on the heap on an x86 machine. Dictionaries are great when you need a mapping or associative data structure with constant-time lookup. However, when you have only a few elements, you waste a lot of space by using a dictionary. Instead, for example, you could iteratively look through a `List<KeyValuePair\\<K,V>>`, just as fast. If you use a dictionary only to load it with data and then read from it (a very common pattern), using a sorted array with an N(log(N)) lookup might be nearly as fast, depending on the number of elements you're using. \n  \n **Classes vs. structures**  \n  \n In a way, classes and structures provide a classic space/time tradeoff for tuning your apps. Classes incur 12 bytes of overhead on an x86 machine even if they have no fields, but they are inexpensive to pass around because it only takes a pointer to refer to a class instance. Structures incur no heap allocations if they aren’t boxed, but when you pass large structures as function arguments or return values, it takes CPU time to atomically copy all the data members of the structures. Watch out for repeated calls to properties that return structures, and cache the property’s value in a local variable to avoid excessive data copying. \n  \n **Caches**  \n  \n A common performance trick is to cache results. However, a cache without a size cap or disposal policy can be a memory leak. When processing large amounts of data, if you hold on to a lot of memory in caches, you can cause garbage collection to override the benefits of your cached lookups. \n  \n In this article, we discussed how you should be aware of performance bottleneck symptoms that can affect your app's responsiveness, especially for large systems or systems that process a large amount of data. Common culprits include boxing, string manipulations, LINQ and lambda, caching in async methods, caching without a size limit or disposal policy, inappropriate use of dictionaries, and passing around structures. Keep in mind the four facts for tuning your apps:  \n  \n-   Don’t prematurely optimize – be productive and tune your app when you spot problems. \n  \n-   Profiles don’t lie – you’re guessing if you’re not measuring. \n  \n-   Good tools make all the difference – download PerfView and try it out. \n  \n-   It's all about allocations – that is where the compiler platform team spent most of their time improving the performance of the new compilers. \n  \n## See also\n\n- [Video of presentation of this topic](https://channel9.msdn.com/Events/TechEd/NorthAmerica/2013/DEV-B333)\n- [Beginners Guide to Performance Profiling](/visualstudio/profiling/beginners-guide-to-performance-profiling)\n- [Performance](../../../docs/framework/performance/index.md)\n- [.NET Performance Tips](https://docs.microsoft.com/previous-versions/dotnet/articles/ms973839(v%3dmsdn.10))\n- [Channel 9 PerfView tutorials](https://channel9.msdn.com/Series/PerfView-Tutorial)\n- [The .NET Compiler Platform SDK](../../csharp/roslyn-sdk/index.md)\n- [dotnet/roslyn repo on GitHub](https://github.com/dotnet/roslyn)\n","nodes":[{"pos":[4,170],"embed":true,"restype":"x-metadata","content":"title: \"Writing Large, Responsive .NET Framework Apps\"\nms.date: \"03/30/2017\"\nms.assetid: 123457ac-4223-4273-bb58-3bc0e4957e9d\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"","nodes":[{"content":"Writing Large, Responsive .NET Framework Apps","nodes":[{"pos":[0,45],"content":"Writing Large, Responsive .NET Framework Apps","nodes":[{"content":"Writing Large, Responsive .NET Framework Apps","pos":[0,45]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[177,222],"content":"Writing Large, Responsive .NET Framework Apps","linkify":"Writing Large, Responsive .NET Framework Apps","nodes":[{"content":"Writing Large, Responsive .NET Framework Apps","pos":[0,45]}]},{"content":"This article provides tips for improving the performance of large .NET Framework apps, or apps that process a large amount of data such as files or databases.","pos":[223,381]},{"content":"These tips come from rewriting the C# and Visual Basic compilers in managed code, and this article includes several real examples from the C# compiler.","pos":[382,533]},{"content":"The .NET Framework is highly productive for building apps.","pos":[539,597]},{"content":"Powerful and safe languages and a rich collection of libraries make app building highly fruitful.","pos":[598,695]},{"content":"However, with great productivity comes responsibility.","pos":[696,750]},{"content":"You should use all the power of the .NET Framework, but be prepared to tune your code’s performance when needed.","pos":[751,863]},{"pos":[871,923],"content":"Why the new compiler performance applies to your app","linkify":"Why the new compiler performance applies to your app","nodes":[{"content":"Why the new compiler performance applies to your app","pos":[0,52]}]},{"content":"The .NET Compiler Platform (\"Roslyn\") team rewrote the C# and Visual Basic compilers in managed code to provide new APIs for modeling and analyzing code, building tools, and enabling much richer, code-aware experiences in Visual Studio.","pos":[927,1163]},{"content":"Rewriting the compilers and building Visual Studio experiences on the new compilers revealed useful performance insights that are applicable to any large .NET Framework app or any app that processes a lot of data.","pos":[1164,1377]},{"content":"You don't need to know about compilers to take advantage of the insights and examples from the C# compiler.","pos":[1378,1485]},{"content":"Visual Studio uses the compiler APIs to build all the IntelliSense features that users love, such as colorization of identifiers and keywords, syntax completion lists, squiggles for errors, parameter tips, code issues, and code actions.","pos":[1491,1727]},{"content":"Visual Studio provides this help while developers are typing and changing their code, and Visual Studio must remain responsive while the compiler continually models the code developers edit.","pos":[1728,1918]},{"content":"When your end users interact with your app, they expect it to be responsive.","pos":[1924,2000]},{"content":"Typing or command handling should never be blocked.","pos":[2001,2052]},{"content":"Help should pop up quickly or give up if the user continues typing.","pos":[2053,2120]},{"content":"Your app should avoid blocking the UI thread with long computations that make the app feel sluggish.","pos":[2121,2221]},{"pos":[2227,2343],"content":"For more information about Roslyn compilers, see <bpt id=\"p1\">[</bpt>The .NET Compiler Platform SDK<ept id=\"p1\">](../../csharp/roslyn-sdk/index.md)</ept>.","source":"For more information about Roslyn compilers, see [The .NET Compiler Platform SDK](../../csharp/roslyn-sdk/index.md)."},{"pos":[2350,2364],"content":"Just the Facts","linkify":"Just the Facts","nodes":[{"content":"Just the Facts","pos":[0,14]}]},{"content":"Consider these facts when tuning performance and creating responsive .NET Framework apps.","pos":[2368,2457]},{"pos":[2466,2500],"content":"Fact 1: Don’t prematurely optimize","linkify":"Fact 1: Don’t prematurely optimize","nodes":[{"content":"Fact 1: Don’t prematurely optimize","pos":[0,34]}]},{"content":"Writing code that is more complex than it needs to be incurs maintenance, debugging, and polishing costs.","pos":[2504,2609]},{"content":"Experienced programmers have an intuitive grasp of how to solve coding problems and write more efficient code.","pos":[2610,2720]},{"content":"However, they sometimes prematurely optimize their code.","pos":[2721,2777]},{"content":"For example, they use a hash table when a simple array would suffice, or use complicated caching that may leak memory instead of simply recomputing values.","pos":[2778,2933]},{"content":"Even if you’re an experience programmer, you should test for performance and analyze your code when you find issues.","pos":[2934,3050]},{"pos":[3059,3107],"content":"Fact 2: If you’re not measuring, you’re guessing","linkify":"Fact 2: If you’re not measuring, you’re guessing","nodes":[{"content":"Fact 2: If you’re not measuring, you’re guessing","pos":[0,48]}]},{"content":"Profiles and measurements don’t lie.","pos":[3111,3147]},{"content":"Profiles show you whether the CPU is fully loaded or whether you’re blocked on disk I/O.","pos":[3148,3236]},{"content":"Profiles tell you what kind and how much memory you’re allocating and whether your CPU is spending a lot of time in <bpt id=\"p1\">[</bpt>garbage collection<ept id=\"p1\">](../../../docs/standard/garbage-collection/index.md)</ept> (GC).","pos":[3237,3431],"source":" Profiles tell you what kind and how much memory you’re allocating and whether your CPU is spending a lot of time in [garbage collection](../../../docs/standard/garbage-collection/index.md) (GC)."},{"content":"You should set performance goals for key customer experiences or scenarios in your app and write tests to measure performance.","pos":[3437,3563]},{"content":"Investigate failing tests by applying the scientific method: use profiles to guide you, hypothesize what the issue might be, and test your hypothesis with an experiment or code change.","pos":[3564,3748]},{"content":"Establish baseline performance measurements over time with regular testing, so you can isolate changes that cause regressions in performance.","pos":[3749,3890]},{"content":"By approaching performance work in a rigorous way, you’ll avoid wasting time with code updates you don’t need.","pos":[3891,4001]},{"pos":[4010,4052],"content":"Fact 3: Good tools make all the difference","linkify":"Fact 3: Good tools make all the difference","nodes":[{"content":"Fact 3: Good tools make all the difference","pos":[0,42]}]},{"content":"Good tools let you drill quickly into the biggest performance issues (CPU, memory, or disk) and help you locate the code that causes those bottlenecks.","pos":[4056,4207]},{"content":"Microsoft ships a variety of performance tools such as <bpt id=\"p1\">[</bpt>Visual Studio Profiler<ept id=\"p1\">](/visualstudio/profiling/beginners-guide-to-performance-profiling)</ept> and <bpt id=\"p2\">[</bpt>PerfView<ept id=\"p2\">](https://www.microsoft.com/download/details.aspx?id=28567)</ept>.","pos":[4208,4427],"source":" Microsoft ships a variety of performance tools such as [Visual Studio Profiler](/visualstudio/profiling/beginners-guide-to-performance-profiling) and [PerfView](https://www.microsoft.com/download/details.aspx?id=28567)."},{"content":"PerfView is a free and amazingly powerful tool that helps you focus on deep issues such as disk I/O, GC events, and memory.","pos":[4433,4556]},{"content":"You can capture performance-related <bpt id=\"p1\">[</bpt>Event Tracing for Windows<ept id=\"p1\">](../../../docs/framework/wcf/samples/etw-tracing.md)</ept> (ETW) events and view easily per app, per process, per stack, and per thread information.","pos":[4557,4762],"source":" You can capture performance-related [Event Tracing for Windows](../../../docs/framework/wcf/samples/etw-tracing.md) (ETW) events and view easily per app, per process, per stack, and per thread information."},{"content":"PerfView shows you how much and what kind of memory your app allocates, and which functions or call stacks contribute how much to the memory allocations.","pos":[4763,4916]},{"content":"For details, see the rich help topics, demos, and videos included with the tool (such as the <bpt id=\"p1\">[</bpt>PerfView tutorials<ept id=\"p1\">](https://channel9.msdn.com/Series/PerfView-Tutorial)</ept> on Channel 9).","pos":[4917,5097],"source":" For details, see the rich help topics, demos, and videos included with the tool (such as the [PerfView tutorials](https://channel9.msdn.com/Series/PerfView-Tutorial) on Channel 9)."},{"pos":[5106,5140],"content":"Fact 4: It’s all about allocations","linkify":"Fact 4: It’s all about allocations","nodes":[{"content":"Fact 4: It’s all about allocations","pos":[0,34]}]},{"content":"You might think that building a responsive .NET Framework app is all about algorithms, such as using quick sort instead of bubble sort, but that's not the case.","pos":[5144,5304]},{"content":"The biggest factor in building a responsive app is allocating memory, especially when your app is very large or processes large amounts of data.","pos":[5305,5449]},{"content":"Almost all the work to build responsive IDE experiences with the new compiler APIs involved avoiding allocations and managing caching strategies.","pos":[5455,5600]},{"content":"PerfView traces show that the performance of the new C# and Visual Basic compilers is rarely CPU bound.","pos":[5601,5704]},{"content":"The compilers can be I/O bound when reading hundreds of thousands or millions of lines of code, reading metadata, or emitting generated code.","pos":[5705,5846]},{"content":"The UI thread delays are nearly all due to garbage collection.","pos":[5847,5909]},{"content":"The .NET Framework GC is highly tuned for performance and does much of its work concurrently while app code executes.","pos":[5910,6027]},{"content":"However, a single allocation can trigger an expensive <bpt id=\"p1\">[</bpt>gen2<ept id=\"p1\">](../../../docs/standard/garbage-collection/fundamentals.md)</ept> collection, stopping all threads.","pos":[6028,6181],"source":" However, a single allocation can trigger an expensive [gen2](../../../docs/standard/garbage-collection/fundamentals.md) collection, stopping all threads."},{"pos":[6189,6220],"content":"Common allocations and examples","linkify":"Common allocations and examples","nodes":[{"content":"Common allocations and examples","pos":[0,31]}]},{"content":"The example expressions in this section have hidden allocations that appear small.","pos":[6224,6306]},{"content":"However, if a large app executes the expressions enough times, they can causes hundreds of megabytes, even gigabytes, of allocations.","pos":[6307,6440]},{"content":"For example, one-minute tests that simulated a developer’s typing in the editor allocated gigabytes of memory and led the performance team to focus on typing scenarios.","pos":[6441,6609]},{"pos":[6618,6624],"content":"Boxing","linkify":"Boxing","nodes":[{"content":"Boxing","pos":[0,6]}]},{"content":"<bpt id=\"p1\">[</bpt>Boxing<ept id=\"p1\">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept> occurs when value types that normally live on the stack or in data structures are wrapped in an object.","pos":[6628,6802],"source":"[Boxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md) occurs when value types that normally live on the stack or in data structures are wrapped in an object."},{"content":"That is, you allocate an object to hold the data, and then return a pointer to the object.","pos":[6803,6893]},{"content":"The .NET Framework sometimes boxes values due to the signature of a method or the type of a storage location.","pos":[6894,7003]},{"content":"Wrapping a value type in an object causes memory allocation.","pos":[7004,7064]},{"content":"Many boxing operations can contribute megabytes or gigabytes of allocations to your app, which means that your app will cause more GCs.","pos":[7065,7200]},{"content":"The .NET Framework and the language compilers avoid boxing when possible, but sometimes it happens when you least expect it.","pos":[7201,7325]},{"content":"To see boxing in PerfView, open a trace and look at GC Heap Alloc Stacks under your app’s process name (remember, PerfView reports on all processes).","pos":[7331,7480]},{"content":"If you see types like <ph id=\"ph1\">&lt;xref:System.Int32?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> under allocations, you are boxing value types.","pos":[7481,7650],"source":" If you see types like <xref:System.Int32?displayProperty=nameWithType> and <xref:System.Char?displayProperty=nameWithType> under allocations, you are boxing value types."},{"content":"Choosing one of these types will show the stacks and functions in which they are boxed.","pos":[7651,7738]},{"pos":[7744,7798],"content":"<bpt id=\"p1\">**</bpt>Example 1: string methods and value type arguments<ept id=\"p1\">**</ept>","source":"**Example 1: string methods and value type arguments**"},{"content":"This sample code illustrates potentially unnecessary and excessive boxing:","pos":[7805,7879]},{"content":"This code provides logging functionality, so an app may call the <ph id=\"ph1\">`Log`</ph> function frequently, maybe millions of times.","pos":[8175,8291],"source":"This code provides logging functionality, so an app may call the `Log` function frequently, maybe millions of times."},{"content":"The problem is that the call to <ph id=\"ph1\">`string.Format`</ph> resolves to the <ph id=\"ph2\">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> overload.","pos":[8292,8444],"source":" The problem is that the call to `string.Format` resolves to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> overload."},{"content":"This overload requires the .NET Framework to box the <ph id=\"ph1\">`int`</ph> values into objects to pass them to this method call.","pos":[8450,8562],"source":"This overload requires the .NET Framework to box the `int` values into objects to pass them to this method call."},{"content":"A partial fix is to call <ph id=\"ph1\">`id.ToString()`</ph> and <ph id=\"ph2\">`size.ToString()`</ph> and pass all strings (which are objects) to the <ph id=\"ph3\">`string.Format`</ph> call.","pos":[8563,8695],"source":" A partial fix is to call `id.ToString()` and `size.ToString()` and pass all strings (which are objects) to the `string.Format` call."},{"content":"Calling <ph id=\"ph1\">`ToString()`</ph> does allocate a string, but that allocation will happen anyway inside <ph id=\"ph2\">`string.Format`</ph>.","pos":[8696,8803],"source":" Calling `ToString()` does allocate a string, but that allocation will happen anyway inside `string.Format`."},{"pos":[8809,8935],"content":"You might consider that this basic call to <ph id=\"ph1\">`string.Format`</ph> is just string concatenation, so you might write this code instead:","source":"You might consider that this basic call to `string.Format` is just string concatenation, so you might write this code instead:"},{"content":"However, that line of code introduces a boxing allocation because it compiles to <ph id=\"ph1\">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph>.","pos":[9012,9172],"source":"However, that line of code introduces a boxing allocation because it compiles to <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%29>."},{"content":"The .NET Framework must box the character literal to invoke <ph id=\"ph1\">`Concat`</ph>","pos":[9173,9241],"source":" The .NET Framework must box the character literal to invoke `Concat`"},{"pos":[9248,9269],"content":"<bpt id=\"p1\">**</bpt>Fix for example 1<ept id=\"p1\">**</ept>","source":"**Fix for example 1**"},{"content":"The complete fix is simple.","pos":[9276,9303]},{"content":"Just replace the character literal with a string literal, which incurs no boxing because strings are already objects:","pos":[9304,9421]},{"pos":[9498,9524],"content":"<bpt id=\"p1\">**</bpt>Example 2: enum boxing<ept id=\"p1\">**</ept>","source":"**Example 2: enum boxing**"},{"content":"This example was responsible for a huge amount of allocation in the new C# and Visual Basic compilers due to frequent use of enumeration types, especially in dictionary lookup operations.","pos":[9531,9718]},{"content":"This problem is very subtle.","pos":[10005,10033]},{"content":"PerfView would report this as <ph id=\"ph1\">&lt;xref:System.Enum.GetHashCode&gt;</ph> boxing because the method boxes the underlying representation of the enumeration type, for implementation reasons.","pos":[10034,10209],"source":" PerfView would report this as <xref:System.Enum.GetHashCode> boxing because the method boxes the underlying representation of the enumeration type, for implementation reasons."},{"content":"If you look closely in PerfView, you may see two boxing allocations for each call to <ph id=\"ph1\">&lt;xref:System.Enum.GetHashCode&gt;</ph>.","pos":[10210,10326],"source":" If you look closely in PerfView, you may see two boxing allocations for each call to <xref:System.Enum.GetHashCode>."},{"content":"The compiler inserts one, and the .NET Framework inserts the other.","pos":[10327,10394]},{"pos":[10400,10421],"content":"<bpt id=\"p1\">**</bpt>Fix for example 2<ept id=\"p1\">**</ept>","source":"**Fix for example 2**"},{"pos":[10428,10556],"content":"You can easily avoid both allocations by casting to the underlying representation before calling <ph id=\"ph1\">&lt;xref:System.Enum.GetHashCode&gt;</ph>:","source":"You can easily avoid both allocations by casting to the underlying representation before calling <xref:System.Enum.GetHashCode>:"},{"content":"Another common source of boxing on enumeration types is the <ph id=\"ph1\">&lt;xref:System.Enum.HasFlag%28System.Enum%29?displayProperty=nameWithType&gt;</ph> method.","pos":[10613,10753],"source":"Another common source of boxing on enumeration types is the <xref:System.Enum.HasFlag%28System.Enum%29?displayProperty=nameWithType> method."},{"content":"The argument passed to <ph id=\"ph1\">&lt;xref:System.Enum.HasFlag%28System.Enum%29&gt;</ph> has to be boxed.","pos":[10754,10837],"source":" The argument passed to <xref:System.Enum.HasFlag%28System.Enum%29> has to be boxed."},{"content":"In most cases, replacing calls to <ph id=\"ph1\">&lt;xref:System.Enum.HasFlag%28System.Enum%29?displayProperty=nameWithType&gt;</ph> with a bitwise test is simpler and allocation-free.","pos":[10838,10996],"source":" In most cases, replacing calls to <xref:System.Enum.HasFlag%28System.Enum%29?displayProperty=nameWithType> with a bitwise test is simpler and allocation-free."},{"content":"Keep the first performance fact in mind (that is, don’t prematurely optimize) and don’t start rewriting all your code in this way.","pos":[11002,11132]},{"content":"Be aware of these boxing costs, but change your code only after profiling your app and finding the hot spots.","pos":[11133,11242]},{"pos":[11251,11258],"content":"Strings","linkify":"Strings","nodes":[{"content":"Strings","pos":[0,7]}]},{"content":"String manipulations are some of the biggest culprits for allocations, and they often show up in PerfView in the top five allocations.","pos":[11262,11396]},{"content":"Programs use strings for serialization, JSON, and REST APIs.","pos":[11397,11457]},{"content":"You can use strings as programmatic constants for interoperating with systems when you can’t use enumeration types.","pos":[11458,11573]},{"content":"When your profiling shows that strings are highly affecting performance, look for calls to <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> methods such as <ph id=\"ph2\">&lt;xref:System.String.Format%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.String.Concat%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.String.Split%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.String.Join%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.String.Substring%2A&gt;</ph>, and so on.","pos":[11574,11872],"source":" When your profiling shows that strings are highly affecting performance, look for calls to <xref:System.String> methods such as <xref:System.String.Format%2A>, <xref:System.String.Concat%2A>, <xref:System.String.Split%2A>, <xref:System.String.Join%2A>, <xref:System.String.Substring%2A>, and so on."},{"content":"Using <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> to avoid the cost of creating one string from many pieces helps, but even allocating the <ph id=\"ph2\">&lt;xref:System.Text.StringBuilder&gt;</ph> object might become a bottleneck that you need to manage.","pos":[11873,12091],"source":" Using <xref:System.Text.StringBuilder> to avoid the cost of creating one string from many pieces helps, but even allocating the <xref:System.Text.StringBuilder> object might become a bottleneck that you need to manage."},{"pos":[12097,12129],"content":"<bpt id=\"p1\">**</bpt>Example 3: string operations<ept id=\"p1\">**</ept>","source":"**Example 3: string operations**"},{"content":"The C# compiler had this code that writes the text of a formatted XML doc comment:","pos":[12136,12218]},{"content":"You can see that this code does a lot of string manipulation.","pos":[13037,13098]},{"content":"The code uses library methods to split lines into separate strings, to trim white space, to check whether the argument <ph id=\"ph1\">`text`</ph> is an XML documentation comment, and to extract substrings from lines.","pos":[13099,13295],"source":" The code uses library methods to split lines into separate strings, to trim white space, to check whether the argument `text` is an XML documentation comment, and to extract substrings from lines."},{"content":"On the first line inside <ph id=\"ph1\">`WriteFormattedDocComment`</ph>, the <ph id=\"ph2\">`text.Split`</ph> call allocates a new three-element array as the argument every time it’s called.","pos":[13301,13451],"source":"On the first line inside `WriteFormattedDocComment`, the `text.Split` call allocates a new three-element array as the argument every time it’s called."},{"content":"The compiler has to emit code to allocate this array each time.","pos":[13452,13515]},{"content":"That’s because the compiler doesn’t know if <ph id=\"ph1\">&lt;xref:System.String.Split%2A&gt;</ph> stores the array somewhere where the array might be modified by other code, which would affect later calls to <ph id=\"ph2\">`WriteFormattedDocComment`</ph>.","pos":[13516,13727],"source":" That’s because the compiler doesn’t know if <xref:System.String.Split%2A> stores the array somewhere where the array might be modified by other code, which would affect later calls to `WriteFormattedDocComment`."},{"content":"The call to <ph id=\"ph1\">&lt;xref:System.String.Split%2A&gt;</ph> also allocates a string for every line in <ph id=\"ph2\">`text`</ph> and allocates other memory to perform the operation.","pos":[13728,13871],"source":" The call to <xref:System.String.Split%2A> also allocates a string for every line in `text` and allocates other memory to perform the operation."},{"content":"<ph id=\"ph1\">`WriteFormattedDocComment`</ph> has three calls to the <ph id=\"ph2\">&lt;xref:System.String.TrimStart%2A&gt;</ph> method.","pos":[13877,13968],"source":"`WriteFormattedDocComment` has three calls to the <xref:System.String.TrimStart%2A> method."},{"content":"Two are in inner loops that duplicate work and allocations.","pos":[13969,14028]},{"content":"To make matters worse, calling the <ph id=\"ph1\">&lt;xref:System.String.TrimStart%2A&gt;</ph> method with no arguments allocates an empty array (for the <ph id=\"ph2\">`params`</ph> parameter) in addition to the string result.","pos":[14029,14210],"source":" To make matters worse, calling the <xref:System.String.TrimStart%2A> method with no arguments allocates an empty array (for the `params` parameter) in addition to the string result."},{"pos":[14216,14326],"content":"Lastly, there is a call to the <ph id=\"ph1\">&lt;xref:System.String.Substring%2A&gt;</ph> method, which usually allocates a new string.","source":"Lastly, there is a call to the <xref:System.String.Substring%2A> method, which usually allocates a new string."},{"pos":[14332,14353],"content":"<bpt id=\"p1\">**</bpt>Fix for example 3<ept id=\"p1\">**</ept>","source":"**Fix for example 3**"},{"content":"Unlike the earlier examples, small edits cannot fix these allocations.","pos":[14360,14430]},{"content":"You need to step back, look at the problem, and approach it differently.","pos":[14431,14503]},{"content":"For example, you'll notice that the argument to <ph id=\"ph1\">`WriteFormattedDocComment()`</ph> is a string that has all the information that the method needs, so the code could do more indexing instead of allocating many partial strings.","pos":[14504,14723],"source":" For example, you'll notice that the argument to `WriteFormattedDocComment()` is a string that has all the information that the method needs, so the code could do more indexing instead of allocating many partial strings."},{"content":"The compiler’s performance team tackled all these allocations with code like this:","pos":[14729,14811]},{"content":"The first version of <ph id=\"ph1\">`WriteFormattedDocComment()`</ph> allocated an array, several substrings, and a trimmed substring along with an empty <ph id=\"ph2\">`params`</ph> array.","pos":[15380,15529],"source":"The first version of `WriteFormattedDocComment()` allocated an array, several substrings, and a trimmed substring along with an empty `params` array."},{"content":"It also checked for \"///\".","pos":[15530,15556]},{"content":"The revised code uses only indexing and allocates nothing.","pos":[15557,15615]},{"content":"It finds the first character that is not white space, and then checks character by character to see if the string starts with \"///\".","pos":[15616,15748]},{"content":"The new code uses <ph id=\"ph1\">`IndexOfFirstNonWhiteSpaceChar`</ph> instead of <ph id=\"ph2\">&lt;xref:System.String.TrimStart%2A&gt;</ph> to return the first index (after a specified start index) where a non-white-space character occurs.","pos":[15749,15943],"source":" The new code uses `IndexOfFirstNonWhiteSpaceChar` instead of <xref:System.String.TrimStart%2A> to return the first index (after a specified start index) where a non-white-space character occurs."},{"content":"The fix is not complete, but you can see how to apply similar fixes for a complete solution.","pos":[15944,16036]},{"content":"By applying this approach throughout the code, you can remove all allocations in <ph id=\"ph1\">`WriteFormattedDocComment()`</ph>.","pos":[16037,16147],"source":" By applying this approach throughout the code, you can remove all allocations in `WriteFormattedDocComment()`."},{"pos":[16153,16181],"content":"<bpt id=\"p1\">**</bpt>Example 4: StringBuilder<ept id=\"p1\">**</ept>","source":"**Example 4: StringBuilder**"},{"content":"This example uses a <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> object.","pos":[16188,16248],"source":"This example uses a <xref:System.Text.StringBuilder> object."},{"content":"The following function generates a full type name for generic types:","pos":[16249,16317]},{"content":"The focus is on the line that creates a new <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> instance.","pos":[16932,17018],"source":"The focus is on the line that creates a new <xref:System.Text.StringBuilder> instance."},{"content":"The code causes an allocation for <ph id=\"ph1\">`sb.ToString()`</ph> and internal allocations within the <ph id=\"ph2\">&lt;xref:System.Text.StringBuilder&gt;</ph> implementation, but you cannot control those allocations if you want the string result.","pos":[17019,17225],"source":" The code causes an allocation for `sb.ToString()` and internal allocations within the <xref:System.Text.StringBuilder> implementation, but you cannot control those allocations if you want the string result."},{"pos":[17231,17252],"content":"<bpt id=\"p1\">**</bpt>Fix for example 4<ept id=\"p1\">**</ept>","source":"**Fix for example 4**"},{"content":"To fix the <ph id=\"ph1\">`StringBuilder`</ph> object allocation, cache the  object.","pos":[17259,17323],"source":"To fix the `StringBuilder` object allocation, cache the  object."},{"content":"Even caching a single instance that might get thrown away can improve performance significantly.","pos":[17324,17420]},{"content":"This is the function’s new implementation, omitting all the code except for the new first and last lines:","pos":[17421,17526]},{"pos":[17789,17879],"content":"The key parts are the new <ph id=\"ph1\">`AcquireBuilder()`</ph> and <ph id=\"ph2\">`GetStringAndReleaseBuilder()`</ph> functions:","source":"The key parts are the new `AcquireBuilder()` and `GetStringAndReleaseBuilder()` functions:"},{"content":"Because the new compilers use threading, these implementations use a thread-static field (<ph id=\"ph1\">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) to cache the <ph id=\"ph2\">&lt;xref:System.Text.StringBuilder&gt;</ph>, and you likely can forgo the <ph id=\"ph3\">`ThreadStatic`</ph> declaration.","pos":[18412,18652],"source":"Because the new compilers use threading, these implementations use a thread-static field (<xref:System.ThreadStaticAttribute> attribute) to cache the <xref:System.Text.StringBuilder>, and you likely can forgo the `ThreadStatic` declaration."},{"content":"The thread-static field holds a unique value for each thread that executes this code.","pos":[18653,18738]},{"content":"<ph id=\"ph1\">`AcquireBuilder()`</ph> returns the cached <ph id=\"ph2\">&lt;xref:System.Text.StringBuilder&gt;</ph> instance if there is one, after clearing it and setting the field or cache to null.","pos":[18744,18898],"source":"`AcquireBuilder()` returns the cached <xref:System.Text.StringBuilder> instance if there is one, after clearing it and setting the field or cache to null."},{"content":"Otherwise, <ph id=\"ph1\">`AcquireBuilder()`</ph> creates a new instance and returns it, leaving the field or cache set to null.","pos":[18899,19007],"source":" Otherwise, `AcquireBuilder()` creates a new instance and returns it, leaving the field or cache set to null."},{"content":"When you’re done with <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> , you call <ph id=\"ph2\">`GetStringAndReleaseBuilder()`</ph> to get the string result, save the <ph id=\"ph3\">&lt;xref:System.Text.StringBuilder&gt;</ph> instance in the field or cache, and then return the result.","pos":[19013,19237],"source":"When you’re done with <xref:System.Text.StringBuilder> , you call `GetStringAndReleaseBuilder()` to get the string result, save the <xref:System.Text.StringBuilder> instance in the field or cache, and then return the result."},{"content":"It is possible for execution to re-enter this code and to create multiple <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> objects (although that rarely happens).","pos":[19238,19384],"source":" It is possible for execution to re-enter this code and to create multiple <xref:System.Text.StringBuilder> objects (although that rarely happens)."},{"content":"The code saves only the last released <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> instance for later use.","pos":[19385,19479],"source":" The code saves only the last released <xref:System.Text.StringBuilder> instance for later use."},{"content":"This simple caching strategy significantly reduced allocations in the new compilers.","pos":[19480,19564]},{"content":"Parts of the .NET Framework and MSBuild (\"MSBuild\") use a similar technique to improve performance.","pos":[19565,19664]},{"content":"This simple caching strategy adheres to good cache design because it has a size cap.","pos":[19670,19754]},{"content":"However, there is more code now than in the original, which means more maintenance costs.","pos":[19755,19844]},{"content":"You should adopt the caching strategy only if you’ve found a performance problem, and PerfView has shown that <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> allocations are a significant contributor.","pos":[19845,20030],"source":" You should adopt the caching strategy only if you’ve found a performance problem, and PerfView has shown that <xref:System.Text.StringBuilder> allocations are a significant contributor."},{"pos":[20039,20055],"content":"LINQ and lambdas","linkify":"LINQ and lambdas","nodes":[{"content":"LINQ and lambdas","pos":[0,16]}]},{"content":"Language-Integrated Query (LINQ), in conjunction with lambda expressions, is an example of a productivity feature.","pos":[20058,20172]},{"content":"However, its use may have a significant impact on performance over time, and you might find you need to rewrite your code.","pos":[20173,20295]},{"pos":[20300,20353],"content":"<bpt id=\"p1\">**</bpt>Example 5: Lambdas, List<ph id=\"ph1\">\\&lt;</ph>T&gt;, and IEnumerable<ph id=\"ph2\">\\&lt;</ph>T&gt;<ept id=\"p1\">**</ept>","source":"**Example 5: Lambdas, List\\<T>, and IEnumerable\\<T>**"},{"pos":[20360,20583],"content":"This example uses <bpt id=\"p1\">[</bpt>LINQ and functional style code<ept id=\"p1\">](https://blogs.msdn.com/b/charlie/archive/2007/01/26/anders-hejlsberg-on-linq-and-functional-programming.aspx)</ept> to find a symbol in the compiler’s model, given a name string:","source":"This example uses [LINQ and functional style code](https://blogs.msdn.com/b/charlie/archive/2007/01/26/anders-hejlsberg-on-linq-and-functional-programming.aspx) to find a symbol in the compiler’s model, given a name string:"},{"content":"The new compiler and the IDE experiences built on it call <ph id=\"ph1\">`FindMatchingSymbol()`</ph> very frequently, and there are several hidden allocations in this function’s single line of code.","pos":[20885,21063],"source":"The new compiler and the IDE experiences built on it call `FindMatchingSymbol()` very frequently, and there are several hidden allocations in this function’s single line of code."},{"content":"To examine those allocations, first split the function’s single line of code into two lines:","pos":[21064,21156]},{"content":"In the first line, the <bpt id=\"p1\">[</bpt>lambda expression<ept id=\"p1\">](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)</ept> <ph id=\"ph1\">`s =&gt; s.Name == name`</ph> <bpt id=\"p2\">[</bpt>closes over<ept id=\"p2\">](https://blogs.msdn.com/b/ericlippert/archive/2003/09/17/53028.aspx)</ept> the local variable <ph id=\"ph2\">`name`</ph>.","pos":[21287,21548],"source":"In the first line, the [lambda expression](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) `s => s.Name == name` [closes over](https://blogs.msdn.com/b/ericlippert/archive/2003/09/17/53028.aspx) the local variable `name`."},{"content":"This means that in addition to allocating an object for the <bpt id=\"p1\">[</bpt>delegate<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/delegate.md)</ept> that <ph id=\"ph1\">`predicate`</ph> holds, the code allocates a static class to hold the environment that captures the value of <ph id=\"ph2\">`name`</ph>.","pos":[21549,21791],"source":" This means that in addition to allocating an object for the [delegate](~/docs/csharp/language-reference/keywords/delegate.md) that `predicate` holds, the code allocates a static class to hold the environment that captures the value of `name`."},{"content":"The compiler generates code like the following:","pos":[21792,21839]},{"pos":[22308,22408],"content":"The two <ph id=\"ph1\">`new`</ph> allocations (one for the environment class and one for the delegate) are explicit now.","source":"The two `new` allocations (one for the environment class and one for the delegate) are explicit now."},{"content":"Now look at the call to <ph id=\"ph1\">`FirstOrDefault`</ph>.","pos":[22414,22455],"source":"Now look at the call to `FirstOrDefault`."},{"content":"This extension method on the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph> type incurs an allocation too.","pos":[22456,22594],"source":" This extension method on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> type incurs an allocation too."},{"content":"Because <ph id=\"ph1\">`FirstOrDefault`</ph> takes an <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> object as its first argument, you can expand the call to the following code (simplified a bit for discussion):","pos":[22595,22789],"source":" Because `FirstOrDefault` takes an <xref:System.Collections.Generic.IEnumerable%601> object as its first argument, you can expand the call to the following code (simplified a bit for discussion):"},{"content":"The <ph id=\"ph1\">`symbols`</ph> variable has type <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.","pos":[23165,23240],"source":"The `symbols` variable has type <xref:System.Collections.Generic.List%601>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> collection type implements <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> and cleverly defines an enumerator (<ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph> interface) that <ph id=\"ph4\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements with a <ph id=\"ph5\">`struct`</ph>.","pos":[23241,23537],"source":" The <xref:System.Collections.Generic.List%601> collection type implements <xref:System.Collections.Generic.IEnumerable%601> and cleverly defines an enumerator (<xref:System.Collections.Generic.IEnumerator%601> interface) that <xref:System.Collections.Generic.List%601> implements with a `struct`."},{"content":"Using a structure instead of a class means that you usually avoid any heap allocations, which, in turn, can affect garbage collection performance.","pos":[23538,23684]},{"content":"Enumerators are typically used with the language’s <ph id=\"ph1\">`foreach`</ph> loop, which uses the enumerator structure as it is returned on the call stack.","pos":[23685,23824],"source":" Enumerators are typically used with the language’s `foreach` loop, which uses the enumerator structure as it is returned on the call stack."},{"content":"Incrementing the call stack pointer to make room for an object does not affect GC the way a heap allocation does.","pos":[23825,23938]},{"content":"In the case of the expanded <ph id=\"ph1\">`FirstOrDefault`</ph> call, the code needs to call <ph id=\"ph2\">`GetEnumerator()`</ph> on an <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[23944,24092],"source":"In the case of the expanded `FirstOrDefault` call, the code needs to call `GetEnumerator()` on an <xref:System.Collections.Generic.IEnumerable%601>."},{"content":"Assigning <ph id=\"ph1\">`symbols`</ph> to the <ph id=\"ph2\">`enumerable`</ph> variable of type <ph id=\"ph3\">`IEnumerable&lt;Symbol&gt;`</ph> loses the information that the actual object is a <ph id=\"ph4\">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.","pos":[24093,24265],"source":" Assigning `symbols` to the `enumerable` variable of type `IEnumerable<Symbol>` loses the information that the actual object is a <xref:System.Collections.Generic.List%601>."},{"content":"This means that when the code fetches the enumerator with <ph id=\"ph1\">`enumerable.GetEnumerator()`</ph>, the .NET Framework has to box the returned structure to assign it to the <ph id=\"ph2\">`enumerator`</ph> variable.","pos":[24266,24449],"source":" This means that when the code fetches the enumerator with `enumerable.GetEnumerator()`, the .NET Framework has to box the returned structure to assign it to the `enumerator` variable."},{"pos":[24455,24476],"content":"<bpt id=\"p1\">**</bpt>Fix for example 5<ept id=\"p1\">**</ept>","source":"**Fix for example 5**"},{"pos":[24483,24669],"content":"The fix is to rewrite <ph id=\"ph1\">`FindMatchingSymbol`</ph> as follows, replacing its single line of code with six lines of code that are still concise, easy to read and understand, and easy to maintain:","source":"The fix is to rewrite `FindMatchingSymbol` as follows, replacing its single line of code with six lines of code that are still concise, easy to read and understand, and easy to maintain:"},{"content":"This code doesn’t use LINQ extension methods, lambdas, or enumerators, and it incurs no allocations.","pos":[24910,25010]},{"content":"There are no allocations because the compiler can see that the <ph id=\"ph1\">`symbols`</ph> collection is a <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> and can bind the resulting enumerator (a structure) to a local variable with the right type to avoid boxing.","pos":[25011,25251],"source":" There are no allocations because the compiler can see that the `symbols` collection is a <xref:System.Collections.Generic.List%601> and can bind the resulting enumerator (a structure) to a local variable with the right type to avoid boxing."},{"content":"The original version of this function was a great example of the expressive power of C# and the productivity of the .NET Framework.","pos":[25252,25383]},{"content":"This new and more efficient version preserves those qualities without adding any complex code to maintain.","pos":[25384,25490]},{"pos":[25499,25519],"content":"Async method caching","linkify":"Async method caching","nodes":[{"content":"Async method caching","pos":[0,20]}]},{"pos":[25523,25675],"content":"The next example shows a common problem when you try to use cached results in an <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](../../csharp/programming-guide/concepts/async/index.md)</ept> method.","source":"The next example shows a common problem when you try to use cached results in an [async](../../csharp/programming-guide/concepts/async/index.md) method."},{"pos":[25680,25719],"content":"<bpt id=\"p1\">**</bpt>Example 6: caching in async methods<ept id=\"p1\">**</ept>","source":"**Example 6: caching in async methods**"},{"content":"The Visual Studio IDE features built on the new C# and Visual Basic compilers frequently fetch syntax trees, and the compilers use async when doing so to keep Visual Studio responsive.","pos":[25726,25910]},{"content":"Here’s the first version of the code you might write to get a syntax tree:","pos":[25911,25985]},{"content":"You can see that calling <ph id=\"ph1\">`GetSyntaxTreeAsync()`</ph> instantiates a <ph id=\"ph2\">`Parser`</ph>, parses the code, and then returns a <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object, <ph id=\"ph4\">`Task&lt;SyntaxTree&gt;`</ph>.","pos":[26412,26583],"source":"You can see that calling `GetSyntaxTreeAsync()` instantiates a `Parser`, parses the code, and then returns a <xref:System.Threading.Tasks.Task> object, `Task<SyntaxTree>`."},{"content":"The expensive part is allocating the <ph id=\"ph1\">`Parser`</ph> instance and parsing the code.","pos":[26584,26660],"source":" The expensive part is allocating the `Parser` instance and parsing the code."},{"content":"The function returns a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> so that callers can await the parsing work and free the UI thread to be responsive to user input.","pos":[26661,26816],"source":" The function returns a <xref:System.Threading.Tasks.Task> so that callers can await the parsing work and free the UI thread to be responsive to user input."},{"content":"Several Visual Studio features might try to get the same syntax tree, so you might write the following code to cache the parsing result to save time and allocations.","pos":[26822,26987]},{"content":"However, this code incurs an allocation:","pos":[26988,27028]},{"content":"You see that the new code with caching has a <ph id=\"ph1\">`SyntaxTree`</ph> field named <ph id=\"ph2\">`cachedResult`</ph>.","pos":[27472,27557],"source":"You see that the new code with caching has a `SyntaxTree` field named `cachedResult`."},{"content":"When this field is null, <ph id=\"ph1\">`GetSyntaxTreeAsync()`</ph> does the work and saves the result in the cache.","pos":[27558,27654],"source":" When this field is null, `GetSyntaxTreeAsync()` does the work and saves the result in the cache."},{"content":"<ph id=\"ph1\">`GetSyntaxTreeAsync()`</ph> returns the <ph id=\"ph2\">`SyntaxTree`</ph> object.","pos":[27655,27710],"source":"`GetSyntaxTreeAsync()` returns the `SyntaxTree` object."},{"content":"The problem is that when you have an <ph id=\"ph1\">`async`</ph> function of type <ph id=\"ph2\">`Task&lt;SyntaxTree&gt;`</ph>, and you return a value of type <ph id=\"ph3\">`SyntaxTree`</ph>, the compiler emits code to allocate a Task to hold the result (by using <ph id=\"ph4\">`Task&lt;SyntaxTree&gt;.FromResult()`</ph>).","pos":[27711,27943],"source":" The problem is that when you have an `async` function of type `Task<SyntaxTree>`, and you return a value of type `SyntaxTree`, the compiler emits code to allocate a Task to hold the result (by using `Task<SyntaxTree>.FromResult()`)."},{"content":"The Task is marked as completed, and the result is immediately available.","pos":[27944,28017]},{"content":"In the code for the new compilers, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects that were already completed occurred so often that fixing these allocations improved responsiveness noticeably.","pos":[28018,28207],"source":" In the code for the new compilers, <xref:System.Threading.Tasks.Task> objects that were already completed occurred so often that fixing these allocations improved responsiveness noticeably."},{"pos":[28213,28234],"content":"<bpt id=\"p1\">**</bpt>Fix for example 6<ept id=\"p1\">**</ept>","source":"**Fix for example 6**"},{"pos":[28241,28368],"content":"To remove the completed <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> allocation, you can cache the Task object with the completed result:","source":"To remove the completed <xref:System.Threading.Tasks.Task> allocation, you can cache the Task object with the completed result:"},{"content":"This code changes the type of <ph id=\"ph1\">`cachedResult`</ph> to <ph id=\"ph2\">`Task&lt;SyntaxTree&gt;`</ph> and employs an <ph id=\"ph3\">`async`</ph> helper function that holds the original code from <ph id=\"ph4\">`GetSyntaxTreeAsync()`</ph>.","pos":[28879,29042],"source":"This code changes the type of `cachedResult` to `Task<SyntaxTree>` and employs an `async` helper function that holds the original code from `GetSyntaxTreeAsync()`."},{"content":"<ph id=\"ph1\">`GetSyntaxTreeAsync()`</ph> now uses the <bpt id=\"p1\">[</bpt>null coalescing operator<ept id=\"p1\">](../../csharp/language-reference/operators/null-coalescing-operator.md)</ept> to return <ph id=\"ph2\">`cachedResult`</ph> if it isn't null.","pos":[29043,29219],"source":"`GetSyntaxTreeAsync()` now uses the [null coalescing operator](../../csharp/language-reference/operators/null-coalescing-operator.md) to return `cachedResult` if it isn't null."},{"content":"If <ph id=\"ph1\">`cachedResult`</ph> is null, then <ph id=\"ph2\">`GetSyntaxTreeAsync()`</ph> calls <ph id=\"ph3\">`GetSyntaxTreeUncachedAsync()`</ph> and caches the result.","pos":[29220,29334],"source":" If `cachedResult` is null, then `GetSyntaxTreeAsync()` calls `GetSyntaxTreeUncachedAsync()` and caches the result."},{"content":"Notice that <ph id=\"ph1\">`GetSyntaxTreeAsync()`</ph> doesn’t await the call to <ph id=\"ph2\">`GetSyntaxTreeUncachedAsync()`</ph> as the code would normally.","pos":[29335,29454],"source":" Notice that `GetSyntaxTreeAsync()` doesn’t await the call to `GetSyntaxTreeUncachedAsync()` as the code would normally."},{"content":"Not using await means that when <ph id=\"ph1\">`GetSyntaxTreeUncachedAsync()`</ph> returns its <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object, <ph id=\"ph3\">`GetSyntaxTreeAsync()`</ph> immediately returns the <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>.","pos":[29455,29655],"source":" Not using await means that when `GetSyntaxTreeUncachedAsync()` returns its <xref:System.Threading.Tasks.Task> object, `GetSyntaxTreeAsync()` immediately returns the <xref:System.Threading.Tasks.Task>."},{"content":"Now, the cached result is a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, so there are no allocations to return the cached result.","pos":[29656,29776],"source":" Now, the cached result is a <xref:System.Threading.Tasks.Task>, so there are no allocations to return the cached result."},{"pos":[29785,29810],"content":"Additional considerations","linkify":"Additional considerations","nodes":[{"content":"Additional considerations","pos":[0,25]}]},{"content":"Here are a few more points about potential problems in large apps or apps that process a lot of data.","pos":[29814,29915]},{"pos":[29921,29937],"content":"<bpt id=\"p1\">**</bpt>Dictionaries<ept id=\"p1\">**</ept>","source":"**Dictionaries**"},{"content":"Dictionaries are used ubiquitously in many programs, and though dictionaries are very convenient and inherently efficient.","pos":[29944,30066]},{"content":"However, they’re often used inappropriately.","pos":[30067,30111]},{"content":"In Visual Studio and the new compilers, analysis shows that many of the dictionaries contained a single element or were empty.","pos":[30112,30238]},{"content":"An empty <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has ten fields and occupies 48 bytes on the heap on an x86 machine.","pos":[30239,30364],"source":" An empty <xref:System.Collections.Generic.Dictionary%602> has ten fields and occupies 48 bytes on the heap on an x86 machine."},{"content":"Dictionaries are great when you need a mapping or associative data structure with constant-time lookup.","pos":[30365,30468]},{"content":"However, when you have only a few elements, you waste a lot of space by using a dictionary.","pos":[30469,30560]},{"content":"Instead, for example, you could iteratively look through a <ph id=\"ph1\">`List&lt;KeyValuePair\\&lt;K,V&gt;&gt;`</ph>, just as fast.","pos":[30561,30661],"source":" Instead, for example, you could iteratively look through a `List<KeyValuePair\\<K,V>>`, just as fast."},{"content":"If you use a dictionary only to load it with data and then read from it (a very common pattern), using a sorted array with an N(log(N)) lookup might be nearly as fast, depending on the number of elements you're using.","pos":[30662,30879]},{"pos":[30885,30911],"content":"<bpt id=\"p1\">**</bpt>Classes vs. structures<ept id=\"p1\">**</ept>","source":"**Classes vs. structures**"},{"content":"In a way, classes and structures provide a classic space/time tradeoff for tuning your apps.","pos":[30918,31010]},{"content":"Classes incur 12 bytes of overhead on an x86 machine even if they have no fields, but they are inexpensive to pass around because it only takes a pointer to refer to a class instance.","pos":[31011,31194]},{"content":"Structures incur no heap allocations if they aren’t boxed, but when you pass large structures as function arguments or return values, it takes CPU time to atomically copy all the data members of the structures.","pos":[31195,31405]},{"content":"Watch out for repeated calls to properties that return structures, and cache the property’s value in a local variable to avoid excessive data copying.","pos":[31406,31556]},{"pos":[31562,31572],"content":"<bpt id=\"p1\">**</bpt>Caches<ept id=\"p1\">**</ept>","source":"**Caches**"},{"content":"A common performance trick is to cache results.","pos":[31579,31626]},{"content":"However, a cache without a size cap or disposal policy can be a memory leak.","pos":[31627,31703]},{"content":"When processing large amounts of data, if you hold on to a lot of memory in caches, you can cause garbage collection to override the benefits of your cached lookups.","pos":[31704,31869]},{"content":"In this article, we discussed how you should be aware of performance bottleneck symptoms that can affect your app's responsiveness, especially for large systems or systems that process a large amount of data.","pos":[31875,32083]},{"content":"Common culprits include boxing, string manipulations, LINQ and lambda, caching in async methods, caching without a size limit or disposal policy, inappropriate use of dictionaries, and passing around structures.","pos":[32084,32295]},{"content":"Keep in mind the four facts for tuning your apps:","pos":[32296,32345]},{"content":"Don’t prematurely optimize – be productive and tune your app when you spot problems.","pos":[32355,32439]},{"content":"Profiles don’t lie – you’re guessing if you’re not measuring.","pos":[32448,32509]},{"content":"Good tools make all the difference – download PerfView and try it out.","pos":[32518,32588]},{"content":"It's all about allocations – that is where the compiler platform team spent most of their time improving the performance of the new compilers.","pos":[32597,32739]},{"pos":[32747,32755],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[32759,32864],"content":"<bpt id=\"p1\">[</bpt>Video of presentation of this topic<ept id=\"p1\">](https://channel9.msdn.com/Events/TechEd/NorthAmerica/2013/DEV-B333)</ept>","source":"[Video of presentation of this topic](https://channel9.msdn.com/Events/TechEd/NorthAmerica/2013/DEV-B333)"},{"pos":[32867,32975],"content":"<bpt id=\"p1\">[</bpt>Beginners Guide to Performance Profiling<ept id=\"p1\">](/visualstudio/profiling/beginners-guide-to-performance-profiling)</ept>","source":"[Beginners Guide to Performance Profiling](/visualstudio/profiling/beginners-guide-to-performance-profiling)"},{"pos":[32978,33037],"content":"<bpt id=\"p1\">[</bpt>Performance<ept id=\"p1\">](../../../docs/framework/performance/index.md)</ept>","source":"[Performance](../../../docs/framework/performance/index.md)"},{"pos":[33040,33147],"content":"<bpt id=\"p1\">[</bpt>.NET Performance Tips<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/articles/ms973839(v%3dmsdn.10))</ept>","source":"[.NET Performance Tips](https://docs.microsoft.com/previous-versions/dotnet/articles/ms973839(v%3dmsdn.10))"},{"pos":[33150,33232],"content":"<bpt id=\"p1\">[</bpt>Channel 9 PerfView tutorials<ept id=\"p1\">](https://channel9.msdn.com/Series/PerfView-Tutorial)</ept>","source":"[Channel 9 PerfView tutorials](https://channel9.msdn.com/Series/PerfView-Tutorial)"},{"pos":[33235,33301],"content":"<bpt id=\"p1\">[</bpt>The .NET Compiler Platform SDK<ept id=\"p1\">](../../csharp/roslyn-sdk/index.md)</ept>","source":"[The .NET Compiler Platform SDK](../../csharp/roslyn-sdk/index.md)"},{"pos":[33304,33368],"content":"<bpt id=\"p1\">[</bpt>dotnet/roslyn repo on GitHub<ept id=\"p1\">](https://github.com/dotnet/roslyn)</ept>","source":"[dotnet/roslyn repo on GitHub](https://github.com/dotnet/roslyn)"}]}