{"content":"---\ntitle: \"Understanding Speedup in PLINQ\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"PLINQ queries, performance tuning\"\nms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Understanding Speedup in PLINQ\nThe primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers. PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates. Such operations are common in LINQ to Objects and PLINQ, and are often called \"*delightfully parallel*\" because they lend themselves easily to scheduling on multiple threads. However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution. And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes. All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*. To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead. This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.  \n  \n## Factors that Impact PLINQ Query Performance  \n The following sections lists some of the most important factors that impact parallel query performance. These are general statements that by themselves are not sufficient to predict query performance in all cases. As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.  \n  \n1.  Computational cost of the overall work.  \n  \n     To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead. The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection. Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup. For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds. This yields a speedup of 750 milliseconds. If the function required one second to execute for each element, then the speedup would be 750 seconds. If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection. Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.  \n  \n     In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work. queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.  \n  \n    ```vb  \n    Dim queryA = From num In numberList.AsParallel()  \n                 Select ExpensiveFunction(num); 'good for PLINQ  \n  \n    Dim queryB = From num In numberList.AsParallel()  \n                 Where num Mod 2 > 0  \n                 Select num; 'not as good for PLINQ  \n    ```  \n  \n    ```csharp  \n    var queryA = from num in numberList.AsParallel()  \n                 select ExpensiveFunction(num); //good for PLINQ  \n  \n    var queryB = from num in numberList.AsParallel()  \n                 where num % 2 > 0  \n                 select num; //not as good for PLINQ  \n    ```  \n  \n2.  The number of logical cores on the system (degree of parallelism).  \n  \n     This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads. The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable. However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer. When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores. This point is related to point #1: larger datasets are required to take advantage of greater computing resources.  \n  \n3.  The number and kind of operations.  \n  \n     PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence. There is a cost associated with ordering, but this cost is usually modest. GroupBy and Join operations likewise incur overhead. PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready. For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).  \n  \n4.  The form of query execution.  \n  \n     If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure. This involves an unavoidable computational cost. Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread. But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.  \n  \n5.  The type of merge options.  \n  \n     PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced. The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.  While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results. For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).  \n  \n6.  The kind of partitioning.  \n  \n     In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load. When this occurs, you might be able to increase the query performance by creating a custom partitioner. For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  \n  \n## When PLINQ Chooses Sequential Mode  \n PLINQ will always attempt to execute a query at least as fast as the query would run sequentially. Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query \"shapes.\" Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode. When it finds such shapes, PLINQ by default falls back to sequential mode.  \n  \n However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode. In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query. For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).  \n  \n The following list describes the query shapes that PLINQ by default will execute in sequential mode:  \n  \n-   Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.  \n  \n-   Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.  \n  \n-   Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).  \n  \n-   Queries that contain Concat, unless it is applied to indexable data sources.  \n  \n-   Queries that contain Reverse, unless applied to an indexable data source.  \n  \n## See also\n\n- [Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)\n","nodes":[{"pos":[4,281],"embed":true,"restype":"x-metadata","content":"title: \"Understanding Speedup in PLINQ\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"PLINQ queries, performance tuning\"\nms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Understanding Speedup in PLINQ","nodes":[{"pos":[0,30],"content":"Understanding Speedup in PLINQ","nodes":[{"content":"Understanding Speedup in PLINQ","pos":[0,30]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[288,318],"content":"Understanding Speedup in PLINQ","linkify":"Understanding Speedup in PLINQ","nodes":[{"content":"Understanding Speedup in PLINQ","pos":[0,30]}]},{"content":"The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.","pos":[319,473]},{"content":"PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.","pos":[474,630]},{"content":"Such operations are common in LINQ to Objects and PLINQ, and are often called \"<bpt id=\"p1\">*</bpt>delightfully parallel<ept id=\"p1\">*</ept>\" because they lend themselves easily to scheduling on multiple threads.","pos":[631,805],"source":" Such operations are common in LINQ to Objects and PLINQ, and are often called \"*delightfully parallel*\" because they lend themselves easily to scheduling on multiple threads."},{"content":"However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.","pos":[806,1005]},{"content":"And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.","pos":[1006,1205]},{"content":"All these operations add to the computational cost of parallelization; these costs of adding parallelization are called <bpt id=\"p1\">*</bpt>overhead<ept id=\"p1\">*</ept>.","pos":[1206,1337],"source":" All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*."},{"content":"To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.","pos":[1338,1497]},{"content":"This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.","pos":[1498,1642]},{"pos":[1651,1694],"content":"Factors that Impact PLINQ Query Performance","linkify":"Factors that Impact PLINQ Query Performance","nodes":[{"content":"Factors that Impact PLINQ Query Performance","pos":[0,43]}]},{"content":"The following sections lists some of the most important factors that impact parallel query performance.","pos":[1698,1801]},{"content":"These are general statements that by themselves are not sufficient to predict query performance in all cases.","pos":[1802,1911]},{"content":"As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.","pos":[1912,2058]},{"content":"Computational cost of the overall work.","pos":[2068,2107]},{"content":"To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.","pos":[2118,2219]},{"content":"The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.","pos":[2220,2351]},{"content":"Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.","pos":[2352,2482]},{"content":"For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.","pos":[2483,2718]},{"content":"This yields a speedup of 750 milliseconds.","pos":[2719,2761]},{"content":"If the function required one second to execute for each element, then the speedup would be 750 seconds.","pos":[2762,2865]},{"content":"If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.","pos":[2866,2991]},{"content":"Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.","pos":[2992,3096]},{"content":"In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.","pos":[3107,3237]},{"content":"queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.","pos":[3238,3411]},{"content":"The number of logical cores on the system (degree of parallelism).","pos":[4019,4085]},{"content":"This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.","pos":[4096,4296]},{"content":"The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.","pos":[4297,4405]},{"content":"However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.","pos":[4406,4519]},{"content":"When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.","pos":[4520,4650]},{"content":"This point is related to point #1: larger datasets are required to take advantage of greater computing resources.","pos":[4651,4764]},{"content":"The number and kind of operations.","pos":[4774,4808]},{"content":"PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.","pos":[4819,4954]},{"content":"There is a cost associated with ordering, but this cost is usually modest.","pos":[4955,5029]},{"content":"GroupBy and Join operations likewise incur overhead.","pos":[5030,5082]},{"content":"PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.","pos":[5083,5242]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Order Preservation in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)</ept>.","pos":[5243,5375],"source":" For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)."},{"content":"The form of query execution.","pos":[5385,5413]},{"content":"If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.","pos":[5424,5585]},{"content":"This involves an unavoidable computational cost.","pos":[5586,5634]},{"content":"Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.","pos":[5635,5809]},{"content":"But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.","pos":[5810,5963]},{"content":"The type of merge options.","pos":[5973,5999]},{"content":"PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.","pos":[6010,6202]},{"content":"The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.","pos":[6203,6326]},{"content":"While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.","pos":[6328,6516]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Merge Options in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)</ept>.","pos":[6517,6639],"source":" For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)."},{"content":"The kind of partitioning.","pos":[6649,6674]},{"content":"In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.","pos":[6685,6788]},{"content":"When this occurs, you might be able to increase the query performance by creating a custom partitioner.","pos":[6789,6892]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Custom Partitioners for PLINQ and TPL<ept id=\"p1\">](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)</ept>.","pos":[6893,7045],"source":" For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)."},{"pos":[7054,7088],"content":"When PLINQ Chooses Sequential Mode","linkify":"When PLINQ Chooses Sequential Mode","nodes":[{"content":"When PLINQ Chooses Sequential Mode","pos":[0,34]}]},{"content":"PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.","pos":[7092,7190]},{"content":"Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query \"shapes.\"","pos":[7191,7349]},{"content":"Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.","pos":[7350,7491]},{"content":"When it finds such shapes, PLINQ by default falls back to sequential mode.","pos":[7492,7566]},{"content":"However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.","pos":[7573,7694]},{"content":"In such cases you can use the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType&gt;</ph> flag via the <ph id=\"ph2\">&lt;xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A&gt;</ph> method to instruct PLINQ to parallelize the query.","pos":[7695,7934],"source":" In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Specify the Execution Mode in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)</ept>.","pos":[7935,8098],"source":" For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)."},{"content":"The following list describes the query shapes that PLINQ by default will execute in sequential mode:","pos":[8105,8205]},{"content":"Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.","pos":[8215,8389]},{"content":"Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.","pos":[8399,8535]},{"content":"Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).","pos":[8545,8719]},{"content":"Queries that contain Concat, unless it is applied to indexable data sources.","pos":[8729,8805]},{"content":"Queries that contain Reverse, unless applied to an indexable data source.","pos":[8815,8888]},{"pos":[8897,8905],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8909,9000],"content":"<bpt id=\"p1\">[</bpt>Parallel LINQ (PLINQ)<ept id=\"p1\">](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)</ept>","source":"[Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)"}]}