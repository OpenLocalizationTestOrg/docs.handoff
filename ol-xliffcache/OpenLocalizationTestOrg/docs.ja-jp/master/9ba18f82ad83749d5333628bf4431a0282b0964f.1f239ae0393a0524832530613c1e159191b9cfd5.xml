{"content":"---\ntitle: C# Versioning - C# Guide\ndescription: Understand how versioning works in C# and .NET\nms.date: 01/08/2017\nms.assetid: aa8732d7-5cd0-46e1-994a-78017f20d861\n---\n\n# Versioning in C\\#\n\nIn this tutorial you'll learn what versioning means in .NET. You'll also learn the factors to consider when versioning your library as well as upgrading\nto a new version of a library.\n\n## Authoring Libraries\n\nAs a developer who has created .NET libraries for public use, you've most likely been in situations where you have\nto roll out new updates. How you go about this process matters a lot as you need to ensure that there's a seamless transition\nof existing code to the new version of your library. Here are several things to consider when creating a new release:\n\n### Semantic Versioning\n\n[Semantic versioning](https://semver.org/) (SemVer for short) is a naming convention applied to versions of your library to signify specific milestone events.\nIdeally, the version information you give your library should help developers determine the compatibility\nwith their projects that make use of older versions of that same library.\n\nThe most basic approach to SemVer is the 3 component format `MAJOR.MINOR.PATCH`, where:\n\n* `MAJOR` is incremented when you make incompatible API changes\n* `MINOR` is incremented when you add functionality in a backwards-compatible manner\n* `PATCH` is incremented when you make backwards-compatible bug fixes\n\nThere are also ways to specify other scenarios like pre-release versions etc. when applying version information to your .NET library.\n\n### Backwards Compatibility\n\nAs you release new versions of your library, backwards compatibility with previous versions will most likely be one of your major concerns.\nA new version of your library is source compatible with a previous version if code that depends on the previous version can, when recompiled, work with the new version. \nA new version of your library is binary compatible if an application that depended on the old version can, without recompilation, work with the new version.\n\nHere are some things to consider when trying to maintain backwards compatibility with older versions of your library:\n\n* Virtual methods: When you make a virtual method non-virtual in your new version it means that projects that override that method\nwill have to be updated. This is a huge breaking change and is strongly discouraged.\n* Method signatures: When updating a method behaviour requires you to change its signature as well, you should instead create an overload so that code calling into that method will still work.\nYou can always manipulate the old method signature to call into the new method signature so that implementation remains consistent.\n* [Obsolete attribute](programming-guide/concepts/attributes/common-attributes.md#Obsolete): You can use this attribute in your code to specify classes or class members that are deprecated and likely to be removed in future versions.\nThis ensures developers utilizing your library are better prepared for breaking changes.\n* Optional Method Arguments: When you make previously optional method arguments compulsory or change their default value then all code that does not supply those arguments will need to be updated.\n> [!NOTE]\n> Making compulsory arguments optional should have very little effect especially if it doesn't change the method's behaviour.\n\nThe easier you make it for your users to upgrade to the new version of your library, the more likely that they will upgrade sooner.\n\n### Application Configuration File\n\nAs a .NET developer there's a very high chance you've encountered [the `app.config` file](../framework/configure-apps/file-schema/index.md) present in most project types.\nThis simple configuration file can go a long way into improving the rollout of new updates. You should generally design your libraries in such\na way that information that is likely to change regularly is stored in the `app.config` file, this way when such information is updated\nthe config file of older versions just needs to be replaced with the new one without the need for recompilation of the library.\n\n## Consuming Libraries\n\nAs a developer that consumes .NET libraries built by other developers you're most likely aware that a new version of a library might not be fully compatible with your project\nand you might often find yourself having to update your code to work with those changes.\n\nLucky for you C# and the .NET ecosystem comes with features and techniques that allow us to easily update our app to work with new versions of libraries that might introduce breaking changes.\n\n### Assembly Binding Redirection\n\nYou can use the `app.config` file to update the version of a library your app uses. By adding what is called a [*binding redirect*](../framework/configure-apps/redirect-assembly-versions.md) you\ncan use the new library version without having to recompile your app. The following example shows how you would update\nyour app's `app.config` file to use the `1.0.1` patch version of `ReferencedLibrary` instead of the `1.0.0` version it was originally compiled with.\n\n```xml\n<dependentAssembly>\n    <assemblyIdentity name=\"ReferencedLibrary\" publicKeyToken=\"32ab4ba45e0a69a1\" culture=\"en-us\" />\n    <bindingRedirect oldVersion=\"1.0.0\" newVersion=\"1.0.1\" />\n</dependentAssembly>\n```\n\n> [!NOTE]\n> This approach will only work if the new version of `ReferencedLibrary` is binary compatible with your app.\n> See the [Backwards Compatibility](#backwards-compatibility) section above for changes to look out for when determining compatibility.\n\n### new\n\nYou use the `new` modifier to hide inherited members of a base class. This is one way derived classes can respond to updates in base classes.\n\nTake the following example:\n\n[!code-csharp[Sample usage of the 'new' modifier](../../samples/csharp/versioning/new/Program.cs#sample)]\n\n**Output**\n\n```\nA base method\nA derived method\n```\n\nFrom the example above you can see how `DerivedClass` hides the `MyMethod` method present in `BaseClass`.\nThis means that when a base class in the new version of a library adds a member that already exists in your derived class, you can\nsimply use the `new` modifier on your derived class member to hide the base class member.\n\nWhen no `new` modifier is specified, a derived class will by default hide conflicting members in a base class,\nalthough a compiler warning will be generated the code will still compile. This means that simply adding new members to an existing class\nmakes that new version of your library both source and binary compatible with code that depends on it.\n\n### override\n\nThe `override` modifier means a derived implementation extends the implementation of a base class member rather than\nhides it. The base class member needs to have the `virtual` modifier applied to it.\n\n[!code-csharp[Sample usage of the 'override' modifier](../../samples/csharp/versioning/override/Program.cs#sample)]\n\n**Output**\n\n```\nBase Method One: Method One\nDerived Method One: Derived Method One\n```\n\nThe `override` modifier is evaluated at compile time and the compiler will throw an error if it doesn't find a virtual member to override.\n\nYour knowledge of the discussed techniques as well as your understanding of what situations to use them will go a long way to boost the ease\nof transition between versions of a library.\n","nodes":[{"pos":[4,164],"embed":true,"restype":"x-metadata","content":"title: C# Versioning - C# Guide\ndescription: Understand how versioning works in C# and .NET\nms.date: 01/08/2017\nms.assetid: aa8732d7-5cd0-46e1-994a-78017f20d861","nodes":[{"content":"C# Versioning - C# Guide","nodes":[{"pos":[0,24],"content":"C# Versioning - C# Guide","nodes":[{"content":"C# Versioning - C# Guide","pos":[0,24]}]}],"path":["title"],"nosxs":false},{"content":"Understand how versioning works in C# and .NET","nodes":[{"pos":[0,46],"content":"Understand how versioning works in C# and .NET","nodes":[{"content":"Understand how versioning works in C# and .NET","pos":[0,46]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[172,189],"content":"Versioning in C\\#","linkify":"Versioning in C\\#","nodes":[{"content":"Versioning in C<ph id=\"ph1\">\\#</ph>","pos":[0,17],"source":"Versioning in C\\#"}]},{"content":"In this tutorial you'll learn what versioning means in .NET.","pos":[191,251]},{"content":"You'll also learn the factors to consider when versioning your library as well as upgrading to a new version of a library.","pos":[252,374],"source":" You'll also learn the factors to consider when versioning your library as well as upgrading\nto a new version of a library."},{"pos":[379,398],"content":"Authoring Libraries","linkify":"Authoring Libraries","nodes":[{"content":"Authoring Libraries","pos":[0,19]}]},{"content":"As a developer who has created .NET libraries for public use, you've most likely been in situations where you have to roll out new updates.","pos":[400,539],"source":"As a developer who has created .NET libraries for public use, you've most likely been in situations where you have\nto roll out new updates."},{"content":"How you go about this process matters a lot as you need to ensure that there's a seamless transition of existing code to the new version of your library.","pos":[540,693],"source":" How you go about this process matters a lot as you need to ensure that there's a seamless transition\nof existing code to the new version of your library."},{"content":"Here are several things to consider when creating a new release:","pos":[694,758]},{"pos":[764,783],"content":"Semantic Versioning","linkify":"Semantic Versioning","nodes":[{"content":"Semantic Versioning","pos":[0,19]}]},{"content":"<bpt id=\"p1\">[</bpt>Semantic versioning<ept id=\"p1\">](https://semver.org/)</ept> (SemVer for short) is a naming convention applied to versions of your library to signify specific milestone events.","pos":[785,943],"source":"[Semantic versioning](https://semver.org/) (SemVer for short) is a naming convention applied to versions of your library to signify specific milestone events."},{"content":"Ideally, the version information you give your library should help developers determine the compatibility with their projects that make use of older versions of that same library.","pos":[944,1123],"source":"\nIdeally, the version information you give your library should help developers determine the compatibility\nwith their projects that make use of older versions of that same library."},{"pos":[1125,1212],"content":"The most basic approach to SemVer is the 3 component format <ph id=\"ph1\">`MAJOR.MINOR.PATCH`</ph>, where:","source":"The most basic approach to SemVer is the 3 component format `MAJOR.MINOR.PATCH`, where:"},{"pos":[1216,1277],"content":"<ph id=\"ph1\">`MAJOR`</ph> is incremented when you make incompatible API changes","source":"`MAJOR` is incremented when you make incompatible API changes"},{"pos":[1280,1362],"content":"<ph id=\"ph1\">`MINOR`</ph> is incremented when you add functionality in a backwards-compatible manner","source":"`MINOR` is incremented when you add functionality in a backwards-compatible manner"},{"pos":[1365,1432],"content":"<ph id=\"ph1\">`PATCH`</ph> is incremented when you make backwards-compatible bug fixes","source":"`PATCH` is incremented when you make backwards-compatible bug fixes"},{"content":"There are also ways to specify other scenarios like pre-release versions etc. when applying version information to your .NET library.","pos":[1434,1567]},{"pos":[1573,1596],"content":"Backwards Compatibility","linkify":"Backwards Compatibility","nodes":[{"content":"Backwards Compatibility","pos":[0,23]}]},{"content":"As you release new versions of your library, backwards compatibility with previous versions will most likely be one of your major concerns.","pos":[1598,1737]},{"content":"A new version of your library is source compatible with a previous version if code that depends on the previous version can, when recompiled, work with the new version.","pos":[1738,1906],"source":"\nA new version of your library is source compatible with a previous version if code that depends on the previous version can, when recompiled, work with the new version."},{"content":"A new version of your library is binary compatible if an application that depended on the old version can, without recompilation, work with the new version.","pos":[1907,2064],"source":" \nA new version of your library is binary compatible if an application that depended on the old version can, without recompilation, work with the new version."},{"content":"Here are some things to consider when trying to maintain backwards compatibility with older versions of your library:","pos":[2066,2183]},{"content":"Virtual methods: When you make a virtual method non-virtual in your new version it means that projects that override that method will have to be updated.","pos":[2187,2340],"source":"Virtual methods: When you make a virtual method non-virtual in your new version it means that projects that override that method\nwill have to be updated."},{"content":"This is a huge breaking change and is strongly discouraged.","pos":[2341,2400]},{"content":"Method signatures: When updating a method behaviour requires you to change its signature as well, you should instead create an overload so that code calling into that method will still work.","pos":[2403,2593]},{"content":"You can always manipulate the old method signature to call into the new method signature so that implementation remains consistent.","pos":[2594,2725],"source":"\nYou can always manipulate the old method signature to call into the new method signature so that implementation remains consistent."},{"content":"<bpt id=\"p1\">[</bpt>Obsolete attribute<ept id=\"p1\">](programming-guide/concepts/attributes/common-attributes.md#Obsolete)</ept>: You can use this attribute in your code to specify classes or class members that are deprecated and likely to be removed in future versions.","pos":[2728,2959],"source":"[Obsolete attribute](programming-guide/concepts/attributes/common-attributes.md#Obsolete): You can use this attribute in your code to specify classes or class members that are deprecated and likely to be removed in future versions."},{"content":"This ensures developers utilizing your library are better prepared for breaking changes.","pos":[2960,3048],"source":"\nThis ensures developers utilizing your library are better prepared for breaking changes."},{"content":"Optional Method Arguments: When you make previously optional method arguments compulsory or change their default value then all code that does not supply those arguments will need to be updated.","pos":[3051,3245]},{"pos":[3248,3381],"content":"[!NOTE]\nMaking compulsory arguments optional should have very little effect especially if it doesn't change the method's behaviour.","leadings":["","> "],"nodes":[{"content":"Making compulsory arguments optional should have very little effect especially if it doesn't change the method's behaviour.","pos":[8,131]}]},{"content":"The easier you make it for your users to upgrade to the new version of your library, the more likely that they will upgrade sooner.","pos":[3383,3514]},{"pos":[3520,3550],"content":"Application Configuration File","linkify":"Application Configuration File","nodes":[{"content":"Application Configuration File","pos":[0,30]}]},{"content":"As a .NET developer there's a very high chance you've encountered <bpt id=\"p1\">[</bpt>the <ph id=\"ph1\">`app.config`</ph> file<ept id=\"p1\">](../framework/configure-apps/file-schema/index.md)</ept> present in most project types.","pos":[3552,3722],"source":"As a .NET developer there's a very high chance you've encountered [the `app.config` file](../framework/configure-apps/file-schema/index.md) present in most project types."},{"content":"This simple configuration file can go a long way into improving the rollout of new updates.","pos":[3723,3814],"source":"\nThis simple configuration file can go a long way into improving the rollout of new updates."},{"content":"You should generally design your libraries in such a way that information that is likely to change regularly is stored in the <ph id=\"ph1\">`app.config`</ph> file, this way when such information is updated the config file of older versions just needs to be replaced with the new one without the need for recompilation of the library.","pos":[3815,4129],"source":" You should generally design your libraries in such\na way that information that is likely to change regularly is stored in the `app.config` file, this way when such information is updated\nthe config file of older versions just needs to be replaced with the new one without the need for recompilation of the library."},{"pos":[4134,4153],"content":"Consuming Libraries","linkify":"Consuming Libraries","nodes":[{"content":"Consuming Libraries","pos":[0,19]}]},{"pos":[4155,4418],"content":"As a developer that consumes .NET libraries built by other developers you're most likely aware that a new version of a library might not be fully compatible with your project and you might often find yourself having to update your code to work with those changes.","source":"As a developer that consumes .NET libraries built by other developers you're most likely aware that a new version of a library might not be fully compatible with your project\nand you might often find yourself having to update your code to work with those changes."},{"content":"Lucky for you C# and the .NET ecosystem comes with features and techniques that allow us to easily update our app to work with new versions of libraries that might introduce breaking changes.","pos":[4420,4611]},{"pos":[4617,4645],"content":"Assembly Binding Redirection","linkify":"Assembly Binding Redirection","nodes":[{"content":"Assembly Binding Redirection","pos":[0,28]}]},{"content":"You can use the <ph id=\"ph1\">`app.config`</ph> file to update the version of a library your app uses.","pos":[4647,4730],"source":"You can use the `app.config` file to update the version of a library your app uses."},{"content":"By adding what is called a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">*</bpt>binding redirect<ept id=\"p2\">*</ept><ept id=\"p1\">](../framework/configure-apps/redirect-assembly-versions.md)</ept> you can use the new library version without having to recompile your app.","pos":[4731,4911],"source":" By adding what is called a [*binding redirect*](../framework/configure-apps/redirect-assembly-versions.md) you\ncan use the new library version without having to recompile your app."},{"content":"The following example shows how you would update your app's <ph id=\"ph1\">`app.config`</ph> file to use the <ph id=\"ph2\">`1.0.1`</ph> patch version of <ph id=\"ph3\">`ReferencedLibrary`</ph> instead of the <ph id=\"ph4\">`1.0.0`</ph> version it was originally compiled with.","pos":[4912,5109],"source":" The following example shows how you would update\nyour app's `app.config` file to use the `1.0.1` patch version of `ReferencedLibrary` instead of the `1.0.0` version it was originally compiled with."},{"pos":[5328,5580],"content":"[!NOTE]\nThis approach will only work if the new version of `ReferencedLibrary` is binary compatible with your app.\nSee the [Backwards Compatibility](#backwards-compatibility) section above for changes to look out for when determining compatibility.","leadings":["","> ","> "],"nodes":[{"content":"This approach will only work if the new version of `ReferencedLibrary` is binary compatible with your app.\nSee the [Backwards Compatibility](#backwards-compatibility) section above for changes to look out for when determining compatibility.","pos":[8,248],"nodes":[{"content":"This approach will only work if the new version of <ph id=\"ph1\">`ReferencedLibrary`</ph> is binary compatible with your app.","pos":[0,106],"source":"This approach will only work if the new version of `ReferencedLibrary` is binary compatible with your app."},{"content":"See the <bpt id=\"p1\">[</bpt>Backwards Compatibility<ept id=\"p1\">](#backwards-compatibility)</ept> section above for changes to look out for when determining compatibility.","pos":[107,240],"source":"\nSee the [Backwards Compatibility](#backwards-compatibility) section above for changes to look out for when determining compatibility."}]}]},{"pos":[5586,5589],"content":"new","linkify":"new","nodes":[{"content":"new","pos":[0,3]}]},{"content":"You use the <ph id=\"ph1\">`new`</ph> modifier to hide inherited members of a base class.","pos":[5591,5660],"source":"You use the `new` modifier to hide inherited members of a base class."},{"content":"This is one way derived classes can respond to updates in base classes.","pos":[5661,5732]},{"content":"Take the following example:","pos":[5734,5761]},{"pos":[5870,5880],"content":"<bpt id=\"p1\">**</bpt>Output<ept id=\"p1\">**</ept>","source":"**Output**"},{"content":"From the example above you can see how <ph id=\"ph1\">`DerivedClass`</ph> hides the <ph id=\"ph2\">`MyMethod`</ph> method present in <ph id=\"ph3\">`BaseClass`</ph>.","pos":[5922,6027],"source":"From the example above you can see how `DerivedClass` hides the `MyMethod` method present in `BaseClass`."},{"content":"This means that when a base class in the new version of a library adds a member that already exists in your derived class, you can simply use the <ph id=\"ph1\">`new`</ph> modifier on your derived class member to hide the base class member.","pos":[6028,6248],"source":"\nThis means that when a base class in the new version of a library adds a member that already exists in your derived class, you can\nsimply use the `new` modifier on your derived class member to hide the base class member."},{"content":"When no <ph id=\"ph1\">`new`</ph> modifier is specified, a derived class will by default hide conflicting members in a base class, although a compiler warning will be generated the code will still compile.","pos":[6250,6435],"source":"When no `new` modifier is specified, a derived class will by default hide conflicting members in a base class,\nalthough a compiler warning will be generated the code will still compile."},{"content":"This means that simply adding new members to an existing class makes that new version of your library both source and binary compatible with code that depends on it.","pos":[6436,6601],"source":" This means that simply adding new members to an existing class\nmakes that new version of your library both source and binary compatible with code that depends on it."},{"pos":[6607,6615],"content":"override","linkify":"override","nodes":[{"content":"override","pos":[0,8]}]},{"content":"The <ph id=\"ph1\">`override`</ph> modifier means a derived implementation extends the implementation of a base class member rather than hides it.","pos":[6617,6743],"source":"The `override` modifier means a derived implementation extends the implementation of a base class member rather than\nhides it."},{"content":"The base class member needs to have the <ph id=\"ph1\">`virtual`</ph> modifier applied to it.","pos":[6744,6817],"source":" The base class member needs to have the `virtual` modifier applied to it."},{"pos":[6936,6946],"content":"<bpt id=\"p1\">**</bpt>Output<ept id=\"p1\">**</ept>","source":"**Output**"},{"pos":[7024,7162],"content":"The <ph id=\"ph1\">`override`</ph> modifier is evaluated at compile time and the compiler will throw an error if it doesn't find a virtual member to override.","source":"The `override` modifier is evaluated at compile time and the compiler will throw an error if it doesn't find a virtual member to override."},{"pos":[7164,7349],"content":"Your knowledge of the discussed techniques as well as your understanding of what situations to use them will go a long way to boost the ease of transition between versions of a library.","source":"Your knowledge of the discussed techniques as well as your understanding of what situations to use them will go a long way to boost the ease\nof transition between versions of a library."}]}