{"content":"---\ntitle: \"Creating a custom header that is signed and-or encrypted\"\nms.date: \"03/30/2017\"\nms.assetid: e8668b37-c79f-4714-9de5-afcb88b9ff02\n---\n# Creating a custom header that is signed and-or encrypted\nWhen calling a non-WCF service using a WCF client it is sometimes necessary to use custom SOAP headers. There is a canonicalization bug in WCF that prevents custom headers that are signed and encrypted from working with a non-WCF service. The problem is caused by the incorrect canonicalization of default XML namespaces. This is only problematic when calling non-WCF services with custom headers that are signed and/or encrypted.  When the service receives the message containing the signed and/or encrypted custom header it is unable to verify the signature. This workaround avoids the canonicalization bug, allows interoperability with non-WCF services, but does not prevent interoperability with WCF services.  \n  \n## Defining the custom header  \n Custom headers are defined by defining a message contract and marking the members you want to be sent as headers with a <xref:System.ServiceModel.MessageHeaderAttribute> attribute. To work around the canonicalization bug you must ensure that the XML serializer declares the namespace for the custom header with a prefix instead of a default namespace declaration. The following code shows how to define the data type that will be used as a message header with the correct namespace declaration.  \n  \n```  \n[System.CodeDom.Compiler.GeneratedCodeAttribute(\"svcutil\", \"3.0.4506.648\")]  \n[System.SerializableAttribute()]  \n[System.Diagnostics.DebuggerStepThroughAttribute()]  \n[System.ComponentModel.DesignerCategoryAttribute(\"code\")]  \n[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace=\"http://www.example.org/getMessage/\")]  \npublic partial class msgHeaderElement  \n{  \n   // Define the XML namespace and force it to use an ‘h’ prefix  \n    [System.Xml.Serialization.XmlNamespaceDeclarations]  \n    public System.Xml.Serialization.XmlSerializerNamespaces _xsns = new System.Xml.Serialization.XmlSerializerNamespaces(new System.Xml.XmlQualifiedName[] { new System.Xml.XmlQualifiedName(\"h\", \"http://www.example.org/getMessage/\") });  \n  \n    private string msgHeaderInputField;  \n  [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, Order=0)]  \n    public string msgHeaderInput  \n    {  \n        get  \n        {  \n            return this.msgHeaderInputField;  \n        }  \n        set  \n        {  \n            this.msgHeaderInputField = value;  \n        }  \n    }  \n}  \n```  \n  \n This code declares a new type called `msgHeaderElement` that will be serialized with the XML Serializer. When an instance of this type is serialized, it will define a namespace with an ‘h’ prefix, thus working around the canonicalization bug.  The message contract would then define an instance of `msgHeaderElement` and mark it with the <xref:System.ServiceModel.MessageHeaderAttribute> attribute as shown in the following example.  \n  \n```  \n[MessageContract]  \npublic  class MyMessageContract  \n{  \n   // other message contents...  \n   [MessageHeader(ProductionLevel=ProtectionLevel.EncryptAndSign)]  \n   public msgHeaderElement;  \n   // other message contents...  \n}  \n```  \n  \n## See also\n\n- [Default Message Contract](../../../../docs/framework/wcf/samples/default-message-contract.md)\n- [Message Contracts](../../../../docs/framework/wcf/samples/message-contracts.md)\n- [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)\n","nodes":[{"pos":[4,140],"embed":true,"restype":"x-metadata","content":"title: \"Creating a custom header that is signed and-or encrypted\"\nms.date: \"03/30/2017\"\nms.assetid: e8668b37-c79f-4714-9de5-afcb88b9ff02","nodes":[{"content":"Creating a custom header that is signed and-or encrypted","nodes":[{"pos":[0,56],"content":"Creating a custom header that is signed and-or encrypted","nodes":[{"content":"Creating a custom header that is signed and-or encrypted","pos":[0,56]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[147,203],"content":"Creating a custom header that is signed and-or encrypted","linkify":"Creating a custom header that is signed and-or encrypted","nodes":[{"content":"Creating a custom header that is signed and-or encrypted","pos":[0,56]}]},{"content":"When calling a non-WCF service using a WCF client it is sometimes necessary to use custom SOAP headers.","pos":[204,307]},{"content":"There is a canonicalization bug in WCF that prevents custom headers that are signed and encrypted from working with a non-WCF service.","pos":[308,442]},{"content":"The problem is caused by the incorrect canonicalization of default XML namespaces.","pos":[443,525]},{"content":"This is only problematic when calling non-WCF services with custom headers that are signed and/or encrypted.","pos":[526,634]},{"content":"When the service receives the message containing the signed and/or encrypted custom header it is unable to verify the signature.","pos":[636,764]},{"content":"This workaround avoids the canonicalization bug, allows interoperability with non-WCF services, but does not prevent interoperability with WCF services.","pos":[765,917]},{"pos":[926,952],"content":"Defining the custom header","linkify":"Defining the custom header","nodes":[{"content":"Defining the custom header","pos":[0,26]}]},{"content":"Custom headers are defined by defining a message contract and marking the members you want to be sent as headers with a <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> attribute.","pos":[956,1136],"source":"Custom headers are defined by defining a message contract and marking the members you want to be sent as headers with a <xref:System.ServiceModel.MessageHeaderAttribute> attribute."},{"content":"To work around the canonicalization bug you must ensure that the XML serializer declares the namespace for the custom header with a prefix instead of a default namespace declaration.","pos":[1137,1319]},{"content":"The following code shows how to define the data type that will be used as a message header with the correct namespace declaration.","pos":[1320,1450]},{"content":"This code declares a new type called <ph id=\"ph1\">`msgHeaderElement`</ph> that will be serialized with the XML Serializer.","pos":[2601,2705],"source":"This code declares a new type called `msgHeaderElement` that will be serialized with the XML Serializer."},{"content":"When an instance of this type is serialized, it will define a namespace with an ‘h’ prefix, thus working around the canonicalization bug.","pos":[2706,2843]},{"content":"The message contract would then define an instance of <ph id=\"ph1\">`msgHeaderElement`</ph> and mark it with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> attribute as shown in the following example.","pos":[2845,3033],"source":"  The message contract would then define an instance of `msgHeaderElement` and mark it with the <xref:System.ServiceModel.MessageHeaderAttribute> attribute as shown in the following example."},{"pos":[3286,3294],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3298,3392],"content":"<bpt id=\"p1\">[</bpt>Default Message Contract<ept id=\"p1\">](../../../../docs/framework/wcf/samples/default-message-contract.md)</ept>","source":"[Default Message Contract](../../../../docs/framework/wcf/samples/default-message-contract.md)"},{"pos":[3395,3475],"content":"<bpt id=\"p1\">[</bpt>Message Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/samples/message-contracts.md)</ept>","source":"[Message Contracts](../../../../docs/framework/wcf/samples/message-contracts.md)"},{"pos":[3478,3578],"content":"<bpt id=\"p1\">[</bpt>Using Message Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)</ept>","source":"[Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)"}]}