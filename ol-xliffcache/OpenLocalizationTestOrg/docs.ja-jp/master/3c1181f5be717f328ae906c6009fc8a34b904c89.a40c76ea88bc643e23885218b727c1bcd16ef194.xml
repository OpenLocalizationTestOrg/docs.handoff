{"content":"---\ntitle: Generic types (generics) overview\ndescription: Learn how generics act as code templates that allow you to define type-safe data structures without committing to an actual data type.\nauthor: kuhlenh\nms.author: wiwagn\nms.date: 10/09/2018\n---\n# Generic types overview\n\nDevelopers use generics all the time in .NET, whether implicitly or explicitly. When you use LINQ in .NET, did you ever notice that you're working with <xref:System.Collections.Generic.IEnumerable%601>? Or if you ever saw an online sample of a \"generic repository\" for talking to databases using Entity Framework, did you see that most methods return IQueryable\\<T>? You may have wondered what the **T** is in these examples and why it's in there.\n\nFirst introduced in the .NET Framework 2.0, **generics** are essentially a \"code template\" that allows developers to define [type-safe](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hbzz1a9a(v=vs.100)) data structures without committing to an actual data type. For example, <xref:System.Collections.Generic.List%601> is a [generic collection](xref:System.Collections.Generic) that can be declared and used with any type, such as `List<int>`, `List<string>`, or `List<Person>`.\n\nTo understand why generics are useful, let's take a look at a specific class before and after adding generics: <xref:System.Collections.ArrayList>. In .NET Framework 1.0, the `ArrayList` elements were of type <xref:System.Object>. This meant that any element added was silently converted into an `Object`. The same would happen when reading the elements from the list. This process is known as [boxing and unboxing](../csharp/programming-guide/types/boxing-and-unboxing.md), and it impacts performance. More than that, however, there's no way to determine the type of data in the list at compile time. This makes for some fragile code. Generics solve this problem by defining the type of data each instance of list will contain. For example, you can only add integers to `List<int>` and only add Persons to `List<Person>`.\n\nGenerics are also available at runtime. This means the runtime knows what type of data structure you're using and can store it in memory more efficiently.\n\nThe following example is a small program that illustrates the efficiency of knowing the data structure type at runtime:\n\n```csharp\n  using System;\n  using System.Collections;\n  using System.Collections.Generic;\n  using System.Diagnostics;\n\n  namespace GenericsExample {\n    class Program {\n      static void Main(string[] args) {\n        //generic list\n        List<int> ListGeneric = new List<int> { 5, 9, 1, 4 };\n        //non-generic list\n        ArrayList ListNonGeneric = new ArrayList { 5, 9, 1, 4 };\n        // timer for generic list sort\n        Stopwatch s = Stopwatch.StartNew();\n        ListGeneric.Sort();\n        s.Stop();\n        Console.WriteLine($\"Generic Sort: {ListGeneric}  \\n Time taken: {s.Elapsed.TotalMilliseconds}ms\");\n\n        //timer for non-generic list sort\n        Stopwatch s2 = Stopwatch.StartNew();\n        ListNonGeneric.Sort();\n        s2.Stop();\n        Console.WriteLine($\"Non-Generic Sort: {ListNonGeneric}  \\n Time taken: {s2.Elapsed.TotalMilliseconds}ms\");\n        Console.ReadLine();\n      }\n    }\n  }\n```\n\nThis program produces output similar to the following:\n\n```console\nGeneric Sort: System.Collections.Generic.List`1[System.Int32]\n Time taken: 0.0034ms\nNon-Generic Sort: System.Collections.ArrayList\n Time taken: 0.2592ms\n```\n\nThe first thing you can notice here is that sorting the generic list is significantly faster than sorting the non-generic list. You might also notice that the type for the generic list is distinct ([System.Int32]), whereas the type for the non-generic list is generalized. Because the runtime knows the generic `List<int>` is of type <xref:System.Int32>, it can store the list elements in an underlying integer array in memory while the non-generic `ArrayList` has to cast each list element to an object. As this example shows, the extra casts take up time and slow down the list sort.\n\nAn additional advantage of the runtime knowing the type of your generic is a better debugging experience. When you're debugging a generic in C#, you know what type each element is in your data structure. Without generics, you would have no idea what type each element was.\n\n## See also\n\n- [C# Programming Guide - Generics](../../docs/csharp/programming-guide/generics/index.md)\n","nodes":[{"pos":[4,246],"embed":true,"restype":"x-metadata","content":"title: Generic types (generics) overview\ndescription: Learn how generics act as code templates that allow you to define type-safe data structures without committing to an actual data type.\nauthor: kuhlenh\nms.author: wiwagn\nms.date: 10/09/2018","nodes":[{"content":"Generic types (generics) overview","nodes":[{"pos":[0,33],"content":"Generic types (generics) overview","nodes":[{"content":"Generic types (generics) overview","pos":[0,33]}]}],"path":["title"],"nosxs":false},{"content":"Learn how generics act as code templates that allow you to define type-safe data structures without committing to an actual data type.","nodes":[{"pos":[0,134],"content":"Learn how generics act as code templates that allow you to define type-safe data structures without committing to an actual data type.","nodes":[{"content":"Learn how generics act as code templates that allow you to define type-safe data structures without committing to an actual data type.","pos":[0,134]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[253,275],"content":"Generic types overview","linkify":"Generic types overview","nodes":[{"content":"Generic types overview","pos":[0,22]}]},{"content":"Developers use generics all the time in .NET, whether implicitly or explicitly.","pos":[277,356]},{"content":"When you use LINQ in .NET, did you ever notice that you're working with <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>?","pos":[357,479],"source":" When you use LINQ in .NET, did you ever notice that you're working with <xref:System.Collections.Generic.IEnumerable%601>?"},{"content":"Or if you ever saw an online sample of a \"generic repository\" for talking to databases using Entity Framework, did you see that most methods return IQueryable<ph id=\"ph1\">\\&lt;</ph>T&gt;?","pos":[480,643],"source":" Or if you ever saw an online sample of a \"generic repository\" for talking to databases using Entity Framework, did you see that most methods return IQueryable\\<T>?"},{"content":"You may have wondered what the <bpt id=\"p1\">**</bpt>T<ept id=\"p1\">**</ept> is in these examples and why it's in there.","pos":[644,724],"source":" You may have wondered what the **T** is in these examples and why it's in there."},{"content":"First introduced in the .NET Framework 2.0, <bpt id=\"p1\">**</bpt>generics<ept id=\"p1\">**</ept> are essentially a \"code template\" that allows developers to define <bpt id=\"p2\">[</bpt>type-safe<ept id=\"p2\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hbzz1a9a(v=vs.100))</ept> data structures without committing to an actual data type.","pos":[726,1009],"source":"First introduced in the .NET Framework 2.0, **generics** are essentially a \"code template\" that allows developers to define [type-safe](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hbzz1a9a(v=vs.100)) data structures without committing to an actual data type."},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is a <bpt id=\"p1\">[</bpt>generic collection<ept id=\"p1\">](xref:System.Collections.Generic)</ept> that can be declared and used with any type, such as <ph id=\"ph2\">`List&lt;int&gt;`</ph>, <ph id=\"ph3\">`List&lt;string&gt;`</ph>, or <ph id=\"ph4\">`List&lt;Person&gt;`</ph>.","pos":[1010,1225],"source":" For example, <xref:System.Collections.Generic.List%601> is a [generic collection](xref:System.Collections.Generic) that can be declared and used with any type, such as `List<int>`, `List<string>`, or `List<Person>`."},{"content":"To understand why generics are useful, let's take a look at a specific class before and after adding generics: <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph>.","pos":[1227,1374],"source":"To understand why generics are useful, let's take a look at a specific class before and after adding generics: <xref:System.Collections.ArrayList>."},{"content":"In .NET Framework 1.0, the <ph id=\"ph1\">`ArrayList`</ph> elements were of type <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[1375,1457],"source":" In .NET Framework 1.0, the `ArrayList` elements were of type <xref:System.Object>."},{"content":"This meant that any element added was silently converted into an <ph id=\"ph1\">`Object`</ph>.","pos":[1458,1532],"source":" This meant that any element added was silently converted into an `Object`."},{"content":"The same would happen when reading the elements from the list.","pos":[1533,1595]},{"content":"This process is known as <bpt id=\"p1\">[</bpt>boxing and unboxing<ept id=\"p1\">](../csharp/programming-guide/types/boxing-and-unboxing.md)</ept>, and it impacts performance.","pos":[1596,1729],"source":" This process is known as [boxing and unboxing](../csharp/programming-guide/types/boxing-and-unboxing.md), and it impacts performance."},{"content":"More than that, however, there's no way to determine the type of data in the list at compile time.","pos":[1730,1828]},{"content":"This makes for some fragile code.","pos":[1829,1862]},{"content":"Generics solve this problem by defining the type of data each instance of list will contain.","pos":[1863,1955]},{"content":"For example, you can only add integers to <ph id=\"ph1\">`List&lt;int&gt;`</ph> and only add Persons to <ph id=\"ph2\">`List&lt;Person&gt;`</ph>.","pos":[1956,2049],"source":" For example, you can only add integers to `List<int>` and only add Persons to `List<Person>`."},{"content":"Generics are also available at runtime.","pos":[2051,2090]},{"content":"This means the runtime knows what type of data structure you're using and can store it in memory more efficiently.","pos":[2091,2205]},{"content":"The following example is a small program that illustrates the efficiency of knowing the data structure type at runtime:","pos":[2207,2326]},{"content":"This program produces output similar to the following:","pos":[3254,3308]},{"content":"The first thing you can notice here is that sorting the generic list is significantly faster than sorting the non-generic list.","pos":[3479,3606]},{"content":"You might also notice that the type for the generic list is distinct ([System.Int32]), whereas the type for the non-generic list is generalized.","pos":[3607,3751]},{"content":"Because the runtime knows the generic <ph id=\"ph1\">`List&lt;int&gt;`</ph> is of type <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph>, it can store the list elements in an underlying integer array in memory while the non-generic <ph id=\"ph3\">`ArrayList`</ph> has to cast each list element to an object.","pos":[3752,3983],"source":" Because the runtime knows the generic `List<int>` is of type <xref:System.Int32>, it can store the list elements in an underlying integer array in memory while the non-generic `ArrayList` has to cast each list element to an object."},{"content":"As this example shows, the extra casts take up time and slow down the list sort.","pos":[3984,4064]},{"content":"An additional advantage of the runtime knowing the type of your generic is a better debugging experience.","pos":[4066,4171]},{"content":"When you're debugging a generic in C#, you know what type each element is in your data structure.","pos":[4172,4269]},{"content":"Without generics, you would have no idea what type each element was.","pos":[4270,4338]},{"pos":[4343,4351],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4355,4443],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide - Generics<ept id=\"p1\">](../../docs/csharp/programming-guide/generics/index.md)</ept>","source":"[C# Programming Guide - Generics](../../docs/csharp/programming-guide/generics/index.md)"}]}