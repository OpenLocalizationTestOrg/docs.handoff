{"content":"---\ntitle: .NET Core CLI extensibility model | Microsoft Docs\ndescription: Learn how you can extend the Command-line Interface (CLI) tools.\nkeywords: CLI, extensibility, custom commands, .NET Core\nauthor: blackdwarf\nms.author: mairaw\nms.date: 04/12/2017\nms.topic: article\nms.prod: .net-core\nms.technology: dotnet-cli\nms.devlang: dotnet\nms.assetid: fffc3400-aeb9-4c07-9fea-83bc8dbdcbf3\n---\n\n# .NET Core CLI tools extensibility model\n\nThis document covers the different ways you can extend the .NET Core Command-line Interface (CLI) tools and explain the scenarios that drive each one of them.\nYou'll see how to consume the tools as well as how to build the different types of tools.\n\n## How to extend CLI tools\nThe CLI tools can be extended in three main ways:\n\n1. [Via NuGet packages on a per-project basis](#per-project-based-extensibility)\n\n  Per-project tools are contained within the project's context, but they allow easy installation through restoration.\n\n2. [Via NuGet packages with custom targets](#custom-targets)\n\n  Custom targets allow you to easily extend the build process with custom tasks.\n\n3. [Via the system's PATH](#path-based-extensibility)\n\n  PATH-based tools are good for general, cross-project tools that are usable on a single machine.\n\nThe three extensibility mechanisms outlined above are not exclusive. You can use one, or all, or a combination of them. Which one to pick\ndepends largely on the goal you are trying to achieve with your extension.\n\n## Per-project based extensibility\nPer-project tools are [framework-dependent deployments](../deploying/index.md#framework-dependent-deployments-fdd) that are distributed as NuGet packages. Tools are only available in the context of the project that references them and for which they are restored. Invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail because the command cannot be found.\n\nThese tools are perfect for build servers, since nothing outside of the project file is needed. The build process\nruns restore for the project it builds and tools will be available. Language projects, such as F#, are also in this\ncategory since each project can only be written in one specific language.\n\nFinally, this extensibility model provides support for creation of tools that need access to the built output of the\nproject. For instance, various Razor view tools in [ASP.NET](https://www.asp.net/) MVC applications fall into this\ncategory.\n\n### Consuming per-project tools\nConsuming these tools requires you to add a `<DotNetCliToolReference>` element to your project file for each tool you want to use. Inside the `<DotNetCliToolReference>` element, you reference the package in which the tool resides and specify the version you need. After running [`dotnet restore`](dotnet-restore.md), the tool and its dependencies are restored.\n\nFor tools that need to load the build output of the project for execution, there is usually another dependency which is\nlisted under the regular dependencies in the project file. Since CLI uses MSBuild as its build engine, we recommend that these parts of the tool be written as custom MSBuild [targets](https://docs.microsoft.com/visualstudio/msbuild/msbuild-targets) and [tasks](https://docs.microsoft.com/visualstudio/msbuild/msbuild-tasks), since they can then take part in the overall build process. Also, they can get any and all data easily that is produced via the build, such as the location of the output files, the current configuration being built, etc. All this information becomes a set of MSBuild properties that can be read from any target. You can see how to add a custom target using NuGet later in this document.\n\nLet's review an example of adding a simple tools-only tool to a simple project. Given an example command called\n`dotnet-api-search` that allows you to search through the NuGet packages for the specified\nAPI, here is a console application's project file that uses that tool:\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>netcoreapp1.1</TargetFramework>\n  </PropertyGroup>\n\n  <!-- The tools reference -->\n  <ItemGroup>\n    <DotNetCliToolReference Include=\"dotnet-api-search\" Version=\"1.0.0\" />\n  </ItemGroup>\n</Project>\n```\n\nThe `<DotNetCliToolReference>` element is structured in a similar way as the `<PackageReference>` element. It needs the package ID of the package containing the tool and its version to be able to restore.\n\n### Building tools\nAs mentioned, tools are just portable console applications. You build tools as you would build any other console application.\nAfter you build it, you use the [`dotnet pack`](dotnet-pack.md) command to create a NuGet package (.nupkg file) that contains\nyour code, information about its dependencies, and so on. You can give any name to the package, but the\napplication inside, the actual tool binary, has to conform to the convention of `dotnet-<command>` in order for `dotnet`\nto be able to invoke it.\n\n> [!NOTE]\n> In pre-RC3 versions of the .NET Core command-line tools, the `dotnet pack` command had a bug that caused the `runtime.config.json` to not be packed with the tool. Lacking that file results in errors at runtime. If you encounter this behavior, be sure to update to the latest tooling and try the `dotnet pack` again.\n\nSince tools are portable applications, the user consuming the tool must have the version of the .NET Core libraries\nthat the tool was built against in order to run the tool. Any other dependency that the tool uses and that is not\ncontained within the .NET Core libraries is restored and placed in the NuGet cache. The entire tool is, therefore, run\nusing the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.\n\nThese kinds of tools have a dependency graph that is completely separate from the dependency graph of the project that\nuses them. The restore process first restores the project's dependencies and then restores each of the tools and\ntheir dependencies.\n\nYou can find richer examples and different combinations of this in the [.NET Core CLI repo](https://github.com/dotnet/cli/tree/rel/1.0.1/TestAssets/TestProjects).\nYou can also see the [implementation of tools used](https://github.com/dotnet/cli/tree/rel/1.0.1/TestAssets/TestPackages) in the same repo.\n\n### Custom targets\nNuGet has the capability to [package custom MSBuild targets and props files](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package). With the move of the .NET Core CLI tools to use MSBuild, the same mechanism of extensibility now applies to .NET Core projects. You would use this type of extensibility when you want to extend the build process, or when you want to access any of the artifacts in the build process, such as generated files, or you want to inspect the configuration under which the build is invoked, etc.\n\nIn the following example, you can see the target's project file using the `csproj` syntax. This instructs the [`dotnet pack`](dotnet-pack.md) command what to package, placing the targets files as well as the assemblies into the *build* folder inside the package. Notice the `<ItemGroup>` element that has the `Label` property set to `dotnet pack instructions`, and the Target\ndefined beneath it.\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <Description>Sample Packer</Description>\n    <VersionPrefix>0.1.0-preview</VersionPrefix>\n    <TargetFramework>netstandard1.3</TargetFramework>\n    <DebugType>portable</DebugType>\n    <AssemblyName>SampleTargets.PackerTarget</AssemblyName>\n  </PropertyGroup>\n  <ItemGroup>\n    <EmbeddedResource Include=\"Resources\\Pkg\\dist-template.xml;compiler\\resources\\**\\*\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" />\n    <None Include=\"build\\SampleTargets.PackerTarget.targets\" />\n  </ItemGroup>\n  <ItemGroup Label=\"dotnet pack instructions\">\n    <Content Include=\"build\\*.targets\">\n      <Pack>true</Pack>\n      <PackagePath>build\\</PackagePath>\n    </Content>\n  </ItemGroup>\n  <Target Name=\"CollectRuntimeOutputs\" BeforeTargets=\"_GetPackageFiles\">\n    <!-- Collect these items inside a target that runs after build but before packaging. -->\n    <ItemGroup>\n      <Content Include=\"$(OutputPath)\\*.dll;$(OutputPath)\\*.json\">\n        <Pack>true</Pack>\n        <PackagePath>build\\</PackagePath>\n      </Content>\n    </ItemGroup>\n  </Target>\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.Extensions.DependencyModel\" Version=\"1.0.1-beta-000933\"/>\n    <PackageReference Include=\"Microsoft.Build.Framework\" Version=\"0.1.0-preview-00028-160627\" />\n    <PackageReference Include=\"Microsoft.Build.Utilities.Core\" Version=\"0.1.0-preview-00028-160627\" />\n    <PackageReference Include=\"Newtonsoft.Json\" Version=\"9.0.1\" />\n  </ItemGroup>\n  <ItemGroup />\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>463c66f0-921d-4d34-8bde-7c9d0bffaf7b</ProjectGuid>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(TargetFramework)' == 'netstandard1.3' \">\n    <DefineConstants>$(DefineConstants);NETSTANDARD1_3</DefineConstants>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)' == 'Release' \">\n    <DefineConstants>$(DefineConstants);RELEASE</DefineConstants>\n  </PropertyGroup>\n</Project>\n```\n\nConsuming custom targets is done by providing a `<PackageReference>` that points to the package and its version inside the project that is being extended. Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.\n\nUsing the custom target depends solely on how you configure it. Since it's an MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the `dotnet msbuild /t:<target-name>` command.\n\nHowever, if you want to provide a better user experience to your users, you can combine per-project tools and custom targets. In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required [`dotnet msbuild`](dotnet-msbuild.md) invocation that would execute the target. You can see a sample of this kind of synergy on the [MVP Summit 2016 Hackathon samples](https://github.com/dotnet/MVPSummitHackathon2016) repo in the [`dotnet-packer`](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer) project.\n\n### PATH-based extensibility\nPATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more\nthan a single project. The main drawback of this extension mechanism is that it's tied to the machine where the\ntool exists. If you need it on another machine, you would have to deploy it.\n\nThis pattern of CLI toolset extensibility is very simple. As covered in the [.NET Core CLI overview](index.md), `dotnet` driver\ncan run any command that is named after the `dotnet-<command>` convention. The default resolution logic first\nprobes several locations and finally falls back to the system PATH. If the requested command exists in the system PATH\nand is a binary that can be invoked, `dotnet` driver will invoke it.\n\nThe file must be executable. On Unix systems, this means anything that\nhas the execute bit set via `chmod +x`. On Windows, you can use *cmd* files.\n\nLet's take a look at the very simple implementation of a \"Hello World\" tool. We will use both `bash` and `cmd` on Windows.\nThe following command will simply echo \"Hello World\" to the console.\n\n```bash\n#!/bin/bash\n\necho \"Hello World!\"\n```\n\n```cmd\necho \"Hello World\"\n```\n\nOn macOS, we can save this script as `dotnet-hello` and set its executable bit with `chmod +x dotnet-hello`. We can then\ncreate a symbolic link to it in `/usr/local/bin` using the command `ln -s dotnet-hello /usr/local/bin/`. This will make\nit possible to invoke the command using the `dotnet hello` syntax.\n\nOn Windows, we can save this script as `dotnet-hello.cmd` and put it in a location that is in a system path (or you can\nadd it to a folder that is already in the path). After this, you can just use `dotnet hello` to run this example.\n","nodes":[{"pos":[11,61],"content":".NET Core CLI extensibility model | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":".NET Core CLI extensibility model | Microsoft Docs","pos":[0,50]}]},{"pos":[75,139],"content":"Learn how you can extend the Command-line Interface (CLI) tools.","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn how you can extend the Command-line Interface (CLI) tools.","pos":[0,64]}]},{"pos":[150,196],"content":"CLI, extensibility, custom commands, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":"CLI, extensibility, custom commands, .NET Core","pos":[0,46]}]},{"pos":[392,431],"content":".NET Core CLI tools extensibility model","linkify":".NET Core CLI tools extensibility model","nodes":[{"content":".NET Core CLI tools extensibility model","pos":[0,39]}]},{"content":"This document covers the different ways you can extend the .NET Core Command-line Interface (CLI) tools and explain the scenarios that drive each one of them.","pos":[433,591]},{"content":"You'll see how to consume the tools as well as how to build the different types of tools.","pos":[592,681],"source":"\nYou'll see how to consume the tools as well as how to build the different types of tools."},{"pos":[686,709],"content":"How to extend CLI tools","linkify":"How to extend CLI tools","nodes":[{"content":"How to extend CLI tools","pos":[0,23]}]},{"content":"The CLI tools can be extended in three main ways:","pos":[710,759]},{"pos":[764,841],"content":"<bpt id=\"p1\">[</bpt>Via NuGet packages on a per-project basis<ept id=\"p1\">](#per-project-based-extensibility)</ept>","source":"[Via NuGet packages on a per-project basis](#per-project-based-extensibility)"},{"content":"Per-project tools are contained within the project's context, but they allow easy installation through restoration.","pos":[845,960]},{"pos":[965,1022],"content":"<bpt id=\"p1\">[</bpt>Via NuGet packages with custom targets<ept id=\"p1\">](#custom-targets)</ept>","source":"[Via NuGet packages with custom targets](#custom-targets)"},{"content":"Custom targets allow you to easily extend the build process with custom tasks.","pos":[1026,1104]},{"pos":[1109,1159],"content":"<bpt id=\"p1\">[</bpt>Via the system's PATH<ept id=\"p1\">](#path-based-extensibility)</ept>","source":"[Via the system's PATH](#path-based-extensibility)"},{"content":"PATH-based tools are good for general, cross-project tools that are usable on a single machine.","pos":[1163,1258]},{"content":"The three extensibility mechanisms outlined above are not exclusive.","pos":[1260,1328]},{"content":"You can use one, or all, or a combination of them.","pos":[1329,1379]},{"content":"Which one to pick depends largely on the goal you are trying to achieve with your extension.","pos":[1380,1472],"source":" Which one to pick\ndepends largely on the goal you are trying to achieve with your extension."},{"pos":[1477,1508],"content":"Per-project based extensibility","linkify":"Per-project based extensibility","nodes":[{"content":"Per-project based extensibility","pos":[0,31]}]},{"content":"Per-project tools are <bpt id=\"p1\">[</bpt>framework-dependent deployments<ept id=\"p1\">](../deploying/index.md#framework-dependent-deployments-fdd)</ept> that are distributed as NuGet packages.","pos":[1509,1663],"source":"Per-project tools are [framework-dependent deployments](../deploying/index.md#framework-dependent-deployments-fdd) that are distributed as NuGet packages."},{"content":"Tools are only available in the context of the project that references them and for which they are restored.","pos":[1664,1772]},{"content":"Invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail because the command cannot be found.","pos":[1773,1934]},{"content":"These tools are perfect for build servers, since nothing outside of the project file is needed.","pos":[1936,2031]},{"content":"The build process runs restore for the project it builds and tools will be available.","pos":[2032,2117],"source":" The build process\nruns restore for the project it builds and tools will be available."},{"content":"Language projects, such as F#, are also in this category since each project can only be written in one specific language.","pos":[2118,2239],"source":" Language projects, such as F#, are also in this\ncategory since each project can only be written in one specific language."},{"content":"Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.","pos":[2241,2366],"source":"Finally, this extensibility model provides support for creation of tools that need access to the built output of the\nproject."},{"content":"For instance, various Razor view tools in <bpt id=\"p1\">[</bpt>ASP.NET<ept id=\"p1\">](https://www.asp.net/)</ept> MVC applications fall into this category.","pos":[2367,2482],"source":" For instance, various Razor view tools in [ASP.NET](https://www.asp.net/) MVC applications fall into this\ncategory."},{"pos":[2488,2515],"content":"Consuming per-project tools","linkify":"Consuming per-project tools","nodes":[{"content":"Consuming per-project tools","pos":[0,27]}]},{"content":"Consuming these tools requires you to add a <ph id=\"ph1\">`&lt;DotNetCliToolReference&gt;`</ph> element to your project file for each tool you want to use.","pos":[2516,2646],"source":"Consuming these tools requires you to add a `<DotNetCliToolReference>` element to your project file for each tool you want to use."},{"content":"Inside the <ph id=\"ph1\">`&lt;DotNetCliToolReference&gt;`</ph> element, you reference the package in which the tool resides and specify the version you need.","pos":[2647,2779],"source":" Inside the `<DotNetCliToolReference>` element, you reference the package in which the tool resides and specify the version you need."},{"content":"After running <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet restore`</ph><ept id=\"p1\">](dotnet-restore.md)</ept>, the tool and its dependencies are restored.","pos":[2780,2876],"source":" After running [`dotnet restore`](dotnet-restore.md), the tool and its dependencies are restored."},{"content":"For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.","pos":[2878,3056],"source":"For tools that need to load the build output of the project for execution, there is usually another dependency which is\nlisted under the regular dependencies in the project file."},{"content":"Since CLI uses MSBuild as its build engine, we recommend that these parts of the tool be written as custom MSBuild <bpt id=\"p1\">[</bpt>targets<ept id=\"p1\">](https://docs.microsoft.com/visualstudio/msbuild/msbuild-targets)</ept> and <bpt id=\"p2\">[</bpt>tasks<ept id=\"p2\">](https://docs.microsoft.com/visualstudio/msbuild/msbuild-tasks)</ept>, since they can then take part in the overall build process.","pos":[3057,3382],"source":" Since CLI uses MSBuild as its build engine, we recommend that these parts of the tool be written as custom MSBuild [targets](https://docs.microsoft.com/visualstudio/msbuild/msbuild-targets) and [tasks](https://docs.microsoft.com/visualstudio/msbuild/msbuild-tasks), since they can then take part in the overall build process."},{"content":"Also, they can get any and all data easily that is produced via the build, such as the location of the output files, the current configuration being built, etc. All this information becomes a set of MSBuild properties that can be read from any target.","pos":[3383,3634]},{"content":"You can see how to add a custom target using NuGet later in this document.","pos":[3635,3709]},{"content":"Let's review an example of adding a simple tools-only tool to a simple project.","pos":[3711,3790]},{"content":"Given an example command called <ph id=\"ph1\">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:","pos":[3791,3984],"source":" Given an example command called\n`dotnet-api-search` that allows you to search through the NuGet packages for the specified\nAPI, here is a console application's project file that uses that tool:"},{"content":"The <ph id=\"ph1\">`&lt;DotNetCliToolReference&gt;`</ph> element is structured in a similar way as the <ph id=\"ph2\">`&lt;PackageReference&gt;`</ph> element.","pos":[4302,4408],"source":"The `<DotNetCliToolReference>` element is structured in a similar way as the `<PackageReference>` element."},{"content":"It needs the package ID of the package containing the tool and its version to be able to restore.","pos":[4409,4506]},{"pos":[4512,4526],"content":"Building tools","linkify":"Building tools","nodes":[{"content":"Building tools","pos":[0,14]}]},{"content":"As mentioned, tools are just portable console applications.","pos":[4527,4586]},{"content":"You build tools as you would build any other console application.","pos":[4587,4652]},{"content":"After you build it, you use the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet pack`</ph><ept id=\"p1\">](dotnet-pack.md)</ept> command to create a NuGet package (.nupkg file) that contains your code, information about its dependencies, and so on.","pos":[4653,4836],"source":"\nAfter you build it, you use the [`dotnet pack`](dotnet-pack.md) command to create a NuGet package (.nupkg file) that contains\nyour code, information about its dependencies, and so on."},{"content":"You can give any name to the package, but the application inside, the actual tool binary, has to conform to the convention of <ph id=\"ph1\">`dotnet-&lt;command&gt;`</ph> in order for <ph id=\"ph2\">`dotnet`</ph> to be able to invoke it.","pos":[4837,5028],"source":" You can give any name to the package, but the\napplication inside, the actual tool binary, has to conform to the convention of `dotnet-<command>` in order for `dotnet`\nto be able to invoke it."},{"pos":[5032,5357],"content":"[!NOTE]\nIn pre-RC3 versions of the .NET Core command-line tools, the `dotnet pack` command had a bug that caused the `runtime.config.json` to not be packed with the tool. Lacking that file results in errors at runtime. If you encounter this behavior, be sure to update to the latest tooling and try the `dotnet pack` again.","leadings":["","> "],"nodes":[{"content":"In pre-RC3 versions of the .NET Core command-line tools, the `dotnet pack` command had a bug that caused the `runtime.config.json` to not be packed with the tool. Lacking that file results in errors at runtime. If you encounter this behavior, be sure to update to the latest tooling and try the `dotnet pack` again.","pos":[8,323],"nodes":[{"content":"In pre-RC3 versions of the .NET Core command-line tools, the <ph id=\"ph1\">`dotnet pack`</ph> command had a bug that caused the <ph id=\"ph2\">`runtime.config.json`</ph> to not be packed with the tool.","pos":[0,162],"source":"In pre-RC3 versions of the .NET Core command-line tools, the `dotnet pack` command had a bug that caused the `runtime.config.json` to not be packed with the tool."},{"content":"Lacking that file results in errors at runtime.","pos":[163,210]},{"content":"If you encounter this behavior, be sure to update to the latest tooling and try the <ph id=\"ph1\">`dotnet pack`</ph> again.","pos":[211,315],"source":" If you encounter this behavior, be sure to update to the latest tooling and try the `dotnet pack` again."}]}]},{"content":"Since tools are portable applications, the user consuming the tool must have the version of the .NET Core libraries that the tool was built against in order to run the tool.","pos":[5359,5532],"source":"Since tools are portable applications, the user consuming the tool must have the version of the .NET Core libraries\nthat the tool was built against in order to run the tool."},{"content":"Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.","pos":[5533,5672],"source":" Any other dependency that the tool uses and that is not\ncontained within the .NET Core libraries is restored and placed in the NuGet cache."},{"content":"The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.","pos":[5673,5801],"source":" The entire tool is, therefore, run\nusing the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache."},{"content":"These kinds of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.","pos":[5803,5932],"source":"These kinds of tools have a dependency graph that is completely separate from the dependency graph of the project that\nuses them."},{"content":"The restore process first restores the project's dependencies and then restores each of the tools and their dependencies.","pos":[5933,6054],"source":" The restore process first restores the project's dependencies and then restores each of the tools and\ntheir dependencies."},{"content":"You can find richer examples and different combinations of this in the <bpt id=\"p1\">[</bpt>.NET Core CLI repo<ept id=\"p1\">](https://github.com/dotnet/cli/tree/rel/1.0.1/TestAssets/TestProjects)</ept>.","pos":[6056,6218],"source":"You can find richer examples and different combinations of this in the [.NET Core CLI repo](https://github.com/dotnet/cli/tree/rel/1.0.1/TestAssets/TestProjects)."},{"content":"You can also see the <bpt id=\"p1\">[</bpt>implementation of tools used<ept id=\"p1\">](https://github.com/dotnet/cli/tree/rel/1.0.1/TestAssets/TestPackages)</ept> in the same repo.","pos":[6219,6358],"source":"\nYou can also see the [implementation of tools used](https://github.com/dotnet/cli/tree/rel/1.0.1/TestAssets/TestPackages) in the same repo."},{"pos":[6364,6378],"content":"Custom targets","linkify":"Custom targets","nodes":[{"content":"Custom targets","pos":[0,14]}]},{"content":"NuGet has the capability to <bpt id=\"p1\">[</bpt>package custom MSBuild targets and props files<ept id=\"p1\">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.","pos":[6379,6574],"source":"NuGet has the capability to [package custom MSBuild targets and props files](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)."},{"content":"With the move of the .NET Core CLI tools to use MSBuild, the same mechanism of extensibility now applies to .NET Core projects.","pos":[6575,6702]},{"content":"You would use this type of extensibility when you want to extend the build process, or when you want to access any of the artifacts in the build process, such as generated files, or you want to inspect the configuration under which the build is invoked, etc.","pos":[6703,6961]},{"content":"In the following example, you can see the target's project file using the <ph id=\"ph1\">`csproj`</ph> syntax.","pos":[6963,7053],"source":"In the following example, you can see the target's project file using the `csproj` syntax."},{"content":"This instructs the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet pack`</ph><ept id=\"p1\">](dotnet-pack.md)</ept> command what to package, placing the targets files as well as the assemblies into the <bpt id=\"p2\">*</bpt>build<ept id=\"p2\">*</ept> folder inside the package.","pos":[7054,7225],"source":" This instructs the [`dotnet pack`](dotnet-pack.md) command what to package, placing the targets files as well as the assemblies into the *build* folder inside the package."},{"content":"Notice the <ph id=\"ph1\">`&lt;ItemGroup&gt;`</ph> element that has the <ph id=\"ph2\">`Label`</ph> property set to <ph id=\"ph3\">`dotnet pack instructions`</ph>, and the Target defined beneath it.","pos":[7226,7358],"source":" Notice the `<ItemGroup>` element that has the `Label` property set to `dotnet pack instructions`, and the Target\ndefined beneath it."},{"content":"Consuming custom targets is done by providing a <ph id=\"ph1\">`&lt;PackageReference&gt;`</ph> that points to the package and its version inside the project that is being extended.","pos":[9320,9474],"source":"Consuming custom targets is done by providing a `<PackageReference>` that points to the package and its version inside the project that is being extended."},{"content":"Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.","pos":[9475,9586]},{"content":"Using the custom target depends solely on how you configure it.","pos":[9588,9651]},{"content":"Since it's an MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <ph id=\"ph1\">`dotnet msbuild /t:&lt;target-name&gt;`</ph> command.","pos":[9652,9825],"source":" Since it's an MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the `dotnet msbuild /t:<target-name>` command."},{"content":"However, if you want to provide a better user experience to your users, you can combine per-project tools and custom targets.","pos":[9827,9952]},{"content":"In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet msbuild`</ph><ept id=\"p1\">](dotnet-msbuild.md)</ept> invocation that would execute the target.","pos":[9953,10171],"source":" In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required [`dotnet msbuild`](dotnet-msbuild.md) invocation that would execute the target."},{"content":"You can see a sample of this kind of synergy on the <bpt id=\"p1\">[</bpt>MVP Summit 2016 Hackathon samples<ept id=\"p1\">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> repo in the <bpt id=\"p2\">[</bpt><ph id=\"ph1\">`dotnet-packer`</ph><ept id=\"p2\">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> project.","pos":[10172,10424],"source":" You can see a sample of this kind of synergy on the [MVP Summit 2016 Hackathon samples](https://github.com/dotnet/MVPSummitHackathon2016) repo in the [`dotnet-packer`](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer) project."},{"pos":[10430,10454],"content":"PATH-based extensibility","linkify":"PATH-based extensibility","nodes":[{"content":"PATH-based extensibility","pos":[0,24]}]},{"content":"PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.","pos":[10455,10595],"source":"PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more\nthan a single project."},{"content":"The main drawback of this extension mechanism is that it's tied to the machine where the tool exists.","pos":[10596,10697],"source":" The main drawback of this extension mechanism is that it's tied to the machine where the\ntool exists."},{"content":"If you need it on another machine, you would have to deploy it.","pos":[10698,10761]},{"content":"This pattern of CLI toolset extensibility is very simple.","pos":[10763,10820]},{"content":"As covered in the <bpt id=\"p1\">[</bpt>.NET Core CLI overview<ept id=\"p1\">](index.md)</ept>, <ph id=\"ph1\">`dotnet`</ph> driver can run any command that is named after the <ph id=\"ph2\">`dotnet-&lt;command&gt;`</ph> convention.","pos":[10821,10965],"source":" As covered in the [.NET Core CLI overview](index.md), `dotnet` driver\ncan run any command that is named after the `dotnet-<command>` convention."},{"content":"The default resolution logic first probes several locations and finally falls back to the system PATH.","pos":[10966,11068],"source":" The default resolution logic first\nprobes several locations and finally falls back to the system PATH."},{"content":"If the requested command exists in the system PATH and is a binary that can be invoked, <ph id=\"ph1\">`dotnet`</ph> driver will invoke it.","pos":[11069,11188],"source":" If the requested command exists in the system PATH\nand is a binary that can be invoked, `dotnet` driver will invoke it."},{"content":"The file must be executable.","pos":[11190,11218]},{"content":"On Unix systems, this means anything that has the execute bit set via <ph id=\"ph1\">`chmod +x`</ph>.","pos":[11219,11300],"source":" On Unix systems, this means anything that\nhas the execute bit set via `chmod +x`."},{"content":"On Windows, you can use <bpt id=\"p1\">*</bpt>cmd<ept id=\"p1\">*</ept> files.","pos":[11301,11337],"source":" On Windows, you can use *cmd* files."},{"content":"Let's take a look at the very simple implementation of a \"Hello World\" tool.","pos":[11339,11415]},{"content":"We will use both <ph id=\"ph1\">`bash`</ph> and <ph id=\"ph2\">`cmd`</ph> on Windows.","pos":[11416,11461],"source":" We will use both `bash` and `cmd` on Windows."},{"content":"The following command will simply echo \"Hello World\" to the console.","pos":[11462,11530],"source":"\nThe following command will simply echo \"Hello World\" to the console."},{"content":"On macOS, we can save this script as <ph id=\"ph1\">`dotnet-hello`</ph> and set its executable bit with <ph id=\"ph2\">`chmod +x dotnet-hello`</ph>.","pos":[11609,11717],"source":"On macOS, we can save this script as `dotnet-hello` and set its executable bit with `chmod +x dotnet-hello`."},{"content":"We can then create a symbolic link to it in <ph id=\"ph1\">`/usr/local/bin`</ph> using the command <ph id=\"ph2\">`ln -s dotnet-hello /usr/local/bin/`</ph>.","pos":[11718,11834],"source":" We can then\ncreate a symbolic link to it in `/usr/local/bin` using the command `ln -s dotnet-hello /usr/local/bin/`."},{"content":"This will make it possible to invoke the command using the <ph id=\"ph1\">`dotnet hello`</ph> syntax.","pos":[11835,11916],"source":" This will make\nit possible to invoke the command using the `dotnet hello` syntax."},{"content":"On Windows, we can save this script as <ph id=\"ph1\">`dotnet-hello.cmd`</ph> and put it in a location that is in a system path (or you can add it to a folder that is already in the path).","pos":[11918,12086],"source":"On Windows, we can save this script as `dotnet-hello.cmd` and put it in a location that is in a system path (or you can\nadd it to a folder that is already in the path)."},{"content":"After this, you can just use <ph id=\"ph1\">`dotnet hello`</ph> to run this example.","pos":[12087,12151],"source":" After this, you can just use `dotnet hello` to run this example."}]}