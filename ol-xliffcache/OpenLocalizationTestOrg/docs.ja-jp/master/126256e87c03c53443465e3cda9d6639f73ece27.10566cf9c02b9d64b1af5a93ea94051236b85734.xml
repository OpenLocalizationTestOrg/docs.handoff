{"content":"---\ntitle: \"Securing Exception Handling | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"code security, exception handling\"\n  - \"security [.NET Framework], exception handling\"\n  - \"secure coding, exception handling\"\n  - \"exception handling, security\"\nms.assetid: 1f3da743-9742-47ff-96e6-d0dd1e9e1c19\ncaps.latest.revision: 10\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# Securing Exception Handling\nIn Visual C++ and Visual Basic, a filter expression further up the stack runs before any **finally** statement. The **catch** block associated with that filter runs after the **finally** statement. For more information, see [Using User-Filtered Exceptions](../../../docs/standard/exceptions/using-user-filtered-exception-handlers.md). This section examines the security implications of this order. Consider the following pseudocode example that illustrates the order in which filter statements and **finally** statements run.  \n  \n```cpp  \nvoid Main()   \n{  \n    try   \n    {  \n        Sub();  \n    }   \n    except (Filter())   \n    {  \n        Console.WriteLine(\"catch\");  \n    }  \n}  \nbool Filter () {  \n    Console.WriteLine(\"filter\");  \n    return true;  \n}  \nvoid Sub()   \n{  \n    try   \n    {  \n        Console.WriteLine(\"throw\");  \n        throw new Exception();  \n    }   \n    finally   \n    {  \n        Console.WriteLine(\"finally\");  \n    }  \n}                        \n```  \n  \n This code prints the following.  \n  \n```  \nThrow  \nFilter  \nFinally  \nCatch  \n```  \n  \n The filter runs before the **finally** statement, so security issues can be introduced by anything that makes a state change where execution of other code could take advantage. For example:  \n  \n```cpp  \ntry   \n{  \n    Alter_Security_State();  \n    // This means changing anything (state variables,  \n    // switching unmanaged context, impersonation, and   \n    // so on) that could be exploited if malicious   \n    // code ran before state is restored.  \n    Do_some_work();  \n}   \nfinally   \n{  \n    Restore_Security_State();  \n    // This simply restores the state change above.  \n}  \n```  \n  \n This pseudocode allows a filter higher up the stack to run arbitrary code. Other examples of operations that would have a similar effect are temporary impersonation of another identity, setting an internal flag that bypasses some security check, or changing the culture associated with the thread. The recommended solution is to introduce an exception handler to isolate the code's changes to thread state from callers' filter blocks. However, it is important that the exception handler be properly introduced or this problem will not be fixed. The following example switches the UI culture, but any kind of thread state change could be similarly exposed.  \n  \n```cpp  \nYourObject.YourMethod()  \n{  \n   CultureInfo saveCulture = Thread.CurrentThread.CurrentUICulture;  \n   try {  \n      Thread.CurrentThread.CurrentUICulture = new CultureInfo(\"de-DE\");  \n      // Do something that throws an exception.  \n}  \n   finally {  \n      Thread.CurrentThread.CurrentUICulture = saveCulture;  \n   }  \n}  \n  \n```  \n  \n```vb  \nPublic Class UserCode  \n   Public Shared Sub Main()  \n      Try  \n         Dim obj As YourObject = new YourObject  \n         obj.YourMethod()  \n      Catch e As Exception When FilterFunc  \n         Console.WriteLine(\"An error occurred: '{0}'\", e)  \n         Console.WriteLine(\"Current Culture: {0}\",   \nThread.CurrentThread.CurrentUICulture)  \n      End Try  \n   End Sub  \n  \n   Public Function FilterFunc As Boolean  \n      Console.WriteLine(\"Current Culture: {0}\", Thread.CurrentThread.CurrentUICulture)  \n      Return True  \n   End Sub  \n  \nEnd Class  \n```  \n  \n The correct fix in this case is to wrap the existing **try**/**finally** block in a **try**/**catch** block. Simply introducing a **catch-throw** clause into the existing **try**/**finally** block does not fix the problem, as shown in the following example.  \n  \n```cpp  \nYourObject.YourMethod()  \n{  \n    CultureInfo saveCulture = Thread.CurrentThread.CurrentUICulture;  \n  \n    try   \n    {  \n        Thread.CurrentThread.CurrentUICulture = new CultureInfo(\"de-DE\");  \n        // Do something that throws an exception.  \n    }  \n    catch { throw; }  \n    finally   \n    {  \n        Thread.CurrentThread.CurrentUICulture = saveCulture;  \n    }  \n}  \n```  \n  \n This does not fix the problem because the **finally** statement has not run before the `FilterFunc` gets control.  \n  \n The following example fixes the problem by ensuring that the **finally** clause has executed before offering an exception up the callers' exception filter blocks.  \n  \n```cpp  \nYourObject.YourMethod()  \n{  \n    CultureInfo saveCulture = Thread.CurrentThread.CurrentUICulture;  \n    try    \n    {  \n        try   \n        {  \n            Thread.CurrentThread.CurrentUICulture = new CultureInfo(\"de-DE\");  \n            // Do something that throws an exception.  \n        }  \n        finally   \n        {  \n            Thread.CurrentThread.CurrentUICulture = saveCulture;  \n        }  \n    }  \n    catch { throw; }  \n}  \n```  \n  \n## See Also  \n [Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)","nodes":[{"pos":[12,56],"content":"Securing Exception Handling | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Securing Exception Handling | Microsoft Docs","pos":[0,44]}]},{"pos":[603,630],"content":"Securing Exception Handling","linkify":"Securing Exception Handling","nodes":[{"content":"Securing Exception Handling","pos":[0,27]}]},{"content":"In Visual C++ and Visual Basic, a filter expression further up the stack runs before any <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> statement.","pos":[631,742],"source":"In Visual C++ and Visual Basic, a filter expression further up the stack runs before any **finally** statement."},{"content":"The <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block associated with that filter runs after the <bpt id=\"p2\">**</bpt>finally<ept id=\"p2\">**</ept> statement.","pos":[743,828],"source":" The **catch** block associated with that filter runs after the **finally** statement."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using User-Filtered Exceptions<ept id=\"p1\">](../../../docs/standard/exceptions/using-user-filtered-exception-handlers.md)</ept>.","pos":[829,965],"source":" For more information, see [Using User-Filtered Exceptions](../../../docs/standard/exceptions/using-user-filtered-exception-handlers.md)."},{"content":"This section examines the security implications of this order.","pos":[966,1028]},{"content":"Consider the following pseudocode example that illustrates the order in which filter statements and <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> statements run.","pos":[1029,1156],"source":" Consider the following pseudocode example that illustrates the order in which filter statements and **finally** statements run."},{"content":"This code prints the following.","pos":[1619,1650]},{"content":"The filter runs before the <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> statement, so security issues can be introduced by anything that makes a state change where execution of other code could take advantage.","pos":[1707,1883],"source":"The filter runs before the **finally** statement, so security issues can be introduced by anything that makes a state change where execution of other code could take advantage."},{"content":"For example:","pos":[1884,1896]},{"content":"This pseudocode allows a filter higher up the stack to run arbitrary code.","pos":[2306,2380]},{"content":"Other examples of operations that would have a similar effect are temporary impersonation of another identity, setting an internal flag that bypasses some security check, or changing the culture associated with the thread.","pos":[2381,2603]},{"content":"The recommended solution is to introduce an exception handler to isolate the code's changes to thread state from callers' filter blocks.","pos":[2604,2740]},{"content":"However, it is important that the exception handler be properly introduced or this problem will not be fixed.","pos":[2741,2850]},{"content":"The following example switches the UI culture, but any kind of thread state change could be similarly exposed.","pos":[2851,2961]},{"content":"The correct fix in this case is to wrap the existing <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>finally<ept id=\"p2\">**</ept> block in a <bpt id=\"p3\">**</bpt>try<ept id=\"p3\">**</ept><ph id=\"ph2\">/</ph><bpt id=\"p4\">**</bpt>catch<ept id=\"p4\">**</ept> block.","pos":[3888,3996],"source":"The correct fix in this case is to wrap the existing **try**/**finally** block in a **try**/**catch** block."},{"content":"Simply introducing a <bpt id=\"p1\">**</bpt>catch-throw<ept id=\"p1\">**</ept> clause into the existing <bpt id=\"p2\">**</bpt>try<ept id=\"p2\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p3\">**</bpt>finally<ept id=\"p3\">**</ept> block does not fix the problem, as shown in the following example.","pos":[3997,4145],"source":" Simply introducing a **catch-throw** clause into the existing **try**/**finally** block does not fix the problem, as shown in the following example."},{"pos":[4550,4663],"content":"This does not fix the problem because the <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> statement has not run before the <ph id=\"ph1\">`FilterFunc`</ph> gets control.","source":"This does not fix the problem because the **finally** statement has not run before the `FilterFunc` gets control."},{"pos":[4670,4832],"content":"The following example fixes the problem by ensuring that the <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> clause has executed before offering an exception up the callers' exception filter blocks.","source":"The following example fixes the problem by ensuring that the **finally** clause has executed before offering an exception up the callers' exception filter blocks."},{"pos":[5300,5308],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[5312,5399],"content":"<bpt id=\"p1\">[</bpt>Secure Coding Guidelines<ept id=\"p1\">](../../../docs/standard/security/secure-coding-guidelines.md)</ept>","source":"[Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)"}]}