{"content":"---\ntitle: \"Refactoring Into Pure Functions (Visual Basic)\"\nms.date: 07/20/2015\nms.assetid: 99e7d27b-a3ff-4577-bdb2-5a8278d6d7af\n---\n\n# Refactoring Into Pure Functions (Visual Basic)\n\nAn important aspect of pure functional transformations is learning how to refactor code using pure functions.\n\nAs noted previously in this section, a pure function has two useful characteristics:\n\n- It has no side effects. The function does not change any variables or the data of any type outside of the function.\n\n- It is consistent. Given the same set of input data, it will always return the same output value.\n\n One way of transitioning to functional programming is to refactor existing code to eliminate unnecessary side effects and external dependencies. In this way, you can create pure function versions of existing code.\n\nThis topic discusses what a pure function is and what it is not. The [Tutorial: Manipulating Content in a WordprocessingML Document (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md) tutorial shows how to manipulate a WordprocessingML document, and includes two examples of how to refactor using a pure function.\n\n## Eliminating Side Effects and External Dependencies\n\nThe following examples contrast two non-pure functions and a pure function.\n\n### Non-Pure Function that Changes a Class Member\n\nIn the following code, the `HyphenatedConcat` function is not a pure function, because it modifies the `aMember` data member in the class:\n\n```vb\nModule Module1\n    Dim aMember As String = \"StringOne\"\n\n    Public Sub HyphenatedConcat(ByVal appendStr As String)\n        aMember = aMember & \"-\" & appendStr\n    End Sub\n\n    Sub Main()\n        HyphenatedConcat(\"StringTwo\")\n        Console.WriteLine(aMember)\n    End Sub\nEnd Module\n```\n\nThis code produces the following output:\n\n```\nStringOne-StringTwo\n```\n\nNote that it is irrelevant whether the data being modified has `public` or `private` access, or is a  `shared` member or an instance member. A pure function does not change any data outside of the function.\n\n### Non-Pure Function that Changes an Argument\n\nFurthermore, the following version of this same function is not pure because it modifies the contents of its parameter, `sb`.\n\n```vb\nModule Module1\n    Public Sub HyphenatedConcat(ByVal sb As StringBuilder, ByVal appendStr As String)\n        sb.Append(\"-\" & appendStr)\n    End Sub\n\n    Sub Main()\n        Dim sb1 As StringBuilder = New StringBuilder(\"StringOne\")\n        HyphenatedConcat(sb1, \"StringTwo\")\n        Console.WriteLine(sb1)\n    End Sub\nEnd Module\n```\n\nThis version of the program produces the same output as the first version, because the `HyphenatedConcat` function has changed the value (state) of its first parameter by invoking the <xref:System.Text.StringBuilder.Append%2A> member function. Note that this alteration occurs despite that fact that `HyphenatedConcat` uses call-by-value parameter passing.\n\n> [!IMPORTANT]\n> For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed. This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object). Call-by-reference is not necessarily required for a function to modify a parameter.\n\n### Pure Function\n\nThis next version of the program hows how to implement the `HyphenatedConcat` function as a pure function.\n\n```vb\nModule Module1\n    Public Function HyphenatedConcat(ByVal s As String, ByVal appendStr As String) As String\n        Return (s & \"-\" & appendStr)\n    End Function\n\n    Sub Main()\n        Dim s1 As String = \"StringOne\"\n        Dim s2 As String = HyphenatedConcat(s1, \"StringTwo\")\n        Console.WriteLine(s2)\n    End Sub\nEnd Module\n```\n\nAgain, this version produces the same line of output: `StringOne-StringTwo`. Note that to retain the concatenated value, it is stored in the intermediate variable `s2`.\n\nOne approach that can be very useful is to write functions that are locally impure (that is, they declare and modify local variables) but are globally pure. Such functions have many of the desirable composability characteristics, but avoid some of the more convoluted functional programming idioms, such as having to use recursion when a simple loop would accomplish the same thing.\n\n## Standard Query Operators\n\nAn important characteristic of the standard query operators is that they are implemented as pure functions.\n\nFor more information, see [Standard Query Operators Overview (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md).\n\n## See also\n\n- [Introduction to Pure Functional Transformations (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)\n- [Functional Programming vs. Imperative Programming (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/functional-programming-vs-imperative-programming.md)\n","nodes":[{"pos":[4,128],"embed":true,"restype":"x-metadata","content":"title: \"Refactoring Into Pure Functions (Visual Basic)\"\nms.date: 07/20/2015\nms.assetid: 99e7d27b-a3ff-4577-bdb2-5a8278d6d7af","nodes":[{"content":"Refactoring Into Pure Functions (Visual Basic)","nodes":[{"pos":[0,46],"content":"Refactoring Into Pure Functions (Visual Basic)","nodes":[{"content":"Refactoring Into Pure Functions (Visual Basic)","pos":[0,46]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[136,182],"content":"Refactoring Into Pure Functions (Visual Basic)","linkify":"Refactoring Into Pure Functions (Visual Basic)","nodes":[{"content":"Refactoring Into Pure Functions (Visual Basic)","pos":[0,46]}]},{"content":"An important aspect of pure functional transformations is learning how to refactor code using pure functions.","pos":[184,293]},{"content":"As noted previously in this section, a pure function has two useful characteristics:","pos":[295,379]},{"content":"It has no side effects.","pos":[383,406]},{"content":"The function does not change any variables or the data of any type outside of the function.","pos":[407,498]},{"content":"It is consistent.","pos":[502,519]},{"content":"Given the same set of input data, it will always return the same output value.","pos":[520,598]},{"content":"One way of transitioning to functional programming is to refactor existing code to eliminate unnecessary side effects and external dependencies.","pos":[601,745]},{"content":"In this way, you can create pure function versions of existing code.","pos":[746,814]},{"content":"This topic discusses what a pure function is and what it is not.","pos":[816,880]},{"content":"The <bpt id=\"p1\">[</bpt>Tutorial: Manipulating Content in a WordprocessingML Document (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)</ept> tutorial shows how to manipulate a WordprocessingML document, and includes two examples of how to refactor using a pure function.","pos":[881,1215],"source":" The [Tutorial: Manipulating Content in a WordprocessingML Document (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md) tutorial shows how to manipulate a WordprocessingML document, and includes two examples of how to refactor using a pure function."},{"pos":[1220,1270],"content":"Eliminating Side Effects and External Dependencies","linkify":"Eliminating Side Effects and External Dependencies","nodes":[{"content":"Eliminating Side Effects and External Dependencies","pos":[0,50]}]},{"content":"The following examples contrast two non-pure functions and a pure function.","pos":[1272,1347]},{"pos":[1353,1398],"content":"Non-Pure Function that Changes a Class Member","linkify":"Non-Pure Function that Changes a Class Member","nodes":[{"content":"Non-Pure Function that Changes a Class Member","pos":[0,45]}]},{"pos":[1400,1538],"content":"In the following code, the <ph id=\"ph1\">`HyphenatedConcat`</ph> function is not a pure function, because it modifies the <ph id=\"ph2\">`aMember`</ph> data member in the class:","source":"In the following code, the `HyphenatedConcat` function is not a pure function, because it modifies the `aMember` data member in the class:"},{"content":"This code produces the following output:","pos":[1834,1874]},{"content":"Note that it is irrelevant whether the data being modified has <ph id=\"ph1\">`public`</ph> or <ph id=\"ph2\">`private`</ph> access, or is a  <ph id=\"ph3\">`shared`</ph> member or an instance member.","pos":[1905,2045],"source":"Note that it is irrelevant whether the data being modified has `public` or `private` access, or is a  `shared` member or an instance member."},{"content":"A pure function does not change any data outside of the function.","pos":[2046,2111]},{"pos":[2117,2159],"content":"Non-Pure Function that Changes an Argument","linkify":"Non-Pure Function that Changes an Argument","nodes":[{"content":"Non-Pure Function that Changes an Argument","pos":[0,42]}]},{"pos":[2161,2286],"content":"Furthermore, the following version of this same function is not pure because it modifies the contents of its parameter, <ph id=\"ph1\">`sb`</ph>.","source":"Furthermore, the following version of this same function is not pure because it modifies the contents of its parameter, `sb`."},{"content":"This version of the program produces the same output as the first version, because the <ph id=\"ph1\">`HyphenatedConcat`</ph> function has changed the value (state) of its first parameter by invoking the <ph id=\"ph2\">&lt;xref:System.Text.StringBuilder.Append%2A&gt;</ph> member function.","pos":[2626,2869],"source":"This version of the program produces the same output as the first version, because the `HyphenatedConcat` function has changed the value (state) of its first parameter by invoking the <xref:System.Text.StringBuilder.Append%2A> member function."},{"content":"Note that this alteration occurs despite that fact that <ph id=\"ph1\">`HyphenatedConcat`</ph> uses call-by-value parameter passing.","pos":[2870,2982],"source":" Note that this alteration occurs despite that fact that `HyphenatedConcat` uses call-by-value parameter passing."},{"pos":[2986,3348],"content":"[!IMPORTANT]\nFor reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed. This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object). Call-by-reference is not necessarily required for a function to modify a parameter.","leadings":["","> "],"nodes":[{"content":"For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed. This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object). Call-by-reference is not necessarily required for a function to modify a parameter.","pos":[13,360],"nodes":[{"content":"For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed.","pos":[0,119]},{"content":"This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object).","pos":[120,263]},{"content":"Call-by-reference is not necessarily required for a function to modify a parameter.","pos":[264,347]}]}]},{"pos":[3354,3367],"content":"Pure Function","linkify":"Pure Function","nodes":[{"content":"Pure Function","pos":[0,13]}]},{"pos":[3369,3475],"content":"This next version of the program hows how to implement the <ph id=\"ph1\">`HyphenatedConcat`</ph> function as a pure function.","source":"This next version of the program hows how to implement the `HyphenatedConcat` function as a pure function."},{"content":"Again, this version produces the same line of output: <ph id=\"ph1\">`StringOne-StringTwo`</ph>.","pos":[3819,3895],"source":"Again, this version produces the same line of output: `StringOne-StringTwo`."},{"content":"Note that to retain the concatenated value, it is stored in the intermediate variable <ph id=\"ph1\">`s2`</ph>.","pos":[3896,3987],"source":" Note that to retain the concatenated value, it is stored in the intermediate variable `s2`."},{"content":"One approach that can be very useful is to write functions that are locally impure (that is, they declare and modify local variables) but are globally pure.","pos":[3989,4145]},{"content":"Such functions have many of the desirable composability characteristics, but avoid some of the more convoluted functional programming idioms, such as having to use recursion when a simple loop would accomplish the same thing.","pos":[4146,4371]},{"pos":[4376,4400],"content":"Standard Query Operators","linkify":"Standard Query Operators","nodes":[{"content":"Standard Query Operators","pos":[0,24]}]},{"content":"An important characteristic of the standard query operators is that they are implemented as pure functions.","pos":[4402,4509]},{"pos":[4511,4683],"content":"For more information, see <bpt id=\"p1\">[</bpt>Standard Query Operators Overview (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>.","source":"For more information, see [Standard Query Operators Overview (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)."},{"pos":[4688,4696],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4700,4873],"content":"<bpt id=\"p1\">[</bpt>Introduction to Pure Functional Transformations (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)</ept>","source":"[Introduction to Pure Functional Transformations (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)"},{"pos":[4876,5052],"content":"<bpt id=\"p1\">[</bpt>Functional Programming vs. Imperative Programming (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/functional-programming-vs-imperative-programming.md)</ept>","source":"[Functional Programming vs. Imperative Programming (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/functional-programming-vs-imperative-programming.md)"}]}