{"content":"---\ntitle: \"Numeric Data Types (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"integral types [Visual Basic], Visual Basic\"\n  - \"Short data type [Visual Basic], numeric data types\"\n  - \"Double data type [Visual Basic], numeric data types\"\n  - \"Long data type [Visual Basic], Visual Basic numeric data types\"\n  - \"numbers [Visual Basic], whole\"\n  - \"fractions\"\n  - \"numbers\"\n  - \"whole numbers\"\n  - \"integer numbers\"\n  - \"numbers [Visual Basic], integer\"\n  - \"fractional data types [Visual Basic]\"\n  - \"mantissas, of fractional numbers\"\n  - \"mantissas\"\n  - \"data types [Visual Basic], numeric\"\n  - \"Integer data type [Visual Basic], numeric data types\"\n  - \"exponent, of fractional numbers\"\n  - \"integers [Visual Basic]\"\n  - \"numeric data types [Visual Basic], Visual Basic\"\n  - \"Single data type [Visual Basic], numeric types\"\n  - \"Decimal data type [Visual Basic], numeric data types\"\nms.assetid: a27bd4d0-7e14-43eb-9cc4-b42eaab323c9\n---\n# Numeric Data Types (Visual Basic)\nVisual Basic supplies several *numeric data types* for handling numbers in various representations. *Integral* types represent only whole numbers (positive, negative, and zero), and *nonintegral* types represent numbers with both integer and fractional parts.  \n  \n For a table showing a side-by-side comparison of the Visual Basic data types, see [Data Types](../../../../visual-basic/language-reference/data-types/index.md).  \n  \n## Integral Numeric Types  \n *Integral data types* are those that represent only numbers without fractional parts.  \n  \n The *signed* integral data types are [SByte Data Type](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md) (8-bit), [Short Data Type](../../../../visual-basic/language-reference/data-types/short-data-type.md) (16-bit), [Integer Data Type](../../../../visual-basic/language-reference/data-types/integer-data-type.md) (32-bit), and [Long Data Type](../../../../visual-basic/language-reference/data-types/long-data-type.md) (64-bit). If a variable always stores integers rather than fractional numbers, declare it as one of these types.  \n  \n The *unsigned* integral types are [Byte Data Type](../../../../visual-basic/language-reference/data-types/byte-data-type.md) (8-bit), [UShort Data Type](../../../../visual-basic/language-reference/data-types/ushort-data-type.md) (16-bit), [UInteger Data Type](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md) (32-bit), and [ULong Data Type](../../../../visual-basic/language-reference/data-types/ulong-data-type.md) (64-bit). If a variable contains binary data, or data of unknown nature, declare it as one of these types.  \n  \n### Performance  \n Arithmetic operations are faster with integral types than with other data types. They are fastest with the `Integer` and `UInteger` types in Visual Basic.  \n  \n### Large Integers  \n If you need to hold an integer larger than the `Integer` data type can hold, you can use the `Long` data type instead. `Long` variables can hold numbers from -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807. Operations with `Long` are slightly slower than with `Integer`.  \n  \n If you need even larger values, you can use the [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md). You can hold numbers from -79,228,162,514,264,337,593,543,950,335 through 79,228,162,514,264,337,593,543,950,335 in a `Decimal` variable if you do not use any decimal places. However, operations with `Decimal` numbers are considerably slower than with any other numeric data type.  \n  \n### Small Integers  \n If you do not need the full range of the `Integer` data type, you can use the `Short` data type, which can hold integers from -32,768 through 32,767. For the smallest integer range, the `SByte` data type holds integers from -128 through 127. If you have a very large number of variables that hold small integers, the common language runtime can sometimes store your `Short` and `SByte` variables more efficiently and save memory consumption. However, operations with `Short` and `SByte` are somewhat slower than with `Integer`.  \n  \n### Unsigned Integers  \n If you know that your variable never needs to hold a negative number, you can use the *unsigned types*`Byte`, `UShort`, `UInteger`, and `ULong`. Each of these data types can hold a positive integer twice as large as its corresponding signed type (`SByte`, `Short`, `Integer`, and `Long`). In terms of performance, each unsigned type is exactly as efficient as its corresponding signed type. In particular, `UInteger` shares with `Integer` the distinction of being the most efficient of all the elementary numeric data types.  \n  \n## Nonintegral Numeric Types  \n *Nonintegral data types* are those that represent numbers with both integer and fractional parts.  \n  \n The nonintegral numeric data types are `Decimal` (128-bit fixed point), [Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) (32-bit floating point), and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md) (64-bit floating point). They are all signed types. If a variable can contain a fraction, declare it as one of these types.  \n  \n `Decimal` is not a floating-point data type. `Decimal` numbers have a binary integer value and an integer scaling factor that specifies what portion of the value is a decimal fraction.  \n  \n You can use `Decimal` variables for money values. The advantage is the precision of the values. The `Double` data type is faster and requires less memory, but it is subject to rounding errors. The `Decimal` data type retains complete accuracy to 28 decimal places.  \n  \n Floating-point (`Single` and `Double`) numbers have larger ranges than `Decimal` numbers but can be subject to rounding errors. Floating-point types support fewer significant digits than `Decimal` but can represent values of greater magnitude.  \n  \n Nonintegral number values can be expressed as mmmEeee, in which mmm is the *mantissa* (the significant digits) and eee is the *exponent* (a power of 10). The highest positive values of the nonintegral types are 7.9228162514264337593543950335E+28 for `Decimal`, 3.4028235E+38 for `Single`, and 1.79769313486231570E+308 for `Double`.  \n  \n### Performance  \n `Double` is the most efficient of the fractional data types, because the processors on current platforms perform floating-point operations in double precision. However, operations with `Double` are not as fast as with the integral types such as `Integer`.  \n  \n### Small Magnitudes  \n For numbers with the smallest possible magnitude (closest to 0), `Double` variables can hold numbers as small as -4.94065645841246544E-324 for negative values and 4.94065645841246544E-324 for positive values.  \n  \n### Small Fractional Numbers  \n If you do not need the full range of the `Double` data type, you can use the `Single` data type, which can hold floating-point numbers from -3.4028235E+38 through 3.4028235E+38. The smallest magnitudes for `Single` variables are -1.401298E-45 for negative values and 1.401298E-45 for positive values. If you have a very large number of variables that hold small floating-point numbers, the common language runtime can sometimes store your `Single` variables more efficiently and save memory consumption.  \n  \n## See also\n\n- [Elementary Data Types](../../../../visual-basic/programming-guide/language-features/data-types/elementary-data-types.md)\n- [Character Data Types](../../../../visual-basic/programming-guide/language-features/data-types/character-data-types.md)\n- [Miscellaneous Data Types](../../../../visual-basic/programming-guide/language-features/data-types/miscellaneous-data-types.md)\n- [Troubleshooting Data Types](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)\n- [How to: Call a Windows Function that Takes Unsigned Types](../../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)\n","nodes":[{"pos":[4,949],"embed":true,"restype":"x-metadata","content":"title: \"Numeric Data Types (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"integral types [Visual Basic], Visual Basic\"\n  - \"Short data type [Visual Basic], numeric data types\"\n  - \"Double data type [Visual Basic], numeric data types\"\n  - \"Long data type [Visual Basic], Visual Basic numeric data types\"\n  - \"numbers [Visual Basic], whole\"\n  - \"fractions\"\n  - \"numbers\"\n  - \"whole numbers\"\n  - \"integer numbers\"\n  - \"numbers [Visual Basic], integer\"\n  - \"fractional data types [Visual Basic]\"\n  - \"mantissas, of fractional numbers\"\n  - \"mantissas\"\n  - \"data types [Visual Basic], numeric\"\n  - \"Integer data type [Visual Basic], numeric data types\"\n  - \"exponent, of fractional numbers\"\n  - \"integers [Visual Basic]\"\n  - \"numeric data types [Visual Basic], Visual Basic\"\n  - \"Single data type [Visual Basic], numeric types\"\n  - \"Decimal data type [Visual Basic], numeric data types\"\nms.assetid: a27bd4d0-7e14-43eb-9cc4-b42eaab323c9","nodes":[{"content":"Numeric Data Types (Visual Basic)","nodes":[{"pos":[0,33],"content":"Numeric Data Types (Visual Basic)","nodes":[{"content":"Numeric Data Types (Visual Basic)","pos":[0,33]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[956,989],"content":"Numeric Data Types (Visual Basic)","linkify":"Numeric Data Types (Visual Basic)","nodes":[{"content":"Numeric Data Types (Visual Basic)","pos":[0,33]}]},{"content":"Visual Basic supplies several <bpt id=\"p1\">*</bpt>numeric data types<ept id=\"p1\">*</ept> for handling numbers in various representations.","pos":[990,1089],"source":"Visual Basic supplies several *numeric data types* for handling numbers in various representations."},{"content":"<bpt id=\"p1\">*</bpt>Integral<ept id=\"p1\">*</ept> types represent only whole numbers (positive, negative, and zero), and <bpt id=\"p2\">*</bpt>nonintegral<ept id=\"p2\">*</ept> types represent numbers with both integer and fractional parts.","pos":[1090,1249],"source":"*Integral* types represent only whole numbers (positive, negative, and zero), and *nonintegral* types represent numbers with both integer and fractional parts."},{"pos":[1256,1416],"content":"For a table showing a side-by-side comparison of the Visual Basic data types, see <bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/index.md)</ept>.","source":"For a table showing a side-by-side comparison of the Visual Basic data types, see [Data Types](../../../../visual-basic/language-reference/data-types/index.md)."},{"pos":[1425,1447],"content":"Integral Numeric Types","linkify":"Integral Numeric Types","nodes":[{"content":"Integral Numeric Types","pos":[0,22]}]},{"pos":[1451,1536],"content":"<bpt id=\"p1\">*</bpt>Integral data types<ept id=\"p1\">*</ept> are those that represent only numbers without fractional parts.","source":"*Integral data types* are those that represent only numbers without fractional parts."},{"content":"The <bpt id=\"p1\">*</bpt>signed<ept id=\"p1\">*</ept> integral data types are <bpt id=\"p2\">[</bpt>SByte Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md)</ept> (8-bit), <bpt id=\"p3\">[</bpt>Short Data Type<ept id=\"p3\">](../../../../visual-basic/language-reference/data-types/short-data-type.md)</ept> (16-bit), <bpt id=\"p4\">[</bpt>Integer Data Type<ept id=\"p4\">](../../../../visual-basic/language-reference/data-types/integer-data-type.md)</ept> (32-bit), and <bpt id=\"p5\">[</bpt>Long Data Type<ept id=\"p5\">](../../../../visual-basic/language-reference/data-types/long-data-type.md)</ept> (64-bit).","pos":[1543,1996],"source":"The *signed* integral data types are [SByte Data Type](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md) (8-bit), [Short Data Type](../../../../visual-basic/language-reference/data-types/short-data-type.md) (16-bit), [Integer Data Type](../../../../visual-basic/language-reference/data-types/integer-data-type.md) (32-bit), and [Long Data Type](../../../../visual-basic/language-reference/data-types/long-data-type.md) (64-bit)."},{"content":"If a variable always stores integers rather than fractional numbers, declare it as one of these types.","pos":[1997,2099]},{"content":"The <bpt id=\"p1\">*</bpt>unsigned<ept id=\"p1\">*</ept> integral types are <bpt id=\"p2\">[</bpt>Byte Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/byte-data-type.md)</ept> (8-bit), <bpt id=\"p3\">[</bpt>UShort Data Type<ept id=\"p3\">](../../../../visual-basic/language-reference/data-types/ushort-data-type.md)</ept> (16-bit), <bpt id=\"p4\">[</bpt>UInteger Data Type<ept id=\"p4\">](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md)</ept> (32-bit), and <bpt id=\"p5\">[</bpt>ULong Data Type<ept id=\"p5\">](../../../../visual-basic/language-reference/data-types/ulong-data-type.md)</ept> (64-bit).","pos":[2106,2560],"source":"The *unsigned* integral types are [Byte Data Type](../../../../visual-basic/language-reference/data-types/byte-data-type.md) (8-bit), [UShort Data Type](../../../../visual-basic/language-reference/data-types/ushort-data-type.md) (16-bit), [UInteger Data Type](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md) (32-bit), and [ULong Data Type](../../../../visual-basic/language-reference/data-types/ulong-data-type.md) (64-bit)."},{"content":"If a variable contains binary data, or data of unknown nature, declare it as one of these types.","pos":[2561,2657]},{"pos":[2667,2678],"content":"Performance","linkify":"Performance","nodes":[{"content":"Performance","pos":[0,11]}]},{"content":"Arithmetic operations are faster with integral types than with other data types.","pos":[2682,2762]},{"content":"They are fastest with the <ph id=\"ph1\">`Integer`</ph> and <ph id=\"ph2\">`UInteger`</ph> types in Visual Basic.","pos":[2763,2836],"source":" They are fastest with the `Integer` and `UInteger` types in Visual Basic."},{"pos":[2846,2860],"content":"Large Integers","linkify":"Large Integers","nodes":[{"content":"Large Integers","pos":[0,14]}]},{"content":"If you need to hold an integer larger than the <ph id=\"ph1\">`Integer`</ph> data type can hold, you can use the <ph id=\"ph2\">`Long`</ph> data type instead.","pos":[2864,2982],"source":"If you need to hold an integer larger than the `Integer` data type can hold, you can use the `Long` data type instead."},{"content":"<ph id=\"ph1\">`Long`</ph> variables can hold numbers from -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807.","pos":[2983,3083],"source":"`Long` variables can hold numbers from -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807."},{"content":"Operations with <ph id=\"ph1\">`Long`</ph> are slightly slower than with <ph id=\"ph2\">`Integer`</ph>.","pos":[3084,3147],"source":" Operations with `Long` are slightly slower than with `Integer`."},{"content":"If you need even larger values, you can use the <bpt id=\"p1\">[</bpt>Decimal Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)</ept>.","pos":[3154,3299],"source":"If you need even larger values, you can use the [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)."},{"content":"You can hold numbers from -79,228,162,514,264,337,593,543,950,335 through 79,228,162,514,264,337,593,543,950,335 in a <ph id=\"ph1\">`Decimal`</ph> variable if you do not use any decimal places.","pos":[3300,3474],"source":" You can hold numbers from -79,228,162,514,264,337,593,543,950,335 through 79,228,162,514,264,337,593,543,950,335 in a `Decimal` variable if you do not use any decimal places."},{"content":"However, operations with <ph id=\"ph1\">`Decimal`</ph> numbers are considerably slower than with any other numeric data type.","pos":[3475,3580],"source":" However, operations with `Decimal` numbers are considerably slower than with any other numeric data type."},{"pos":[3590,3604],"content":"Small Integers","linkify":"Small Integers","nodes":[{"content":"Small Integers","pos":[0,14]}]},{"content":"If you do not need the full range of the <ph id=\"ph1\">`Integer`</ph> data type, you can use the <ph id=\"ph2\">`Short`</ph> data type, which can hold integers from -32,768 through 32,767.","pos":[3608,3757],"source":"If you do not need the full range of the `Integer` data type, you can use the `Short` data type, which can hold integers from -32,768 through 32,767."},{"content":"For the smallest integer range, the <ph id=\"ph1\">`SByte`</ph> data type holds integers from -128 through 127.","pos":[3758,3849],"source":" For the smallest integer range, the `SByte` data type holds integers from -128 through 127."},{"content":"If you have a very large number of variables that hold small integers, the common language runtime can sometimes store your <ph id=\"ph1\">`Short`</ph> and <ph id=\"ph2\">`SByte`</ph> variables more efficiently and save memory consumption.","pos":[3850,4049],"source":" If you have a very large number of variables that hold small integers, the common language runtime can sometimes store your `Short` and `SByte` variables more efficiently and save memory consumption."},{"content":"However, operations with <ph id=\"ph1\">`Short`</ph> and <ph id=\"ph2\">`SByte`</ph> are somewhat slower than with <ph id=\"ph3\">`Integer`</ph>.","pos":[4050,4135],"source":" However, operations with `Short` and `SByte` are somewhat slower than with `Integer`."},{"pos":[4145,4162],"content":"Unsigned Integers","linkify":"Unsigned Integers","nodes":[{"content":"Unsigned Integers","pos":[0,17]}]},{"content":"If you know that your variable never needs to hold a negative number, you can use the <bpt id=\"p1\">*</bpt>unsigned types<ept id=\"p1\">*</ept><ph id=\"ph1\">`Byte`</ph>, <ph id=\"ph2\">`UShort`</ph>, <ph id=\"ph3\">`UInteger`</ph>, and <ph id=\"ph4\">`ULong`</ph>.","pos":[4166,4310],"source":"If you know that your variable never needs to hold a negative number, you can use the *unsigned types*`Byte`, `UShort`, `UInteger`, and `ULong`."},{"content":"Each of these data types can hold a positive integer twice as large as its corresponding signed type (<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Short`</ph>, <ph id=\"ph3\">`Integer`</ph>, and <ph id=\"ph4\">`Long`</ph>).","pos":[4311,4454],"source":" Each of these data types can hold a positive integer twice as large as its corresponding signed type (`SByte`, `Short`, `Integer`, and `Long`)."},{"content":"In terms of performance, each unsigned type is exactly as efficient as its corresponding signed type.","pos":[4455,4556]},{"content":"In particular, <ph id=\"ph1\">`UInteger`</ph> shares with <ph id=\"ph2\">`Integer`</ph> the distinction of being the most efficient of all the elementary numeric data types.","pos":[4557,4690],"source":" In particular, `UInteger` shares with `Integer` the distinction of being the most efficient of all the elementary numeric data types."},{"pos":[4699,4724],"content":"Nonintegral Numeric Types","linkify":"Nonintegral Numeric Types","nodes":[{"content":"Nonintegral Numeric Types","pos":[0,25]}]},{"pos":[4728,4825],"content":"<bpt id=\"p1\">*</bpt>Nonintegral data types<ept id=\"p1\">*</ept> are those that represent numbers with both integer and fractional parts.","source":"*Nonintegral data types* are those that represent numbers with both integer and fractional parts."},{"content":"The nonintegral numeric data types are <ph id=\"ph1\">`Decimal`</ph> (128-bit fixed point), <bpt id=\"p1\">[</bpt>Single Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/single-data-type.md)</ept> (32-bit floating point), and <bpt id=\"p2\">[</bpt>Double Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/double-data-type.md)</ept> (64-bit floating point).","pos":[4832,5147],"source":"The nonintegral numeric data types are `Decimal` (128-bit fixed point), [Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) (32-bit floating point), and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md) (64-bit floating point)."},{"content":"They are all signed types.","pos":[5148,5174]},{"content":"If a variable can contain a fraction, declare it as one of these types.","pos":[5175,5246]},{"content":"<ph id=\"ph1\">`Decimal`</ph> is not a floating-point data type.","pos":[5253,5297],"source":"`Decimal` is not a floating-point data type."},{"content":"<ph id=\"ph1\">`Decimal`</ph> numbers have a binary integer value and an integer scaling factor that specifies what portion of the value is a decimal fraction.","pos":[5298,5437],"source":"`Decimal` numbers have a binary integer value and an integer scaling factor that specifies what portion of the value is a decimal fraction."},{"content":"You can use <ph id=\"ph1\">`Decimal`</ph> variables for money values.","pos":[5444,5493],"source":"You can use `Decimal` variables for money values."},{"content":"The advantage is the precision of the values.","pos":[5494,5539]},{"content":"The <ph id=\"ph1\">`Double`</ph> data type is faster and requires less memory, but it is subject to rounding errors.","pos":[5540,5636],"source":" The `Double` data type is faster and requires less memory, but it is subject to rounding errors."},{"content":"The <ph id=\"ph1\">`Decimal`</ph> data type retains complete accuracy to 28 decimal places.","pos":[5637,5708],"source":" The `Decimal` data type retains complete accuracy to 28 decimal places."},{"content":"Floating-point (<ph id=\"ph1\">`Single`</ph> and <ph id=\"ph2\">`Double`</ph>) numbers have larger ranges than <ph id=\"ph3\">`Decimal`</ph> numbers but can be subject to rounding errors.","pos":[5715,5842],"source":"Floating-point (`Single` and `Double`) numbers have larger ranges than `Decimal` numbers but can be subject to rounding errors."},{"content":"Floating-point types support fewer significant digits than <ph id=\"ph1\">`Decimal`</ph> but can represent values of greater magnitude.","pos":[5843,5958],"source":" Floating-point types support fewer significant digits than `Decimal` but can represent values of greater magnitude."},{"content":"Nonintegral number values can be expressed as mmmEeee, in which mmm is the <bpt id=\"p1\">*</bpt>mantissa<ept id=\"p1\">*</ept> (the significant digits) and eee is the <bpt id=\"p2\">*</bpt>exponent<ept id=\"p2\">*</ept> (a power of 10).","pos":[5965,6118],"source":"Nonintegral number values can be expressed as mmmEeee, in which mmm is the *mantissa* (the significant digits) and eee is the *exponent* (a power of 10)."},{"content":"The highest positive values of the nonintegral types are 7.9228162514264337593543950335E+28 for <ph id=\"ph1\">`Decimal`</ph>, 3.4028235E+38 for <ph id=\"ph2\">`Single`</ph>, and 1.79769313486231570E+308 for <ph id=\"ph3\">`Double`</ph>.","pos":[6119,6296],"source":" The highest positive values of the nonintegral types are 7.9228162514264337593543950335E+28 for `Decimal`, 3.4028235E+38 for `Single`, and 1.79769313486231570E+308 for `Double`."},{"pos":[6306,6317],"content":"Performance","linkify":"Performance","nodes":[{"content":"Performance","pos":[0,11]}]},{"content":"<ph id=\"ph1\">`Double`</ph> is the most efficient of the fractional data types, because the processors on current platforms perform floating-point operations in double precision.","pos":[6321,6480],"source":"`Double` is the most efficient of the fractional data types, because the processors on current platforms perform floating-point operations in double precision."},{"content":"However, operations with <ph id=\"ph1\">`Double`</ph> are not as fast as with the integral types such as <ph id=\"ph2\">`Integer`</ph>.","pos":[6481,6576],"source":" However, operations with `Double` are not as fast as with the integral types such as `Integer`."},{"pos":[6586,6602],"content":"Small Magnitudes","linkify":"Small Magnitudes","nodes":[{"content":"Small Magnitudes","pos":[0,16]}]},{"pos":[6606,6814],"content":"For numbers with the smallest possible magnitude (closest to 0), <ph id=\"ph1\">`Double`</ph> variables can hold numbers as small as -4.94065645841246544E-324 for negative values and 4.94065645841246544E-324 for positive values.","source":"For numbers with the smallest possible magnitude (closest to 0), `Double` variables can hold numbers as small as -4.94065645841246544E-324 for negative values and 4.94065645841246544E-324 for positive values."},{"pos":[6824,6848],"content":"Small Fractional Numbers","linkify":"Small Fractional Numbers","nodes":[{"content":"Small Fractional Numbers","pos":[0,24]}]},{"content":"If you do not need the full range of the <ph id=\"ph1\">`Double`</ph> data type, you can use the <ph id=\"ph2\">`Single`</ph> data type, which can hold floating-point numbers from -3.4028235E+38 through 3.4028235E+38.","pos":[6852,7029],"source":"If you do not need the full range of the `Double` data type, you can use the `Single` data type, which can hold floating-point numbers from -3.4028235E+38 through 3.4028235E+38."},{"content":"The smallest magnitudes for <ph id=\"ph1\">`Single`</ph> variables are -1.401298E-45 for negative values and 1.401298E-45 for positive values.","pos":[7030,7152],"source":" The smallest magnitudes for `Single` variables are -1.401298E-45 for negative values and 1.401298E-45 for positive values."},{"content":"If you have a very large number of variables that hold small floating-point numbers, the common language runtime can sometimes store your <ph id=\"ph1\">`Single`</ph> variables more efficiently and save memory consumption.","pos":[7153,7355],"source":" If you have a very large number of variables that hold small floating-point numbers, the common language runtime can sometimes store your `Single` variables more efficiently and save memory consumption."},{"pos":[7364,7372],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7376,7497],"content":"<bpt id=\"p1\">[</bpt>Elementary Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/elementary-data-types.md)</ept>","source":"[Elementary Data Types](../../../../visual-basic/programming-guide/language-features/data-types/elementary-data-types.md)"},{"pos":[7500,7619],"content":"<bpt id=\"p1\">[</bpt>Character Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/character-data-types.md)</ept>","source":"[Character Data Types](../../../../visual-basic/programming-guide/language-features/data-types/character-data-types.md)"},{"pos":[7622,7749],"content":"<bpt id=\"p1\">[</bpt>Miscellaneous Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/miscellaneous-data-types.md)</ept>","source":"[Miscellaneous Data Types](../../../../visual-basic/programming-guide/language-features/data-types/miscellaneous-data-types.md)"},{"pos":[7752,7883],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept>","source":"[Troubleshooting Data Types](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)"},{"pos":[7886,8061],"content":"<bpt id=\"p1\">[</bpt>How to: Call a Windows Function that Takes Unsigned Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)</ept>","source":"[How to: Call a Windows Function that Takes Unsigned Types](../../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)"}]}