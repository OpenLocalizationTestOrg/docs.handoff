{"content":"---\ntitle: \"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"inferring property names [Visual Basic]\"\n  - \"anonymous types [Visual Basic], inferring property names and types\"\n  - \"inferring property types [Visual Basic]\"\nms.assetid: 7c748b22-913f-4d9d-b747-6b7bf296a0bc\n---\n# How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)\nAnonymous types provide no mechanism for directly specifying the data types of properties. Types of all properties are inferred. In the following example, the types of `Name` and `Price` are inferred directly from the values that are used to initialize them.  \n  \n [!code-vb[VbVbalrAnonymousTypes#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#1)]  \n  \n Anonymous types can also infer property names and types from other sources. The sections that follow provide a list of the circumstances where inference is possible, and examples of situations where it is not.  \n  \n## Successful Inference  \n  \n#### Anonymous types can infer property names and types from the following sources:  \n  \n-   From variable names. Anonymous type `anonProduct` will have two properties, `productName` and `productPrice`. Their data types will be those of the original variables, `String` and `Double`, respectively.  \n  \n     [!code-vb[VbVbalrAnonymousTypes#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#11)]  \n  \n-   From property or field names of other objects. For example, consider a `car` object of a `CarClass` type that includes `Name` and `ID` properties. To create a new anonymous type instance, `car1`, with `Name` and `ID` properties that are initialized with the values from the `car` object, you can write the following:  \n  \n     [!code-vb[VbVbalrAnonymousTypes#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#34)]  \n  \n     The previous declaration is equivalent to the longer line of code that defines anonymous type `car2`.  \n  \n     [!code-vb[VbVbalrAnonymousTypes#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#35)]  \n  \n-   From XML member names.  \n  \n     [!code-vb[VbVbalrAnonymousTypes#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#12)]  \n  \n     The resulting type for `anon` would have one property, `Book`, of type <xref:System.Collections.IEnumerable>(Of XElement).  \n  \n-   From a function that has no parameters, such as `SomeFunction` in the following example.  \n  \n     `Dim sc As New SomeClass`  \n  \n     `Dim anon1 = New With {Key sc.SomeFunction()}`  \n  \n     The variable `anon2` in the following code is an anonymous type that has one property, a character named `First`. This code will display a letter \"E,\" the letter that is returned by function <xref:System.Linq.Enumerable.First%2A>.  \n  \n     [!code-vb[VbVbalrAnonymousTypes#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#13)]  \n  \n## Inference Failures  \n  \n#### Name inference will fail in many circumstances, including the following:  \n  \n-   The inference derives from the invocation of a method, a constructor, or a parameterized property that requires arguments. The previous declaration of `anon1` fails if `someFunction` has one or more arguments.  \n  \n     `' Not valid.`  \n  \n     `' Dim anon3 = New With {Key sc.someFunction(someArg)}`  \n  \n     Assignment to a new property name solves the problem.  \n  \n     `' Valid.`  \n  \n     `Dim anon4 = New With {Key .FunResult = sc.someFunction(someArg)}`  \n  \n-   The inference derives from a complex expression.  \n  \n    ```  \n    Dim aString As String = \"Act \"  \n    ' Not valid.  \n    ' Dim label = New With {Key aString & \"IV\"}  \n    ```  \n  \n     The error can be resolved by assigning the result of the expression to a property name.  \n  \n     [!code-vb[VbVbalrAnonymousTypes#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#14)]  \n  \n-   Inference for multiple properties produces two or more properties that have the same name. Referring back to declarations in earlier examples, you cannot list both `product.Name` and `car1.Name` as properties of the same anonymous type. This is because the inferred identifier for each of these would be `Name`.  \n  \n     `' Not valid.`  \n  \n     `' Dim anon5 = New With {Key product.Name, Key car1.Name}`  \n  \n     The problem can be solved by assigning the values to distinct property names.  \n  \n     [!code-vb[VbVbalrAnonymousTypes#36](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#36)]  \n  \n     Note that changes in case (changes between uppercase and lowercase letters) do not make two names distinct.  \n  \n     `Dim price = 0`  \n  \n     `' Not valid, because Price and price are the same name.`  \n  \n     `' Dim anon7 = New With {Key product.Price, Key price}`  \n  \n-   The initial type and value of one property depends on another property that is not yet established. For example, `.IDName = .LastName` is not valid in an anonymous type declaration unless `.LastName` is already initialized.  \n  \n     `' Not valid.`  \n  \n     `' Dim anon8 = New With {Key .IDName = .LastName, Key .LastName = \"Jones\"}`  \n  \n     In this example, you can fix the problem by reversing the order in which the properties are declared.  \n  \n     [!code-vb[VbVbalrAnonymousTypes#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#15)]  \n  \n-   A property name of the anonymous type is the same as the name of a member of <xref:System.Object>. For example, the following declaration fails because `Equals` is a method of <xref:System.Object>.  \n  \n     `' Not valid.`  \n  \n     `' Dim relationsLabels1 = New With {Key .Equals = \"equals\", Key .Greater = _`  \n  \n     `'                       \"greater than\", Key .Less = \"less than\"}`  \n  \n     You can fix the problem by changing the property name:  \n  \n     [!code-vb[VbVbalrAnonymousTypes#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#16)]  \n  \n## See also\n\n- [Object Initializers: Named and Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)\n- [Local Type Inference](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)\n- [Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)\n- [Key](../../../../visual-basic/language-reference/modifiers/key.md)\n","nodes":[{"pos":[4,353],"embed":true,"restype":"x-metadata","content":"title: \"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"inferring property names [Visual Basic]\"\n  - \"anonymous types [Visual Basic], inferring property names and types\"\n  - \"inferring property types [Visual Basic]\"\nms.assetid: 7c748b22-913f-4d9d-b747-6b7bf296a0bc","nodes":[{"content":"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)","nodes":[{"pos":[0,84],"content":"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)","nodes":[{"content":"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)","pos":[0,84]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[360,444],"content":"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)","linkify":"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)","nodes":[{"content":"How to: Infer Property Names and Types in Anonymous Type Declarations (Visual Basic)","pos":[0,84]}]},{"content":"Anonymous types provide no mechanism for directly specifying the data types of properties.","pos":[445,535]},{"content":"Types of all properties are inferred.","pos":[536,573]},{"content":"In the following example, the types of <ph id=\"ph1\">`Name`</ph> and <ph id=\"ph2\">`Price`</ph> are inferred directly from the values that are used to initialize them.","pos":[574,703],"source":" In the following example, the types of `Name` and `Price` are inferred directly from the values that are used to initialize them."},{"content":"Anonymous types can also infer property names and types from other sources.","pos":[842,917]},{"content":"The sections that follow provide a list of the circumstances where inference is possible, and examples of situations where it is not.","pos":[918,1051]},{"pos":[1060,1080],"content":"Successful Inference","linkify":"Successful Inference","nodes":[{"content":"Successful Inference","pos":[0,20]}]},{"pos":[1091,1169],"content":"Anonymous types can infer property names and types from the following sources:","linkify":"Anonymous types can infer property names and types from the following sources:","nodes":[{"content":"Anonymous types can infer property names and types from the following sources:","pos":[0,78]}]},{"content":"From variable names.","pos":[1179,1199]},{"content":"Anonymous type <ph id=\"ph1\">`anonProduct`</ph> will have two properties, <ph id=\"ph2\">`productName`</ph> and <ph id=\"ph3\">`productPrice`</ph>.","pos":[1200,1288],"source":" Anonymous type `anonProduct` will have two properties, `productName` and `productPrice`."},{"content":"Their data types will be those of the original variables, <ph id=\"ph1\">`String`</ph> and <ph id=\"ph2\">`Double`</ph>, respectively.","pos":[1289,1383],"source":" Their data types will be those of the original variables, `String` and `Double`, respectively."},{"content":"From property or field names of other objects.","pos":[1531,1577]},{"content":"For example, consider a <ph id=\"ph1\">`car`</ph> object of a <ph id=\"ph2\">`CarClass`</ph> type that includes <ph id=\"ph3\">`Name`</ph> and <ph id=\"ph4\">`ID`</ph> properties.","pos":[1578,1677],"source":" For example, consider a `car` object of a `CarClass` type that includes `Name` and `ID` properties."},{"content":"To create a new anonymous type instance, <ph id=\"ph1\">`car1`</ph>, with <ph id=\"ph2\">`Name`</ph> and <ph id=\"ph3\">`ID`</ph> properties that are initialized with the values from the <ph id=\"ph4\">`car`</ph> object, you can write the following:","pos":[1678,1847],"source":" To create a new anonymous type instance, `car1`, with `Name` and `ID` properties that are initialized with the values from the `car` object, you can write the following:"},{"pos":[1996,2097],"content":"The previous declaration is equivalent to the longer line of code that defines anonymous type <ph id=\"ph1\">`car2`</ph>.","source":"The previous declaration is equivalent to the longer line of code that defines anonymous type `car2`."},{"content":"From XML member names.","pos":[2245,2267]},{"pos":[2416,2538],"content":"The resulting type for <ph id=\"ph1\">`anon`</ph> would have one property, <ph id=\"ph2\">`Book`</ph>, of type <ph id=\"ph3\">&lt;xref:System.Collections.IEnumerable&gt;</ph>(Of XElement).","source":"The resulting type for `anon` would have one property, `Book`, of type <xref:System.Collections.IEnumerable>(Of XElement)."},{"pos":[2548,2636],"content":"From a function that has no parameters, such as <ph id=\"ph1\">`SomeFunction`</ph> in the following example.","source":"From a function that has no parameters, such as `SomeFunction` in the following example."},{"content":"The variable <ph id=\"ph1\">`anon2`</ph> in the following code is an anonymous type that has one property, a character named <ph id=\"ph2\">`First`</ph>.","pos":[2740,2853],"source":"The variable `anon2` in the following code is an anonymous type that has one property, a character named `First`."},{"content":"This code will display a letter \"E,\" the letter that is returned by function <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.First%2A&gt;</ph>.","pos":[2854,2970],"source":" This code will display a letter \"E,\" the letter that is returned by function <xref:System.Linq.Enumerable.First%2A>."},{"pos":[3117,3135],"content":"Inference Failures","linkify":"Inference Failures","nodes":[{"content":"Inference Failures","pos":[0,18]}]},{"pos":[3146,3218],"content":"Name inference will fail in many circumstances, including the following:","linkify":"Name inference will fail in many circumstances, including the following:","nodes":[{"content":"Name inference will fail in many circumstances, including the following:","pos":[0,72]}]},{"content":"The inference derives from the invocation of a method, a constructor, or a parameterized property that requires arguments.","pos":[3228,3350]},{"content":"The previous declaration of <ph id=\"ph1\">`anon1`</ph> fails if <ph id=\"ph2\">`someFunction`</ph> has one or more arguments.","pos":[3351,3437],"source":" The previous declaration of `anon1` fails if `someFunction` has one or more arguments."},{"content":"Assignment to a new property name solves the problem.","pos":[3539,3592]},{"content":"The inference derives from a complex expression.","pos":[3700,3748]},{"content":"The error can be resolved by assigning the result of the expression to a property name.","pos":[3888,3975]},{"content":"Inference for multiple properties produces two or more properties that have the same name.","pos":[4123,4213]},{"content":"Referring back to declarations in earlier examples, you cannot list both <ph id=\"ph1\">`product.Name`</ph> and <ph id=\"ph2\">`car1.Name`</ph> as properties of the same anonymous type.","pos":[4214,4359],"source":" Referring back to declarations in earlier examples, you cannot list both `product.Name` and `car1.Name` as properties of the same anonymous type."},{"content":"This is because the inferred identifier for each of these would be <ph id=\"ph1\">`Name`</ph>.","pos":[4360,4434],"source":" This is because the inferred identifier for each of these would be `Name`."},{"content":"The problem can be solved by assigning the values to distinct property names.","pos":[4539,4616]},{"content":"Note that changes in case (changes between uppercase and lowercase letters) do not make two names distinct.","pos":[4765,4872]},{"content":"The initial type and value of one property depends on another property that is not yet established.","pos":[5042,5141]},{"content":"For example, <ph id=\"ph1\">`.IDName = .LastName`</ph> is not valid in an anonymous type declaration unless <ph id=\"ph2\">`.LastName`</ph> is already initialized.","pos":[5142,5265],"source":" For example, `.IDName = .LastName` is not valid in an anonymous type declaration unless `.LastName` is already initialized."},{"content":"In this example, you can fix the problem by reversing the order in which the properties are declared.","pos":[5387,5488]},{"content":"A property name of the anonymous type is the same as the name of a member of <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>.","pos":[5636,5734],"source":"A property name of the anonymous type is the same as the name of a member of <xref:System.Object>."},{"content":"For example, the following declaration fails because <ph id=\"ph1\">`Equals`</ph> is a method of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[5735,5833],"source":" For example, the following declaration fails because `Equals` is a method of <xref:System.Object>."},{"content":"You can fix the problem by changing the property name:","pos":[6034,6088]},{"pos":[6235,6243],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6247,6426],"content":"<bpt id=\"p1\">[</bpt>Object Initializers: Named and Anonymous Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)</ept>","source":"[Object Initializers: Named and Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)"},{"pos":[6429,6547],"content":"<bpt id=\"p1\">[</bpt>Local Type Inference<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept>","source":"[Local Type Inference](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)"},{"pos":[6550,6668],"content":"<bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>","source":"[Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)"},{"pos":[6671,6738],"content":"<bpt id=\"p1\">[</bpt>Key<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/key.md)</ept>","source":"[Key](../../../../visual-basic/language-reference/modifiers/key.md)"}]}