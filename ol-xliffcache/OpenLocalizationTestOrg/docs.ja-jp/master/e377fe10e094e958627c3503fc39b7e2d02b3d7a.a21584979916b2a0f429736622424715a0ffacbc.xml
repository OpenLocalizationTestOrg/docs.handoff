{"content":"---\ntitle: Get started with syntax analysis (Roslyn APIs)\ndescription: An introduction to traversing, querying and walking syntax trees.\nms.date: 02/05/2018\nms.custom: mvc\n---\n# Get started with syntax analysis\n\nIn this tutorial, you'll explore the **Syntax API**. The Syntax API provides access to the data structures that describe a C# or Visual Basic program. These data structures have enough detail that they can fully represent any program of any size. These structures can describe complete programs that compile and run correctly. They can also describe incomplete programs, as you write them, in the editor.\n\nTo enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex. Let's start with what the data structure looks like for the typical \"Hello World\" program:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HelloWorld\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n        }\n    }\n}\n```\n\nLook at the text of the previous program. You recognize familiar elements. The entire text represents a single source file, or a **compilation unit**. The first three lines of that source file are **using directives**. The remaining source is contained in a **namespace declaration**. The namespace declaration contains a child **class declaration**. The class declaration contains one **method declaration**.\n\nThe Syntax API creates a tree structure with the root representing the compilation unit. Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program. The tree structure continues down to the lowest levels: the string \"Hello World!\" is a **string literal token** that is a descendent of an **argument**. The Syntax API provides access to the structure of the program. You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.\n\nThat brief description provides an overview of the kind of information accessible using the Syntax API. The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#. The full capabilities include information about how the code is formatted including line breaks, white space, and indenting. Using this information, you can fully represent the code as written and read by human programmers or the compiler. Using this structure enables you to interact with the source code on a deeply meaningful level. It's no longer text strings, but data that represents the structure of a C# program.\n\nTo get started, you'll need to install the **.NET Compiler Platform SDK**:\n\n[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]\n\n## Understanding syntax trees\n\nYou use the Syntax API for any analysis of the structure of C# code. The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees. It's how you search code for specific syntax elements or read the code for a program.\n\nA syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs. Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5. The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree. Writing a syntax tree to text reproduces the exact original text that was parsed. The syntax trees are also **immutable**; once created a syntax tree can never be changed. Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes. You can use APIs to create new trees that are the result of modifying an existing tree.\n\nThe four primary building blocks of syntax trees are:\n\n* The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree. <xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives. You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or VB.\n* The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.\n* The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.\n* And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.\n\nTrivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code. You can see this structure using the **Syntax Visualizer** window. In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**. For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:\n\n**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red\n![C# Code File](media/walkthrough-csharp-syntax-figure1.png)\n\nBy navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.\n\nWhile you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments. The two examples that follow show typical uses to browse the structure of code, or search for single statements.\n\n## Traversing trees\n\nYou can examine the nodes in a syntax tree in two ways. You can traverse the tree to examine each node, or you can query for specific elements or nodes.\n\n### Manual traversal\n\nYou can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).\n\n> [!NOTE]\n> The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program. Using these APIs often means casting properties or collection members to specific derived types. In the following examples, the assignment and the casts are separate statements, using explicitly typed variables. You can read the code to see the return types of the API and the runtime type of the objects returned. In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.\n\nCreate a new C# **Stand-Alone Code Analysis Tool** project:\n\n* In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.\n* Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.\n* Name your project \"**SyntaxTreeManualTraversal**\" and click OK.\n\nYou're going to analyze the basic \"Hello World!\" program shown earlier.\nAdd the text for the Hello World program as a constant in your `Program` class:\n\n[!code-csharp[Declare the program text](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 \"Declare a constant string for the program text to analyze\")]\n\nNext, add the following code to build the **syntax tree** for the code text in the `programText` constant.  Add the following line to your `Main` method:\n\n[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 \"Create the syntax tree\")]\n\nThose two lines create the tree and retrieve the root node of that tree. You can now examine the nodes in the tree. Add these lines to your `Main` method to display some of the properties of the root node in the tree:\n\n[!code-csharp[Examine the root node](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 \"Examine the root node\")]\n\nRun the application to see what your code has discovered about the root node in this tree.\n\nTypically, you'd traverse the tree to learn about the code. In this example, you're analyzing code you know to explore the APIs. Add the following code to examine the first member of the `root` node:\n\n[!code-csharp[Find the first member](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 \"Find the first member\")]\n\nThat member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>. It represents everything in the scope of the `namespace HelloWorld` declaration. Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:\n\n[!code-csharp[Find the class declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 \"Find the class declaration\")]\n\nRun the program to see what you've learned.\n\nNow that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration. This class only contains one member: the `Main` method. Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.\n\n[!code-csharp[Find the main declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 \"Find the main declaration\")]\n\nThe method declaration node contains all the syntactic information about the method. Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method. Add the following code:\n\n[!code-csharp[Examine the syntax of the main method](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 \"Display information about the main method\")]\n\nRun the program to see all the information you've discovered about this program:\n\n```text\nThe tree is a CompilationUnit node.\nThe tree has 1 elements in it.\nThe tree has 4 using statements. They are:\n        System\n        System.Collections\n        System.Linq\n        System.Text\nThe first member is a NamespaceDeclaration.\nThere are 1 members declared in this namespace.\nThe first member is a ClassDeclaration.\nThere are 1 members declared in the Program class.\nThe first member is a MethodDeclaration.\nThe return type of the Main method is void.\nThe method has 1 parameters.\nThe type of the args parameter is string[].\nThe body text of the Main method follows:\n        {\n            Console.WriteLine(\"Hello, World!\");\n        }\n```\n\n### Query methods\n\nIn addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>. These methods should be immediately familiar to anyone familiar with XPath. You can use these methods with LINQ to quickly find things in a tree. The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.\n\nYou can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree. Add the following code to the bottom of your `Main` method:\n\n[!code-csharp[Query the tree for the arguments to Main](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 \"Query the tree for the arguments to Main\")]\n\nThe first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.\n\nRun the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.\n\nThe sample uses `WriteLine` statements to display information about the syntax trees as they are traversed. You can also learn much more by running the finished program under the debugger. You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.\n\n## Syntax walkers\n\nOften you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file. By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand. <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.\n\nThis example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree. It collects `using` directives it finds that aren't importing a `System` namespace.\n\nCreate a new C# **Stand-Alone Code Analysis Tool** project; name it \"**SyntaxWalker**.\"\n\nYou can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart). The sample on GitHub contains both projects described in this tutorial.\n\nAs in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:\n\n[!code-csharp[Define the code text to analyzer](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 \"Define the program text to analyze\")]\n\nThis source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces. This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code. It would be cumbersome to visit every node in the root syntax tree to find using declarations. Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive. Your visitor does not do any work on any other node types. This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace. You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.\n\nNow that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:\n\n[!code-csharp[Create the Syntax tree and access the root](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 \"Create the Syntax tree and access the root node.\")]\n\nNext, create a new class. In Visual Studio, choose **Project** > **Add New Item**. In the **Add New Item** dialog type *UsingCollector.cs* as the filename.\n\nYou implement the `using` visitor functionality in the `UsingCollector` class. Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.\n\n[!code-csharp[Declare the base class for the using collector](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 \"Declare the base class for the UsingCollector\")]\n\nYou need storage to hold the namespace nodes that you're collecting.  Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:\n\n[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 \"Declare storage for the using syntax nodes\")]\n\nThe base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree. The derived class overrides the methods called for the specific nodes you're interested in. In this case, you're interested in any `using` directive. That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method. The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object. That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type. The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported. It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>. Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:\n\n[!code-csharp[Examine using nodes for the System namespace](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 \"Examine all using nodes for the System namespace.\")]\n\nAs with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method. You can see when it's called, and what arguments are passed to it each time.\n\nFinally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements. Then, add a `foreach` loop to display all the `using` statements your collector found:\n\n[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 \"Create the UsingCollector and visit the root node.\")]\n\nCompile and run the program. You should see the following output:\n\n```console\n        VisitUsingDirective called with System.\n        VisitUsingDirective called with System.Collections.Generic.\n        VisitUsingDirective called with System.Linq.\n        VisitUsingDirective called with System.Text.\n        VisitUsingDirective called with Microsoft.CodeAnalysis.\n                Success. Adding Microsoft.CodeAnalysis.\n        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.\n                Success. Adding Microsoft.CodeAnalysis.CSharp.\n        VisitUsingDirective called with Microsoft.\n                Success. Adding Microsoft.\n        VisitUsingDirective called with System.ComponentModel.\n        VisitUsingDirective called with Microsoft.Win32.\n                Success. Adding Microsoft.Win32.\n        VisitUsingDirective called with System.Runtime.InteropServices.\n        VisitUsingDirective called with System.CodeDom.\n        VisitUsingDirective called with Microsoft.CSharp.\n                Success. Adding Microsoft.CSharp.\nMicrosoft.CodeAnalysis\nMicrosoft.CodeAnalysis.CSharp\nMicrosoft\nMicrosoft.Win32\nMicrosoft.CSharp\nPress any key to continue . . .\n```\n\nCongratulations! You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.\n","nodes":[{"pos":[4,171],"embed":true,"restype":"x-metadata","content":"title: Get started with syntax analysis (Roslyn APIs)\ndescription: An introduction to traversing, querying and walking syntax trees.\nms.date: 02/05/2018\nms.custom: mvc","nodes":[{"content":"Get started with syntax analysis (Roslyn APIs)","nodes":[{"pos":[0,46],"content":"Get started with syntax analysis (Roslyn APIs)","nodes":[{"content":"Get started with syntax analysis (Roslyn APIs)","pos":[0,46]}]}],"path":["title"],"nosxs":false},{"content":"An introduction to traversing, querying and walking syntax trees.","nodes":[{"pos":[0,65],"content":"An introduction to traversing, querying and walking syntax trees.","nodes":[{"content":"An introduction to traversing, querying and walking syntax trees.","pos":[0,65]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[178,210],"content":"Get started with syntax analysis","linkify":"Get started with syntax analysis","nodes":[{"content":"Get started with syntax analysis","pos":[0,32]}]},{"content":"In this tutorial, you'll explore the <bpt id=\"p1\">**</bpt>Syntax API<ept id=\"p1\">**</ept>.","pos":[212,264],"source":"In this tutorial, you'll explore the **Syntax API**."},{"content":"The Syntax API provides access to the data structures that describe a C# or Visual Basic program.","pos":[265,362]},{"content":"These data structures have enough detail that they can fully represent any program of any size.","pos":[363,458]},{"content":"These structures can describe complete programs that compile and run correctly.","pos":[459,538]},{"content":"They can also describe incomplete programs, as you write them, in the editor.","pos":[539,616]},{"content":"To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.","pos":[618,731]},{"content":"Let's start with what the data structure looks like for the typical \"Hello World\" program:","pos":[732,822]},{"content":"Look at the text of the previous program.","pos":[1069,1110]},{"content":"You recognize familiar elements.","pos":[1111,1143]},{"content":"The entire text represents a single source file, or a <bpt id=\"p1\">**</bpt>compilation unit<ept id=\"p1\">**</ept>.","pos":[1144,1219],"source":" The entire text represents a single source file, or a **compilation unit**."},{"content":"The first three lines of that source file are <bpt id=\"p1\">**</bpt>using directives<ept id=\"p1\">**</ept>.","pos":[1220,1287],"source":" The first three lines of that source file are **using directives**."},{"content":"The remaining source is contained in a <bpt id=\"p1\">**</bpt>namespace declaration<ept id=\"p1\">**</ept>.","pos":[1288,1353],"source":" The remaining source is contained in a **namespace declaration**."},{"content":"The namespace declaration contains a child <bpt id=\"p1\">**</bpt>class declaration<ept id=\"p1\">**</ept>.","pos":[1354,1419],"source":" The namespace declaration contains a child **class declaration**."},{"content":"The class declaration contains one <bpt id=\"p1\">**</bpt>method declaration<ept id=\"p1\">**</ept>.","pos":[1420,1478],"source":" The class declaration contains one **method declaration**."},{"content":"The Syntax API creates a tree structure with the root representing the compilation unit.","pos":[1480,1568]},{"content":"Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.","pos":[1569,1683]},{"content":"The tree structure continues down to the lowest levels: the string \"Hello World!\"","pos":[1684,1765]},{"content":"is a <bpt id=\"p1\">**</bpt>string literal token<ept id=\"p1\">**</ept> that is a descendent of an <bpt id=\"p2\">**</bpt>argument<ept id=\"p2\">**</ept>.","pos":[1766,1836],"source":" is a **string literal token** that is a descendent of an **argument**."},{"content":"The Syntax API provides access to the structure of the program.","pos":[1837,1900]},{"content":"You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.","pos":[1901,2041]},{"content":"That brief description provides an overview of the kind of information accessible using the Syntax API.","pos":[2043,2146]},{"content":"The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.","pos":[2147,2257]},{"content":"The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.","pos":[2258,2382]},{"content":"Using this information, you can fully represent the code as written and read by human programmers or the compiler.","pos":[2383,2497]},{"content":"Using this structure enables you to interact with the source code on a deeply meaningful level.","pos":[2498,2593]},{"content":"It's no longer text strings, but data that represents the structure of a C# program.","pos":[2594,2678]},{"pos":[2680,2754],"content":"To get started, you'll need to install the <bpt id=\"p1\">**</bpt>.NET Compiler Platform SDK<ept id=\"p1\">**</ept>:","source":"To get started, you'll need to install the **.NET Compiler Platform SDK**:"},{"pos":[2824,2850],"content":"Understanding syntax trees","linkify":"Understanding syntax trees","nodes":[{"content":"Understanding syntax trees","pos":[0,26]}]},{"content":"You use the Syntax API for any analysis of the structure of C# code.","pos":[2852,2920]},{"content":"The <bpt id=\"p1\">**</bpt>Syntax API<ept id=\"p1\">**</ept> exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.","pos":[2921,3037],"source":" The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees."},{"content":"It's how you search code for specific syntax elements or read the code for a program.","pos":[3038,3123]},{"content":"A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.","pos":[3125,3244]},{"content":"Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.","pos":[3245,3347]},{"content":"The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.","pos":[3348,3470]},{"content":"Writing a syntax tree to text reproduces the exact original text that was parsed.","pos":[3471,3552]},{"content":"The syntax trees are also <bpt id=\"p1\">**</bpt>immutable<ept id=\"p1\">**</ept>; once created a syntax tree can never be changed.","pos":[3553,3642],"source":" The syntax trees are also **immutable**; once created a syntax tree can never be changed."},{"content":"Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.","pos":[3643,3785]},{"content":"You can use APIs to create new trees that are the result of modifying an existing tree.","pos":[3786,3873]},{"content":"The four primary building blocks of syntax trees are:","pos":[3875,3928]},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType&gt;</ph> class, an instance of which represents an entire parse tree.","pos":[3932,4066],"source":"The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree."},{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxTree&gt;</ph> is an abstract class that has language-specific derivatives.","pos":[4067,4168],"source":"<xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives."},{"content":"You use the parse methods of the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType&gt;</ph> (or <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType&gt;</ph>) class to parse text in C# or VB.","pos":[4169,4415],"source":" You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or VB."},{"pos":[4418,4608],"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType&gt;</ph> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.","source":"The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions."},{"pos":[4611,4774],"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType&gt;</ph> structure, which represents an individual keyword, identifier, operator, or punctuation.","source":"The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation."},{"pos":[4777,5019],"content":"And lastly the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType&gt;</ph> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.","source":"And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments."},{"content":"Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.","pos":[5021,5169]},{"content":"You can see this structure using the <bpt id=\"p1\">**</bpt>Syntax Visualizer<ept id=\"p1\">**</ept> window.","pos":[5170,5236],"source":" You can see this structure using the **Syntax Visualizer** window."},{"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>View<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Other Windows<ept id=\"p2\">**</ept><ph id=\"ph2\"> &gt; </ph><bpt id=\"p3\">**</bpt>Syntax Visualizer<ept id=\"p3\">**</ept>.","pos":[5237,5315],"source":" In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**."},{"content":"For example, the preceding C# source file examined using the <bpt id=\"p1\">**</bpt>Syntax Visualizer<ept id=\"p1\">**</ept> looks like the following figure:","pos":[5316,5431],"source":" For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:"},{"pos":[5433,5563],"content":"<bpt id=\"p1\">**</bpt>SyntaxNode<ept id=\"p1\">**</ept>: Blue | <bpt id=\"p2\">**</bpt>SyntaxToken<ept id=\"p2\">**</ept>: Green | <bpt id=\"p3\">**</bpt>SyntaxTrivia<ept id=\"p3\">**</ept>: Red <ph id=\"ph1\">![</ph>C# Code File<ph id=\"ph2\">](media/walkthrough-csharp-syntax-figure1.png)</ph>","source":"**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red\n![C# Code File](media/walkthrough-csharp-syntax-figure1.png)"},{"content":"By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.","pos":[5565,5684]},{"content":"While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.","pos":[5686,5861]},{"content":"The two examples that follow show typical uses to browse the structure of code, or search for single statements.","pos":[5862,5974]},{"pos":[5979,5995],"content":"Traversing trees","linkify":"Traversing trees","nodes":[{"content":"Traversing trees","pos":[0,16]}]},{"content":"You can examine the nodes in a syntax tree in two ways.","pos":[5997,6052]},{"content":"You can traverse the tree to examine each node, or you can query for specific elements or nodes.","pos":[6053,6149]},{"pos":[6155,6171],"content":"Manual traversal","linkify":"Manual traversal","nodes":[{"content":"Manual traversal","pos":[0,16]}]},{"pos":[6173,6328],"content":"You can see the finished code for this sample in <bpt id=\"p1\">[</bpt>our GitHub repository<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart)</ept>.","source":"You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart)."},{"pos":[6332,6924],"content":"[!NOTE]\nThe Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program. Using these APIs often means casting properties or collection members to specific derived types. In the following examples, the assignment and the casts are separate statements, using explicitly typed variables. You can read the code to see the return types of the API and the runtime type of the objects returned. In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.","leadings":["","> "],"nodes":[{"content":"The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program. Using these APIs often means casting properties or collection members to specific derived types. In the following examples, the assignment and the casts are separate statements, using explicitly typed variables. You can read the code to see the return types of the API and the runtime type of the objects returned. In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.","pos":[8,590],"nodes":[{"content":"The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.","pos":[0,133]},{"content":"Using these APIs often means casting properties or collection members to specific derived types.","pos":[134,230]},{"content":"In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.","pos":[231,345]},{"content":"You can read the code to see the return types of the API and the runtime type of the objects returned.","pos":[346,448]},{"content":"In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.","pos":[449,582]}]}]},{"pos":[6926,6985],"content":"Create a new C# <bpt id=\"p1\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p1\">**</ept> project:","source":"Create a new C# **Stand-Alone Code Analysis Tool** project:"},{"pos":[6989,7081],"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>File<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept><ph id=\"ph2\"> &gt; </ph><bpt id=\"p3\">**</bpt>Project<ept id=\"p3\">**</ept> to display the New Project dialog.","source":"In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog."},{"pos":[7084,7167],"content":"Under <bpt id=\"p1\">**</bpt>Visual C#<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Extensibility<ept id=\"p2\">**</ept>, choose <bpt id=\"p3\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p3\">**</ept>.","source":"Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**."},{"pos":[7170,7233],"content":"Name your project \"<bpt id=\"p1\">**</bpt>SyntaxTreeManualTraversal<ept id=\"p1\">**</ept>\" and click OK.","source":"Name your project \"**SyntaxTreeManualTraversal**\" and click OK."},{"content":"You're going to analyze the basic \"Hello World!\"","pos":[7235,7283]},{"content":"program shown earlier.","pos":[7284,7306]},{"content":"Add the text for the Hello World program as a constant in your <ph id=\"ph1\">`Program`</ph> class:","pos":[7307,7386],"source":"\nAdd the text for the Hello World program as a constant in your `Program` class:"},{"content":"Next, add the following code to build the <bpt id=\"p1\">**</bpt>syntax tree<ept id=\"p1\">**</ept> for the code text in the <ph id=\"ph1\">`programText`</ph> constant.","pos":[7575,7681],"source":"Next, add the following code to build the **syntax tree** for the code text in the `programText` constant."},{"content":"Add the following line to your <ph id=\"ph1\">`Main`</ph> method:","pos":[7683,7728],"source":"  Add the following line to your `Main` method:"},{"content":"Those two lines create the tree and retrieve the root node of that tree.","pos":[7873,7945]},{"content":"You can now examine the nodes in the tree.","pos":[7946,7988]},{"content":"Add these lines to your <ph id=\"ph1\">`Main`</ph> method to display some of the properties of the root node in the tree:","pos":[7989,8090],"source":" Add these lines to your `Main` method to display some of the properties of the root node in the tree:"},{"content":"Run the application to see what your code has discovered about the root node in this tree.","pos":[8240,8330]},{"content":"Typically, you'd traverse the tree to learn about the code.","pos":[8332,8391]},{"content":"In this example, you're analyzing code you know to explore the APIs.","pos":[8392,8460]},{"content":"Add the following code to examine the first member of the <ph id=\"ph1\">`root`</ph> node:","pos":[8461,8531],"source":" Add the following code to examine the first member of the `root` node:"},{"content":"That member is a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType&gt;</ph>.","pos":[8681,8798],"source":"That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>."},{"content":"It represents everything in the scope of the <ph id=\"ph1\">`namespace HelloWorld`</ph> declaration.","pos":[8799,8879],"source":" It represents everything in the scope of the `namespace HelloWorld` declaration."},{"content":"Add the following code to examine what nodes are declared inside the <ph id=\"ph1\">`HelloWorld`</ph> namespace:","pos":[8880,8972],"source":" Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:"},{"content":"Run the program to see what you've learned.","pos":[9132,9175]},{"content":"Now that you know the declaration is a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType&gt;</ph>, declare a new variable of that type to examine the class declaration.","pos":[9177,9382],"source":"Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration."},{"content":"This class only contains one member: the <ph id=\"ph1\">`Main`</ph> method.","pos":[9383,9438],"source":" This class only contains one member: the `Main` method."},{"content":"Add the following code to find the <ph id=\"ph1\">`Main`</ph> method, and cast it to a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType&gt;</ph>.","pos":[9439,9603],"source":" Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>."},{"content":"The method declaration node contains all the syntactic information about the method.","pos":[9761,9845]},{"content":"Let's display the return type of the <ph id=\"ph1\">`Main`</ph> method, the number and types of the arguments, and the body text of the method.","pos":[9846,9969],"source":" Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method."},{"content":"Add the following code:","pos":[9970,9993]},{"content":"Run the program to see all the information you've discovered about this program:","pos":[10179,10259]},{"pos":[10921,10934],"content":"Query methods","linkify":"Query methods","nodes":[{"content":"Query methods","pos":[0,13]}]},{"content":"In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType&gt;</ph>.","pos":[10936,11111],"source":"In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>."},{"content":"These methods should be immediately familiar to anyone familiar with XPath.","pos":[11112,11187]},{"content":"You can use these methods with LINQ to quickly find things in a tree.","pos":[11188,11257]},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode&gt;</ph> has query methods such as <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A&gt;</ph>.","pos":[11258,11510],"source":" The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>."},{"content":"You can use these query methods to find the argument to the <ph id=\"ph1\">`Main`</ph> method as an alternative to navigating the tree.","pos":[11512,11627],"source":"You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree."},{"content":"Add the following code to the bottom of your <ph id=\"ph1\">`Main`</ph> method:","pos":[11628,11687],"source":" Add the following code to the bottom of your `Main` method:"},{"pos":[11875,12049],"content":"The first statement uses a LINQ expression and the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A&gt;</ph> method to locate the same parameter as in the previous example.","source":"The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example."},{"content":"Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.","pos":[12051,12166]},{"content":"The sample uses <ph id=\"ph1\">`WriteLine`</ph> statements to display information about the syntax trees as they are traversed.","pos":[12168,12275],"source":"The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed."},{"content":"You can also learn much more by running the finished program under the debugger.","pos":[12276,12356]},{"content":"You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.","pos":[12357,12477]},{"pos":[12482,12496],"content":"Syntax walkers","linkify":"Syntax walkers","nodes":[{"content":"Syntax walkers","pos":[0,14]}]},{"content":"Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.","pos":[12498,12618]},{"content":"By extending the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType&gt;</ph> class and overriding the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)&gt;</ph> method, you process every property declaration in a syntax tree without knowing its structure beforehand.","pos":[12619,12997],"source":" By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand."},{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker&gt;</ph> is a specific kind of <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&gt;</ph> that recursively visits a node and each of its children.","pos":[12998,13189],"source":"<xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children."},{"content":"This example implements a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker&gt;</ph> that examines a syntax tree.","pos":[13191,13301],"source":"This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree."},{"content":"It collects <ph id=\"ph1\">`using`</ph> directives it finds that aren't importing a <ph id=\"ph2\">`System`</ph> namespace.","pos":[13302,13385],"source":" It collects `using` directives it finds that aren't importing a `System` namespace."},{"pos":[13387,13474],"content":"Create a new C# <bpt id=\"p1\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p1\">**</ept> project; name it \"<bpt id=\"p2\">**</bpt>SyntaxWalker<ept id=\"p2\">**</ept>.\"","source":"Create a new C# **Stand-Alone Code Analysis Tool** project; name it \"**SyntaxWalker**.\""},{"content":"You can see the finished code for this sample in <bpt id=\"p1\">[</bpt>our GitHub repository<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart)</ept>.","pos":[13476,13631],"source":"You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart)."},{"content":"The sample on GitHub contains both projects described in this tutorial.","pos":[13632,13703]},{"content":"As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:","pos":[13705,13821]},{"content":"This source text contains <ph id=\"ph1\">`using`</ph> directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.","pos":[13992,14157],"source":"This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces."},{"content":"This example highlights a core scenario for using the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker&gt;</ph> class to query code.","pos":[14158,14288],"source":" This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code."},{"content":"It would be cumbersome to visit every node in the root syntax tree to find using declarations.","pos":[14289,14383]},{"content":"Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.","pos":[14384,14521]},{"content":"Your visitor does not do any work on any other node types.","pos":[14522,14580]},{"content":"This single method examines each of the <ph id=\"ph1\">`using`</ph> statements and builds a collection of the namespaces that aren't in the <ph id=\"ph2\">`System`</ph> namespace.","pos":[14581,14720],"source":" This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace."},{"content":"You build a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker&gt;</ph> that examines all the <ph id=\"ph2\">`using`</ph> statements, but only the <ph id=\"ph3\">`using`</ph> statements.","pos":[14721,14863],"source":" You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements."},{"pos":[14865,14971],"content":"Now that you've defined the program text, you need to create a <ph id=\"ph1\">`SyntaxTree`</ph> and get the root of that tree:","source":"Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:"},{"content":"Next, create a new class.","pos":[15166,15191]},{"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>Project<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Add New Item<ept id=\"p2\">**</ept>.","pos":[15192,15248],"source":" In Visual Studio, choose **Project** > **Add New Item**."},{"content":"In the <bpt id=\"p1\">**</bpt>Add New Item<ept id=\"p1\">**</ept> dialog type <bpt id=\"p2\">*</bpt>UsingCollector.cs<ept id=\"p2\">*</ept> as the filename.","pos":[15249,15321],"source":" In the **Add New Item** dialog type *UsingCollector.cs* as the filename."},{"content":"You implement the <ph id=\"ph1\">`using`</ph> visitor functionality in the <ph id=\"ph2\">`UsingCollector`</ph> class.","pos":[15323,15401],"source":"You implement the `using` visitor functionality in the `UsingCollector` class."},{"content":"Start by making the <ph id=\"ph1\">`UsingCollector`</ph> class derive from <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker&gt;</ph>.","pos":[15402,15513],"source":" Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>."},{"content":"You need storage to hold the namespace nodes that you're collecting.","pos":[15716,15784]},{"content":"Declare a public read-only property in the <ph id=\"ph1\">`UsingCollector`</ph> class; you use this variable to store the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax&gt;</ph> nodes you find:","pos":[15786,15968],"source":"  Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:"},{"content":"The base class, <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker&gt;</ph> implements the logic to visit each node in the syntax tree.","pos":[16164,16295],"source":"The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree."},{"content":"The derived class overrides the methods called for the specific nodes you're interested in.","pos":[16296,16387]},{"content":"In this case, you're interested in any <ph id=\"ph1\">`using`</ph> directive.","pos":[16388,16445],"source":" In this case, you're interested in any `using` directive."},{"content":"That means you must override the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)&gt;</ph> method.","pos":[16446,16622],"source":" That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method."},{"content":"The one argument to this method is a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType&gt;</ph> object.","pos":[16623,16761],"source":" The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object."},{"content":"That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.","pos":[16762,16902]},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType&gt;</ph> class has a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name&gt;</ph> property that stores the name of the namespace being imported.","pos":[16903,17145],"source":" The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported."},{"content":"It is a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType&gt;</ph>.","pos":[17146,17238],"source":" It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>."},{"content":"Add the following code in the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)&gt;</ph> override:","pos":[17239,17414],"source":" Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:"},{"content":"As with the earlier example, you've added a variety of <ph id=\"ph1\">`WriteLine`</ph> statements to aid in understanding of this method.","pos":[17619,17736],"source":"As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method."},{"content":"You can see when it's called, and what arguments are passed to it each time.","pos":[17737,17813]},{"content":"Finally, you need to add two lines of code to create the <ph id=\"ph1\">`UsingCollector`</ph> and have it visit the root node, collecting all the <ph id=\"ph2\">`using`</ph> statements.","pos":[17815,17960],"source":"Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements."},{"content":"Then, add a <ph id=\"ph1\">`foreach`</ph> loop to display all the <ph id=\"ph2\">`using`</ph> statements your collector found:","pos":[17961,18047],"source":" Then, add a `foreach` loop to display all the `using` statements your collector found:"},{"content":"Compile and run the program.","pos":[18252,18280]},{"content":"You should see the following output:","pos":[18281,18317]},{"content":"Congratulations!","pos":[19438,19454]},{"content":"You've used the <bpt id=\"p1\">**</bpt>Syntax API<ept id=\"p1\">**</ept> to locate specific kinds of C# statements and declarations in C# source code.","pos":[19455,19563],"source":" You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code."}]}