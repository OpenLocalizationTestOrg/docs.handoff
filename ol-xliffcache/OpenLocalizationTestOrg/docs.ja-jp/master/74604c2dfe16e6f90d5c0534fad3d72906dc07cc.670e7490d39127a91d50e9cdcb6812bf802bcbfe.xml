{"content":"---\ntitle: \"Types (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"value types [C#]\"\n  - \"reference types [C#]\"\n  - \"types [C#]\"\n  - \"C# language, data types\"\n  - \"common type system [C#]\"\n  - \"data types [C#]\"\n  - \"C# language, types\"\n  - \"strong typing [C#]\"\nms.assetid: f782d7cc-035e-4500-b1b1-36a9881130ad\ncaps.latest.revision: 53\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Types (C# Programming Guide)\n## Types, Variables, and Values  \n C# is a strongly-typed language. Every variable and constant has a type, as does every expression that evaluates to a value. Every method signature specifies a type for each input parameter and for the return value. The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates. A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.  \n  \n The information stored in a type can include the following:  \n  \n-   The storage space that a variable of the type requires.  \n  \n-   The maximum and minimum values that it can represent.  \n  \n-   The members (methods, fields, events, and so on) that it contains.  \n  \n-   The base type it inherits from.  \n  \n-   The location where the memory for variables will be allocated at run time.  \n  \n-   The kinds of operations that are permitted.  \n  \n The compiler uses type information to make sure that all operations that are performed in your code are *type safe*. For example, if you declare a variable of type [int](../../../csharp/language-reference/keywords/int.md), the compiler allows you to use the variable in addition and subtraction operations. If you try to perform those same operations on a variable of type [bool](../../../csharp/language-reference/keywords/bool.md), the compiler generates an error, as shown in the following example:  \n  \n [!code-cs[csProgGuideTypes#42](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_1.cs)]  \n  \n> [!NOTE]\n>  C and C++ developers, notice that in C#, [bool](../../../csharp/language-reference/keywords/bool.md) is not convertible to [int](../../../csharp/language-reference/keywords/int.md).  \n  \n The compiler embeds the type information into the executable file as metadata. The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.  \n  \n### Specifying Types in Variable Declarations  \n When you declare a variable or constant in a program, you must either specify its type or use the [var](../../../csharp/language-reference/keywords/var.md) keyword to let the compiler infer the type. The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:  \n  \n [!code-cs[csProgGuideTypes#36](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_2.cs)]  \n  \n The types of method parameters and return values are specified in the method signature. The following signature shows a method that requires an [int](../../../csharp/language-reference/keywords/int.md) as an input argument and returns a string:  \n  \n [!code-cs[csProgGuideTypes#35](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_3.cs)]  \n  \n After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type. For example, you cannot declare an [int](../../../csharp/language-reference/keywords/int.md) and then assign it a Boolean value of [true](../../../csharp/language-reference/keywords/true-literal.md). However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments. A *type conversion* that does not cause data loss is performed automatically by the compiler. A conversion that might cause data loss requires a *cast* in the source code.  \n  \n For more information, see [Casting and Type Conversions](../../../csharp/programming-guide/types/casting-and-type-conversions.md).  \n  \n## Built-in Types  \n C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data. There are also built-in `string` and `object` types. These are available for you to use in any C# program. For a more information about the built-in types, see [Reference Tables for Types](../../../csharp/language-reference/keywords/reference-tables-for-types.md).  \n  \n## Custom Types  \n You use the [struct](../../../csharp/language-reference/keywords/struct.md), [class](../../../csharp/language-reference/keywords/class.md), [interface](../../../csharp/language-reference/keywords/interface.md), and [enum](../../../csharp/language-reference/keywords/enum.md) constructs to create your own custom types. The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications. By default, the most frequently used types in the class library are available in any C# program. Others become available only when you explicitly add a project reference to the assembly in which they are defined. After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code. For more information, see [.NET Framework Class Library](http://go.microsoft.com/fwlink/?LinkID=217856).  \n  \n## The Common Type System  \n It is important to understand two fundamental points about the type system in the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]:  \n  \n-   It supports the principle of inheritance. Types can derive from other types, called *base types*. The derived type inherits (with some restrictions) the methods, properties, and other members of the base type. The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy. All types, including built-in numeric types such as <xref:System.Int32?displayProperty=fullName> (C# keyword: [int](../../../csharp/language-reference/keywords/int.md)), derive ultimately from a single base type, which is <xref:System.Object?displayProperty=fullName> (C# keyword: [object](../../../csharp/language-reference/keywords/object.md)). This unified type hierarchy is called the [Common Type System](../../../standard/base-types/common-type-system.md) (CTS). For more information about inheritance in C#, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).  \n  \n-   Each type in the CTS is defined as either a *value type* or a *reference type*. This includes all custom types in the .NET Framework class library and also your own user-defined types. Types that you define by using the [struct](../../../csharp/language-reference/keywords/struct.md) keyword are value types; all the built-in numeric types are `structs`. Types that you define by using the [class](../../../csharp/language-reference/keywords/class.md) keyword are reference types. Reference types and value types have different compile-time rules, and different run-time behavior.  \n  \n The following illustration shows the relationship between value types and reference types in the CTS.  \n  \n ![Value Types and Reference Types](../../../csharp/programming-guide/types/media/valuetypescts.png \"ValueTypesCTS\")  \nValue types and reference types in the CTS  \n  \n> [!NOTE]\n>  You can see that the most commonly used types are all organized in the <xref:System> namespace. However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.  \n  \n### Value Types  \n Value types derive from <xref:System.ValueType?displayProperty=fullName>, which derives from <xref:System.Object?displayProperty=fullName>. Types that derive from <xref:System.ValueType?displayProperty=fullName> have special behavior in the CLR. Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared. There is no separate heap allocation or garbage collection overhead for value-type variables.  \n  \n There are two categories of value types: [struct](../../../csharp/language-reference/keywords/struct.md) and [enum](../../../csharp/language-reference/keywords/enum.md).  \n  \n The built-in numeric types are structs, and they have properties and methods that you can access:  \n  \n```csharp  \n// Static method on type Byte.  \nbyte b = Byte.MaxValue;  \n```  \n  \n But you declare and assign values to them as if they were simple non-aggregate types:  \n  \n```csharp  \nbyte num = 0xA;  \nint i = 5;  \nchar c = 'Z';  \n```  \n  \n Value types are *sealed*, which means, for example, that you cannot derive a type from <xref:System.Int32?displayProperty=fullName>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <xref:System.ValueType?displayProperty=fullName>. However, a struct can implement one or more interfaces. You can cast a struct type to an interface type; this causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap. Boxing operations occur when you pass a value type to a method that takes a <xref:System.Object?displayProperty=fullName> as an input parameter. For more information, see [Boxing and Unboxing](../../../csharp/programming-guide/types/boxing-and-unboxing.md).  \n  \n You use the [struct](../../../csharp/language-reference/keywords/struct.md) keyword to create your own custom value types. Typically, a struct is used as a container for a small set of related variables, as shown in the following example:  \n  \n [!code-cs[csProgGuideObjects#1](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/index_4.cs)]  \n  \n For more information about structs, see [Structs](../../../csharp/programming-guide/classes-and-structs/structs.md). For more information about value types in the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)], see [Common Type System](../../../standard/base-types/common-type-system.md).  \n  \n The other category of value types is [enum](../../../csharp/language-reference/keywords/enum.md). An enum defines a set of named integral constants. For example, the <xref:System.IO.FileMode?displayProperty=fullName> enumeration in the .NET Framework class library contains a set of named constant integers that specify how a file should be opened. It is defined as shown in the following example:  \n \n [!code-cs[csProgGuideTypes#44](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_5.cs)]  \n  \n The `System.IO.FileMode.Create` constant has a value of 2. However, the name is much more meaningful for humans reading the source code, and for that reason it is better to use enumerations instead of constant literal numbers. For more information, see <xref:System.IO.FileMode?displayProperty=fullName>.  \n  \n All enums inherit from <xref:System.Enum?displayProperty=fullName>, which inherits from <xref:System.ValueType?displayProperty=fullName>. All the rules that apply to structs also apply to enums. For more information about enums, see [Enumeration Types](../../../csharp/programming-guide/enumeration-types.md).  \n  \n### Reference Types  \n A type that is defined as a [class](../../../csharp/language-reference/keywords/class.md), [delegate](../../../csharp/language-reference/keywords/delegate.md), array, or [interface](../../../csharp/language-reference/keywords/interface.md) is a *reference type*. At run time, when you declare a variable of a reference type, the variable contains the value [null](../../../csharp/language-reference/keywords/null.md) until you explicitly create an instance of the object by using the [new](../../../csharp/language-reference/keywords/new.md) operator, or assign it an object that has been created elsewhere by using `new, as shown in the following example:`  \n  \n```csharp  \nMyClass mc = new MyClass();  \nMyClass mc2 = mc;  \n```  \n   An interface must be initialized together with a class object that implements it. If `MyClass` implements `IMyInterface`, you create an instance of `IMyInterface` as shown in the following example:  \n  \n```csharp  \nIMyInterface iface = new MyClass();  \n```  \n  \n When the object is created, the memory is allocated on the managed heap, and the variable holds only a reference to the location of the object. Types on the managed heap require overhead both when they are allocated and when they are reclaimed by the automatic memory management functionality of the CLR, which is known as *garbage collection*. However, garbage collection is also highly optimized, and in most scenarios it does not create a performance issue. For more information about garbage collection, see [Automatic Memory Management](../../../standard/automatic-memory-management.md).  \n  \n All arrays are reference types, even if their elements are value types. Arrays implicitly derive from the <xref:System.Array?displayProperty=fullName> class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:  \n  \n [!code-cs[csProgGuideTypes#45](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_6.cs)]  \n  \n Reference types fully support inheritance. When you create a class, you can inherit from any other interface or class that is not defined as [sealed](../../../csharp/language-reference/keywords/sealed.md), and other classes can inherit from your class and override your virtual methods. For more information about how to create your own classes, see [Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md). For more information about inheritance and virtual methods, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).  \n  \n## Types of Literal Values  \n In C#, literal values receive a type from the compiler. You can specify how a numeric literal should be typed by appending a letter to the end of the number. For example, to specify that the value 4.56 should be treated as a float, append an \"f\" or \"F\" after the number: `4.56f`. If no letter is appended, the compiler will infer a type for the literal. For more information about which types can be specified with letter suffixes, see the reference pages for individual types in [Value Types](../../../csharp/language-reference/keywords/value-types.md).  \n  \n Because literals are typed, and all types derive ultimately from <xref:System.Object?displayProperty=fullName>, you can write and compile code such as the following:  \n  \n [!code-cs[csProgGuideTypes#37](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_7.cs)]  \n  \n## Generic Types  \n A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type. Such types are called *generic types*. For example, the .NET Framework type <xref:System.Collections.Generic.List%601?displayProperty=fullName> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:  \n \n```csharp\nList<string> stringList = new List<string>();\nstringList.Add(\"String example\");\n// compile time error adding a type other than a string:\nstringList.Add(4);\n```\n The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](../../../csharp/language-reference/keywords/object.md). Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example. For more information, see [Generics](../../../csharp/programming-guide/generics/index.md).  \n  \n## Implicit Types, Anonymous Types, and Nullable Types  \n As stated previously, you can implicitly type a local variable (but not class members) by using the [var](../../../csharp/language-reference/keywords/var.md) keyword. The variable still receives a type at compile time, but the type is provided by the compiler. For more information, see [Implicitly Typed Local Variables](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).  \n  \n In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries. You can create *anonymous types* for this purpose. For more information, see [Anonymous Types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md).  \n  \n Ordinary value types cannot have a value of [null](../../../csharp/language-reference/keywords/null.md). However, you can create nullable value types by affixing a `?` after the type. For example, `int?` is an `int` type that can also have the value [null](../../../csharp/language-reference/keywords/null.md). In the CTS, nullable types are instances of the generic struct type <xref:System.Nullable%601?displayProperty=fullName>. Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null. For more information, see [Nullable Types](../../../csharp/programming-guide/nullable-types/index.md).  \n  \n## Related Sections  \n For more information, see the following topics:  \n  \n-   [Casting and Type Conversions](../../../csharp/programming-guide/types/casting-and-type-conversions.md)  \n  \n-   [Boxing and Unboxing](../../../csharp/programming-guide/types/boxing-and-unboxing.md)  \n  \n-   [Using Type dynamic](../../../csharp/programming-guide/types/using-type-dynamic.md)  \n  \n-   [Value Types](../../../csharp/language-reference/keywords/value-types.md)  \n  \n-   [Reference Types](../../../csharp/language-reference/keywords/reference-types.md)  \n  \n-   [Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)  \n  \n-   [Anonymous Types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)  \n  \n-   [Generics](../../../csharp/programming-guide/generics/index.md)  \n\n## C# Language Specification  \n [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n## See Also  \n [C# Reference](../../../csharp/language-reference/index.md)   \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Conversion of XML Data Types](../../../standard/data/xml/conversion-of-xml-data-types.md)   \n [Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md)\n","nodes":[{"pos":[4,725],"nodes":[{"content":"Types (C# Programming Guide) | Microsoft Docs","nodes":[{"pos":[0,45],"content":"Types (C# Programming Guide) | Microsoft Docs","nodes":[{"content":"Types (C# Programming Guide) | Microsoft Docs","pos":[0,45]}]}],"pos":[6,54],"yaml":true}],"content":"title: \"Types (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"value types [C#]\"\n  - \"reference types [C#]\"\n  - \"types [C#]\"\n  - \"C# language, data types\"\n  - \"common type system [C#]\"\n  - \"data types [C#]\"\n  - \"C# language, types\"\n  - \"strong typing [C#]\"\nms.assetid: f782d7cc-035e-4500-b1b1-36a9881130ad\ncaps.latest.revision: 53\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","yamlblock":true},{"pos":[732,760],"content":"Types (C# Programming Guide)","linkify":"Types (C# Programming Guide)","nodes":[{"content":"Types (C# Programming Guide)","pos":[0,28]}]},{"pos":[764,792],"content":"Types, Variables, and Values","linkify":"Types, Variables, and Values","nodes":[{"content":"Types, Variables, and Values","pos":[0,28]}]},{"content":"C# is a strongly-typed language.","pos":[796,828]},{"content":"Every variable and constant has a type, as does every expression that evaluates to a value.","pos":[829,920]},{"content":"Every method signature specifies a type for each input parameter and for the return value.","pos":[921,1011]},{"content":"The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.","pos":[1012,1259]},{"content":"A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.","pos":[1260,1419]},{"content":"The information stored in a type can include the following:","pos":[1426,1485]},{"content":"The storage space that a variable of the type requires.","pos":[1495,1550]},{"content":"The maximum and minimum values that it can represent.","pos":[1560,1613]},{"content":"The members (methods, fields, events, and so on) that it contains.","pos":[1623,1689]},{"content":"The base type it inherits from.","pos":[1699,1730]},{"content":"The location where the memory for variables will be allocated at run time.","pos":[1740,1814]},{"content":"The kinds of operations that are permitted.","pos":[1824,1867]},{"content":"The compiler uses type information to make sure that all operations that are performed in your code are <bpt id=\"p1\">*</bpt>type safe<ept id=\"p1\">*</ept>.","pos":[1874,1990],"source":"The compiler uses type information to make sure that all operations that are performed in your code are *type safe*."},{"content":"For example, if you declare a variable of type <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../../../csharp/language-reference/keywords/int.md)</ept>, the compiler allows you to use the variable in addition and subtraction operations.","pos":[1991,2180],"source":" For example, if you declare a variable of type [int](../../../csharp/language-reference/keywords/int.md), the compiler allows you to use the variable in addition and subtraction operations."},{"content":"If you try to perform those same operations on a variable of type <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](../../../csharp/language-reference/keywords/bool.md)</ept>, the compiler generates an error, as shown in the following example:","pos":[2181,2375],"source":" If you try to perform those same operations on a variable of type [bool](../../../csharp/language-reference/keywords/bool.md), the compiler generates an error, as shown in the following example:"},{"pos":[2382,2493],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideTypes#42<ept id=\"p2\">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_1.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideTypes#42](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_1.cs)]"},{"pos":[2501,2693],"content":"[!NOTE]\n C and C++ developers, notice that in C#, [bool](../../../csharp/language-reference/keywords/bool.md) is not convertible to [int](../../../csharp/language-reference/keywords/int.md).","leadings":["","> "],"nodes":[{"content":"C and C++ developers, notice that in C#, <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](../../../csharp/language-reference/keywords/bool.md)</ept> is not convertible to <bpt id=\"p2\">[</bpt>int<ept id=\"p2\">](../../../csharp/language-reference/keywords/int.md)</ept>.","pos":[9,190],"source":"C and C++ developers, notice that in C#, [bool](../../../csharp/language-reference/keywords/bool.md) is not convertible to [int](../../../csharp/language-reference/keywords/int.md)."}]},{"content":"The compiler embeds the type information into the executable file as metadata.","pos":[2700,2778]},{"content":"The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.","pos":[2779,2915]},{"pos":[2925,2966],"content":"Specifying Types in Variable Declarations","linkify":"Specifying Types in Variable Declarations","nodes":[{"content":"Specifying Types in Variable Declarations","pos":[0,41]}]},{"content":"When you declare a variable or constant in a program, you must either specify its type or use the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](../../../csharp/language-reference/keywords/var.md)</ept> keyword to let the compiler infer the type.","pos":[2970,3169],"source":"When you declare a variable or constant in a program, you must either specify its type or use the [var](../../../csharp/language-reference/keywords/var.md) keyword to let the compiler infer the type."},{"content":"The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:","pos":[3170,3293]},{"pos":[3300,3411],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideTypes#36<ept id=\"p2\">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_2.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideTypes#36](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_2.cs)]"},{"content":"The types of method parameters and return values are specified in the method signature.","pos":[3418,3505]},{"content":"The following signature shows a method that requires an <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../../../csharp/language-reference/keywords/int.md)</ept> as an input argument and returns a string:","pos":[3506,3662],"source":" The following signature shows a method that requires an [int](../../../csharp/language-reference/keywords/int.md) as an input argument and returns a string:"},{"pos":[3669,3780],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideTypes#35<ept id=\"p2\">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_3.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideTypes#35](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_3.cs)]"},{"content":"After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.","pos":[3787,3939]},{"content":"For example, you cannot declare an <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../../../csharp/language-reference/keywords/int.md)</ept> and then assign it a Boolean value of <bpt id=\"p2\">[</bpt>true<ept id=\"p2\">](../../../csharp/language-reference/keywords/true-literal.md)</ept>.","pos":[3940,4139],"source":" For example, you cannot declare an [int](../../../csharp/language-reference/keywords/int.md) and then assign it a Boolean value of [true](../../../csharp/language-reference/keywords/true-literal.md)."},{"content":"However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.","pos":[4140,4271]},{"content":"A <bpt id=\"p1\">*</bpt>type conversion<ept id=\"p1\">*</ept> that does not cause data loss is performed automatically by the compiler.","pos":[4272,4365],"source":" A *type conversion* that does not cause data loss is performed automatically by the compiler."},{"content":"A conversion that might cause data loss requires a <bpt id=\"p1\">*</bpt>cast<ept id=\"p1\">*</ept> in the source code.","pos":[4366,4443],"source":" A conversion that might cause data loss requires a *cast* in the source code."},{"pos":[4450,4580],"content":"For more information, see <bpt id=\"p1\">[</bpt>Casting and Type Conversions<ept id=\"p1\">](../../../csharp/programming-guide/types/casting-and-type-conversions.md)</ept>.","source":"For more information, see [Casting and Type Conversions](../../../csharp/programming-guide/types/casting-and-type-conversions.md)."},{"pos":[4589,4603],"content":"Built-in Types","linkify":"Built-in Types","nodes":[{"content":"Built-in Types","pos":[0,14]}]},{"content":"C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.","pos":[4607,4784]},{"content":"There are also built-in <ph id=\"ph1\">`string`</ph> and <ph id=\"ph2\">`object`</ph> types.","pos":[4785,4837],"source":" There are also built-in `string` and `object` types."},{"content":"These are available for you to use in any C# program.","pos":[4838,4891]},{"content":"For a more information about the built-in types, see <bpt id=\"p1\">[</bpt>Reference Tables for Types<ept id=\"p1\">](../../../csharp/language-reference/keywords/reference-tables-for-types.md)</ept>.","pos":[4892,5049],"source":" For a more information about the built-in types, see [Reference Tables for Types](../../../csharp/language-reference/keywords/reference-tables-for-types.md)."},{"pos":[5058,5070],"content":"Custom Types","linkify":"Custom Types","nodes":[{"content":"Custom Types","pos":[0,12]}]},{"content":"You use the <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](../../../csharp/language-reference/keywords/struct.md)</ept>, <bpt id=\"p2\">[</bpt>class<ept id=\"p2\">](../../../csharp/language-reference/keywords/class.md)</ept>, <bpt id=\"p3\">[</bpt>interface<ept id=\"p3\">](../../../csharp/language-reference/keywords/interface.md)</ept>, and <bpt id=\"p4\">[</bpt>enum<ept id=\"p4\">](../../../csharp/language-reference/keywords/enum.md)</ept> constructs to create your own custom types.","pos":[5074,5392],"source":"You use the [struct](../../../csharp/language-reference/keywords/struct.md), [class](../../../csharp/language-reference/keywords/class.md), [interface](../../../csharp/language-reference/keywords/interface.md), and [enum](../../../csharp/language-reference/keywords/enum.md) constructs to create your own custom types."},{"content":"The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.","pos":[5393,5529]},{"content":"By default, the most frequently used types in the class library are available in any C# program.","pos":[5530,5626]},{"content":"Others become available only when you explicitly add a project reference to the assembly in which they are defined.","pos":[5627,5742]},{"content":"After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.","pos":[5743,5891]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>.NET Framework Class Library<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=217856)</ept>.","pos":[5892,5996],"source":" For more information, see [.NET Framework Class Library](http://go.microsoft.com/fwlink/?LinkID=217856)."},{"pos":[6005,6027],"content":"The Common Type System","linkify":"The Common Type System","nodes":[{"content":"The Common Type System","pos":[0,22]}]},{"pos":[6031,6197],"content":"It is important to understand two fundamental points about the type system in the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>:","source":"It is important to understand two fundamental points about the type system in the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]:"},{"content":"It supports the principle of inheritance.","pos":[6207,6248]},{"content":"Types can derive from other types, called <bpt id=\"p1\">*</bpt>base types<ept id=\"p1\">*</ept>.","pos":[6249,6304],"source":" Types can derive from other types, called *base types*."},{"content":"The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.","pos":[6305,6416]},{"content":"The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.","pos":[6417,6572]},{"content":"All types, including built-in numeric types such as <ph id=\"ph1\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph> (C# keyword: <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../../../csharp/language-reference/keywords/int.md)</ept>), derive ultimately from a single base type, which is <ph id=\"ph2\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> (C# keyword: <bpt id=\"p2\">[</bpt>object<ept id=\"p2\">](../../../csharp/language-reference/keywords/object.md)</ept>).","pos":[6573,6919],"source":" All types, including built-in numeric types such as <xref:System.Int32?displayProperty=fullName> (C# keyword: [int](../../../csharp/language-reference/keywords/int.md)), derive ultimately from a single base type, which is <xref:System.Object?displayProperty=fullName> (C# keyword: [object](../../../csharp/language-reference/keywords/object.md))."},{"content":"This unified type hierarchy is called the <bpt id=\"p1\">[</bpt>Common Type System<ept id=\"p1\">](../../../standard/base-types/common-type-system.md)</ept> (CTS).","pos":[6920,7041],"source":" This unified type hierarchy is called the [Common Type System](../../../standard/base-types/common-type-system.md) (CTS)."},{"content":"For more information about inheritance in C#, see <bpt id=\"p1\">[</bpt>Inheritance<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/inheritance.md)</ept>.","pos":[7042,7176],"source":" For more information about inheritance in C#, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md)."},{"content":"Each type in the CTS is defined as either a <bpt id=\"p1\">*</bpt>value type<ept id=\"p1\">*</ept> or a <bpt id=\"p2\">*</bpt>reference type<ept id=\"p2\">*</ept>.","pos":[7186,7265],"source":"Each type in the CTS is defined as either a *value type* or a *reference type*."},{"content":"This includes all custom types in the .NET Framework class library and also your own user-defined types.","pos":[7266,7370]},{"content":"Types that you define by using the <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](../../../csharp/language-reference/keywords/struct.md)</ept> keyword are value types; all the built-in numeric types are <ph id=\"ph1\">`structs`</ph>.","pos":[7371,7540],"source":" Types that you define by using the [struct](../../../csharp/language-reference/keywords/struct.md) keyword are value types; all the built-in numeric types are `structs`."},{"content":"Types that you define by using the <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../../../csharp/language-reference/keywords/class.md)</ept> keyword are reference types.","pos":[7541,7666],"source":" Types that you define by using the [class](../../../csharp/language-reference/keywords/class.md) keyword are reference types."},{"content":"Reference types and value types have different compile-time rules, and different run-time behavior.","pos":[7667,7766]},{"content":"The following illustration shows the relationship between value types and reference types in the CTS.","pos":[7773,7874]},{"content":"<bpt id=\"p1\">![</bpt>Value Types and Reference Types<ept id=\"p1\">](../../../csharp/programming-guide/types/media/valuetypescts.png \"ValueTypesCTS\")</ept>","pos":[7881,7996],"source":"![Value Types and Reference Types](../../../csharp/programming-guide/types/media/valuetypescts.png \"ValueTypesCTS\")"},{"content":"Value types and reference types in the CTS","pos":[7999,8041]},{"pos":[8049,8272],"content":"[!NOTE]\n You can see that the most commonly used types are all organized in the <xref:System> namespace. However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.","leadings":["","> "],"nodes":[{"content":"You can see that the most commonly used types are all organized in the <xref:System> namespace. However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.","pos":[9,221],"nodes":[{"content":"You can see that the most commonly used types are all organized in the <ph id=\"ph1\">&lt;xref:System&gt;</ph> namespace.","pos":[0,95],"source":"You can see that the most commonly used types are all organized in the <xref:System> namespace."},{"content":"However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.","pos":[96,212]}]}]},{"pos":[8282,8293],"content":"Value Types","linkify":"Value Types","nodes":[{"content":"Value Types","pos":[0,11]}]},{"content":"Value types derive from <ph id=\"ph1\">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>, which derives from <ph id=\"ph2\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>.","pos":[8297,8436],"source":"Value types derive from <xref:System.ValueType?displayProperty=fullName>, which derives from <xref:System.Object?displayProperty=fullName>."},{"content":"Types that derive from <ph id=\"ph1\">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph> have special behavior in the CLR.","pos":[8437,8542],"source":" Types that derive from <xref:System.ValueType?displayProperty=fullName> have special behavior in the CLR."},{"content":"Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.","pos":[8543,8688]},{"content":"There is no separate heap allocation or garbage collection overhead for value-type variables.","pos":[8689,8782]},{"pos":[8789,8958],"content":"There are two categories of value types: <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](../../../csharp/language-reference/keywords/struct.md)</ept> and <bpt id=\"p2\">[</bpt>enum<ept id=\"p2\">](../../../csharp/language-reference/keywords/enum.md)</ept>.","source":"There are two categories of value types: [struct](../../../csharp/language-reference/keywords/struct.md) and [enum](../../../csharp/language-reference/keywords/enum.md)."},{"content":"The built-in numeric types are structs, and they have properties and methods that you can access:","pos":[8965,9062]},{"content":"But you declare and assign values to them as if they were simple non-aggregate types:","pos":[9149,9234]},{"content":"Value types are <bpt id=\"p1\">*</bpt>sealed<ept id=\"p1\">*</ept>, which means, for example, that you cannot derive a type from <ph id=\"ph1\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <ph id=\"ph2\">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>.","pos":[9309,9610],"source":"Value types are *sealed*, which means, for example, that you cannot derive a type from <xref:System.Int32?displayProperty=fullName>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <xref:System.ValueType?displayProperty=fullName>."},{"content":"However, a struct can implement one or more interfaces.","pos":[9611,9666]},{"content":"You can cast a struct type to an interface type; this causes a <bpt id=\"p1\">*</bpt>boxing<ept id=\"p1\">*</ept> operation to wrap the struct inside a reference type object on the managed heap.","pos":[9667,9819],"source":" You can cast a struct type to an interface type; this causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap."},{"content":"Boxing operations occur when you pass a value type to a method that takes a <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> as an input parameter.","pos":[9820,9964],"source":" Boxing operations occur when you pass a value type to a method that takes a <xref:System.Object?displayProperty=fullName> as an input parameter."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Boxing and Unboxing<ept id=\"p1\">](../../../csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.","pos":[9965,10077],"source":" For more information, see [Boxing and Unboxing](../../../csharp/programming-guide/types/boxing-and-unboxing.md)."},{"content":"You use the <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](../../../csharp/language-reference/keywords/struct.md)</ept> keyword to create your own custom value types.","pos":[10084,10206],"source":"You use the [struct](../../../csharp/language-reference/keywords/struct.md) keyword to create your own custom value types."},{"content":"Typically, a struct is used as a container for a small set of related variables, as shown in the following example:","pos":[10207,10322]},{"pos":[10329,10446],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#1<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/index_4.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#1](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/index_4.cs)]"},{"content":"For more information about structs, see <bpt id=\"p1\">[</bpt>Structs<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/structs.md)</ept>.","pos":[10453,10569],"source":"For more information about structs, see [Structs](../../../csharp/programming-guide/classes-and-structs/structs.md)."},{"content":"For more information about value types in the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>, see <bpt id=\"p1\">[</bpt>Common Type System<ept id=\"p1\">](../../../standard/base-types/common-type-system.md)</ept>.","pos":[10570,10778],"source":" For more information about value types in the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)], see [Common Type System](../../../standard/base-types/common-type-system.md)."},{"content":"The other category of value types is <bpt id=\"p1\">[</bpt>enum<ept id=\"p1\">](../../../csharp/language-reference/keywords/enum.md)</ept>.","pos":[10785,10882],"source":"The other category of value types is [enum](../../../csharp/language-reference/keywords/enum.md)."},{"content":"An enum defines a set of named integral constants.","pos":[10883,10933]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.IO.FileMode?displayProperty=fullName&gt;</ph> enumeration in the .NET Framework class library contains a set of named constant integers that specify how a file should be opened.","pos":[10934,11133],"source":" For example, the <xref:System.IO.FileMode?displayProperty=fullName> enumeration in the .NET Framework class library contains a set of named constant integers that specify how a file should be opened."},{"content":"It is defined as shown in the following example:","pos":[11134,11182]},{"pos":[11188,11299],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideTypes#44<ept id=\"p2\">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_5.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideTypes#44](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_5.cs)]"},{"content":"The <ph id=\"ph1\">`System.IO.FileMode.Create`</ph> constant has a value of 2.","pos":[11306,11364],"source":"The `System.IO.FileMode.Create` constant has a value of 2."},{"content":"However, the name is much more meaningful for humans reading the source code, and for that reason it is better to use enumerations instead of constant literal numbers.","pos":[11365,11532]},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.IO.FileMode?displayProperty=fullName&gt;</ph>.","pos":[11533,11610],"source":" For more information, see <xref:System.IO.FileMode?displayProperty=fullName>."},{"content":"All enums inherit from <ph id=\"ph1\">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph>, which inherits from <ph id=\"ph2\">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>.","pos":[11617,11754],"source":"All enums inherit from <xref:System.Enum?displayProperty=fullName>, which inherits from <xref:System.ValueType?displayProperty=fullName>."},{"content":"All the rules that apply to structs also apply to enums.","pos":[11755,11811]},{"content":"For more information about enums, see <bpt id=\"p1\">[</bpt>Enumeration Types<ept id=\"p1\">](../../../csharp/programming-guide/enumeration-types.md)</ept>.","pos":[11812,11926],"source":" For more information about enums, see [Enumeration Types](../../../csharp/programming-guide/enumeration-types.md)."},{"pos":[11936,11951],"content":"Reference Types","linkify":"Reference Types","nodes":[{"content":"Reference Types","pos":[0,15]}]},{"content":"A type that is defined as a <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../../../csharp/language-reference/keywords/class.md)</ept>, <bpt id=\"p2\">[</bpt>delegate<ept id=\"p2\">](../../../csharp/language-reference/keywords/delegate.md)</ept>, array, or <bpt id=\"p3\">[</bpt>interface<ept id=\"p3\">](../../../csharp/language-reference/keywords/interface.md)</ept> is a <bpt id=\"p4\">*</bpt>reference type<ept id=\"p4\">*</ept>.","pos":[11955,12217],"source":"A type that is defined as a [class](../../../csharp/language-reference/keywords/class.md), [delegate](../../../csharp/language-reference/keywords/delegate.md), array, or [interface](../../../csharp/language-reference/keywords/interface.md) is a *reference type*."},{"content":"At run time, when you declare a variable of a reference type, the variable contains the value <bpt id=\"p1\">[</bpt>null<ept id=\"p1\">](../../../csharp/language-reference/keywords/null.md)</ept> until you explicitly create an instance of the object by using the <bpt id=\"p2\">[</bpt>new<ept id=\"p2\">](../../../csharp/language-reference/keywords/new.md)</ept> operator, or assign it an object that has been created elsewhere by using <ph id=\"ph1\">`new, as shown in the following example:`</ph>","pos":[12218,12612],"source":" At run time, when you declare a variable of a reference type, the variable contains the value [null](../../../csharp/language-reference/keywords/null.md) until you explicitly create an instance of the object by using the [new](../../../csharp/language-reference/keywords/new.md) operator, or assign it an object that has been created elsewhere by using `new, as shown in the following example:`"},{"content":"An interface must be initialized together with a class object that implements it.","pos":[12689,12770]},{"content":"If <ph id=\"ph1\">`MyClass`</ph> implements <ph id=\"ph2\">`IMyInterface`</ph>, you create an instance of <ph id=\"ph3\">`IMyInterface`</ph> as shown in the following example:","pos":[12771,12886],"source":" If `MyClass` implements `IMyInterface`, you create an instance of `IMyInterface` as shown in the following example:"},{"content":"When the object is created, the memory is allocated on the managed heap, and the variable holds only a reference to the location of the object.","pos":[12952,13095]},{"content":"Types on the managed heap require overhead both when they are allocated and when they are reclaimed by the automatic memory management functionality of the CLR, which is known as <bpt id=\"p1\">*</bpt>garbage collection<ept id=\"p1\">*</ept>.","pos":[13096,13296],"source":" Types on the managed heap require overhead both when they are allocated and when they are reclaimed by the automatic memory management functionality of the CLR, which is known as *garbage collection*."},{"content":"However, garbage collection is also highly optimized, and in most scenarios it does not create a performance issue.","pos":[13297,13412]},{"content":"For more information about garbage collection, see <bpt id=\"p1\">[</bpt>Automatic Memory Management<ept id=\"p1\">](../../../standard/automatic-memory-management.md)</ept>.","pos":[13413,13544],"source":" For more information about garbage collection, see [Automatic Memory Management](../../../standard/automatic-memory-management.md)."},{"content":"All arrays are reference types, even if their elements are value types.","pos":[13551,13622]},{"content":"Arrays implicitly derive from the <ph id=\"ph1\">&lt;xref:System.Array?displayProperty=fullName&gt;</ph> class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:","pos":[13623,13823],"source":" Arrays implicitly derive from the <xref:System.Array?displayProperty=fullName> class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:"},{"pos":[13830,13941],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideTypes#45<ept id=\"p2\">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_6.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideTypes#45](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_6.cs)]"},{"content":"Reference types fully support inheritance.","pos":[13948,13990]},{"content":"When you create a class, you can inherit from any other interface or class that is not defined as <bpt id=\"p1\">[</bpt>sealed<ept id=\"p1\">](../../../csharp/language-reference/keywords/sealed.md)</ept>, and other classes can inherit from your class and override your virtual methods.","pos":[13991,14234],"source":" When you create a class, you can inherit from any other interface or class that is not defined as [sealed](../../../csharp/language-reference/keywords/sealed.md), and other classes can inherit from your class and override your virtual methods."},{"content":"For more information about how to create your own classes, see <bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/index.md)</ept>.","pos":[14235,14384],"source":" For more information about how to create your own classes, see [Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)."},{"content":"For more information about inheritance and virtual methods, see <bpt id=\"p1\">[</bpt>Inheritance<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/inheritance.md)</ept>.","pos":[14385,14533],"source":" For more information about inheritance and virtual methods, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md)."},{"pos":[14542,14565],"content":"Types of Literal Values","linkify":"Types of Literal Values","nodes":[{"content":"Types of Literal Values","pos":[0,23]}]},{"content":"In C#, literal values receive a type from the compiler.","pos":[14569,14624]},{"content":"You can specify how a numeric literal should be typed by appending a letter to the end of the number.","pos":[14625,14726]},{"content":"For example, to specify that the value 4.56 should be treated as a float, append an \"f\" or \"F\" after the number: <ph id=\"ph1\">`4.56f`</ph>.","pos":[14727,14848],"source":" For example, to specify that the value 4.56 should be treated as a float, append an \"f\" or \"F\" after the number: `4.56f`."},{"content":"If no letter is appended, the compiler will infer a type for the literal.","pos":[14849,14922]},{"content":"For more information about which types can be specified with letter suffixes, see the reference pages for individual types in <bpt id=\"p1\">[</bpt>Value Types<ept id=\"p1\">](../../../csharp/language-reference/keywords/value-types.md)</ept>.","pos":[14923,15123],"source":" For more information about which types can be specified with letter suffixes, see the reference pages for individual types in [Value Types](../../../csharp/language-reference/keywords/value-types.md)."},{"content":"Because literals are typed, and all types derive ultimately from <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>, you can write and compile code such as the following:","pos":[15130,15295],"source":"Because literals are typed, and all types derive ultimately from <xref:System.Object?displayProperty=fullName>, you can write and compile code such as the following:"},{"pos":[15302,15413],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideTypes#37<ept id=\"p2\">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_7.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideTypes#37](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_7.cs)]"},{"pos":[15422,15435],"content":"Generic Types","linkify":"Generic Types","nodes":[{"content":"Generic Types","pos":[0,13]}]},{"content":"A type can be declared with one or more <bpt id=\"p1\">*</bpt>type parameters<ept id=\"p1\">*</ept> that serve as a placeholder for the actual type (the <bpt id=\"p2\">*</bpt>concrete type<ept id=\"p2\">*</ept>) that client code will provide when it creates an instance of the type.","pos":[15439,15637],"source":"A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type."},{"content":"Such types are called <bpt id=\"p1\">*</bpt>generic types<ept id=\"p1\">*</ept>.","pos":[15638,15676],"source":" Such types are called *generic types*."},{"content":"For example, the .NET Framework type <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601?displayProperty=fullName&gt;</ph> has one type parameter that by convention is given the name <bpt id=\"p1\">*</bpt>T<ept id=\"p1\">*</ept>. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:","pos":[15677,15972],"source":" For example, the .NET Framework type <xref:System.Collections.Generic.List%601?displayProperty=fullName> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:"},{"content":"The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to <bpt id=\"p1\">[</bpt>object<ept id=\"p1\">](../../../csharp/language-reference/keywords/object.md)</ept>.","pos":[16148,16355],"source":"The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](../../../csharp/language-reference/keywords/object.md)."},{"content":"Generic collection classes are called <bpt id=\"p1\">*</bpt>strongly-typed collections<ept id=\"p1\">*</ept> because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the <ph id=\"ph1\">`strings`</ph> object in the previous example.","pos":[16356,16627],"source":" Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/index.md)</ept>.","pos":[16628,16718],"source":" For more information, see [Generics](../../../csharp/programming-guide/generics/index.md)."},{"pos":[16727,16778],"content":"Implicit Types, Anonymous Types, and Nullable Types","linkify":"Implicit Types, Anonymous Types, and Nullable Types","nodes":[{"content":"Implicit Types, Anonymous Types, and Nullable Types","pos":[0,51]}]},{"content":"As stated previously, you can implicitly type a local variable (but not class members) by using the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](../../../csharp/language-reference/keywords/var.md)</ept> keyword.","pos":[16782,16948],"source":"As stated previously, you can implicitly type a local variable (but not class members) by using the [var](../../../csharp/language-reference/keywords/var.md) keyword."},{"content":"The variable still receives a type at compile time, but the type is provided by the compiler.","pos":[16949,17042]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Implicitly Typed Local Variables<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)</ept>.","pos":[17043,17195],"source":" For more information, see [Implicitly Typed Local Variables](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)."},{"content":"In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.","pos":[17202,17359]},{"content":"You can create <bpt id=\"p1\">*</bpt>anonymous types<ept id=\"p1\">*</ept> for this purpose.","pos":[17360,17410],"source":" You can create *anonymous types* for this purpose."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept>.","pos":[17411,17529],"source":" For more information, see [Anonymous Types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)."},{"content":"Ordinary value types cannot have a value of <bpt id=\"p1\">[</bpt>null<ept id=\"p1\">](../../../csharp/language-reference/keywords/null.md)</ept>.","pos":[17536,17640],"source":"Ordinary value types cannot have a value of [null](../../../csharp/language-reference/keywords/null.md)."},{"content":"However, you can create nullable value types by affixing a <ph id=\"ph1\">`?`</ph> after the type.","pos":[17641,17719],"source":" However, you can create nullable value types by affixing a `?` after the type."},{"content":"For example, <ph id=\"ph1\">`int?`</ph> is an <ph id=\"ph2\">`int`</ph> type that can also have the value <bpt id=\"p1\">[</bpt>null<ept id=\"p1\">](../../../csharp/language-reference/keywords/null.md)</ept>.","pos":[17720,17846],"source":" For example, `int?` is an `int` type that can also have the value [null](../../../csharp/language-reference/keywords/null.md)."},{"content":"In the CTS, nullable types are instances of the generic struct type <ph id=\"ph1\">&lt;xref:System.Nullable%601?displayProperty=fullName&gt;</ph>.","pos":[17847,17967],"source":" In the CTS, nullable types are instances of the generic struct type <xref:System.Nullable%601?displayProperty=fullName>."},{"content":"Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null.","pos":[17968,18091]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Nullable Types<ept id=\"p1\">](../../../csharp/programming-guide/nullable-types/index.md)</ept>.","pos":[18092,18194],"source":" For more information, see [Nullable Types](../../../csharp/programming-guide/nullable-types/index.md)."},{"pos":[18203,18219],"content":"Related Sections","linkify":"Related Sections","nodes":[{"content":"Related Sections","pos":[0,16]}]},{"content":"For more information, see the following topics:","pos":[18223,18270]},{"pos":[18280,18383],"content":"<bpt id=\"p1\">[</bpt>Casting and Type Conversions<ept id=\"p1\">](../../../csharp/programming-guide/types/casting-and-type-conversions.md)</ept>","source":"[Casting and Type Conversions](../../../csharp/programming-guide/types/casting-and-type-conversions.md)"},{"pos":[18393,18478],"content":"<bpt id=\"p1\">[</bpt>Boxing and Unboxing<ept id=\"p1\">](../../../csharp/programming-guide/types/boxing-and-unboxing.md)</ept>","source":"[Boxing and Unboxing](../../../csharp/programming-guide/types/boxing-and-unboxing.md)"},{"pos":[18488,18571],"content":"<bpt id=\"p1\">[</bpt>Using Type dynamic<ept id=\"p1\">](../../../csharp/programming-guide/types/using-type-dynamic.md)</ept>","source":"[Using Type dynamic](../../../csharp/programming-guide/types/using-type-dynamic.md)"},{"pos":[18581,18654],"content":"<bpt id=\"p1\">[</bpt>Value Types<ept id=\"p1\">](../../../csharp/language-reference/keywords/value-types.md)</ept>","source":"[Value Types](../../../csharp/language-reference/keywords/value-types.md)"},{"pos":[18664,18745],"content":"<bpt id=\"p1\">[</bpt>Reference Types<ept id=\"p1\">](../../../csharp/language-reference/keywords/reference-types.md)</ept>","source":"[Reference Types](../../../csharp/language-reference/keywords/reference-types.md)"},{"pos":[18755,18840],"content":"<bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/index.md)</ept>","source":"[Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)"},{"pos":[18850,18941],"content":"<bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept>","source":"[Anonymous Types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)"},{"pos":[18951,19014],"content":"<bpt id=\"p1\">[</bpt>Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/index.md)</ept>","source":"[Generics](../../../csharp/programming-guide/generics/index.md)"},{"pos":[19021,19046],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[19160,19168],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[19172,19232],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[19236,19303],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Conversion of XML Data Types<ept id=\"p1\">](../../../standard/data/xml/conversion-of-xml-data-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[19307,19398],"source":"[Conversion of XML Data Types](../../../standard/data/xml/conversion-of-xml-data-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Integral Types Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/integral-types-table.md)</ept>","pos":[19402,19493],"source":"[Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md)"}]}