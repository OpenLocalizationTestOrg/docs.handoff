{"content":"---\ntitle: \"Local Type Inference (Visual Basic)\"\nms.date: 07/20/2015\nf1_keywords: \n  - \"local type inference\"\n  - \"vb.TypeInfer\"\nhelpviewer_keywords: \n  - \"Option Infer statement [Visual Basic]\"\n  - \"local type inference [Visual Basic]\"\n  - \"implicitly-typed local variables [Visual Basic]\"\n  - \"variables [Visual Basic], type inference\"\n  - \"inference [Visual Basic]\"\n  - \"type inference [Visual Basic]\"\nms.assetid: b8307f18-2e56-4ab3-a45a-826873f400f6\n---\n# Local Type Inference (Visual Basic)\nThe Visual Basic compiler uses *type inference* to determine the data types of local variables declared without an `As` clause. The compiler infers the type of the variable from the type of the initialization expression. This enables you to declare variables without explicitly stating a type, as shown in the following example. As a result of the declarations, both `num1` and `num2` are strongly typed as integers.  \n  \n [!code-vb[VbVbalrTypeInference#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTypeInference/VB/Class1.vb#1)]  \n \n> [!NOTE]\n>  If you do not want `num2` in the previous example to be typed as an `Integer`, you can specify another type by using a declaration like `Dim num3 As Object = 3` or `Dim num4 As Double = 3`.  \n\n> [!NOTE]\n>  Type inference can be used only for non-static local variables; it cannot be used to determine the type of class fields, properties, or functions.\n \n Local type inference applies at procedure level. It cannot be used to declare variables at module level (within a class, structure, module, or interface but not within a procedure or block). If `num2` in the previous example were a field of a class instead of a local variable in a procedure, the declaration would cause an error with `Option Strict` on, and would classify `num2` as an `Object` with `Option Strict` off. Similarly, local type inference does not apply to procedure level variables declared as `Static`.  \n  \n## Type Inference vs. Late Binding  \n Code that uses type inference resembles code that relies on late binding. However, type inference strongly types the variable instead of leaving it as `Object`. The compiler uses a variable's initializer to determine the variable's type at compile time to produce early-bound code. In the previous example, `num2`, like `num1`, is typed as an `Integer`.  \n  \n The behavior of early-bound variables differs from that of late-bound variables, for which the type is known only at run time. Knowing the type early enables the compiler to identify problems before execution, allocate memory precisely, and perform other optimizations. Early binding also enables the Visual Basic integrated development environment (IDE) to provide IntelliSense Help about the members of an object. Early binding is also preferred for performance. This is because all data stored in a late-bound variable must be wrapped as type `Object`, and accessing members of the type at run time makes the program slower.  \n  \n## Examples  \n Type inference occurs when a local variable is declared without an `As` clause and initialized. The compiler uses the type of the assigned initial value as the type of the variable. For example, each of the following lines of code declares a variable of type `String`.  \n  \n [!code-vb[VbVbalrTypeInference#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTypeInference/VB/Class1.vb#2)]  \n  \n The following code demonstrates two equivalent ways to create an array of integers.  \n  \n [!code-vb[VbVbalrTypeInference#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTypeInference/VB/Class1.vb#3)]  \n  \n It is convenient to use type inference to determine the type of a loop control variable. In the following code, the compiler infers that `number` is an `Integer` because `someNumbers2` from the previous example is an array of integers.  \n  \n [!code-vb[VbVbalrTypeInference#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTypeInference/VB/Class1.vb#4)]  \n  \n Local type inference can be used in `Using` statements to establish the type of the resource name, as the following example demonstrates.  \n  \n [!code-vb[VbVbalrTypeInference#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTypeInference/VB/Class1.vb#7)]  \n  \n The type of a variable can also be inferred from the return values of functions, as the following example demonstrates. Both `pList1` and `pList2` are arrays of processes because `Process.GetProcesses` returns an array of processes.  \n  \n [!code-vb[VbVbalrTypeInference#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTypeInference/VB/Class1.vb#5)]  \n  \n## Option Infer  \n `Option Infer` enables you specify whether local type inference is allowed in a particular file. To enable or to block the option, type one of the following statements at the start of the file.  \n  \n `Option Infer On`  \n  \n `Option Infer Off`  \n  \n If you do not specify a value for `Option Infer` in your code, the compiler default is `Option Infer On`. For projects upgraded from [!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)] or earlier, the compiler default is `Option Infer Off`.  \n  \n If the value set for `Option Infer` in a file conflicts with the value set in the IDE or on the command line, the value in the file has precedence.  \n  \n For more information, see [Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md) and [Compile Page, Project Designer (Visual Basic)](/visualstudio/ide/reference/compile-page-project-designer-visual-basic).  \n  \n## See also\n\n- [Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)\n- [Early and Late Binding](../../../../visual-basic/programming-guide/language-features/early-late-binding/index.md)\n- [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)\n- [For...Next Statement](../../../../visual-basic/language-reference/statements/for-next-statement.md)\n- [Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md)\n- [/optioninfer](../../../../visual-basic/reference/command-line-compiler/optioninfer.md)\n- [Introduction to LINQ in Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)\n","nodes":[{"pos":[4,453],"embed":true,"restype":"x-metadata","content":"title: \"Local Type Inference (Visual Basic)\"\nms.date: 07/20/2015\nf1_keywords: \n  - \"local type inference\"\n  - \"vb.TypeInfer\"\nhelpviewer_keywords: \n  - \"Option Infer statement [Visual Basic]\"\n  - \"local type inference [Visual Basic]\"\n  - \"implicitly-typed local variables [Visual Basic]\"\n  - \"variables [Visual Basic], type inference\"\n  - \"inference [Visual Basic]\"\n  - \"type inference [Visual Basic]\"\nms.assetid: b8307f18-2e56-4ab3-a45a-826873f400f6","nodes":[{"content":"Local Type Inference (Visual Basic)","nodes":[{"pos":[0,35],"content":"Local Type Inference (Visual Basic)","nodes":[{"content":"Local Type Inference (Visual Basic)","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[460,495],"content":"Local Type Inference (Visual Basic)","linkify":"Local Type Inference (Visual Basic)","nodes":[{"content":"Local Type Inference (Visual Basic)","pos":[0,35]}]},{"content":"The Visual Basic compiler uses <bpt id=\"p1\">*</bpt>type inference<ept id=\"p1\">*</ept> to determine the data types of local variables declared without an <ph id=\"ph1\">`As`</ph> clause.","pos":[496,623],"source":"The Visual Basic compiler uses *type inference* to determine the data types of local variables declared without an `As` clause."},{"content":"The compiler infers the type of the variable from the type of the initialization expression.","pos":[624,716]},{"content":"This enables you to declare variables without explicitly stating a type, as shown in the following example.","pos":[717,824]},{"content":"As a result of the declarations, both <ph id=\"ph1\">`num1`</ph> and <ph id=\"ph2\">`num2`</ph> are strongly typed as integers.","pos":[825,912],"source":" As a result of the declarations, both `num1` and `num2` are strongly typed as integers."},{"pos":[1049,1249],"content":"[!NOTE]\n If you do not want `num2` in the previous example to be typed as an `Integer`, you can specify another type by using a declaration like `Dim num3 As Object = 3` or `Dim num4 As Double = 3`.","leadings":["","> "],"nodes":[{"content":"If you do not want <ph id=\"ph1\">`num2`</ph> in the previous example to be typed as an <ph id=\"ph2\">`Integer`</ph>, you can specify another type by using a declaration like <ph id=\"ph3\">`Dim num3 As Object = 3`</ph> or <ph id=\"ph4\">`Dim num4 As Double = 3`</ph>.","pos":[9,198],"source":"If you do not want `num2` in the previous example to be typed as an `Integer`, you can specify another type by using a declaration like `Dim num3 As Object = 3` or `Dim num4 As Double = 3`."}]},{"pos":[1255,1412],"content":"[!NOTE]\n Type inference can be used only for non-static local variables; it cannot be used to determine the type of class fields, properties, or functions.","leadings":["","> "],"nodes":[{"content":"Type inference can be used only for non-static local variables; it cannot be used to determine the type of class fields, properties, or functions.","pos":[9,155]}]},{"content":"Local type inference applies at procedure level.","pos":[1416,1464]},{"content":"It cannot be used to declare variables at module level (within a class, structure, module, or interface but not within a procedure or block).","pos":[1465,1606]},{"content":"If <ph id=\"ph1\">`num2`</ph> in the previous example were a field of a class instead of a local variable in a procedure, the declaration would cause an error with <ph id=\"ph2\">`Option Strict`</ph> on, and would classify <ph id=\"ph3\">`num2`</ph> as an <ph id=\"ph4\">`Object`</ph> with <ph id=\"ph5\">`Option Strict`</ph> off.","pos":[1607,1837],"source":" If `num2` in the previous example were a field of a class instead of a local variable in a procedure, the declaration would cause an error with `Option Strict` on, and would classify `num2` as an `Object` with `Option Strict` off."},{"content":"Similarly, local type inference does not apply to procedure level variables declared as <ph id=\"ph1\">`Static`</ph>.","pos":[1838,1935],"source":" Similarly, local type inference does not apply to procedure level variables declared as `Static`."},{"pos":[1944,1975],"content":"Type Inference vs. Late Binding","linkify":"Type Inference vs. Late Binding","nodes":[{"content":"Type Inference vs. Late Binding","pos":[0,31]}]},{"content":"Code that uses type inference resembles code that relies on late binding.","pos":[1979,2052]},{"content":"However, type inference strongly types the variable instead of leaving it as <ph id=\"ph1\">`Object`</ph>.","pos":[2053,2139],"source":" However, type inference strongly types the variable instead of leaving it as `Object`."},{"content":"The compiler uses a variable's initializer to determine the variable's type at compile time to produce early-bound code.","pos":[2140,2260]},{"content":"In the previous example, <ph id=\"ph1\">`num2`</ph>, like <ph id=\"ph2\">`num1`</ph>, is typed as an <ph id=\"ph3\">`Integer`</ph>.","pos":[2261,2332],"source":" In the previous example, `num2`, like `num1`, is typed as an `Integer`."},{"content":"The behavior of early-bound variables differs from that of late-bound variables, for which the type is known only at run time.","pos":[2339,2465]},{"content":"Knowing the type early enables the compiler to identify problems before execution, allocate memory precisely, and perform other optimizations.","pos":[2466,2608]},{"content":"Early binding also enables the Visual Basic integrated development environment (IDE) to provide IntelliSense Help about the members of an object.","pos":[2609,2754]},{"content":"Early binding is also preferred for performance.","pos":[2755,2803]},{"content":"This is because all data stored in a late-bound variable must be wrapped as type <ph id=\"ph1\">`Object`</ph>, and accessing members of the type at run time makes the program slower.","pos":[2804,2966],"source":" This is because all data stored in a late-bound variable must be wrapped as type `Object`, and accessing members of the type at run time makes the program slower."},{"pos":[2975,2983],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"content":"Type inference occurs when a local variable is declared without an <ph id=\"ph1\">`As`</ph> clause and initialized.","pos":[2987,3082],"source":"Type inference occurs when a local variable is declared without an `As` clause and initialized."},{"content":"The compiler uses the type of the assigned initial value as the type of the variable.","pos":[3083,3168]},{"content":"For example, each of the following lines of code declares a variable of type <ph id=\"ph1\">`String`</ph>.","pos":[3169,3255],"source":" For example, each of the following lines of code declares a variable of type `String`."},{"content":"The following code demonstrates two equivalent ways to create an array of integers.","pos":[3392,3475]},{"content":"It is convenient to use type inference to determine the type of a loop control variable.","pos":[3612,3700]},{"content":"In the following code, the compiler infers that <ph id=\"ph1\">`number`</ph> is an <ph id=\"ph2\">`Integer`</ph> because <ph id=\"ph3\">`someNumbers2`</ph> from the previous example is an array of integers.","pos":[3701,3847],"source":" In the following code, the compiler infers that `number` is an `Integer` because `someNumbers2` from the previous example is an array of integers."},{"pos":[3984,4121],"content":"Local type inference can be used in <ph id=\"ph1\">`Using`</ph> statements to establish the type of the resource name, as the following example demonstrates.","source":"Local type inference can be used in `Using` statements to establish the type of the resource name, as the following example demonstrates."},{"content":"The type of a variable can also be inferred from the return values of functions, as the following example demonstrates.","pos":[4258,4377]},{"content":"Both <ph id=\"ph1\">`pList1`</ph> and <ph id=\"ph2\">`pList2`</ph> are arrays of processes because <ph id=\"ph3\">`Process.GetProcesses`</ph> returns an array of processes.","pos":[4378,4490],"source":" Both `pList1` and `pList2` are arrays of processes because `Process.GetProcesses` returns an array of processes."},{"pos":[4629,4641],"content":"Option Infer","linkify":"Option Infer","nodes":[{"content":"Option Infer","pos":[0,12]}]},{"content":"<ph id=\"ph1\">`Option Infer`</ph> enables you specify whether local type inference is allowed in a particular file.","pos":[4645,4741],"source":"`Option Infer` enables you specify whether local type inference is allowed in a particular file."},{"content":"To enable or to block the option, type one of the following statements at the start of the file.","pos":[4742,4838]},{"content":"If you do not specify a value for <ph id=\"ph1\">`Option Infer`</ph> in your code, the compiler default is <ph id=\"ph2\">`Option Infer On`</ph>.","pos":[4894,4999],"source":"If you do not specify a value for `Option Infer` in your code, the compiler default is `Option Infer On`."},{"content":"For projects upgraded from <ph id=\"ph1\">[!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)]</ph> or earlier, the compiler default is <ph id=\"ph2\">`Option Infer Off`</ph>.","pos":[5000,5140],"source":" For projects upgraded from [!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)] or earlier, the compiler default is `Option Infer Off`."},{"pos":[5147,5294],"content":"If the value set for <ph id=\"ph1\">`Option Infer`</ph> in a file conflicts with the value set in the IDE or on the command line, the value in the file has precedence.","source":"If the value set for `Option Infer` in a file conflicts with the value set in the IDE or on the command line, the value in the file has precedence."},{"pos":[5301,5558],"content":"For more information, see <bpt id=\"p1\">[</bpt>Option Infer Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept> and <bpt id=\"p2\">[</bpt>Compile Page, Project Designer (Visual Basic)<ept id=\"p2\">](/visualstudio/ide/reference/compile-page-project-designer-visual-basic)</ept>.","source":"For more information, see [Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md) and [Compile Page, Project Designer (Visual Basic)](/visualstudio/ide/reference/compile-page-project-designer-visual-basic)."},{"pos":[5567,5575],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5579,5697],"content":"<bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>","source":"[Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)"},{"pos":[5700,5814],"content":"<bpt id=\"p1\">[</bpt>Early and Late Binding<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/early-late-binding/index.md)</ept>","source":"[Early and Late Binding](../../../../visual-basic/programming-guide/language-features/early-late-binding/index.md)"},{"pos":[5817,5927],"content":"<bpt id=\"p1\">[</bpt>For Each...Next Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)</ept>","source":"[For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)"},{"pos":[5930,6030],"content":"<bpt id=\"p1\">[</bpt>For...Next Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/for-next-statement.md)</ept>","source":"[For...Next Statement](../../../../visual-basic/language-reference/statements/for-next-statement.md)"},{"pos":[6033,6139],"content":"<bpt id=\"p1\">[</bpt>Option Infer Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept>","source":"[Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md)"},{"pos":[6142,6229],"content":"<bpt id=\"p1\">[</bpt>/optioninfer<ept id=\"p1\">](../../../../visual-basic/reference/command-line-compiler/optioninfer.md)</ept>","source":"[/optioninfer](../../../../visual-basic/reference/command-line-compiler/optioninfer.md)"},{"pos":[6232,6361],"content":"<bpt id=\"p1\">[</bpt>Introduction to LINQ in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept>","source":"[Introduction to LINQ in Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)"}]}