{"content":"---\ntitle: \"XAML Namespaces and Namespace Mapping for WPF XAML | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"custom classes, mapping namespaces to\"\n  - \"XAML, namespaces\"\n  - \"namespace mapping\"\n  - \"assemblies, mapping namespaces to\"\n  - \"mapping namespaces\"\n  - \"XAML, namespace mapping\"\n  - \"classes, mapping namespaces to\"\n  - \"namespaces\"\nms.assetid: 5c0854e3-7470-435d-9fe2-93eec9d3634e\ncaps.latest.revision: 23\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# XAML Namespaces and Namespace Mapping for WPF XAML\nThis topic further explains the presence and purpose of the two XAML namespace mappings as often found in the root tag of a WPF XAML file. It also describes how to produce similar mappings for using elements that are defined in your own code, and/or within separate assemblies.  \n  \n  \n## What is a XAML Namespace?  \n A XAML namespace is really an extension of the concept of an XML namespace. The techniques of specifying a XAML namespace rely on the XML namespace syntax, the convention of using URIs as namespace identifiers, using prefixes to provide a means to reference multiple namespaces from the same markup source, and so on. The primary concept that is added to the XAML definition of the XML namespace is that a XAML namespace implies both a scope of uniqueness for the markup usages, and also influences how markup entities are potentially backed by specific CLR namespaces and referenced assemblies. This latter consideration is also influenced by the concept of a XAML schema context. But for purposes of how WPF works with XAML namespaces, you can generally think of XAML namespaces in terms of a default XAML namespace, the XAML language namespace, and any further XAML namespaces as mapped by your XAML markup directly to specific backing CLR namespaces and referenced assemblies.  \n  \n<a name=\"The_WPF_and_XAML_Namespace_Declarations\"></a>   \n## The WPF and XAML Namespace Declarations  \n Within the namespace declarations in the root tag of many XAML files, you will see that there are typically two XML namespace declarations. The first declaration maps the overall WPF client / framework XAML namespace as the default:  \n  \n `xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"`  \n  \n The second declaration maps a separate XAML namespace, mapping it (typically) to the `x:` prefix.  \n  \n `xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"`  \n  \n The relationship between these declarations is that the `x:` prefix mapping supports the intrinsics that are part of the XAML language definition, and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is one implementation that uses XAML as a language and defines a vocabulary of its objects for XAML. Because the WPF vocabulary's usages will be far more common than the XAML intrinsics usages, the WPF vocabulary is mapped as the default.  \n  \n The `x:` prefix convention for mapping the XAML language intrinsics support is followed by project templates, sample code, and the documentation of language features within this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]. The XAML namespace defines many commonly-used features that are necessary even for basic WPF  applications. For instance, in order to join any code-behind to a XAML file through a partial class, you must name that class as the `x:Class` attribute in the root element of the relevant XAML file. Or, any element as defined in a XAML page that you wish to access as a keyed resource should have the `x:Key` attribute set on the element in question. For more information on these and other aspects of XAML see [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md) or [XAML Syntax In Detail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).  \n  \n<a name=\"Mapping_To_Custom_Classes_and_Assemblies\"></a>   \n## Mapping to Custom Classes and Assemblies  \n You can map XML namespaces to assemblies using a series of tokens within an `xmlns` prefix declaration, similar to how the standard WPF and XAML-intrinsics XAML namespaces are mapped to prefixes.  \n  \n The syntax takes the following possible named tokens and following values:  \n  \n `clr-namespace:` The CLR namespace declared within the assembly that contains the public types to expose as elements.  \n  \n `assembly=` The assembly that contains some or all of the referenced [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespace. This value is typically just the name of the assembly, not the path, and does not include the extension (such as .dll or .exe). The path to that assembly must be established as a project reference in the project file that contains the XAML you are trying to map. In order to incorporate versioning and strong-name signing, the `assembly` value can be a string as defined by <xref:System.Reflection.AssemblyName>, rather than the simple string name.  \n  \n Note that the character separating the `clr-namespace` token from its value is a colon (:) whereas the character separating the `assembly` token from its value is an equals sign (=). The character to use between these two tokens is a semicolon. Also, do not include any whitespace anywhere in the declaration.  \n  \n### A Basic Custom Mapping Example  \n The following code defines an example custom class:  \n  \n```csharp  \nnamespace SDKSample {  \n    public class ExampleClass : ContentControl {  \n        public ExampleClass() {  \n        ...  \n        }  \n    }  \n}  \n```  \n  \n```vb  \nNamespace SDKSample  \n    Public Class ExampleClass  \n        Inherits ContentControl  \n         ...  \n        Public Sub New()  \n        End Sub  \n    End Class  \nEnd Namespace  \n```  \n  \n This custom class is then compiled into a library, which per the project settings (not shown) is named `SDKSampleLibrary`.  \n  \n In order to reference this custom class, you also need to include it as a reference for your current project, which you would typically do using the Solution Explorer UI in Visual Studio.  \n  \n Now that you have a library containing a class, and a reference to it in project settings, you can add the following prefix mapping as part of your root element in XAML:  \n  \n `xmlns:custom=\"clr-namespace:SDKSample;assembly=SDKSampleLibrary\"`  \n  \n To put it all together, the following is XAML that includes the custom mapping along with the typical default and x: mappings in the root tag, then uses a prefixed reference to instantiate `ExampleClass` in that UI:  \n  \n```xaml  \n<Page x:Class=\"WPFApplication1.MainPage\"  \n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"   \n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  \n    xmlns:custom=\"clr-namespace:SDKSample;assembly=SDKSampleLibrary\">  \n  ...  \n  <custom:ExampleClass/>  \n...  \n</Page>  \n```  \n  \n### Mapping to Current Assemblies  \n `assembly` can be omitted if the `clr-namespace` referenced is being defined within the same assembly as the application code that is referencing the custom classes. Or, an equivalent syntax for this case is to specify `assembly=`, with no string token following the equals sign.  \n  \n Custom classes cannot be used as the root element of a page if defined in the same assembly. Partial classes do not need to be mapped; only classes that are not the partial class of a page in your application need to be mapped if you intend to reference them as elements in XAML.  \n  \n<a name=\"Mapping_CLR_Namespaces_to_XML_Namespaces_in_an\"></a>   \n## Mapping CLR Namespaces to XML Namespaces in an Assembly  \n WPF defines a CLR attribute that is consumed by XAML processors in order to map multiple CLR namespaces to a single XAML namespace. This attribute, <xref:System.Windows.Markup.XmlnsDefinitionAttribute>, is placed at the assembly level in the source code that produces the assembly. The WPF assembly source code uses this attribute to map the various common namespaces, such as <xref:System.Windows> and <xref:System.Windows.Controls>, to the [!INCLUDE[TLA#tla_wpfxmlnsv1](../../../../includes/tlasharptla-wpfxmlnsv1-md.md)] namespace.  \n  \n The <xref:System.Windows.Markup.XmlnsDefinitionAttribute> takes two parameters: the XML/XAML namespace name, and the CLR namespace name. More than one <xref:System.Windows.Markup.XmlnsDefinitionAttribute> can exist to map multiple CLR namespaces to the same XML namespace. Once mapped, members of those namespaces can also be referenced without full qualification if desired by providing the appropriate `using` statement in the partial-class code-behind page. For more details, see <xref:System.Windows.Markup.XmlnsDefinitionAttribute>.  \n  \n## Designer Namespaces and Other Prefixes From XAML Templates  \n If you are working with development environments and/or design tools for WPF XAML, you may notice that there are other defined XAML namespaces / prefixes within the XAML markup.  \n  \n [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] uses a designer namespace that is typically mapped to the prefix `d:`. More recent project templates for WPF might pre-map this XAML namespace to support interchange of the XAML between [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] and other design environments. This design XAML namespace is used to perpetuate design state while roundtripping XAML-based UI in the designer. It is also used for features such as `d:IsDataSource`, which enable runtime data sources in a designer.  \n  \n Another prefix you might see mapped is `mc:`. `mc:` is for markup compatibility, and is leveraging a markup compatibility pattern that is not necessarily XAML-specific. To some extent, the markup compatibility features can be used to exchange XAML between frameworks or across other boundaries of backing implementation, work between XAML schema contexts, provide compatibility for limited modes in designers, and so on. For more information on markup compatibility concepts and how they relate to WPF, see  [Markup Compatibility (mc:) Language Features](../../../../docs/framework/wpf/advanced/markup-compatibility-mc-language-features.md).  \n  \n## WPF and Assembly Loading  \n The XAML schema context for WPF integrates with the WPF application model, which in turn uses the CLR-defined concept of <xref:System.AppDomain>. The following sequence describes how XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the WPF use of <xref:System.AppDomain> and other factors.  \n  \n1.  Iterate through the <xref:System.AppDomain>, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.  \n  \n2.  If the name is qualified, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName> on the qualified name.  \n  \n3.  If the short name + public key token of a qualified name matches the assembly that the markup was loaded from, return that assembly.  \n  \n4.  Use the short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName>.  \n  \n5.  If the name is unqualified, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=fullName>.  \n  \n Loose XAML does not use Step 3; there is no loaded-from assembly.  \n  \n Compiled XAML for WPF (generated via XamlBuildTask) does not use the already-loaded assemblies from <xref:System.AppDomain> (Step 1). Also, the name should never be unqualified from XamlBuildTask output, so Step 5 does not apply.  \n  \n Compiled BAML (generated via PresentationBuildTask) uses all steps, although BAML also should not contain unqualified assembly names.  \n  \n## See Also  \n [Understanding XML Namespaces](http://go.microsoft.com/fwlink/?LinkId=98069)   \n [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)\n","nodes":[{"pos":[4,642],"nodes":[{"content":"XAML Namespaces and Namespace Mapping for WPF XAML | Microsoft Docs","nodes":[{"pos":[0,67],"content":"XAML Namespaces and Namespace Mapping for WPF XAML | Microsoft Docs","nodes":[{"content":"XAML Namespaces and Namespace Mapping for WPF XAML | Microsoft Docs","pos":[0,67]}]}],"pos":[6,76],"yaml":true}],"content":"title: \"XAML Namespaces and Namespace Mapping for WPF XAML | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"custom classes, mapping namespaces to\"\n  - \"XAML, namespaces\"\n  - \"namespace mapping\"\n  - \"assemblies, mapping namespaces to\"\n  - \"mapping namespaces\"\n  - \"XAML, namespace mapping\"\n  - \"classes, mapping namespaces to\"\n  - \"namespaces\"\nms.assetid: 5c0854e3-7470-435d-9fe2-93eec9d3634e\ncaps.latest.revision: 23\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","yamlblock":true},{"pos":[649,699],"content":"XAML Namespaces and Namespace Mapping for WPF XAML","linkify":"XAML Namespaces and Namespace Mapping for WPF XAML","nodes":[{"content":"XAML Namespaces and Namespace Mapping for WPF XAML","pos":[0,50]}]},{"content":"This topic further explains the presence and purpose of the two XAML namespace mappings as often found in the root tag of a WPF XAML file.","pos":[700,838]},{"content":"It also describes how to produce similar mappings for using elements that are defined in your own code, and/or within separate assemblies.","pos":[839,977]},{"pos":[989,1014],"content":"What is a XAML Namespace?","linkify":"What is a XAML Namespace?","nodes":[{"content":"What is a XAML Namespace?","pos":[0,25]}]},{"content":"A XAML namespace is really an extension of the concept of an XML namespace.","pos":[1018,1093]},{"content":"The techniques of specifying a XAML namespace rely on the XML namespace syntax, the convention of using URIs as namespace identifiers, using prefixes to provide a means to reference multiple namespaces from the same markup source, and so on.","pos":[1094,1335]},{"content":"The primary concept that is added to the XAML definition of the XML namespace is that a XAML namespace implies both a scope of uniqueness for the markup usages, and also influences how markup entities are potentially backed by specific CLR namespaces and referenced assemblies.","pos":[1336,1613]},{"content":"This latter consideration is also influenced by the concept of a XAML schema context.","pos":[1614,1699]},{"content":"But for purposes of how WPF works with XAML namespaces, you can generally think of XAML namespaces in terms of a default XAML namespace, the XAML language namespace, and any further XAML namespaces as mapped by your XAML markup directly to specific backing CLR namespaces and referenced assemblies.","pos":[1700,1998]},{"pos":[2065,2104],"content":"The WPF and XAML Namespace Declarations","linkify":"The WPF and XAML Namespace Declarations","nodes":[{"content":"The WPF and XAML Namespace Declarations","pos":[0,39]}]},{"content":"Within the namespace declarations in the root tag of many XAML files, you will see that there are typically two XML namespace declarations.","pos":[2108,2247]},{"content":"The first declaration maps the overall WPF client / framework XAML namespace as the default:","pos":[2248,2340]},{"pos":[2421,2518],"content":"The second declaration maps a separate XAML namespace, mapping it (typically) to the <ph id=\"ph1\">`x:`</ph> prefix.","source":"The second declaration maps a separate XAML namespace, mapping it (typically) to the `x:` prefix."},{"content":"The relationship between these declarations is that the <ph id=\"ph1\">`x:`</ph> prefix mapping supports the intrinsics that are part of the XAML language definition, and <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is one implementation that uses XAML as a language and defines a vocabulary of its objects for XAML.","pos":[2588,2921],"source":"The relationship between these declarations is that the `x:` prefix mapping supports the intrinsics that are part of the XAML language definition, and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is one implementation that uses XAML as a language and defines a vocabulary of its objects for XAML."},{"content":"Because the WPF vocabulary's usages will be far more common than the XAML intrinsics usages, the WPF vocabulary is mapped as the default.","pos":[2922,3059]},{"content":"The <ph id=\"ph1\">`x:`</ph> prefix convention for mapping the XAML language intrinsics support is followed by project templates, sample code, and the documentation of language features within this <ph id=\"ph2\">[!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]</ph>.","pos":[3066,3314],"source":"The `x:` prefix convention for mapping the XAML language intrinsics support is followed by project templates, sample code, and the documentation of language features within this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]."},{"content":"The XAML namespace defines many commonly-used features that are necessary even for basic WPF  applications.","pos":[3315,3422]},{"content":"For instance, in order to join any code-behind to a XAML file through a partial class, you must name that class as the <ph id=\"ph1\">`x:Class`</ph> attribute in the root element of the relevant XAML file.","pos":[3423,3608],"source":" For instance, in order to join any code-behind to a XAML file through a partial class, you must name that class as the `x:Class` attribute in the root element of the relevant XAML file."},{"content":"Or, any element as defined in a XAML page that you wish to access as a keyed resource should have the <ph id=\"ph1\">`x:Key`</ph> attribute set on the element in question.","pos":[3609,3760],"source":" Or, any element as defined in a XAML page that you wish to access as a keyed resource should have the `x:Key` attribute set on the element in question."},{"content":"For more information on these and other aspects of XAML see <bpt id=\"p1\">[</bpt>XAML Overview (WPF)<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)</ept> or <bpt id=\"p2\">[</bpt>XAML Syntax In Detail<ept id=\"p2\">](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.","pos":[3761,3998],"source":" For more information on these and other aspects of XAML see [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md) or [XAML Syntax In Detail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)."},{"pos":[4066,4106],"content":"Mapping to Custom Classes and Assemblies","linkify":"Mapping to Custom Classes and Assemblies","nodes":[{"content":"Mapping to Custom Classes and Assemblies","pos":[0,40]}]},{"pos":[4110,4305],"content":"You can map XML namespaces to assemblies using a series of tokens within an <ph id=\"ph1\">`xmlns`</ph> prefix declaration, similar to how the standard WPF and XAML-intrinsics XAML namespaces are mapped to prefixes.","source":"You can map XML namespaces to assemblies using a series of tokens within an `xmlns` prefix declaration, similar to how the standard WPF and XAML-intrinsics XAML namespaces are mapped to prefixes."},{"content":"The syntax takes the following possible named tokens and following values:","pos":[4312,4386]},{"pos":[4393,4510],"content":"<ph id=\"ph1\">`clr-namespace:`</ph> The CLR namespace declared within the assembly that contains the public types to expose as elements.","source":"`clr-namespace:` The CLR namespace declared within the assembly that contains the public types to expose as elements."},{"content":"<ph id=\"ph1\">`assembly=`</ph> The assembly that contains some or all of the referenced <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> namespace.","pos":[4517,4666],"source":"`assembly=` The assembly that contains some or all of the referenced [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespace."},{"content":"This value is typically just the name of the assembly, not the path, and does not include the extension (such as .dll or .exe).","pos":[4667,4794]},{"content":"The path to that assembly must be established as a project reference in the project file that contains the XAML you are trying to map.","pos":[4795,4929]},{"content":"In order to incorporate versioning and strong-name signing, the <ph id=\"ph1\">`assembly`</ph> value can be a string as defined by <ph id=\"ph2\">&lt;xref:System.Reflection.AssemblyName&gt;</ph>, rather than the simple string name.","pos":[4930,5115],"source":" In order to incorporate versioning and strong-name signing, the `assembly` value can be a string as defined by <xref:System.Reflection.AssemblyName>, rather than the simple string name."},{"content":"Note that the character separating the <ph id=\"ph1\">`clr-namespace`</ph> token from its value is a colon (:) whereas the character separating the <ph id=\"ph2\">`assembly`</ph> token from its value is an equals sign (=).","pos":[5122,5304],"source":"Note that the character separating the `clr-namespace` token from its value is a colon (:) whereas the character separating the `assembly` token from its value is an equals sign (=)."},{"content":"The character to use between these two tokens is a semicolon.","pos":[5305,5366]},{"content":"Also, do not include any whitespace anywhere in the declaration.","pos":[5367,5431]},{"pos":[5441,5471],"content":"A Basic Custom Mapping Example","linkify":"A Basic Custom Mapping Example","nodes":[{"content":"A Basic Custom Mapping Example","pos":[0,30]}]},{"content":"The following code defines an example custom class:","pos":[5475,5526]},{"pos":[5898,6020],"content":"This custom class is then compiled into a library, which per the project settings (not shown) is named <ph id=\"ph1\">`SDKSampleLibrary`</ph>.","source":"This custom class is then compiled into a library, which per the project settings (not shown) is named `SDKSampleLibrary`."},{"content":"In order to reference this custom class, you also need to include it as a reference for your current project, which you would typically do using the Solution Explorer UI in Visual Studio.","pos":[6027,6214]},{"content":"Now that you have a library containing a class, and a reference to it in project settings, you can add the following prefix mapping as part of your root element in XAML:","pos":[6221,6390]},{"pos":[6470,6685],"content":"To put it all together, the following is XAML that includes the custom mapping along with the typical default and x: mappings in the root tag, then uses a prefixed reference to instantiate <ph id=\"ph1\">`ExampleClass`</ph> in that UI:","source":"To put it all together, the following is XAML that includes the custom mapping along with the typical default and x: mappings in the root tag, then uses a prefixed reference to instantiate `ExampleClass` in that UI:"},{"pos":[7014,7043],"content":"Mapping to Current Assemblies","linkify":"Mapping to Current Assemblies","nodes":[{"content":"Mapping to Current Assemblies","pos":[0,29]}]},{"content":"<ph id=\"ph1\">`assembly`</ph> can be omitted if the <ph id=\"ph2\">`clr-namespace`</ph> referenced is being defined within the same assembly as the application code that is referencing the custom classes.","pos":[7047,7212],"source":"`assembly` can be omitted if the `clr-namespace` referenced is being defined within the same assembly as the application code that is referencing the custom classes."},{"content":"Or, an equivalent syntax for this case is to specify <ph id=\"ph1\">`assembly=`</ph>, with no string token following the equals sign.","pos":[7213,7326],"source":" Or, an equivalent syntax for this case is to specify `assembly=`, with no string token following the equals sign."},{"content":"Custom classes cannot be used as the root element of a page if defined in the same assembly.","pos":[7333,7425]},{"content":"Partial classes do not need to be mapped; only classes that are not the partial class of a page in your application need to be mapped if you intend to reference them as elements in XAML.","pos":[7426,7612]},{"pos":[7686,7741],"content":"Mapping CLR Namespaces to XML Namespaces in an Assembly","linkify":"Mapping CLR Namespaces to XML Namespaces in an Assembly","nodes":[{"content":"Mapping CLR Namespaces to XML Namespaces in an Assembly","pos":[0,55]}]},{"content":"WPF defines a CLR attribute that is consumed by XAML processors in order to map multiple CLR namespaces to a single XAML namespace.","pos":[7745,7876]},{"content":"This attribute, <ph id=\"ph1\">&lt;xref:System.Windows.Markup.XmlnsDefinitionAttribute&gt;</ph>, is placed at the assembly level in the source code that produces the assembly.","pos":[7877,8026],"source":" This attribute, <xref:System.Windows.Markup.XmlnsDefinitionAttribute>, is placed at the assembly level in the source code that produces the assembly."},{"content":"The WPF assembly source code uses this attribute to map the various common namespaces, such as <ph id=\"ph1\">&lt;xref:System.Windows&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Controls&gt;</ph>, to the <ph id=\"ph3\">[!INCLUDE[TLA#tla_wpfxmlnsv1](../../../../includes/tlasharptla-wpfxmlnsv1-md.md)]</ph> namespace.","pos":[8027,8279],"source":" The WPF assembly source code uses this attribute to map the various common namespaces, such as <xref:System.Windows> and <xref:System.Windows.Controls>, to the [!INCLUDE[TLA#tla_wpfxmlnsv1](../../../../includes/tlasharptla-wpfxmlnsv1-md.md)] namespace."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Markup.XmlnsDefinitionAttribute&gt;</ph> takes two parameters: the XML/XAML namespace name, and the CLR namespace name.","pos":[8286,8422],"source":"The <xref:System.Windows.Markup.XmlnsDefinitionAttribute> takes two parameters: the XML/XAML namespace name, and the CLR namespace name."},{"content":"More than one <ph id=\"ph1\">&lt;xref:System.Windows.Markup.XmlnsDefinitionAttribute&gt;</ph> can exist to map multiple CLR namespaces to the same XML namespace.","pos":[8423,8558],"source":" More than one <xref:System.Windows.Markup.XmlnsDefinitionAttribute> can exist to map multiple CLR namespaces to the same XML namespace."},{"content":"Once mapped, members of those namespaces can also be referenced without full qualification if desired by providing the appropriate <ph id=\"ph1\">`using`</ph> statement in the partial-class code-behind page.","pos":[8559,8746],"source":" Once mapped, members of those namespaces can also be referenced without full qualification if desired by providing the appropriate `using` statement in the partial-class code-behind page."},{"content":"For more details, see <ph id=\"ph1\">&lt;xref:System.Windows.Markup.XmlnsDefinitionAttribute&gt;</ph>.","pos":[8747,8823],"source":" For more details, see <xref:System.Windows.Markup.XmlnsDefinitionAttribute>."},{"pos":[8832,8890],"content":"Designer Namespaces and Other Prefixes From XAML Templates","linkify":"Designer Namespaces and Other Prefixes From XAML Templates","nodes":[{"content":"Designer Namespaces and Other Prefixes From XAML Templates","pos":[0,58]}]},{"content":"If you are working with development environments and/or design tools for WPF XAML, you may notice that there are other defined XAML namespaces / prefixes within the XAML markup.","pos":[8894,9071]},{"content":"<ph id=\"ph1\">[!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)]</ph> uses a designer namespace that is typically mapped to the prefix <ph id=\"ph2\">`d:`</ph>.","pos":[9078,9238],"source":"[!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] uses a designer namespace that is typically mapped to the prefix `d:`."},{"content":"More recent project templates for WPF might pre-map this XAML namespace to support interchange of the XAML between <ph id=\"ph1\">[!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)]</ph> and other design environments.","pos":[9239,9474],"source":" More recent project templates for WPF might pre-map this XAML namespace to support interchange of the XAML between [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] and other design environments."},{"content":"This design XAML namespace is used to perpetuate design state while roundtripping XAML-based UI in the designer.","pos":[9475,9587]},{"content":"It is also used for features such as <ph id=\"ph1\">`d:IsDataSource`</ph>, which enable runtime data sources in a designer.","pos":[9588,9691],"source":" It is also used for features such as `d:IsDataSource`, which enable runtime data sources in a designer."},{"content":"Another prefix you might see mapped is <ph id=\"ph1\">`mc:`</ph>.","pos":[9698,9743],"source":"Another prefix you might see mapped is `mc:`."},{"content":"<ph id=\"ph1\">`mc:`</ph> is for markup compatibility, and is leveraging a markup compatibility pattern that is not necessarily XAML-specific.","pos":[9744,9866],"source":"`mc:` is for markup compatibility, and is leveraging a markup compatibility pattern that is not necessarily XAML-specific."},{"content":"To some extent, the markup compatibility features can be used to exchange XAML between frameworks or across other boundaries of backing implementation, work between XAML schema contexts, provide compatibility for limited modes in designers, and so on.","pos":[9867,10118]},{"content":"For more information on markup compatibility concepts and how they relate to WPF, see  <bpt id=\"p1\">[</bpt>Markup Compatibility (mc:) Language Features<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/markup-compatibility-mc-language-features.md)</ept>.","pos":[10119,10339],"source":" For more information on markup compatibility concepts and how they relate to WPF, see  [Markup Compatibility (mc:) Language Features](../../../../docs/framework/wpf/advanced/markup-compatibility-mc-language-features.md)."},{"pos":[10348,10372],"content":"WPF and Assembly Loading","linkify":"WPF and Assembly Loading","nodes":[{"content":"WPF and Assembly Loading","pos":[0,24]}]},{"content":"The XAML schema context for WPF integrates with the WPF application model, which in turn uses the CLR-defined concept of <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph>.","pos":[10376,10521],"source":"The XAML schema context for WPF integrates with the WPF application model, which in turn uses the CLR-defined concept of <xref:System.AppDomain>."},{"content":"The following sequence describes how XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the WPF use of <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> and other factors.","pos":[10522,10728],"source":" The following sequence describes how XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the WPF use of <xref:System.AppDomain> and other factors."},{"content":"Iterate through the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph>, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.","pos":[10738,10908],"source":"Iterate through the <xref:System.AppDomain>, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly."},{"content":"If the name is qualified, call <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName&gt;</ph> on the qualified name.","pos":[10918,11054],"source":"If the name is qualified, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName> on the qualified name."},{"content":"If the short name + public key token of a qualified name matches the assembly that the markup was loaded from, return that assembly.","pos":[11064,11196]},{"content":"Use the short name + public key token to call <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName&gt;</ph>.","pos":[11206,11335],"source":"Use the short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName>."},{"content":"If the name is unqualified, call <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=fullName&gt;</ph>.","pos":[11345,11460],"source":"If the name is unqualified, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=fullName>."},{"content":"Loose XAML does not use Step 3; there is no loaded-from assembly.","pos":[11467,11532]},{"content":"Compiled XAML for WPF (generated via XamlBuildTask) does not use the already-loaded assemblies from <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> (Step 1).","pos":[11539,11672],"source":"Compiled XAML for WPF (generated via XamlBuildTask) does not use the already-loaded assemblies from <xref:System.AppDomain> (Step 1)."},{"content":"Also, the name should never be unqualified from XamlBuildTask output, so Step 5 does not apply.","pos":[11673,11768]},{"content":"Compiled BAML (generated via PresentationBuildTask) uses all steps, although BAML also should not contain unqualified assembly names.","pos":[11775,11908]},{"pos":[11917,11925],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Understanding XML Namespaces<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=98069)</ept><ph id=\"ph1\"> </ph>","pos":[11929,12006],"source":"[Understanding XML Namespaces](http://go.microsoft.com/fwlink/?LinkId=98069) "},{"content":"<bpt id=\"p1\">[</bpt>XAML Overview (WPF)<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)</ept>","pos":[12010,12093],"source":"[XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)"}]}