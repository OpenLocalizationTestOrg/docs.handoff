{"content":"---\ntitle: \"Exceptions in Managed Threads\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"unhandled exceptions,in managed threads\"\n  - \"threading [.NET Framework],unhandled exceptions\"\n  - \"threading [.NET Framework],exceptions in managed threads\"\n  - \"managed threading\"\nms.assetid: 11294769-2e89-43cb-890e-ad4ad79cfbee\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Exceptions in Managed Threads\nStarting with the .NET Framework version 2.0, the common language runtime allows most unhandled exceptions in threads to proceed naturally. In most cases this means that the unhandled exception causes the application to terminate.  \n  \n> [!NOTE]\n>  This is a significant change from the .NET Framework versions 1.0 and 1.1, which provide a backstop for many unhandled exceptions — for example, unhandled exceptions in thread pool threads. See [Change from Previous Versions](#ChangeFromPreviousVersions) later in this topic.  \n  \n The common language runtime provides a backstop for certain unhandled exceptions that are used for controlling program flow:  \n  \n-   A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called.  \n  \n-   An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain in which the thread is executing is being unloaded.  \n  \n-   The common language runtime or a host process terminates the thread by throwing an internal exception.  \n  \n If any of these exceptions are unhandled in threads created by the common language runtime, the exception terminates the thread, but the common language runtime does not allow the exception to proceed further.  \n  \n If these exceptions are unhandled in the main thread, or in threads that entered the runtime from unmanaged code, they proceed normally, resulting in termination of the application.  \n  \n> [!NOTE]\n>  It is possible for the runtime to throw an unhandled exception before any managed code has had a chance to install an exception handler. Even though managed code had no chance to handle such an exception, the exception is allowed to proceed naturally.  \n  \n## Exposing Threading Problems During Development  \n When threads are allowed to fail silently, without terminating the application, serious programming problems can go undetected. This is a particular problem for services and other applications which run for extended periods. As threads fail, program state gradually becomes corrupted. Application performance may degrade, or the application might hang.  \n  \n Allowing unhandled exceptions in threads to proceed naturally, until the operating system terminates the program, exposes such problems during development and testing. Error reports on program terminations support debugging.  \n  \n<a name=\"ChangeFromPreviousVersions\"></a>   \n## Change from Previous Versions  \n The most significant change pertains to managed threads. In the .NET Framework versions 1.0 and 1.1, the common language runtime provides a backstop for unhandled exceptions in the following situations:  \n  \n-   There is no such thing as an unhandled exception on a thread pool thread. When a task throws an exception that it does not handle, the runtime prints the exception stack trace to the console and then returns the thread to the thread pool.  \n  \n-   There is no such thing as an unhandled exception on a thread created with the <xref:System.Threading.Thread.Start%2A> method of the <xref:System.Threading.Thread> class. When code running on such a thread throws an exception that it does not handle, the runtime prints the exception stack trace to the console and then gracefully terminates the thread.  \n  \n-   There is no such thing as an unhandled exception on the finalizer thread. When a finalizer throws an exception that it does not handle, the runtime prints the exception stack trace to the console and then allows the finalizer thread to resume running finalizers.  \n  \n The foreground or background status of a managed thread does not affect this behavior.  \n  \n For unhandled exceptions on threads originating in unmanaged code, the difference is more subtle. The runtime JIT-attach dialog preempts the operating system dialog for managed exceptions or native exceptions on threads that have passed through native code. The process terminates in all cases.  \n  \n### Migrating Code  \n In general, the change will expose previously unrecognized programming problems so that they can be fixed. In some cases, however, programmers might have taken advantage of the runtime backstop, for example to terminate threads. Depending on the situation, they should consider one of the following migration strategies:  \n  \n-   Restructure the code so the thread exits gracefully when a signal is received.  \n  \n-   Use the <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> method to abort the thread.  \n  \n-   If a thread must be stopped so that process termination can proceed, make the thread a background thread so that it is automatically terminated on process exit.  \n  \n In all cases, the strategy should follow the design guidelines for exceptions. See [Design Guidelines for Exceptions](../../../docs/standard/design-guidelines/exceptions.md).  \n  \n### Application Compatibility Flag  \n As a temporary compatibility measure, administrators can place a compatibility flag in the `<runtime>` section of the application configuration file. This causes the common language runtime to revert to the behavior of versions 1.0 and 1.1.  \n  \n```xml  \n<legacyUnhandledExceptionPolicy enabled=\"1\"/>  \n```  \n  \n## Host Override  \n In the .NET Framework version 2.0, an unmanaged host can use the [ICLRPolicyManager](../../../docs/framework/unmanaged-api/hosting/iclrpolicymanager-interface.md) interface in the Hosting API to override the default unhandled exception policy of the common language runtime. The [ICLRPolicyManager::SetUnhandledExceptionPolicy](../../../docs/framework/unmanaged-api/hosting/iclrpolicymanager-setunhandledexceptionpolicy-method.md) function is used to set the policy for unhandled exceptions.  \n  \n## See also\n\n- [Managed Threading Basics](../../../docs/standard/threading/managed-threading-basics.md)\n","nodes":[{"pos":[4,393],"embed":true,"restype":"x-metadata","content":"title: \"Exceptions in Managed Threads\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"unhandled exceptions,in managed threads\"\n  - \"threading [.NET Framework],unhandled exceptions\"\n  - \"threading [.NET Framework],exceptions in managed threads\"\n  - \"managed threading\"\nms.assetid: 11294769-2e89-43cb-890e-ad4ad79cfbee\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Exceptions in Managed Threads","nodes":[{"pos":[0,29],"content":"Exceptions in Managed Threads","nodes":[{"content":"Exceptions in Managed Threads","pos":[0,29]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[400,429],"content":"Exceptions in Managed Threads","linkify":"Exceptions in Managed Threads","nodes":[{"content":"Exceptions in Managed Threads","pos":[0,29]}]},{"content":"Starting with the .NET Framework version 2.0, the common language runtime allows most unhandled exceptions in threads to proceed naturally.","pos":[430,569]},{"content":"In most cases this means that the unhandled exception causes the application to terminate.","pos":[570,660]},{"pos":[668,954],"content":"[!NOTE]\n This is a significant change from the .NET Framework versions 1.0 and 1.1, which provide a backstop for many unhandled exceptions — for example, unhandled exceptions in thread pool threads. See [Change from Previous Versions](#ChangeFromPreviousVersions) later in this topic.","leadings":["","> "],"nodes":[{"content":"This is a significant change from the .NET Framework versions 1.0 and 1.1, which provide a backstop for many unhandled exceptions — for example, unhandled exceptions in thread pool threads. See [Change from Previous Versions](#ChangeFromPreviousVersions) later in this topic.","pos":[9,284],"nodes":[{"content":"This is a significant change from the .NET Framework versions 1.0 and 1.1, which provide a backstop for many unhandled exceptions — for example, unhandled exceptions in thread pool threads.","pos":[0,189]},{"content":"See <bpt id=\"p1\">[</bpt>Change from Previous Versions<ept id=\"p1\">](#ChangeFromPreviousVersions)</ept> later in this topic.","pos":[190,275],"source":" See [Change from Previous Versions](#ChangeFromPreviousVersions) later in this topic."}]}]},{"content":"The common language runtime provides a backstop for certain unhandled exceptions that are used for controlling program flow:","pos":[961,1085]},{"pos":[1095,1223],"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is thrown in a thread because <ph id=\"ph2\">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> was called.","source":"A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called."},{"pos":[1233,1381],"content":"An <ph id=\"ph1\">&lt;xref:System.AppDomainUnloadedException&gt;</ph> is thrown in a thread because the application domain in which the thread is executing is being unloaded.","source":"An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain in which the thread is executing is being unloaded."},{"content":"The common language runtime or a host process terminates the thread by throwing an internal exception.","pos":[1391,1493]},{"content":"If any of these exceptions are unhandled in threads created by the common language runtime, the exception terminates the thread, but the common language runtime does not allow the exception to proceed further.","pos":[1500,1709]},{"content":"If these exceptions are unhandled in the main thread, or in threads that entered the runtime from unmanaged code, they proceed normally, resulting in termination of the application.","pos":[1716,1897]},{"pos":[1905,2167],"content":"[!NOTE]\n It is possible for the runtime to throw an unhandled exception before any managed code has had a chance to install an exception handler. Even though managed code had no chance to handle such an exception, the exception is allowed to proceed naturally.","leadings":["","> "],"nodes":[{"content":"It is possible for the runtime to throw an unhandled exception before any managed code has had a chance to install an exception handler. Even though managed code had no chance to handle such an exception, the exception is allowed to proceed naturally.","pos":[9,260],"nodes":[{"content":"It is possible for the runtime to throw an unhandled exception before any managed code has had a chance to install an exception handler.","pos":[0,136]},{"content":"Even though managed code had no chance to handle such an exception, the exception is allowed to proceed naturally.","pos":[137,251]}]}]},{"pos":[2176,2222],"content":"Exposing Threading Problems During Development","linkify":"Exposing Threading Problems During Development","nodes":[{"content":"Exposing Threading Problems During Development","pos":[0,46]}]},{"content":"When threads are allowed to fail silently, without terminating the application, serious programming problems can go undetected.","pos":[2226,2353]},{"content":"This is a particular problem for services and other applications which run for extended periods.","pos":[2354,2450]},{"content":"As threads fail, program state gradually becomes corrupted.","pos":[2451,2510]},{"content":"Application performance may degrade, or the application might hang.","pos":[2511,2578]},{"content":"Allowing unhandled exceptions in threads to proceed naturally, until the operating system terminates the program, exposes such problems during development and testing.","pos":[2585,2752]},{"content":"Error reports on program terminations support debugging.","pos":[2753,2809]},{"pos":[2863,2892],"content":"Change from Previous Versions","linkify":"Change from Previous Versions","nodes":[{"content":"Change from Previous Versions","pos":[0,29]}]},{"content":"The most significant change pertains to managed threads.","pos":[2896,2952]},{"content":"In the .NET Framework versions 1.0 and 1.1, the common language runtime provides a backstop for unhandled exceptions in the following situations:","pos":[2953,3098]},{"content":"There is no such thing as an unhandled exception on a thread pool thread.","pos":[3108,3181]},{"content":"When a task throws an exception that it does not handle, the runtime prints the exception stack trace to the console and then returns the thread to the thread pool.","pos":[3182,3346]},{"content":"There is no such thing as an unhandled exception on a thread created with the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Threading.Thread&gt;</ph> class.","pos":[3356,3525],"source":"There is no such thing as an unhandled exception on a thread created with the <xref:System.Threading.Thread.Start%2A> method of the <xref:System.Threading.Thread> class."},{"content":"When code running on such a thread throws an exception that it does not handle, the runtime prints the exception stack trace to the console and then gracefully terminates the thread.","pos":[3526,3708]},{"content":"There is no such thing as an unhandled exception on the finalizer thread.","pos":[3718,3791]},{"content":"When a finalizer throws an exception that it does not handle, the runtime prints the exception stack trace to the console and then allows the finalizer thread to resume running finalizers.","pos":[3792,3980]},{"content":"The foreground or background status of a managed thread does not affect this behavior.","pos":[3987,4073]},{"content":"For unhandled exceptions on threads originating in unmanaged code, the difference is more subtle.","pos":[4080,4177]},{"content":"The runtime JIT-attach dialog preempts the operating system dialog for managed exceptions or native exceptions on threads that have passed through native code.","pos":[4178,4337]},{"content":"The process terminates in all cases.","pos":[4338,4374]},{"pos":[4384,4398],"content":"Migrating Code","linkify":"Migrating Code","nodes":[{"content":"Migrating Code","pos":[0,14]}]},{"content":"In general, the change will expose previously unrecognized programming problems so that they can be fixed.","pos":[4402,4508]},{"content":"In some cases, however, programmers might have taken advantage of the runtime backstop, for example to terminate threads.","pos":[4509,4630]},{"content":"Depending on the situation, they should consider one of the following migration strategies:","pos":[4631,4722]},{"content":"Restructure the code so the thread exits gracefully when a signal is received.","pos":[4732,4810]},{"pos":[4820,4924],"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph> method to abort the thread.","source":"Use the <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> method to abort the thread."},{"content":"If a thread must be stopped so that process termination can proceed, make the thread a background thread so that it is automatically terminated on process exit.","pos":[4934,5094]},{"content":"In all cases, the strategy should follow the design guidelines for exceptions.","pos":[5101,5179]},{"content":"See <bpt id=\"p1\">[</bpt>Design Guidelines for Exceptions<ept id=\"p1\">](../../../docs/standard/design-guidelines/exceptions.md)</ept>.","pos":[5180,5275],"source":" See [Design Guidelines for Exceptions](../../../docs/standard/design-guidelines/exceptions.md)."},{"pos":[5285,5315],"content":"Application Compatibility Flag","linkify":"Application Compatibility Flag","nodes":[{"content":"Application Compatibility Flag","pos":[0,30]}]},{"content":"As a temporary compatibility measure, administrators can place a compatibility flag in the <ph id=\"ph1\">`&lt;runtime&gt;`</ph> section of the application configuration file.","pos":[5319,5468],"source":"As a temporary compatibility measure, administrators can place a compatibility flag in the `<runtime>` section of the application configuration file."},{"content":"This causes the common language runtime to revert to the behavior of versions 1.0 and 1.1.","pos":[5469,5559]},{"pos":[5634,5647],"content":"Host Override","linkify":"Host Override","nodes":[{"content":"Host Override","pos":[0,13]}]},{"content":"In the .NET Framework version 2.0, an unmanaged host can use the <bpt id=\"p1\">[</bpt>ICLRPolicyManager<ept id=\"p1\">](../../../docs/framework/unmanaged-api/hosting/iclrpolicymanager-interface.md)</ept> interface in the Hosting API to override the default unhandled exception policy of the common language runtime.","pos":[5651,5925],"source":"In the .NET Framework version 2.0, an unmanaged host can use the [ICLRPolicyManager](../../../docs/framework/unmanaged-api/hosting/iclrpolicymanager-interface.md) interface in the Hosting API to override the default unhandled exception policy of the common language runtime."},{"content":"The <bpt id=\"p1\">[</bpt>ICLRPolicyManager::SetUnhandledExceptionPolicy<ept id=\"p1\">](../../../docs/framework/unmanaged-api/hosting/iclrpolicymanager-setunhandledexceptionpolicy-method.md)</ept> function is used to set the policy for unhandled exceptions.","pos":[5926,6142],"source":" The [ICLRPolicyManager::SetUnhandledExceptionPolicy](../../../docs/framework/unmanaged-api/hosting/iclrpolicymanager-setunhandledexceptionpolicy-method.md) function is used to set the policy for unhandled exceptions."},{"pos":[6151,6159],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6163,6251],"content":"<bpt id=\"p1\">[</bpt>Managed Threading Basics<ept id=\"p1\">](../../../docs/standard/threading/managed-threading-basics.md)</ept>","source":"[Managed Threading Basics](../../../docs/standard/threading/managed-threading-basics.md)"}]}