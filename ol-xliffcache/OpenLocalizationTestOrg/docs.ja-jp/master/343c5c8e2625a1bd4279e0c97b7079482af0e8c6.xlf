<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="generic-types.md" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">343c5c8e2625a1bd4279e0c97b7079482af0e8c6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\data-types\generic-types.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7d8e9696f6023222b2deafcc54895c9f976e86fc</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5dd3b409b5a28f3cdf9d455d5d94479bb6cef321</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Generic Types in Visual Basic (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Generic Types in Visual Basic (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>generic type<ept id="p1">*</ept> is a single programming element that adapts to perform the same functionality for a variety of data types.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When you define a generic class or procedure, you do not have to define a separate version for each data type for which you might want to perform that functionality.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>An analogy is a screwdriver set with removable heads.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You inspect the screw you need to turn and select the correct head for that screw (slotted, crossed, starred).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Once you insert the correct head in the screwdriver handle, you perform the exact same function with the screwdriver, namely turning the screw.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Diagram of a screwdriver set with different heads.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>When you define a generic type, you parameterize it with one or more data types.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This allows the using code to tailor the data types to its requirements.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Your code can declare several different programming elements from the generic element, each one acting on a different set of data types.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>But the declared elements all perform the identical logic, no matter what data types they are using.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For example, you might want to create and use a queue class that operates on a specific data type such as <ph id="ph1">`String`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can declare such a class from <ph id="ph1">&lt;xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType&gt;</ph>, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can now use <ph id="ph1">`stringQ`</ph> to work exclusively with <ph id="ph2">`String`</ph> values.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`stringQ`</ph> is specific for <ph id="ph2">`String`</ph> instead of being generalized for <ph id="ph3">`Object`</ph> values, you do not have late binding or type conversion.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This saves execution time and reduces run-time errors.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information on using a generic type, see <bpt id="p1">[</bpt>How to: Use a Generic Class<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Example of a Generic Class</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following example shows a skeleton definition of a generic class.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In the preceding skeleton, <ph id="ph1">`t`</ph> is a <bpt id="p1">*</bpt>type parameter<ept id="p1">*</ept>, that is, a placeholder for a data type that you supply when you declare the class.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Elsewhere in your code, you can declare various versions of <ph id="ph1">`classHolder`</ph> by supplying various data types for <ph id="ph2">`t`</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following example shows two such declarations.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The preceding statements declare <bpt id="p1">*</bpt>constructed classes<ept id="p1">*</ept>, in which a specific type replaces the type parameter.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This replacement is propagated throughout the code within the constructed class.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The following example shows what the <ph id="ph1">`processNewItem`</ph> procedure looks like in <ph id="ph2">`integerClass`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For a more complete example, see <bpt id="p1">[</bpt>How to: Define a Class That Can Provide Identical Functionality on Different Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Eligible Programming Elements</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You can define and use generic classes, structures, interfaces, procedures, and delegates.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> defines several generic classes, structures, and interfaces that represent commonly used generic elements.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace provides dictionaries, lists, queues, and stacks.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Before defining your own generic element, see if it is already available in <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Procedures are not types, but you can define and use generic procedures.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Generic Procedures in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Advantages of Generic Types</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A generic type serves as a basis for declaring several different programming elements, each of which operates on a specific data type.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The alternatives to a generic type are:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A single type operating on the <ph id="ph1">`Object`</ph> data type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A set of <bpt id="p1">*</bpt>type-specific<ept id="p1">*</ept> versions of the type, each version individually coded and operating on one specific data type such as <ph id="ph1">`String`</ph>, <ph id="ph2">`Integer`</ph>, or a user-defined type such as <ph id="ph3">`customer`</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A generic type has the following advantages over these alternatives:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Type Safety.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Generic types enforce compile-time type checking.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Types based on <ph id="ph1">`Object`</ph> accept any data type, and you must write code to check whether an input data type is acceptable.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>With generic types, the compiler can catch type mismatches before run time.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Performance.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Generic types do not have to <bpt id="p1">*</bpt>box<ept id="p1">*</ept> and <bpt id="p2">*</bpt>unbox<ept id="p2">*</ept> data, because each one is specialized for one data type.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Operations based on <ph id="ph1">`Object`</ph> must box input data types to convert them to <ph id="ph2">`Object`</ph> and unbox data destined for output.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Boxing and unboxing reduce performance.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Types based on <ph id="ph1">`Object`</ph> are also late-bound, which means that accessing their members requires extra code at run time.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This also reduces performance.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Code Consolidation.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The code in a generic type has to be defined only once.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A set of type-specific versions of a type must replicate the same code in each version, with the only difference being the specific data type for that version.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>With generic types, the type-specific versions are all generated from the original generic type.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Code Reuse.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Code that does not depend on a particular data type can be reused with various data types if it is generic.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can often reuse it even with a data type that you did not originally predict.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>IDE Support.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When you use a constructed type declared from a generic type, the integrated development environment (IDE) can give you more support while you are developing your code.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, IntelliSense can show you the type-specific options for an argument to a constructor or method.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generic Algorithms.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Abstract algorithms that are type-independent are good candidates for generic types.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example, a generic procedure that sorts items using the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface can be used with any data type that implements <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Constraints</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Although the code in a generic type definition should be as type-independent as possible, you might need to require a certain capability of any data type supplied to your generic type.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example, if you want to compare two items for the purpose of sorting or collating, their data type must implement the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can enforce this requirement by adding a <bpt id="p1">*</bpt>constraint<ept id="p1">*</ept> to the type parameter.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Example of a Constraint</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following example shows a skeleton definition of a class with a constraint that requires the type argument to implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If subsequent code attempts to construct a class from <ph id="ph1">`itemManager`</ph> supplying a type that does not implement <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>, the compiler signals an error.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Types of Constraints</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Your constraint can specify the following requirements in any combination:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The type argument must implement one or more interfaces</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The type argument must be of the type of, or inherit from, at most one class</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The type argument must expose a parameterless constructor accessible to the code that creates objects from it</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The type argument must be a <bpt id="p1">*</bpt>reference type<ept id="p1">*</ept>, or it must be a <bpt id="p2">*</bpt>value type<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If you need to impose more than one requirement, you use a comma-separated <bpt id="p1">*</bpt>constraint list<ept id="p1">*</ept> inside braces (<ph id="ph1">`{ }`</ph>).</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>To require an accessible constructor, you include the <bpt id="p1">[</bpt>New Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/new-operator.md)</ept> keyword in the list.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>To require a reference type, you include the <ph id="ph1">`Class`</ph> keyword; to require a value type, you include the <ph id="ph2">`Structure`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>For more information on constraints, see <bpt id="p1">[</bpt>Type List<ept id="p1">](../../../../visual-basic/language-reference/statements/type-list.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Example of Multiple Constraints</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following example shows a skeleton definition of a generic class with a constraint list on the type parameter.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In the code that creates an instance of this class, the type argument must implement both the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> and <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interfaces, be a reference type, and expose an accessible parameterless constructor.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Important Terms</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Generic types introduce and use the following terms:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Generic Type<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A definition of a class, structure, interface, procedure, or delegate for which you supply at least one data type when you declare it.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Type Parameter<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In a generic type definition, a placeholder for a data type you supply when you declare the type.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Type Argument<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A specific data type that replaces a type parameter when you declare a constructed type from a generic type.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Constraint<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A condition on a type parameter that restricts the type argument you can supply for it.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A constraint can require that the type argument must implement a particular interface, be or inherit from a particular class, have an accessible parameterless constructor, or be a reference type or a value type.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can combine these constraints, but you can specify at most one class.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Constructed Type<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A class, structure, interface, procedure, or delegate declared from a generic type by supplying type arguments for its type parameters.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type Characters<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)</ept></source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Value Types and Reference Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)</ept></source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type Conversions in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Troubleshooting Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data Types<ept id="p1">](../../../../visual-basic/language-reference/data-types/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Of<ept id="p1">](../../../../visual-basic/language-reference/statements/of-clause.md)</ept></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>As<ept id="p1">](../../../../visual-basic/language-reference/statements/as-clause.md)</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Object Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/object-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](../../concepts/covariance-contravariance/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Iterators<ept id="p1">](../../../../visual-basic/programming-guide/concepts/iterators.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>