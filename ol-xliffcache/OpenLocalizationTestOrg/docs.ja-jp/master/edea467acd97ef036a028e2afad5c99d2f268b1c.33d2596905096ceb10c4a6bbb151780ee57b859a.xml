{"content":"---\ntitle: \"Managed Extensibility Framework (MEF) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Managed Extensibility Framework, overview\"\n  - \"MEF, overview\"\nms.assetid: 6c61b4ec-c6df-4651-80f1-4854f8b14dde\ncaps.latest.revision: 31\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Managed Extensibility Framework (MEF)\nThis topic provides an overview of the Managed Extensibility Framework introduced in the .NET Framework 4.  \n  \n<a name=\"what_is_mef\"></a>   \n## What is MEF?  \n The Managed Extensibility Framework or MEF is a library for creating lightweight, extensible applications. It allows application developers to discover and use extensions with no configuration required. It also lets extension developers easily encapsulate code and avoid fragile hard dependencies. MEF not only allows extensions to be reused within applications, but across applications as well.  \n  \n<a name=\"the_problem_of_extensibility\"></a>   \n## The Problem of Extensibility  \n Imagine that you are the architect of a large application that must provide support for extensibility. Your application has to include a potentially large number of smaller components, and is responsible for creating and running them.  \n  \n The simplest approach to the problem is to include the components as source code in your application, and call them directly from your code.  This has a number of obvious drawbacks.  Most importantly, you cannot add new components without modifying the source code, a restriction that might be acceptable in, for example, a Web application, but is unworkable in a client application.  Equally problematic, you may not have access to the source code for the components, because they might be developed by third parties, and for the same reason you cannot allow them to access yours.  \n  \n A slightly more sophisticated approach would be to provide an extension point or interface, to permit decoupling between the application and its components.  Under this model, you might provide an interface that a component can implement, and an API to enable it to interact with your application.  This solves the problem of requiring source code access, but it still has its own difficulties.  \n  \n Because the application lacks any capacity for discovering components on its own, it must still be explicitly told which components are available and should be loaded.  This is typically accomplished by explicitly registering the available components in a configuration file. This means that assuring that the components are correct becomes a maintenance issue, particularly if it is the end user and not the developer who is expected to do the updating.  \n  \n In addition, components are incapable of communicating with one another, except through the rigidly defined channels of the application itself.  If the application architect has not anticipated the need for a particular communication, it is usually impossible.  \n  \n Finally, the component developers must accept a hard dependency on what assembly contains the interface they implement.  This makes it difficult for a component to be used in more than one application, and can also create problems when you create a test framework for components.  \n  \n<a name=\"what_mef_provides\"></a>   \n## What MEF Provides  \n Instead of this explicit registration of available components, MEF provides a way to discover them implicitly, via *composition*.  A MEF component, called a *part*, declaratively specifies both its dependencies (known as *imports*) and what capabilities (known as *exports*) it makes available. When a part is created, the MEF composition engine satisfies its imports with what is available from other parts.  \n  \n This approach solves the problems discussed in the previous section.  Because MEF parts declaratively specify their capabilities, they are discoverable at runtime, which means an application can make use of parts without either hard-coded references or fragile configuration files.  MEF allows applications to discover and examine parts by their metadata, without instantiating them or even loading their assemblies. As a result, there is no need to carefully specify when and how extensions should be loaded.  \n  \n In addition to its provided exports, a part can specify its imports, which will be filled by other parts.  This makes communication among parts not only possible, but easy, and allows for good factoring of code. For example, services common to many components can be factored into a separate part and easily modified or replaced.  \n  \n Because the MEF model requires no hard dependency on a particular application assembly, it allows extensions to be reused from application to application.  This also makes it easy to develop a test harness, independent of the application, to test extension components.  \n  \n An extensible application written by using MEF declares an import that can be filled by extension components, and may also declare exports in order to expose application services to extensions.  Each extension component declares an export, and may also declare imports.  In this way, extension components themselves are automatically extensible.  \n  \n<a name=\"where_is_mef_available\"></a>   \n## Where Is MEF Available?  \n MEF is an integral part of the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], and is available wherever the .NET Framework is used.  You can use MEF in your client applications, whether they use Windows Forms, WPF, or any other technology, or in server applications that use ASP.NET.  \n  \n<a name=\"mef_and_maf\"></a>   \n## MEF and MAF  \n Previous versions of the .NET Framework introduced the Managed Add-in Framework (MAF), designed to allow applications to isolate and manage extensions.  The focus of MAF is slightly higher-level than MEF, concentrating on extension isolation and assembly loading and unloading, while MEF's focus is on discoverability, extensibility, and portability.  The two frameworks interoperate smoothly, and a single application can take advantage of both.  \n  \n<a name=\"simplecalculator_an_example_application\"></a>   \n## SimpleCalculator: An Example Application  \n The simplest way to see what MEF can do is to build a simple MEF application. In this example, you build a very simple calculator named SimpleCalculator. The goal of SimpleCalculator is to create a console application that accepts basic arithmetic commands, in the form \"5+3\" or \"6-2\", and returns the correct answers. Using MEF, you will be able to add new operators without changing the application code.  \n  \n To download the complete code for this example, see the [SimpleCalculator sample](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e).  \n  \n> [!NOTE]\n>  The purpose of SimpleCalculator is to demonstrate the concepts and syntax of MEF, rather than to necessarily provide a realistic scenario for its use. Many of the applications that would benefit most from the power of MEF are more complex than SimpleCalculator. For more extensive examples, see the [Managed Extensibility Framework](http://go.microsoft.com/fwlink/?LinkId=144282) on Codeplex.  \n  \n To start, in [!INCLUDE[vs_dev10_long](../../../includes/vs-dev10-long-md.md)], create a new Console Application project named `SimpleCalculator`. Add a reference to the System.ComponentModel.Composition assembly, where MEF resides. Open Module1.vb or Program.cs and add `Imports` or `using` statements for System.ComponentModel.Composition and System.ComponentModel.Composition.Hosting. These two namespaces contain MEF types you will need to develop an extensible application. In Visual Basic, add the `Public` keyword to the line that declares the `Module1` module.  \n  \n<a name=\"composition_container_and_catalogs\"></a>   \n## Composition Container and Catalogs  \n The core of the MEF composition model is the *composition container*, which contains all the parts available and performs composition.  (That is, the matching up of imports to exports.)  The most common type of composition container is <xref:System.ComponentModel.Composition.Hosting.CompositionContainer>, and you will use this for SimpleCalculator.  \n  \n In Visual Basic, in Module1.vb, add a public class named `Program`. Then add the following line to the `Program` class in Module1.vb or Program.cs:  \n  \n```vb  \nDim _container As CompositionContainer  \n```  \n  \n```csharp  \nprivate CompositionContainer _container;  \n```  \n  \n In order to discover the parts available to it, the composition containers makes use of a *catalog*. A catalog is an object that makes available parts discovered from some source.  MEF provides catalogs to discover parts from a provided type, an assembly, or a directory. Application developers can easily create new catalogs to discover parts from other sources, such as a Web service.  \n  \n Add the following constructor to the `Program` class:  \n  \n```vb  \nPublic Sub New()  \n    'An aggregate catalog that combines multiple catalogs  \n     Dim catalog = New AggregateCatalog()  \n  \n    'Adds all the parts found in the same assembly as the Program class  \n    catalog.Catalogs.Add(New AssemblyCatalog(GetType(Program).Assembly))  \n  \n    'Create the CompositionContainer with the parts in the catalog  \n    _container = New CompositionContainer(catalog)  \n  \n    'Fill the imports of this object  \n    Try  \n        _container.ComposeParts(Me)  \n    Catch ex As Exception  \n        Console.WriteLine(ex.ToString)  \n    End Try  \nEnd Sub  \n```  \n  \n```csharp  \nprivate Program()  \n{  \n    //An aggregate catalog that combines multiple catalogs  \n    var catalog = new AggregateCatalog();  \n    //Adds all the parts found in the same assembly as the Program class  \n    catalog.Catalogs.Add(new AssemblyCatalog(typeof(Program).Assembly));  \n  \n    //Create the CompositionContainer with the parts in the catalog  \n    _container = new CompositionContainer(catalog);  \n  \n    //Fill the imports of this object  \n    try  \n    {  \n        this._container.ComposeParts(this);  \n    }  \n    catch (CompositionException compositionException)  \n    {  \n        Console.WriteLine(compositionException.ToString());  \n   }  \n}  \n```  \n  \n The call to <xref:System.ComponentModel.Composition.AttributedModelServices.ComposeParts%2A> tells the composition container to compose a specific set of parts, in this case the current instance of `Program`. At this point, however, nothing will happen, since `Program` has no imports to fill.  \n  \n<a name=\"imports_and_exports_with_attributes\"></a>   \n## Imports and Exports with Attributes  \n First, you have `Program` import a calculator. This allows the separation of user interface concerns, such as the console input and output that will go into `Program`, from the logic of the calculator.  \n  \n Add the following code to the `Program` class:  \n  \n```vb  \n<Import(GetType(ICalculator))>  \nPublic Property calculator As ICalculator  \n```  \n  \n```csharp  \n[Import(typeof(ICalculator))]  \npublic ICalculator calculator;  \n```  \n  \n Notice that the declaration of the `calculator` object is not unusual, but that it is decorated with the <xref:System.ComponentModel.Composition.ImportAttribute> attribute.  This attribute declares something to be an import; that is, it will be filled by the composition engine when the object is composed.  \n  \n Every import has a *contract*, which determines what exports it will be matched with. The contract can be an explicitly specified string, or it can be automatically generated by MEF from a given type, in this case the interface `ICalculator`.  Any export declared with a matching contract will fulfill this import.  Note that while the type of the `calculator` object is in fact `ICalculator`, this is not required. The contract is independent from the type of the importing object.  (In this case, you could leave out the `typeof(ICalculator)`.  MEF will automatically assume the contract to be based on the type of the import unless you specify it explicitly.)  \n  \n Add this very simple interface to the module or `SimpleCalculator` namespace:  \n  \n```vb  \nPublic Interface ICalculator  \n    Function Calculate(ByVal input As String) As String  \nEnd Interface  \n```  \n  \n```csharp  \npublic interface ICalculator  \n{  \n    String Calculate(String input);  \n}  \n```  \n  \n Now that you have defined `ICalculator`, you need a class that implements it.  Add the following class to the module or `SimpleCalculator` namespace:  \n  \n```vb  \n<Export(GetType(ICalculator))>  \nPublic Class MySimpleCalculator  \n   Implements ICalculator  \n  \nEnd Class  \n```  \n  \n```csharp  \n[Export(typeof(ICalculator))]  \nclass MySimpleCalculator : ICalculator  \n{  \n  \n}  \n```  \n  \n Here is the export that will match the import in `Program`. In order for the export to match the import, the export must have the same contract.  Exporting under a contract based on `typeof(MySimpleCalculator)` would produce a mismatch, and the import would not be filled; the contract needs to match exactly.  \n  \n Since the composition container will be populated with all the parts available in this assembly, the `MySimpleCalculator` part will be available.  When the constructor for `Program` performs composition on the `Program` object, its import will be filled with a `MySimpleCalculator` object, which will be created for that purpose.  \n  \n The user interface layer (`Program`) does not need to know anything else.  You can therefore fill in the rest of the user interface logic in the `Main` method.  \n  \n Add the following code to the `Main` method:  \n  \n```vb  \nSub Main()  \n    Dim p As New Program()  \n    Dim s As String  \n    Console.WriteLine(\"Enter Command:\")  \n    While (True)  \n        s = Console.ReadLine()  \n        Console.WriteLine(p.calculator.Calculate(s))  \n    End While  \nEnd Sub  \n```  \n  \n```csharp  \nstatic void Main(string[] args)  \n{  \n    Program p = new Program(); //Composition is performed in the constructor  \n    String s;  \n    Console.WriteLine(\"Enter Command:\");  \n    while (true)  \n    {  \n        s = Console.ReadLine();  \n        Console.WriteLine(p.calculator.Calculate(s));  \n    }  \n}  \n```  \n  \n This code simply reads a line of input and calls the `Calculate` function of `ICalculator` on the result, which it writes back to the console. That is all the code you need in `Program`.  All the rest of the work will happen in the parts.  \n  \n<a name=\"further_imports_and_importmany\"></a>   \n## Further Imports and ImportMany  \n In order for SimpleCalculator to be extensible, it needs to import a list of operations. An ordinary <xref:System.ComponentModel.Composition.ImportAttribute> attribute is filled by one and only one <xref:System.ComponentModel.Composition.ExportAttribute>.  If more than one is available, the composition engine produces an error.  To create an import that can be filled by any number of exports, you can use the <xref:System.ComponentModel.Composition.ImportManyAttribute> attribute.  \n  \n Add the following operations property to the `MySimpleCalculator` class:  \n  \n```vb  \n<ImportMany()>  \nPublic Property operations As IEnumerable(Of Lazy(Of IOperation, IOperationData))  \n```  \n  \n```csharp  \n[ImportMany]  \nIEnumerable<Lazy<IOperation, IOperationData>> operations;  \n```  \n  \n <xref:System.Lazy%602> is a type provided by MEF to hold indirect references to exports.  Here, in addition to the exported object itself, you also get *export metadata*, or information that describes the exported object. Each <xref:System.Lazy%602> contains an `IOperation` object, representing an actual operation, and an `IOperationData` object, representing its metadata.  \n  \n Add the following simple interfaces to the module or `SimpleCalculator` namespace:  \n  \n```vb  \nPublic Interface IOperation  \n    Function Operate(ByVal left As Integer, ByVal right As Integer) As Integer  \nEnd Interface  \n  \nPublic Interface IOperationData  \n    ReadOnly Property Symbol As Char  \nEnd Interface  \n```  \n  \n```csharp  \npublic interface IOperation  \n{  \n     int Operate(int left, int right);  \n}  \n  \npublic interface IOperationData  \n{  \n    Char Symbol { get; }  \n}  \n```  \n  \n In this case, the metadata for each operation is the symbol that represents that operation, such as +, -, *, and so on. To make the addition operation available, add the following class to the module or `SimpleCalculator` namespace:  \n  \n```vb  \n<Export(GetType(IOperation))>  \n<ExportMetadata(\"Symbol\", \"+\"c)>  \nPublic Class Add  \n    Implements IOperation  \n  \n    Public Function Operate(ByVal left As Integer, ByVal right As Integer) As Integer Implements IOperation.Operate  \n        Return left + right  \n    End Function  \nEnd Class  \n```  \n  \n```csharp  \n[Export(typeof(IOperation))]  \n[ExportMetadata(\"Symbol\", '+')]  \nclass Add: IOperation  \n{  \n    public int Operate(int left, int right)  \n    {  \n        return left + right;  \n    }  \n}  \n```  \n  \n The <xref:System.ComponentModel.Composition.ExportAttribute> attribute functions as it did before.  The <xref:System.ComponentModel.Composition.ExportMetadataAttribute> attribute attaches metadata, in the form of a name-value pair, to that export.  While the `Add` class implements `IOperation`, a class that implements `IOperationData` is not explicitly defined. Instead, a class is implicitly created by MEF with properties based on the names of the metadata provided.  (This is one of several ways to access metadata in MEF.)  \n  \n Composition in MEF is *recursive*. You explicitly composed the `Program` object, which imported an `ICalculator` that turned out to be of type `MySimpleCalculator`.  `MySimpleCalculator`, in turn, imports a collection of `IOperation` objects, and that import will be filled when `MySimpleCalculator` is created, at the same time as the imports of `Program`. If the `Add` class declared a further import, that too would have to be filled, and so on. Any import left unfilled results in a composition error.  (It is possible, however, to declare imports to be optional or to assign them default values.)  \n  \n<a name=\"calculator_logic\"></a>   \n## Calculator Logic  \n With these parts in place, all that remains is the calculator logic itself. Add the following code in the `MySimpleCalculator` class to implement the `Calculate` method:  \n  \n```vb  \nPublic Function Calculate(ByVal input As String) As String Implements ICalculator.Calculate  \n    Dim left, right As Integer  \n    Dim operation As Char  \n    Dim fn = FindFirstNonDigit(input) 'Finds the operator  \n    If fn < 0 Then  \n        Return \"Could not parse command.\"  \n    End If  \n    operation = input(fn)  \n    Try  \n        left = Integer.Parse(input.Substring(0, fn))  \n        right = Integer.Parse(input.Substring(fn + 1))  \n    Catch ex As Exception  \n        Return \"Could not parse command.\"  \n    End Try  \n    For Each i As Lazy(Of IOperation, IOperationData) In operations  \n        If i.Metadata.symbol = operation Then  \n            Return i.Value.Operate(left, right).ToString()  \n        End If  \n    Next  \n    Return \"Operation not found!\"  \nEnd Function  \n```  \n  \n```csharp  \npublic String Calculate(String input)  \n{  \n    int left;  \n    int right;  \n    Char operation;  \n    int fn = FindFirstNonDigit(input); //finds the operator  \n    if (fn < 0) return \"Could not parse command.\";  \n  \n    try  \n    {  \n        //separate out the operands  \n        left = int.Parse(input.Substring(0, fn));  \n        right = int.Parse(input.Substring(fn + 1));  \n    }  \n    catch   \n    {  \n        return \"Could not parse command.\";  \n    }  \n  \n    operation = input[fn];  \n  \n    foreach (Lazy<IOperation, IOperationData> i in operations)  \n    {  \n        if (i.Metadata.Symbol.Equals(operation)) return i.Value.Operate(left, right).ToString();  \n    }  \n    return \"Operation Not Found!\";  \n}  \n```  \n  \n The initial steps parse the input string into left and right operands and an operator character.  In the `foreach` loop, every member of the `operations` collection is examined. These objects are of type <xref:System.Lazy%602>, and their metadata values and exported object can be accessed with the <xref:System.Lazy%602.Metadata%2A> property and the <xref:System.Lazy%601.Value%2A>property respectively. In this case, if the `Symbol` property of the `IOperationData` object is discovered to be a match, the calculator calls the `Operate` method of the `IOperation` object and returns the result.  \n  \n To complete the calculator, you also need a helper method that returns the position of the first non-digit character in a string.  Add the following helper method to the `MySimpleCalculator` class:  \n  \n```vb  \nPrivate Function FindFirstNonDigit(ByVal s As String) As Integer  \n    For i = 0 To s.Length  \n        If (Not (Char.IsDigit(s(i)))) Then Return i  \n    Next  \n    Return -1  \nEnd Function  \n```  \n  \n```csharp  \nprivate int FindFirstNonDigit(String s)  \n{  \n    for (int i = 0; i < s.Length; i++)  \n    {  \n        if (!(Char.IsDigit(s[i]))) return i;  \n    }  \n    return -1;  \n}  \n```  \n  \n You should now be able to compile and run the project. In Visual Basic, make sure that you added the `Public` keyword to `Module1`. In the console window, type an addition operation, such as \"5+3\", and the calculator will return the results.  Any other operator will result in the \"Operation Not Found!\" message.  \n  \n<a name=\"extending_simplecalculator_using_a_new_class\"></a>   \n## Extending SimpleCalculator Using A New Class  \n Now that the calculator works, adding a new operation is easy. Add the following class to the module or `SimpleCalculator` namespace:  \n  \n```vb  \n<Export(GetType(IOperation))>  \n<ExportMetadata(\"Symbol\", \"-\"c)>  \nPublic Class Subtract  \n    Implements IOperation  \n  \n    Public Function Operate(ByVal left As Integer, ByVal right As Integer) As Integer Implements IOperation.Operate  \n        Return left - right  \n    End Function  \nEnd Class  \n```  \n  \n```csharp  \n[Export(typeof(IOperation))]  \n[ExportMetadata(\"Symbol\", '-')]  \nclass Subtract : IOperation  \n{  \n    public int Operate(int left, int right)  \n    {  \n        return left - right;  \n    }  \n}  \n```  \n  \n Compile and run the project. Type a subtraction operation, such as \"5-3\". The calculator now supports subtraction as well as addition.  \n  \n<a name=\"extending_simplecalculator_using_a_new_assembly\"></a>   \n## Extending SimpleCalculator Using A New Assembly  \n Adding classes to the source code is simple enough, but MEF provides the ability to look outside an application’s own source for parts. To demonstrate this, you will need to modify SimpleCalculator to search a directory, as well as its own assembly, for parts, by adding a <xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog>.  \n  \n Add a new directory named `Extensions` to the SimpleCalculator project.  Make sure to add it at the project level, and not at the solution level. Then add a new Class Library project to the solution, named `ExtendedOperations`. The new project will compile into a separate assembly.  \n  \n Open the Project Properties Designer for the ExtendedOperations project and click the **Compile** or **Build** tab. Change the **Build output path** or **Output path** to point to the Extensions directory in the SimpleCalculator project directory (..\\SimpleCalculator\\Extensions\\\\).  \n  \n In Module1.vb or Program.cs, add the following line to the `Program` constructor:  \n  \n```vb  \ncatalog.Catalogs.Add(New DirectoryCatalog(\"C:\\SimpleCalculator\\SimpleCalculator\\Extensions\"))  \n```  \n  \n```csharp  \ncatalog.Catalogs.Add(new DirectoryCatalog(\"C:\\\\SimpleCalculator\\\\SimpleCalculator\\\\Extensions\"));  \n```  \n  \n Replace the example path with the path to your Extensions directory.  (This absolute path is for debugging purposes only.  In a production application, you would use a relative path.) The <xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog> will now add any parts found in any assemblies in the Extensions directory to the composition container.  \n  \n In the ExtendedOperations project, add references to SimpleCalculator and System.ComponentModel.Composition. In the ExtendedOperations class file, add an `Imports` or a `using` statement for System.ComponentModel.Composition. In Visual Basic, also add an `Imports` statement for SimpleCalculator. Then add the following class to the ExtendedOperations class file:  \n  \n```vb  \n<Export(GetType(SimpleCalculator.IOperation))>  \n<ExportMetadata(\"Symbol\", \"%\"c)>  \nPublic Class Modulo  \n    Implements IOperation  \n  \n    Public Function Operate(ByVal left As Integer, ByVal right As Integer) As Integer Implements IOperation.Operate  \n        Return left Mod right  \n    End Function  \nEnd Class  \n```  \n  \n```csharp  \n[Export(typeof(SimpleCalculator.IOperation))]  \n[ExportMetadata(\"Symbol\", '%')]  \npublic class Mod : SimpleCalculator.IOperation  \n{  \n    public int Operate(int left, int right)  \n    {  \n        return left % right;  \n    }  \n}  \n```  \n  \n Note that in order for the contract to match, the <xref:System.ComponentModel.Composition.ExportAttribute> attribute must have the same type as the <xref:System.ComponentModel.Composition.ImportAttribute>.  \n  \n Compile and run the project. Test the new Mod (%) operator.  \n  \n<a name=\"conclusion\"></a>   \n## Conclusion  \n This topic covered the basic concepts of MEF.  \n  \n-   Parts, catalogs, and the composition container  \n  \n     Parts and the composition container are the basic building blocks of a MEF application. A part is any object that imports or exports a value, up to and including itself. A catalog provides a collection of parts from a particular source.  The composition container uses the parts provided by a catalog to perform composition, the binding of imports to exports.  \n  \n-   Imports and exports  \n  \n     Imports and exports are the way by which components communicate. With an import, the component specifies a need for a particular value or object, and with an export it specifies the availability of a value. Each import is matched with a list of exports by way of its contract.  \n  \n<a name=\"where_do_i_go_now\"></a>   \n## Where Do I Go Now?  \n To download the complete code for this example, see the [SimpleCalculator sample](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e).  \n  \n For more information and code examples, see [Managed Extensibility Framework](http://go.microsoft.com/fwlink/?LinkId=144282). For a list of the MEF types, see the <xref:System.ComponentModel.Composition?displayProperty=fullName> namespace.","nodes":[{"pos":[12,66],"content":"Managed Extensibility Framework (MEF) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Managed Extensibility Framework (MEF) | Microsoft Docs","pos":[0,54]}]},{"pos":[460,497],"content":"Managed Extensibility Framework (MEF)","linkify":"Managed Extensibility Framework (MEF)","nodes":[{"content":"Managed Extensibility Framework (MEF)","pos":[0,37]}]},{"content":"This topic provides an overview of the Managed Extensibility Framework introduced in the .NET Framework 4.","pos":[498,604]},{"pos":[643,655],"content":"What is MEF?","linkify":"What is MEF?","nodes":[{"content":"What is MEF?","pos":[0,12]}]},{"content":"The Managed Extensibility Framework or MEF is a library for creating lightweight, extensible applications.","pos":[659,765]},{"content":"It allows application developers to discover and use extensions with no configuration required.","pos":[766,861]},{"content":"It also lets extension developers easily encapsulate code and avoid fragile hard dependencies.","pos":[862,956]},{"content":"MEF not only allows extensions to be reused within applications, but across applications as well.","pos":[957,1054]},{"pos":[1110,1138],"content":"The Problem of Extensibility","linkify":"The Problem of Extensibility","nodes":[{"content":"The Problem of Extensibility","pos":[0,28]}]},{"content":"Imagine that you are the architect of a large application that must provide support for extensibility.","pos":[1142,1244]},{"content":"Your application has to include a potentially large number of smaller components, and is responsible for creating and running them.","pos":[1245,1376]},{"content":"The simplest approach to the problem is to include the components as source code in your application, and call them directly from your code.","pos":[1383,1523]},{"content":"This has a number of obvious drawbacks.","pos":[1525,1564]},{"content":"Most importantly, you cannot add new components without modifying the source code, a restriction that might be acceptable in, for example, a Web application, but is unworkable in a client application.","pos":[1566,1766]},{"content":"Equally problematic, you may not have access to the source code for the components, because they might be developed by third parties, and for the same reason you cannot allow them to access yours.","pos":[1768,1964]},{"content":"A slightly more sophisticated approach would be to provide an extension point or interface, to permit decoupling between the application and its components.","pos":[1971,2127]},{"content":"Under this model, you might provide an interface that a component can implement, and an API to enable it to interact with your application.","pos":[2129,2268]},{"content":"This solves the problem of requiring source code access, but it still has its own difficulties.","pos":[2270,2365]},{"content":"Because the application lacks any capacity for discovering components on its own, it must still be explicitly told which components are available and should be loaded.","pos":[2372,2539]},{"content":"This is typically accomplished by explicitly registering the available components in a configuration file.","pos":[2541,2647]},{"content":"This means that assuring that the components are correct becomes a maintenance issue, particularly if it is the end user and not the developer who is expected to do the updating.","pos":[2648,2826]},{"content":"In addition, components are incapable of communicating with one another, except through the rigidly defined channels of the application itself.","pos":[2833,2976]},{"content":"If the application architect has not anticipated the need for a particular communication, it is usually impossible.","pos":[2978,3093]},{"content":"Finally, the component developers must accept a hard dependency on what assembly contains the interface they implement.","pos":[3100,3219]},{"content":"This makes it difficult for a component to be used in more than one application, and can also create problems when you create a test framework for components.","pos":[3221,3379]},{"pos":[3424,3441],"content":"What MEF Provides","linkify":"What MEF Provides","nodes":[{"content":"What MEF Provides","pos":[0,17]}]},{"content":"Instead of this explicit registration of available components, MEF provides a way to discover them implicitly, via <bpt id=\"p1\">*</bpt>composition<ept id=\"p1\">*</ept>.","pos":[3445,3574],"source":"Instead of this explicit registration of available components, MEF provides a way to discover them implicitly, via *composition*."},{"content":"A MEF component, called a <bpt id=\"p1\">*</bpt>part<ept id=\"p1\">*</ept>, declaratively specifies both its dependencies (known as <bpt id=\"p2\">*</bpt>imports<ept id=\"p2\">*</ept>) and what capabilities (known as <bpt id=\"p3\">*</bpt>exports<ept id=\"p3\">*</ept>) it makes available.","pos":[3576,3739],"source":"  A MEF component, called a *part*, declaratively specifies both its dependencies (known as *imports*) and what capabilities (known as *exports*) it makes available."},{"content":"When a part is created, the MEF composition engine satisfies its imports with what is available from other parts.","pos":[3740,3853]},{"content":"This approach solves the problems discussed in the previous section.","pos":[3860,3928]},{"content":"Because MEF parts declaratively specify their capabilities, they are discoverable at runtime, which means an application can make use of parts without either hard-coded references or fragile configuration files.","pos":[3930,4141]},{"content":"MEF allows applications to discover and examine parts by their metadata, without instantiating them or even loading their assemblies.","pos":[4143,4276]},{"content":"As a result, there is no need to carefully specify when and how extensions should be loaded.","pos":[4277,4369]},{"content":"In addition to its provided exports, a part can specify its imports, which will be filled by other parts.","pos":[4376,4481]},{"content":"This makes communication among parts not only possible, but easy, and allows for good factoring of code.","pos":[4483,4587]},{"content":"For example, services common to many components can be factored into a separate part and easily modified or replaced.","pos":[4588,4705]},{"content":"Because the MEF model requires no hard dependency on a particular application assembly, it allows extensions to be reused from application to application.","pos":[4712,4866]},{"content":"This also makes it easy to develop a test harness, independent of the application, to test extension components.","pos":[4868,4980]},{"content":"An extensible application written by using MEF declares an import that can be filled by extension components, and may also declare exports in order to expose application services to extensions.","pos":[4987,5180]},{"content":"Each extension component declares an export, and may also declare imports.","pos":[5182,5256]},{"content":"In this way, extension components themselves are automatically extensible.","pos":[5258,5332]},{"pos":[5382,5405],"content":"Where Is MEF Available?","linkify":"Where Is MEF Available?","nodes":[{"content":"Where Is MEF Available?","pos":[0,23]}]},{"content":"MEF is an integral part of the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, and is available wherever the .NET Framework is used.","pos":[5409,5559],"source":"MEF is an integral part of the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], and is available wherever the .NET Framework is used."},{"content":"You can use MEF in your client applications, whether they use Windows Forms, WPF, or any other technology, or in server applications that use ASP.NET.","pos":[5561,5711]},{"pos":[5750,5761],"content":"MEF and MAF","linkify":"MEF and MAF","nodes":[{"content":"MEF and MAF","pos":[0,11]}]},{"content":"Previous versions of the .NET Framework introduced the Managed Add-in Framework (MAF), designed to allow applications to isolate and manage extensions.","pos":[5765,5916]},{"content":"The focus of MAF is slightly higher-level than MEF, concentrating on extension isolation and assembly loading and unloading, while MEF's focus is on discoverability, extensibility, and portability.","pos":[5918,6115]},{"content":"The two frameworks interoperate smoothly, and a single application can take advantage of both.","pos":[6117,6211]},{"pos":[6278,6318],"content":"SimpleCalculator: An Example Application","linkify":"SimpleCalculator: An Example Application","nodes":[{"content":"SimpleCalculator: An Example Application","pos":[0,40]}]},{"content":"The simplest way to see what MEF can do is to build a simple MEF application.","pos":[6322,6399]},{"content":"In this example, you build a very simple calculator named SimpleCalculator.","pos":[6400,6475]},{"content":"The goal of SimpleCalculator is to create a console application that accepts basic arithmetic commands, in the form \"5+3\" or \"6-2\", and returns the correct answers.","pos":[6476,6640]},{"content":"Using MEF, you will be able to add new operators without changing the application code.","pos":[6641,6728]},{"pos":[6735,6895],"content":"To download the complete code for this example, see the <bpt id=\"p1\">[</bpt>SimpleCalculator sample<ept id=\"p1\">](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e)</ept>.","source":"To download the complete code for this example, see the [SimpleCalculator sample](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e)."},{"pos":[6903,7306],"content":"[!NOTE]\n The purpose of SimpleCalculator is to demonstrate the concepts and syntax of MEF, rather than to necessarily provide a realistic scenario for its use. Many of the applications that would benefit most from the power of MEF are more complex than SimpleCalculator. For more extensive examples, see the [Managed Extensibility Framework](http://go.microsoft.com/fwlink/?LinkId=144282) on Codeplex.","leadings":["","> "],"nodes":[{"content":" The purpose of SimpleCalculator is to demonstrate the concepts and syntax of MEF, rather than to necessarily provide a realistic scenario for its use. Many of the applications that would benefit most from the power of MEF are more complex than SimpleCalculator. For more extensive examples, see the [Managed Extensibility Framework](http://go.microsoft.com/fwlink/?LinkId=144282) on Codeplex.","pos":[8,401],"nodes":[{"content":"The purpose of SimpleCalculator is to demonstrate the concepts and syntax of MEF, rather than to necessarily provide a realistic scenario for its use.","pos":[1,151]},{"content":"Many of the applications that would benefit most from the power of MEF are more complex than SimpleCalculator.","pos":[152,262]},{"content":"For more extensive examples, see the <bpt id=\"p1\">[</bpt>Managed Extensibility Framework<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=144282)</ept> on Codeplex.","pos":[263,393],"source":" For more extensive examples, see the [Managed Extensibility Framework](http://go.microsoft.com/fwlink/?LinkId=144282) on Codeplex."}]}]},{"content":"To start, in <ph id=\"ph1\">[!INCLUDE[vs_dev10_long](../../../includes/vs-dev10-long-md.md)]</ph>, create a new Console Application project named <ph id=\"ph2\">`SimpleCalculator`</ph>.","pos":[7313,7458],"source":"To start, in [!INCLUDE[vs_dev10_long](../../../includes/vs-dev10-long-md.md)], create a new Console Application project named `SimpleCalculator`."},{"content":"Add a reference to the System.ComponentModel.Composition assembly, where MEF resides.","pos":[7459,7544]},{"content":"Open Module1.vb or Program.cs and add <ph id=\"ph1\">`Imports`</ph> or <ph id=\"ph2\">`using`</ph> statements for System.ComponentModel.Composition and System.ComponentModel.Composition.Hosting.","pos":[7545,7699],"source":" Open Module1.vb or Program.cs and add `Imports` or `using` statements for System.ComponentModel.Composition and System.ComponentModel.Composition.Hosting."},{"content":"These two namespaces contain MEF types you will need to develop an extensible application.","pos":[7700,7790]},{"content":"In Visual Basic, add the <ph id=\"ph1\">`Public`</ph> keyword to the line that declares the <ph id=\"ph2\">`Module1`</ph> module.","pos":[7791,7880],"source":" In Visual Basic, add the `Public` keyword to the line that declares the `Module1` module."},{"pos":[7942,7976],"content":"Composition Container and Catalogs","linkify":"Composition Container and Catalogs","nodes":[{"content":"Composition Container and Catalogs","pos":[0,34]}]},{"content":"The core of the MEF composition model is the <bpt id=\"p1\">*</bpt>composition container<ept id=\"p1\">*</ept>, which contains all the parts available and performs composition.","pos":[7980,8114],"source":"The core of the MEF composition model is the *composition container*, which contains all the parts available and performs composition."},{"content":"(That is, the matching up of imports to exports.)  The most common type of composition container is <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.Hosting.CompositionContainer&gt;</ph>, and you will use this for SimpleCalculator.","pos":[8116,8330],"source":"  (That is, the matching up of imports to exports.)  The most common type of composition container is <xref:System.ComponentModel.Composition.Hosting.CompositionContainer>, and you will use this for SimpleCalculator."},{"content":"In Visual Basic, in Module1.vb, add a public class named <ph id=\"ph1\">`Program`</ph>.","pos":[8337,8404],"source":"In Visual Basic, in Module1.vb, add a public class named `Program`."},{"content":"Then add the following line to the <ph id=\"ph1\">`Program`</ph> class in Module1.vb or Program.cs:","pos":[8405,8484],"source":" Then add the following line to the `Program` class in Module1.vb or Program.cs:"},{"content":"In order to discover the parts available to it, the composition containers makes use of a <bpt id=\"p1\">*</bpt>catalog<ept id=\"p1\">*</ept>.","pos":[8613,8713],"source":"In order to discover the parts available to it, the composition containers makes use of a *catalog*."},{"content":"A catalog is an object that makes available parts discovered from some source.","pos":[8714,8792]},{"content":"MEF provides catalogs to discover parts from a provided type, an assembly, or a directory.","pos":[8794,8884]},{"content":"Application developers can easily create new catalogs to discover parts from other sources, such as a Web service.","pos":[8885,8999]},{"pos":[9006,9059],"content":"Add the following constructor to the <ph id=\"ph1\">`Program`</ph> class:","source":"Add the following constructor to the `Program` class:"},{"content":"The call to <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.AttributedModelServices.ComposeParts%2A&gt;</ph> tells the composition container to compose a specific set of parts, in this case the current instance of <ph id=\"ph2\">`Program`</ph>.","pos":[10345,10553],"source":"The call to <xref:System.ComponentModel.Composition.AttributedModelServices.ComposeParts%2A> tells the composition container to compose a specific set of parts, in this case the current instance of `Program`."},{"content":"At this point, however, nothing will happen, since <ph id=\"ph1\">`Program`</ph> has no imports to fill.","pos":[10554,10638],"source":" At this point, however, nothing will happen, since `Program` has no imports to fill."},{"pos":[10701,10736],"content":"Imports and Exports with Attributes","linkify":"Imports and Exports with Attributes","nodes":[{"content":"Imports and Exports with Attributes","pos":[0,35]}]},{"content":"First, you have <ph id=\"ph1\">`Program`</ph> import a calculator.","pos":[10740,10786],"source":"First, you have `Program` import a calculator."},{"content":"This allows the separation of user interface concerns, such as the console input and output that will go into <ph id=\"ph1\">`Program`</ph>, from the logic of the calculator.","pos":[10787,10941],"source":" This allows the separation of user interface concerns, such as the console input and output that will go into `Program`, from the logic of the calculator."},{"pos":[10948,10994],"content":"Add the following code to the <ph id=\"ph1\">`Program`</ph> class:","source":"Add the following code to the `Program` class:"},{"content":"Notice that the declaration of the <ph id=\"ph1\">`calculator`</ph> object is not unusual, but that it is decorated with the <ph id=\"ph2\">&lt;xref:System.ComponentModel.Composition.ImportAttribute&gt;</ph> attribute.","pos":[11181,11353],"source":"Notice that the declaration of the `calculator` object is not unusual, but that it is decorated with the <xref:System.ComponentModel.Composition.ImportAttribute> attribute."},{"content":"This attribute declares something to be an import; that is, it will be filled by the composition engine when the object is composed.","pos":[11355,11487]},{"content":"Every import has a <bpt id=\"p1\">*</bpt>contract<ept id=\"p1\">*</ept>, which determines what exports it will be matched with.","pos":[11494,11579],"source":"Every import has a *contract*, which determines what exports it will be matched with."},{"content":"The contract can be an explicitly specified string, or it can be automatically generated by MEF from a given type, in this case the interface <ph id=\"ph1\">`ICalculator`</ph>.","pos":[11580,11736],"source":" The contract can be an explicitly specified string, or it can be automatically generated by MEF from a given type, in this case the interface `ICalculator`."},{"content":"Any export declared with a matching contract will fulfill this import.","pos":[11738,11808]},{"content":"Note that while the type of the <ph id=\"ph1\">`calculator`</ph> object is in fact <ph id=\"ph2\">`ICalculator`</ph>, this is not required.","pos":[11810,11909],"source":"  Note that while the type of the `calculator` object is in fact `ICalculator`, this is not required."},{"content":"The contract is independent from the type of the importing object.","pos":[11910,11976]},{"content":"(In this case, you could leave out the <ph id=\"ph1\">`typeof(ICalculator)`</ph>.","pos":[11978,12039],"source":"  (In this case, you could leave out the `typeof(ICalculator)`."},{"content":"MEF will automatically assume the contract to be based on the type of the import unless you specify it explicitly.)","pos":[12041,12156]},{"pos":[12163,12240],"content":"Add this very simple interface to the module or <ph id=\"ph1\">`SimpleCalculator`</ph> namespace:","source":"Add this very simple interface to the module or `SimpleCalculator` namespace:"},{"content":"Now that you have defined <ph id=\"ph1\">`ICalculator`</ph>, you need a class that implements it.","pos":[12467,12544],"source":"Now that you have defined `ICalculator`, you need a class that implements it."},{"content":"Add the following class to the module or <ph id=\"ph1\">`SimpleCalculator`</ph> namespace:","pos":[12546,12616],"source":"  Add the following class to the module or `SimpleCalculator` namespace:"},{"content":"Here is the export that will match the import in <ph id=\"ph1\">`Program`</ph>.","pos":[12855,12914],"source":"Here is the export that will match the import in `Program`."},{"content":"In order for the export to match the import, the export must have the same contract.","pos":[12915,12999]},{"content":"Exporting under a contract based on <ph id=\"ph1\">`typeof(MySimpleCalculator)`</ph> would produce a mismatch, and the import would not be filled; the contract needs to match exactly.","pos":[13001,13164],"source":"  Exporting under a contract based on `typeof(MySimpleCalculator)` would produce a mismatch, and the import would not be filled; the contract needs to match exactly."},{"content":"Since the composition container will be populated with all the parts available in this assembly, the <ph id=\"ph1\">`MySimpleCalculator`</ph> part will be available.","pos":[13171,13316],"source":"Since the composition container will be populated with all the parts available in this assembly, the `MySimpleCalculator` part will be available."},{"content":"When the constructor for <ph id=\"ph1\">`Program`</ph> performs composition on the <ph id=\"ph2\">`Program`</ph> object, its import will be filled with a <ph id=\"ph3\">`MySimpleCalculator`</ph> object, which will be created for that purpose.","pos":[13318,13500],"source":"  When the constructor for `Program` performs composition on the `Program` object, its import will be filled with a `MySimpleCalculator` object, which will be created for that purpose."},{"content":"The user interface layer (<ph id=\"ph1\">`Program`</ph>) does not need to know anything else.","pos":[13507,13580],"source":"The user interface layer (`Program`) does not need to know anything else."},{"content":"You can therefore fill in the rest of the user interface logic in the <ph id=\"ph1\">`Main`</ph> method.","pos":[13582,13666],"source":"  You can therefore fill in the rest of the user interface logic in the `Main` method."},{"pos":[13673,13717],"content":"Add the following code to the <ph id=\"ph1\">`Main`</ph> method:","source":"Add the following code to the `Main` method:"},{"content":"This code simply reads a line of input and calls the <ph id=\"ph1\">`Calculate`</ph> function of <ph id=\"ph2\">`ICalculator`</ph> on the result, which it writes back to the console.","pos":[14306,14448],"source":"This code simply reads a line of input and calls the `Calculate` function of `ICalculator` on the result, which it writes back to the console."},{"content":"That is all the code you need in <ph id=\"ph1\">`Program`</ph>.","pos":[14449,14492],"source":" That is all the code you need in `Program`."},{"content":"All the rest of the work will happen in the parts.","pos":[14494,14544]},{"pos":[14602,14632],"content":"Further Imports and ImportMany","linkify":"Further Imports and ImportMany","nodes":[{"content":"Further Imports and ImportMany","pos":[0,30]}]},{"content":"In order for SimpleCalculator to be extensible, it needs to import a list of operations.","pos":[14636,14724]},{"content":"An ordinary <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.ImportAttribute&gt;</ph> attribute is filled by one and only one <ph id=\"ph2\">&lt;xref:System.ComponentModel.Composition.ExportAttribute&gt;</ph>.","pos":[14725,14891],"source":" An ordinary <xref:System.ComponentModel.Composition.ImportAttribute> attribute is filled by one and only one <xref:System.ComponentModel.Composition.ExportAttribute>."},{"content":"If more than one is available, the composition engine produces an error.","pos":[14893,14965]},{"content":"To create an import that can be filled by any number of exports, you can use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.ImportManyAttribute&gt;</ph> attribute.","pos":[14967,15119],"source":"  To create an import that can be filled by any number of exports, you can use the <xref:System.ComponentModel.Composition.ImportManyAttribute> attribute."},{"pos":[15126,15198],"content":"Add the following operations property to the <ph id=\"ph1\">`MySimpleCalculator`</ph> class:","source":"Add the following operations property to the `MySimpleCalculator` class:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Lazy%602&gt;</ph> is a type provided by MEF to hold indirect references to exports.","pos":[15419,15507],"source":"<xref:System.Lazy%602> is a type provided by MEF to hold indirect references to exports."},{"content":"Here, in addition to the exported object itself, you also get <bpt id=\"p1\">*</bpt>export metadata<ept id=\"p1\">*</ept>, or information that describes the exported object.","pos":[15509,15640],"source":"  Here, in addition to the exported object itself, you also get *export metadata*, or information that describes the exported object."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.Lazy%602&gt;</ph> contains an <ph id=\"ph2\">`IOperation`</ph> object, representing an actual operation, and an <ph id=\"ph3\">`IOperationData`</ph> object, representing its metadata.","pos":[15641,15794],"source":" Each <xref:System.Lazy%602> contains an `IOperation` object, representing an actual operation, and an `IOperationData` object, representing its metadata."},{"pos":[15801,15883],"content":"Add the following simple interfaces to the module or <ph id=\"ph1\">`SimpleCalculator`</ph> namespace:","source":"Add the following simple interfaces to the module or `SimpleCalculator` namespace:"},{"content":"In this case, the metadata for each operation is the symbol that represents that operation, such as +, -, *, and so on.","pos":[16298,16417]},{"content":"To make the addition operation available, add the following class to the module or <ph id=\"ph1\">`SimpleCalculator`</ph> namespace:","pos":[16418,16530],"source":" To make the addition operation available, add the following class to the module or `SimpleCalculator` namespace:"},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.ExportAttribute&gt;</ph> attribute functions as it did before.","pos":[17061,17159],"source":"The <xref:System.ComponentModel.Composition.ExportAttribute> attribute functions as it did before."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.ExportMetadataAttribute&gt;</ph> attribute attaches metadata, in the form of a name-value pair, to that export.","pos":[17161,17308],"source":"  The <xref:System.ComponentModel.Composition.ExportMetadataAttribute> attribute attaches metadata, in the form of a name-value pair, to that export."},{"content":"While the <ph id=\"ph1\">`Add`</ph> class implements <ph id=\"ph2\">`IOperation`</ph>, a class that implements <ph id=\"ph3\">`IOperationData`</ph> is not explicitly defined.","pos":[17310,17424],"source":"  While the `Add` class implements `IOperation`, a class that implements `IOperationData` is not explicitly defined."},{"content":"Instead, a class is implicitly created by MEF with properties based on the names of the metadata provided.","pos":[17425,17531]},{"content":"(This is one of several ways to access metadata in MEF.)","pos":[17533,17589]},{"content":"Composition in MEF is <bpt id=\"p1\">*</bpt>recursive<ept id=\"p1\">*</ept>.","pos":[17596,17630],"source":"Composition in MEF is *recursive*."},{"content":"You explicitly composed the <ph id=\"ph1\">`Program`</ph> object, which imported an <ph id=\"ph2\">`ICalculator`</ph> that turned out to be of type <ph id=\"ph3\">`MySimpleCalculator`</ph>.","pos":[17631,17760],"source":" You explicitly composed the `Program` object, which imported an `ICalculator` that turned out to be of type `MySimpleCalculator`."},{"content":"<ph id=\"ph1\">`MySimpleCalculator`</ph>, in turn, imports a collection of <ph id=\"ph2\">`IOperation`</ph> objects, and that import will be filled when <ph id=\"ph3\">`MySimpleCalculator`</ph> is created, at the same time as the imports of <ph id=\"ph4\">`Program`</ph>.","pos":[17762,17953],"source":"`MySimpleCalculator`, in turn, imports a collection of `IOperation` objects, and that import will be filled when `MySimpleCalculator` is created, at the same time as the imports of `Program`."},{"content":"If the <ph id=\"ph1\">`Add`</ph> class declared a further import, that too would have to be filled, and so on.","pos":[17954,18044],"source":" If the `Add` class declared a further import, that too would have to be filled, and so on."},{"content":"Any import left unfilled results in a composition error.","pos":[18045,18101]},{"content":"(It is possible, however, to declare imports to be optional or to assign them default values.)","pos":[18103,18197]},{"pos":[18241,18257],"content":"Calculator Logic","linkify":"Calculator Logic","nodes":[{"content":"Calculator Logic","pos":[0,16]}]},{"content":"With these parts in place, all that remains is the calculator logic itself.","pos":[18261,18336]},{"content":"Add the following code in the <ph id=\"ph1\">`MySimpleCalculator`</ph> class to implement the <ph id=\"ph2\">`Calculate`</ph> method:","pos":[18337,18430],"source":" Add the following code in the `MySimpleCalculator` class to implement the `Calculate` method:"},{"content":"The initial steps parse the input string into left and right operands and an operator character.","pos":[19979,20075]},{"content":"In the <ph id=\"ph1\">`foreach`</ph> loop, every member of the <ph id=\"ph2\">`operations`</ph> collection is examined.","pos":[20077,20156],"source":"  In the `foreach` loop, every member of the `operations` collection is examined."},{"content":"These objects are of type <ph id=\"ph1\">&lt;xref:System.Lazy%602&gt;</ph>, and their metadata values and exported object can be accessed with the <ph id=\"ph2\">&lt;xref:System.Lazy%602.Metadata%2A&gt;</ph> property and the <ph id=\"ph3\">&lt;xref:System.Lazy%601.Value%2A&gt;</ph>property respectively.","pos":[20157,20383],"source":" These objects are of type <xref:System.Lazy%602>, and their metadata values and exported object can be accessed with the <xref:System.Lazy%602.Metadata%2A> property and the <xref:System.Lazy%601.Value%2A>property respectively."},{"content":"In this case, if the <ph id=\"ph1\">`Symbol`</ph> property of the <ph id=\"ph2\">`IOperationData`</ph> object is discovered to be a match, the calculator calls the <ph id=\"ph3\">`Operate`</ph> method of the <ph id=\"ph4\">`IOperation`</ph> object and returns the result.","pos":[20384,20575],"source":" In this case, if the `Symbol` property of the `IOperationData` object is discovered to be a match, the calculator calls the `Operate` method of the `IOperation` object and returns the result."},{"content":"To complete the calculator, you also need a helper method that returns the position of the first non-digit character in a string.","pos":[20582,20711]},{"content":"Add the following helper method to the <ph id=\"ph1\">`MySimpleCalculator`</ph> class:","pos":[20713,20779],"source":"  Add the following helper method to the `MySimpleCalculator` class:"},{"content":"You should now be able to compile and run the project.","pos":[21186,21240]},{"content":"In Visual Basic, make sure that you added the <ph id=\"ph1\">`Public`</ph> keyword to <ph id=\"ph2\">`Module1`</ph>.","pos":[21241,21317],"source":" In Visual Basic, make sure that you added the `Public` keyword to `Module1`."},{"content":"In the console window, type an addition operation, such as \"5+3\", and the calculator will return the results.","pos":[21318,21427]},{"content":"Any other operator will result in the \"Operation Not Found!\"","pos":[21429,21489]},{"content":"message.","pos":[21490,21498]},{"pos":[21570,21614],"content":"Extending SimpleCalculator Using A New Class","linkify":"Extending SimpleCalculator Using A New Class","nodes":[{"content":"Extending SimpleCalculator Using A New Class","pos":[0,44]}]},{"content":"Now that the calculator works, adding a new operation is easy.","pos":[21618,21680]},{"content":"Add the following class to the module or <ph id=\"ph1\">`SimpleCalculator`</ph> namespace:","pos":[21681,21751],"source":" Add the following class to the module or `SimpleCalculator` namespace:"},{"content":"Compile and run the project.","pos":[22293,22321]},{"content":"Type a subtraction operation, such as \"5-3\".","pos":[22322,22366]},{"content":"The calculator now supports subtraction as well as addition.","pos":[22367,22427]},{"pos":[22502,22549],"content":"Extending SimpleCalculator Using A New Assembly","linkify":"Extending SimpleCalculator Using A New Assembly","nodes":[{"content":"Extending SimpleCalculator Using A New Assembly","pos":[0,47]}]},{"content":"Adding classes to the source code is simple enough, but MEF provides the ability to look outside an application’s own source for parts.","pos":[22553,22688]},{"content":"To demonstrate this, you will need to modify SimpleCalculator to search a directory, as well as its own assembly, for parts, by adding a <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog&gt;</ph>.","pos":[22689,22892],"source":" To demonstrate this, you will need to modify SimpleCalculator to search a directory, as well as its own assembly, for parts, by adding a <xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog>."},{"content":"Add a new directory named <ph id=\"ph1\">`Extensions`</ph> to the SimpleCalculator project.","pos":[22899,22970],"source":"Add a new directory named `Extensions` to the SimpleCalculator project."},{"content":"Make sure to add it at the project level, and not at the solution level.","pos":[22972,23044]},{"content":"Then add a new Class Library project to the solution, named <ph id=\"ph1\">`ExtendedOperations`</ph>.","pos":[23045,23126],"source":" Then add a new Class Library project to the solution, named `ExtendedOperations`."},{"content":"The new project will compile into a separate assembly.","pos":[23127,23181]},{"content":"Open the Project Properties Designer for the ExtendedOperations project and click the <bpt id=\"p1\">**</bpt>Compile<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>Build<ept id=\"p2\">**</ept> tab.","pos":[23188,23303],"source":"Open the Project Properties Designer for the ExtendedOperations project and click the **Compile** or **Build** tab."},{"content":"Change the <bpt id=\"p1\">**</bpt>Build output path<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>Output path<ept id=\"p2\">**</ept> to point to the Extensions directory in the SimpleCalculator project directory (..\\SimpleCalculator\\Extensions<ph id=\"ph1\">\\\\</ph>).","pos":[23304,23470],"source":" Change the **Build output path** or **Output path** to point to the Extensions directory in the SimpleCalculator project directory (..\\SimpleCalculator\\Extensions\\\\)."},{"pos":[23477,23558],"content":"In Module1.vb or Program.cs, add the following line to the <ph id=\"ph1\">`Program`</ph> constructor:","source":"In Module1.vb or Program.cs, add the following line to the `Program` constructor:"},{"content":"Replace the example path with the path to your Extensions directory.","pos":[23799,23867]},{"content":"(This absolute path is for debugging purposes only.","pos":[23869,23920]},{"content":"In a production application, you would use a relative path.) The <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog&gt;</ph> will now add any parts found in any assemblies in the Extensions directory to the composition container.","pos":[23922,24157],"source":"  In a production application, you would use a relative path.) The <xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog> will now add any parts found in any assemblies in the Extensions directory to the composition container."},{"content":"In the ExtendedOperations project, add references to SimpleCalculator and System.ComponentModel.Composition.","pos":[24164,24272]},{"content":"In the ExtendedOperations class file, add an <ph id=\"ph1\">`Imports`</ph> or a <ph id=\"ph2\">`using`</ph> statement for System.ComponentModel.Composition.","pos":[24273,24389],"source":" In the ExtendedOperations class file, add an `Imports` or a `using` statement for System.ComponentModel.Composition."},{"content":"In Visual Basic, also add an <ph id=\"ph1\">`Imports`</ph> statement for SimpleCalculator.","pos":[24390,24460],"source":" In Visual Basic, also add an `Imports` statement for SimpleCalculator."},{"content":"Then add the following class to the ExtendedOperations class file:","pos":[24461,24527]},{"content":"Note that in order for the contract to match, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition.ExportAttribute&gt;</ph> attribute must have the same type as the <ph id=\"ph2\">&lt;xref:System.ComponentModel.Composition.ImportAttribute&gt;</ph>.","pos":[25122,25327],"source":"Note that in order for the contract to match, the <xref:System.ComponentModel.Composition.ExportAttribute> attribute must have the same type as the <xref:System.ComponentModel.Composition.ImportAttribute>."},{"content":"Compile and run the project.","pos":[25334,25362]},{"content":"Test the new Mod (%) operator.","pos":[25363,25393]},{"pos":[25431,25441],"content":"Conclusion","linkify":"Conclusion","nodes":[{"content":"Conclusion","pos":[0,10]}]},{"content":"This topic covered the basic concepts of MEF.","pos":[25445,25490]},{"content":"Parts, catalogs, and the composition container","pos":[25500,25546]},{"content":"Parts and the composition container are the basic building blocks of a MEF application.","pos":[25557,25644]},{"content":"A part is any object that imports or exports a value, up to and including itself.","pos":[25645,25726]},{"content":"A catalog provides a collection of parts from a particular source.","pos":[25727,25793]},{"content":"The composition container uses the parts provided by a catalog to perform composition, the binding of imports to exports.","pos":[25795,25916]},{"content":"Imports and exports","pos":[25926,25945]},{"content":"Imports and exports are the way by which components communicate.","pos":[25956,26020]},{"content":"With an import, the component specifies a need for a particular value or object, and with an export it specifies the availability of a value.","pos":[26021,26162]},{"content":"Each import is matched with a list of exports by way of its contract.","pos":[26163,26232]},{"pos":[26277,26295],"content":"Where Do I Go Now?","linkify":"Where Do I Go Now?","nodes":[{"content":"Where Do I Go Now?","pos":[0,18]}]},{"pos":[26299,26459],"content":"To download the complete code for this example, see the <bpt id=\"p1\">[</bpt>SimpleCalculator sample<ept id=\"p1\">](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e)</ept>.","source":"To download the complete code for this example, see the [SimpleCalculator sample](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e)."},{"content":"For more information and code examples, see <bpt id=\"p1\">[</bpt>Managed Extensibility Framework<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=144282)</ept>.","pos":[26466,26591],"source":"For more information and code examples, see [Managed Extensibility Framework](http://go.microsoft.com/fwlink/?LinkId=144282)."},{"content":"For a list of the MEF types, see the <ph id=\"ph1\">&lt;xref:System.ComponentModel.Composition?displayProperty=fullName&gt;</ph> namespace.","pos":[26592,26705],"source":" For a list of the MEF types, see the <xref:System.ComponentModel.Composition?displayProperty=fullName> namespace."}]}