{"content":"---\ntitle: \"Variance in Generic Interfaces (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 4828a8f9-48c0-4128-9749-7fcd6bf19a06\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Variance in Generic Interfaces (C#)\n.NET Framework 4 introduced variance support for several existing generic interfaces. Variance support enables implicit conversion of classes that implement these interfaces. The following interfaces are now variant:  \n  \n-   <xref:System.Collections.Generic.IEnumerable%601> (T is covariant)  \n  \n-   <xref:System.Collections.Generic.IEnumerator%601> (T is covariant)  \n  \n-   <xref:System.Linq.IQueryable%601> (T is covariant)  \n  \n-   <xref:System.Linq.IGrouping%602> (`TKey` and `TElement` are covariant)  \n  \n-   <xref:System.Collections.Generic.IComparer%601> (T is contravariant)  \n  \n-   <xref:System.Collections.Generic.IEqualityComparer%601> (T is contravariant)  \n  \n-   <xref:System.IComparable%601> (T is contravariant)  \n  \n Covariance permits a method to have a more derived return type than that defined by the generic type parameter of the interface. To illustrate the covariance feature, consider these generic interfaces: `IEnumerable<Object>` and `IEnumerable<String>`. The `IEnumerable<String>` interface does not inherit the `IEnumerable<Object>` interface. However, the `String` type does inherit the `Object` type, and in some cases you may want to assign objects of these interfaces to each other. This is shown in the following code example.  \n  \n```csharp  \nIEnumerable<String> strings = new List<String>();  \nIEnumerable<Object> objects = strings;  \n```  \n  \n In earlier versions of the .NET Framework, this code causes a compilation error in C# with `Option Strict On`. But now you can use `strings` instead of `objects`, as shown in the previous example, because the <xref:System.Collections.Generic.IEnumerable%601> interface is covariant.  \n  \n Contravariance permits a method to have argument types that are less derived than that specified by the generic parameter of the interface. To illustrate contravariance, assume that you have created a `BaseComparer` class to compare instances of the `BaseClass` class. The `BaseComparer` class implements the `IEqualityComparer<BaseClass>` interface. Because the <xref:System.Collections.Generic.IEqualityComparer%601> interface is now contravariant, you can use `BaseComparer` to compare instances of classes that inherit the `BaseClass` class. This is shown in the following code example.  \n  \n```csharp  \n// Simple hierarchy of classes.  \nclass BaseClass { }  \nclass DerivedClass : BaseClass { }  \n  \n// Comparer class.  \nclass BaseComparer : IEqualityComparer<BaseClass>   \n{  \n    public int GetHashCode(BaseClass baseInstance)  \n    {  \n        return baseInstance.GetHashCode();  \n    }  \n    public bool Equals(BaseClass x, BaseClass y)  \n    {  \n        return x == y;  \n    }  \n}  \nclass Program  \n{  \n    static void Test()  \n    {  \n        IEqualityComparer<BaseClass> baseComparer = new BaseComparer();  \n  \n        // Implicit conversion of IEqualityComparer<BaseClass> to   \n        // IEqualityComparer<DerivedClass>.  \n        IEqualityComparer<DerivedClass> childComparer = baseComparer;  \n    }  \n}  \n```  \n  \n For more examples, see [Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md).  \n  \n Variance in generic interfaces is supported for reference types only. Value types do not support variance. For example, `IEnumerable<int>` cannot be implicitly converted to `IEnumerable<object>`, because integers are represented by a value type.  \n  \n```csharp  \nIEnumerable<int> integers = new List<int>();  \n// The following statement generates a compiler errror,  \n// because int is a value type.  \n// IEnumerable<Object> objects = integers;  \n```  \n  \n It is also important to remember that classes that implement variant interfaces are still invariant. For example, although <xref:System.Collections.Generic.List%601> implements the covariant interface <xref:System.Collections.Generic.IEnumerable%601>, you cannot implicitly convert `List<Object>` to `List<String>`. This is illustrated in the following code example.  \n  \n```csharp  \n// The following line generates a compiler error  \n// because classes are invariant.  \n// List<Object> list = new List<String>();  \n  \n// You can use the interface object instead.  \nIEnumerable<Object> listObjects = new List<String>();  \n```  \n  \n## See Also  \n [Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)   \n [Creating Variant Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md)   \n [Generic Interfaces](../../../../standard/generics/interfaces.md)   \n [Variance in Delegates (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)","nodes":[{"pos":[4,416],"nodes":[{"content":"Variance in Generic Interfaces (C#) | Microsoft Docs","nodes":[{"pos":[0,52],"content":"Variance in Generic Interfaces (C#) | Microsoft Docs","nodes":[{"content":"Variance in Generic Interfaces (C#) | Microsoft Docs","pos":[0,52]}]}],"pos":[6,61],"yaml":true}],"content":"title: \"Variance in Generic Interfaces (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 4828a8f9-48c0-4128-9749-7fcd6bf19a06\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","yamlblock":true},{"pos":[423,458],"content":"Variance in Generic Interfaces (C#)","linkify":"Variance in Generic Interfaces (C#)","nodes":[{"content":"Variance in Generic Interfaces (C#)","pos":[0,35]}]},{"content":".NET Framework 4 introduced variance support for several existing generic interfaces.","pos":[459,544]},{"content":"Variance support enables implicit conversion of classes that implement these interfaces.","pos":[545,633]},{"content":"The following interfaces are now variant:","pos":[634,675]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> (T is covariant)","pos":[685,751],"source":"<xref:System.Collections.Generic.IEnumerable%601> (T is covariant)"},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph> (T is covariant)","pos":[761,827],"source":"<xref:System.Collections.Generic.IEnumerator%601> (T is covariant)"},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.IQueryable%601&gt;</ph> (T is covariant)","pos":[837,887],"source":"<xref:System.Linq.IQueryable%601> (T is covariant)"},{"pos":[897,967],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> (<ph id=\"ph2\">`TKey`</ph> and <ph id=\"ph3\">`TElement`</ph> are covariant)","source":"<xref:System.Linq.IGrouping%602> (`TKey` and `TElement` are covariant)"},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> (T is contravariant)","pos":[977,1045],"source":"<xref:System.Collections.Generic.IComparer%601> (T is contravariant)"},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> (T is contravariant)","pos":[1055,1131],"source":"<xref:System.Collections.Generic.IEqualityComparer%601> (T is contravariant)"},{"content":"<ph id=\"ph1\">&lt;xref:System.IComparable%601&gt;</ph> (T is contravariant)","pos":[1141,1191],"source":"<xref:System.IComparable%601> (T is contravariant)"},{"content":"Covariance permits a method to have a more derived return type than that defined by the generic type parameter of the interface.","pos":[1198,1326]},{"content":"To illustrate the covariance feature, consider these generic interfaces: <ph id=\"ph1\">`IEnumerable&lt;Object&gt;`</ph> and <ph id=\"ph2\">`IEnumerable&lt;String&gt;`</ph>.","pos":[1327,1448],"source":" To illustrate the covariance feature, consider these generic interfaces: `IEnumerable<Object>` and `IEnumerable<String>`."},{"content":"The <ph id=\"ph1\">`IEnumerable&lt;String&gt;`</ph> interface does not inherit the <ph id=\"ph2\">`IEnumerable&lt;Object&gt;`</ph> interface.","pos":[1449,1538],"source":" The `IEnumerable<String>` interface does not inherit the `IEnumerable<Object>` interface."},{"content":"However, the <ph id=\"ph1\">`String`</ph> type does inherit the <ph id=\"ph2\">`Object`</ph> type, and in some cases you may want to assign objects of these interfaces to each other.","pos":[1539,1681],"source":" However, the `String` type does inherit the `Object` type, and in some cases you may want to assign objects of these interfaces to each other."},{"content":"This is shown in the following code example.","pos":[1682,1726]},{"content":"In earlier versions of the .NET Framework, this code causes a compilation error in C# with <ph id=\"ph1\">`Option Strict On`</ph>.","pos":[1847,1957],"source":"In earlier versions of the .NET Framework, this code causes a compilation error in C# with `Option Strict On`."},{"content":"But now you can use <ph id=\"ph1\">`strings`</ph> instead of <ph id=\"ph2\">`objects`</ph>, as shown in the previous example, because the <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface is covariant.","pos":[1958,2129],"source":" But now you can use `strings` instead of `objects`, as shown in the previous example, because the <xref:System.Collections.Generic.IEnumerable%601> interface is covariant."},{"content":"Contravariance permits a method to have argument types that are less derived than that specified by the generic parameter of the interface.","pos":[2136,2275]},{"content":"To illustrate contravariance, assume that you have created a <ph id=\"ph1\">`BaseComparer`</ph> class to compare instances of the <ph id=\"ph2\">`BaseClass`</ph> class.","pos":[2276,2404],"source":" To illustrate contravariance, assume that you have created a `BaseComparer` class to compare instances of the `BaseClass` class."},{"content":"The <ph id=\"ph1\">`BaseComparer`</ph> class implements the <ph id=\"ph2\">`IEqualityComparer&lt;BaseClass&gt;`</ph> interface.","pos":[2405,2486],"source":" The `BaseComparer` class implements the `IEqualityComparer<BaseClass>` interface."},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> interface is now contravariant, you can use <ph id=\"ph2\">`BaseComparer`</ph> to compare instances of classes that inherit the <ph id=\"ph3\">`BaseClass`</ph> class.","pos":[2487,2681],"source":" Because the <xref:System.Collections.Generic.IEqualityComparer%601> interface is now contravariant, you can use `BaseComparer` to compare instances of classes that inherit the `BaseClass` class."},{"content":"This is shown in the following code example.","pos":[2682,2726]},{"pos":[3467,3679],"content":"For more examples, see <bpt id=\"p1\">[</bpt>Using Variance in Interfaces for Generic Collections (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)</ept>.","source":"For more examples, see [Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)."},{"content":"Variance in generic interfaces is supported for reference types only.","pos":[3686,3755]},{"content":"Value types do not support variance.","pos":[3756,3792]},{"content":"For example, <ph id=\"ph1\">`IEnumerable&lt;int&gt;`</ph> cannot be implicitly converted to <ph id=\"ph2\">`IEnumerable&lt;object&gt;`</ph>, because integers are represented by a value type.","pos":[3793,3931],"source":" For example, `IEnumerable<int>` cannot be implicitly converted to `IEnumerable<object>`, because integers are represented by a value type."},{"content":"It is also important to remember that classes that implement variant interfaces are still invariant.","pos":[4143,4243]},{"content":"For example, although <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements the covariant interface <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, you cannot implicitly convert <ph id=\"ph3\">`List&lt;Object&gt;`</ph> to <ph id=\"ph4\">`List&lt;String&gt;`</ph>.","pos":[4244,4458],"source":" For example, although <xref:System.Collections.Generic.List%601> implements the covariant interface <xref:System.Collections.Generic.IEnumerable%601>, you cannot implicitly convert `List<Object>` to `List<String>`."},{"content":"This is illustrated in the following code example.","pos":[4459,4509]},{"pos":[4777,4785],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Using Variance in Interfaces for Generic Collections (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)</ept><ph id=\"ph1\"> </ph>","pos":[4789,4978],"source":"[Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md) "},{"content":"<bpt id=\"p1\">[</bpt>Creating Variant Generic Interfaces (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md)</ept><ph id=\"ph1\"> </ph>","pos":[4982,5137],"source":"[Creating Variant Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md) "},{"content":"<bpt id=\"p1\">[</bpt>Generic Interfaces<ept id=\"p1\">](../../../../standard/generics/interfaces.md)</ept><ph id=\"ph1\"> </ph>","pos":[5141,5207],"source":"[Generic Interfaces](../../../../standard/generics/interfaces.md) "},{"content":"<bpt id=\"p1\">[</bpt>Variance in Delegates (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)</ept>","pos":[5211,5337],"source":"[Variance in Delegates (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)"}]}