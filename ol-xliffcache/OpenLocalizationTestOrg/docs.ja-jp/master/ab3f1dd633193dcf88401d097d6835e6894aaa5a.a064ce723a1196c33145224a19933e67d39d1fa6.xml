{"content":"---\ntitle: \"Delegation and Impersonation with WCF\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"impersonation [WCF]\"\n  - \"delegation [WCF]\"\nms.assetid: 110e60f7-5b03-4b69-b667-31721b8e3152\n---\n# Delegation and Impersonation with WCF\n*Impersonation* is a common technique that services use to restrict client access to a service domain's resources. Service domain resources can either be machine resources, such as local files (impersonation), or a resource on another machine, such as a file share (delegation). For a sample application, see [Impersonating the Client](../../../../docs/framework/wcf/samples/impersonating-the-client.md). For an example of how to use impersonation, see [How to: Impersonate a Client on a Service](../../../../docs/framework/wcf/how-to-impersonate-a-client-on-a-service.md).  \n  \n> [!IMPORTANT]\n>  Be aware that when impersonating a client on a service, the service runs with the client's credentials, which may have higher privileges than the server process.  \n  \n## Overview  \n Typically, clients call a service to have the service perform some action on the client’s behalf. Impersonation allows the service to act as the client while performing the action. Delegation allows a front-end service to forward the client’s request to a back-end service in such a way that the back-end service can also impersonate the client. Impersonation is most commonly used as a way of checking whether a client is authorized to perform a particular action, while delegation is a way of flowing impersonation capabilities, along with the client’s identity, to a back-end service. Delegation is a Windows domain feature that can be used when Kerberos-based authentication is performed. Delegation is distinct from identity flow and, because delegation transfers the ability to impersonate the client without possession of the client’s password, it is a much higher privileged operation than identity flow.  \n  \n Both impersonation and delegation require that the client have a Windows identity. If a client does not possess a Windows identity, then the only option available is to flow the client’s identity to the second service.  \n  \n## Impersonation Basics  \n Windows Communication Foundation (WCF) supports impersonation for a variety of client credentials. This topic describes service model support for impersonating the caller during the implementation of a service method. Also discussed are common deployment scenarios involving impersonation and SOAP security and WCF options in these scenarios.  \n  \n This topic focuses on impersonation and delegation in WCF when using SOAP security. You can also use impersonation and delegation with WCF when using transport security, as described in [Using Impersonation with Transport Security](../../../../docs/framework/wcf/feature-details/using-impersonation-with-transport-security.md).  \n  \n## Two Methods  \n WCF SOAP security has two distinct methods for performing impersonation. The method used depends on the binding. One is impersonation from a Windows token obtained from the Security Support Provider Interface (SSPI) or Kerberos authentication, which is then cached on the service. The second is impersonation from a Windows token obtained from the Kerberos extensions, collectively called *Service-for-User* (S4U).  \n  \n### Cached Token Impersonation  \n You can perform cached-token impersonation with the following:  \n  \n-   <xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>, and <xref:System.ServiceModel.NetTcpBinding> with a Windows client credential.  \n  \n-   <xref:System.ServiceModel.BasicHttpBinding> with a <xref:System.ServiceModel.BasicHttpSecurityMode> set to the <xref:System.ServiceModel.BasicHttpSecurityMode.TransportWithMessageCredential> credential, or any other standard binding where the client presents a user name credential that the service can map to a valid Windows account.  \n  \n-   Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a Windows client credential with the `requireCancellation` set to `true`. (The property is available on the following classes: <xref:System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters>, <xref:System.ServiceModel.Security.Tokens.SslSecurityTokenParameters>, and <xref:System.ServiceModel.Security.Tokens.SspiSecurityTokenParameters>.) If a secure conversation is used on the binding, it must also have the `requireCancellation` property set to `true`.  \n  \n-   Any <xref:System.ServiceModel.Channels.CustomBinding> where the client presents a user name credential. If secure conversation is used on the binding, it must also have the `requireCancellation` property set to `true`.  \n  \n### S4U-Based Impersonation  \n You can perform S4U-based impersonation with the following:  \n  \n-   <xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>, and <xref:System.ServiceModel.NetTcpBinding> with a certificate client credential that the service can map to a valid Windows account.  \n  \n-   Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a Windows client credential with the `requireCancellation` property set to `false`.  \n  \n-   Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a user name or Windows client credential and secure conversation with the `requireCancellation` property set to `false`.  \n  \n The extent to which the service can impersonate the client depends on the privileges the service account holds when it attempts impersonation, the type of impersonation used, and possibly the extent of impersonation the client permits.  \n  \n> [!NOTE]\n>  When the client and service are running on the same computer and the client is running under a system account (for example, `Local System` or `Network Service`), the client cannot be impersonated when a secure session is established with stateful Security Context tokens. A Windows Form or console application typically runs under the currently logged-in account, so that account can be impersonated by default. However, when the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page and that page is hosted in [!INCLUDE[iis601](../../../../includes/iis601-md.md)] or [!INCLUDE[iisver](../../../../includes/iisver-md.md)], then the client does run under the `Network Service` account by default. All of the system-provided bindings that support secure sessions use a stateless security context token (SCT) by default. However, if the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page, and secure sessions with stateful SCTs are used, the client cannot be impersonated. For more information about using stateful SCTs in a secure session, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).  \n  \n## Impersonation in a Service Method: Declarative Model  \n Most impersonation scenarios involve executing the service method in the caller context. WCF provides an impersonation feature that makes this easy to do by allowing the user to specify the impersonation requirement in the <xref:System.ServiceModel.OperationBehaviorAttribute> attribute. For example, in the following code, the WCF infrastructure impersonates the caller before executing the `Hello` method. Any attempt to access native resources inside the `Hello` method succeed only if the access control list (ACL) of the resource allows the caller access privileges. To enable impersonation, set the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property to one of the <xref:System.ServiceModel.ImpersonationOption> enumeration values, either <xref:System.ServiceModel.ImpersonationOption.Required?displayProperty=nameWithType> or <xref:System.ServiceModel.ImpersonationOption.Allowed?displayProperty=nameWithType>, as shown in the following example.  \n  \n> [!NOTE]\n>  When a service has higher credentials than the remote client, the credentials of the service are used if the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property is set to <xref:System.ServiceModel.ImpersonationOption.Allowed>. That is, if a low-privileged user provides its credentials, a higher-privileged service executes the method with the credentials of the service, and can use resources that the low-privileged user would otherwise not be able to use.  \n  \n [!code-csharp[c_ImpersonationAndDelegation#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#1)]\n [!code-vb[c_ImpersonationAndDelegation#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#1)]  \n  \n The WCF infrastructure can impersonate the caller only if the caller is authenticated with credentials that can be mapped to a Windows user account. If the service is configured to authenticate using a credential that cannot be mapped to a Windows account, the service method is not executed.  \n  \n> [!NOTE]\n>  On [!INCLUDE[wxp](../../../../includes/wxp-md.md)], impersonation fails if a stateful SCT is created, resulting in an <xref:System.InvalidOperationException>. For more information, see [Unsupported Scenarios](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md).  \n  \n## Impersonation in a Service Method: Imperative Model  \n Sometimes a caller does not need to impersonate the entire service method to function, but for only a portion of it. In this case, obtain the Windows identity of the caller inside the service method and imperatively perform the impersonation. Do this by using the <xref:System.ServiceModel.ServiceSecurityContext.WindowsIdentity%2A> property of the <xref:System.ServiceModel.ServiceSecurityContext> to return an instance of the <xref:System.Security.Principal.WindowsIdentity> class and calling the <xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> method before using the instance.  \n  \n> [!NOTE]\n>  Be sure to use the Visual Basic`Using` statement or the C# `using` statement to automatically revert the impersonation action. If you do not use the statement, or if you use a programming language other than Visual Basic or C#, be sure to revert the impersonation level. Failure to do this can form the basis for denial of service and elevation of privilege attacks.  \n  \n [!code-csharp[c_ImpersonationAndDelegation#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#2)]\n [!code-vb[c_ImpersonationAndDelegation#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#2)]  \n  \n## Impersonation for All Service Methods  \n In some cases, you must perform all the methods of a service in the caller’s context. Instead of explicitly enabling this feature on a per-method basis, use the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior>. As shown in the following code, set the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior.ImpersonateCallerForAllOperations%2A> property to `true`. The <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior> is retrieved from the collections of behaviors of the <xref:System.ServiceModel.ServiceHost> class. Also note that the `Impersonation` property of the <xref:System.ServiceModel.OperationBehaviorAttribute> applied to each method must also be set to either <xref:System.ServiceModel.ImpersonationOption.Allowed> or <xref:System.ServiceModel.ImpersonationOption.Required>.  \n  \n [!code-csharp[c_ImpersonationAndDelegation#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#3)]\n [!code-vb[c_ImpersonationAndDelegation#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#3)]  \n  \n The following table describes WCF behavior for all possible combinations of `ImpersonationOption` and `ImpersonateCallerForAllServiceOperations`.  \n  \n|`ImpersonationOption`|`ImpersonateCallerForAllServiceOperations`|Behavior|  \n|---------------------------|------------------------------------------------|--------------|  \n|Required|n/a|WCF impersonates the caller|  \n|Allowed|false|WCF does not impersonate the caller|  \n|Allowed|true|WCF impersonates the caller|  \n|NotAllowed|false|WCF does not impersonate the caller|  \n|NotAllowed|true|Disallowed. (An <xref:System.InvalidOperationException> is thrown.)|  \n  \n## Impersonation Level Obtained from Windows Credentials and Cached Token Impersonation  \n In some scenarios the client has partial control over the level of impersonation the service performs when a Windows client credential is used. One scenario occurs when the client specifies an Anonymous impersonation level. The other occurs when performing impersonation with a cached token. This is done by setting the <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> property of the <xref:System.ServiceModel.Security.WindowsClientCredential> class, which is accessed as a property of the generic <xref:System.ServiceModel.ChannelFactory%601> class.  \n  \n> [!NOTE]\n>  Specifying an impersonation level of Anonymous causes the client to log on to the service anonymously. The service must therefore allow anonymous logons, regardless of whether impersonation is performed.  \n  \n The client can specify the impersonation level as <xref:System.Security.Principal.TokenImpersonationLevel.Anonymous>, <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>, or <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>. Only a token at the specified level is produced, as shown in the following code.  \n  \n [!code-csharp[c_ImpersonationAndDelegation#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#4)]\n [!code-vb[c_ImpersonationAndDelegation#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#4)]  \n  \n The following table specifies the impersonation level the service obtains when impersonating from a cached token.  \n  \n|`AllowedImpersonationLevel` value|Service has `SeImpersonatePrivilege`|Service and client are capable of delegation|Cached token `ImpersonationLevel`|  \n|---------------------------------------|------------------------------------------|--------------------------------------------------|---------------------------------------|  \n|Anonymous|Yes|n/a|Impersonation|  \n|Anonymous|No|n/a|Identification|  \n|Identification|n/a|n/a|Identification|  \n|Impersonation|Yes|n/a|Impersonation|  \n|Impersonation|No|n/a|Identification|  \n|Delegation|Yes|Yes|Delegation|  \n|Delegation|Yes|No|Impersonation|  \n|Delegation|No|n/a|Identification|  \n  \n## Impersonation Level Obtained from User Name Credentials and Cached Token Impersonation  \n By passing the service its user name and password, a client enables WCF to log on as that user, which is equivalent to setting the `AllowedImpersonationLevel` property to <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>. (The `AllowedImpersonationLevel` is available on the <xref:System.ServiceModel.Security.WindowsClientCredential> and <xref:System.ServiceModel.Security.HttpDigestClientCredential> classes.) The following table provides the impersonation level obtained when the service receives user name credentials.  \n  \n|`AllowedImpersonationLevel`|Service has `SeImpersonatePrivilege`|Service and client are capable of delegation|Cached token `ImpersonationLevel`|  \n|---------------------------------|------------------------------------------|--------------------------------------------------|---------------------------------------|  \n|n/a|Yes|Yes|Delegation|  \n|n/a|Yes|No|Impersonation|  \n|n/a|No|n/a|Identification|  \n  \n## Impersonation Level Obtained from S4U-Based Impersonation  \n  \n|Service has `SeTcbPrivilege`|Service has `SeImpersonatePrivilege`|Service and client are capable of delegation|Cached token `ImpersonationLevel`|  \n|----------------------------------|------------------------------------------|--------------------------------------------------|---------------------------------------|  \n|Yes|Yes|n/a|Impersonation|  \n|Yes|No|n/a|Identification|  \n|No|n/a|n/a|Identification|  \n  \n## Mapping a Client Certificate to a Windows Account  \n It is possible for a client to authenticate itself to a service using a certificate, and to have the service map the client to an existing account through Active Directory. The following XML shows how to configure the service to map the certificate.  \n  \n```xml  \n<behaviors>  \n  <serviceBehaviors>  \n    <behavior name=\"MapToWindowsAccount\">  \n      <serviceCredentials>  \n        <clientCertificate>  \n          <authentication mapClientCertificateToWindowsAccount=\"true\" />  \n        </clientCertificate>  \n      </serviceCredentials>  \n    </behavior>  \n  </serviceBehaviors>  \n</behaviors>  \n```  \n  \n The following code shows how to configure the service.  \n  \n```  \n// Create a binding that sets a certificate as the client credential type.  \nWSHttpBinding b = new WSHttpBinding();  \nb.Security.Message.ClientCredentialType = MessageCredentialType.Certificate;  \n  \n// Create a service host that maps the certificate to a Windows account.  \nUri httpUri = new Uri(\"http://localhost/Calculator\");  \nServiceHost sh = new ServiceHost(typeof(HelloService), httpUri);  \nsh.Credentials.ClientCertificate.Authentication.MapClientCertificateToWindowsAccount = true;  \n```  \n  \n## Delegation  \n To delegate to a back-end service, a service must perform Kerberos multi-leg (SSPI without NTLM fallback) or Kerberos direct authentication to the back-end service using the client’s Windows identity. To delegate to a back-end service, create a <xref:System.ServiceModel.ChannelFactory%601> and a channel, and then communicate through the channel while impersonating the client. With this form of delegation, the distance at which the back-end service can be located from the front-end service depends on the impersonation level achieved by the front-end service. When the impersonation level is <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>, the front-end and back-end services must be running on the same machine. When the impersonation level is <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>, the front-end and back-end services can be on separate machines or on the same machine. Enabling delegation-level impersonation requires that Windows domain policy be configured to permit delegation. For more information about configuring Active Directory for delegation support, see [Enabling Delegated Authentication](https://go.microsoft.com/fwlink/?LinkId=99690).  \n  \n> [!NOTE]\n>  When a client authenticates to the front-end service using a user name and password that correspond to a Windows account on the back-end service, the front-end service can authenticate to the back-end service by reusing the client’s user name and password. This is a particularly powerful form of identity flow, because passing user name and password to the back-end service enables the back-end service to perform impersonation, but it does not constitute delegation because Kerberos is not used. Active Directory controls on delegation do not apply to user name and password authentication.  \n  \n### Delegation Ability as a Function of Impersonation Level  \n  \n|Impersonation level|Service can perform cross-process delegation|Service can perform cross-machine delegation|  \n|-------------------------|---------------------------------------------------|---------------------------------------------------|  \n|<xref:System.Security.Principal.TokenImpersonationLevel.Identification>|No|No|  \n|<xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>|Yes|No|  \n|<xref:System.Security.Principal.TokenImpersonationLevel.Delegation>|Yes|Yes|  \n  \n The following code example demonstrates how to use delegation.  \n  \n [!code-csharp[c_delegation#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_delegation/cs/source.cs#1)]\n [!code-vb[c_delegation#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_delegation/vb/source.vb#1)]  \n  \n### How to Configure an Application to Use Constrained Delegation  \n Before you can use constrained delegation, the sender, receiver, and the domain controller must be configured to do so. The following procedure lists the steps that enable constrained delegation. For details about the differences between delegation and constrained delegation, see the portion of [Windows Server 2003 Kerberos Extensions](https://go.microsoft.com/fwlink/?LinkId=100194) that discusses constrained discussion.  \n  \n1.  On the domain controller, clear the **Account is sensitive and cannot be delegated** check box for the account under which the client application is running.  \n  \n2.  On the domain controller, select the **Account is trusted for delegation** check box for the account under which the client application is running.  \n  \n3.  On the domain controller, configure the middle tier computer so that it is trusted for delegation, by clicking the **Trust computer for delegation** option.  \n  \n4.  On the domain controller, configure the middle tier computer to use constrained delegation, by clicking the **Trust this computer for delegation to specified services only** option.  \n  \n For more detailed instructions about configuring constrained delegation, see the following topics on MSDN:  \n  \n-   [Troubleshooting Kerberos Delegation](https://go.microsoft.com/fwlink/?LinkId=36724)  \n  \n-   [Kerberos Protocol Transition and Constrained Delegation](https://go.microsoft.com/fwlink/?LinkId=36725)  \n  \n## See also\n\n- <xref:System.ServiceModel.OperationBehaviorAttribute>\n- <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A>\n- <xref:System.ServiceModel.ImpersonationOption>\n- <xref:System.ServiceModel.ServiceSecurityContext.WindowsIdentity%2A>\n- <xref:System.ServiceModel.ServiceSecurityContext>\n- <xref:System.Security.Principal.WindowsIdentity>\n- <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior>\n- <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior.ImpersonateCallerForAllOperations%2A>\n- <xref:System.ServiceModel.ServiceHost>\n- <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A>\n- <xref:System.ServiceModel.Security.WindowsClientCredential>\n- <xref:System.ServiceModel.ChannelFactory%601>\n- <xref:System.Security.Principal.TokenImpersonationLevel.Identification>\n- [Using Impersonation with Transport Security](../../../../docs/framework/wcf/feature-details/using-impersonation-with-transport-security.md)\n- [Impersonating the Client](../../../../docs/framework/wcf/samples/impersonating-the-client.md)\n- [How to: Impersonate a Client on a Service](../../../../docs/framework/wcf/how-to-impersonate-a-client-on-a-service.md)\n- [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)\n","nodes":[{"pos":[4,226],"embed":true,"restype":"x-metadata","content":"title: \"Delegation and Impersonation with WCF\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"impersonation [WCF]\"\n  - \"delegation [WCF]\"\nms.assetid: 110e60f7-5b03-4b69-b667-31721b8e3152","nodes":[{"content":"Delegation and Impersonation with WCF","nodes":[{"pos":[0,37],"content":"Delegation and Impersonation with WCF","nodes":[{"content":"Delegation and Impersonation with WCF","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[233,270],"content":"Delegation and Impersonation with WCF","linkify":"Delegation and Impersonation with WCF","nodes":[{"content":"Delegation and Impersonation with WCF","pos":[0,37]}]},{"content":"<bpt id=\"p1\">*</bpt>Impersonation<ept id=\"p1\">*</ept> is a common technique that services use to restrict client access to a service domain's resources.","pos":[271,385],"source":"*Impersonation* is a common technique that services use to restrict client access to a service domain's resources."},{"content":"Service domain resources can either be machine resources, such as local files (impersonation), or a resource on another machine, such as a file share (delegation).","pos":[386,549]},{"content":"For a sample application, see <bpt id=\"p1\">[</bpt>Impersonating the Client<ept id=\"p1\">](../../../../docs/framework/wcf/samples/impersonating-the-client.md)</ept>.","pos":[550,675],"source":" For a sample application, see [Impersonating the Client](../../../../docs/framework/wcf/samples/impersonating-the-client.md)."},{"content":"For an example of how to use impersonation, see <bpt id=\"p1\">[</bpt>How to: Impersonate a Client on a Service<ept id=\"p1\">](../../../../docs/framework/wcf/how-to-impersonate-a-client-on-a-service.md)</ept>.","pos":[676,844],"source":" For an example of how to use impersonation, see [How to: Impersonate a Client on a Service](../../../../docs/framework/wcf/how-to-impersonate-a-client-on-a-service.md)."},{"pos":[852,1029],"content":"[!IMPORTANT]\n Be aware that when impersonating a client on a service, the service runs with the client's credentials, which may have higher privileges than the server process.","leadings":["","> "],"nodes":[{"content":"Be aware that when impersonating a client on a service, the service runs with the client's credentials, which may have higher privileges than the server process.","pos":[14,175]}]},{"pos":[1038,1046],"content":"Overview","linkify":"Overview","nodes":[{"content":"Overview","pos":[0,8]}]},{"content":"Typically, clients call a service to have the service perform some action on the client’s behalf.","pos":[1050,1147]},{"content":"Impersonation allows the service to act as the client while performing the action.","pos":[1148,1230]},{"content":"Delegation allows a front-end service to forward the client’s request to a back-end service in such a way that the back-end service can also impersonate the client.","pos":[1231,1395]},{"content":"Impersonation is most commonly used as a way of checking whether a client is authorized to perform a particular action, while delegation is a way of flowing impersonation capabilities, along with the client’s identity, to a back-end service.","pos":[1396,1637]},{"content":"Delegation is a Windows domain feature that can be used when Kerberos-based authentication is performed.","pos":[1638,1742]},{"content":"Delegation is distinct from identity flow and, because delegation transfers the ability to impersonate the client without possession of the client’s password, it is a much higher privileged operation than identity flow.","pos":[1743,1962]},{"content":"Both impersonation and delegation require that the client have a Windows identity.","pos":[1969,2051]},{"content":"If a client does not possess a Windows identity, then the only option available is to flow the client’s identity to the second service.","pos":[2052,2187]},{"pos":[2196,2216],"content":"Impersonation Basics","linkify":"Impersonation Basics","nodes":[{"content":"Impersonation Basics","pos":[0,20]}]},{"content":"Windows Communication Foundation (WCF) supports impersonation for a variety of client credentials.","pos":[2220,2318]},{"content":"This topic describes service model support for impersonating the caller during the implementation of a service method.","pos":[2319,2437]},{"content":"Also discussed are common deployment scenarios involving impersonation and SOAP security and WCF options in these scenarios.","pos":[2438,2562]},{"content":"This topic focuses on impersonation and delegation in WCF when using SOAP security.","pos":[2569,2652]},{"content":"You can also use impersonation and delegation with WCF when using transport security, as described in <bpt id=\"p1\">[</bpt>Using Impersonation with Transport Security<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-impersonation-with-transport-security.md)</ept>.","pos":[2653,2896],"source":" You can also use impersonation and delegation with WCF when using transport security, as described in [Using Impersonation with Transport Security](../../../../docs/framework/wcf/feature-details/using-impersonation-with-transport-security.md)."},{"pos":[2905,2916],"content":"Two Methods","linkify":"Two Methods","nodes":[{"content":"Two Methods","pos":[0,11]}]},{"content":"WCF SOAP security has two distinct methods for performing impersonation.","pos":[2920,2992]},{"content":"The method used depends on the binding.","pos":[2993,3032]},{"content":"One is impersonation from a Windows token obtained from the Security Support Provider Interface (SSPI) or Kerberos authentication, which is then cached on the service.","pos":[3033,3200]},{"content":"The second is impersonation from a Windows token obtained from the Kerberos extensions, collectively called <bpt id=\"p1\">*</bpt>Service-for-User<ept id=\"p1\">*</ept> (S4U).","pos":[3201,3334],"source":" The second is impersonation from a Windows token obtained from the Kerberos extensions, collectively called *Service-for-User* (S4U)."},{"pos":[3344,3370],"content":"Cached Token Impersonation","linkify":"Cached Token Impersonation","nodes":[{"content":"Cached Token Impersonation","pos":[0,26]}]},{"content":"You can perform cached-token impersonation with the following:","pos":[3374,3436]},{"pos":[3446,3612],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.WSHttpBinding&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.WSDualHttpBinding&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.NetTcpBinding&gt;</ph> with a Windows client credential.","source":"<xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>, and <xref:System.ServiceModel.NetTcpBinding> with a Windows client credential."},{"pos":[3622,3956],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.BasicHttpBinding&gt;</ph> with a <ph id=\"ph2\">&lt;xref:System.ServiceModel.BasicHttpSecurityMode&gt;</ph> set to the <ph id=\"ph3\">&lt;xref:System.ServiceModel.BasicHttpSecurityMode.TransportWithMessageCredential&gt;</ph> credential, or any other standard binding where the client presents a user name credential that the service can map to a valid Windows account.","source":"<xref:System.ServiceModel.BasicHttpBinding> with a <xref:System.ServiceModel.BasicHttpSecurityMode> set to the <xref:System.ServiceModel.BasicHttpSecurityMode.TransportWithMessageCredential> credential, or any other standard binding where the client presents a user name credential that the service can map to a valid Windows account."},{"content":"Any <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CustomBinding&gt;</ph> that uses a Windows client credential with the <ph id=\"ph2\">`requireCancellation`</ph> set to <ph id=\"ph3\">`true`</ph>.","pos":[3966,4103],"source":"Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a Windows client credential with the `requireCancellation` set to `true`."},{"content":"(The property is available on the following classes: <ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Security.Tokens.SslSecurityTokenParameters&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.Security.Tokens.SspiSecurityTokenParameters&gt;</ph>.) If a secure conversation is used on the binding, it must also have the <ph id=\"ph4\">`requireCancellation`</ph> property set to <ph id=\"ph5\">`true`</ph>.","pos":[4104,4507],"source":" (The property is available on the following classes: <xref:System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters>, <xref:System.ServiceModel.Security.Tokens.SslSecurityTokenParameters>, and <xref:System.ServiceModel.Security.Tokens.SspiSecurityTokenParameters>.) If a secure conversation is used on the binding, it must also have the `requireCancellation` property set to `true`."},{"content":"Any <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CustomBinding&gt;</ph> where the client presents a user name credential.","pos":[4517,4620],"source":"Any <xref:System.ServiceModel.Channels.CustomBinding> where the client presents a user name credential."},{"content":"If secure conversation is used on the binding, it must also have the <ph id=\"ph1\">`requireCancellation`</ph> property set to <ph id=\"ph2\">`true`</ph>.","pos":[4621,4735],"source":" If secure conversation is used on the binding, it must also have the `requireCancellation` property set to `true`."},{"pos":[4745,4768],"content":"S4U-Based Impersonation","linkify":"S4U-Based Impersonation","nodes":[{"content":"S4U-Based Impersonation","pos":[0,23]}]},{"content":"You can perform S4U-based impersonation with the following:","pos":[4772,4831]},{"pos":[4841,5063],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.WSHttpBinding&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.WSDualHttpBinding&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.NetTcpBinding&gt;</ph> with a certificate client credential that the service can map to a valid Windows account.","source":"<xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>, and <xref:System.ServiceModel.NetTcpBinding> with a certificate client credential that the service can map to a valid Windows account."},{"pos":[5073,5220],"content":"Any <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CustomBinding&gt;</ph> that uses a Windows client credential with the <ph id=\"ph2\">`requireCancellation`</ph> property set to <ph id=\"ph3\">`false`</ph>.","source":"Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a Windows client credential with the `requireCancellation` property set to `false`."},{"pos":[5230,5414],"content":"Any <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CustomBinding&gt;</ph> that uses a user name or Windows client credential and secure conversation with the <ph id=\"ph2\">`requireCancellation`</ph> property set to <ph id=\"ph3\">`false`</ph>.","source":"Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a user name or Windows client credential and secure conversation with the `requireCancellation` property set to `false`."},{"content":"The extent to which the service can impersonate the client depends on the privileges the service account holds when it attempts impersonation, the type of impersonation used, and possibly the extent of impersonation the client permits.","pos":[5421,5656]},{"pos":[5664,6938],"content":"[!NOTE]\n When the client and service are running on the same computer and the client is running under a system account (for example, `Local System` or `Network Service`), the client cannot be impersonated when a secure session is established with stateful Security Context tokens. A Windows Form or console application typically runs under the currently logged-in account, so that account can be impersonated by default. However, when the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page and that page is hosted in [!INCLUDE[iis601](../../../../includes/iis601-md.md)] or [!INCLUDE[iisver](../../../../includes/iisver-md.md)], then the client does run under the `Network Service` account by default. All of the system-provided bindings that support secure sessions use a stateless security context token (SCT) by default. However, if the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page, and secure sessions with stateful SCTs are used, the client cannot be impersonated. For more information about using stateful SCTs in a secure session, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).","leadings":["","> "],"nodes":[{"content":"When the client and service are running on the same computer and the client is running under a system account (for example, `Local System` or `Network Service`), the client cannot be impersonated when a secure session is established with stateful Security Context tokens. A Windows Form or console application typically runs under the currently logged-in account, so that account can be impersonated by default. However, when the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page and that page is hosted in [!INCLUDE[iis601](../../../../includes/iis601-md.md)] or [!INCLUDE[iisver](../../../../includes/iisver-md.md)], then the client does run under the `Network Service` account by default. All of the system-provided bindings that support secure sessions use a stateless security context token (SCT) by default. However, if the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page, and secure sessions with stateful SCTs are used, the client cannot be impersonated. For more information about using stateful SCTs in a secure session, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).","pos":[9,1272],"nodes":[{"content":"When the client and service are running on the same computer and the client is running under a system account (for example, <ph id=\"ph1\">`Local System`</ph> or <ph id=\"ph2\">`Network Service`</ph>), the client cannot be impersonated when a secure session is established with stateful Security Context tokens.","pos":[0,271],"source":"When the client and service are running on the same computer and the client is running under a system account (for example, `Local System` or `Network Service`), the client cannot be impersonated when a secure session is established with stateful Security Context tokens."},{"content":"A Windows Form or console application typically runs under the currently logged-in account, so that account can be impersonated by default.","pos":[272,411]},{"content":"However, when the client is an <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> page and that page is hosted in <ph id=\"ph2\">[!INCLUDE[iis601](../../../../includes/iis601-md.md)]</ph> or <ph id=\"ph3\">[!INCLUDE[iisver](../../../../includes/iisver-md.md)]</ph>, then the client does run under the <ph id=\"ph4\">`Network Service`</ph> account by default.","pos":[412,717],"source":" However, when the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page and that page is hosted in [!INCLUDE[iis601](../../../../includes/iis601-md.md)] or [!INCLUDE[iisver](../../../../includes/iisver-md.md)], then the client does run under the `Network Service` account by default."},{"content":"All of the system-provided bindings that support secure sessions use a stateless security context token (SCT) by default.","pos":[718,839]},{"content":"However, if the client is an <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> page, and secure sessions with stateful SCTs are used, the client cannot be impersonated.","pos":[840,1016],"source":" However, if the client is an [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] page, and secure sessions with stateful SCTs are used, the client cannot be impersonated."},{"content":"For more information about using stateful SCTs in a secure session, see <bpt id=\"p1\">[</bpt>How to: Create a Security Context Token for a Secure Session<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md)</ept>.","pos":[1017,1263],"source":" For more information about using stateful SCTs in a secure session, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md)."}]}]},{"pos":[6947,6999],"content":"Impersonation in a Service Method: Declarative Model","linkify":"Impersonation in a Service Method: Declarative Model","nodes":[{"content":"Impersonation in a Service Method: Declarative Model","pos":[0,52]}]},{"content":"Most impersonation scenarios involve executing the service method in the caller context.","pos":[7003,7091]},{"content":"WCF provides an impersonation feature that makes this easy to do by allowing the user to specify the impersonation requirement in the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationBehaviorAttribute&gt;</ph> attribute.","pos":[7092,7290],"source":" WCF provides an impersonation feature that makes this easy to do by allowing the user to specify the impersonation requirement in the <xref:System.ServiceModel.OperationBehaviorAttribute> attribute."},{"content":"For example, in the following code, the WCF infrastructure impersonates the caller before executing the <ph id=\"ph1\">`Hello`</ph> method.","pos":[7291,7410],"source":" For example, in the following code, the WCF infrastructure impersonates the caller before executing the `Hello` method."},{"content":"Any attempt to access native resources inside the <ph id=\"ph1\">`Hello`</ph> method succeed only if the access control list (ACL) of the resource allows the caller access privileges.","pos":[7411,7574],"source":" Any attempt to access native resources inside the `Hello` method succeed only if the access control list (ACL) of the resource allows the caller access privileges."},{"content":"To enable impersonation, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A&gt;</ph> property to one of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ImpersonationOption&gt;</ph> enumeration values, either <ph id=\"ph3\">&lt;xref:System.ServiceModel.ImpersonationOption.Required?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.ServiceModel.ImpersonationOption.Allowed?displayProperty=nameWithType&gt;</ph>, as shown in the following example.","pos":[7575,7983],"source":" To enable impersonation, set the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property to one of the <xref:System.ServiceModel.ImpersonationOption> enumeration values, either <xref:System.ServiceModel.ImpersonationOption.Required?displayProperty=nameWithType> or <xref:System.ServiceModel.ImpersonationOption.Allowed?displayProperty=nameWithType>, as shown in the following example."},{"pos":[7991,8488],"content":"[!NOTE]\n When a service has higher credentials than the remote client, the credentials of the service are used if the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property is set to <xref:System.ServiceModel.ImpersonationOption.Allowed>. That is, if a low-privileged user provides its credentials, a higher-privileged service executes the method with the credentials of the service, and can use resources that the low-privileged user would otherwise not be able to use.","leadings":["","> "],"nodes":[{"content":"When a service has higher credentials than the remote client, the credentials of the service are used if the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property is set to <xref:System.ServiceModel.ImpersonationOption.Allowed>. That is, if a low-privileged user provides its credentials, a higher-privileged service executes the method with the credentials of the service, and can use resources that the low-privileged user would otherwise not be able to use.","pos":[9,495],"nodes":[{"content":"When a service has higher credentials than the remote client, the credentials of the service are used if the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A&gt;</ph> property is set to <ph id=\"ph2\">&lt;xref:System.ServiceModel.ImpersonationOption.Allowed&gt;</ph>.","pos":[0,254],"source":"When a service has higher credentials than the remote client, the credentials of the service are used if the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property is set to <xref:System.ServiceModel.ImpersonationOption.Allowed>."},{"content":"That is, if a low-privileged user provides its credentials, a higher-privileged service executes the method with the credentials of the service, and can use resources that the low-privileged user would otherwise not be able to use.","pos":[255,486]}]}]},{"content":"The WCF infrastructure can impersonate the caller only if the caller is authenticated with credentials that can be mapped to a Windows user account.","pos":[8791,8939]},{"content":"If the service is configured to authenticate using a credential that cannot be mapped to a Windows account, the service method is not executed.","pos":[8940,9083]},{"pos":[9091,9384],"content":"[!NOTE]\n On [!INCLUDE[wxp](../../../../includes/wxp-md.md)], impersonation fails if a stateful SCT is created, resulting in an <xref:System.InvalidOperationException>. For more information, see [Unsupported Scenarios](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md).","leadings":["","> "],"nodes":[{"content":"On [!INCLUDE[wxp](../../../../includes/wxp-md.md)], impersonation fails if a stateful SCT is created, resulting in an <xref:System.InvalidOperationException>. For more information, see [Unsupported Scenarios](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md).","pos":[9,291],"nodes":[{"content":"On <ph id=\"ph1\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>, impersonation fails if a stateful SCT is created, resulting in an <ph id=\"ph2\">&lt;xref:System.InvalidOperationException&gt;</ph>.","pos":[0,158],"source":"On [!INCLUDE[wxp](../../../../includes/wxp-md.md)], impersonation fails if a stateful SCT is created, resulting in an <xref:System.InvalidOperationException>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Unsupported Scenarios<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)</ept>.","pos":[159,282],"source":" For more information, see [Unsupported Scenarios](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)."}]}]},{"pos":[9393,9444],"content":"Impersonation in a Service Method: Imperative Model","linkify":"Impersonation in a Service Method: Imperative Model","nodes":[{"content":"Impersonation in a Service Method: Imperative Model","pos":[0,51]}]},{"content":"Sometimes a caller does not need to impersonate the entire service method to function, but for only a portion of it.","pos":[9448,9564]},{"content":"In this case, obtain the Windows identity of the caller inside the service method and imperatively perform the impersonation.","pos":[9565,9690]},{"content":"Do this by using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceSecurityContext.WindowsIdentity%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceSecurityContext&gt;</ph> to return an instance of the <ph id=\"ph3\">&lt;xref:System.Security.Principal.WindowsIdentity&gt;</ph> class and calling the <ph id=\"ph4\">&lt;xref:System.Security.Principal.WindowsIdentity.Impersonate%2A&gt;</ph> method before using the instance.","pos":[9691,10044],"source":" Do this by using the <xref:System.ServiceModel.ServiceSecurityContext.WindowsIdentity%2A> property of the <xref:System.ServiceModel.ServiceSecurityContext> to return an instance of the <xref:System.Security.Principal.WindowsIdentity> class and calling the <xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> method before using the instance."},{"pos":[10052,10429],"content":"[!NOTE]\n Be sure to use the Visual Basic`Using` statement or the C# `using` statement to automatically revert the impersonation action. If you do not use the statement, or if you use a programming language other than Visual Basic or C#, be sure to revert the impersonation level. Failure to do this can form the basis for denial of service and elevation of privilege attacks.","leadings":["","> "],"nodes":[{"content":"Be sure to use the Visual Basic`Using` statement or the C# `using` statement to automatically revert the impersonation action. If you do not use the statement, or if you use a programming language other than Visual Basic or C#, be sure to revert the impersonation level. Failure to do this can form the basis for denial of service and elevation of privilege attacks.","pos":[9,375],"nodes":[{"content":"Be sure to use the Visual Basic<ph id=\"ph1\">`Using`</ph> statement or the C# <ph id=\"ph2\">`using`</ph> statement to automatically revert the impersonation action.","pos":[0,126],"source":"Be sure to use the Visual Basic`Using` statement or the C# `using` statement to automatically revert the impersonation action."},{"content":"If you do not use the statement, or if you use a programming language other than Visual Basic or C#, be sure to revert the impersonation level.","pos":[127,270]},{"content":"Failure to do this can form the basis for denial of service and elevation of privilege attacks.","pos":[271,366]}]}]},{"pos":[10734,10771],"content":"Impersonation for All Service Methods","linkify":"Impersonation for All Service Methods","nodes":[{"content":"Impersonation for All Service Methods","pos":[0,37]}]},{"content":"In some cases, you must perform all the methods of a service in the caller’s context.","pos":[10775,10860]},{"content":"Instead of explicitly enabling this feature on a per-method basis, use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.ServiceAuthorizationBehavior&gt;</ph>.","pos":[10861,11004],"source":" Instead of explicitly enabling this feature on a per-method basis, use the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior>."},{"content":"As shown in the following code, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.ServiceAuthorizationBehavior.ImpersonateCallerForAllOperations%2A&gt;</ph> property to <ph id=\"ph2\">`true`</ph>.","pos":[11005,11169],"source":" As shown in the following code, set the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior.ImpersonateCallerForAllOperations%2A> property to `true`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.ServiceAuthorizationBehavior&gt;</ph> is retrieved from the collections of behaviors of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph> class.","pos":[11170,11341],"source":" The <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior> is retrieved from the collections of behaviors of the <xref:System.ServiceModel.ServiceHost> class."},{"content":"Also note that the <ph id=\"ph1\">`Impersonation`</ph> property of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationBehaviorAttribute&gt;</ph> applied to each method must also be set to either <ph id=\"ph3\">&lt;xref:System.ServiceModel.ImpersonationOption.Allowed&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.ServiceModel.ImpersonationOption.Required&gt;</ph>.","pos":[11342,11611],"source":" Also note that the `Impersonation` property of the <xref:System.ServiceModel.OperationBehaviorAttribute> applied to each method must also be set to either <xref:System.ServiceModel.ImpersonationOption.Allowed> or <xref:System.ServiceModel.ImpersonationOption.Required>."},{"pos":[11914,12059],"content":"The following table describes WCF behavior for all possible combinations of <ph id=\"ph1\">`ImpersonationOption`</ph> and <ph id=\"ph2\">`ImpersonateCallerForAllServiceOperations`</ph>.","source":"The following table describes WCF behavior for all possible combinations of `ImpersonationOption` and `ImpersonateCallerForAllServiceOperations`."},{"content":"Behavior","pos":[12131,12139]},{"content":"Required","pos":[12240,12248]},{"content":"n/a","pos":[12249,12252]},{"content":"WCF impersonates the caller","pos":[12253,12280]},{"content":"Allowed","pos":[12285,12292]},{"content":"false","pos":[12293,12298]},{"content":"WCF does not impersonate the caller","pos":[12299,12334]},{"content":"Allowed","pos":[12339,12346]},{"content":"true","pos":[12347,12351]},{"content":"WCF impersonates the caller","pos":[12352,12379]},{"content":"NotAllowed","pos":[12384,12394]},{"content":"false","pos":[12395,12400]},{"content":"WCF does not impersonate the caller","pos":[12401,12436]},{"content":"NotAllowed","pos":[12441,12451]},{"content":"true","pos":[12452,12456]},{"content":"Disallowed.","pos":[12457,12468]},{"content":"(An <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.)","pos":[12469,12524],"source":" (An <xref:System.InvalidOperationException> is thrown.)"},{"pos":[12534,12618],"content":"Impersonation Level Obtained from Windows Credentials and Cached Token Impersonation","linkify":"Impersonation Level Obtained from Windows Credentials and Cached Token Impersonation","nodes":[{"content":"Impersonation Level Obtained from Windows Credentials and Cached Token Impersonation","pos":[0,84]}]},{"content":"In some scenarios the client has partial control over the level of impersonation the service performs when a Windows client credential is used.","pos":[12622,12765]},{"content":"One scenario occurs when the client specifies an Anonymous impersonation level.","pos":[12766,12845]},{"content":"The other occurs when performing impersonation with a cached token.","pos":[12846,12913]},{"content":"This is done by setting the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Security.WindowsClientCredential&gt;</ph> class, which is accessed as a property of the generic <ph id=\"ph3\">&lt;xref:System.ServiceModel.ChannelFactory%601&gt;</ph> class.","pos":[12914,13213],"source":" This is done by setting the <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> property of the <xref:System.ServiceModel.Security.WindowsClientCredential> class, which is accessed as a property of the generic <xref:System.ServiceModel.ChannelFactory%601> class."},{"pos":[13221,13435],"content":"[!NOTE]\n Specifying an impersonation level of Anonymous causes the client to log on to the service anonymously. The service must therefore allow anonymous logons, regardless of whether impersonation is performed.","leadings":["","> "],"nodes":[{"content":"Specifying an impersonation level of Anonymous causes the client to log on to the service anonymously. The service must therefore allow anonymous logons, regardless of whether impersonation is performed.","pos":[9,212],"nodes":[{"content":"Specifying an impersonation level of Anonymous causes the client to log on to the service anonymously.","pos":[0,102]},{"content":"The service must therefore allow anonymous logons, regardless of whether impersonation is performed.","pos":[103,203]}]}]},{"content":"The client can specify the impersonation level as <ph id=\"ph1\">&lt;xref:System.Security.Principal.TokenImpersonationLevel.Anonymous&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Security.Principal.TokenImpersonationLevel.Identification&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Security.Principal.TokenImpersonationLevel.Impersonation&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Security.Principal.TokenImpersonationLevel.Delegation&gt;</ph>.","pos":[13442,13776],"source":"The client can specify the impersonation level as <xref:System.Security.Principal.TokenImpersonationLevel.Anonymous>, <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>, or <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>."},{"content":"Only a token at the specified level is produced, as shown in the following code.","pos":[13777,13857]},{"content":"The following table specifies the impersonation level the service obtains when impersonating from a cached token.","pos":[14160,14273]},{"pos":[14280,14313],"content":"<ph id=\"ph1\">`AllowedImpersonationLevel`</ph> value","source":"`AllowedImpersonationLevel` value"},{"pos":[14314,14350],"content":"Service has <ph id=\"ph1\">`SeImpersonatePrivilege`</ph>","source":"Service has `SeImpersonatePrivilege`"},{"content":"Service and client are capable of delegation","pos":[14351,14395]},{"pos":[14396,14429],"content":"Cached token <ph id=\"ph1\">`ImpersonationLevel`</ph>","source":"Cached token `ImpersonationLevel`"},{"content":"Anonymous","pos":[14612,14621]},{"content":"Yes","pos":[14622,14625]},{"content":"n/a","pos":[14626,14629]},{"content":"Impersonation","pos":[14630,14643]},{"content":"Anonymous","pos":[14648,14657]},{"content":"No","pos":[14658,14660]},{"content":"n/a","pos":[14661,14664]},{"content":"Identification","pos":[14665,14679]},{"content":"Identification","pos":[14684,14698]},{"content":"n/a","pos":[14699,14702]},{"content":"n/a","pos":[14703,14706]},{"content":"Identification","pos":[14707,14721]},{"content":"Impersonation","pos":[14726,14739]},{"content":"Yes","pos":[14740,14743]},{"content":"n/a","pos":[14744,14747]},{"content":"Impersonation","pos":[14748,14761]},{"content":"Impersonation","pos":[14766,14779]},{"content":"No","pos":[14780,14782]},{"content":"n/a","pos":[14783,14786]},{"content":"Identification","pos":[14787,14801]},{"content":"Delegation","pos":[14806,14816]},{"content":"Yes","pos":[14817,14820]},{"content":"Yes","pos":[14821,14824]},{"content":"Delegation","pos":[14825,14835]},{"content":"Delegation","pos":[14840,14850]},{"content":"Yes","pos":[14851,14854]},{"content":"No","pos":[14855,14857]},{"content":"Impersonation","pos":[14858,14871]},{"content":"Delegation","pos":[14876,14886]},{"content":"No","pos":[14887,14889]},{"content":"n/a","pos":[14890,14893]},{"content":"Identification","pos":[14894,14908]},{"pos":[14918,15004],"content":"Impersonation Level Obtained from User Name Credentials and Cached Token Impersonation","linkify":"Impersonation Level Obtained from User Name Credentials and Cached Token Impersonation","nodes":[{"content":"Impersonation Level Obtained from User Name Credentials and Cached Token Impersonation","pos":[0,86]}]},{"content":"By passing the service its user name and password, a client enables WCF to log on as that user, which is equivalent to setting the <ph id=\"ph1\">`AllowedImpersonationLevel`</ph> property to <ph id=\"ph2\">&lt;xref:System.Security.Principal.TokenImpersonationLevel.Delegation&gt;</ph>.","pos":[15008,15247],"source":"By passing the service its user name and password, a client enables WCF to log on as that user, which is equivalent to setting the `AllowedImpersonationLevel` property to <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>."},{"content":"(The <ph id=\"ph1\">`AllowedImpersonationLevel`</ph> is available on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Security.WindowsClientCredential&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.ServiceModel.Security.HttpDigestClientCredential&gt;</ph> classes.) The following table provides the impersonation level obtained when the service receives user name credentials.","pos":[15248,15548],"source":" (The `AllowedImpersonationLevel` is available on the <xref:System.ServiceModel.Security.WindowsClientCredential> and <xref:System.ServiceModel.Security.HttpDigestClientCredential> classes.) The following table provides the impersonation level obtained when the service receives user name credentials."},{"pos":[15583,15619],"content":"Service has <ph id=\"ph1\">`SeImpersonatePrivilege`</ph>","source":"Service has `SeImpersonatePrivilege`"},{"content":"Service and client are capable of delegation","pos":[15620,15664]},{"pos":[15665,15698],"content":"Cached token <ph id=\"ph1\">`ImpersonationLevel`</ph>","source":"Cached token `ImpersonationLevel`"},{"content":"n/a","pos":[15875,15878]},{"content":"Yes","pos":[15879,15882]},{"content":"Yes","pos":[15883,15886]},{"content":"Delegation","pos":[15887,15897]},{"content":"n/a","pos":[15902,15905]},{"content":"Yes","pos":[15906,15909]},{"content":"No","pos":[15910,15912]},{"content":"Impersonation","pos":[15913,15926]},{"content":"n/a","pos":[15931,15934]},{"content":"No","pos":[15935,15937]},{"content":"n/a","pos":[15938,15941]},{"content":"Identification","pos":[15942,15956]},{"pos":[15966,16023],"content":"Impersonation Level Obtained from S4U-Based Impersonation","linkify":"Impersonation Level Obtained from S4U-Based Impersonation","nodes":[{"content":"Impersonation Level Obtained from S4U-Based Impersonation","pos":[0,57]}]},{"pos":[16030,16058],"content":"Service has <ph id=\"ph1\">`SeTcbPrivilege`</ph>","source":"Service has `SeTcbPrivilege`"},{"pos":[16059,16095],"content":"Service has <ph id=\"ph1\">`SeImpersonatePrivilege`</ph>","source":"Service has `SeImpersonatePrivilege`"},{"content":"Service and client are capable of delegation","pos":[16096,16140]},{"pos":[16141,16174],"content":"Cached token <ph id=\"ph1\">`ImpersonationLevel`</ph>","source":"Cached token `ImpersonationLevel`"},{"content":"Yes","pos":[16352,16355]},{"content":"Yes","pos":[16356,16359]},{"content":"n/a","pos":[16360,16363]},{"content":"Impersonation","pos":[16364,16377]},{"content":"Yes","pos":[16382,16385]},{"content":"No","pos":[16386,16388]},{"content":"n/a","pos":[16389,16392]},{"content":"Identification","pos":[16393,16407]},{"content":"No","pos":[16412,16414]},{"content":"n/a","pos":[16415,16418]},{"content":"n/a","pos":[16419,16422]},{"content":"Identification","pos":[16423,16437]},{"pos":[16447,16496],"content":"Mapping a Client Certificate to a Windows Account","linkify":"Mapping a Client Certificate to a Windows Account","nodes":[{"content":"Mapping a Client Certificate to a Windows Account","pos":[0,49]}]},{"content":"It is possible for a client to authenticate itself to a service using a certificate, and to have the service map the client to an existing account through Active Directory.","pos":[16500,16672]},{"content":"The following XML shows how to configure the service to map the certificate.","pos":[16673,16749]},{"content":"The following code shows how to configure the service.","pos":[17107,17161]},{"pos":[17678,17688],"content":"Delegation","linkify":"Delegation","nodes":[{"content":"Delegation","pos":[0,10]}]},{"content":"To delegate to a back-end service, a service must perform Kerberos multi-leg (SSPI without NTLM fallback) or Kerberos direct authentication to the back-end service using the client’s Windows identity.","pos":[17692,17892]},{"content":"To delegate to a back-end service, create a <ph id=\"ph1\">&lt;xref:System.ServiceModel.ChannelFactory%601&gt;</ph> and a channel, and then communicate through the channel while impersonating the client.","pos":[17893,18070],"source":" To delegate to a back-end service, create a <xref:System.ServiceModel.ChannelFactory%601> and a channel, and then communicate through the channel while impersonating the client."},{"content":"With this form of delegation, the distance at which the back-end service can be located from the front-end service depends on the impersonation level achieved by the front-end service.","pos":[18071,18255]},{"content":"When the impersonation level is <ph id=\"ph1\">&lt;xref:System.Security.Principal.TokenImpersonationLevel.Impersonation&gt;</ph>, the front-end and back-end services must be running on the same machine.","pos":[18256,18432],"source":" When the impersonation level is <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>, the front-end and back-end services must be running on the same machine."},{"content":"When the impersonation level is <ph id=\"ph1\">&lt;xref:System.Security.Principal.TokenImpersonationLevel.Delegation&gt;</ph>, the front-end and back-end services can be on separate machines or on the same machine.","pos":[18433,18621],"source":" When the impersonation level is <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>, the front-end and back-end services can be on separate machines or on the same machine."},{"content":"Enabling delegation-level impersonation requires that Windows domain policy be configured to permit delegation.","pos":[18622,18733]},{"content":"For more information about configuring Active Directory for delegation support, see <bpt id=\"p1\">[</bpt>Enabling Delegated Authentication<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=99690)</ept>.","pos":[18734,18901],"source":" For more information about configuring Active Directory for delegation support, see [Enabling Delegated Authentication](https://go.microsoft.com/fwlink/?LinkId=99690)."},{"pos":[18909,19512],"content":"[!NOTE]\n When a client authenticates to the front-end service using a user name and password that correspond to a Windows account on the back-end service, the front-end service can authenticate to the back-end service by reusing the client’s user name and password. This is a particularly powerful form of identity flow, because passing user name and password to the back-end service enables the back-end service to perform impersonation, but it does not constitute delegation because Kerberos is not used. Active Directory controls on delegation do not apply to user name and password authentication.","leadings":["","> "],"nodes":[{"content":"When a client authenticates to the front-end service using a user name and password that correspond to a Windows account on the back-end service, the front-end service can authenticate to the back-end service by reusing the client’s user name and password. This is a particularly powerful form of identity flow, because passing user name and password to the back-end service enables the back-end service to perform impersonation, but it does not constitute delegation because Kerberos is not used. Active Directory controls on delegation do not apply to user name and password authentication.","pos":[9,601],"nodes":[{"content":"When a client authenticates to the front-end service using a user name and password that correspond to a Windows account on the back-end service, the front-end service can authenticate to the back-end service by reusing the client’s user name and password.","pos":[0,256]},{"content":"This is a particularly powerful form of identity flow, because passing user name and password to the back-end service enables the back-end service to perform impersonation, but it does not constitute delegation because Kerberos is not used.","pos":[257,497]},{"content":"Active Directory controls on delegation do not apply to user name and password authentication.","pos":[498,592]}]}]},{"pos":[19522,19577],"content":"Delegation Ability as a Function of Impersonation Level","linkify":"Delegation Ability as a Function of Impersonation Level","nodes":[{"content":"Delegation Ability as a Function of Impersonation Level","pos":[0,55]}]},{"content":"Impersonation level","pos":[19584,19603]},{"content":"Service can perform cross-process delegation","pos":[19604,19648]},{"content":"Service can perform cross-machine delegation","pos":[19649,19693]},{"content":"No","pos":[19904,19906]},{"content":"No","pos":[19907,19909]},{"content":"Yes","pos":[19985,19988]},{"content":"No","pos":[19989,19991]},{"content":"Yes","pos":[20064,20067]},{"content":"Yes","pos":[20068,20071]},{"content":"The following code example demonstrates how to use delegation.","pos":[20079,20141]},{"pos":[20383,20444],"content":"How to Configure an Application to Use Constrained Delegation","linkify":"How to Configure an Application to Use Constrained Delegation","nodes":[{"content":"How to Configure an Application to Use Constrained Delegation","pos":[0,61]}]},{"content":"Before you can use constrained delegation, the sender, receiver, and the domain controller must be configured to do so.","pos":[20448,20567]},{"content":"The following procedure lists the steps that enable constrained delegation.","pos":[20568,20643]},{"content":"For details about the differences between delegation and constrained delegation, see the portion of <bpt id=\"p1\">[</bpt>Windows Server 2003 Kerberos Extensions<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=100194)</ept> that discusses constrained discussion.","pos":[20644,20872],"source":" For details about the differences between delegation and constrained delegation, see the portion of [Windows Server 2003 Kerberos Extensions](https://go.microsoft.com/fwlink/?LinkId=100194) that discusses constrained discussion."},{"pos":[20882,21039],"content":"On the domain controller, clear the <bpt id=\"p1\">**</bpt>Account is sensitive and cannot be delegated<ept id=\"p1\">**</ept> check box for the account under which the client application is running.","source":"On the domain controller, clear the **Account is sensitive and cannot be delegated** check box for the account under which the client application is running."},{"pos":[21049,21196],"content":"On the domain controller, select the <bpt id=\"p1\">**</bpt>Account is trusted for delegation<ept id=\"p1\">**</ept> check box for the account under which the client application is running.","source":"On the domain controller, select the **Account is trusted for delegation** check box for the account under which the client application is running."},{"pos":[21206,21362],"content":"On the domain controller, configure the middle tier computer so that it is trusted for delegation, by clicking the <bpt id=\"p1\">**</bpt>Trust computer for delegation<ept id=\"p1\">**</ept> option.","source":"On the domain controller, configure the middle tier computer so that it is trusted for delegation, by clicking the **Trust computer for delegation** option."},{"pos":[21372,21553],"content":"On the domain controller, configure the middle tier computer to use constrained delegation, by clicking the <bpt id=\"p1\">**</bpt>Trust this computer for delegation to specified services only<ept id=\"p1\">**</ept> option.","source":"On the domain controller, configure the middle tier computer to use constrained delegation, by clicking the **Trust this computer for delegation to specified services only** option."},{"content":"For more detailed instructions about configuring constrained delegation, see the following topics on MSDN:","pos":[21560,21666]},{"pos":[21676,21760],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Kerberos Delegation<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=36724)</ept>","source":"[Troubleshooting Kerberos Delegation](https://go.microsoft.com/fwlink/?LinkId=36724)"},{"pos":[21770,21874],"content":"<bpt id=\"p1\">[</bpt>Kerberos Protocol Transition and Constrained Delegation<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=36725)</ept>","source":"[Kerberos Protocol Transition and Constrained Delegation](https://go.microsoft.com/fwlink/?LinkId=36725)"},{"pos":[21883,21891],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[22740,22880],"content":"<bpt id=\"p1\">[</bpt>Using Impersonation with Transport Security<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-impersonation-with-transport-security.md)</ept>","source":"[Using Impersonation with Transport Security](../../../../docs/framework/wcf/feature-details/using-impersonation-with-transport-security.md)"},{"pos":[22883,22977],"content":"<bpt id=\"p1\">[</bpt>Impersonating the Client<ept id=\"p1\">](../../../../docs/framework/wcf/samples/impersonating-the-client.md)</ept>","source":"[Impersonating the Client](../../../../docs/framework/wcf/samples/impersonating-the-client.md)"},{"pos":[22980,23099],"content":"<bpt id=\"p1\">[</bpt>How to: Impersonate a Client on a Service<ept id=\"p1\">](../../../../docs/framework/wcf/how-to-impersonate-a-client-on-a-service.md)</ept>","source":"[How to: Impersonate a Client on a Service](../../../../docs/framework/wcf/how-to-impersonate-a-client-on-a-service.md)"},{"pos":[23102,23234],"content":"<bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>","source":"[ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)"}]}