{"content":"---\ntitle: \"Error handling\"\nms.date: \"03/30/2017\"\nms.assetid: c948841a-7db9-40ae-9b78-587d216cbcaf\n---\n# Error handling\n## Error Handling in Windows Communication Foundation  \n When a service encounters an unexpected exception or error, there are multiple ways to design an exception-handling solution. While there is no single \"correct\" or \"best practice\" error-handling solution, there are multiple valid paths for one to consider. It is normally recommended that one implement a hybrid solution that combines multiple approaches from the list below, depending on the complexity of the WCF implementation, the type and frequency of the exceptions, the handled vs. unhandled nature of the exceptions, and any associated tracing, logging, or policy requirements.  \n  \n These solutions are explained more deeply in the rest of this section.  \n  \n### The Microsoft Enterprise Library  \n The Microsoft Enterprise Library Exception Handling Application Block helps implement common design patterns and create a consistent strategy for processing exceptions that occur in all architectural layers of an enterprise application. It is designed to support the typical code contained in catch statements in application components. Instead of repeating this code (such as code that logs exception information) in identical catch blocks throughout an application, the Exception Handling Application Block allows developers to encapsulate this logic as reusable exception handlers.  \n  \n This Library includes out-of-the-box a Fault Contract Exception Handler. This exception handler is designed for use at Windows® Communication Foundation (WCF) service boundaries, and generates a new Fault Contract from the exception.  \n  \n Application blocks aim to incorporate commonly used best practices and provide a common approach for exception handling throughout your application. On the other hand, custom error handlers and fault contracts developed on one’s own can also be very useful. For instance, custom error handlers provide an excellent opportunity to automatically promote all exceptions to FaultExceptions and also to add logging capabilities to your application.  \n  \n For more information, please see [Microsoft Enterprise Library](https://docs.microsoft.com/previous-versions/msp-n-p/ff632023(v=pandp.10)).  \n  \n### Dealing with Expected Exceptions  \n The proper course of action is to catch expected exceptions in every operation or relevant extensibility point, decide whether they can be recovered from, and return the proper custom fault in a FaultException\\<T>  \n  \n### Dealing with Unexpected Exceptions using an IErrorHandler  \n To deal with unexpected exceptions, the recommended course of action is to \"hook\" an IErrorHandler. Error handlers only catch exceptions at the WCF runtime level (the \"service model\" layer), not at the channel layer. The only way to hook an IErrorHandler at the channel level is to create a custom channel, which is not recommended in most scenarios.  \n  \n An \"unexpected exception\" is generally neither an irrecoverable exception nor a processing exception; it is, instead, an unexpected user exception. An irrecoverable exception (such as an out-of-memory exception) – one generally handled by the [Service Model Exception Handler](xref:System.ServiceModel.Dispatcher.ExceptionHandler) automatically – cannot generally be handled gracefully, and the only reason to handle such an exception at all may be do additional logging or to return a standard exception to the client. A processing exception occurs in the processing of the message – for example, at the serialization, encoder, or formatter level – generally cannot be handled at an IErrorHandler, because it is generally either too early or too late for the error handler to intervene by the time these exceptions occur. Similarly, transport exceptions cannot be handled at an IErrorHandler.  \n  \n With an IErrorHandler, you can explicitly control the behavior of your application when an exception is thrown. You may:  \n  \n1.  Decide whether or not to send a fault to the client  \n  \n2.  Replace an exception with a fault  \n  \n3.  Replace a fault with another fault  \n  \n4.  Perform logging or tracing  \n  \n5.  Perform other custom activities  \n  \n One can install a custom error handler by adding it to the ErrorHandlers property of the channel dispatchers for your service.  It is possible to have more than one error handler and they are called in the order they are added to this collection.  \n  \n IErrorHandler.ProvideFault controls the fault message that is sent to the client. This method is called regardless of the type of the exception thrown by an operation in your service. If no operation is performed here, WCF assumes its default behaviour and continues as if there were no custom error handlers in place.  \n  \n One area that you could perhaps use this approach is when you want to create a central place for converting exceptions to faults before they are sent to the client (ensuring that the instance is not disposed and the channel is not moved to the Faulted state).  \n  \n The IErrorHandler.HandleError method is usually used to implement error-related behaviors such as error logging, system notifications, shutting down the application, etc. IErrorHandler.HandleError can be called at multiple places inside the service, and depending on where the error is thrown, the HandleError method may or may not be called by the same thread as the operation; no guarantees are made in this regard.  \n  \n### Dealing with Exceptions outside WCF  \n Often, configuration exceptions, database connection string exceptions, and other similar exceptions may occur within the context of a WCF application, but are themselves are not exceptions caused by the service model or the web service itself. These exceptions are \"regular\" exceptions external to the web service, and should be handled just as other external exceptions in the environment are to be handled.  \n  \n### Tracing exceptions  \n Tracing is the only \"catch-all\" place where one can potentially see all exceptions. For more information on tracing and logging exceptions, see Tracing and Logging.  \n  \n### URI template errors when using WebGetAttribute and WebInvokeAttribute  \n The WebGet and WebInvoke attributes allow you to specify a URI template that maps components of the request address to operation parameters. For example, the URI template \"weather/{state}/{city}\" maps the request address into literal tokens, a parameter named state, and a parameter named city. These parameters might then be bound by name to some of the formal parameters of the operation.  \n  \n The template parameters appear in the form of strings within the URI while the formal parameters of a typed contract might be of non-string types. Therefore, a conversion needs to take place before the operation can be invoked. A [table of conversion formats](wcf-web-http-programming-model-overview.md) is available.  \n  \n However, if the conversion fails, then there's no way to let the operation know that something has gone wrong. The type conversion instead surfaces in the form of a dispatch failure.  \n  \n A type conversion dispatch failure can be inspected the same as with many other types of dispatch failures by installing an error handler. The IErrorHandler extensibility point is called to handle service-level exceptions. From there, the response to be sent back to the caller – as well as perform any custom tasks and reporting – may be chosen.  \n  \n## See also\n\n- [Basic WCF Programming](../basic-wcf-programming.md)\n","nodes":[{"pos":[4,98],"embed":true,"restype":"x-metadata","content":"title: \"Error handling\"\nms.date: \"03/30/2017\"\nms.assetid: c948841a-7db9-40ae-9b78-587d216cbcaf","nodes":[{"content":"Error handling","nodes":[{"pos":[0,14],"content":"Error handling","nodes":[{"content":"Error handling","pos":[0,14]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[105,119],"content":"Error handling","linkify":"Error handling","nodes":[{"content":"Error handling","pos":[0,14]}]},{"pos":[123,173],"content":"Error Handling in Windows Communication Foundation","linkify":"Error Handling in Windows Communication Foundation","nodes":[{"content":"Error Handling in Windows Communication Foundation","pos":[0,50]}]},{"content":"When a service encounters an unexpected exception or error, there are multiple ways to design an exception-handling solution.","pos":[177,302]},{"content":"While there is no single \"correct\" or \"best practice\" error-handling solution, there are multiple valid paths for one to consider.","pos":[303,433]},{"content":"It is normally recommended that one implement a hybrid solution that combines multiple approaches from the list below, depending on the complexity of the WCF implementation, the type and frequency of the exceptions, the handled vs. unhandled nature of the exceptions, and any associated tracing, logging, or policy requirements.","pos":[434,762]},{"content":"These solutions are explained more deeply in the rest of this section.","pos":[769,839]},{"pos":[849,881],"content":"The Microsoft Enterprise Library","linkify":"The Microsoft Enterprise Library","nodes":[{"content":"The Microsoft Enterprise Library","pos":[0,32]}]},{"content":"The Microsoft Enterprise Library Exception Handling Application Block helps implement common design patterns and create a consistent strategy for processing exceptions that occur in all architectural layers of an enterprise application.","pos":[885,1121]},{"content":"It is designed to support the typical code contained in catch statements in application components.","pos":[1122,1221]},{"content":"Instead of repeating this code (such as code that logs exception information) in identical catch blocks throughout an application, the Exception Handling Application Block allows developers to encapsulate this logic as reusable exception handlers.","pos":[1222,1469]},{"content":"This Library includes out-of-the-box a Fault Contract Exception Handler.","pos":[1476,1548]},{"content":"This exception handler is designed for use at Windows® Communication Foundation (WCF) service boundaries, and generates a new Fault Contract from the exception.","pos":[1549,1709]},{"content":"Application blocks aim to incorporate commonly used best practices and provide a common approach for exception handling throughout your application.","pos":[1716,1864]},{"content":"On the other hand, custom error handlers and fault contracts developed on one’s own can also be very useful.","pos":[1865,1973]},{"content":"For instance, custom error handlers provide an excellent opportunity to automatically promote all exceptions to FaultExceptions and also to add logging capabilities to your application.","pos":[1974,2159]},{"pos":[2166,2305],"content":"For more information, please see <bpt id=\"p1\">[</bpt>Microsoft Enterprise Library<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/msp-n-p/ff632023(v=pandp.10))</ept>.","source":"For more information, please see [Microsoft Enterprise Library](https://docs.microsoft.com/previous-versions/msp-n-p/ff632023(v=pandp.10))."},{"pos":[2315,2347],"content":"Dealing with Expected Exceptions","linkify":"Dealing with Expected Exceptions","nodes":[{"content":"Dealing with Expected Exceptions","pos":[0,32]}]},{"content":"The proper course of action is to catch expected exceptions in every operation or relevant extensibility point, decide whether they can be recovered from, and return the proper custom fault in a FaultException<ph id=\"ph1\">\\&lt;</ph>T&gt;","pos":[2351,2564],"source":"The proper course of action is to catch expected exceptions in every operation or relevant extensibility point, decide whether they can be recovered from, and return the proper custom fault in a FaultException\\<T>"},{"pos":[2574,2631],"content":"Dealing with Unexpected Exceptions using an IErrorHandler","linkify":"Dealing with Unexpected Exceptions using an IErrorHandler","nodes":[{"content":"Dealing with Unexpected Exceptions using an IErrorHandler","pos":[0,57]}]},{"content":"To deal with unexpected exceptions, the recommended course of action is to \"hook\" an IErrorHandler.","pos":[2635,2734]},{"content":"Error handlers only catch exceptions at the WCF runtime level (the \"service model\" layer), not at the channel layer.","pos":[2735,2851]},{"content":"The only way to hook an IErrorHandler at the channel level is to create a custom channel, which is not recommended in most scenarios.","pos":[2852,2985]},{"content":"An \"unexpected exception\" is generally neither an irrecoverable exception nor a processing exception; it is, instead, an unexpected user exception.","pos":[2992,3139]},{"content":"An irrecoverable exception (such as an out-of-memory exception) – one generally handled by the <bpt id=\"p1\">[</bpt>Service Model Exception Handler<ept id=\"p1\">](xref:System.ServiceModel.Dispatcher.ExceptionHandler)</ept> automatically – cannot generally be handled gracefully, and the only reason to handle such an exception at all may be do additional logging or to return a standard exception to the client.","pos":[3140,3511],"source":" An irrecoverable exception (such as an out-of-memory exception) – one generally handled by the [Service Model Exception Handler](xref:System.ServiceModel.Dispatcher.ExceptionHandler) automatically – cannot generally be handled gracefully, and the only reason to handle such an exception at all may be do additional logging or to return a standard exception to the client."},{"content":"A processing exception occurs in the processing of the message – for example, at the serialization, encoder, or formatter level – generally cannot be handled at an IErrorHandler, because it is generally either too early or too late for the error handler to intervene by the time these exceptions occur.","pos":[3512,3814]},{"content":"Similarly, transport exceptions cannot be handled at an IErrorHandler.","pos":[3815,3885]},{"content":"With an IErrorHandler, you can explicitly control the behavior of your application when an exception is thrown.","pos":[3892,4003]},{"content":"You may:","pos":[4004,4012]},{"content":"Decide whether or not to send a fault to the client","pos":[4022,4073]},{"content":"Replace an exception with a fault","pos":[4083,4116]},{"content":"Replace a fault with another fault","pos":[4126,4160]},{"content":"Perform logging or tracing","pos":[4170,4196]},{"content":"Perform other custom activities","pos":[4206,4237]},{"content":"One can install a custom error handler by adding it to the ErrorHandlers property of the channel dispatchers for your service.","pos":[4244,4370]},{"content":"It is possible to have more than one error handler and they are called in the order they are added to this collection.","pos":[4372,4490]},{"content":"IErrorHandler.ProvideFault controls the fault message that is sent to the client.","pos":[4497,4578]},{"content":"This method is called regardless of the type of the exception thrown by an operation in your service.","pos":[4579,4680]},{"content":"If no operation is performed here, WCF assumes its default behaviour and continues as if there were no custom error handlers in place.","pos":[4681,4815]},{"content":"One area that you could perhaps use this approach is when you want to create a central place for converting exceptions to faults before they are sent to the client (ensuring that the instance is not disposed and the channel is not moved to the Faulted state).","pos":[4822,5081]},{"content":"The IErrorHandler.HandleError method is usually used to implement error-related behaviors such as error logging, system notifications, shutting down the application, etc. IErrorHandler.HandleError can be called at multiple places inside the service, and depending on where the error is thrown, the HandleError method may or may not be called by the same thread as the operation; no guarantees are made in this regard.","pos":[5088,5505]},{"pos":[5515,5550],"content":"Dealing with Exceptions outside WCF","linkify":"Dealing with Exceptions outside WCF","nodes":[{"content":"Dealing with Exceptions outside WCF","pos":[0,35]}]},{"content":"Often, configuration exceptions, database connection string exceptions, and other similar exceptions may occur within the context of a WCF application, but are themselves are not exceptions caused by the service model or the web service itself.","pos":[5554,5798]},{"content":"These exceptions are \"regular\" exceptions external to the web service, and should be handled just as other external exceptions in the environment are to be handled.","pos":[5799,5963]},{"pos":[5973,5991],"content":"Tracing exceptions","linkify":"Tracing exceptions","nodes":[{"content":"Tracing exceptions","pos":[0,18]}]},{"content":"Tracing is the only \"catch-all\" place where one can potentially see all exceptions.","pos":[5995,6078]},{"content":"For more information on tracing and logging exceptions, see Tracing and Logging.","pos":[6079,6159]},{"pos":[6169,6238],"content":"URI template errors when using WebGetAttribute and WebInvokeAttribute","linkify":"URI template errors when using WebGetAttribute and WebInvokeAttribute","nodes":[{"content":"URI template errors when using WebGetAttribute and WebInvokeAttribute","pos":[0,69]}]},{"content":"The WebGet and WebInvoke attributes allow you to specify a URI template that maps components of the request address to operation parameters.","pos":[6242,6382]},{"content":"For example, the URI template \"weather/{state}/{city}\" maps the request address into literal tokens, a parameter named state, and a parameter named city.","pos":[6383,6536]},{"content":"These parameters might then be bound by name to some of the formal parameters of the operation.","pos":[6537,6632]},{"content":"The template parameters appear in the form of strings within the URI while the formal parameters of a typed contract might be of non-string types.","pos":[6639,6785]},{"content":"Therefore, a conversion needs to take place before the operation can be invoked.","pos":[6786,6866]},{"content":"A <bpt id=\"p1\">[</bpt>table of conversion formats<ept id=\"p1\">](wcf-web-http-programming-model-overview.md)</ept> is available.","pos":[6867,6956],"source":" A [table of conversion formats](wcf-web-http-programming-model-overview.md) is available."},{"content":"However, if the conversion fails, then there's no way to let the operation know that something has gone wrong.","pos":[6963,7073]},{"content":"The type conversion instead surfaces in the form of a dispatch failure.","pos":[7074,7145]},{"content":"A type conversion dispatch failure can be inspected the same as with many other types of dispatch failures by installing an error handler.","pos":[7152,7290]},{"content":"The IErrorHandler extensibility point is called to handle service-level exceptions.","pos":[7291,7374]},{"content":"From there, the response to be sent back to the caller – as well as perform any custom tasks and reporting – may be chosen.","pos":[7375,7498]},{"pos":[7507,7515],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7519,7571],"content":"<bpt id=\"p1\">[</bpt>Basic WCF Programming<ept id=\"p1\">](../basic-wcf-programming.md)</ept>","source":"[Basic WCF Programming](../basic-wcf-programming.md)"}]}