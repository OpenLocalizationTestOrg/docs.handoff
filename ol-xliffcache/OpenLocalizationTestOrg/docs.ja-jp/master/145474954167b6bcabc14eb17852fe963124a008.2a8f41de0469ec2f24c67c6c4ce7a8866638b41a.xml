{"content":"---\ntitle: \"How to: Make Thread-Safe Calls to Windows Forms Controls | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-winforms\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"EHInvalidOperation.WinForms.IllegalCrossThreadCall\"\ndev_langs: \n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"thread safety, calling controls [Windows Forms]\"\n  - \"calling controls, thread safety [Windows Forms]\"\n  - \"CheckForIllegalCrossThreadCalls property [Windows Forms]\"\n  - \"Windows Forms controls, multithreading\"\n  - \"BackgroundWorker class, examples\"\n  - \"threading [Windows Forms], cross-thread calls\"\n  - \"controls [Windows Forms], multithreading\"\nms.assetid: 138f38b6-1099-4fd5-910c-390b41cbad35\ncaps.latest.revision: 20\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# How to: Make Thread-Safe Calls to Windows Forms Controls\nIf you use multithreading to improve the performance of your Windows Forms applications, you must make sure that you make calls to your controls in a thread-safe way.  \n  \n Access to Windows Forms controls is not inherently thread safe. If you have two or more threads manipulating the state of a control, it is possible to force the control into an inconsistent state. Other thread-related bugs are possible, such as race conditions and deadlocks. It is important to make sure that access to your controls is performed in a thread-safe way.  \n  \n It is unsafe to call a control from a thread other than the one that created the control without using the <xref:System.Windows.Forms.Control.Invoke%2A> method. The following is an example of a call that is not thread safe.  \n  \n```csharp  \n// This event handler creates a thread that calls a   \n// Windows Forms control in an unsafe way.  \nprivate void setTextUnsafeBtn_Click(  \n    object sender,   \n    EventArgs e)  \n{  \n    this.demoThread =   \n        new Thread(new ThreadStart(this.ThreadProcUnsafe));  \n  \n    this.demoThread.Start();  \n}  \n  \n// This method is executed on the worker thread and makes  \n// an unsafe call on the TextBox control.  \nprivate void ThreadProcUnsafe()  \n{  \n    this.textBox1.Text = \"This text was set unsafely.\";  \n}  \n```  \n  \n```vb  \n' This event handler creates a thread that calls a   \n' Windows Forms control in an unsafe way.  \n Private Sub setTextUnsafeBtn_Click( _  \n ByVal sender As Object, _  \n ByVal e As EventArgs) Handles setTextUnsafeBtn.Click  \n  \n     Me.demoThread = New Thread( _  \n     New ThreadStart(AddressOf Me.ThreadProcUnsafe))  \n  \n     Me.demoThread.Start()  \n End Sub  \n  \n' This method is executed on the worker thread and makes  \n' an unsafe call on the TextBox control.  \nPrivate Sub ThreadProcUnsafe()  \n   Me.textBox1.Text = \"This text was set unsafely.\"  \nEnd Sub  \n```  \n  \n```cpp  \n// This event handler creates a thread that calls a  \n    // Windows Forms control in an unsafe way.  \nprivate:  \n    void setTextUnsafeBtn_Click(Object^ sender, EventArgs^ e)  \n    {  \n        this->demoThread =  \n            gcnew Thread(gcnew ThreadStart(this,&Form1::ThreadProcUnsafe));  \n  \n        this->demoThread->Start();  \n    }  \n  \n    // This method is executed on the worker thread and makes  \n    // an unsafe call on the TextBox control.  \nprivate:  \n    void ThreadProcUnsafe()  \n    {  \n        this->textBox1->Text = \"This text was set unsafely.\";  \n    }  \n```  \n  \n The [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] helps you detect when you are accessing your controls in a manner that is not thread safe. When you are running your application in the debugger, and a thread other than the one which created a control tries to call that control, the debugger raises an <xref:System.InvalidOperationException> with the message, \"Control *control name* accessed from a thread other than the thread it was created on.\"  \n  \n This exception occurs reliably during debugging and, under some circumstances, at run time. You might see this exception when you debug applications that you wrote with the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] prior to the [!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]. You are strongly advised to fix this problem when you see it, but you can disable it by setting the <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> property to `false`. This causes your control to run like it would run under Visual Studio .NET 2003 and the [!INCLUDE[net_v11_short](../../../../includes/net-v11-short-md.md)].  \n  \n> [!NOTE]\n>  If you are using ActiveX controls on a form, you may receive the cross-thread <xref:System.InvalidOperationException> when you run under the debugger. When this occurs, the ActiveX control does not support multithreading. For more information about using ActiveX controls with Windows Forms, see [Windows Forms and Unmanaged Applications](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md). If you are using Visual Studio, you can prevent this exception by disabling the Visual Studio hosting process, see [How to: Disable the Hosting Process](/visualstudio/ide/how-to-disable-the-hosting-process).  \n  \n## Making Thread-Safe Calls to Windows Forms Controls  \n  \n#### To make a thread-safe call to a Windows Forms control  \n  \n1.  Query the control's <xref:System.Windows.Forms.Control.InvokeRequired%2A> property.  \n  \n2.  If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `true`, call <xref:System.Windows.Forms.Control.Invoke%2A> with a delegate that makes the actual call to the control.  \n  \n3.  If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `false`, call the control directly.  \n  \n In the following code example, a thread-safe call is implemented in the `ThreadProcSafe` method, which is executed by the background thread. If the <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `true`, the `ThreadProcSafe` method creates an instance of `StringArgReturningVoidDelegate` and passes that to the form's <xref:System.Windows.Forms.Control.Invoke%2A> method. This causes the `SetText` method to be called on the thread that created the <xref:System.Windows.Forms.TextBox> control, and in this thread context the <xref:System.Windows.Forms.Control.Text%2A> property is set directly.  \n  \n```csharp  \n// This event handler creates a thread that calls a   \n// Windows Forms control in a thread-safe way.  \nprivate void setTextSafeBtn_Click(  \n    object sender,   \n    EventArgs e)  \n{  \n    this.demoThread =   \n        new Thread(new ThreadStart(this.ThreadProcSafe));  \n  \n    this.demoThread.Start();  \n}  \n  \n// This method is executed on the worker thread and makes  \n// a thread-safe call on the TextBox control.  \nprivate void ThreadProcSafe()  \n{  \n    this.SetText(\"This text was set safely.\");  \n}  \n```  \n  \n```vb  \n' This event handler creates a thread that calls a   \n' Windows Forms control in a thread-safe way.  \n Private Sub setTextSafeBtn_Click( _  \n ByVal sender As Object, _  \n ByVal e As EventArgs) Handles setTextSafeBtn.Click  \n  \n     Me.demoThread = New Thread( _  \n     New ThreadStart(AddressOf Me.ThreadProcSafe))  \n  \n     Me.demoThread.Start()  \n End Sub  \n  \n' This method is executed on the worker thread and makes  \n' a thread-safe call on the TextBox control.  \nPrivate Sub ThreadProcSafe()  \n   Me.SetText(\"This text was set safely.\")  \n End Sub  \n```  \n  \n```cpp  \n// This event handler creates a thread that calls a  \n    // Windows Forms control in a thread-safe way.  \nprivate:  \n    void setTextSafeBtn_Click(Object^ sender, EventArgs^ e)  \n    {  \n        this->demoThread =  \n            gcnew Thread(gcnew ThreadStart(this,&Form1::ThreadProcSafe));  \n  \n        this->demoThread->Start();  \n    }  \n  \n    // This method is executed on the worker thread and makes  \n    // a thread-safe call on the TextBox control.  \nprivate:  \n    void ThreadProcSafe()  \n    {  \n        this->SetText(\"This text was set safely.\");  \n    }  \n```  \n  \n```csharp  \n// This delegate enables asynchronous calls for setting  \n// the text property on a TextBox control.  \ndelegate void StringArgReturningVoidDelegate(string text);  \n```  \n  \n```vb  \n' This delegate enables asynchronous calls for setting  \n' the text property on a TextBox control.  \nDelegate Sub StringArgReturningVoidDelegate([text] As String)  \n```  \n  \n```cpp  \n// This delegate enables asynchronous calls for setting  \n// the text property on a TextBox control.  \ndelegate void StringArgReturningVoidDelegate(String^ text);  \n```  \n  \n```csharp  \n// This method demonstrates a pattern for making thread-safe  \n// calls on a Windows Forms control.   \n//  \n// If the calling thread is different from the thread that  \n// created the TextBox control, this method creates a  \n// StringArgReturningVoidDelegate and calls itself asynchronously using the  \n// Invoke method.  \n//  \n// If the calling thread is the same as the thread that created  \n// the TextBox control, the Text property is set directly.   \n  \nprivate void SetText(string text)  \n{  \n    // InvokeRequired required compares the thread ID of the  \n    // calling thread to the thread ID of the creating thread.  \n    // If these threads are different, it returns true.  \n    if (this.textBox1.InvokeRequired)  \n    {     \n        StringArgReturningVoidDelegate d = new StringArgReturningVoidDelegate(SetText);  \n        this.Invoke(d, new object[] { text });  \n    }  \n    else  \n    {  \n        this.textBox1.Text = text;  \n    }  \n}  \n```  \n  \n```vb  \n' This method demonstrates a pattern for making thread-safe  \n' calls on a Windows Forms control.   \n'  \n' If the calling thread is different from the thread that  \n' created the TextBox control, this method creates a  \n' StringArgReturningVoidDelegate and calls itself asynchronously using the  \n' Invoke method.  \n'  \n' If the calling thread is the same as the thread that created  \n ' the TextBox control, the Text property is set directly.   \n  \n Private Sub SetText(ByVal [text] As String)  \n  \n     ' InvokeRequired required compares the thread ID of the  \n     ' calling thread to the thread ID of the creating thread.  \n     ' If these threads are different, it returns true.  \n     If Me.textBox1.InvokeRequired Then  \n         Dim d As New StringArgReturningVoidDelegate(AddressOf SetText)  \n         Me.Invoke(d, New Object() {[text]})  \n     Else  \n         Me.textBox1.Text = [text]  \n     End If  \n End Sub  \n```  \n  \n```cpp  \n// This method demonstrates a pattern for making thread-safe  \n    // calls on a Windows Forms control.  \n    //  \n    // If the calling thread is different from the thread that  \n    // created the TextBox control, this method creates a  \n    // StringArgReturningVoidDelegate and calls itself asynchronously using the  \n    // Invoke method.  \n    //  \n    // If the calling thread is the same as the thread that created  \n    // the TextBox control, the Text property is set directly.  \n  \nprivate:  \n    void SetText(String^ text)  \n    {  \n        // InvokeRequired required compares the thread ID of the  \n        // calling thread to the thread ID of the creating thread.  \n        // If these threads are different, it returns true.  \n        if (this->textBox1->InvokeRequired)  \n        {  \n            StringArgReturningVoidDelegate^ d =   \n                gcnew StringArgReturningVoidDelegate(this, &Form1::SetText);  \n            this->Invoke(d, gcnew array<Object^> { text });  \n        }  \n        else  \n        {  \n            this->textBox1->Text = text;  \n        }  \n    }  \n```  \n  \n## Making Thread-Safe Calls by using BackgroundWorker  \n The preferred way to implement multithreading in your application is to use the <xref:System.ComponentModel.BackgroundWorker> component. The <xref:System.ComponentModel.BackgroundWorker> component uses an event-driven model for multithreading. The background thread runs your <xref:System.ComponentModel.BackgroundWorker.DoWork> event handler, and the thread that creates your controls runs your <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> and <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handlers. You can call your controls from your <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> and <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handlers.  \n  \n#### To make thread-safe calls by using BackgroundWorker  \n  \n1.  Create a method to do the work that you want done in the background thread. Do not call controls created by the main thread in this method.  \n  \n2.  Create a method to report the results of your background work after it finishes. You can call controls created by the main thread in this method.  \n  \n3.  Bind the method created in step 1 to the <xref:System.ComponentModel.BackgroundWorker.DoWork> event of an instance of <xref:System.ComponentModel.BackgroundWorker>, and bind the method created in step 2 to the same instance’s <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event.  \n  \n4.  To start the background thread, call the <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> method of the <xref:System.ComponentModel.BackgroundWorker> instance.  \n  \n In the following code example, the <xref:System.ComponentModel.BackgroundWorker.DoWork> event handler uses <xref:System.Threading.Thread.Sleep%2A> to simulate work that takes some time. It does not call the form’s <xref:System.Windows.Forms.TextBox> control. The <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.Control.Text%2A> property is set directly in the <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handler.  \n  \n```csharp  \n// This BackgroundWorker is used to demonstrate the   \n// preferred way of performing asynchronous operations.  \nprivate BackgroundWorker backgroundWorker1;  \n```  \n  \n```vb  \n' This BackgroundWorker is used to demonstrate the   \n' preferred way of performing asynchronous operations.  \nPrivate WithEvents backgroundWorker1 As BackgroundWorker  \n```  \n  \n```cpp  \n// This BackgroundWorker is used to demonstrate the  \n    // preferred way of performing asynchronous operations.  \nprivate:  \n    BackgroundWorker^ backgroundWorker1;  \n```  \n  \n```csharp  \n// This event handler starts the form's   \n// BackgroundWorker by calling RunWorkerAsync.  \n//  \n// The Text property of the TextBox control is set  \n// when the BackgroundWorker raises the RunWorkerCompleted  \n// event.  \nprivate void setTextBackgroundWorkerBtn_Click(  \n    object sender,   \n    EventArgs e)  \n{  \n    this.backgroundWorker1.RunWorkerAsync();  \n}  \n  \n// This event handler sets the Text property of the TextBox  \n// control. It is called on the thread that created the   \n// TextBox control, so the call is thread-safe.  \n//  \n// BackgroundWorker is the preferred way to perform asynchronous  \n// operations.  \n  \nprivate void backgroundWorker1_RunWorkerCompleted(  \n    object sender,   \n    RunWorkerCompletedEventArgs e)  \n{  \n    this.textBox1.Text =   \n        \"This text was set safely by BackgroundWorker.\";  \n}  \n```  \n  \n```vb  \n' This event handler starts the form's   \n' BackgroundWorker by calling RunWorkerAsync.  \n'  \n' The Text property of the TextBox control is set  \n' when the BackgroundWorker raises the RunWorkerCompleted  \n' event.  \n Private Sub setTextBackgroundWorkerBtn_Click( _  \n ByVal sender As Object, _  \n ByVal e As EventArgs) Handles setTextBackgroundWorkerBtn.Click  \n     Me.backgroundWorker1.RunWorkerAsync()  \n End Sub  \n  \n' This event handler sets the Text property of the TextBox  \n' control. It is called on the thread that created the   \n' TextBox control, so the call is thread-safe.  \n'  \n' BackgroundWorker is the preferred way to perform asynchronous  \n' operations.  \n Private Sub backgroundWorker1_RunWorkerCompleted( _  \n ByVal sender As Object, _  \n ByVal e As RunWorkerCompletedEventArgs) _  \n Handles backgroundWorker1.RunWorkerCompleted  \n     Me.textBox1.Text = _  \n     \"This text was set safely by BackgroundWorker.\"  \n End Sub  \n```  \n  \n```cpp  \n// This event handler starts the form's  \n    // BackgroundWorker by calling RunWorkerAsync.  \n    //  \n    // The Text property of the TextBox control is set  \n    // when the BackgroundWorker raises the RunWorkerCompleted  \n    // event.  \nprivate:  \n    void setTextBackgroundWorkerBtn_Click(Object^ sender, EventArgs^ e)  \n    {  \n        this->backgroundWorker1->RunWorkerAsync();  \n    }  \n  \n    // This event handler sets the Text property of the TextBox  \n    // control. It is called on the thread that created the  \n    // TextBox control, so the call is thread-safe.  \n    //  \n    // BackgroundWorker is the preferred way to perform asynchronous  \n    // operations.  \n  \nprivate:  \n    void backgroundWorker1_RunWorkerCompleted(  \n        Object^ sender,  \n        RunWorkerCompletedEventArgs^ e)  \n    {  \n        this->textBox1->Text =  \n            \"This text was set safely by BackgroundWorker.\";  \n    }  \n```  \n  \n You can also report the progress of a background task by using the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> event. For an example that incorporates that event, see <xref:System.ComponentModel.BackgroundWorker>.  \n  \n## Example  \n The following code example is a complete Windows Forms application that consists of a form with three buttons and one text box. The first button demonstrates unsafe cross-thread access, the second button demonstrates safe access by using <xref:System.Windows.Forms.Control.Invoke%2A>, and the third button demonstrates safe access by using <xref:System.ComponentModel.BackgroundWorker>.  \n  \n> [!NOTE]\n>  For instructions on how to run the example, see [How to: Compile and Run a Complete Windows Forms Code Example Using Visual Studio](http://msdn.microsoft.com/en-us/cc447f7e-4c3b-4397-9d05-aeba3ca49416). This example requires references to the System.Drawing and System.Windows.Forms assemblies.  \n  \n```csharp  \nusing System;  \nusing System.ComponentModel;  \nusing System.Threading;  \nusing System.Windows.Forms;  \n  \nnamespace CrossThreadDemo  \n{  \n    public class Form1 : Form  \n    {  \n        // This delegate enables asynchronous calls for setting  \n        // the text property on a TextBox control.  \n        delegate void StringArgReturningVoidDelegate(string text);  \n  \n        // This thread is used to demonstrate both thread-safe and  \n        // unsafe ways to call a Windows Forms control.  \n        private Thread demoThread = null;  \n  \n        // This BackgroundWorker is used to demonstrate the   \n        // preferred way of performing asynchronous operations.  \n        private BackgroundWorker backgroundWorker1;  \n  \n        private TextBox textBox1;  \n        private Button setTextUnsafeBtn;  \n        private Button setTextSafeBtn;  \n        private Button setTextBackgroundWorkerBtn;  \n  \n        private System.ComponentModel.IContainer components = null;  \n  \n        public Form1()  \n        {  \n            InitializeComponent();  \n        }  \n  \n        protected override void Dispose(bool disposing)  \n        {  \n            if (disposing && (components != null))  \n            {  \n                components.Dispose();  \n            }  \n            base.Dispose(disposing);  \n        }  \n  \n        // This event handler creates a thread that calls a   \n        // Windows Forms control in an unsafe way.  \n        private void setTextUnsafeBtn_Click(  \n            object sender,   \n            EventArgs e)  \n        {  \n            this.demoThread =   \n                new Thread(new ThreadStart(this.ThreadProcUnsafe));  \n  \n            this.demoThread.Start();  \n        }  \n  \n        // This method is executed on the worker thread and makes  \n        // an unsafe call on the TextBox control.  \n        private void ThreadProcUnsafe()  \n        {  \n            this.textBox1.Text = \"This text was set unsafely.\";  \n        }  \n  \n        // This event handler creates a thread that calls a   \n        // Windows Forms control in a thread-safe way.  \n        private void setTextSafeBtn_Click(  \n            object sender,   \n            EventArgs e)  \n        {  \n            this.demoThread =   \n                new Thread(new ThreadStart(this.ThreadProcSafe));  \n  \n            this.demoThread.Start();  \n        }  \n  \n        // This method is executed on the worker thread and makes  \n        // a thread-safe call on the TextBox control.  \n        private void ThreadProcSafe()  \n        {  \n            this.SetText(\"This text was set safely.\");  \n        }  \n  \n        // This method demonstrates a pattern for making thread-safe  \n        // calls on a Windows Forms control.   \n        //  \n        // If the calling thread is different from the thread that  \n        // created the TextBox control, this method creates a  \n        // StringArgReturningVoidDelegate and calls itself asynchronously using the  \n        // Invoke method.  \n        //  \n        // If the calling thread is the same as the thread that created  \n        // the TextBox control, the Text property is set directly.   \n  \n        private void SetText(string text)  \n        {  \n            // InvokeRequired required compares the thread ID of the  \n            // calling thread to the thread ID of the creating thread.  \n            // If these threads are different, it returns true.  \n            if (this.textBox1.InvokeRequired)  \n            {     \n                StringArgReturningVoidDelegate d = new StringArgReturningVoidDelegate(SetText);  \n                this.Invoke(d, new object[] { text });  \n            }  \n            else  \n            {  \n                this.textBox1.Text = text;  \n            }  \n        }  \n  \n        // This event handler starts the form's   \n        // BackgroundWorker by calling RunWorkerAsync.  \n        //  \n        // The Text property of the TextBox control is set  \n        // when the BackgroundWorker raises the RunWorkerCompleted  \n        // event.  \n        private void setTextBackgroundWorkerBtn_Click(  \n            object sender,   \n            EventArgs e)  \n        {  \n            this.backgroundWorker1.RunWorkerAsync();  \n        }  \n  \n        // This event handler sets the Text property of the TextBox  \n        // control. It is called on the thread that created the   \n        // TextBox control, so the call is thread-safe.  \n        //  \n        // BackgroundWorker is the preferred way to perform asynchronous  \n        // operations.  \n  \n        private void backgroundWorker1_RunWorkerCompleted(  \n            object sender,   \n            RunWorkerCompletedEventArgs e)  \n        {  \n            this.textBox1.Text =   \n                \"This text was set safely by BackgroundWorker.\";  \n        }  \n  \n        #region Windows Form Designer generated code  \n  \n        private void InitializeComponent()  \n        {  \n            this.textBox1 = new System.Windows.Forms.TextBox();  \n            this.setTextUnsafeBtn = new System.Windows.Forms.Button();  \n            this.setTextSafeBtn = new System.Windows.Forms.Button();  \n            this.setTextBackgroundWorkerBtn = new System.Windows.Forms.Button();  \n            this.backgroundWorker1 = new System.ComponentModel.BackgroundWorker();  \n            this.SuspendLayout();  \n            //   \n            // textBox1  \n            //   \n            this.textBox1.Location = new System.Drawing.Point(12, 12);  \n            this.textBox1.Name = \"textBox1\";  \n            this.textBox1.Size = new System.Drawing.Size(240, 20);  \n            this.textBox1.TabIndex = 0;  \n            //   \n            // setTextUnsafeBtn  \n            //   \n            this.setTextUnsafeBtn.Location = new System.Drawing.Point(15, 55);  \n            this.setTextUnsafeBtn.Name = \"setTextUnsafeBtn\";  \n            this.setTextUnsafeBtn.TabIndex = 1;  \n            this.setTextUnsafeBtn.Text = \"Unsafe Call\";  \n            this.setTextUnsafeBtn.Click += new System.EventHandler(this.setTextUnsafeBtn_Click);  \n            //   \n            // setTextSafeBtn  \n            //   \n            this.setTextSafeBtn.Location = new System.Drawing.Point(96, 55);  \n            this.setTextSafeBtn.Name = \"setTextSafeBtn\";  \n            this.setTextSafeBtn.TabIndex = 2;  \n            this.setTextSafeBtn.Text = \"Safe Call\";  \n            this.setTextSafeBtn.Click += new System.EventHandler(this.setTextSafeBtn_Click);  \n            //   \n            // setTextBackgroundWorkerBtn  \n            //   \n            this.setTextBackgroundWorkerBtn.Location = new System.Drawing.Point(177, 55);  \n            this.setTextBackgroundWorkerBtn.Name = \"setTextBackgroundWorkerBtn\";  \n            this.setTextBackgroundWorkerBtn.TabIndex = 3;  \n            this.setTextBackgroundWorkerBtn.Text = \"Safe BW Call\";  \n            this.setTextBackgroundWorkerBtn.Click += new System.EventHandler(this.setTextBackgroundWorkerBtn_Click);  \n            //   \n            // backgroundWorker1  \n            //   \n            this.backgroundWorker1.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.backgroundWorker1_RunWorkerCompleted);  \n            //   \n            // Form1  \n            //   \n            this.ClientSize = new System.Drawing.Size(268, 96);  \n            this.Controls.Add(this.setTextBackgroundWorkerBtn);  \n            this.Controls.Add(this.setTextSafeBtn);  \n            this.Controls.Add(this.setTextUnsafeBtn);  \n            this.Controls.Add(this.textBox1);  \n            this.Name = \"Form1\";  \n            this.Text = \"Form1\";  \n            this.ResumeLayout(false);  \n            this.PerformLayout();  \n  \n        }  \n  \n        #endregion  \n  \n        [STAThread]  \n        static void Main()  \n        {  \n            Application.EnableVisualStyles();  \n            Application.Run(new Form1());  \n        }  \n  \n    }  \n}  \n```  \n  \n```vb  \nImports System  \nImports System.ComponentModel  \nImports System.Threading  \nImports System.Windows.Forms  \n  \nPublic Class Form1  \n   Inherits Form  \n  \n   ' This delegate enables asynchronous calls for setting  \n   ' the text property on a TextBox control.  \n   Delegate Sub StringArgReturningVoidDelegate([text] As String)  \n  \n   ' This thread is used to demonstrate both thread-safe and  \n   ' unsafe ways to call a Windows Forms control.  \n   Private demoThread As Thread = Nothing  \n  \n   ' This BackgroundWorker is used to demonstrate the   \n   ' preferred way of performing asynchronous operations.  \n   Private WithEvents backgroundWorker1 As BackgroundWorker  \n  \n   Private textBox1 As TextBox  \n   Private WithEvents setTextUnsafeBtn As Button  \n   Private WithEvents setTextSafeBtn As Button  \n   Private WithEvents setTextBackgroundWorkerBtn As Button  \n  \n   Private components As System.ComponentModel.IContainer = Nothing  \n  \n   Public Sub New()  \n      InitializeComponent()  \n    End Sub  \n  \n   Protected Overrides Sub Dispose(disposing As Boolean)  \n      If disposing AndAlso (components IsNot Nothing) Then  \n         components.Dispose()  \n      End If  \n      MyBase.Dispose(disposing)  \n    End Sub  \n  \n   ' This event handler creates a thread that calls a   \n   ' Windows Forms control in an unsafe way.  \n    Private Sub setTextUnsafeBtn_Click( _  \n    ByVal sender As Object, _  \n    ByVal e As EventArgs) Handles setTextUnsafeBtn.Click  \n  \n        Me.demoThread = New Thread( _  \n        New ThreadStart(AddressOf Me.ThreadProcUnsafe))  \n  \n        Me.demoThread.Start()  \n    End Sub  \n  \n   ' This method is executed on the worker thread and makes  \n   ' an unsafe call on the TextBox control.  \n   Private Sub ThreadProcUnsafe()  \n      Me.textBox1.Text = \"This text was set unsafely.\"  \n   End Sub   \n  \n   ' This event handler creates a thread that calls a   \n   ' Windows Forms control in a thread-safe way.  \n    Private Sub setTextSafeBtn_Click( _  \n    ByVal sender As Object, _  \n    ByVal e As EventArgs) Handles setTextSafeBtn.Click  \n  \n        Me.demoThread = New Thread( _  \n        New ThreadStart(AddressOf Me.ThreadProcSafe))  \n  \n        Me.demoThread.Start()  \n    End Sub  \n  \n   ' This method is executed on the worker thread and makes  \n   ' a thread-safe call on the TextBox control.  \n   Private Sub ThreadProcSafe()  \n      Me.SetText(\"This text was set safely.\")  \n    End Sub  \n  \n   ' This method demonstrates a pattern for making thread-safe  \n   ' calls on a Windows Forms control.   \n   '  \n   ' If the calling thread is different from the thread that  \n   ' created the TextBox control, this method creates a  \n   ' StringArgReturningVoidDelegate and calls itself asynchronously using the  \n   ' Invoke method.  \n   '  \n   ' If the calling thread is the same as the thread that created  \n    ' the TextBox control, the Text property is set directly.   \n  \n    Private Sub SetText(ByVal [text] As String)  \n  \n        ' InvokeRequired required compares the thread ID of the  \n        ' calling thread to the thread ID of the creating thread.  \n        ' If these threads are different, it returns true.  \n        If Me.textBox1.InvokeRequired Then  \n            Dim d As New StringArgReturningVoidDelegate(AddressOf SetText)  \n            Me.Invoke(d, New Object() {[text]})  \n        Else  \n            Me.textBox1.Text = [text]  \n        End If  \n    End Sub  \n  \n   ' This event handler starts the form's   \n   ' BackgroundWorker by calling RunWorkerAsync.  \n   '  \n   ' The Text property of the TextBox control is set  \n   ' when the BackgroundWorker raises the RunWorkerCompleted  \n   ' event.  \n    Private Sub setTextBackgroundWorkerBtn_Click( _  \n    ByVal sender As Object, _  \n    ByVal e As EventArgs) Handles setTextBackgroundWorkerBtn.Click  \n        Me.backgroundWorker1.RunWorkerAsync()  \n    End Sub  \n  \n   ' This event handler sets the Text property of the TextBox  \n   ' control. It is called on the thread that created the   \n   ' TextBox control, so the call is thread-safe.  \n   '  \n   ' BackgroundWorker is the preferred way to perform asynchronous  \n   ' operations.  \n    Private Sub backgroundWorker1_RunWorkerCompleted( _  \n    ByVal sender As Object, _  \n    ByVal e As RunWorkerCompletedEventArgs) _  \n    Handles backgroundWorker1.RunWorkerCompleted  \n        Me.textBox1.Text = _  \n        \"This text was set safely by BackgroundWorker.\"  \n    End Sub  \n  \n   #Region \"Windows Form Designer generated code\"  \n  \n   Private Sub InitializeComponent()  \n      Me.textBox1 = New System.Windows.Forms.TextBox()  \n      Me.setTextUnsafeBtn = New System.Windows.Forms.Button()  \n      Me.setTextSafeBtn = New System.Windows.Forms.Button()  \n      Me.setTextBackgroundWorkerBtn = New System.Windows.Forms.Button()  \n      Me.backgroundWorker1 = New System.ComponentModel.BackgroundWorker()  \n      Me.SuspendLayout()  \n      '   \n      ' textBox1  \n      '   \n      Me.textBox1.Location = New System.Drawing.Point(12, 12)  \n      Me.textBox1.Name = \"textBox1\"  \n      Me.textBox1.Size = New System.Drawing.Size(240, 20)  \n      Me.textBox1.TabIndex = 0  \n      '   \n      ' setTextUnsafeBtn  \n      '   \n      Me.setTextUnsafeBtn.Location = New System.Drawing.Point(15, 55)  \n      Me.setTextUnsafeBtn.Name = \"setTextUnsafeBtn\"  \n      Me.setTextUnsafeBtn.TabIndex = 1  \n      Me.setTextUnsafeBtn.Text = \"Unsafe Call\"  \n      '   \n      ' setTextSafeBtn  \n      '   \n      Me.setTextSafeBtn.Location = New System.Drawing.Point(96, 55)  \n      Me.setTextSafeBtn.Name = \"setTextSafeBtn\"  \n      Me.setTextSafeBtn.TabIndex = 2  \n      Me.setTextSafeBtn.Text = \"Safe Call\"  \n      '   \n      ' setTextBackgroundWorkerBtn  \n      '   \n      Me.setTextBackgroundWorkerBtn.Location = New System.Drawing.Point(177, 55)  \n      Me.setTextBackgroundWorkerBtn.Name = \"setTextBackgroundWorkerBtn\"  \n      Me.setTextBackgroundWorkerBtn.TabIndex = 3  \n      Me.setTextBackgroundWorkerBtn.Text = \"Safe BW Call\"  \n      '   \n      ' backgroundWorker1  \n      '   \n      '   \n      ' Form1  \n      '   \n      Me.ClientSize = New System.Drawing.Size(268, 96)  \n      Me.Controls.Add(setTextBackgroundWorkerBtn)  \n      Me.Controls.Add(setTextSafeBtn)  \n      Me.Controls.Add(setTextUnsafeBtn)  \n      Me.Controls.Add(textBox1)  \n      Me.Name = \"Form1\"  \n      Me.Text = \"Form1\"  \n      Me.ResumeLayout(False)  \n      Me.PerformLayout()  \n   End Sub 'InitializeComponent   \n  \n   #End Region  \n  \n   <STAThread()>  _  \n   Shared Sub Main()  \n      Application.EnableVisualStyles()  \n      Application.Run(New Form1())  \n    End Sub  \nEnd Class  \n```  \n  \n```cpp  \n#using <System.dll>  \n#using <System.Windows.Forms.dll>  \n#using <System.Drawing.dll>  \n  \nusing namespace System;  \nusing namespace System::ComponentModel;  \nusing namespace System::Threading;  \nusing namespace System::Windows::Forms;  \n  \nnamespace CrossThreadDemo  \n{  \n    public ref class Form1 : public Form  \n    {  \n        // This delegate enables asynchronous calls for setting  \n        // the text property on a TextBox control.  \n        delegate void StringArgReturningVoidDelegate(String^ text);  \n  \n        // This thread is used to demonstrate both thread-safe and  \n        // unsafe ways to call a Windows Forms control.  \n    private:  \n        Thread^ demoThread;  \n  \n        // This BackgroundWorker is used to demonstrate the  \n        // preferred way of performing asynchronous operations.  \n    private:  \n        BackgroundWorker^ backgroundWorker1;  \n  \n    private:  \n        TextBox^ textBox1;  \n    private:  \n        Button^ setTextUnsafeBtn;  \n    private:  \n        Button^ setTextSafeBtn;  \n    private:  \n        Button^ setTextBackgroundWorkerBtn;  \n  \n    private:  \n        System::ComponentModel::IContainer^ components;  \n  \n    public:  \n        Form1()  \n        {  \n            components = nullptr;  \n            InitializeComponent();  \n        }  \n  \n    protected:  \n        ~Form1()  \n        {  \n            if (components != nullptr)  \n            {  \n                delete components;  \n            }  \n        }  \n  \n        // This event handler creates a thread that calls a  \n        // Windows Forms control in an unsafe way.  \n    private:  \n        void setTextUnsafeBtn_Click(Object^ sender, EventArgs^ e)  \n        {  \n            this->demoThread =  \n                gcnew Thread(gcnew ThreadStart(this,&Form1::ThreadProcUnsafe));  \n  \n            this->demoThread->Start();  \n        }  \n  \n        // This method is executed on the worker thread and makes  \n        // an unsafe call on the TextBox control.  \n    private:  \n        void ThreadProcUnsafe()  \n        {  \n            this->textBox1->Text = \"This text was set unsafely.\";  \n        }  \n  \n        // This event handler creates a thread that calls a  \n        // Windows Forms control in a thread-safe way.  \n    private:  \n        void setTextSafeBtn_Click(Object^ sender, EventArgs^ e)  \n        {  \n            this->demoThread =  \n                gcnew Thread(gcnew ThreadStart(this,&Form1::ThreadProcSafe));  \n  \n            this->demoThread->Start();  \n        }  \n  \n        // This method is executed on the worker thread and makes  \n        // a thread-safe call on the TextBox control.  \n    private:  \n        void ThreadProcSafe()  \n        {  \n            this->SetText(\"This text was set safely.\");  \n        }  \n  \n        // This method demonstrates a pattern for making thread-safe  \n        // calls on a Windows Forms control.  \n        //  \n        // If the calling thread is different from the thread that  \n        // created the TextBox control, this method creates a  \n        // StringArgReturningVoidDelegate and calls itself asynchronously using the  \n        // Invoke method.  \n        //  \n        // If the calling thread is the same as the thread that created  \n        // the TextBox control, the Text property is set directly.  \n  \n    private:  \n        void SetText(String^ text)  \n        {  \n            // InvokeRequired required compares the thread ID of the  \n            // calling thread to the thread ID of the creating thread.  \n            // If these threads are different, it returns true.  \n            if (this->textBox1->InvokeRequired)  \n            {  \n                StringArgReturningVoidDelegate^ d =   \n                    gcnew StringArgReturningVoidDelegate(this, &Form1::SetText);  \n                this->Invoke(d, gcnew array<Object^> { text });  \n            }  \n            else  \n            {  \n                this->textBox1->Text = text;  \n            }  \n        }  \n  \n        // This event handler starts the form's  \n        // BackgroundWorker by calling RunWorkerAsync.  \n        //  \n        // The Text property of the TextBox control is set  \n        // when the BackgroundWorker raises the RunWorkerCompleted  \n        // event.  \n    private:  \n        void setTextBackgroundWorkerBtn_Click(Object^ sender, EventArgs^ e)  \n        {  \n            this->backgroundWorker1->RunWorkerAsync();  \n        }  \n  \n        // This event handler sets the Text property of the TextBox  \n        // control. It is called on the thread that created the  \n        // TextBox control, so the call is thread-safe.  \n        //  \n        // BackgroundWorker is the preferred way to perform asynchronous  \n        // operations.  \n  \n    private:  \n        void backgroundWorker1_RunWorkerCompleted(  \n            Object^ sender,  \n            RunWorkerCompletedEventArgs^ e)  \n        {  \n            this->textBox1->Text =  \n                \"This text was set safely by BackgroundWorker.\";  \n        }  \n  \n        #pragma region Windows Form Designer generated code  \n  \n    private:  \n        void InitializeComponent()  \n        {  \n            this->textBox1 = gcnew System::Windows::Forms::TextBox();  \n            this->setTextUnsafeBtn = gcnew System::Windows::Forms::Button();  \n            this->setTextSafeBtn = gcnew System::Windows::Forms::Button();  \n            this->setTextBackgroundWorkerBtn =   \n                gcnew System::Windows::Forms::Button();  \n            this->backgroundWorker1 =   \n                gcnew System::ComponentModel::BackgroundWorker();  \n            this->SuspendLayout();  \n            //  \n            // textBox1  \n            //  \n            this->textBox1->Location = System::Drawing::Point(12, 12);  \n            this->textBox1->Name = \"textBox1\";  \n            this->textBox1->Size = System::Drawing::Size(240, 20);  \n            this->textBox1->TabIndex = 0;  \n            //  \n            // setTextUnsafeBtn  \n            //  \n            this->setTextUnsafeBtn->Location = System::Drawing::Point(15, 55);  \n            this->setTextUnsafeBtn->Name = \"setTextUnsafeBtn\";  \n            this->setTextUnsafeBtn->TabIndex = 1;  \n            this->setTextUnsafeBtn->Text = \"Unsafe Call\";  \n            this->setTextUnsafeBtn->Click +=   \n                gcnew System::EventHandler(  \n                this,&Form1::setTextUnsafeBtn_Click);  \n            //  \n            // setTextSafeBtn  \n            //  \n            this->setTextSafeBtn->Location = System::Drawing::Point(96, 55);  \n            this->setTextSafeBtn->Name = \"setTextSafeBtn\";  \n            this->setTextSafeBtn->TabIndex = 2;  \n            this->setTextSafeBtn->Text = \"Safe Call\";  \n            this->setTextSafeBtn->Click +=   \n                gcnew System::EventHandler(this,&Form1::setTextSafeBtn_Click);  \n            //  \n            // setTextBackgroundWorkerBtn  \n            //  \n            this->setTextBackgroundWorkerBtn->Location =   \n                System::Drawing::Point(177, 55);  \n            this->setTextBackgroundWorkerBtn->Name =   \n                \"setTextBackgroundWorkerBtn\";  \n            this->setTextBackgroundWorkerBtn->TabIndex = 3;  \n            this->setTextBackgroundWorkerBtn->Text = \"Safe BW Call\";  \n            this->setTextBackgroundWorkerBtn->Click +=   \n                gcnew System::EventHandler(  \n                this,&Form1::setTextBackgroundWorkerBtn_Click);  \n            //  \n            // backgroundWorker1  \n            //  \n            this->backgroundWorker1->RunWorkerCompleted +=   \n                gcnew System::ComponentModel::RunWorkerCompletedEventHandler(  \n                this,&Form1::backgroundWorker1_RunWorkerCompleted);  \n            //  \n            // Form1  \n            //  \n            this->ClientSize = System::Drawing::Size(268, 96);  \n            this->Controls->Add(this->setTextBackgroundWorkerBtn);  \n            this->Controls->Add(this->setTextSafeBtn);  \n            this->Controls->Add(this->setTextUnsafeBtn);  \n            this->Controls->Add(this->textBox1);  \n            this->Name = \"Form1\";  \n            this->Text = \"Form1\";  \n            this->ResumeLayout(false);  \n            this->PerformLayout();  \n  \n        }  \n  \n        #pragma endregion  \n    };  \n}  \n  \n[STAThread]  \nint main()  \n{  \n    Application::EnableVisualStyles();  \n    Application::Run(gcnew CrossThreadDemo::Form1());  \n}  \n```  \n  \n When you run the application and click the **Unsafe Call** button, you immediately see \"Written by the main thread\" in the text box. Two seconds later, when the unsafe call is attempted, the Visual Studio debugger indicates that an exception occurred. The debugger stops at the line in the background thread that attempted to write directly to the text box. You will have to restart the application to test the other two buttons. When you click the **Safe Call** button, \"Written by the main thread\" appears in the text box. Two seconds later, the text box is set to \"Written by the background thread (Invoke)\", which indicates that the <xref:System.Windows.Forms.Control.Invoke%2A> method was called. When you click the **Safe BW Call** button, \"Written by the main thread\" appears in the text box. Two seconds later, the text box is set to \"Written by the main thread after the background thread completed\", which indicates that the handler for the <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event of <xref:System.ComponentModel.BackgroundWorker> was called.  \n  \n## Robust Programming  \n  \n> [!CAUTION]\n>  When you use multithreading of any sort, your code can be exposed to very serious and complex bugs. For more information, see [Managed Threading Best Practices](../../../../docs/standard/threading/managed-threading-best-practices.md) before you implement any solution that uses multithreading.  \n  \n## See Also  \n <xref:System.ComponentModel.BackgroundWorker>   \n [How to: Run an Operation in the Background](../../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)   \n [How to: Implement a Form That Uses a Background Operation](../../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md)   \n [Developing Custom Windows Forms Controls with the .NET Framework](../../../../docs/framework/winforms/controls/developing-custom-windows-forms-controls.md)   \n [Windows Forms and Unmanaged Applications](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md)","nodes":[{"pos":[4,863],"nodes":[{"content":"How to: Make Thread-Safe Calls to Windows Forms Controls | Microsoft Docs","nodes":[{"pos":[0,73],"content":"How to: Make Thread-Safe Calls to Windows Forms Controls | Microsoft Docs","nodes":[{"content":"How to: Make Thread-Safe Calls to Windows Forms Controls | Microsoft Docs","pos":[0,73]}]}],"pos":[6,82],"yaml":true}],"content":"title: \"How to: Make Thread-Safe Calls to Windows Forms Controls | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-winforms\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"EHInvalidOperation.WinForms.IllegalCrossThreadCall\"\ndev_langs: \n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"thread safety, calling controls [Windows Forms]\"\n  - \"calling controls, thread safety [Windows Forms]\"\n  - \"CheckForIllegalCrossThreadCalls property [Windows Forms]\"\n  - \"Windows Forms controls, multithreading\"\n  - \"BackgroundWorker class, examples\"\n  - \"threading [Windows Forms], cross-thread calls\"\n  - \"controls [Windows Forms], multithreading\"\nms.assetid: 138f38b6-1099-4fd5-910c-390b41cbad35\ncaps.latest.revision: 20\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","yamlblock":true},{"pos":[870,926],"content":"How to: Make Thread-Safe Calls to Windows Forms Controls","linkify":"How to: Make Thread-Safe Calls to Windows Forms Controls","nodes":[{"content":"How to: Make Thread-Safe Calls to Windows Forms Controls","pos":[0,56]}]},{"content":"If you use multithreading to improve the performance of your Windows Forms applications, you must make sure that you make calls to your controls in a thread-safe way.","pos":[927,1093]},{"content":"Access to Windows Forms controls is not inherently thread safe.","pos":[1100,1163]},{"content":"If you have two or more threads manipulating the state of a control, it is possible to force the control into an inconsistent state.","pos":[1164,1296]},{"content":"Other thread-related bugs are possible, such as race conditions and deadlocks.","pos":[1297,1375]},{"content":"It is important to make sure that access to your controls is performed in a thread-safe way.","pos":[1376,1468]},{"content":"It is unsafe to call a control from a thread other than the one that created the control without using the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> method.","pos":[1475,1635],"source":"It is unsafe to call a control from a thread other than the one that created the control without using the <xref:System.Windows.Forms.Control.Invoke%2A> method."},{"content":"The following is an example of a call that is not thread safe.","pos":[1636,1698]},{"content":"The <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> helps you detect when you are accessing your controls in a manner that is not thread safe.","pos":[3418,3576],"source":"The [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] helps you detect when you are accessing your controls in a manner that is not thread safe."},{"content":"When you are running your application in the debugger, and a thread other than the one which created a control tries to call that control, the debugger raises an <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> with the message, \"Control <bpt id=\"p1\">*</bpt>control name<ept id=\"p1\">*</ept> accessed from a thread other than the thread it was created on.\"","pos":[3577,3885],"source":" When you are running your application in the debugger, and a thread other than the one which created a control tries to call that control, the debugger raises an <xref:System.InvalidOperationException> with the message, \"Control *control name* accessed from a thread other than the thread it was created on.\""},{"content":"This exception occurs reliably during debugging and, under some circumstances, at run time.","pos":[3892,3983]},{"content":"You might see this exception when you debug applications that you wrote with the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> prior to the <ph id=\"ph2\">[!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]</ph>.","pos":[3984,4202],"source":" You might see this exception when you debug applications that you wrote with the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] prior to the [!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]."},{"content":"You are strongly advised to fix this problem when you see it, but you can disable it by setting the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A&gt;</ph> property to <ph id=\"ph2\">`false`</ph>.","pos":[4203,4394],"source":" You are strongly advised to fix this problem when you see it, but you can disable it by setting the <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> property to `false`."},{"content":"This causes your control to run like it would run under Visual Studio .NET 2003 and the <ph id=\"ph1\">[!INCLUDE[net_v11_short](../../../../includes/net-v11-short-md.md)]</ph>.","pos":[4395,4551],"source":" This causes your control to run like it would run under Visual Studio .NET 2003 and the [!INCLUDE[net_v11_short](../../../../includes/net-v11-short-md.md)]."},{"pos":[4559,5207],"content":"[!NOTE]\n If you are using ActiveX controls on a form, you may receive the cross-thread <xref:System.InvalidOperationException> when you run under the debugger. When this occurs, the ActiveX control does not support multithreading. For more information about using ActiveX controls with Windows Forms, see [Windows Forms and Unmanaged Applications](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md). If you are using Visual Studio, you can prevent this exception by disabling the Visual Studio hosting process, see [How to: Disable the Hosting Process](/visualstudio/ide/how-to-disable-the-hosting-process).","leadings":["","> "],"nodes":[{"content":"If you are using ActiveX controls on a form, you may receive the cross-thread <xref:System.InvalidOperationException> when you run under the debugger. When this occurs, the ActiveX control does not support multithreading. For more information about using ActiveX controls with Windows Forms, see [Windows Forms and Unmanaged Applications](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md). If you are using Visual Studio, you can prevent this exception by disabling the Visual Studio hosting process, see [How to: Disable the Hosting Process](/visualstudio/ide/how-to-disable-the-hosting-process).","pos":[9,646],"nodes":[{"content":"If you are using ActiveX controls on a form, you may receive the cross-thread <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> when you run under the debugger.","pos":[0,150],"source":"If you are using ActiveX controls on a form, you may receive the cross-thread <xref:System.InvalidOperationException> when you run under the debugger."},{"content":"When this occurs, the ActiveX control does not support multithreading.","pos":[151,221]},{"content":"For more information about using ActiveX controls with Windows Forms, see <bpt id=\"p1\">[</bpt>Windows Forms and Unmanaged Applications<ept id=\"p1\">](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md)</ept>.","pos":[222,429],"source":" For more information about using ActiveX controls with Windows Forms, see [Windows Forms and Unmanaged Applications](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md)."},{"content":"If you are using Visual Studio, you can prevent this exception by disabling the Visual Studio hosting process, see <bpt id=\"p1\">[</bpt>How to: Disable the Hosting Process<ept id=\"p1\">](/visualstudio/ide/how-to-disable-the-hosting-process)</ept>.","pos":[430,637],"source":" If you are using Visual Studio, you can prevent this exception by disabling the Visual Studio hosting process, see [How to: Disable the Hosting Process](/visualstudio/ide/how-to-disable-the-hosting-process)."}]}]},{"pos":[5216,5266],"content":"Making Thread-Safe Calls to Windows Forms Controls","linkify":"Making Thread-Safe Calls to Windows Forms Controls","nodes":[{"content":"Making Thread-Safe Calls to Windows Forms Controls","pos":[0,50]}]},{"pos":[5277,5330],"content":"To make a thread-safe call to a Windows Forms control","linkify":"To make a thread-safe call to a Windows Forms control","nodes":[{"content":"To make a thread-safe call to a Windows Forms control","pos":[0,53]}]},{"content":"Query the control's <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A&gt;</ph> property.","pos":[5340,5423],"source":"Query the control's <xref:System.Windows.Forms.Control.InvokeRequired%2A> property."},{"pos":[5433,5615],"content":"If <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A&gt;</ph> returns <ph id=\"ph2\">`true`</ph>, call <ph id=\"ph3\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> with a delegate that makes the actual call to the control.","source":"If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `true`, call <xref:System.Windows.Forms.Control.Invoke%2A> with a delegate that makes the actual call to the control."},{"pos":[5625,5725],"content":"If <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A&gt;</ph> returns <ph id=\"ph2\">`false`</ph>, call the control directly.","source":"If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `false`, call the control directly."},{"content":"In the following code example, a thread-safe call is implemented in the <ph id=\"ph1\">`ThreadProcSafe`</ph> method, which is executed by the background thread.","pos":[5732,5872],"source":"In the following code example, a thread-safe call is implemented in the `ThreadProcSafe` method, which is executed by the background thread."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> control's <ph id=\"ph2\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A&gt;</ph> returns <ph id=\"ph3\">`true`</ph>, the <ph id=\"ph4\">`ThreadProcSafe`</ph> method creates an instance of <ph id=\"ph5\">`StringArgReturningVoidDelegate`</ph> and passes that to the form's <ph id=\"ph6\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> method.","pos":[5873,6163],"source":" If the <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `true`, the `ThreadProcSafe` method creates an instance of `StringArgReturningVoidDelegate` and passes that to the form's <xref:System.Windows.Forms.Control.Invoke%2A> method."},{"content":"This causes the <ph id=\"ph1\">`SetText`</ph> method to be called on the thread that created the <ph id=\"ph2\">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> control, and in this thread context the <ph id=\"ph3\">&lt;xref:System.Windows.Forms.Control.Text%2A&gt;</ph> property is set directly.","pos":[6164,6386],"source":" This causes the `SetText` method to be called on the thread that created the <xref:System.Windows.Forms.TextBox> control, and in this thread context the <xref:System.Windows.Forms.Control.Text%2A> property is set directly."},{"pos":[11660,11710],"content":"Making Thread-Safe Calls by using BackgroundWorker","linkify":"Making Thread-Safe Calls by using BackgroundWorker","nodes":[{"content":"Making Thread-Safe Calls by using BackgroundWorker","pos":[0,50]}]},{"content":"The preferred way to implement multithreading in your application is to use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> component.","pos":[11714,11850],"source":"The preferred way to implement multithreading in your application is to use the <xref:System.ComponentModel.BackgroundWorker> component."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> component uses an event-driven model for multithreading.","pos":[11851,11957],"source":" The <xref:System.ComponentModel.BackgroundWorker> component uses an event-driven model for multithreading."},{"content":"The background thread runs your <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.DoWork&gt;</ph> event handler, and the thread that creates your controls runs your <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker.ProgressChanged&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted&gt;</ph> event handlers.","pos":[11958,12256],"source":" The background thread runs your <xref:System.ComponentModel.BackgroundWorker.DoWork> event handler, and the thread that creates your controls runs your <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> and <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handlers."},{"content":"You can call your controls from your <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.ProgressChanged&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted&gt;</ph> event handlers.","pos":[12257,12440],"source":" You can call your controls from your <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> and <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handlers."},{"pos":[12451,12502],"content":"To make thread-safe calls by using BackgroundWorker","linkify":"To make thread-safe calls by using BackgroundWorker","nodes":[{"content":"To make thread-safe calls by using BackgroundWorker","pos":[0,51]}]},{"content":"Create a method to do the work that you want done in the background thread.","pos":[12512,12587]},{"content":"Do not call controls created by the main thread in this method.","pos":[12588,12651]},{"content":"Create a method to report the results of your background work after it finishes.","pos":[12661,12741]},{"content":"You can call controls created by the main thread in this method.","pos":[12742,12806]},{"content":"Bind the method created in step 1 to the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.DoWork&gt;</ph> event of an instance of <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>, and bind the method created in step 2 to the same instance’s <ph id=\"ph3\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted&gt;</ph> event.","pos":[12816,13113],"source":"Bind the method created in step 1 to the <xref:System.ComponentModel.BackgroundWorker.DoWork> event of an instance of <xref:System.ComponentModel.BackgroundWorker>, and bind the method created in step 2 to the same instance’s <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event."},{"content":"To start the background thread, call the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> instance.","pos":[13123,13297],"source":"To start the background thread, call the <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> method of the <xref:System.ComponentModel.BackgroundWorker> instance."},{"content":"In the following code example, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.DoWork&gt;</ph> event handler uses <ph id=\"ph2\">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> to simulate work that takes some time.","pos":[13304,13489],"source":"In the following code example, the <xref:System.ComponentModel.BackgroundWorker.DoWork> event handler uses <xref:System.Threading.Thread.Sleep%2A> to simulate work that takes some time."},{"content":"It does not call the form’s <ph id=\"ph1\">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> control.","pos":[13490,13562],"source":" It does not call the form’s <xref:System.Windows.Forms.TextBox> control."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> control's <ph id=\"ph2\">&lt;xref:System.Windows.Forms.Control.Text%2A&gt;</ph> property is set directly in the <ph id=\"ph3\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted&gt;</ph> event handler.","pos":[13563,13768],"source":" The <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.Control.Text%2A> property is set directly in the <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handler."},{"content":"You can also report the progress of a background task by using the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.ProgressChanged&gt;</ph> event.","pos":[17099,17234],"source":"You can also report the progress of a background task by using the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> event."},{"content":"For an example that incorporates that event, see <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>.","pos":[17235,17330],"source":" For an example that incorporates that event, see <xref:System.ComponentModel.BackgroundWorker>."},{"pos":[17339,17346],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following code example is a complete Windows Forms application that consists of a form with three buttons and one text box.","pos":[17350,17477]},{"content":"The first button demonstrates unsafe cross-thread access, the second button demonstrates safe access by using <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph>, and the third button demonstrates safe access by using <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>.","pos":[17478,17736],"source":" The first button demonstrates unsafe cross-thread access, the second button demonstrates safe access by using <xref:System.Windows.Forms.Control.Invoke%2A>, and the third button demonstrates safe access by using <xref:System.ComponentModel.BackgroundWorker>."},{"pos":[17744,18049],"content":"[!NOTE]\n For instructions on how to run the example, see [How to: Compile and Run a Complete Windows Forms Code Example Using Visual Studio](http://msdn.microsoft.com/en-us/cc447f7e-4c3b-4397-9d05-aeba3ca49416). This example requires references to the System.Drawing and System.Windows.Forms assemblies.","leadings":["","> "],"nodes":[{"content":"For instructions on how to run the example, see [How to: Compile and Run a Complete Windows Forms Code Example Using Visual Studio](http://msdn.microsoft.com/en-us/cc447f7e-4c3b-4397-9d05-aeba3ca49416). This example requires references to the System.Drawing and System.Windows.Forms assemblies.","pos":[9,303],"nodes":[{"content":"For instructions on how to run the example, see <bpt id=\"p1\">[</bpt>How to: Compile and Run a Complete Windows Forms Code Example Using Visual Studio<ept id=\"p1\">](http://msdn.microsoft.com/en-us/cc447f7e-4c3b-4397-9d05-aeba3ca49416)</ept>.","pos":[0,202],"source":"For instructions on how to run the example, see [How to: Compile and Run a Complete Windows Forms Code Example Using Visual Studio](http://msdn.microsoft.com/en-us/cc447f7e-4c3b-4397-9d05-aeba3ca49416)."},{"content":"This example requires references to the System.Drawing and System.Windows.Forms assemblies.","pos":[203,294]}]}]},{"content":"When you run the application and click the <bpt id=\"p1\">**</bpt>Unsafe Call<ept id=\"p1\">**</ept> button, you immediately see \"Written by the main thread\" in the text box.","pos":[41031,41163],"source":"When you run the application and click the **Unsafe Call** button, you immediately see \"Written by the main thread\" in the text box."},{"content":"Two seconds later, when the unsafe call is attempted, the Visual Studio debugger indicates that an exception occurred.","pos":[41164,41282]},{"content":"The debugger stops at the line in the background thread that attempted to write directly to the text box.","pos":[41283,41388]},{"content":"You will have to restart the application to test the other two buttons.","pos":[41389,41460]},{"content":"When you click the <bpt id=\"p1\">**</bpt>Safe Call<ept id=\"p1\">**</ept> button, \"Written by the main thread\" appears in the text box.","pos":[41461,41555],"source":" When you click the **Safe Call** button, \"Written by the main thread\" appears in the text box."},{"content":"Two seconds later, the text box is set to \"Written by the background thread (Invoke)\", which indicates that the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> method was called.","pos":[41556,41732],"source":" Two seconds later, the text box is set to \"Written by the background thread (Invoke)\", which indicates that the <xref:System.Windows.Forms.Control.Invoke%2A> method was called."},{"content":"When you click the <bpt id=\"p1\">**</bpt>Safe BW Call<ept id=\"p1\">**</ept> button, \"Written by the main thread\" appears in the text box.","pos":[41733,41830],"source":" When you click the **Safe BW Call** button, \"Written by the main thread\" appears in the text box."},{"content":"Two seconds later, the text box is set to \"Written by the main thread after the background thread completed\", which indicates that the handler for the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted&gt;</ph> event of <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> was called.","pos":[41831,42113],"source":" Two seconds later, the text box is set to \"Written by the main thread after the background thread completed\", which indicates that the handler for the <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event of <xref:System.ComponentModel.BackgroundWorker> was called."},{"pos":[42122,42140],"content":"Robust Programming","linkify":"Robust Programming","nodes":[{"content":"Robust Programming","pos":[0,18]}]},{"pos":[42148,42455],"content":"[!CAUTION]\n When you use multithreading of any sort, your code can be exposed to very serious and complex bugs. For more information, see [Managed Threading Best Practices](../../../../docs/standard/threading/managed-threading-best-practices.md) before you implement any solution that uses multithreading.","leadings":["","> "],"nodes":[{"content":"When you use multithreading of any sort, your code can be exposed to very serious and complex bugs. For more information, see [Managed Threading Best Practices](../../../../docs/standard/threading/managed-threading-best-practices.md) before you implement any solution that uses multithreading.","pos":[12,305],"nodes":[{"content":"When you use multithreading of any sort, your code can be exposed to very serious and complex bugs.","pos":[0,99]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Managed Threading Best Practices<ept id=\"p1\">](../../../../docs/standard/threading/managed-threading-best-practices.md)</ept> before you implement any solution that uses multithreading.","pos":[100,293],"source":" For more information, see [Managed Threading Best Practices](../../../../docs/standard/threading/managed-threading-best-practices.md) before you implement any solution that uses multithreading."}]}]},{"pos":[42464,42472],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>","pos":[42476,42521],"source":"<xref:System.ComponentModel.BackgroundWorker> "},{"content":"<bpt id=\"p1\">[</bpt>How to: Run an Operation in the Background<ept id=\"p1\">](../../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)</ept><ph id=\"ph1\"> </ph>","pos":[42526,42662],"source":"[How to: Run an Operation in the Background](../../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Implement a Form That Uses a Background Operation<ept id=\"p1\">](../../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md)</ept><ph id=\"ph1\"> </ph>","pos":[42666,42832],"source":"[How to: Implement a Form That Uses a Background Operation](../../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md) "},{"content":"<bpt id=\"p1\">[</bpt>Developing Custom Windows Forms Controls with the .NET Framework<ept id=\"p1\">](../../../../docs/framework/winforms/controls/developing-custom-windows-forms-controls.md)</ept><ph id=\"ph1\"> </ph>","pos":[42836,42993],"source":"[Developing Custom Windows Forms Controls with the .NET Framework](../../../../docs/framework/winforms/controls/developing-custom-windows-forms-controls.md) "},{"content":"<bpt id=\"p1\">[</bpt>Windows Forms and Unmanaged Applications<ept id=\"p1\">](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md)</ept>","pos":[42997,43129],"source":"[Windows Forms and Unmanaged Applications](../../../../docs/framework/winforms/advanced/windows-forms-and-unmanaged-applications.md)"}]}