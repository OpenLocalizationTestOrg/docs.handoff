<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="logical-and-bitwise-operators.md" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">851a9485e7c8310aba51bf32f4174903ef819466</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\operators-and-expressions\logical-and-bitwise-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">62fe900ca274d9cbaab465a7c8b3fcf8f33b1873</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">74f8c2cda5511f50abbed0d258dafd7da409836b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Logical and Bitwise Operators in Visual Basic | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Logical and Bitwise Operators in Visual Basic</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Logical operators compare <ph id="ph1">`Boolean`</ph> expressions and return a <ph id="ph2">`Boolean`</ph> result.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`And`</ph>, <ph id="ph2">`Or`</ph>, <ph id="ph3">`AndAlso`</ph>, <ph id="ph4">`OrElse`</ph>, and <ph id="ph5">`Xor`</ph> operators are <bpt id="p1">*</bpt>binary<ept id="p1">*</ept> because they take two operands, while the <ph id="ph6">`Not`</ph> operator is <bpt id="p2">*</bpt>unary<ept id="p2">*</ept> because it takes a single operand.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Some of these operators can also perform bitwise logical operations on integral values.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Unary Logical Operator</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Not Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/not-operator.md)</ept> performs logical <bpt id="p2">*</bpt>negation<ept id="p2">*</ept> on a <ph id="ph1">`Boolean`</ph> expression.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It yields the logical opposite of its operand.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to <ph id="ph1">`True`</ph>, then <ph id="ph2">`Not`</ph> returns <ph id="ph3">`False`</ph>; if the expression evaluates to <ph id="ph4">`False`</ph>, then <ph id="ph5">`Not`</ph> returns <ph id="ph6">`True`</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Binary Logical Operators</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>And Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/and-operator.md)</ept> performs logical <bpt id="p2">*</bpt>conjunction<ept id="p2">*</ept> on two <ph id="ph1">`Boolean`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If both expressions evaluate to <ph id="ph1">`True`</ph>, then <ph id="ph2">`And`</ph> returns <ph id="ph3">`True`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If at least one of the expressions evaluates to <ph id="ph1">`False`</ph>, then <ph id="ph2">`And`</ph> returns <ph id="ph3">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Or Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/or-operator.md)</ept> performs logical <bpt id="p2">*</bpt>disjunction<ept id="p2">*</ept> or <bpt id="p3">*</bpt>inclusion<ept id="p3">*</ept> on two <ph id="ph1">`Boolean`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If either expression evaluates to <ph id="ph1">`True`</ph>, or both evaluate to <ph id="ph2">`True`</ph>, then <ph id="ph3">`Or`</ph> returns <ph id="ph4">`True`</ph>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If neither expression evaluates to <ph id="ph1">`True`</ph>, <ph id="ph2">`Or`</ph> returns <ph id="ph3">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Xor Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/xor-operator.md)</ept> performs logical <bpt id="p2">*</bpt>exclusion<ept id="p2">*</ept> on two <ph id="ph1">`Boolean`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If exactly one expression evaluates to <ph id="ph1">`True`</ph>, but not both, <ph id="ph2">`Xor`</ph> returns <ph id="ph3">`True`</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If both expressions evaluate to <ph id="ph1">`True`</ph> or both evaluate to <ph id="ph2">`False`</ph>, <ph id="ph3">`Xor`</ph> returns <ph id="ph4">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following example illustrates the <ph id="ph1">`And`</ph>, <ph id="ph2">`Or`</ph>, and <ph id="ph3">`Xor`</ph> operators.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Short-Circuiting Logical Operations</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>AndAlso Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/andalso-operator.md)</ept> is very similar to the <ph id="ph1">`And`</ph> operator, in that it also performs logical conjunction on two <ph id="ph2">`Boolean`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The key difference between the two is that <ph id="ph1">`AndAlso`</ph> exhibits <bpt id="p1">*</bpt>short-circuiting<ept id="p1">*</ept> behavior.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If the first expression in an <ph id="ph1">`AndAlso`</ph> expression evaluates to <ph id="ph2">`False`</ph>, then the second expression is not evaluated because it cannot alter the final result, and <ph id="ph3">`AndAlso`</ph> returns <ph id="ph4">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Similarly, the <bpt id="p1">[</bpt>OrElse Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/orelse-operator.md)</ept> performs short-circuiting logical disjunction on two <ph id="ph1">`Boolean`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If the first expression in an <ph id="ph1">`OrElse`</ph> expression evaluates to <ph id="ph2">`True`</ph>, then the second expression is not evaluated because it cannot alter the final result, and <ph id="ph3">`OrElse`</ph> returns <ph id="ph4">`True`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Short-Circuiting Trade-Offs</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Short-circuiting can improve performance by not evaluating an expression that cannot alter the result of the logical operation.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, if that expression performs additional actions, short-circuiting skips those actions.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, if the expression includes a call to a <ph id="ph1">`Function`</ph> procedure, that procedure is not called if the expression is short-circuited, and any additional code contained in the <ph id="ph2">`Function`</ph> does not run.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Therefore, the function might run only occasionally, and might not be tested correctly.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Or the program logic might depend on the code in the <ph id="ph1">`Function`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between <ph id="ph1">`And`</ph>, <ph id="ph2">`Or`</ph>, and their short-circuiting counterparts.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In the preceding example, note that some important code inside <ph id="ph1">`checkIfValid()`</ph> does not run when the call is short-circuited.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">`If`</ph> statement calls <ph id="ph2">`checkIfValid()`</ph> even though <ph id="ph3">`12 &gt; 45`</ph> returns <ph id="ph4">`False`</ph>, because <ph id="ph5">`And`</ph> does not short-circuit.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">`If`</ph> statement does not call <ph id="ph2">`checkIfValid()`</ph>, because when <ph id="ph3">`12 &gt; 45`</ph> returns <ph id="ph4">`False`</ph>, <ph id="ph5">`AndAlso`</ph> short-circuits the second expression.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The third <ph id="ph1">`If`</ph> statement calls <ph id="ph2">`checkIfValid()`</ph> even though <ph id="ph3">`12 &lt; 45`</ph> returns <ph id="ph4">`True`</ph>, because <ph id="ph5">`Or`</ph> does not short-circuit.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The fourth <ph id="ph1">`If`</ph> statement does not call <ph id="ph2">`checkIfValid()`</ph>, because when <ph id="ph3">`12 &lt; 45`</ph> returns <ph id="ph4">`True`</ph>, <ph id="ph5">`OrElse`</ph> short-circuits the second expression.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Bitwise Operations</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Bitwise operations evaluate two integral values in binary (base 2) form.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>They compare the bits at corresponding positions and then assign values based on the comparison.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following example illustrates the <ph id="ph1">`And`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The preceding example sets the value of <ph id="ph1">`x`</ph> to 1.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This happens for the following reasons:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The values are treated as binary:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>3 in binary form = 011</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>5 in binary form = 101</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`And`</ph> operator compares the binary representations, one binary position (bit) at a time.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If both bits at a given position are 1, then a 1 is placed in that position in the result.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If either bit is 0, then a 0 is placed in that position in the result.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In the preceding example this works out as follows:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>011 (3 in binary form)</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>101 (5 in binary form)</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>001 (The result, in binary form)</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The result is treated as decimal.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The value 001 is the binary representation of 1, so <ph id="ph1">`x`</ph> = 1.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The bitwise <ph id="ph1">`Or`</ph> operation is similar, except that a 1 is assigned to the result bit if either or both of the compared bits is 1.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Xor`</ph> assigns a 1 to the result bit if exactly one of the compared bits (not both) is 1.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Not`</ph> takes a single operand and inverts all the bits, including the sign bit, and assigns that value to the result.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This means that for signed positive numbers, <ph id="ph1">`Not`</ph> always returns a negative value, and for negative numbers, <ph id="ph2">`Not`</ph> always returns a positive or zero value.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`AndAlso`</ph> and <ph id="ph2">`OrElse`</ph> operators do not support bitwise operations.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Bitwise operations can be performed on integral types only.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Floating-point values must be converted to integral types before bitwise operation can proceed.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Logical/Bitwise Operators (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/logical-bitwise-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean Expressions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/boolean-expressions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arithmetic Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/arithmetic-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Comparison Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Concatenation Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Efficient Combination of Operators<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>