{"content":"---\ntitle: \"Collection-Type Dependency Properties\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"properties [WPF], dependency\"\n  - \"properties [WPF], collection-type\"\n  - \"dependency properties [WPF]\"\n  - \"collection-type properties [WPF]\"\nms.assetid: 99f96a42-3ab7-4f64-a16b-2e10d654e97c\n---\n# Collection-Type Dependency Properties\nThis topic provides guidance and suggested patterns for how to implement a dependency property where the type of the property is a collection type.  \n\n<a name=\"implementing\"></a>   \n## Implementing a Collection-Type Dependency Property  \n For a dependency property in general, the implementation pattern that you follow is that you define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property wrapper, where that property is backed by a <xref:System.Windows.DependencyProperty> identifier rather than a field or other construct. You follow this same pattern when you implement a collection-type property. However, a collection-type property introduces some complexity to the pattern whenever the type that is contained within the collection is itself a <xref:System.Windows.DependencyObject> or <xref:System.Windows.Freezable> derived class.  \n  \n<a name=\"initializing\"></a>   \n## Initializing the Collection Beyond the Default Value  \n When you create a dependency property, you do not specify the property default value as the initial field value. Instead, you specify the default value through the dependency property metadata. If your property is a reference type, the default value specified in dependency property metadata is not a default value per instance; instead it is a default value that applies to all instances of the type. Therefore you must be careful to not use the singular static collection defined by the collection property metadata as the working default value for newly created instances of your type. Instead, you must make sure that you deliberately set the collection value to a unique (instance) collection as part of your class constructor logic. Otherwise you will have created an unintentional singleton class.  \n  \n Consider the following example. The following section of the example shows the definition for a class `Aquarium`. The class defines the collection type dependency property `AquariumObjects`, which uses the generic <xref:System.Collections.Generic.List%601> type with a <xref:System.Windows.FrameworkElement> type constraint. In the <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> call for the dependency property, the metadata establishes the default value to be a new generic <xref:System.Collections.Generic.List%601>.  \n  \n [!code-csharp[PropertiesOvwSupport2#CollectionProblemDefinition](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport2/CSharp/page.xaml.cs#collectionproblemdefinition)]\n [!code-vb[PropertiesOvwSupport2#CollectionProblemDefinition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport2/visualbasic/page.xaml.vb#collectionproblemdefinition)]  \n  \n However, if you just left the code as shown, that single list default value is shared for all instances of `Aquarium`. If you ran the following test code, which is intended to show how you would instantiate two separate `Aquarium` instances and add a single different `Fish` to each of them, you would see a surprising result:  \n  \n [!code-csharp[PropertiesOvwSupport#CollectionProblemTestCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemtestcode)]\n [!code-vb[PropertiesOvwSupport#CollectionProblemTestCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemtestcode)]  \n  \n Instead of each collection having a count of one, each collection has a count of two! This is because each `Aquarium` added its `Fish` to the default value collection, which resulted from a single constructor call in the metadata and is therefore shared between all instances. This situation is almost never what you want.  \n  \n To correct this problem, you must reset the collection dependency property value to a unique instance, as part of the class constructor call. Because the property is a read-only dependency property, you use the <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> method to set it, using the <xref:System.Windows.DependencyPropertyKey> that is only accessible within the class.  \n  \n [!code-csharp[PropertiesOvwSupport#CollectionProblemCtor](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemctor)]\n [!code-vb[PropertiesOvwSupport#CollectionProblemCtor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemctor)]  \n  \n Now, if you ran that same test code again, you could see more expected results, where each `Aquarium` supported its own unique collection.  \n  \n There would be a slight variation on this pattern if you chose to have your collection property be read-write. In that case, you could call the public set accessor from the constructor to do the initialization, which would still be calling the nonkey signature of <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> within your set wrapper, using a public <xref:System.Windows.DependencyProperty> identifier.  \n  \n## Reporting Binding Value Changes from Collection Properties  \n A collection property that is itself a dependency property does not automatically report changes to its subproperties. If you are creating bindings into a collection, this can prevent the binding from reporting changes, thus invalidating some data binding scenarios. However, if you use the collection type <xref:System.Windows.FreezableCollection%601> as your collection type, then subproperty changes to contained elements in the collection are properly reported, and binding works as expected.  \n  \n To enable subproperty binding in a dependency object collection, create the collection property as type <xref:System.Windows.FreezableCollection%601>, with a type constraint for that collection to any <xref:System.Windows.DependencyObject> derived class.  \n  \n## See also\n\n- <xref:System.Windows.FreezableCollection%601>\n- [XAML and Custom Classes for WPF](xaml-and-custom-classes-for-wpf.md)\n- [Data Binding Overview](../data/data-binding-overview.md)\n- [Dependency Properties Overview](dependency-properties-overview.md)\n- [Custom Dependency Properties](custom-dependency-properties.md)\n- [Dependency Property Metadata](dependency-property-metadata.md)\n","nodes":[{"pos":[4,325],"embed":true,"restype":"x-metadata","content":"title: \"Collection-Type Dependency Properties\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"properties [WPF], dependency\"\n  - \"properties [WPF], collection-type\"\n  - \"dependency properties [WPF]\"\n  - \"collection-type properties [WPF]\"\nms.assetid: 99f96a42-3ab7-4f64-a16b-2e10d654e97c","nodes":[{"content":"Collection-Type Dependency Properties","nodes":[{"pos":[0,37],"content":"Collection-Type Dependency Properties","nodes":[{"content":"Collection-Type Dependency Properties","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[332,369],"content":"Collection-Type Dependency Properties","linkify":"Collection-Type Dependency Properties","nodes":[{"content":"Collection-Type Dependency Properties","pos":[0,37]}]},{"content":"This topic provides guidance and suggested patterns for how to implement a dependency property where the type of the property is a collection type.","pos":[370,517]},{"pos":[555,605],"content":"Implementing a Collection-Type Dependency Property","linkify":"Implementing a Collection-Type Dependency Property","nodes":[{"content":"Implementing a Collection-Type Dependency Property","pos":[0,50]}]},{"content":"For a dependency property in general, the implementation pattern that you follow is that you define a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> property wrapper, where that property is backed by a <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier rather than a field or other construct.","pos":[609,925],"source":"For a dependency property in general, the implementation pattern that you follow is that you define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property wrapper, where that property is backed by a <xref:System.Windows.DependencyProperty> identifier rather than a field or other construct."},{"content":"You follow this same pattern when you implement a collection-type property.","pos":[926,1001]},{"content":"However, a collection-type property introduces some complexity to the pattern whenever the type that is contained within the collection is itself a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.Freezable&gt;</ph> derived class.","pos":[1002,1238],"source":" However, a collection-type property introduces some complexity to the pattern whenever the type that is contained within the collection is itself a <xref:System.Windows.DependencyObject> or <xref:System.Windows.Freezable> derived class."},{"pos":[1278,1330],"content":"Initializing the Collection Beyond the Default Value","linkify":"Initializing the Collection Beyond the Default Value","nodes":[{"content":"Initializing the Collection Beyond the Default Value","pos":[0,52]}]},{"content":"When you create a dependency property, you do not specify the property default value as the initial field value.","pos":[1334,1446]},{"content":"Instead, you specify the default value through the dependency property metadata.","pos":[1447,1527]},{"content":"If your property is a reference type, the default value specified in dependency property metadata is not a default value per instance; instead it is a default value that applies to all instances of the type.","pos":[1528,1735]},{"content":"Therefore you must be careful to not use the singular static collection defined by the collection property metadata as the working default value for newly created instances of your type.","pos":[1736,1922]},{"content":"Instead, you must make sure that you deliberately set the collection value to a unique (instance) collection as part of your class constructor logic.","pos":[1923,2072]},{"content":"Otherwise you will have created an unintentional singleton class.","pos":[2073,2138]},{"content":"Consider the following example.","pos":[2145,2176]},{"content":"The following section of the example shows the definition for a class <ph id=\"ph1\">`Aquarium`</ph>.","pos":[2177,2258],"source":" The following section of the example shows the definition for a class `Aquarium`."},{"content":"The class defines the collection type dependency property <ph id=\"ph1\">`AquariumObjects`</ph>, which uses the generic <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> type with a <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> type constraint.","pos":[2259,2469],"source":" The class defines the collection type dependency property `AquariumObjects`, which uses the generic <xref:System.Collections.Generic.List%601> type with a <xref:System.Windows.FrameworkElement> type constraint."},{"content":"In the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> call for the dependency property, the metadata establishes the default value to be a new generic <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.","pos":[2470,2748],"source":" In the <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> call for the dependency property, the metadata establishes the default value to be a new generic <xref:System.Collections.Generic.List%601>."},{"content":"However, if you just left the code as shown, that single list default value is shared for all instances of <ph id=\"ph1\">`Aquarium`</ph>.","pos":[3126,3244],"source":"However, if you just left the code as shown, that single list default value is shared for all instances of `Aquarium`."},{"content":"If you ran the following test code, which is intended to show how you would instantiate two separate <ph id=\"ph1\">`Aquarium`</ph> instances and add a single different <ph id=\"ph2\">`Fish`</ph> to each of them, you would see a surprising result:","pos":[3245,3452],"source":" If you ran the following test code, which is intended to show how you would instantiate two separate `Aquarium` instances and add a single different `Fish` to each of them, you would see a surprising result:"},{"content":"Instead of each collection having a count of one, each collection has a count of two!","pos":[3820,3905]},{"content":"This is because each <ph id=\"ph1\">`Aquarium`</ph> added its <ph id=\"ph2\">`Fish`</ph> to the default value collection, which resulted from a single constructor call in the metadata and is therefore shared between all instances.","pos":[3906,4096],"source":" This is because each `Aquarium` added its `Fish` to the default value collection, which resulted from a single constructor call in the metadata and is therefore shared between all instances."},{"content":"This situation is almost never what you want.","pos":[4097,4142]},{"content":"To correct this problem, you must reset the collection dependency property value to a unique instance, as part of the class constructor call.","pos":[4149,4290]},{"content":"Because the property is a read-only dependency property, you use the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> method to set it, using the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> that is only accessible within the class.","pos":[4291,4579],"source":" Because the property is a read-only dependency property, you use the <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> method to set it, using the <xref:System.Windows.DependencyPropertyKey> that is only accessible within the class."},{"pos":[4931,5069],"content":"Now, if you ran that same test code again, you could see more expected results, where each <ph id=\"ph1\">`Aquarium`</ph> supported its own unique collection.","source":"Now, if you ran that same test code again, you could see more expected results, where each `Aquarium` supported its own unique collection."},{"content":"There would be a slight variation on this pattern if you chose to have your collection property be read-write.","pos":[5076,5186]},{"content":"In that case, you could call the public set accessor from the constructor to do the initialization, which would still be calling the nonkey signature of <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29&gt;</ph> within your set wrapper, using a public <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier.","pos":[5187,5535],"source":" In that case, you could call the public set accessor from the constructor to do the initialization, which would still be calling the nonkey signature of <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> within your set wrapper, using a public <xref:System.Windows.DependencyProperty> identifier."},{"pos":[5544,5602],"content":"Reporting Binding Value Changes from Collection Properties","linkify":"Reporting Binding Value Changes from Collection Properties","nodes":[{"content":"Reporting Binding Value Changes from Collection Properties","pos":[0,58]}]},{"content":"A collection property that is itself a dependency property does not automatically report changes to its subproperties.","pos":[5606,5724]},{"content":"If you are creating bindings into a collection, this can prevent the binding from reporting changes, thus invalidating some data binding scenarios.","pos":[5725,5872]},{"content":"However, if you use the collection type <ph id=\"ph1\">&lt;xref:System.Windows.FreezableCollection%601&gt;</ph> as your collection type, then subproperty changes to contained elements in the collection are properly reported, and binding works as expected.","pos":[5873,6102],"source":" However, if you use the collection type <xref:System.Windows.FreezableCollection%601> as your collection type, then subproperty changes to contained elements in the collection are properly reported, and binding works as expected."},{"pos":[6109,6363],"content":"To enable subproperty binding in a dependency object collection, create the collection property as type <ph id=\"ph1\">&lt;xref:System.Windows.FreezableCollection%601&gt;</ph>, with a type constraint for that collection to any <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject&gt;</ph> derived class.","source":"To enable subproperty binding in a dependency object collection, create the collection property as type <xref:System.Windows.FreezableCollection%601>, with a type constraint for that collection to any <xref:System.Windows.DependencyObject> derived class."},{"pos":[6372,6380],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6432,6501],"content":"<bpt id=\"p1\">[</bpt>XAML and Custom Classes for WPF<ept id=\"p1\">](xaml-and-custom-classes-for-wpf.md)</ept>","source":"[XAML and Custom Classes for WPF](xaml-and-custom-classes-for-wpf.md)"},{"pos":[6504,6561],"content":"<bpt id=\"p1\">[</bpt>Data Binding Overview<ept id=\"p1\">](../data/data-binding-overview.md)</ept>","source":"[Data Binding Overview](../data/data-binding-overview.md)"},{"pos":[6564,6631],"content":"<bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](dependency-properties-overview.md)</ept>","source":"[Dependency Properties Overview](dependency-properties-overview.md)"},{"pos":[6634,6697],"content":"<bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](custom-dependency-properties.md)</ept>","source":"[Custom Dependency Properties](custom-dependency-properties.md)"},{"pos":[6700,6763],"content":"<bpt id=\"p1\">[</bpt>Dependency Property Metadata<ept id=\"p1\">](dependency-property-metadata.md)</ept>","source":"[Dependency Property Metadata](dependency-property-metadata.md)"}]}