{"content":"---\ntitle: \"Perform custom join operations\"\ndescription: How to perform custom join operations.\nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nmanager: wpickett\nms.author: wiwagn\nms.date: 12/1/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 56a2a4a5-7299-497d-b3c3-23c848678911\n---\n# Perform custom join operations\n\nThis example shows how to perform join operations that are not possible with the `join` clause. In a query expression, the `join` clause is limited to, and optimized for, equijoins, which are by far the most common type of join operation. When performing an equijoin, you will probably always get the best performance by using the `join` clause.  \n  \n However, the `join` clause cannot be used in the following cases:  \n  \n-   When the join is predicated on an expression of inequality (a non-equijoin).  \n  \n-   When the join is predicated on more than one expression of equality or inequality.  \n  \n-   When you have to introduce a temporary range variable for the right side (inner) sequence before the join operation.  \n  \n To perform joins that are not equijoins, you can use multiple `from` clauses to introduce each data source independently. You then apply a predicate expression in a `where` clause to the range variable for each source. The expression also can take the form of a method call.  \n  \n> [!NOTE]\n>  Do not confuse this kind of custom join operation with the use of multiple `from` clauses to access inner collections. For more information, see [join clause](../language-reference/keywords/join-clause.md).  \n  \n## Example  \n The first method in the following example shows a simple cross join. Cross joins must be used with caution because they can produce very large result sets. However, they can be useful in some scenarios for creating source sequences against which additional queries are run.  \n  \n The second method produces a sequence of all the products whose category ID is listed in the category list on the left side. Note the use of the `let` clause and the `Contains` method to create a temporary array. It also is possible to create the array before the query and eliminate the first `from` clause.  \n  \n [!code-cs[csProgGuideLINQ#64](../../../samples/snippets/csharp/concepts/linq/how-to-perform-custom-join-operations_1.cs)]  \n  \n## Example  \n In the following example, the query must join two sequences based on matching keys that, in the case of the inner (right side) sequence, cannot be obtained prior to the join clause itself. If this join were performed with a `join` clause, then the `Split` method would have to be called for each element. The use of multiple `from` clauses enables the query to avoid the overhead of the repeated method call. However, since `join` is optimized, in this particular case it might still be faster than using multiple `from` clauses. The results will vary depending primarily on how expensive the method call is.  \n  \n [!code-cs[csProgGuideLINQ#13](../../../samples/snippets/csharp/concepts/linq/how-to-perform-custom-join-operations_2.cs)]  \n  \n## See also  \n [LINQ query expressions](index.md)   \n [join clause](../language-reference/keywords/join-clause.md)   \n [Order the results of a join clause](order-the-results-of-a-join-clause.md)","nodes":[{"pos":[4,342],"nodes":[{"content":"Perform custom join operations","nodes":[{"pos":[0,30],"content":"Perform custom join operations","nodes":[{"content":"Perform custom join operations","pos":[0,30]}]}],"pos":[6,39],"yaml":true},{"content":"How to perform custom join operations.","nodes":[{"pos":[0,38],"content":"How to perform custom join operations.","nodes":[{"content":"How to perform custom join operations.","pos":[0,38]}]}],"pos":[52,91],"yaml":true},{"content":".NET, .NET Core, C#","nodes":[{"pos":[0,19],"content":".NET, .NET Core, C#","nodes":[{"content":".NET, .NET Core, C#","pos":[0,19]}]}],"pos":[101,121],"yaml":true}],"content":"title: \"Perform custom join operations\"\ndescription: How to perform custom join operations.\nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nmanager: wpickett\nms.author: wiwagn\nms.date: 12/1/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 56a2a4a5-7299-497d-b3c3-23c848678911","yamlblock":true},{"pos":[349,379],"content":"Perform custom join operations","linkify":"Perform custom join operations","nodes":[{"content":"Perform custom join operations","pos":[0,30]}]},{"content":"This example shows how to perform join operations that are not possible with the <ph id=\"ph1\">`join`</ph> clause.","pos":[381,476],"source":"This example shows how to perform join operations that are not possible with the `join` clause."},{"content":"In a query expression, the <ph id=\"ph1\">`join`</ph> clause is limited to, and optimized for, equijoins, which are by far the most common type of join operation.","pos":[477,619],"source":" In a query expression, the `join` clause is limited to, and optimized for, equijoins, which are by far the most common type of join operation."},{"content":"When performing an equijoin, you will probably always get the best performance by using the <ph id=\"ph1\">`join`</ph> clause.","pos":[620,726],"source":" When performing an equijoin, you will probably always get the best performance by using the `join` clause."},{"pos":[733,798],"content":"However, the <ph id=\"ph1\">`join`</ph> clause cannot be used in the following cases:","source":"However, the `join` clause cannot be used in the following cases:"},{"content":"When the join is predicated on an expression of inequality (a non-equijoin).","pos":[808,884]},{"content":"When the join is predicated on more than one expression of equality or inequality.","pos":[894,976]},{"content":"When you have to introduce a temporary range variable for the right side (inner) sequence before the join operation.","pos":[986,1102]},{"content":"To perform joins that are not equijoins, you can use multiple <ph id=\"ph1\">`from`</ph> clauses to introduce each data source independently.","pos":[1109,1230],"source":"To perform joins that are not equijoins, you can use multiple `from` clauses to introduce each data source independently."},{"content":"You then apply a predicate expression in a <ph id=\"ph1\">`where`</ph> clause to the range variable for each source.","pos":[1231,1327],"source":" You then apply a predicate expression in a `where` clause to the range variable for each source."},{"content":"The expression also can take the form of a method call.","pos":[1328,1383]},{"pos":[1391,1608],"content":"[!NOTE]\n Do not confuse this kind of custom join operation with the use of multiple `from` clauses to access inner collections. For more information, see [join clause](../language-reference/keywords/join-clause.md).","leadings":["","> "],"nodes":[{"content":"Do not confuse this kind of custom join operation with the use of multiple `from` clauses to access inner collections. For more information, see [join clause](../language-reference/keywords/join-clause.md).","pos":[9,215],"nodes":[{"content":"Do not confuse this kind of custom join operation with the use of multiple <ph id=\"ph1\">`from`</ph> clauses to access inner collections.","pos":[0,118],"source":"Do not confuse this kind of custom join operation with the use of multiple `from` clauses to access inner collections."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>join clause<ept id=\"p1\">](../language-reference/keywords/join-clause.md)</ept>.","pos":[119,206],"source":" For more information, see [join clause](../language-reference/keywords/join-clause.md)."}]}]},{"pos":[1617,1624],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The first method in the following example shows a simple cross join.","pos":[1628,1696]},{"content":"Cross joins must be used with caution because they can produce very large result sets.","pos":[1697,1783]},{"content":"However, they can be useful in some scenarios for creating source sequences against which additional queries are run.","pos":[1784,1901]},{"content":"The second method produces a sequence of all the products whose category ID is listed in the category list on the left side.","pos":[1908,2032]},{"content":"Note the use of the <ph id=\"ph1\">`let`</ph> clause and the <ph id=\"ph2\">`Contains`</ph> method to create a temporary array.","pos":[2033,2120],"source":" Note the use of the `let` clause and the `Contains` method to create a temporary array."},{"content":"It also is possible to create the array before the query and eliminate the first <ph id=\"ph1\">`from`</ph> clause.","pos":[2121,2216],"source":" It also is possible to create the array before the query and eliminate the first `from` clause."},{"pos":[2223,2344],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideLINQ#64<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/how-to-perform-custom-join-operations_1.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideLINQ#64](../../../samples/snippets/csharp/concepts/linq/how-to-perform-custom-join-operations_1.cs)]"},{"pos":[2353,2360],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"In the following example, the query must join two sequences based on matching keys that, in the case of the inner (right side) sequence, cannot be obtained prior to the join clause itself.","pos":[2364,2552]},{"content":"If this join were performed with a <ph id=\"ph1\">`join`</ph> clause, then the <ph id=\"ph2\">`Split`</ph> method would have to be called for each element.","pos":[2553,2668],"source":" If this join were performed with a `join` clause, then the `Split` method would have to be called for each element."},{"content":"The use of multiple <ph id=\"ph1\">`from`</ph> clauses enables the query to avoid the overhead of the repeated method call.","pos":[2669,2772],"source":" The use of multiple `from` clauses enables the query to avoid the overhead of the repeated method call."},{"content":"However, since <ph id=\"ph1\">`join`</ph> is optimized, in this particular case it might still be faster than using multiple <ph id=\"ph2\">`from`</ph> clauses.","pos":[2773,2893],"source":" However, since `join` is optimized, in this particular case it might still be faster than using multiple `from` clauses."},{"content":"The results will vary depending primarily on how expensive the method call is.","pos":[2894,2972]},{"pos":[2979,3100],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideLINQ#13<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/how-to-perform-custom-join-operations_2.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideLINQ#13](../../../samples/snippets/csharp/concepts/linq/how-to-perform-custom-join-operations_2.cs)]"},{"pos":[3109,3117],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>LINQ query expressions<ept id=\"p1\">](index.md)</ept><ph id=\"ph1\"> </ph>","pos":[3121,3156],"source":"[LINQ query expressions](index.md) "},{"content":"<bpt id=\"p1\">[</bpt>join clause<ept id=\"p1\">](../language-reference/keywords/join-clause.md)</ept><ph id=\"ph1\"> </ph>","pos":[3160,3221],"source":"[join clause](../language-reference/keywords/join-clause.md) "},{"content":"<bpt id=\"p1\">[</bpt>Order the results of a join clause<ept id=\"p1\">](order-the-results-of-a-join-clause.md)</ept>","pos":[3225,3300],"source":"[Order the results of a join clause](order-the-results-of-a-join-clause.md)"}]}