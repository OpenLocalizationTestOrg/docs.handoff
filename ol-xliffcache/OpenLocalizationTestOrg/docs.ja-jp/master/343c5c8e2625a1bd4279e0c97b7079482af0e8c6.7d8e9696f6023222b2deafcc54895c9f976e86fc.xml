{"content":"---\ntitle: \"Generic Types in Visual Basic (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generic interfaces\"\n  - \"data type arguments [Visual Basic], defining\"\n  - \"generic delegates\"\n  - \"arguments [Visual Basic], data types\"\n  - \"Of keyword [Visual Basic], using\"\n  - \"delegates, generic\"\n  - \"constraints, Visual Basic generic types\"\n  - \"generic parameters\"\n  - \"data type parameters\"\n  - \"procedures [Visual Basic], generic\"\n  - \"generic procedures\"\n  - \"data types [Visual Basic], generic\"\n  - \"data types [Visual Basic], as parameters\"\n  - \"generics [Visual Basic], generic types\"\n  - \"data types [Visual Basic], as arguments\"\n  - \"generic classes [Visual Basic], Visual Basic\"\n  - \"parameters [Visual Basic], type\"\n  - \"type arguments\"\n  - \"interfaces [Visual Basic], generic\"\n  - \"generics [Visual Basic]\"\n  - \"types [Visual Basic], generic\"\n  - \"parameters [Visual Basic], generic\"\n  - \"generic structures [Visual Basic]\"\n  - \"generic classes [Visual Basic]\"\n  - \"type parameters\"\n  - \"data type arguments\"\n  - \"structures [Visual Basic], generic\"\n  - \"parameters [Visual Basic], data type\"\n  - \"collections, generic\"\n  - \"classes [Visual Basic], generic\"\n  - \"data type parameters [Visual Basic], defining\"\n  - \"type arguments [Visual Basic], defining\"\n  - \"arguments [Visual Basic], type\"\nms.assetid: 89f771d9-ecbb-4737-88b8-116b63c6cf4d\n---\n# Generic Types in Visual Basic (Visual Basic)\nA *generic type* is a single programming element that adapts to perform the same functionality for a variety of data types. When you define a generic class or procedure, you do not have to define a separate version for each data type for which you might want to perform that functionality.  \n  \n An analogy is a screwdriver set with removable heads. You inspect the screw you need to turn and select the correct head for that screw (slotted, crossed, starred). Once you insert the correct head in the screwdriver handle, you perform the exact same function with the screwdriver, namely turning the screw.  \n  \n ![Diagram of a screwdriver set with different heads.](./media/generic-types/generic-screwdriver-set.gif)  \n  \n When you define a generic type, you parameterize it with one or more data types. This allows the using code to tailor the data types to its requirements. Your code can declare several different programming elements from the generic element, each one acting on a different set of data types. But the declared elements all perform the identical logic, no matter what data types they are using.  \n  \n For example, you might want to create and use a queue class that operates on a specific data type such as `String`. You can declare such a class from <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>, as the following example shows.  \n  \n [!code-vb[VbVbalrDataTypes#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#1)]  \n  \n You can now use `stringQ` to work exclusively with `String` values. Because `stringQ` is specific for `String` instead of being generalized for `Object` values, you do not have late binding or type conversion. This saves execution time and reduces run-time errors.  \n  \n For more information on using a generic type, see [How to: Use a Generic Class](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md).  \n  \n## Example of a Generic Class  \n The following example shows a skeleton definition of a generic class.  \n  \n [!code-vb[VbVbalrDataTypes#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#2)]  \n  \n In the preceding skeleton, `t` is a *type parameter*, that is, a placeholder for a data type that you supply when you declare the class. Elsewhere in your code, you can declare various versions of `classHolder` by supplying various data types for `t`. The following example shows two such declarations.  \n  \n [!code-vb[VbVbalrDataTypes#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#3)]  \n  \n The preceding statements declare *constructed classes*, in which a specific type replaces the type parameter. This replacement is propagated throughout the code within the constructed class. The following example shows what the `processNewItem` procedure looks like in `integerClass`.  \n  \n [!code-vb[VbVbalrDataTypes#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#4)]  \n  \n For a more complete example, see [How to: Define a Class That Can Provide Identical Functionality on Different Data Types](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md).  \n  \n## Eligible Programming Elements  \n You can define and use generic classes, structures, interfaces, procedures, and delegates. Note that the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] defines several generic classes, structures, and interfaces that represent commonly used generic elements. The <xref:System.Collections.Generic?displayProperty=nameWithType> namespace provides dictionaries, lists, queues, and stacks. Before defining your own generic element, see if it is already available in <xref:System.Collections.Generic?displayProperty=nameWithType>.  \n  \n Procedures are not types, but you can define and use generic procedures. See [Generic Procedures in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md).  \n  \n## Advantages of Generic Types  \n A generic type serves as a basis for declaring several different programming elements, each of which operates on a specific data type. The alternatives to a generic type are:  \n  \n1.  A single type operating on the `Object` data type.  \n  \n2.  A set of *type-specific* versions of the type, each version individually coded and operating on one specific data type such as `String`, `Integer`, or a user-defined type such as `customer`.  \n  \n A generic type has the following advantages over these alternatives:  \n  \n-   **Type Safety.** Generic types enforce compile-time type checking. Types based on `Object` accept any data type, and you must write code to check whether an input data type is acceptable. With generic types, the compiler can catch type mismatches before run time.  \n  \n-   **Performance.** Generic types do not have to *box* and *unbox* data, because each one is specialized for one data type. Operations based on `Object` must box input data types to convert them to `Object` and unbox data destined for output. Boxing and unboxing reduce performance.  \n  \n     Types based on `Object` are also late-bound, which means that accessing their members requires extra code at run time. This also reduces performance.  \n  \n-   **Code Consolidation.** The code in a generic type has to be defined only once. A set of type-specific versions of a type must replicate the same code in each version, with the only difference being the specific data type for that version. With generic types, the type-specific versions are all generated from the original generic type.  \n  \n-   **Code Reuse.** Code that does not depend on a particular data type can be reused with various data types if it is generic. You can often reuse it even with a data type that you did not originally predict.  \n  \n-   **IDE Support.** When you use a constructed type declared from a generic type, the integrated development environment (IDE) can give you more support while you are developing your code. For example, IntelliSense can show you the type-specific options for an argument to a constructor or method.  \n  \n-   **Generic Algorithms.** Abstract algorithms that are type-independent are good candidates for generic types. For example, a generic procedure that sorts items using the <xref:System.IComparable> interface can be used with any data type that implements <xref:System.IComparable>.  \n  \n## Constraints  \n Although the code in a generic type definition should be as type-independent as possible, you might need to require a certain capability of any data type supplied to your generic type. For example, if you want to compare two items for the purpose of sorting or collating, their data type must implement the <xref:System.IComparable> interface. You can enforce this requirement by adding a *constraint* to the type parameter.  \n  \n### Example of a Constraint  \n The following example shows a skeleton definition of a class with a constraint that requires the type argument to implement <xref:System.IComparable>.  \n  \n [!code-vb[VbVbalrDataTypes#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#5)]  \n  \n If subsequent code attempts to construct a class from `itemManager` supplying a type that does not implement <xref:System.IComparable>, the compiler signals an error.  \n  \n### Types of Constraints  \n Your constraint can specify the following requirements in any combination:  \n  \n-   The type argument must implement one or more interfaces  \n  \n-   The type argument must be of the type of, or inherit from, at most one class  \n  \n-   The type argument must expose a parameterless constructor accessible to the code that creates objects from it  \n  \n-   The type argument must be a *reference type*, or it must be a *value type*  \n  \n If you need to impose more than one requirement, you use a comma-separated *constraint list* inside braces (`{ }`). To require an accessible constructor, you include the [New Operator](../../../../visual-basic/language-reference/operators/new-operator.md) keyword in the list. To require a reference type, you include the `Class` keyword; to require a value type, you include the `Structure` keyword.  \n  \n For more information on constraints, see [Type List](../../../../visual-basic/language-reference/statements/type-list.md).  \n  \n### Example of Multiple Constraints  \n The following example shows a skeleton definition of a generic class with a constraint list on the type parameter. In the code that creates an instance of this class, the type argument must implement both the <xref:System.IComparable> and <xref:System.IDisposable> interfaces, be a reference type, and expose an accessible parameterless constructor.  \n  \n [!code-vb[VbVbalrDataTypes#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#6)]  \n  \n## Important Terms  \n Generic types introduce and use the following terms:  \n  \n-   *Generic Type*. A definition of a class, structure, interface, procedure, or delegate for which you supply at least one data type when you declare it.  \n  \n-   *Type Parameter*. In a generic type definition, a placeholder for a data type you supply when you declare the type.  \n  \n-   *Type Argument*. A specific data type that replaces a type parameter when you declare a constructed type from a generic type.  \n  \n-   *Constraint*. A condition on a type parameter that restricts the type argument you can supply for it. A constraint can require that the type argument must implement a particular interface, be or inherit from a particular class, have an accessible parameterless constructor, or be a reference type or a value type. You can combine these constraints, but you can specify at most one class.  \n  \n-   *Constructed Type*. A class, structure, interface, procedure, or delegate declared from a generic type by supplying type arguments for its type parameters.  \n  \n## See also\n\n- [Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md)\n- [Type Characters](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)\n- [Value Types and Reference Types](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)\n- [Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)\n- [Troubleshooting Data Types](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)\n- [Data Types](../../../../visual-basic/language-reference/data-types/index.md)\n- [Of](../../../../visual-basic/language-reference/statements/of-clause.md)\n- [As](../../../../visual-basic/language-reference/statements/as-clause.md)\n- [Object Data Type](../../../../visual-basic/language-reference/data-types/object-data-type.md)\n- [Covariance and Contravariance](../../concepts/covariance-contravariance/index.md)\n- [Iterators](../../../../visual-basic/programming-guide/concepts/iterators.md)\n","nodes":[{"pos":[4,1365],"embed":true,"restype":"x-metadata","content":"title: \"Generic Types in Visual Basic (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generic interfaces\"\n  - \"data type arguments [Visual Basic], defining\"\n  - \"generic delegates\"\n  - \"arguments [Visual Basic], data types\"\n  - \"Of keyword [Visual Basic], using\"\n  - \"delegates, generic\"\n  - \"constraints, Visual Basic generic types\"\n  - \"generic parameters\"\n  - \"data type parameters\"\n  - \"procedures [Visual Basic], generic\"\n  - \"generic procedures\"\n  - \"data types [Visual Basic], generic\"\n  - \"data types [Visual Basic], as parameters\"\n  - \"generics [Visual Basic], generic types\"\n  - \"data types [Visual Basic], as arguments\"\n  - \"generic classes [Visual Basic], Visual Basic\"\n  - \"parameters [Visual Basic], type\"\n  - \"type arguments\"\n  - \"interfaces [Visual Basic], generic\"\n  - \"generics [Visual Basic]\"\n  - \"types [Visual Basic], generic\"\n  - \"parameters [Visual Basic], generic\"\n  - \"generic structures [Visual Basic]\"\n  - \"generic classes [Visual Basic]\"\n  - \"type parameters\"\n  - \"data type arguments\"\n  - \"structures [Visual Basic], generic\"\n  - \"parameters [Visual Basic], data type\"\n  - \"collections, generic\"\n  - \"classes [Visual Basic], generic\"\n  - \"data type parameters [Visual Basic], defining\"\n  - \"type arguments [Visual Basic], defining\"\n  - \"arguments [Visual Basic], type\"\nms.assetid: 89f771d9-ecbb-4737-88b8-116b63c6cf4d","nodes":[{"content":"Generic Types in Visual Basic (Visual Basic)","nodes":[{"pos":[0,44],"content":"Generic Types in Visual Basic (Visual Basic)","nodes":[{"content":"Generic Types in Visual Basic (Visual Basic)","pos":[0,44]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[1372,1416],"content":"Generic Types in Visual Basic (Visual Basic)","linkify":"Generic Types in Visual Basic (Visual Basic)","nodes":[{"content":"Generic Types in Visual Basic (Visual Basic)","pos":[0,44]}]},{"content":"A <bpt id=\"p1\">*</bpt>generic type<ept id=\"p1\">*</ept> is a single programming element that adapts to perform the same functionality for a variety of data types.","pos":[1417,1540],"source":"A *generic type* is a single programming element that adapts to perform the same functionality for a variety of data types."},{"content":"When you define a generic class or procedure, you do not have to define a separate version for each data type for which you might want to perform that functionality.","pos":[1541,1706]},{"content":"An analogy is a screwdriver set with removable heads.","pos":[1713,1766]},{"content":"You inspect the screw you need to turn and select the correct head for that screw (slotted, crossed, starred).","pos":[1767,1877]},{"content":"Once you insert the correct head in the screwdriver handle, you perform the exact same function with the screwdriver, namely turning the screw.","pos":[1878,2021]},{"content":"Diagram of a screwdriver set with different heads.","pos":[2030,2080]},{"content":"When you define a generic type, you parameterize it with one or more data types.","pos":[2139,2219]},{"content":"This allows the using code to tailor the data types to its requirements.","pos":[2220,2292]},{"content":"Your code can declare several different programming elements from the generic element, each one acting on a different set of data types.","pos":[2293,2429]},{"content":"But the declared elements all perform the identical logic, no matter what data types they are using.","pos":[2430,2530]},{"content":"For example, you might want to create and use a queue class that operates on a specific data type such as <ph id=\"ph1\">`String`</ph>.","pos":[2537,2652],"source":"For example, you might want to create and use a queue class that operates on a specific data type such as `String`."},{"content":"You can declare such a class from <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType&gt;</ph>, as the following example shows.","pos":[2653,2792],"source":" You can declare such a class from <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>, as the following example shows."},{"content":"You can now use <ph id=\"ph1\">`stringQ`</ph> to work exclusively with <ph id=\"ph2\">`String`</ph> values.","pos":[2921,2988],"source":"You can now use `stringQ` to work exclusively with `String` values."},{"content":"Because <ph id=\"ph1\">`stringQ`</ph> is specific for <ph id=\"ph2\">`String`</ph> instead of being generalized for <ph id=\"ph3\">`Object`</ph> values, you do not have late binding or type conversion.","pos":[2989,3130],"source":" Because `stringQ` is specific for `String` instead of being generalized for `Object` values, you do not have late binding or type conversion."},{"content":"This saves execution time and reduces run-time errors.","pos":[3131,3185]},{"pos":[3192,3375],"content":"For more information on using a generic type, see <bpt id=\"p1\">[</bpt>How to: Use a Generic Class<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)</ept>.","source":"For more information on using a generic type, see [How to: Use a Generic Class](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)."},{"pos":[3384,3410],"content":"Example of a Generic Class","linkify":"Example of a Generic Class","nodes":[{"content":"Example of a Generic Class","pos":[0,26]}]},{"content":"The following example shows a skeleton definition of a generic class.","pos":[3414,3483]},{"content":"In the preceding skeleton, <ph id=\"ph1\">`t`</ph> is a <bpt id=\"p1\">*</bpt>type parameter<ept id=\"p1\">*</ept>, that is, a placeholder for a data type that you supply when you declare the class.","pos":[3612,3748],"source":"In the preceding skeleton, `t` is a *type parameter*, that is, a placeholder for a data type that you supply when you declare the class."},{"content":"Elsewhere in your code, you can declare various versions of <ph id=\"ph1\">`classHolder`</ph> by supplying various data types for <ph id=\"ph2\">`t`</ph>.","pos":[3749,3863],"source":" Elsewhere in your code, you can declare various versions of `classHolder` by supplying various data types for `t`."},{"content":"The following example shows two such declarations.","pos":[3864,3914]},{"content":"The preceding statements declare <bpt id=\"p1\">*</bpt>constructed classes<ept id=\"p1\">*</ept>, in which a specific type replaces the type parameter.","pos":[4043,4152],"source":"The preceding statements declare *constructed classes*, in which a specific type replaces the type parameter."},{"content":"This replacement is propagated throughout the code within the constructed class.","pos":[4153,4233]},{"content":"The following example shows what the <ph id=\"ph1\">`processNewItem`</ph> procedure looks like in <ph id=\"ph2\">`integerClass`</ph>.","pos":[4234,4327],"source":" The following example shows what the `processNewItem` procedure looks like in `integerClass`."},{"pos":[4456,4718],"content":"For a more complete example, see <bpt id=\"p1\">[</bpt>How to: Define a Class That Can Provide Identical Functionality on Different Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)</ept>.","source":"For a more complete example, see [How to: Define a Class That Can Provide Identical Functionality on Different Data Types](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)."},{"pos":[4727,4756],"content":"Eligible Programming Elements","linkify":"Eligible Programming Elements","nodes":[{"content":"Eligible Programming Elements","pos":[0,29]}]},{"content":"You can define and use generic classes, structures, interfaces, procedures, and delegates.","pos":[4760,4850]},{"content":"Note that the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> defines several generic classes, structures, and interfaces that represent commonly used generic elements.","pos":[4851,5025],"source":" Note that the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] defines several generic classes, structures, and interfaces that represent commonly used generic elements."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace provides dictionaries, lists, queues, and stacks.","pos":[5026,5152],"source":" The <xref:System.Collections.Generic?displayProperty=nameWithType> namespace provides dictionaries, lists, queues, and stacks."},{"content":"Before defining your own generic element, see if it is already available in <ph id=\"ph1\">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph>.","pos":[5153,5292],"source":" Before defining your own generic element, see if it is already available in <xref:System.Collections.Generic?displayProperty=nameWithType>."},{"content":"Procedures are not types, but you can define and use generic procedures.","pos":[5299,5371]},{"content":"See <bpt id=\"p1\">[</bpt>Generic Procedures in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md)</ept>.","pos":[5372,5508],"source":" See [Generic Procedures in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md)."},{"pos":[5517,5544],"content":"Advantages of Generic Types","linkify":"Advantages of Generic Types","nodes":[{"content":"Advantages of Generic Types","pos":[0,27]}]},{"content":"A generic type serves as a basis for declaring several different programming elements, each of which operates on a specific data type.","pos":[5548,5682]},{"content":"The alternatives to a generic type are:","pos":[5683,5722]},{"pos":[5732,5782],"content":"A single type operating on the <ph id=\"ph1\">`Object`</ph> data type.","source":"A single type operating on the `Object` data type."},{"pos":[5792,5982],"content":"A set of <bpt id=\"p1\">*</bpt>type-specific<ept id=\"p1\">*</ept> versions of the type, each version individually coded and operating on one specific data type such as <ph id=\"ph1\">`String`</ph>, <ph id=\"ph2\">`Integer`</ph>, or a user-defined type such as <ph id=\"ph3\">`customer`</ph>.","source":"A set of *type-specific* versions of the type, each version individually coded and operating on one specific data type such as `String`, `Integer`, or a user-defined type such as `customer`."},{"content":"A generic type has the following advantages over these alternatives:","pos":[5989,6057]},{"content":"<bpt id=\"p1\">**</bpt>Type Safety.<ept id=\"p1\">**</ept>","pos":[6067,6083],"source":"**Type Safety.**"},{"content":"Generic types enforce compile-time type checking.","pos":[6084,6133]},{"content":"Types based on <ph id=\"ph1\">`Object`</ph> accept any data type, and you must write code to check whether an input data type is acceptable.","pos":[6134,6254],"source":" Types based on `Object` accept any data type, and you must write code to check whether an input data type is acceptable."},{"content":"With generic types, the compiler can catch type mismatches before run time.","pos":[6255,6330]},{"content":"<bpt id=\"p1\">**</bpt>Performance.<ept id=\"p1\">**</ept>","pos":[6340,6356],"source":"**Performance.**"},{"content":"Generic types do not have to <bpt id=\"p1\">*</bpt>box<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>unbox<ept id=\"p2\">*</ept> data, because each one is specialized for one data type.","pos":[6357,6460],"source":" Generic types do not have to *box* and *unbox* data, because each one is specialized for one data type."},{"content":"Operations based on <ph id=\"ph1\">`Object`</ph> must box input data types to convert them to <ph id=\"ph2\">`Object`</ph> and unbox data destined for output.","pos":[6461,6579],"source":" Operations based on `Object` must box input data types to convert them to `Object` and unbox data destined for output."},{"content":"Boxing and unboxing reduce performance.","pos":[6580,6619]},{"content":"Types based on <ph id=\"ph1\">`Object`</ph> are also late-bound, which means that accessing their members requires extra code at run time.","pos":[6630,6748],"source":"Types based on `Object` are also late-bound, which means that accessing their members requires extra code at run time."},{"content":"This also reduces performance.","pos":[6749,6779]},{"content":"<bpt id=\"p1\">**</bpt>Code Consolidation.<ept id=\"p1\">**</ept>","pos":[6789,6812],"source":"**Code Consolidation.**"},{"content":"The code in a generic type has to be defined only once.","pos":[6813,6868]},{"content":"A set of type-specific versions of a type must replicate the same code in each version, with the only difference being the specific data type for that version.","pos":[6869,7028]},{"content":"With generic types, the type-specific versions are all generated from the original generic type.","pos":[7029,7125]},{"content":"<bpt id=\"p1\">**</bpt>Code Reuse.<ept id=\"p1\">**</ept>","pos":[7135,7150],"source":"**Code Reuse.**"},{"content":"Code that does not depend on a particular data type can be reused with various data types if it is generic.","pos":[7151,7258]},{"content":"You can often reuse it even with a data type that you did not originally predict.","pos":[7259,7340]},{"content":"<bpt id=\"p1\">**</bpt>IDE Support.<ept id=\"p1\">**</ept>","pos":[7350,7366],"source":"**IDE Support.**"},{"content":"When you use a constructed type declared from a generic type, the integrated development environment (IDE) can give you more support while you are developing your code.","pos":[7367,7535]},{"content":"For example, IntelliSense can show you the type-specific options for an argument to a constructor or method.","pos":[7536,7644]},{"content":"<bpt id=\"p1\">**</bpt>Generic Algorithms.<ept id=\"p1\">**</ept>","pos":[7654,7677],"source":"**Generic Algorithms.**"},{"content":"Abstract algorithms that are type-independent are good candidates for generic types.","pos":[7678,7762]},{"content":"For example, a generic procedure that sorts items using the <ph id=\"ph1\">&lt;xref:System.IComparable&gt;</ph> interface can be used with any data type that implements <ph id=\"ph2\">&lt;xref:System.IComparable&gt;</ph>.","pos":[7763,7932],"source":" For example, a generic procedure that sorts items using the <xref:System.IComparable> interface can be used with any data type that implements <xref:System.IComparable>."},{"pos":[7941,7952],"content":"Constraints","linkify":"Constraints","nodes":[{"content":"Constraints","pos":[0,11]}]},{"content":"Although the code in a generic type definition should be as type-independent as possible, you might need to require a certain capability of any data type supplied to your generic type.","pos":[7956,8140]},{"content":"For example, if you want to compare two items for the purpose of sorting or collating, their data type must implement the <ph id=\"ph1\">&lt;xref:System.IComparable&gt;</ph> interface.","pos":[8141,8299],"source":" For example, if you want to compare two items for the purpose of sorting or collating, their data type must implement the <xref:System.IComparable> interface."},{"content":"You can enforce this requirement by adding a <bpt id=\"p1\">*</bpt>constraint<ept id=\"p1\">*</ept> to the type parameter.","pos":[8300,8380],"source":" You can enforce this requirement by adding a *constraint* to the type parameter."},{"pos":[8390,8413],"content":"Example of a Constraint","linkify":"Example of a Constraint","nodes":[{"content":"Example of a Constraint","pos":[0,23]}]},{"pos":[8417,8567],"content":"The following example shows a skeleton definition of a class with a constraint that requires the type argument to implement <ph id=\"ph1\">&lt;xref:System.IComparable&gt;</ph>.","source":"The following example shows a skeleton definition of a class with a constraint that requires the type argument to implement <xref:System.IComparable>."},{"pos":[8696,8862],"content":"If subsequent code attempts to construct a class from <ph id=\"ph1\">`itemManager`</ph> supplying a type that does not implement <ph id=\"ph2\">&lt;xref:System.IComparable&gt;</ph>, the compiler signals an error.","source":"If subsequent code attempts to construct a class from `itemManager` supplying a type that does not implement <xref:System.IComparable>, the compiler signals an error."},{"pos":[8872,8892],"content":"Types of Constraints","linkify":"Types of Constraints","nodes":[{"content":"Types of Constraints","pos":[0,20]}]},{"content":"Your constraint can specify the following requirements in any combination:","pos":[8896,8970]},{"content":"The type argument must implement one or more interfaces","pos":[8980,9035]},{"content":"The type argument must be of the type of, or inherit from, at most one class","pos":[9045,9121]},{"content":"The type argument must expose a parameterless constructor accessible to the code that creates objects from it","pos":[9131,9240]},{"pos":[9250,9324],"content":"The type argument must be a <bpt id=\"p1\">*</bpt>reference type<ept id=\"p1\">*</ept>, or it must be a <bpt id=\"p2\">*</bpt>value type<ept id=\"p2\">*</ept>","source":"The type argument must be a *reference type*, or it must be a *value type*"},{"content":"If you need to impose more than one requirement, you use a comma-separated <bpt id=\"p1\">*</bpt>constraint list<ept id=\"p1\">*</ept> inside braces (<ph id=\"ph1\">`{ }`</ph>).","pos":[9331,9446],"source":"If you need to impose more than one requirement, you use a comma-separated *constraint list* inside braces (`{ }`)."},{"content":"To require an accessible constructor, you include the <bpt id=\"p1\">[</bpt>New Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/new-operator.md)</ept> keyword in the list.","pos":[9447,9607],"source":" To require an accessible constructor, you include the [New Operator](../../../../visual-basic/language-reference/operators/new-operator.md) keyword in the list."},{"content":"To require a reference type, you include the <ph id=\"ph1\">`Class`</ph> keyword; to require a value type, you include the <ph id=\"ph2\">`Structure`</ph> keyword.","pos":[9608,9731],"source":" To require a reference type, you include the `Class` keyword; to require a value type, you include the `Structure` keyword."},{"pos":[9738,9860],"content":"For more information on constraints, see <bpt id=\"p1\">[</bpt>Type List<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/type-list.md)</ept>.","source":"For more information on constraints, see [Type List](../../../../visual-basic/language-reference/statements/type-list.md)."},{"pos":[9870,9901],"content":"Example of Multiple Constraints","linkify":"Example of Multiple Constraints","nodes":[{"content":"Example of Multiple Constraints","pos":[0,31]}]},{"content":"The following example shows a skeleton definition of a generic class with a constraint list on the type parameter.","pos":[9905,10019]},{"content":"In the code that creates an instance of this class, the type argument must implement both the <ph id=\"ph1\">&lt;xref:System.IComparable&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.IDisposable&gt;</ph> interfaces, be a reference type, and expose an accessible parameterless constructor.","pos":[10020,10254],"source":" In the code that creates an instance of this class, the type argument must implement both the <xref:System.IComparable> and <xref:System.IDisposable> interfaces, be a reference type, and expose an accessible parameterless constructor."},{"pos":[10385,10400],"content":"Important Terms","linkify":"Important Terms","nodes":[{"content":"Important Terms","pos":[0,15]}]},{"content":"Generic types introduce and use the following terms:","pos":[10404,10456]},{"content":"<bpt id=\"p1\">*</bpt>Generic Type<ept id=\"p1\">*</ept>.","pos":[10466,10481],"source":"*Generic Type*."},{"content":"A definition of a class, structure, interface, procedure, or delegate for which you supply at least one data type when you declare it.","pos":[10482,10616]},{"content":"<bpt id=\"p1\">*</bpt>Type Parameter<ept id=\"p1\">*</ept>.","pos":[10626,10643],"source":"*Type Parameter*."},{"content":"In a generic type definition, a placeholder for a data type you supply when you declare the type.","pos":[10644,10741]},{"content":"<bpt id=\"p1\">*</bpt>Type Argument<ept id=\"p1\">*</ept>.","pos":[10751,10767],"source":"*Type Argument*."},{"content":"A specific data type that replaces a type parameter when you declare a constructed type from a generic type.","pos":[10768,10876]},{"content":"<bpt id=\"p1\">*</bpt>Constraint<ept id=\"p1\">*</ept>.","pos":[10886,10899],"source":"*Constraint*."},{"content":"A condition on a type parameter that restricts the type argument you can supply for it.","pos":[10900,10987]},{"content":"A constraint can require that the type argument must implement a particular interface, be or inherit from a particular class, have an accessible parameterless constructor, or be a reference type or a value type.","pos":[10988,11199]},{"content":"You can combine these constraints, but you can specify at most one class.","pos":[11200,11273]},{"content":"<bpt id=\"p1\">*</bpt>Constructed Type<ept id=\"p1\">*</ept>.","pos":[11283,11302],"source":"*Constructed Type*."},{"content":"A class, structure, interface, procedure, or delegate declared from a generic type by supplying type arguments for its type parameters.","pos":[11303,11438]},{"pos":[11447,11455],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[11459,11553],"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/index.md)</ept>","source":"[Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md)"},{"pos":[11556,11665],"content":"<bpt id=\"p1\">[</bpt>Type Characters<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)</ept>","source":"[Type Characters](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)"},{"pos":[11668,11809],"content":"<bpt id=\"p1\">[</bpt>Value Types and Reference Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)</ept>","source":"[Value Types and Reference Types](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)"},{"pos":[11812,11939],"content":"<bpt id=\"p1\">[</bpt>Type Conversions in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept>","source":"[Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)"},{"pos":[11942,12073],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept>","source":"[Troubleshooting Data Types](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)"},{"pos":[12076,12153],"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/index.md)</ept>","source":"[Data Types](../../../../visual-basic/language-reference/data-types/index.md)"},{"pos":[12156,12229],"content":"<bpt id=\"p1\">[</bpt>Of<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/of-clause.md)</ept>","source":"[Of](../../../../visual-basic/language-reference/statements/of-clause.md)"},{"pos":[12232,12305],"content":"<bpt id=\"p1\">[</bpt>As<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/as-clause.md)</ept>","source":"[As](../../../../visual-basic/language-reference/statements/as-clause.md)"},{"pos":[12308,12402],"content":"<bpt id=\"p1\">[</bpt>Object Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/object-data-type.md)</ept>","source":"[Object Data Type](../../../../visual-basic/language-reference/data-types/object-data-type.md)"},{"pos":[12405,12487],"content":"<bpt id=\"p1\">[</bpt>Covariance and Contravariance<ept id=\"p1\">](../../concepts/covariance-contravariance/index.md)</ept>","source":"[Covariance and Contravariance](../../concepts/covariance-contravariance/index.md)"},{"pos":[12490,12567],"content":"<bpt id=\"p1\">[</bpt>Iterators<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/iterators.md)</ept>","source":"[Iterators](../../../../visual-basic/programming-guide/concepts/iterators.md)"}]}