{"content":"---\ntitle: \"Using Dead-Letter Queues to Handle Message Transfer Failures\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 9e891c6a-d960-45ea-904f-1a00e202d61a\n---\n# Using Dead-Letter Queues to Handle Message Transfer Failures\nQueued messages can fail delivery. These failed messages are recorded in a dead-letter queue. The failed delivery can be caused by reasons such as network failures, a deleted queue, a full queue, authentication failure, or a failure to deliver on time.  \n  \n Queued messages can remain in the queue for a long time if the receiving application does not read them from the queue in a timely fashion. This behavior may not be appropriate for time-sensitive messages. Time-sensitive messages have a Time to Live (TTL) property set in the queued binding, which indicates how long the messages can be in the queue before they must expire. Expired messages are sent to a special queue called the dead-letter queue. Messages can also be put in a dead-letter queue for other reasons, such as exceeding a queue quota or because of authentication failure.  \n  \n Generally, applications write compensation logic to read messages from the dead-letter queue and failure reasons. The compensation logic depends on the cause of the failure. For example, in the case of authentication failure, you can correct the certificate attached with the message and resend the message. If delivery failed because the target queue quota was reached, you can reattempt delivery in the hope that the quota problem was resolved.  \n  \n Most queuing systems have a system-wide dead-letter queue where all failed messages from that system are stored. Message Queuing (MSMQ) provides two system-wide dead-letter queues: a transactional system-wide dead-letter queue that stores messages that failed delivery to the transactional queue and a non-transactional system-wide dead-letter queue that stores messages that failed delivery to the non-transactional queue. If two clients are sending messages to two different services, and therefore different queues in WCF are sharing the same MSMQ service to send, then it is possible to have a mix of messages in the system dead-letter queue. This is not always optimal. In several cases (security, for example), you may not want one client to read another client's messages from a dead-letter queue. A shared dead-letter queue also requires clients to browse through the queue to find a message that they sent, which can be prohibitively expensive based on the number of messages in the dead-letter queue. Therefore, in WCF`NetMsmqBinding`, `MsmqIntegrationBinding,` and MSMQ on [!INCLUDE[wv](../../../../includes/wv-md.md)] provide a custom dead-letter queue (sometimes referred to as an application-specific dead-letter queue).  \n  \n The custom dead-letter queue provides isolation between clients that share the same MSMQ service to send messages.  \n  \n On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], Windows Communication Foundation (WCF) provides a system-wide dead-letter queue for all queued client applications. On [!INCLUDE[wv](../../../../includes/wv-md.md)], WCF provides a dead-letter queue for each queued client application.  \n  \n## Specifying Use of the Dead-Letter Queue  \n A dead-letter queue is in the queue manager of the sending application. It stores messages that have expired or that have failed transfer or delivery.  \n  \n The binding has the following dead-letter queue properties:  \n  \n-   <xref:System.ServiceModel.MsmqBindingBase.DeadLetterQueue%2A>  \n  \n-   <xref:System.ServiceModel.MsmqBindingBase.CustomDeadLetterQueue%2A>  \n  \n## Reading Messages from the Dead-Letter Queue  \n An application that reads messages out of a dead-letter queue is similar to a WCF service that reads from an application queue, except for the following minor differences:  \n  \n-   To read messages from a system transactional dead-letter queue, the Uniform Resource Identifier (URI) must be of the form: net.msmq://localhost/system$;DeadXact.  \n  \n-   To read messages from a system non-transactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadLetter.  \n  \n-   To read messages from a custom dead-letter queue, the URI must be of the form:net.msmq://localhost/private/\\<*custom-dlq-name*> where *custom-dlq-name* is the name of the custom dead-letter queue.  \n  \n For more information about how to address queues, see [Service Endpoints and Queue Addressing](../../../../docs/framework/wcf/feature-details/service-endpoints-and-queue-addressing.md).  \n  \n The WCF stack on the receiver matches addresses that the service is listening on with the address on the message. If the addresses match, the message is dispatched; if not, the message is not dispatched. This can cause problems when reading from the dead-letter queue, because messages in the dead-letter queue are typically addressed to the service and not the dead-letter queue service. Therefore, the service reading from the dead-letter queue must install an address filter `ServiceBehavior` that instructs the stack to match all messages in the queue independently of the addressee. Specifically, you must add a `ServiceBehavior` with the <xref:System.ServiceModel.AddressFilterMode.Any> parameter to the service reading messages from the dead-letter queue.  \n  \n## Poison Message Handling from the Dead-Letter Queue  \n Poison message handling is available on dead-letter queues, with some conditions. Because you cannot create sub-queues from system queues, when reading from the system dead-letter queue, the `ReceiveErrorHandling` cannot be set to `Move`. Note that if you are reading from a custom dead-letter queue, you can have sub-queues and, therefore, `Move` is a valid disposition for the poison message.  \n  \n When `ReceiveErrorHandling` is set to `Reject`, when reading from the custom dead letter queue, the poison message is put in the system dead-letter queue. If reading from the system dead-letter queue, the message is dropped (purged). A reject from a system dead-letter queue in MSMQ drops (purges) the message.  \n  \n## Example  \n The following example shows how to create a dead-letter queue and how to use it to process expired messages. The example is based on the example in [How to: Exchange Queued Messages with WCF Endpoints](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md). The following example shows how to write the client code to the order processing service that uses a dead-letter queue for each application. The example also shows how to process messages from the dead-letter queue.  \n  \n The following is code for a client that specifies a dead-letter queue for each application.  \n  \n [!code-csharp[S_DeadLetter#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/client.cs#1)]\n [!code-vb[S_DeadLetter#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/client.vb#1)]  \n  \n The following is code for the client configuration file.  \n\n The following is code for a service processing messages from a dead-letter queue.  \n  \n [!code-csharp[S_DeadLetter#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/dlservice.cs#3)]\n [!code-vb[S_DeadLetter#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/dlservice.vb#3)]  \n  \n The following is code for the dead-letter queue service configuration file.  \n\n## See also\n\n- [Queues Overview](../../../../docs/framework/wcf/feature-details/queues-overview.md)\n- [How to: Exchange Queued Messages with WCF Endpoints](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)\n- [Poison Message Handling](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)\n","nodes":[{"pos":[4,178],"embed":true,"restype":"x-metadata","content":"title: \"Using Dead-Letter Queues to Handle Message Transfer Failures\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 9e891c6a-d960-45ea-904f-1a00e202d61a","nodes":[{"content":"Using Dead-Letter Queues to Handle Message Transfer Failures","nodes":[{"pos":[0,60],"content":"Using Dead-Letter Queues to Handle Message Transfer Failures","nodes":[{"content":"Using Dead-Letter Queues to Handle Message Transfer Failures","pos":[0,60]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[185,245],"content":"Using Dead-Letter Queues to Handle Message Transfer Failures","linkify":"Using Dead-Letter Queues to Handle Message Transfer Failures","nodes":[{"content":"Using Dead-Letter Queues to Handle Message Transfer Failures","pos":[0,60]}]},{"content":"Queued messages can fail delivery.","pos":[246,280]},{"content":"These failed messages are recorded in a dead-letter queue.","pos":[281,339]},{"content":"The failed delivery can be caused by reasons such as network failures, a deleted queue, a full queue, authentication failure, or a failure to deliver on time.","pos":[340,498]},{"content":"Queued messages can remain in the queue for a long time if the receiving application does not read them from the queue in a timely fashion.","pos":[505,644]},{"content":"This behavior may not be appropriate for time-sensitive messages.","pos":[645,710]},{"content":"Time-sensitive messages have a Time to Live (TTL) property set in the queued binding, which indicates how long the messages can be in the queue before they must expire.","pos":[711,879]},{"content":"Expired messages are sent to a special queue called the dead-letter queue.","pos":[880,954]},{"content":"Messages can also be put in a dead-letter queue for other reasons, such as exceeding a queue quota or because of authentication failure.","pos":[955,1091]},{"content":"Generally, applications write compensation logic to read messages from the dead-letter queue and failure reasons.","pos":[1098,1211]},{"content":"The compensation logic depends on the cause of the failure.","pos":[1212,1271]},{"content":"For example, in the case of authentication failure, you can correct the certificate attached with the message and resend the message.","pos":[1272,1405]},{"content":"If delivery failed because the target queue quota was reached, you can reattempt delivery in the hope that the quota problem was resolved.","pos":[1406,1544]},{"content":"Most queuing systems have a system-wide dead-letter queue where all failed messages from that system are stored.","pos":[1551,1663]},{"content":"Message Queuing (MSMQ) provides two system-wide dead-letter queues: a transactional system-wide dead-letter queue that stores messages that failed delivery to the transactional queue and a non-transactional system-wide dead-letter queue that stores messages that failed delivery to the non-transactional queue.","pos":[1664,1974]},{"content":"If two clients are sending messages to two different services, and therefore different queues in WCF are sharing the same MSMQ service to send, then it is possible to have a mix of messages in the system dead-letter queue.","pos":[1975,2197]},{"content":"This is not always optimal.","pos":[2198,2225]},{"content":"In several cases (security, for example), you may not want one client to read another client's messages from a dead-letter queue.","pos":[2226,2355]},{"content":"A shared dead-letter queue also requires clients to browse through the queue to find a message that they sent, which can be prohibitively expensive based on the number of messages in the dead-letter queue.","pos":[2356,2561]},{"content":"Therefore, in WCF<ph id=\"ph1\">`NetMsmqBinding`</ph>, <ph id=\"ph2\">`MsmqIntegrationBinding,`</ph> and MSMQ on <ph id=\"ph3\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph> provide a custom dead-letter queue (sometimes referred to as an application-specific dead-letter queue).","pos":[2562,2785],"source":" Therefore, in WCF`NetMsmqBinding`, `MsmqIntegrationBinding,` and MSMQ on [!INCLUDE[wv](../../../../includes/wv-md.md)] provide a custom dead-letter queue (sometimes referred to as an application-specific dead-letter queue)."},{"content":"The custom dead-letter queue provides isolation between clients that share the same MSMQ service to send messages.","pos":[2792,2906]},{"content":"On <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>, Windows Communication Foundation (WCF) provides a system-wide dead-letter queue for all queued client applications.","pos":[2913,3138],"source":"On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], Windows Communication Foundation (WCF) provides a system-wide dead-letter queue for all queued client applications."},{"content":"On <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph>, WCF provides a dead-letter queue for each queued client application.","pos":[3139,3257],"source":" On [!INCLUDE[wv](../../../../includes/wv-md.md)], WCF provides a dead-letter queue for each queued client application."},{"pos":[3266,3305],"content":"Specifying Use of the Dead-Letter Queue","linkify":"Specifying Use of the Dead-Letter Queue","nodes":[{"content":"Specifying Use of the Dead-Letter Queue","pos":[0,39]}]},{"content":"A dead-letter queue is in the queue manager of the sending application.","pos":[3309,3380]},{"content":"It stores messages that have expired or that have failed transfer or delivery.","pos":[3381,3459]},{"content":"The binding has the following dead-letter queue properties:","pos":[3466,3525]},{"pos":[3682,3725],"content":"Reading Messages from the Dead-Letter Queue","linkify":"Reading Messages from the Dead-Letter Queue","nodes":[{"content":"Reading Messages from the Dead-Letter Queue","pos":[0,43]}]},{"content":"An application that reads messages out of a dead-letter queue is similar to a WCF service that reads from an application queue, except for the following minor differences:","pos":[3729,3900]},{"content":"To read messages from a system transactional dead-letter queue, the Uniform Resource Identifier (URI) must be of the form: net.msmq://localhost/system$;DeadXact.","pos":[3910,4071]},{"content":"To read messages from a system non-transactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadLetter.","pos":[4081,4218]},{"pos":[4228,4424],"content":"To read messages from a custom dead-letter queue, the URI must be of the form:net.msmq://localhost/private/<ph id=\"ph1\">\\&lt;</ph><bpt id=\"p1\">*</bpt>custom-dlq-name<ept id=\"p1\">*</ept>&gt; where <bpt id=\"p2\">*</bpt>custom-dlq-name<ept id=\"p2\">*</ept> is the name of the custom dead-letter queue.","source":"To read messages from a custom dead-letter queue, the URI must be of the form:net.msmq://localhost/private/\\<*custom-dlq-name*> where *custom-dlq-name* is the name of the custom dead-letter queue."},{"pos":[4431,4616],"content":"For more information about how to address queues, see <bpt id=\"p1\">[</bpt>Service Endpoints and Queue Addressing<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/service-endpoints-and-queue-addressing.md)</ept>.","source":"For more information about how to address queues, see [Service Endpoints and Queue Addressing](../../../../docs/framework/wcf/feature-details/service-endpoints-and-queue-addressing.md)."},{"content":"The WCF stack on the receiver matches addresses that the service is listening on with the address on the message.","pos":[4623,4736]},{"content":"If the addresses match, the message is dispatched; if not, the message is not dispatched.","pos":[4737,4826]},{"content":"This can cause problems when reading from the dead-letter queue, because messages in the dead-letter queue are typically addressed to the service and not the dead-letter queue service.","pos":[4827,5011]},{"content":"Therefore, the service reading from the dead-letter queue must install an address filter <ph id=\"ph1\">`ServiceBehavior`</ph> that instructs the stack to match all messages in the queue independently of the addressee.","pos":[5012,5210],"source":" Therefore, the service reading from the dead-letter queue must install an address filter `ServiceBehavior` that instructs the stack to match all messages in the queue independently of the addressee."},{"content":"Specifically, you must add a <ph id=\"ph1\">`ServiceBehavior`</ph> with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.AddressFilterMode.Any&gt;</ph> parameter to the service reading messages from the dead-letter queue.","pos":[5211,5385],"source":" Specifically, you must add a `ServiceBehavior` with the <xref:System.ServiceModel.AddressFilterMode.Any> parameter to the service reading messages from the dead-letter queue."},{"pos":[5394,5444],"content":"Poison Message Handling from the Dead-Letter Queue","linkify":"Poison Message Handling from the Dead-Letter Queue","nodes":[{"content":"Poison Message Handling from the Dead-Letter Queue","pos":[0,50]}]},{"content":"Poison message handling is available on dead-letter queues, with some conditions.","pos":[5448,5529]},{"content":"Because you cannot create sub-queues from system queues, when reading from the system dead-letter queue, the <ph id=\"ph1\">`ReceiveErrorHandling`</ph> cannot be set to <ph id=\"ph2\">`Move`</ph>.","pos":[5530,5686],"source":" Because you cannot create sub-queues from system queues, when reading from the system dead-letter queue, the `ReceiveErrorHandling` cannot be set to `Move`."},{"content":"Note that if you are reading from a custom dead-letter queue, you can have sub-queues and, therefore, <ph id=\"ph1\">`Move`</ph> is a valid disposition for the poison message.","pos":[5687,5842],"source":" Note that if you are reading from a custom dead-letter queue, you can have sub-queues and, therefore, `Move` is a valid disposition for the poison message."},{"content":"When <ph id=\"ph1\">`ReceiveErrorHandling`</ph> is set to <ph id=\"ph2\">`Reject`</ph>, when reading from the custom dead letter queue, the poison message is put in the system dead-letter queue.","pos":[5849,6003],"source":"When `ReceiveErrorHandling` is set to `Reject`, when reading from the custom dead letter queue, the poison message is put in the system dead-letter queue."},{"content":"If reading from the system dead-letter queue, the message is dropped (purged).","pos":[6004,6082]},{"content":"A reject from a system dead-letter queue in MSMQ drops (purges) the message.","pos":[6083,6159]},{"pos":[6168,6175],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows how to create a dead-letter queue and how to use it to process expired messages.","pos":[6179,6287]},{"content":"The example is based on the example in <bpt id=\"p1\">[</bpt>How to: Exchange Queued Messages with WCF Endpoints<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)</ept>.","pos":[6288,6483],"source":" The example is based on the example in [How to: Exchange Queued Messages with WCF Endpoints](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)."},{"content":"The following example shows how to write the client code to the order processing service that uses a dead-letter queue for each application.","pos":[6484,6624]},{"content":"The example also shows how to process messages from the dead-letter queue.","pos":[6625,6699]},{"content":"The following is code for a client that specifies a dead-letter queue for each application.","pos":[6706,6797]},{"content":"The following is code for the client configuration file.","pos":[7036,7092]},{"content":"The following is code for a service processing messages from a dead-letter queue.","pos":[7097,7178]},{"content":"The following is code for the dead-letter queue service configuration file.","pos":[7423,7498]},{"pos":[7505,7513],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7517,7601],"content":"<bpt id=\"p1\">[</bpt>Queues Overview<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/queues-overview.md)</ept>","source":"[Queues Overview](../../../../docs/framework/wcf/feature-details/queues-overview.md)"},{"pos":[7604,7759],"content":"<bpt id=\"p1\">[</bpt>How to: Exchange Queued Messages with WCF Endpoints<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)</ept>","source":"[How to: Exchange Queued Messages with WCF Endpoints](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)"},{"pos":[7762,7862],"content":"<bpt id=\"p1\">[</bpt>Poison Message Handling<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)</ept>","source":"[Poison Message Handling](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)"}]}