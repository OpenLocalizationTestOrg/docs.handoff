{"content":"---\ntitle: C# Program Structure - A Tour of the C# Language\ndescription: Learn the basic building blocks of a C# program\nms.date: 08/10/2016\nms.assetid: 984f0314-507f-47a0-af56-9011243f5e65\n---\n\n# Program Structure\n\nThe key organizational concepts in C# are ***programs***, ***namespaces***, ***types***, ***members***, and ***assemblies***. C# programs consist of one or more source files. Programs declare types, which contain members and can be organized into namespaces. Classes and interfaces are examples of types. Fields, methods, properties, and events are examples of members. When C# programs are compiled, they are physically packaged into assemblies. Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.\n\nThe example declares a class named `Stack` in a namespace called `Acme.Collections`:\n\n[!code-csharp[Stack](../../../samples/snippets/csharp/tour/program-structure/program.cs#L1-L34)]\n\nThe fully qualified name of this class is `Acme.Collections.Stack`. The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`. The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor. Assuming that the source code of the example is stored in the file `acme.cs`, the command line\n\n```\ncsc /t:library acme.cs\n```\n\ncompiles the example as a library (code without a `Main` entry point) and produces an assembly named `acme.dll`.\n\n> [!IMPORTANT]\n> The examples above use `csc` as the command line C# compiler. This compiler is a Windows executable. To use C# across other platforms, you should use the tools for .NET Core. The .NET Core ecosystem uses the `dotnet` CLI to manage command line builds. This includes managing dependencies, and invoking the C# compiler. See [this tutorial](../../core/tutorials/using-with-xplat-cli.md) for a full description of those tools on the platforms supported by .NET Core.\n\nAssemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata. Before it is executed, the IL code in an assembly is automatically converted to processor-specific code by the Just-In-Time (JIT) compiler of .NET Common Language Runtime.\n\nBecause an assembly is a self-describing unit of functionality containing both code and metadata, there is no need for `#include` directives and header files in C#. The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program. For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:\n\n[!code-csharp[UsingStack](../../../samples/snippets/csharp/tour/program-structure/Program.cs#L38-L52)]\n\nIf the program is stored in the file `example.cs`, when `example.cs` is compiled, the acme.dll assembly can be referenced using the compiler’s /r option:\n\n```\ncsc /r:acme.dll example.cs\n```\n\nThis creates an executable assembly named `example.exe`, which, when run, produces the output:\n\n```\n100\n10\n1\n```\n\nC# permits the source text of a program to be stored in several source files. When a multi-file C# program is compiled, all of the source files are processed together, and the source files can freely reference each other—conceptually, it is as if all the source files were concatenated into one large file before being processed. Forward declarations are never needed in C# because, with very few exceptions, declaration order is insignificant. C# does not limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.\n\n>[!div class=\"step-by-step\"]\n>[Previous](index.md)\n>[Next](types-and-variables.md)","nodes":[{"pos":[4,189],"embed":true,"restype":"x-metadata","content":"title: C# Program Structure - A Tour of the C# Language\ndescription: Learn the basic building blocks of a C# program\nms.date: 08/10/2016\nms.assetid: 984f0314-507f-47a0-af56-9011243f5e65","nodes":[{"content":"C# Program Structure - A Tour of the C# Language","nodes":[{"pos":[0,48],"content":"C# Program Structure - A Tour of the C# Language","nodes":[{"content":"C# Program Structure - A Tour of the C# Language","pos":[0,48]}]}],"path":["title"],"nosxs":false},{"content":"Learn the basic building blocks of a C# program","nodes":[{"pos":[0,47],"content":"Learn the basic building blocks of a C# program","nodes":[{"content":"Learn the basic building blocks of a C# program","pos":[0,47]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[197,214],"content":"Program Structure","linkify":"Program Structure","nodes":[{"content":"Program Structure","pos":[0,17]}]},{"content":"The key organizational concepts in C# are <bpt id=\"p1\">***</bpt>programs<ept id=\"p1\">***</ept>, <bpt id=\"p2\">***</bpt>namespaces<ept id=\"p2\">***</ept>, <bpt id=\"p3\">***</bpt>types<ept id=\"p3\">***</ept>, <bpt id=\"p4\">***</bpt>members<ept id=\"p4\">***</ept>, and <bpt id=\"p5\">***</bpt>assemblies<ept id=\"p5\">***</ept>.","pos":[216,341],"source":"The key organizational concepts in C# are ***programs***, ***namespaces***, ***types***, ***members***, and ***assemblies***."},{"content":"C# programs consist of one or more source files.","pos":[342,390]},{"content":"Programs declare types, which contain members and can be organized into namespaces.","pos":[391,474]},{"content":"Classes and interfaces are examples of types.","pos":[475,520]},{"content":"Fields, methods, properties, and events are examples of members.","pos":[521,585]},{"content":"When C# programs are compiled, they are physically packaged into assemblies.","pos":[586,662]},{"content":"Assemblies typically have the file extension <ph id=\"ph1\">`.exe`</ph> or <ph id=\"ph2\">`.dll`</ph>, depending on whether they implement <bpt id=\"p1\">***</bpt>applications<ept id=\"p1\">***</ept> or <bpt id=\"p2\">***</bpt>libraries<ept id=\"p2\">***</ept>, respectively.","pos":[663,814],"source":" Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively."},{"pos":[816,900],"content":"The example declares a class named <ph id=\"ph1\">`Stack`</ph> in a namespace called <ph id=\"ph2\">`Acme.Collections`</ph>:","source":"The example declares a class named `Stack` in a namespace called `Acme.Collections`:"},{"content":"The fully qualified name of this class is <ph id=\"ph1\">`Acme.Collections.Stack`</ph>.","pos":[1000,1067],"source":"The fully qualified name of this class is `Acme.Collections.Stack`."},{"content":"The class contains several members: a field named <ph id=\"ph1\">`top`</ph>, two methods named <ph id=\"ph2\">`Push`</ph> and <ph id=\"ph3\">`Pop`</ph>, and a nested class named <ph id=\"ph4\">`Entry`</ph>.","pos":[1068,1194],"source":" The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`."},{"content":"The <ph id=\"ph1\">`Entry`</ph> class further contains three members: a field named <ph id=\"ph2\">`next`</ph>, a field named <ph id=\"ph3\">`data`</ph>, and a constructor.","pos":[1195,1307],"source":" The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor."},{"content":"Assuming that the source code of the example is stored in the file <ph id=\"ph1\">`acme.cs`</ph>, the command line","pos":[1308,1402],"source":" Assuming that the source code of the example is stored in the file `acme.cs`, the command line"},{"pos":[1436,1548],"content":"compiles the example as a library (code without a <ph id=\"ph1\">`Main`</ph> entry point) and produces an assembly named <ph id=\"ph2\">`acme.dll`</ph>.","source":"compiles the example as a library (code without a `Main` entry point) and produces an assembly named `acme.dll`."},{"pos":[1552,2030],"content":"[!IMPORTANT]\nThe examples above use `csc` as the command line C# compiler. This compiler is a Windows executable. To use C# across other platforms, you should use the tools for .NET Core. The .NET Core ecosystem uses the `dotnet` CLI to manage command line builds. This includes managing dependencies, and invoking the C# compiler. See [this tutorial](../../core/tutorials/using-with-xplat-cli.md) for a full description of those tools on the platforms supported by .NET Core.","leadings":["","> "],"nodes":[{"content":"The examples above use `csc` as the command line C# compiler. This compiler is a Windows executable. To use C# across other platforms, you should use the tools for .NET Core. The .NET Core ecosystem uses the `dotnet` CLI to manage command line builds. This includes managing dependencies, and invoking the C# compiler. See [this tutorial](../../core/tutorials/using-with-xplat-cli.md) for a full description of those tools on the platforms supported by .NET Core.","pos":[13,476],"nodes":[{"content":"The examples above use <ph id=\"ph1\">`csc`</ph> as the command line C# compiler.","pos":[0,61],"source":"The examples above use `csc` as the command line C# compiler."},{"content":"This compiler is a Windows executable.","pos":[62,100]},{"content":"To use C# across other platforms, you should use the tools for .NET Core.","pos":[101,174]},{"content":"The .NET Core ecosystem uses the <ph id=\"ph1\">`dotnet`</ph> CLI to manage command line builds.","pos":[175,251],"source":" The .NET Core ecosystem uses the `dotnet` CLI to manage command line builds."},{"content":"This includes managing dependencies, and invoking the C# compiler.","pos":[252,318]},{"content":"See <bpt id=\"p1\">[</bpt>this tutorial<ept id=\"p1\">](../../core/tutorials/using-with-xplat-cli.md)</ept> for a full description of those tools on the platforms supported by .NET Core.","pos":[319,463],"source":" See [this tutorial](../../core/tutorials/using-with-xplat-cli.md) for a full description of those tools on the platforms supported by .NET Core."}]}]},{"content":"Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.","pos":[2032,2172]},{"content":"Before it is executed, the IL code in an assembly is automatically converted to processor-specific code by the Just-In-Time (JIT) compiler of .NET Common Language Runtime.","pos":[2173,2344]},{"content":"Because an assembly is a self-describing unit of functionality containing both code and metadata, there is no need for <ph id=\"ph1\">`#include`</ph> directives and header files in C#.","pos":[2346,2510],"source":"Because an assembly is a self-describing unit of functionality containing both code and metadata, there is no need for `#include` directives and header files in C#."},{"content":"The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.","pos":[2511,2673]},{"content":"For example, this program uses the <ph id=\"ph1\">`Acme.Collections.Stack`</ph> class from the <ph id=\"ph2\">`acme.dll`</ph> assembly:","pos":[2674,2769],"source":" For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:"},{"pos":[2875,3028],"content":"If the program is stored in the file <ph id=\"ph1\">`example.cs`</ph>, when <ph id=\"ph2\">`example.cs`</ph> is compiled, the acme.dll assembly can be referenced using the compiler’s /r option:","source":"If the program is stored in the file `example.cs`, when `example.cs` is compiled, the acme.dll assembly can be referenced using the compiler’s /r option:"},{"pos":[3066,3160],"content":"This creates an executable assembly named <ph id=\"ph1\">`example.exe`</ph>, which, when run, produces the output:","source":"This creates an executable assembly named `example.exe`, which, when run, produces the output:"},{"content":"C# permits the source text of a program to be stored in several source files.","pos":[3180,3257]},{"content":"When a multi-file C# program is compiled, all of the source files are processed together, and the source files can freely reference each other—conceptually, it is as if all the source files were concatenated into one large file before being processed.","pos":[3258,3509]},{"content":"Forward declarations are never needed in C# because, with very few exceptions, declaration order is insignificant.","pos":[3510,3624]},{"content":"C# does not limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.","pos":[3625,3783]},{"pos":[3786,3867],"content":"[!div class=\"step-by-step\"]\n[Previous](index.md)\n[Next](types-and-variables.md)","leadings":["",">",">"],"nodes":[{"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](index.md)</ept><ph id=\"ph1\">\n</ph><bpt id=\"p2\">[</bpt>Next<ept id=\"p2\">](types-and-variables.md)</ept>","pos":[28,79],"source":"[Previous](index.md)\n[Next](types-and-variables.md)"}]}]}