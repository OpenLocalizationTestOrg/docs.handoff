{"content":"---\ntitle: \"Stand-Alone JSON Serialization | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287\ncaps.latest.revision: 32\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Stand-Alone JSON Serialization\nJSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser. It is the default data format used by ASP.NET AJAX services created in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].  \n  \n This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.  \n  \n Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types. For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).  \n  \n When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>. For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md). This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.  \n  \n## Mapping .NET types to JSON Types  \n The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.  \n  \n|.NET Types|JSON/JavaScript|Notes|  \n|----------------|----------------------|-----------|  \n|All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>|Number|Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.|  \n|<xref:System.Enum>|Number|See \"Enumerations and JSON\" later in this topic.|  \n|<xref:System.Boolean>|Boolean|--|  \n|<xref:System.String>, <xref:System.Char>|String|--|  \n|<xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri>|String|The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the \"12345678-ABCD-ABCD-ABCD-1234567890AB\" format and URI in its natural string form like \"http://www.example.com\"). For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).|  \n|<xref:System.Xml.XmlQualifiedName>|String|The format is \"name:namespace\" (anything before the first colon is the name). Either the name or the namespace can be missing. If there is no namespace the colon can be omitted as well.|  \n|<xref:System.Array> of type <xref:System.Byte>|Array of numbers|Each number represents the value of one byte.|  \n|<xref:System.DateTime>|DateTime or String|See Dates/Times and JSON later in this topic.|  \n|<xref:System.DateTimeOffset>|Complex type|See Dates/Times and JSON later in this topic.|  \n|XML and ADO.NET types (<xref:System.Xml.XmlElement>,<br /><br /> <xref:System.Xml.Linq.XElement>. Arrays of <xref:System.Xml.XmlNode>,<br /><br /> <xref:System.Runtime.Serialization.ISerializable>,<br /><br /> <xref:System.Data.DataSet>).|String|See the XML Types and JSON section of this topic.|  \n|<xref:System.DBNull>|Empty complex type|--|  \n|Collections, dictionaries, and arrays|Array|See the Collections, Dictionaries, and Arrays section of this topic.|  \n|Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)|Complex type|Data members become members of the JavaScript complex type.|  \n|Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)|Complex type|Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.|  \n|`Null` value for any type|Null|Nullable types are also supported and map to JSON in the same way as non-nullable types.|  \n  \n### Enumerations and JSON  \n Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names. [!INCLUDE[crabout](../../../../includes/crabout-md.md)] the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).  \n  \n-   For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string \"yellow\".  \n  \n-   All `enum` members are serializable. The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.  \n  \n-   It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.  \n  \n-   A flags `enum` is not special and is treated the same as any other `enum`.  \n  \n### Dates/Times and JSON  \n The JSON format does not directly support dates and times. However, they are very commonly used and ASP.NET AJAX provides special support for these types. When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.  \n  \n-   When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.  \n  \n-   <xref:System.DateTimeOffset> is represented in JSON as a complex type: {\"DateTime\":dateTime,\"OffsetMinutes\":offsetMinutes}. The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest. The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not). On serialization, the `dateTime` member is always serialized in GMT. So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).  \n  \n    > [!NOTE]\n    >  <xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision. Sub-millisecond values (micro/nanoseconds) are lost during serialization.  \n  \n### XML Types and JSON  \n XML types become JSON strings.  \n  \n-   For example, if a data member \"q\" of type XElement contains \\<abc/>, the JSON is {\"q\":\"\\<abc/>\"}.  \n  \n-   There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.  \n  \n-   If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.  \n  \n### Collections, Dictionaries and Arrays  \n All collections, dictionaries, and arrays are represented in JSON as arrays.  \n  \n-   Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.  \n  \n-   Dictionaries are not a way to work directly with JSON. Dictionary\\<string,object> may not be supported in the same way in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] as expected from working with other JSON technologies. For example, if \"abc\" is mapped to \"xyz\" and \"def\" is mapped to 42 in a dictionary, the JSON representation is not {\"abc\":\"xyz\",\"def\":42} but is [{\"Key\":\"abc\",\"Value\":\"xyz\"},{\"Key\":\"def\",\"Value\":42}] instead.  \n  \n-   If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:  \n  \n    -   Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.  \n  \n    -   Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.  \n  \n    -   Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.  \n  \n    -   *Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected. There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>. This issue is more fully discussed in the Advanced Information section later in this topic.  \n  \n## Additional Details  \n  \n### Order of Data Members  \n Order of data members is not important when using JSON. Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.  \n  \n### JSON Types  \n The JSON type does not have to match the preceding table on deserialization. For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number. That is, both {\"q\":42} and {\"q\":\"42\"} are valid if there is an `Int` data member called \"q\".  \n  \n### Polymorphism  \n Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected. This is supported for JSON serialization by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] comparable to the way XML serialization is supported. For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.  \n  \n Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type. For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string. If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned. The deserializer does not know that the string was initially of type <xref:System.Uri>. Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been. A JSON boolean maps to a .NET <xref:System.Boolean>. However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.  \n  \n When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.  \n  \n When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required. For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes. For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).  \n  \n For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.  \n  \n### Versioning  \n The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON. Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md). Remember that JSON is unordered so any order information is lost. Furthermore, JSON does not support multiple key/value pairs with the same key name. Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.  \n  \n## JSON in URLs  \n When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body. JSON is supported even in the request URL, so if you have an operation that takes an `Int` called \"number\" and a `Person` complex type called \"p\", the URL may resemble the following URL.  \n  \n```  \nhttp://example.com/myservice.svc/MyOperation?number=7&p={\"name\":\"John\",\"age\":42}  \n```  \n  \n If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen. JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.  \n  \n## Advanced information  \n  \n### ISerializable Support  \n  \n#### Supported and Unsupported ISerializable Types  \n In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON. However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:  \n  \n-   With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance. This leads to a polymorphic situation similar to deserializing types into an object. As mentioned before, this may lead to loss of type information in JSON. For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double). So the fact that the number used to be an `enum` value is lost.  \n  \n-   An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.  \n  \n#### Factory Types  \n While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the \"factory type\" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.  \n  \n### DateTime Wire Format  \n <xref:System.DateTime> values appear as JSON strings in the form of \"/Date(700000+0500)/\", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970. The number may be negative to represent earlier times. The part that consists of \"+0500\" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind> kind - that is, should be converted to the local time zone on deserialization. If it is absent, the time is deserialized as <xref:System.DateTimeKind>. The actual number (\"0500\" in this example) and its sign (+ or -) are ignored.  \n  \n When serializing <xref:System.DateTime>, <xref:System.DateTimeKind> and <xref:System.DateTimeKind> times are written with an offset, and <xref:System.DateTimeKind> is written without.  \n  \n The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances. If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.  \n  \n The conversion only takes place if the \"/\" characters are escaped (that is, the JSON looks like \"\\\\/Date(700000+0500)\\\\/\"), and for this reason [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the \"/\" character.  \n  \n### XML in JSON Strings  \n  \n#### XmlElement  \n <xref:System.Xml.XmlElement> is serialized as is, with no wrapping. For example, data member \"x\" of type <xref:System.Xml.XmlElement> that contains \\<abc/> is as represented as follows.  \n  \n```  \n{\"x\":\"<abc/>\"}  \n```  \n  \n#### Arrays of XmlNode  \n <xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type. If \"x\" is an array that contains attribute node \"N\" in namespace \"ns\" that contains \"value\" and an empty element node \"M\", the representation is as follows.  \n  \n```  \n{\"x\":\"<ArrayOfXmlNode xmlns=\\\"http://schemas.datacontract.org/2004/07/System.Xml\\\" a:N=\\\"value\\\" xmlns:a=\\\"ns\\\"><M/></ArrayOfXmlNode>\"}  \n```  \n  \n Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.  \n  \n#### IXmlSerializable Types including XElement and DataSet  \n <xref:System.Runtime.Serialization.ISerializable> types subdivide into \"content types\", \"DataSet types\" and \"element types\". For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).  \n  \n \"Content\" and \"DataSet\" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section. They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.  \n  \n \"Element\" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.  \n  \n### Polymorphism  \n  \n#### Preserving Type Information  \n As stated earlier, polymorphism is supported in JSON with some limitations. JavaScript is a weakly-typed language and type identity is normally not an issue. However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity. For example, types with data contract names \"Square\" and \"Circle\" derive from a type with a data contract name of \"Shape\". If \"Circle\" is sent from .NET to JavaScript and is later returned to a .NET method that expects \"Shape\", it is useful for the .NET side to know that the object in question was originally a \"Circle\" - otherwise any information specific to the derived type (for example, \"radius\" data member on \"Circle\") may be lost.  \n  \n To preserve type identity, when serializing complex types to JSON a \"type hint\" can be added, and the deserializer recognizes the hint and acts appropriately. The \"type hint\" is a JSON key/value pair with the key name of \"__type\" (two underscores followed by the word \"type\"). The value is a JSON string of the form \"DataContractName:DataContractNamespace\" (anything up to the first colon is the name). Using the earlier example, \"Circle\" can be serialized as follows.  \n  \n```  \n{\"__type\":\"Circle:http://example.com/myNamespace\",\"x\":50,\"y\":70,\"radius\":10}  \n```  \n  \n The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.  \n  \n Data members called \"__type\" are forbidden due to potential conflict with the type hint.  \n  \n#### Reducing the Size of Type Hints  \n To reduce the size of JSON messages, the default data contract namespace prefix (http://schemas.datacontract.org/2004/07/) is replaced with the \"#\" character. (To make this replacement reversible, an escaping rule is used: if the namespace starts with the \"#\" or \"\\\\\" characters, they are appended with an extra \"\\\\\" character). Thus, if \"Circle\" is a type in the .NET namespace \"MyApp.Shapes\", its default data contract namespace is http://schemas.datacontract.org/2004/07/MyApp. Shapes and the JSON representation is as follows.  \n  \n```  \n{\"__type\":\"Circle:#MyApp.Shapes\",\"x\":50,\"y\":70,\"radius\":10}  \n```  \n  \n Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.  \n  \n#### Type Hint Position in JSON Objects  \n Note that the type hint must appear first in the JSON representation. This is the only case where order of key/value pairs is important in JSON processing. For example, the following is not a valid way to specify the type hint.  \n  \n```  \n{\"x\":50,\"y\":70,\"radius\":10,\"__type\":\"Circle:#MyApp.Shapes\"}  \n```  \n  \n Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and ASP.NET AJAX client pages always emit the type hint first.  \n  \n#### Type Hints Apply Only to Complex Types  \n There is no way to emit a type hint for non-complex types. For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved. However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost. This applies not only to primitive types but also to collections and arrays.  \n  \n#### When Are Type Hints Emitted  \n Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible). Therefore, the following rules govern whether type hints are emitted:  \n  \n-   When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle. (This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)  \n  \n-   When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle. This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients. Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.  \n  \n-   When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being \"`false`\" (only emit type hints when required).  \n  \n#### Duplicate Data Member Names  \n Derived type information is present in the same JSON object together with base type information, and can occur in any order. For example, `Shape` may be represented as follows.  \n  \n```  \n{\"__type\":\"Shape:#MyApp.Shapes\",\"x\":50,\"y\":70}  \n```  \n  \n Whereas Circle may be represented as follows.  \n  \n```  \n{\"__type\":\"Circle:#MyApp.Shapes\",\"x\":50, \"radius\":10,\"y\":70}  \n```  \n  \n If the base `Shape` type also contained a data member called \"`radius`\", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether \"radius\" refers to `Shape.radius` or `Circle.radius`). Therefore, while the concept of \"property hiding\" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.  \n  \n#### Polymorphism and IXmlSerializable Types  \n <xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules. However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.  \n  \n#### Polymorphism and Certain Interface Types  \n It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected. For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`. It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`. This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.  \n  \n#### Known Types and Configuration  \n All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>. Both serializers read the same configuration element, [\\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.  \n  \n#### Collections Assigned to Object  \n Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type. For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.  \n  \n```  \n[{\"__type\":\"Shape:#MyApp.Shapes\",\"x\":50,\"y\":70},  \n{\"__type\":\"Shape:#MyApp.Shapes\",\"x\":58,\"y\":73},  \n{\"__type\":\"Shape:#MyApp.Shapes\",\"x\":41,\"y\":32}]  \n```  \n  \n When deserialized back into <xref:System.Object>:  \n  \n-   `Shape` must be in the Known Types list. Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect. Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.  \n  \n-   The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.  \n  \n#### Derived Collections Assigned to Base Collections  \n When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type. However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.  \n  \n#### Type Hints and Dictionaries  \n When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.  \n  \n When serializing dictionary types, the JSON object that contains the \"Key\" and \"Value\" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.  \n  \n### Valid JSON Key Names  \n The serializer XML-encodes key names that are not valid XML names. For example, a data member with the name of \"123\" would have an encoded name such as \"_x0031\\__x0032\\__x0033\\_\" because \"123\" is an invalid XML element name (starts with a digit). A similar situation may arise with some international character sets not valid in XML names. For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).  \n  \n## See Also  \n [Support for JSON and Other Data Transfer Formats](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)","nodes":[{"pos":[12,59],"content":"Stand-Alone JSON Serialization | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Stand-Alone JSON Serialization | Microsoft Docs","pos":[0,47]}]},{"pos":[358,388],"content":"Stand-Alone JSON Serialization","linkify":"Stand-Alone JSON Serialization","nodes":[{"content":"Stand-Alone JSON Serialization","pos":[0,30]}]},{"content":"JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.","pos":[389,540]},{"content":"It is the default data format used by ASP.NET AJAX services created in <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph>.","pos":[541,668],"source":" It is the default data format used by ASP.NET AJAX services created in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]."},{"content":"This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.","pos":[675,823]},{"content":"Finally, if you require JSON support but are not creating an AJAX service, the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.","pos":[830,1108],"source":"Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types."},{"content":"For a description of how to do this, see <bpt id=\"p1\">[</bpt>How to: Serialize and Deserialize JSON Data<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)</ept>.","pos":[1109,1290],"source":" For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)."},{"content":"When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.","pos":[1297,1462],"source":"When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>."},{"content":"For a list of the types supported, see <bpt id=\"p1\">[</bpt>Types Supported by the Data Contract Serializer<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</ept>.","pos":[1463,1651],"source":" For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)."},{"content":"This includes most primitive types, most array and collection types, as well as complex types that use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph>.","pos":[1652,1877],"source":" This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>."},{"pos":[1886,1918],"content":"Mapping .NET types to JSON Types","linkify":"Mapping .NET types to JSON Types","nodes":[{"content":"Mapping .NET types to JSON Types","pos":[0,32]}]},{"content":"The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.","pos":[1922,2072]},{"content":".NET Types","pos":[2079,2089]},{"content":"JSON/JavaScript","pos":[2090,2105]},{"content":"Notes","pos":[2106,2111]},{"content":"All numeric types, for example <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Decimal&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Double&gt;</ph>","pos":[2172,2269],"source":"All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>"},{"content":"Number","pos":[2270,2276]},{"pos":[2277,2416],"content":"Special values such as  <ph id=\"ph1\">`Double.NaN`</ph>, <ph id=\"ph2\">`Double.PositiveInfinity`</ph> and <ph id=\"ph3\">`Double.NegativeInfinity`</ph> are not supported and result in invalid JSON.","source":"Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON."},{"content":"Number","pos":[2440,2446]},{"content":"See \"Enumerations and JSON\" later in this topic.","pos":[2447,2495]},{"content":"Boolean","pos":[2522,2529]},{"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Char&gt;</ph>","pos":[2537,2577],"source":"<xref:System.String>, <xref:System.Char>"},{"content":"String","pos":[2578,2584]},{"content":"<ph id=\"ph1\">&lt;xref:System.TimeSpan&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Guid&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Uri&gt;</ph>","pos":[2592,2653],"source":"<xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri>"},{"content":"String","pos":[2654,2660]},{"content":"The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the \"12345678-ABCD-ABCD-ABCD-1234567890AB\" format and URI in its natural string form like \"http://www.example.com\").","pos":[2661,2897]},{"content":"For precise information, see <bpt id=\"p1\">[</bpt>Data Contract Schema Reference<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.","pos":[2898,3042],"source":" For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)."},{"content":"String","pos":[3082,3088]},{"content":"The format is \"name:namespace\" (anything before the first colon is the name).","pos":[3089,3166]},{"content":"Either the name or the namespace can be missing.","pos":[3167,3215]},{"content":"If there is no namespace the colon can be omitted as well.","pos":[3216,3274]},{"content":"<ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> of type <ph id=\"ph2\">&lt;xref:System.Byte&gt;</ph>","pos":[3279,3325],"source":"<xref:System.Array> of type <xref:System.Byte>"},{"content":"Array of numbers","pos":[3326,3342]},{"content":"Each number represents the value of one byte.","pos":[3343,3388]},{"content":"DateTime or String","pos":[3416,3434]},{"content":"See Dates/Times and JSON later in this topic.","pos":[3435,3480]},{"content":"Complex type","pos":[3514,3526]},{"content":"See Dates/Times and JSON later in this topic.","pos":[3527,3572]},{"content":"XML and ADO.NET types (<ph id=\"ph1\">&lt;xref:System.Xml.XmlElement&gt;</ph>,","pos":[3577,3629],"source":"XML and ADO.NET types (<xref:System.Xml.XmlElement>,"},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.","pos":[3642,3674],"source":"<xref:System.Xml.Linq.XElement>."},{"content":"Arrays of <ph id=\"ph1\">&lt;xref:System.Xml.XmlNode&gt;</ph>,","pos":[3675,3711],"source":" Arrays of <xref:System.Xml.XmlNode>,"},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>,","pos":[3724,3774],"source":"<xref:System.Runtime.Serialization.ISerializable>,"},{"content":"<ph id=\"ph1\">&lt;xref:System.Data.DataSet&gt;</ph>).","pos":[3787,3815],"source":"<xref:System.Data.DataSet>)."},{"content":"String","pos":[3816,3822]},{"content":"See the XML Types and JSON section of this topic.","pos":[3823,3872]},{"content":"Empty complex type","pos":[3898,3916]},{"content":"Collections, dictionaries, and arrays","pos":[3924,3961]},{"content":"Array","pos":[3962,3967]},{"content":"See the Collections, Dictionaries, and Arrays section of this topic.","pos":[3968,4036]},{"content":"Complex types (with the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.SerializableAttribute&gt;</ph> applied)","pos":[4041,4170],"source":"Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)"},{"content":"Complex type","pos":[4171,4183]},{"content":"Data members become members of the JavaScript complex type.","pos":[4184,4243]},{"content":"Complex types implementing the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface)","pos":[4248,4339],"source":"Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)"},{"content":"Complex type","pos":[4340,4352]},{"content":"Same as other complex types but some <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.","pos":[4353,4551],"source":"Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic."},{"pos":[4556,4581],"content":"<ph id=\"ph1\">`Null`</ph> value for any type","source":"`Null` value for any type"},{"content":"Null","pos":[4582,4586]},{"content":"Nullable types are also supported and map to JSON in the same way as non-nullable types.","pos":[4587,4675]},{"pos":[4686,4707],"content":"Enumerations and JSON","linkify":"Enumerations and JSON","nodes":[{"content":"Enumerations and JSON","pos":[0,21]}]},{"content":"Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.","pos":[4711,4873]},{"content":"<ph id=\"ph1\">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> the data contract treatment, see <bpt id=\"p1\">[</bpt>Enumeration Types in Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)</ept>.","pos":[4874,5088],"source":"[!INCLUDE[crabout](../../../../includes/crabout-md.md)] the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)."},{"pos":[5098,5248],"content":"For example, if you have <ph id=\"ph1\">`public enum Color {red, green, blue, yellow, pink}`</ph>, serializing <ph id=\"ph2\">`yellow`</ph> produces the number 3 and not the string \"yellow\".","source":"For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string \"yellow\"."},{"content":"All <ph id=\"ph1\">`enum`</ph> members are serializable.","pos":[5258,5294],"source":"All `enum` members are serializable."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.EnumMemberAttribute&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.NonSerializedAttribute&gt;</ph> attributes are ignored if used.","pos":[5295,5431],"source":" The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used."},{"pos":[5441,5632],"content":"It is possible to deserialize a nonexistent <ph id=\"ph1\">`enum`</ph> value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.","source":"It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined."},{"pos":[5642,5716],"content":"A flags <ph id=\"ph1\">`enum`</ph> is not special and is treated the same as any other <ph id=\"ph2\">`enum`</ph>.","source":"A flags `enum` is not special and is treated the same as any other `enum`."},{"pos":[5726,5746],"content":"Dates/Times and JSON","linkify":"Dates/Times and JSON","nodes":[{"content":"Dates/Times and JSON","pos":[0,20]}]},{"content":"The JSON format does not directly support dates and times.","pos":[5750,5808]},{"content":"However, they are very commonly used and ASP.NET AJAX provides special support for these types.","pos":[5809,5904]},{"content":"When using ASP.NET AJAX proxies, the <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> type in .NET fully corresponds to the <ph id=\"ph2\">`DateTime`</ph> type in JavaScript.","pos":[5905,6033],"source":" When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript."},{"content":"When not using ASP.NET, a <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.","pos":[6043,6222],"source":"When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic."},{"content":"<ph id=\"ph1\">&lt;xref:System.DateTimeOffset&gt;</ph> is represented in JSON as a complex type: {\"DateTime\":dateTime,\"OffsetMinutes\":offsetMinutes}.","pos":[6232,6355],"source":"<xref:System.DateTimeOffset> is represented in JSON as a complex type: {\"DateTime\":dateTime,\"OffsetMinutes\":offsetMinutes}."},{"content":"The <ph id=\"ph1\">`offsetMinutes`</ph> member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.","pos":[6356,6552],"source":" The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest."},{"content":"The <ph id=\"ph1\">`dateTime`</ph> member represents the instance in time when the event of interest occurred (again, it becomes a <ph id=\"ph2\">`DateTime`</ph> in JavaScript when ASP.NET AJAX is in use and a string when it is not).","pos":[6553,6746],"source":" The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not)."},{"content":"On serialization, the <ph id=\"ph1\">`dateTime`</ph> member is always serialized in GMT.","pos":[6747,6815],"source":" On serialization, the `dateTime` member is always serialized in GMT."},{"content":"So, if describing 3:00 AM New York time, <ph id=\"ph1\">`dateTime`</ph> has a time component of 8:00 AM and <ph id=\"ph2\">`offsetMinutes`</ph> are 300 (minus 300 minutes or 5 hours from GMT).","pos":[6816,6968],"source":" So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT)."},{"pos":[6980,7210],"content":"[!NOTE]\n<xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision. Sub-millisecond values (micro/nanoseconds) are lost during serialization.","leadings":["","    >  "],"nodes":[{"content":"<xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision. Sub-millisecond values (micro/nanoseconds) are lost during serialization.","pos":[8,223],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.DateTimeOffset&gt;</ph> objects, when serialized to JSON, only preserve information to millisecond precision.","pos":[0,141],"source":"<xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision."},{"content":"Sub-millisecond values (micro/nanoseconds) are lost during serialization.","pos":[142,215]}]}]},{"pos":[7220,7238],"content":"XML Types and JSON","linkify":"XML Types and JSON","nodes":[{"content":"XML Types and JSON","pos":[0,18]}]},{"content":"XML types become JSON strings.","pos":[7242,7272]},{"content":"For example, if a data member \"q\" of type XElement contains <ph id=\"ph1\">\\&lt;</ph>abc/&gt;, the JSON is {\"q\":\"<ph id=\"ph2\">\\&lt;</ph>abc/&gt;\"}.","pos":[7282,7379],"source":"For example, if a data member \"q\" of type XElement contains \\<abc/>, the JSON is {\"q\":\"\\<abc/>\"}."},{"content":"There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.","pos":[7389,7531]},{"content":"If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A&gt;</ph> property to XML on <ph id=\"ph2\">&lt;xref:System.ServiceModel.Web.WebGetAttribute&gt;</ph> or the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A&gt;</ph> property to XML on the <ph id=\"ph4\">&lt;xref:System.ServiceModel.Web.WebInvokeAttribute&gt;</ph>.","pos":[7541,7938],"source":"If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>."},{"pos":[7948,7984],"content":"Collections, Dictionaries and Arrays","linkify":"Collections, Dictionaries and Arrays","nodes":[{"content":"Collections, Dictionaries and Arrays","pos":[0,36]}]},{"content":"All collections, dictionaries, and arrays are represented in JSON as arrays.","pos":[7988,8064]},{"content":"Any customization that uses the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> is ignored in the JSON representation.","pos":[8074,8212],"source":"Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation."},{"content":"Dictionaries are not a way to work directly with JSON.","pos":[8222,8276]},{"content":"Dictionary<ph id=\"ph1\">\\&lt;</ph>string,object&gt; may not be supported in the same way in <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> as expected from working with other JSON technologies.","pos":[8277,8454],"source":" Dictionary\\<string,object> may not be supported in the same way in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] as expected from working with other JSON technologies."},{"content":"For example, if \"abc\" is mapped to \"xyz\" and \"def\" is mapped to 42 in a dictionary, the JSON representation is not {\"abc\":\"xyz\",\"def\":42} but is [{\"Key\":\"abc\",\"Value\":\"xyz\"},{\"Key\":\"def\",\"Value\":42}] instead.","pos":[8455,8663]},{"content":"If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:","pos":[8673,8823]},{"pos":[8837,8986],"content":"Consider using the <bpt id=\"p1\">[</bpt>Weakly-typed JSON Serialization (AJAX)<ept id=\"p1\">](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)</ept> sample.","source":"Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample."},{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.","pos":[9000,9270],"source":"Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios."},{"pos":[9284,9451],"content":"Consider working with the <bpt id=\"p1\">[</bpt>Mapping Between JSON and XML<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)</ept> instead of using a serializer.","source":"Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer."},{"content":"<bpt id=\"p1\">*</bpt>Polymorphism<ept id=\"p1\">*</ept> in the context of serialization refers to the ability to serialize a derived type where its base type is expected.","pos":[9465,9594],"source":"*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected."},{"content":"There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>.","pos":[9595,9742],"source":" There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>."},{"content":"This issue is more fully discussed in the Advanced Information section later in this topic.","pos":[9743,9834]},{"pos":[9843,9861],"content":"Additional Details","linkify":"Additional Details","nodes":[{"content":"Additional Details","pos":[0,18]}]},{"pos":[9871,9892],"content":"Order of Data Members","linkify":"Order of Data Members","nodes":[{"content":"Order of Data Members","pos":[0,21]}]},{"content":"Order of data members is not important when using JSON.","pos":[9896,9951]},{"content":"Specifically, even if <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A&gt;</ph> is set, JSON data can still be deserialized in any order.","pos":[9952,10096],"source":" Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order."},{"pos":[10106,10116],"content":"JSON Types","linkify":"JSON Types","nodes":[{"content":"JSON Types","pos":[0,10]}]},{"content":"The JSON type does not have to match the preceding table on deserialization.","pos":[10120,10196]},{"content":"For example, an <ph id=\"ph1\">`Int`</ph> normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.","pos":[10197,10362],"source":" For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number."},{"content":"That is, both {\"q\":42} and {\"q\":\"42\"} are valid if there is an <ph id=\"ph1\">`Int`</ph> data member called \"q\".","pos":[10363,10455],"source":" That is, both {\"q\":42} and {\"q\":\"42\"} are valid if there is an `Int` data member called \"q\"."},{"pos":[10465,10477],"content":"Polymorphism","linkify":"Polymorphism","nodes":[{"content":"Polymorphism","pos":[0,12]}]},{"content":"Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.","pos":[10481,10591]},{"content":"This is supported for JSON serialization by <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> comparable to the way XML serialization is supported.","pos":[10592,10745],"source":" This is supported for JSON serialization by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] comparable to the way XML serialization is supported."},{"content":"For example, you can serialize <ph id=\"ph1\">`MyDerivedType`</ph> where <ph id=\"ph2\">`MyBaseType`</ph> is expected, or serialize <ph id=\"ph3\">`Int`</ph> where <ph id=\"ph4\">`Object`</ph> is expected.","pos":[10746,10871],"source":" For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected."},{"content":"Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.","pos":[10878,11015]},{"content":"For example, if <ph id=\"ph1\">&lt;xref:System.Uri&gt;</ph> is serialized where <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> is expected, it results in a JSON string.","pos":[11016,11132],"source":" For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string."},{"content":"If this string is then deserialized back into <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, a .NET <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> is returned.","pos":[11133,11241],"source":" If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned."},{"content":"The deserializer does not know that the string was initially of type <ph id=\"ph1\">&lt;xref:System.Uri&gt;</ph>.","pos":[11242,11329],"source":" The deserializer does not know that the string was initially of type <xref:System.Uri>."},{"content":"Generally, when expecting <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <ph id=\"ph2\">&lt;xref:System.Array&gt;</ph> of type <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>, regardless of what the actual original type had been.","pos":[11330,11638],"source":" Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been."},{"content":"A JSON boolean maps to a .NET <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph>.","pos":[11639,11691],"source":" A JSON boolean maps to a .NET <xref:System.Boolean>."},{"content":"However when expecting an <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, JSON numbers are deserialized as either .NET <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Decimal&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Double&gt;</ph>, where the most appropriate type is automatically picked.","pos":[11692,11909],"source":" However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked."},{"content":"When deserializing into an interface type, the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> deserializes as if the declared type were object.","pos":[11916,12080],"source":"When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object."},{"content":"When working with your own base and derived types, using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceKnownTypeAttribute&gt;</ph> or an equivalent mechanism is normally required.","pos":[12087,12305],"source":"When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required."},{"content":"For example, if you have an operation that has an <ph id=\"ph1\">`Animal`</ph> return value and it actually returns an instance of <ph id=\"ph2\">`Cat`</ph> (derived from <ph id=\"ph3\">`Animal`</ph>), you should either apply the <ph id=\"ph4\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph>, to the <ph id=\"ph5\">`Animal`</ph> type or the <ph id=\"ph6\">&lt;xref:System.ServiceModel.ServiceKnownTypeAttribute&gt;</ph> to the operation and specify the <ph id=\"ph7\">`Cat`</ph> type in these attributes.","pos":[12306,12677],"source":" For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Data Contract Known Types<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</ept>.","pos":[12678,12809],"source":" For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)."},{"content":"For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.","pos":[12816,13006]},{"pos":[13016,13026],"content":"Versioning","linkify":"Versioning","nodes":[{"content":"Versioning","pos":[0,10]}]},{"content":"The data contract versioning features, including the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface, are fully supported in JSON.","pos":[13030,13180],"source":"The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON."},{"content":"Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph>.","pos":[13181,13429],"source":" Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>."},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Forward-Compatible Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>.","pos":[13430,13610],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)."},{"content":"Remember that JSON is unordered so any order information is lost.","pos":[13611,13676]},{"content":"Furthermore, JSON does not support multiple key/value pairs with the same key name.","pos":[13677,13760]},{"content":"Finally, all operations on <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> are inherently polymorphic - that is their derived type are assigned to <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, the base type for all types.","pos":[13761,13968],"source":" Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types."},{"pos":[13977,13989],"content":"JSON in URLs","linkify":"JSON in URLs","nodes":[{"content":"JSON in URLs","pos":[0,12]}]},{"content":"When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Web.WebGetAttribute&gt;</ph> attribute), incoming parameters appear in the request URL instead of the message body.","pos":[13993,14194],"source":"When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body."},{"content":"JSON is supported even in the request URL, so if you have an operation that takes an <ph id=\"ph1\">`Int`</ph> called \"number\" and a <ph id=\"ph2\">`Person`</ph> complex type called \"p\", the URL may resemble the following URL.","pos":[14195,14381],"source":" JSON is supported even in the request URL, so if you have an operation that takes an `Int` called \"number\" and a `Person` complex type called \"p\", the URL may resemble the following URL."},{"content":"If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.","pos":[14486,14638]},{"content":"JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.","pos":[14639,14697]},{"pos":[14706,14726],"content":"Advanced information","linkify":"Advanced information","nodes":[{"content":"Advanced information","pos":[0,20]}]},{"pos":[14736,14757],"content":"ISerializable Support","linkify":"ISerializable Support","nodes":[{"content":"ISerializable Support","pos":[0,21]}]},{"pos":[14768,14813],"content":"Supported and Unsupported ISerializable Types","linkify":"Supported and Unsupported ISerializable Types","nodes":[{"content":"Supported and Unsupported ISerializable Types","pos":[0,45]}]},{"content":"In general, types that implement the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface are fully supported when serializing/deserializing JSON.","pos":[14817,14970],"source":"In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON."},{"content":"However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:","pos":[14971,15153]},{"content":"With <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>, the type of individual data members is never known in advance.","pos":[15163,15281],"source":"With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance."},{"content":"This leads to a polymorphic situation similar to deserializing types into an object.","pos":[15282,15366]},{"content":"As mentioned before, this may lead to loss of type information in JSON.","pos":[15367,15438]},{"content":"For example, a type that serializes an <ph id=\"ph1\">`enum`</ph> in its <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> implementation and attempts to deserialize back directly into an <ph id=\"ph3\">`enum`</ph> (without proper casts) fails, because an <ph id=\"ph4\">`enum`</ph> is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).","pos":[15439,15787],"source":" For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double)."},{"content":"So the fact that the number used to be an <ph id=\"ph1\">`enum`</ph> value is lost.","pos":[15788,15851],"source":" So the fact that the number used to be an `enum` value is lost."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.","pos":[15861,16119],"source":"An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order."},{"pos":[16130,16143],"content":"Factory Types","linkify":"Factory Types","nodes":[{"content":"Factory Types","pos":[0,13]}]},{"content":"While the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IObjectReference&gt;</ph> interface is supported in JSON in general, any types that require the \"factory type\" feature (returning an instance of a different type from <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29&gt;</ph> than the type that implements the interface) are not supported.","pos":[16147,16532],"source":"While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the \"factory type\" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported."},{"pos":[16542,16562],"content":"DateTime Wire Format","linkify":"DateTime Wire Format","nodes":[{"content":"DateTime Wire Format","pos":[0,20]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> values appear as JSON strings in the form of \"/Date(700000+0500)/\", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.","pos":[16566,16833],"source":"<xref:System.DateTime> values appear as JSON strings in the form of \"/Date(700000+0500)/\", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970."},{"content":"The number may be negative to represent earlier times.","pos":[16834,16888]},{"content":"The part that consists of \"+0500\" in the example is optional and indicates that the time is of the <ph id=\"ph1\">&lt;xref:System.DateTimeKind&gt;</ph> kind - that is, should be converted to the local time zone on deserialization.","pos":[16889,17093],"source":" The part that consists of \"+0500\" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind> kind - that is, should be converted to the local time zone on deserialization."},{"content":"If it is absent, the time is deserialized as <ph id=\"ph1\">&lt;xref:System.DateTimeKind&gt;</ph>.","pos":[17094,17166],"source":" If it is absent, the time is deserialized as <xref:System.DateTimeKind>."},{"content":"The actual number (\"0500\" in this example) and its sign (+ or -) are ignored.","pos":[17167,17244]},{"content":"When serializing <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.DateTimeKind&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.DateTimeKind&gt;</ph> times are written with an offset, and <ph id=\"ph4\">&lt;xref:System.DateTimeKind&gt;</ph> is written without.","pos":[17251,17434],"source":"When serializing <xref:System.DateTime>, <xref:System.DateTimeKind> and <xref:System.DateTimeKind> times are written with an offset, and <xref:System.DateTimeKind> is written without."},{"content":"The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript <ph id=\"ph1\">`DateTime`</ph> instances.","pos":[17441,17554],"source":"The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances."},{"content":"If there are other strings that have a similar form that are not of type <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> in .NET, they are converted as well.","pos":[17555,17687],"source":" If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well."},{"pos":[17694,18001],"content":"The conversion only takes place if the \"/\" characters are escaped (that is, the JSON looks like \"<ph id=\"ph1\">\\\\</ph>/Date(700000+0500)<ph id=\"ph2\">\\\\</ph>/\"), and for this reason <ph id=\"ph3\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>'s JSON encoder (enabled by the <ph id=\"ph4\">&lt;xref:System.ServiceModel.WebHttpBinding&gt;</ph>) always escapes the \"/\" character.","source":"The conversion only takes place if the \"/\" characters are escaped (that is, the JSON looks like \"\\\\/Date(700000+0500)\\\\/\"), and for this reason [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the \"/\" character."},{"pos":[18011,18030],"content":"XML in JSON Strings","linkify":"XML in JSON Strings","nodes":[{"content":"XML in JSON Strings","pos":[0,19]}]},{"pos":[18041,18051],"content":"XmlElement","linkify":"XmlElement","nodes":[{"content":"XmlElement","pos":[0,10]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.XmlElement&gt;</ph> is serialized as is, with no wrapping.","pos":[18055,18122],"source":"<xref:System.Xml.XmlElement> is serialized as is, with no wrapping."},{"content":"For example, data member \"x\" of type <ph id=\"ph1\">&lt;xref:System.Xml.XmlElement&gt;</ph> that contains <ph id=\"ph2\">\\&lt;</ph>abc/&gt; is as represented as follows.","pos":[18123,18240],"source":" For example, data member \"x\" of type <xref:System.Xml.XmlElement> that contains \\<abc/> is as represented as follows."},{"pos":[18283,18300],"content":"Arrays of XmlNode","linkify":"Arrays of XmlNode","nodes":[{"content":"Arrays of XmlNode","pos":[0,17]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> objects of type <ph id=\"ph2\">&lt;xref:System.Xml.XmlNode&gt;</ph> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.","pos":[18304,18467],"source":"<xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type."},{"content":"If \"x\" is an array that contains attribute node \"N\" in namespace \"ns\" that contains \"value\" and an empty element node \"M\", the representation is as follows.","pos":[18468,18624]},{"content":"Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.","pos":[18784,18893]},{"pos":[18904,18957],"content":"IXmlSerializable Types including XElement and DataSet","linkify":"IXmlSerializable Types including XElement and DataSet","nodes":[{"content":"IXmlSerializable Types including XElement and DataSet","pos":[0,53]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> types subdivide into \"content types\", \"DataSet types\" and \"element types\".","pos":[18961,19085],"source":"<xref:System.Runtime.Serialization.ISerializable> types subdivide into \"content types\", \"DataSet types\" and \"element types\"."},{"content":"For definitions of these types, see <bpt id=\"p1\">[</bpt>XML and ADO.NET Types in Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)</ept>.","pos":[19086,19255],"source":" For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)."},{"content":"\"Content\" and \"DataSet\" types are serialized similar to <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> objects of <ph id=\"ph2\">&lt;xref:System.Xml.XmlNode&gt;</ph> discussed in the previous section.","pos":[19262,19409],"source":"\"Content\" and \"DataSet\" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section."},{"content":"They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.","pos":[19410,19542]},{"content":"\"Element\" types such as <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement&gt;</ph> are serialized as is, similar to <ph id=\"ph2\">&lt;xref:System.Xml.XmlElement&gt;</ph> previously discussed in this topic.","pos":[19549,19702],"source":"\"Element\" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic."},{"pos":[19712,19724],"content":"Polymorphism","linkify":"Polymorphism","nodes":[{"content":"Polymorphism","pos":[0,12]}]},{"pos":[19735,19762],"content":"Preserving Type Information","linkify":"Preserving Type Information","nodes":[{"content":"Preserving Type Information","pos":[0,27]}]},{"content":"As stated earlier, polymorphism is supported in JSON with some limitations.","pos":[19766,19841]},{"content":"JavaScript is a weakly-typed language and type identity is normally not an issue.","pos":[19842,19923]},{"content":"However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.","pos":[19924,20082]},{"content":"For example, types with data contract names \"Square\" and \"Circle\" derive from a type with a data contract name of \"Shape\".","pos":[20083,20205]},{"content":"If \"Circle\" is sent from .NET to JavaScript and is later returned to a .NET method that expects \"Shape\", it is useful for the .NET side to know that the object in question was originally a \"Circle\" - otherwise any information specific to the derived type (for example, \"radius\" data member on \"Circle\") may be lost.","pos":[20206,20521]},{"content":"To preserve type identity, when serializing complex types to JSON a \"type hint\" can be added, and the deserializer recognizes the hint and acts appropriately.","pos":[20528,20686]},{"content":"The \"type hint\" is a JSON key/value pair with the key name of \"__type\" (two underscores followed by the word \"type\").","pos":[20687,20804]},{"content":"The value is a JSON string of the form \"DataContractName:DataContractNamespace\" (anything up to the first colon is the name).","pos":[20805,20930]},{"content":"Using the earlier example, \"Circle\" can be serialized as follows.","pos":[20931,20996]},{"pos":[21097,21243],"content":"The type hint is very similar to the <ph id=\"ph1\">`xsi:type`</ph> attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.","source":"The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML."},{"content":"Data members called \"__type\" are forbidden due to potential conflict with the type hint.","pos":[21250,21338]},{"pos":[21349,21380],"content":"Reducing the Size of Type Hints","linkify":"Reducing the Size of Type Hints","nodes":[{"content":"Reducing the Size of Type Hints","pos":[0,31]}]},{"content":"To reduce the size of JSON messages, the default data contract namespace prefix (http://schemas.datacontract.org/2004/07/) is replaced with the \"#\" character.","pos":[21384,21542]},{"content":"(To make this replacement reversible, an escaping rule is used: if the namespace starts with the \"#\" or \"<ph id=\"ph1\">\\\\</ph>\" characters, they are appended with an extra \"<ph id=\"ph2\">\\\\</ph>\" character).","pos":[21543,21712],"source":" (To make this replacement reversible, an escaping rule is used: if the namespace starts with the \"#\" or \"\\\\\" characters, they are appended with an extra \"\\\\\" character)."},{"content":"Thus, if \"Circle\" is a type in the .NET namespace \"MyApp.Shapes\", its default data contract namespace is http://schemas.datacontract.org/2004/07/MyApp.","pos":[21713,21864]},{"content":"Shapes and the JSON representation is as follows.","pos":[21865,21914]},{"content":"Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.","pos":[21998,22140]},{"pos":[22151,22185],"content":"Type Hint Position in JSON Objects","linkify":"Type Hint Position in JSON Objects","nodes":[{"content":"Type Hint Position in JSON Objects","pos":[0,34]}]},{"content":"Note that the type hint must appear first in the JSON representation.","pos":[22189,22258]},{"content":"This is the only case where order of key/value pairs is important in JSON processing.","pos":[22259,22344]},{"content":"For example, the following is not a valid way to specify the type hint.","pos":[22345,22416]},{"pos":[22500,22703],"content":"Both the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> used by <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> and ASP.NET AJAX client pages always emit the type hint first.","source":"Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and ASP.NET AJAX client pages always emit the type hint first."},{"pos":[22714,22752],"content":"Type Hints Apply Only to Complex Types","linkify":"Type Hints Apply Only to Complex Types","nodes":[{"content":"Type Hints Apply Only to Complex Types","pos":[0,38]}]},{"content":"There is no way to emit a type hint for non-complex types.","pos":[22756,22814]},{"content":"For example, if an operation has an <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.","pos":[22815,22992],"source":" For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved."},{"content":"However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.","pos":[22993,23119]},{"content":"This applies not only to primitive types but also to collections and arrays.","pos":[23120,23196]},{"pos":[23207,23234],"content":"When Are Type Hints Emitted","linkify":"When Are Type Hints Emitted","nodes":[{"content":"When Are Type Hints Emitted","pos":[0,27]}]},{"content":"Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).","pos":[23238,23371]},{"content":"Therefore, the following rules govern whether type hints are emitted:","pos":[23372,23441]},{"content":"When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.","pos":[23451,23625]},{"content":"(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)","pos":[23626,23803]},{"content":"When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> but not when assigned to Circle.","pos":[23813,24043],"source":"When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle."},{"content":"This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.","pos":[24044,24246]},{"content":"Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.","pos":[24247,24362]},{"pos":[24372,24630],"content":"When using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> type, the <ph id=\"ph2\">`alwaysEmitTypeInformation`</ph> constructor parameter allows you to choose between the preceding two modes, with the default being \"<ph id=\"ph3\">`false`</ph>\" (only emit type hints when required).","source":"When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being \"`false`\" (only emit type hints when required)."},{"pos":[24641,24668],"content":"Duplicate Data Member Names","linkify":"Duplicate Data Member Names","nodes":[{"content":"Duplicate Data Member Names","pos":[0,27]}]},{"content":"Derived type information is present in the same JSON object together with base type information, and can occur in any order.","pos":[24672,24796]},{"content":"For example, <ph id=\"ph1\">`Shape`</ph> may be represented as follows.","pos":[24797,24848],"source":" For example, `Shape` may be represented as follows."},{"content":"Whereas Circle may be represented as follows.","pos":[24919,24964]},{"content":"If the base <ph id=\"ph1\">`Shape`</ph> type also contained a data member called \"<ph id=\"ph2\">`radius`</ph>\", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether \"radius\" refers to <ph id=\"ph3\">`Shape.radius`</ph> or <ph id=\"ph4\">`Circle.radius`</ph>).","pos":[25049,25330],"source":"If the base `Shape` type also contained a data member called \"`radius`\", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether \"radius\" refers to `Shape.radius` or `Circle.radius`)."},{"content":"Therefore, while the concept of \"property hiding\" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.","pos":[25331,25542]},{"pos":[25553,25592],"content":"Polymorphism and IXmlSerializable Types","linkify":"Polymorphism and IXmlSerializable Types","nodes":[{"content":"Polymorphism and IXmlSerializable Types","pos":[0,39]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.","pos":[25596,25790],"source":"<xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules."},{"content":"However, serializing an <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> type in place of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> results in loss of type information as the result is a JSON string.","pos":[25791,25969],"source":" However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string."},{"pos":[25980,26020],"content":"Polymorphism and Certain Interface Types","linkify":"Polymorphism and Certain Interface Types","nodes":[{"content":"Polymorphism and Certain Interface Types","pos":[0,40]}]},{"content":"It is forbidden to serialize a collection type or a type that implements <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> where a non-collection type that is not <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> (except for <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>) is expected.","pos":[26024,26281],"source":"It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected."},{"content":"For example, a custom interface called <ph id=\"ph1\">`IMyInterface`</ph> and a type <ph id=\"ph2\">`MyType`</ph> that implement both <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of type <ph id=\"ph4\">`int`</ph> and <ph id=\"ph5\">`IMyInterface`</ph>.","pos":[26282,26459],"source":" For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`."},{"content":"It is forbidden to return <ph id=\"ph1\">`MyType`</ph> from an operation whose return type is <ph id=\"ph2\">`IMyInterface`</ph>.","pos":[26460,26549],"source":" It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`."},{"content":"This is because <ph id=\"ph1\">`MyType`</ph> must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.","pos":[26550,26725],"source":" This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types."},{"pos":[26736,26765],"content":"Known Types and Configuration","linkify":"Known Types and Configuration","nodes":[{"content":"Known Types and Configuration","pos":[0,29]}]},{"content":"All of the Known Type mechanisms used by the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> are also supported in the same way by the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph>.","pos":[26769,26983],"source":"All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>."},{"content":"Both serializers read the same configuration element, <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>dataContractSerializer&gt;<ept id=\"p1\">](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md)</ept> in <bpt id=\"p2\">[</bpt><ph id=\"ph2\">\\&lt;</ph>system.runtime.serialization&gt;<ept id=\"p2\">](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)</ept>, to discover known types added through a configuration file.","pos":[26984,27371],"source":" Both serializers read the same configuration element, [\\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file."},{"pos":[27382,27412],"content":"Collections Assigned to Object","linkify":"Collections Assigned to Object","nodes":[{"content":"Collections Assigned to Object","pos":[0,30]}]},{"content":"Collections assigned to Object are serialized as if they are collections that implement <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>: a JSON array with each entry that has a type hint if it is a complex type.","pos":[27416,27629],"source":"Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type."},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of type <ph id=\"ph2\">`Shape`</ph> assigned to <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph> looks like the following.","pos":[27630,27762],"source":" For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following."},{"content":"When deserialized back into <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>:","pos":[27935,27984],"source":"When deserialized back into <xref:System.Object>:"},{"content":"<ph id=\"ph1\">`Shape`</ph> must be in the Known Types list.","pos":[27994,28034],"source":"`Shape` must be in the Known Types list."},{"content":"Having <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of type <ph id=\"ph2\">`Shape`</ph> in known types has no effect.","pos":[28035,28130],"source":" Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect."},{"content":"Note that you do not have to add <ph id=\"ph1\">`Shape`</ph> to known types on serialization in this case - this is done automatically.","pos":[28131,28246],"source":" Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically."},{"pos":[28256,28374],"content":"The collection is deserialized as an <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> of type <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> that contains <ph id=\"ph3\">`Shape`</ph> instances.","source":"The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances."},{"pos":[28385,28433],"content":"Derived Collections Assigned to Base Collections","linkify":"Derived Collections Assigned to Base Collections","nodes":[{"content":"Derived Collections Assigned to Base Collections","pos":[0,48]}]},{"content":"When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.","pos":[28437,28577]},{"content":"However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.","pos":[28578,28713]},{"pos":[28724,28751],"content":"Type Hints and Dictionaries","linkify":"Type Hints and Dictionaries","nodes":[{"content":"Type Hints and Dictionaries","pos":[0,27]}]},{"content":"When a dictionary is assigned to an <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, each Key and Value entry in the dictionary is treated as if it was assigned to <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> and gets a type hint.","pos":[28755,28934],"source":"When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint."},{"pos":[28941,29170],"content":"When serializing dictionary types, the JSON object that contains the \"Key\" and \"Value\" members is unaffected by the <ph id=\"ph1\">`alwaysEmitTypeInformation`</ph> setting and only contains a type hint when the preceding collection rules require it.","source":"When serializing dictionary types, the JSON object that contains the \"Key\" and \"Value\" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it."},{"pos":[29180,29200],"content":"Valid JSON Key Names","linkify":"Valid JSON Key Names","nodes":[{"content":"Valid JSON Key Names","pos":[0,20]}]},{"content":"The serializer XML-encodes key names that are not valid XML names.","pos":[29204,29270]},{"content":"For example, a data member with the name of \"123\" would have an encoded name such as \"_x0031<ph id=\"ph1\">\\_</ph>_x0032<ph id=\"ph2\">\\_</ph>_x0033<ph id=\"ph3\">\\_</ph>\" because \"123\" is an invalid XML element name (starts with a digit).","pos":[29271,29450],"source":" For example, a data member with the name of \"123\" would have an encoded name such as \"_x0031\\__x0032\\__x0033\\_\" because \"123\" is an invalid XML element name (starts with a digit)."},{"content":"A similar situation may arise with some international character sets not valid in XML names.","pos":[29451,29543]},{"content":"For an explanation of this effect of XML on JSON processing, see <bpt id=\"p1\">[</bpt>Mapping Between JSON and XML<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)</ept>.","pos":[29544,29720],"source":" For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)."},{"pos":[29729,29737],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[29741,29891],"content":"<bpt id=\"p1\">[</bpt>Support for JSON and Other Data Transfer Formats<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)</ept>","source":"[Support for JSON and Other Data Transfer Formats](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)"}]}