{"content":"---\ntitle: \"Dependency Property Security\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"wrappers [WPF], access\"\n  - \"wrappers [WPF], security\"\n  - \"dependency properties [WPF], security\"\n  - \"security [WPF], wrappers\"\n  - \"validation [WPF], dependency properties\"\n  - \"dependency properties [WPF], access\"\n  - \"security [WPF], dependency properties\"\nms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4\n---\n# Dependency Property Security\nDependency properties should generally be considered to be public properties. The nature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system prevents the ability to make security guarantees about a dependency property value.  \n\n<a name=\"AccessSecurity\"></a>   \n## Access and Security of Wrappers and Dependency Properties  \n Typically, dependency properties are implemented along with \"wrapper\" [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that simplify getting or setting the property from an instance. But the wrappers are really just convenience methods that implement the underlying <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> static calls that are used when interacting with dependency properties. Thinking of it in another way, the properties are exposed as [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that happen to be backed by a dependency property rather than by a private field. Security mechanisms applied to the wrappers do not parallel the property system behavior and access of the underlying dependency property. Placing a security demand on the wrapper will only prevent the usage of the convenience method but will not prevent calls to <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyObject.SetValue%2A>. Similarly, placing protected or private access level on the wrappers does not provide any effective security.  \n  \n If you are writing your own dependency properties, you should declare the wrappers and the <xref:System.Windows.DependencyProperty> identifier field as public members, so that callers do not get misleading information about the true access level of that property (because of its store being implemented as a dependency property).  \n  \n For a custom dependency property, you can register your property as a read-only dependency property, and this does provide an effective means of preventing a property being set by anyone that does not hold a reference to the <xref:System.Windows.DependencyPropertyKey> for that property. For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).  \n  \n> [!NOTE]\n>  Declaring a <xref:System.Windows.DependencyProperty> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered \"private\" in the same sense as the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language definitions define that access level, for reasons described in the next section.  \n  \n<a name=\"PropertySystemExposure\"></a>   \n## Property System Exposure of Dependency Properties  \n It is not generally useful, and it is potentially misleading, to declare a <xref:System.Windows.DependencyProperty> as any access level other than public. That access level setting only prevents someone from being able to get a reference to the instance from the declaring class. But there are several aspects of the property system that will return a <xref:System.Windows.DependencyProperty> as the means of identifying a particular property as it exists on an instance of a class or a derived class instance, and this identifier is still usable in a <xref:System.Windows.DependencyObject.SetValue%2A> call even if the original static identifier is declared as nonpublic. Also, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> virtual methods receive information of any existing dependency property that changed value. In addition, the <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> method returns identifiers for any property on instances with a locally set value.  \n  \n### Validation and Security  \n Applying a demand to a <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> and expecting the validation failure on a demand failure to prevent a property from being set is not an adequate security mechanism. Set-value invalidation enforced through <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> could also be suppressed by malicious callers, if those callers are operating within the application domain.  \n  \n## See also\n\n- [Custom Dependency Properties](custom-dependency-properties.md)\n","nodes":[{"pos":[4,401],"embed":true,"restype":"x-metadata","content":"title: \"Dependency Property Security\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"wrappers [WPF], access\"\n  - \"wrappers [WPF], security\"\n  - \"dependency properties [WPF], security\"\n  - \"security [WPF], wrappers\"\n  - \"validation [WPF], dependency properties\"\n  - \"dependency properties [WPF], access\"\n  - \"security [WPF], dependency properties\"\nms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4","nodes":[{"content":"Dependency Property Security","nodes":[{"pos":[0,28],"content":"Dependency Property Security","nodes":[{"content":"Dependency Property Security","pos":[0,28]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[408,436],"content":"Dependency Property Security","linkify":"Dependency Property Security","nodes":[{"content":"Dependency Property Security","pos":[0,28]}]},{"content":"Dependency properties should generally be considered to be public properties.","pos":[437,514]},{"content":"The nature of the <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> property system prevents the ability to make security guarantees about a dependency property value.","pos":[515,712],"source":" The nature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system prevents the ability to make security guarantees about a dependency property value."},{"pos":[752,809],"content":"Access and Security of Wrappers and Dependency Properties","linkify":"Access and Security of Wrappers and Dependency Properties","nodes":[{"content":"Access and Security of Wrappers and Dependency Properties","pos":[0,57]}]},{"content":"Typically, dependency properties are implemented along with \"wrapper\" <ph id=\"ph1\">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> properties that simplify getting or setting the property from an instance.","pos":[813,1025],"source":"Typically, dependency properties are implemented along with \"wrapper\" [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that simplify getting or setting the property from an instance."},{"content":"But the wrappers are really just convenience methods that implement the underlying <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> static calls that are used when interacting with dependency properties.","pos":[1026,1286],"source":" But the wrappers are really just convenience methods that implement the underlying <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> static calls that are used when interacting with dependency properties."},{"content":"Thinking of it in another way, the properties are exposed as <ph id=\"ph1\">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> properties that happen to be backed by a dependency property rather than by a private field.","pos":[1287,1508],"source":" Thinking of it in another way, the properties are exposed as [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that happen to be backed by a dependency property rather than by a private field."},{"content":"Security mechanisms applied to the wrappers do not parallel the property system behavior and access of the underlying dependency property.","pos":[1509,1647]},{"content":"Placing a security demand on the wrapper will only prevent the usage of the convenience method but will not prevent calls to <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>.","pos":[1648,1878],"source":" Placing a security demand on the wrapper will only prevent the usage of the convenience method but will not prevent calls to <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyObject.SetValue%2A>."},{"content":"Similarly, placing protected or private access level on the wrappers does not provide any effective security.","pos":[1879,1988]},{"pos":[1995,2324],"content":"If you are writing your own dependency properties, you should declare the wrappers and the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier field as public members, so that callers do not get misleading information about the true access level of that property (because of its store being implemented as a dependency property).","source":"If you are writing your own dependency properties, you should declare the wrappers and the <xref:System.Windows.DependencyProperty> identifier field as public members, so that callers do not get misleading information about the true access level of that property (because of its store being implemented as a dependency property)."},{"content":"For a custom dependency property, you can register your property as a read-only dependency property, and this does provide an effective means of preventing a property being set by anyone that does not hold a reference to the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> for that property.","pos":[2331,2618],"source":"For a custom dependency property, you can register your property as a read-only dependency property, and this does provide an effective means of preventing a property being set by anyone that does not hold a reference to the <xref:System.Windows.DependencyPropertyKey> for that property."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Read-Only Dependency Properties<ept id=\"p1\">](read-only-dependency-properties.md)</ept>.","pos":[2619,2715],"source":" For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md)."},{"pos":[2723,3166],"content":"[!NOTE]\n Declaring a <xref:System.Windows.DependencyProperty> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered \"private\" in the same sense as the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language definitions define that access level, for reasons described in the next section.","leadings":["","> "],"nodes":[{"content":"Declaring a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered \"private\" in the same sense as the <ph id=\"ph2\">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> language definitions define that access level, for reasons described in the next section.","pos":[9,441],"source":"Declaring a <xref:System.Windows.DependencyProperty> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered \"private\" in the same sense as the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language definitions define that access level, for reasons described in the next section."}]},{"pos":[3216,3265],"content":"Property System Exposure of Dependency Properties","linkify":"Property System Exposure of Dependency Properties","nodes":[{"content":"Property System Exposure of Dependency Properties","pos":[0,49]}]},{"content":"It is not generally useful, and it is potentially misleading, to declare a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as any access level other than public.","pos":[3269,3423],"source":"It is not generally useful, and it is potentially misleading, to declare a <xref:System.Windows.DependencyProperty> as any access level other than public."},{"content":"That access level setting only prevents someone from being able to get a reference to the instance from the declaring class.","pos":[3424,3548]},{"content":"But there are several aspects of the property system that will return a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as the means of identifying a particular property as it exists on an instance of a class or a derived class instance, and this identifier is still usable in a <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> call even if the original static identifier is declared as nonpublic.","pos":[3549,3941],"source":" But there are several aspects of the property system that will return a <xref:System.Windows.DependencyProperty> as the means of identifying a particular property as it exists on an instance of a class or a derived class instance, and this identifier is still usable in a <xref:System.Windows.DependencyObject.SetValue%2A> call even if the original static identifier is declared as nonpublic."},{"content":"Also, <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> virtual methods receive information of any existing dependency property that changed value.","pos":[3942,4099],"source":" Also, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> virtual methods receive information of any existing dependency property that changed value."},{"content":"In addition, the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> method returns identifiers for any property on instances with a locally set value.","pos":[4100,4265],"source":" In addition, the <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> method returns identifiers for any property on instances with a locally set value."},{"pos":[4275,4298],"content":"Validation and Security","linkify":"Validation and Security","nodes":[{"content":"Validation and Security","pos":[0,23]}]},{"content":"Applying a demand to a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.ValidateValueCallback%2A&gt;</ph> and expecting the validation failure on a demand failure to prevent a property from being set is not an adequate security mechanism.","pos":[4302,4523],"source":"Applying a demand to a <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> and expecting the validation failure on a demand failure to prevent a property from being set is not an adequate security mechanism."},{"content":"Set-value invalidation enforced through <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.ValidateValueCallback%2A&gt;</ph> could also be suppressed by malicious callers, if those callers are operating within the application domain.","pos":[4524,4738],"source":" Set-value invalidation enforced through <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> could also be suppressed by malicious callers, if those callers are operating within the application domain."},{"pos":[4747,4755],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4759,4822],"content":"<bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](custom-dependency-properties.md)</ept>","source":"[Custom Dependency Properties](custom-dependency-properties.md)"}]}