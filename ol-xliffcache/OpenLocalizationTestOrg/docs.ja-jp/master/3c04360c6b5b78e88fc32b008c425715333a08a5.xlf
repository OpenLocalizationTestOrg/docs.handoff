<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3c04360c6b5b78e88fc32b008c425715333a08a5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\advanced\xaml-resources.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">defe40a9acd418994121303bf9c123675495f673</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2012beda95dc6bee87b93005ef1a256f0803c399</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>XAML Resources | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>XAML Resources</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A resource is an object that can be reused in different places in your application.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Examples of resources include brushes and styles.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This overview describes how to use resources in              <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can also create and access resources by using code, or interchangeably between code and              <ph id="ph1">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For more information, see              <bpt id="p1">[</bpt>Resources and Code<ept id="p1">](../../../../docs/framework/wpf/advanced/resources-and-code.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The resource files described in this topic are different than the resource files described in                  <bpt id="p1">[</bpt>WPF Application Resource, Content, and Data Files<ept id="p1">](../../../../docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)</ept> and different than the embedded or linked resources described in                  <bpt id="p2">[</bpt>Managing Application Resources (.NET)<ept id="p2">](http://msdn.microsoft.com/library/f2582734-8ada-4baa-8a7c-e2ef943ddf7e)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Using Resources in XAML</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example defines a                  <ph id="ph1">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph> as a resource on the root element of a page.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The example then references the resource and uses it to set properties of several child elements, including an                  <ph id="ph1">&lt;xref:System.Windows.Shapes.Ellipse&gt;</ph>, a                  <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, and a                  <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>FEResourceSH_snip#XAML<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xaml)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Every framework-level element (                 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or                  <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>) has a                  <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Resources%2A&gt;</ph> property, which is the property that contains the resources (as a                  <ph id="ph4">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>) that a resource defines.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can define resources on any element.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>However, resources are most often defined on the root element, which is                  <ph id="ph1">&lt;xref:System.Windows.Controls.Page&gt;</ph> in the example.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Each resource in a resource dictionary must have a unique key.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When you define resources in markup, you assign the unique key through the                  <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](../../../../docs/framework/xaml-services/x-key-directive.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Typically, the key is a string; however, you can also set it to other object types by using the appropriate markup extensions.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Nonstring keys for resources are used by certain feature areas in                  <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, notably for styles, component resources, and data styling.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After you define a resource, you can reference the resource to be used for a property value by using a resource markup extension syntax that specifies the key name, for example:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>FEResourceSH_snip#KeyNameUsage<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#keynameusage)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In the preceding example, when the                  <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> loader processes the value                  <ph id="ph2">`{StaticResource MyBrush}`</ph> for the                  <ph id="ph3">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> property on                  <ph id="ph4">&lt;xref:System.Windows.Controls.Button&gt;</ph>, the resource lookup logic first checks the resource dictionary for the                  <ph id="ph5">&lt;xref:System.Windows.Controls.Button&gt;</ph> element.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If                  <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> does not have a definition of the resource key                  <ph id="ph2">`MyBrush`</ph> (it does not; its resource collection is empty), the lookup next checks the parent element of                  <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph>, which is                  <ph id="ph4">&lt;xref:System.Windows.Controls.Page&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Thus, when you define a resource on the                  <ph id="ph1">&lt;xref:System.Windows.Controls.Page&gt;</ph> root element, all the elements in the logical tree of the                  <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> can access it, and you can reuse the same resource for setting the value of any property that accepts the                  <ph id="ph3">&lt;xref:System.Type&gt;</ph> that the resource represents.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In the previous example, the same                  <ph id="ph1">`MyBrush`</ph> resource sets two different properties: the                  <ph id="ph2">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> of a                  <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph>, and the                  <ph id="ph4">&lt;xref:System.Windows.Shapes.Shape.Fill%2A&gt;</ph> of a                  <ph id="ph5">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Static and Dynamic Resources</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A resource can be referenced as either a static resource or a dynamic resource.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This is done by using either the                  <bpt id="p1">[</bpt>StaticResource Markup Extension<ept id="p1">](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)</ept> or the                  <bpt id="p2">[</bpt>DynamicResource Markup Extension<ept id="p2">](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A markup extension is a feature of                  <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> whereby you can specify an object reference by having the markup extension process the attribute string and return the object to a                  <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> loader.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For more information about markup extension behavior, see                  <bpt id="p1">[</bpt>Markup Extensions and WPF XAML<ept id="p1">](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When you use a markup extension, you typically provide one or more parameters in string form that are processed by that particular markup extension, rather than being evaluated in the context of the property being set.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The                  <bpt id="p1">[</bpt>StaticResource Markup Extension<ept id="p1">](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)</ept> processes a key by looking up the value for that key in all available resource dictionaries.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This happens during loading, which is the point in time when the loading process needs to assign the property value that takes the static resource reference.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The                  <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> instead processes a key by creating an expression, and that expression remains unevaluated until the application is actually run, at which time the expression is evaluated and provides a value.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When you reference a resource, the following considerations can influence whether you use a static resource reference or a dynamic resource reference:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The overall design of how you create the resources for your application (per page, in the application, in loose                          <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, in a resource only assembly).</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The application functionality: is updating resources in real time part of your application requirements?</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The respective lookup behavior of that resource reference type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The particular property or resource type, and the native behavior of those types.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Static Resources</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Static resource references work best for the following circumstances:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Your application design concentrates most of all of its resources into page or application level resource dictionaries.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Static resource references are not reevaluated based on runtime behaviors such as reloading a page, and therefore there can be some performance benefit to avoiding large numbers of dynamic resource references when they are not necessary per your resource and application design.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You are setting the value of a property that is not on a                                  <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> or a                                  <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You are creating a resource dictionary that will be compiled into a DLL, and packaged as part of the application or shared between applications.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You are creating a theme for a custom control, and are defining resources that are used within the themes.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For this case, you typically do not want the dynamic resource reference lookup behavior, you instead want the static resource reference behavior so that the lookup is predictable and self-contained to the theme.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>With a dynamic resource reference, even a reference within a theme is left unevaluated until runtime, and there is a chance that when the theme is applied, some local element will redefine a key that your theme is trying to reference, and the local element will fall prior to the theme itself in the lookup.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If that happens, your theme will not behave in an expected manner.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You are using resources to set large numbers of dependency properties.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Dependency properties have effective value caching as enabled by the property system, so if you provide a value for a dependency property that can be evaluated at load time, the dependency property does not have to check for a reevaluated expression and can return the last effective value.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This technique can be a performance benefit.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You want to change the underlying resource for all consumers, or you want to maintain separate writable instances for each consumer by using the                                  <bpt id="p1">[</bpt>x:Shared Attribute<ept id="p1">](../../../../docs/framework/xaml-services/x-shared-attribute.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Static resource lookup behavior</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The lookup process then traverses the logical tree upward, to the parent element and its resource dictionary.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This continues until the root element is reached.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Next, application resources are checked.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Application resources are those resources within the resource dictionary that is defined by the                                          <ph id="ph1">&lt;xref:System.Windows.Application&gt;</ph> object for your                                          <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Static resource references from within a resource dictionary must reference a resource that has already been defined lexically before the resource reference.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Forward references cannot be resolved by a static resource reference.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For this reason, if you use static resource references, you must design your resource dictionary structure such that resources intended for by-resource use are defined at or near the beginning of each respective resource dictionary.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Static resource lookup can extend into themes, or into system resources, but this is supported only because the                                  <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> loader defers the request.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The deferral is necessary so that the runtime theme at the time the page loads applies properly to the application.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>However, static resource references to keys that are known to only exist in themes or as system resources are not recommended.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is because such references are not reevaluated if the theme is changed by the user in realtime.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A dynamic resource reference is more reliable when you request theme or system resources.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The exception is when a theme element itself requests another resource.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>These references should be static resource references, for the reasons mentioned earlier.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The exception behavior if a static resource reference is not found varies.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If the resource was deferred, then the exception occurs at runtime.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If the resource was not deferred, the exception occurs at load time.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Dynamic Resources</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Dynamic resources work best for the following circumstances:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The value of the resource depends on conditions that are not known until runtime.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This includes system resources, or resources that are otherwise user settable.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For example, you can create setter values that refer to system properties, as exposed by                                  <ph id="ph1">&lt;xref:System.Windows.SystemColors&gt;</ph>,                                  <ph id="ph2">&lt;xref:System.Windows.SystemFonts&gt;</ph>, or                                  <ph id="ph3">&lt;xref:System.Windows.SystemParameters&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>These values are truly dynamic because they ultimately come from the runtime environment of the user and operating system.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You might also have application-level themes that can change, where page-level resource access must also capture the change.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You are creating or referencing theme styles for a custom control.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You intend to adjust the contents of a                                  <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> during an application lifetime.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You have a complicated resource structure that has interdependencies, where a forward reference may be required.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Static resource references do not support forward references, but dynamic resource references do support them because the resource does not need to be evaluated until                                  runtime                                 , and forward references are therefore not a relevant concept.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You are referencing a resource that is particularly large from the perspective of a compile or working set, and the resource might not be used immediately when the page loads.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Static resource references always load from                                  <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> when the page loads; however, a dynamic resource reference does not load until it is actually used.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You are creating a style where setter values might come from other values that are influenced by themes or other user settings.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>You are applying resources to elements that might be reparented in the logical tree during application lifetime.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Changing the parent also potentially changes the resource lookup scope, so if you want the resource for a reparented element to be reevaluated based on the new scope, always use a dynamic resource reference.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Dynamic resource lookup behavior</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Resource lookup behavior for a dynamic resource reference parallels the lookup behavior in your code if you call                                  <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph> or                                  <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.SetResourceReference%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>If the element defines a                                                  <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property, the                                                  <ph id="ph2">&lt;xref:System.Windows.Style.Resources%2A&gt;</ph> dictionary within the                                                  <ph id="ph3">&lt;xref:System.Windows.Style&gt;</ph> is checked.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>If the element defines a                                                  <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Template%2A&gt;</ph> property, the                                                  <ph id="ph2">&lt;xref:System.Windows.FrameworkTemplate.Resources%2A&gt;</ph> dictionary within the                                                  <ph id="ph3">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> is checked.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The lookup process then traverses the logical tree upward, to the parent element and its resource dictionary.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This continues until the root element is reached.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Next, application resources are checked.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Application resources are those resources within the resource dictionary that is defined by the                                          <ph id="ph1">&lt;xref:System.Windows.Application&gt;</ph> object for your                                          <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Theme resource dictionary is checked, for the currently active theme.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If the theme changes at runtime, the value is reevaluated.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>System resources are checked.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Exception behavior (if any) varies:</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>If a resource was requested by a                                          <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph> call, and was not found, an exception is raised.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If a resource was requested by a                                          <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> call, and was not found, no exception is raised, but the returned value is                                          <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If the property being set does not accept                                          <ph id="ph1">`null`</ph>, then it is still possible that a deeper exception will be raised (this depends on the individual property being set).</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If a resource was requested by a dynamic resource reference in                                          <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, and was not found, then the behavior depends on the general property system, but the general behavior is as if no property setting operation occurred at the level where the resource exists.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For instance, if you attempt to set the background on a an individual button element using a resource that could not be evaluated, then no value set results, but the effective value can still come from other participants in the property system and value precedence.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>For instance, the background value might still come from a locally defined button style, or from the theme style.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For properties that are not defined by theme styles, the effective value after a failed resource evaluation might come from the default value in the property metadata.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Restrictions</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Dynamic resource references have some notable restrictions.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>At least one of the following must be true:</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The property being set must be a property on a                                          <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or                                          <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>That property must be backed by a                                          <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The reference is for a value within a                                          <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph><ph id="ph2">&lt;xref:System.Windows.Setter&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The property being set must be a property on a                                          <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph> that is provided as a value of either a                                          <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or                                          <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> property, or a                                          <ph id="ph4">&lt;xref:System.Windows.Setter&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Because the property being set must be a                                  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> or                                  <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> property, most property changes can propagate to UI because a property change (the changed dynamic resource value) is acknowledged by the property system.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Most controls include logic that will force another layout of a control if a                                  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> changes and that property might affect layout.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>However, not all properties that have a                                  <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> as their value are guaranteed to provide the value in such a way that they update in realtime in the UI.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>That functionality still might vary depending on the property, as well as depending on the type that owns the property, or even the logical structure of your application.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Styles, DataTemplates, and Implicit Keys</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Earlier, it was stated that all items in a                  <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> must have a key.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>However, that does not mean that all resources must have an explicit                  <ph id="ph1">`x:Key`</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Several object types support an implicit key when defined as a resource, where the key value is tied to the value of another property.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>This is known as an implicit key, whereas an                  <ph id="ph1">`x:Key`</ph> attribute is an explicit key.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>You can overwrite any implicit key by specifying an explicit key.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>One very important scenario for resources is when you define a                  <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In fact, a                  <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> is almost always defined as an entry in a resource dictionary, because styles are inherently intended for reuse.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For more information about styles, see                  <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](../../../../docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Styles for controls can be both created with and referenced with an implicit key.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The theme styles that define the default appearance of a control rely on this implicit key.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The implicit key from the standpoint of requesting it is the                  <ph id="ph1">&lt;xref:System.Type&gt;</ph> of the control itself.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The implicit key from the standpoint of defining the resource is the                  <ph id="ph1">&lt;xref:System.Windows.Style.TargetType%2A&gt;</ph> of the style.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Therefore, if you are creating themes for custom controls, creating styles that interact with existing theme styles, you do not need to specify an                  <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](../../../../docs/framework/xaml-services/x-key-directive.md)</ept> for that                  <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>And if you want to use the themed styles, you do not need to specify any style at all.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>For instance, the following style definition works, even though the                  <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> resource does not appear to have a key:</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>FEResourceSH_snip#ImplicitStyle<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#implicitstyle)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>That style really does have a key: the implicit key                  <ph id="ph1">`typeof(`</ph><ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph><ph id="ph3">`)`</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>In markup, you can specify a                  <ph id="ph1">&lt;xref:System.Windows.Style.TargetType%2A&gt;</ph> directly as the type name (or you can optionally use                  <bpt id="p1">[</bpt>{x:Type...}<ept id="p1">](../../../../docs/framework/xaml-services/x-type-markup-extension.md)</ept></source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>to return a                  <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Through the default theme style mechanisms used by                  <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, that style is applied as the runtime style of a                  <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> on the page, even though the                  <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> itself does not attempt to specify its                  <ph id="ph4">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property or a specific resource reference to the style.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Your style defined in the page is found earlier in the lookup sequence earlier than the theme dictionary style, using the same key that the theme dictionary style has.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>You could just specify                  <ph id="ph1">`&lt;Button&gt;Hello&lt;/Button&gt;`</ph> anywhere in the page, and the style you defined with                  <ph id="ph2">&lt;xref:System.Windows.Style.TargetType%2A&gt;</ph> of                  <ph id="ph3">`Button`</ph> would apply to that button.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>If you want, you can still explicitly key the style with the same type value as                  <ph id="ph1">&lt;xref:System.Windows.Style.TargetType%2A&gt;</ph>, for clarity in your markup, but that is optional.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Implicit keys for styles do not apply on a control if                  <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A&gt;</ph> is                  <ph id="ph2">`true`</ph> (also note that                  <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A&gt;</ph> might be set as part of native behavior for the control class, rather than explicitly on an instance of the control).</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Also, in order to support implicit keys for derived class scenarios, the control must override                  <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> (all existing controls provided as part of                  <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> do this).</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For more information about styles, themes, and control design, see                  <bpt id="p1">[</bpt>Guidelines for Designing Stylable Controls<ept id="p1">](../../../../docs/framework/wpf/controls/guidelines-for-designing-stylable-controls.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph> also has an implicit key.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The implicit key for a                  <ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph> is the                  <ph id="ph2">&lt;xref:System.Windows.DataTemplate.DataType%2A&gt;</ph> property value.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.DataTemplate.DataType%2A&gt;</ph> can also be specified as the name of the type rather than explicitly using                  <bpt id="p1">[</bpt>{x:Type...}<ept id="p1">](../../../../docs/framework/xaml-services/x-type-markup-extension.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>For details, see                  <bpt id="p1">[</bpt>Data Templating Overview<ept id="p1">](../../../../docs/framework/wpf/data/data-templating-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph></source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Application Resources<ept id="p1">](../../../../docs/framework/wpf/advanced/optimizing-performance-application-resources.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Resources and Code<ept id="p1">](../../../../docs/framework/wpf/advanced/resources-and-code.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Define and Reference a Resource<ept id="p1">](../../../../docs/framework/wpf/advanced/how-to-define-and-reference-a-resource.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Application Management Overview<ept id="p1">](../../../../docs/framework/wpf/app-development/application-management-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>x:Type Markup Extension<ept id="p1">](../../../../docs/framework/xaml-services/x-type-markup-extension.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StaticResource Markup Extension<ept id="p1">](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>