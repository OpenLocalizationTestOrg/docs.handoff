{"content":"---\ntitle: \"Pooling\"\nms.date: \"03/30/2017\"\nms.assetid: 688dfb30-b79a-4cad-a687-8302f8a9ad6a\n---\n# Pooling\nThis sample demonstrates how to extend Windows Communication Foundation (WCF) to support object pooling. The sample demonstrates how to create an attribute that is syntactically and semantically similar to the `ObjectPoolingAttribute` attribute functionality of Enterprise Services. Object pooling can provide a dramatic boost to an application's performance. However, it can have the opposite effect if it is not used properly. Object pooling helps reduce the overhead of recreating frequently used objects that require extensive initialization. However, if a call to a method on a pooled object takes a considerable amount of time to complete, object pooling queues additional requests as soon as the maximum pool size is reached. Thus it may fail to serve some object creation requests by throwing a timeout exception.  \n  \n> [!NOTE]\n>  The setup procedure and build instructions for this sample are located at the end of this topic.  \n  \n The first step in creating a WCF extension is to decide the extensibility point to use.  \n  \n In WCF the term *dispatcher* refers to a run-time component responsible for converting incoming messages into method invocations on the user’s service and for converting return values from that method to an outgoing message. A WCF service creates a dispatcher for each endpoint. A WCF client must use a dispatcher if the contract associated with that client is a duplex contract.  \n  \n The channel and endpoint dispatchers offer channel-and contract-wide extensibility by exposing various properties that control the behavior of the dispatcher. The <xref:System.ServiceModel.Dispatcher.EndpointDispatcher.DispatchRuntime%2A> property also enables you to inspect, modify, or customize the dispatching process. This sample focuses on the <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A> property that points to the object that provides the instances of the service class.  \n  \n## The IInstanceProvider  \n In WCF, the dispatcher creates instances of the service class using a <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A>, which implements the <xref:System.ServiceModel.Dispatcher.IInstanceProvider> interface. This interface has three methods:  \n  \n-   <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29>: When a message arrives the Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> method to create an instance of the service class to process the message. The frequency of the calls to this method is determined by the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property. For example, if the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property is set to <xref:System.ServiceModel.InstanceContextMode.PerCall> a new instance of service class is created to process each message that arrives, so <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> is called whenever a message arrives.  \n  \n-   <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%29>: This is identical to the previous method, except this is invoked when there is no Message argument.  \n  \n-   <xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%28System.ServiceModel.InstanceContext%2CSystem.Object%29>: When a service instance's lifetime has elapsed, the Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%28System.ServiceModel.InstanceContext%2CSystem.Object%29> method. Just like for the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> method, the frequency of the calls to this method is determined by the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property.  \n  \n## The Object Pool  \n A custom <xref:System.ServiceModel.Dispatcher.IInstanceProvider> implementation provides the required object pooling semantics for a service. Therefore, this sample has an `ObjectPoolingInstanceProvider` type that provides custom implementation of <xref:System.ServiceModel.Dispatcher.IInstanceProvider> for pooling. When the `Dispatcher` calls the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> method, instead of creating a new instance, the custom implementation looks for an existing object in an in-memory pool. If one is available, it is returned. Otherwise, a new object is created. The implementation for `GetInstance` is shown in the following sample code.  \n  \n```  \nobject IInstanceProvider.GetInstance(InstanceContext instanceContext, Message message)  \n{  \n    object obj = null;  \n  \n    lock (poolLock)  \n    {  \n        if (pool.Count > 0)  \n        {  \n            obj = pool.Pop();  \n        }  \n        else  \n        {  \n            obj = CreateNewPoolObject();  \n        }  \n        activeObjectsCount++;  \n    }  \n  \n    WritePoolMessage(ResourceHelper.GetString(\"MsgNewObject\"));  \n  \n    idleTimer.Stop();  \n  \n    return obj;            \n}  \n```  \n  \n The custom `ReleaseInstance` implementation adds the released instance back to the pool and decrements the `ActiveObjectsCount` value. The `Dispatcher` can call these methods from different threads, and therefore synchronized access to the class level members in the `ObjectPoolingInstanceProvider` class is required.  \n  \n```  \nvoid IInstanceProvider.ReleaseInstance(InstanceContext instanceContext, object instance)  \n{  \n    lock (poolLock)  \n    {  \n        pool.Push(instance);  \n        activeObjectsCount--;  \n  \n        WritePoolMessage(  \n        ResourceHelper.GetString(\"MsgObjectPooled\"));  \n  \n        // When the service goes completely idle (no requests   \n        // are being processed), the idle timer is started  \n        if (activeObjectsCount == 0)  \n            idleTimer.Start();                       \n    }  \n}  \n```  \n  \n The `ReleaseInstance` method provides a \"clean up initialization\" feature. Normally the pool maintains a minimum number of objects for the lifetime of the pool. However, there can be periods of excessive usage that require creating additional objects in the pool to reach the maximum limit specified in the configuration. Eventually, when the pool becomes less active, those surplus objects can become an extra overhead. Therefore, when the `activeObjectsCount` reaches zero, an idle timer is started that triggers and performs a clean-up cycle.  \n  \n## Adding the Behavior  \n Dispatcher-layer extensions are hooked up using the following behaviors:  \n  \n-   Service Behaviors. These allow for the customization of the entire service runtime.  \n  \n-   Endpoint Behaviors. These allow for the customization of service endpoints, specifically a Channel and Endpoint Dispatcher.  \n  \n-   Contract Behaviors. These allow for the customization of both <xref:System.ServiceModel.Dispatcher.ClientRuntime> and <xref:System.ServiceModel.Dispatcher.DispatchRuntime> classes on the client and the service respectively.  \n  \n For the purpose of an object pooling extension a service behavior must be created. Service behaviors are created by implementing the <xref:System.ServiceModel.Description.IServiceBehavior> interface. There are several ways to make the service model aware of the custom behaviors:  \n  \n-   Using a custom attribute.  \n  \n-   Imperatively adding it to the service description’s behaviors collection.  \n  \n-   Extending the configuration file.  \n  \n This sample uses a custom attribute. When the <xref:System.ServiceModel.ServiceHost> is constructed it examines the attributes used in the service’s type definition and adds the available behaviors to the service description’s behaviors collection.  \n  \n The interface <xref:System.ServiceModel.Description.IServiceBehavior> has three methods in it -- <xref:System.ServiceModel.Description.IServiceBehavior.Validate%2A>, <xref:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters%2A>, and <xref:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior%2A>. The <xref:System.ServiceModel.Description.IServiceBehavior.Validate%2A> method is used to ensure that the behavior can be applied to the service. In this sample, the implementation ensures that the service is not configured with <xref:System.ServiceModel.InstanceContextMode.Single>. The <xref:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters%2A> method is used to configure the service's bindings. It is not required in this scenario. The <xref:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior%2A> is used to configure the service's dispatchers. This method is called by WCF when the <xref:System.ServiceModel.ServiceHost> is being initialized. The following parameters are passed into this method:  \n  \n-   `Description`: This argument provides the service description for the entire service. This can be used to inspect description data about the service’s endpoints, contracts, bindings, and other data.  \n  \n-   `ServiceHostBase`: This argument provides the <xref:System.ServiceModel.ServiceHostBase> that is currently being initialized.  \n  \n In the custom <xref:System.ServiceModel.Description.IServiceBehavior> implementation a new instance of `ObjectPoolingInstanceProvider` is instantiated and assigned to the <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A> property in each <xref:System.ServiceModel.Dispatcher.DispatchRuntime> in the ServiceHostBase.  \n  \n```  \nvoid IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase)  \n{  \n    // Create an instance of the ObjectPoolInstanceProvider.  \n    ObjectPoolingInstanceProvider instanceProvider = new  \n           ObjectPoolingInstanceProvider(description.ServiceType,   \n                                                    minPoolSize);  \n  \n    // Forward the call if we created a ServiceThrottlingBehavior.  \n    if (this.throttlingBehavior != null)  \n    {  \n        ((IServiceBehavior)this.throttlingBehavior).ApplyDispatchBehavior(description, serviceHostBase);  \n    }  \n  \n    // In case there was already a ServiceThrottlingBehavior   \n    // (this.throttlingBehavior==null), it should have initialized   \n    // a single ServiceThrottle on all ChannelDispatchers.    \n    // As we loop through the ChannelDispatchers, we verify that   \n    // and modify the ServiceThrottle to guard MaxPoolSize.  \n    ServiceThrottle throttle = null;  \n  \n    foreach (ChannelDispatcherBase cdb in   \n            serviceHostBase.ChannelDispatchers)  \n    {  \n        ChannelDispatcher cd = cdb as ChannelDispatcher;  \n        if (cd != null)  \n        {  \n            // Make sure there is exactly one throttle used by all   \n            // endpoints. If there were others, we could not enforce   \n            // MaxPoolSize.  \n            if ((this.throttlingBehavior == null) &&   \n                        (this.maxPoolSize != Int32.MaxValue))  \n            {  \n                if (throttle == null)  \n                {  \n                    throttle = cd.ServiceThrottle;  \n                }  \n                if (cd.ServiceThrottle == null)  \n                {  \n                    throw new   \nInvalidOperationException(ResourceHelper.GetString(\"ExNullThrottle\"));  \n                }  \n                if (throttle != cd.ServiceThrottle)  \n                {  \n                    throw new InvalidOperationException(ResourceHelper.GetString(\"ExDifferentThrottle\"));  \n                }  \n             }  \n  \n             foreach (EndpointDispatcher ed in cd.Endpoints)  \n             {  \n                 // Assign it to DispatchBehavior in each endpoint.  \n                 ed.DispatchRuntime.InstanceProvider =   \n                                      instanceProvider;  \n             }  \n         }  \n     }  \n  \n     // Set the MaxConcurrentInstances to limit the number of items   \n     // that will ever be requested from the pool.  \n     if ((throttle != null) && (throttle.MaxConcurrentInstances >   \n                                      this.maxPoolSize))  \n     {  \n         throttle.MaxConcurrentInstances = this.maxPoolSize;  \n     }  \n}  \n```  \n  \n In addition to an <xref:System.ServiceModel.Description.IServiceBehavior> implementation the <xref:System.EnterpriseServices.ObjectPoolingAttribute> class has several members to customize the object pool using the attribute arguments. These members include <xref:System.EnterpriseServices.ObjectPoolingAttribute.MaxPoolSize%2A>, <xref:System.EnterpriseServices.ObjectPoolingAttribute.MinPoolSize%2A>, and <xref:System.EnterpriseServices.ObjectPoolingAttribute.CreationTimeout%2A>, to match the object pooling feature set provided by .NET Enterprise Services.  \n  \n The object pooling behavior can now be added to a WCF service by annotating the service implementation with the newly created custom `ObjectPooling` attribute.  \n  \n```  \n[ObjectPooling(MaxPoolSize=1024, MinPoolSize=10, CreationTimeout=30000)]      \npublic class PoolService : IPoolService  \n{  \n  // …  \n}  \n```  \n  \n## Running the Sample  \n The sample demonstrates the performance benefits that can be gained by using object pooling in certain scenarios.  \n  \n The service application implements two services -- `WorkService` and `ObjectPooledWorkService`. Both services share the same implementation -- they both require expensive initialization and then expose a `DoWork()` method that is relatively cheap. The only difference is that the `ObjectPooledWorkService` has object pooling configured:  \n  \n```  \n[ObjectPooling(MinPoolSize = 0, MaxPoolSize = 5)]  \npublic class ObjectPooledWorkService : IDoWork  \n{  \n    public ObjectPooledWorkService()  \n    {  \n        Thread.Sleep(5000);  \n        ColorConsole.WriteLine(ConsoleColor.Blue, \"ObjectPooledWorkService instance created.\");  \n    }  \n  \n    public void DoWork()  \n    {  \n        ColorConsole.WriteLine(ConsoleColor.Blue, \"ObjectPooledWorkService.GetData() completed.\");  \n    }          \n}  \n```  \n  \n When you run the client, it times calling the `WorkService` 5 times. It then times calling the `ObjectPooledWorkService` 5 times. The difference in time is then displayed:  \n  \n```  \nPress <ENTER> to start the client.  \n  \nCalling WorkService:  \n1 - DoWork() Done  \n2 - DoWork() Done  \n3 - DoWork() Done  \n4 - DoWork() Done  \n5 - DoWork() Done  \nCalling WorkService took: 26722 ms.  \nCalling ObjectPooledWorkService:  \n1 - DoWork() Done  \n2 - DoWork() Done  \n3 - DoWork() Done  \n4 - DoWork() Done  \n5 - DoWork() Done  \nCalling ObjectPooledWorkService took: 5323 ms.  \nPress <ENTER> to exit.  \n```  \n  \n> [!NOTE]\n>  The first time the client is run both services appear to take about the same amount of time. If you re-run the sample, you can see that the `ObjectPooledWorkService` returns much quicker because an instance of that object already exists in the pool.  \n  \n#### To set up, build, and run the sample  \n  \n1.  Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).  \n  \n2.  To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n3.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n> [!NOTE]\n>  If you use Svcutil.exe to regenerate the configuration for this sample, be sure to modify the endpoint name in the client configuration to match the client code.  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Instancing\\Pooling`  \n","nodes":[{"pos":[4,91],"embed":true,"restype":"x-metadata","content":"title: \"Pooling\"\nms.date: \"03/30/2017\"\nms.assetid: 688dfb30-b79a-4cad-a687-8302f8a9ad6a","nodes":[{"content":"Pooling","nodes":[{"pos":[0,7],"content":"Pooling","nodes":[{"content":"Pooling","pos":[0,7]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[98,105],"content":"Pooling","linkify":"Pooling","nodes":[{"content":"Pooling","pos":[0,7]}]},{"content":"This sample demonstrates how to extend Windows Communication Foundation (WCF) to support object pooling.","pos":[106,210]},{"content":"The sample demonstrates how to create an attribute that is syntactically and semantically similar to the <ph id=\"ph1\">`ObjectPoolingAttribute`</ph> attribute functionality of Enterprise Services.","pos":[211,388],"source":" The sample demonstrates how to create an attribute that is syntactically and semantically similar to the `ObjectPoolingAttribute` attribute functionality of Enterprise Services."},{"content":"Object pooling can provide a dramatic boost to an application's performance.","pos":[389,465]},{"content":"However, it can have the opposite effect if it is not used properly.","pos":[466,534]},{"content":"Object pooling helps reduce the overhead of recreating frequently used objects that require extensive initialization.","pos":[535,652]},{"content":"However, if a call to a method on a pooled object takes a considerable amount of time to complete, object pooling queues additional requests as soon as the maximum pool size is reached.","pos":[653,838]},{"content":"Thus it may fail to serve some object creation requests by throwing a timeout exception.","pos":[839,927]},{"pos":[935,1042],"content":"[!NOTE]\n The setup procedure and build instructions for this sample are located at the end of this topic.","leadings":["","> "],"nodes":[{"content":"The setup procedure and build instructions for this sample are located at the end of this topic.","pos":[9,105]}]},{"content":"The first step in creating a WCF extension is to decide the extensibility point to use.","pos":[1049,1136]},{"content":"In WCF the term <bpt id=\"p1\">*</bpt>dispatcher<ept id=\"p1\">*</ept> refers to a run-time component responsible for converting incoming messages into method invocations on the user’s service and for converting return values from that method to an outgoing message.","pos":[1143,1367],"source":"In WCF the term *dispatcher* refers to a run-time component responsible for converting incoming messages into method invocations on the user’s service and for converting return values from that method to an outgoing message."},{"content":"A WCF service creates a dispatcher for each endpoint.","pos":[1368,1421]},{"content":"A WCF client must use a dispatcher if the contract associated with that client is a duplex contract.","pos":[1422,1522]},{"content":"The channel and endpoint dispatchers offer channel-and contract-wide extensibility by exposing various properties that control the behavior of the dispatcher.","pos":[1529,1687]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.EndpointDispatcher.DispatchRuntime%2A&gt;</ph> property also enables you to inspect, modify, or customize the dispatching process.","pos":[1688,1851],"source":" The <xref:System.ServiceModel.Dispatcher.EndpointDispatcher.DispatchRuntime%2A> property also enables you to inspect, modify, or customize the dispatching process."},{"content":"This sample focuses on the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A&gt;</ph> property that points to the object that provides the instances of the service class.","pos":[1852,2037],"source":" This sample focuses on the <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A> property that points to the object that provides the instances of the service class."},{"pos":[2046,2067],"content":"The IInstanceProvider","linkify":"The IInstanceProvider","nodes":[{"content":"The IInstanceProvider","pos":[0,21]}]},{"content":"In WCF, the dispatcher creates instances of the service class using a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A&gt;</ph>, which implements the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider&gt;</ph> interface.","pos":[2071,2303],"source":"In WCF, the dispatcher creates instances of the service class using a <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A>, which implements the <xref:System.ServiceModel.Dispatcher.IInstanceProvider> interface."},{"content":"This interface has three methods:","pos":[2304,2337]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29&gt;</ph>: When a message arrives the Dispatcher calls the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29&gt;</ph> method to create an instance of the service class to process the message.","pos":[2347,2765],"source":"<xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29>: When a message arrives the Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> method to create an instance of the service class to process the message."},{"content":"The frequency of the calls to this method is determined by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A&gt;</ph> property.","pos":[2766,2913],"source":" The frequency of the calls to this method is determined by the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property."},{"content":"For example, if the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A&gt;</ph> property is set to <ph id=\"ph2\">&lt;xref:System.ServiceModel.InstanceContextMode.PerCall&gt;</ph> a new instance of service class is created to process each message that arrives, so <ph id=\"ph3\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29&gt;</ph> is called whenever a message arrives.","pos":[2914,3352],"source":" For example, if the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property is set to <xref:System.ServiceModel.InstanceContextMode.PerCall> a new instance of service class is created to process each message that arrives, so <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> is called whenever a message arrives."},{"pos":[3362,3571],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%29&gt;</ph>: This is identical to the previous method, except this is invoked when there is no Message argument.","source":"<xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%29>: This is identical to the previous method, except this is invoked when there is no Message argument."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%28System.ServiceModel.InstanceContext%2CSystem.Object%29&gt;</ph>: When a service instance's lifetime has elapsed, the Dispatcher calls the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%28System.ServiceModel.InstanceContext%2CSystem.Object%29&gt;</ph> method.","pos":[3581,3920],"source":"<xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%28System.ServiceModel.InstanceContext%2CSystem.Object%29>: When a service instance's lifetime has elapsed, the Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%28System.ServiceModel.InstanceContext%2CSystem.Object%29> method."},{"content":"Just like for the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29&gt;</ph> method, the frequency of the calls to this method is determined by the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A&gt;</ph> property.","pos":[3921,4242],"source":" Just like for the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> method, the frequency of the calls to this method is determined by the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property."},{"pos":[4251,4266],"content":"The Object Pool","linkify":"The Object Pool","nodes":[{"content":"The Object Pool","pos":[0,15]}]},{"content":"A custom <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider&gt;</ph> implementation provides the required object pooling semantics for a service.","pos":[4270,4411],"source":"A custom <xref:System.ServiceModel.Dispatcher.IInstanceProvider> implementation provides the required object pooling semantics for a service."},{"content":"Therefore, this sample has an <ph id=\"ph1\">`ObjectPoolingInstanceProvider`</ph> type that provides custom implementation of <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider&gt;</ph> for pooling.","pos":[4412,4586],"source":" Therefore, this sample has an `ObjectPoolingInstanceProvider` type that provides custom implementation of <xref:System.ServiceModel.Dispatcher.IInstanceProvider> for pooling."},{"content":"When the <ph id=\"ph1\">`Dispatcher`</ph> calls the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29&gt;</ph> method, instead of creating a new instance, the custom implementation looks for an existing object in an in-memory pool.","pos":[4587,4887],"source":" When the `Dispatcher` calls the <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%28System.ServiceModel.InstanceContext%2CSystem.ServiceModel.Channels.Message%29> method, instead of creating a new instance, the custom implementation looks for an existing object in an in-memory pool."},{"content":"If one is available, it is returned.","pos":[4888,4924]},{"content":"Otherwise, a new object is created.","pos":[4925,4960]},{"content":"The implementation for <ph id=\"ph1\">`GetInstance`</ph> is shown in the following sample code.","pos":[4961,5036],"source":" The implementation for `GetInstance` is shown in the following sample code."},{"content":"The custom <ph id=\"ph1\">`ReleaseInstance`</ph> implementation adds the released instance back to the pool and decrements the <ph id=\"ph2\">`ActiveObjectsCount`</ph> value.","pos":[5548,5682],"source":"The custom `ReleaseInstance` implementation adds the released instance back to the pool and decrements the `ActiveObjectsCount` value."},{"content":"The <ph id=\"ph1\">`Dispatcher`</ph> can call these methods from different threads, and therefore synchronized access to the class level members in the <ph id=\"ph2\">`ObjectPoolingInstanceProvider`</ph> class is required.","pos":[5683,5865],"source":" The `Dispatcher` can call these methods from different threads, and therefore synchronized access to the class level members in the `ObjectPoolingInstanceProvider` class is required."},{"content":"The <ph id=\"ph1\">`ReleaseInstance`</ph> method provides a \"clean up initialization\" feature.","pos":[6396,6470],"source":"The `ReleaseInstance` method provides a \"clean up initialization\" feature."},{"content":"Normally the pool maintains a minimum number of objects for the lifetime of the pool.","pos":[6471,6556]},{"content":"However, there can be periods of excessive usage that require creating additional objects in the pool to reach the maximum limit specified in the configuration.","pos":[6557,6717]},{"content":"Eventually, when the pool becomes less active, those surplus objects can become an extra overhead.","pos":[6718,6816]},{"content":"Therefore, when the <ph id=\"ph1\">`activeObjectsCount`</ph> reaches zero, an idle timer is started that triggers and performs a clean-up cycle.","pos":[6817,6941],"source":" Therefore, when the `activeObjectsCount` reaches zero, an idle timer is started that triggers and performs a clean-up cycle."},{"pos":[6950,6969],"content":"Adding the Behavior","linkify":"Adding the Behavior","nodes":[{"content":"Adding the Behavior","pos":[0,19]}]},{"content":"Dispatcher-layer extensions are hooked up using the following behaviors:","pos":[6973,7045]},{"content":"Service Behaviors.","pos":[7055,7073]},{"content":"These allow for the customization of the entire service runtime.","pos":[7074,7138]},{"content":"Endpoint Behaviors.","pos":[7148,7167]},{"content":"These allow for the customization of service endpoints, specifically a Channel and Endpoint Dispatcher.","pos":[7168,7271]},{"content":"Contract Behaviors.","pos":[7281,7300]},{"content":"These allow for the customization of both <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.ClientRuntime&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.DispatchRuntime&gt;</ph> classes on the client and the service respectively.","pos":[7301,7504],"source":" These allow for the customization of both <xref:System.ServiceModel.Dispatcher.ClientRuntime> and <xref:System.ServiceModel.Dispatcher.DispatchRuntime> classes on the client and the service respectively."},{"content":"For the purpose of an object pooling extension a service behavior must be created.","pos":[7511,7593]},{"content":"Service behaviors are created by implementing the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.IServiceBehavior&gt;</ph> interface.","pos":[7594,7710],"source":" Service behaviors are created by implementing the <xref:System.ServiceModel.Description.IServiceBehavior> interface."},{"content":"There are several ways to make the service model aware of the custom behaviors:","pos":[7711,7790]},{"content":"Using a custom attribute.","pos":[7800,7825]},{"content":"Imperatively adding it to the service description’s behaviors collection.","pos":[7835,7908]},{"content":"Extending the configuration file.","pos":[7918,7951]},{"content":"This sample uses a custom attribute.","pos":[7958,7994]},{"content":"When the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph> is constructed it examines the attributes used in the service’s type definition and adds the available behaviors to the service description’s behaviors collection.","pos":[7995,8206],"source":" When the <xref:System.ServiceModel.ServiceHost> is constructed it examines the attributes used in the service’s type definition and adds the available behaviors to the service description’s behaviors collection."},{"content":"The interface <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.IServiceBehavior&gt;</ph> has three methods in it -- <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.IServiceBehavior.Validate%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior%2A&gt;</ph>.","pos":[8213,8545],"source":"The interface <xref:System.ServiceModel.Description.IServiceBehavior> has three methods in it -- <xref:System.ServiceModel.Description.IServiceBehavior.Validate%2A>, <xref:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters%2A>, and <xref:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.IServiceBehavior.Validate%2A&gt;</ph> method is used to ensure that the behavior can be applied to the service.","pos":[8546,8691],"source":" The <xref:System.ServiceModel.Description.IServiceBehavior.Validate%2A> method is used to ensure that the behavior can be applied to the service."},{"content":"In this sample, the implementation ensures that the service is not configured with <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContextMode.Single&gt;</ph>.","pos":[8692,8829],"source":" In this sample, the implementation ensures that the service is not configured with <xref:System.ServiceModel.InstanceContextMode.Single>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters%2A&gt;</ph> method is used to configure the service's bindings.","pos":[8830,8965],"source":" The <xref:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters%2A> method is used to configure the service's bindings."},{"content":"It is not required in this scenario.","pos":[8966,9002]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior%2A&gt;</ph> is used to configure the service's dispatchers.","pos":[9003,9135],"source":" The <xref:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior%2A> is used to configure the service's dispatchers."},{"content":"This method is called by WCF when the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph> is being initialized.","pos":[9136,9234],"source":" This method is called by WCF when the <xref:System.ServiceModel.ServiceHost> is being initialized."},{"content":"The following parameters are passed into this method:","pos":[9235,9288]},{"content":"<ph id=\"ph1\">`Description`</ph>: This argument provides the service description for the entire service.","pos":[9298,9383],"source":"`Description`: This argument provides the service description for the entire service."},{"content":"This can be used to inspect description data about the service’s endpoints, contracts, bindings, and other data.","pos":[9384,9496]},{"pos":[9506,9631],"content":"<ph id=\"ph1\">`ServiceHostBase`</ph>: This argument provides the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceHostBase&gt;</ph> that is currently being initialized.","source":"`ServiceHostBase`: This argument provides the <xref:System.ServiceModel.ServiceHostBase> that is currently being initialized."},{"pos":[9638,9977],"content":"In the custom <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.IServiceBehavior&gt;</ph> implementation a new instance of <ph id=\"ph2\">`ObjectPoolingInstanceProvider`</ph> is instantiated and assigned to the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A&gt;</ph> property in each <ph id=\"ph4\">&lt;xref:System.ServiceModel.Dispatcher.DispatchRuntime&gt;</ph> in the ServiceHostBase.","source":"In the custom <xref:System.ServiceModel.Description.IServiceBehavior> implementation a new instance of `ObjectPoolingInstanceProvider` is instantiated and assigned to the <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A> property in each <xref:System.ServiceModel.Dispatcher.DispatchRuntime> in the ServiceHostBase."},{"content":"In addition to an <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.IServiceBehavior&gt;</ph> implementation the <ph id=\"ph2\">&lt;xref:System.EnterpriseServices.ObjectPoolingAttribute&gt;</ph> class has several members to customize the object pool using the attribute arguments.","pos":[12687,12921],"source":"In addition to an <xref:System.ServiceModel.Description.IServiceBehavior> implementation the <xref:System.EnterpriseServices.ObjectPoolingAttribute> class has several members to customize the object pool using the attribute arguments."},{"content":"These members include <ph id=\"ph1\">&lt;xref:System.EnterpriseServices.ObjectPoolingAttribute.MaxPoolSize%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.EnterpriseServices.ObjectPoolingAttribute.MinPoolSize%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.EnterpriseServices.ObjectPoolingAttribute.CreationTimeout%2A&gt;</ph>, to match the object pooling feature set provided by .NET Enterprise Services.","pos":[12922,13245],"source":" These members include <xref:System.EnterpriseServices.ObjectPoolingAttribute.MaxPoolSize%2A>, <xref:System.EnterpriseServices.ObjectPoolingAttribute.MinPoolSize%2A>, and <xref:System.EnterpriseServices.ObjectPoolingAttribute.CreationTimeout%2A>, to match the object pooling feature set provided by .NET Enterprise Services."},{"pos":[13252,13411],"content":"The object pooling behavior can now be added to a WCF service by annotating the service implementation with the newly created custom <ph id=\"ph1\">`ObjectPooling`</ph> attribute.","source":"The object pooling behavior can now be added to a WCF service by annotating the service implementation with the newly created custom `ObjectPooling` attribute."},{"pos":[13573,13591],"content":"Running the Sample","linkify":"Running the Sample","nodes":[{"content":"Running the Sample","pos":[0,18]}]},{"content":"The sample demonstrates the performance benefits that can be gained by using object pooling in certain scenarios.","pos":[13595,13708]},{"content":"The service application implements two services -- <ph id=\"ph1\">`WorkService`</ph> and <ph id=\"ph2\">`ObjectPooledWorkService`</ph>.","pos":[13715,13810],"source":"The service application implements two services -- `WorkService` and `ObjectPooledWorkService`."},{"content":"Both services share the same implementation -- they both require expensive initialization and then expose a <ph id=\"ph1\">`DoWork()`</ph> method that is relatively cheap.","pos":[13811,13962],"source":" Both services share the same implementation -- they both require expensive initialization and then expose a `DoWork()` method that is relatively cheap."},{"content":"The only difference is that the <ph id=\"ph1\">`ObjectPooledWorkService`</ph> has object pooling configured:","pos":[13963,14051],"source":" The only difference is that the `ObjectPooledWorkService` has object pooling configured:"},{"content":"When you run the client, it times calling the <ph id=\"ph1\">`WorkService`</ph> 5 times.","pos":[14520,14588],"source":"When you run the client, it times calling the `WorkService` 5 times."},{"content":"It then times calling the <ph id=\"ph1\">`ObjectPooledWorkService`</ph> 5 times.","pos":[14589,14649],"source":" It then times calling the `ObjectPooledWorkService` 5 times."},{"content":"The difference in time is then displayed:","pos":[14650,14691]},{"pos":[15124,15384],"content":"[!NOTE]\n The first time the client is run both services appear to take about the same amount of time. If you re-run the sample, you can see that the `ObjectPooledWorkService` returns much quicker because an instance of that object already exists in the pool.","leadings":["","> "],"nodes":[{"content":"The first time the client is run both services appear to take about the same amount of time. If you re-run the sample, you can see that the `ObjectPooledWorkService` returns much quicker because an instance of that object already exists in the pool.","pos":[9,258],"nodes":[{"content":"The first time the client is run both services appear to take about the same amount of time.","pos":[0,92]},{"content":"If you re-run the sample, you can see that the <ph id=\"ph1\">`ObjectPooledWorkService`</ph> returns much quicker because an instance of that object already exists in the pool.","pos":[93,249],"source":" If you re-run the sample, you can see that the `ObjectPooledWorkService` returns much quicker because an instance of that object already exists in the pool."}]}]},{"pos":[15395,15431],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[15441,15640],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[15650,15820],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[15830,16038],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"pos":[16046,16218],"content":"[!NOTE]\n If you use Svcutil.exe to regenerate the configuration for this sample, be sure to modify the endpoint name in the client configuration to match the client code.","leadings":["","> "],"nodes":[{"content":"If you use Svcutil.exe to regenerate the configuration for this sample, be sure to modify the endpoint name in the client configuration to match the client code.","pos":[9,170]}]},{"pos":[16226,16358],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[14,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[0,53]},{"content":"Check for the following (default) directory before continuing.","pos":[54,116]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[16412,16722],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[16723,16773]}]}