{"content":"---\ntitle: \"-refout (C# Compiler Options)\"\nms.date: 08/08/2017\nf1_keywords: \n  - \"/refout\"\nhelpviewer_keywords: \n  - \"refout compiler option [C#]\"\n  - \"/refout compiler option [C#]\"\n  - \"-refout compiler option [C#]\"\n---\n\n# -refout (C# Compiler Options)\n\nThe **-refout** option specifies a file path where the reference assembly should be output. This translates to `metadataPeStream` in the Emit API.\n\n## Syntax\n\n```console\n-refout:filepath\n```\n\n## Arguments\n\n `filepath`\nThe filepath for the reference assembly. It should generally match that of the primary assembly. The recommended convention (used by MSBuild) is to place the reference assembly in a \"ref/\" sub-folder relative to the primary assembly.\n\n## Remarks\n\nMetadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types. The reason for using `throw null` bodies (as opposed to no bodies) is so that PEVerify could run and pass (thus validating the completeness of the metadata).\n\nReference assemblies include an assembly-level `ReferenceAssembly` attribute. This attribute may be specified in source (then the compiler won't need to synthesize it). Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can still be loaded in reflection-only mode). Tools that reflect on assemblies need to ensure they load reference assemblies as reflection-only, otherwise they will receive a typeload error from the runtime.\n\nReference assemblies further remove metadata (private members) from metadata-only assemblies:\n\n- A reference assembly only has references for what it needs in the API surface. The real assembly may have additional references related to specific implementations. For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` does not reference any types required for `dynamic`.\n- Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation. If there are no <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attributes, do the same for internal function-members.\n- But all types (including private or nested types) are kept in reference assemblies. All attributes are kept (even internal ones).\n- All virtual methods are kept. Explicit interface implementations are kept. Explicitly implemented properties and events are kept, as their accessors are virtual (and are therefore kept).\n- All fields of a struct are kept. (This is a candidate for post-C#-7.1 refinement)\n\nThe `-refout` and [`-refonly`](refonly-compiler-option.md) options are mutually exclusive.\n\n## See also\n\n- [C# Compiler Options](../../../csharp/language-reference/compiler-options/index.md)\n- [Managing Project and Solution Properties](/visualstudio/ide/managing-project-and-solution-properties)\n","nodes":[{"pos":[4,216],"embed":true,"restype":"x-metadata","content":"title: \"-refout (C# Compiler Options)\"\nms.date: 08/08/2017\nf1_keywords: \n  - \"/refout\"\nhelpviewer_keywords: \n  - \"refout compiler option [C#]\"\n  - \"/refout compiler option [C#]\"\n  - \"-refout compiler option [C#]\"","nodes":[{"content":"-refout (C# Compiler Options)","nodes":[{"pos":[0,29],"content":"-refout (C# Compiler Options)","nodes":[{"content":"-refout (C# Compiler Options)","pos":[0,29]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[224,253],"content":"-refout (C# Compiler Options)","linkify":"-refout (C# Compiler Options)","nodes":[{"content":"-refout (C# Compiler Options)","pos":[0,29]}]},{"content":"The <bpt id=\"p1\">**</bpt>-refout<ept id=\"p1\">**</ept> option specifies a file path where the reference assembly should be output.","pos":[255,346],"source":"The **-refout** option specifies a file path where the reference assembly should be output."},{"content":"This translates to <ph id=\"ph1\">`metadataPeStream`</ph> in the Emit API.","pos":[347,401],"source":" This translates to `metadataPeStream` in the Emit API."},{"pos":[406,412],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[450,459],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"content":"<ph id=\"ph1\">`filepath`</ph> The filepath for the reference assembly.","pos":[462,513],"source":"`filepath`\nThe filepath for the reference assembly."},{"content":"It should generally match that of the primary assembly.","pos":[514,569]},{"content":"The recommended convention (used by MSBuild) is to place the reference assembly in a \"ref/\" sub-folder relative to the primary assembly.","pos":[570,706]},{"pos":[711,718],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Metadata-only assemblies have their method bodies replaced with a single <ph id=\"ph1\">`throw null`</ph> body, but include all members except anonymous types.","pos":[720,859],"source":"Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types."},{"content":"The reason for using <ph id=\"ph1\">`throw null`</ph> bodies (as opposed to no bodies) is so that PEVerify could run and pass (thus validating the completeness of the metadata).","pos":[860,1017],"source":" The reason for using `throw null` bodies (as opposed to no bodies) is so that PEVerify could run and pass (thus validating the completeness of the metadata)."},{"content":"Reference assemblies include an assembly-level <ph id=\"ph1\">`ReferenceAssembly`</ph> attribute.","pos":[1019,1096],"source":"Reference assemblies include an assembly-level `ReferenceAssembly` attribute."},{"content":"This attribute may be specified in source (then the compiler won't need to synthesize it).","pos":[1097,1187]},{"content":"Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can still be loaded in reflection-only mode).","pos":[1188,1334]},{"content":"Tools that reflect on assemblies need to ensure they load reference assemblies as reflection-only, otherwise they will receive a typeload error from the runtime.","pos":[1335,1496]},{"content":"Reference assemblies further remove metadata (private members) from metadata-only assemblies:","pos":[1498,1591]},{"content":"A reference assembly only has references for what it needs in the API surface.","pos":[1595,1673]},{"content":"The real assembly may have additional references related to specific implementations.","pos":[1674,1759]},{"content":"For instance, the reference assembly for <ph id=\"ph1\">`class C { private void M() { dynamic d = 1; ... } }`</ph> does not reference any types required for <ph id=\"ph2\">`dynamic`</ph>.","pos":[1760,1907],"source":" For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` does not reference any types required for `dynamic`."},{"content":"Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.","pos":[1910,2048]},{"content":"If there are no <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attributes, do the same for internal function-members.","pos":[2049,2186],"source":" If there are no <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attributes, do the same for internal function-members."},{"content":"But all types (including private or nested types) are kept in reference assemblies.","pos":[2189,2272]},{"content":"All attributes are kept (even internal ones).","pos":[2273,2318]},{"content":"All virtual methods are kept.","pos":[2321,2350]},{"content":"Explicit interface implementations are kept.","pos":[2351,2395]},{"content":"Explicitly implemented properties and events are kept, as their accessors are virtual (and are therefore kept).","pos":[2396,2507]},{"content":"All fields of a struct are kept.","pos":[2510,2542]},{"content":"(This is a candidate for post-C#-7.1 refinement)","pos":[2543,2591]},{"pos":[2593,2683],"content":"The <ph id=\"ph1\">`-refout`</ph> and <bpt id=\"p1\">[</bpt><ph id=\"ph2\">`-refonly`</ph><ept id=\"p1\">](refonly-compiler-option.md)</ept> options are mutually exclusive.","source":"The `-refout` and [`-refonly`](refonly-compiler-option.md) options are mutually exclusive."},{"pos":[2688,2696],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2700,2783],"content":"<bpt id=\"p1\">[</bpt>C# Compiler Options<ept id=\"p1\">](../../../csharp/language-reference/compiler-options/index.md)</ept>","source":"[C# Compiler Options](../../../csharp/language-reference/compiler-options/index.md)"},{"pos":[2786,2888],"content":"<bpt id=\"p1\">[</bpt>Managing Project and Solution Properties<ept id=\"p1\">](/visualstudio/ide/managing-project-and-solution-properties)</ept>","source":"[Managing Project and Solution Properties](/visualstudio/ide/managing-project-and-solution-properties)"}]}