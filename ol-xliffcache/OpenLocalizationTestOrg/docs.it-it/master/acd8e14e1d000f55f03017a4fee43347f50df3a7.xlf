<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="tour.md" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">acd8e14e1d000f55f03017a4fee43347f50df3a7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\tour.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a93159b76fe4a96d1684a18fe7b35b728b400e11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">57748d77726f87be55be640a8f27fc8400ace2aa</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Tour of .NET</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>A guided tour through some of the prominent features of .NET.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article offers a guided tour through some of the key features of the .NET.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept> topic to learn about the architectural pieces of .NET and what they're used for.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to run the code samples</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>To learn how to set up a development environment to run the code samples, see the <bpt id="p1">[</bpt>Getting Started<ept id="p1">](get-started.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Copy and paste code samples from this page into your environment to execute them.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>.NET supports multiple programming languages.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The .NET implementations implement the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://visualstudio.microsoft.com/license-terms/ecma-c-common-language-infrastructure-standards/)</ept>, which among other things specifies a language-independent runtime and language interoperability.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This means that you choose any .NET language to build apps and services on .NET.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic (VB).</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages finds few problems in adapting to C#.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>C# Guide<ept id="p1">](../csharp/index.md)</ept> to learn more about C#.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>F# Guide<ept id="p1">](../fsharp/index.md)</ept> to learn more about F#.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Among the .NET languages, the syntax of VB is the closest to ordinary human language, often making it easier for people new to software development.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>.NET uses <bpt id="p1">[</bpt>garbage collection (GC)<ept id="p1">](garbagecollection/index.md)</ept> to provide automatic memory management for programs.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>To learn more about the .NET GC, check out <bpt id="p1">[</bpt>Fundamentals of garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The garbage collector is one of the services that help ensure <bpt id="p1">*</bpt>memory safety<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A program is memory safe if it accesses only allocated memory.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In the following example, the runtime throws an <ph id="ph1">`InvalidIndexException`</ph> exception to enforce memory safety:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Working with unmanaged resources</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Some objects reference <bpt id="p1">*</bpt>unmanaged resources<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, a file handle is an unmanaged resource.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object is a managed object, but it references a file handle, which is unmanaged.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>When you're done using the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>, you need to release the file handle.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In .NET, objects that reference unmanaged resources implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When you're done using the object, you call the object's <ph id="ph1">&lt;xref:System.IDisposable.Dispose&gt;</ph> method, which is responsible for releasing any unmanaged resources.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>.NET languages provide a convenient <ph id="ph1">`using`</ph> syntax for such objects, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the .NET runtime automatically calls the <ph id="ph2">`stream`</ph> object's <ph id="ph3">&lt;xref:System.IDisposable.Dispose&gt;</ph> method, which releases the file handle.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The runtime also does this if an exception causes control to leave the block.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more details, see the following topics:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For C#, see the <bpt id="p1">[</bpt>using Statement (C# Reference)<ept id="p1">](../csharp/language-reference/keywords/using-statement.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For F#, see <bpt id="p1">[</bpt>Resource Management: The use Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For VB, see the <bpt id="p1">[</bpt>Using Statement (Visual Basic)<ept id="p1">](../visual-basic/language-reference/statements/using-statement.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Type safety</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>An object is an instance of a specific type.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object are those of its type.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods but not a <ph id="ph4">`SumTotal`</ph> method.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A program only calls the methods belonging to a given type.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented with hierarchies of base and derived classes.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The .NET runtime only allows object casts and calls that align with the object hierarchy.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">&lt;xref:System.Object&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>C#, VB, and F# support local <bpt id="p1">*</bpt>type inference<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The resulting type does have a strong type with everything that implies.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>From the previous example, <ph id="ph1">`dog`</ph> is rewritten to introduce type inference, and the remainder of the example is unchanged:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>F# has even further type inference capabilities than the method-local type inference found in C# and VB.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To learn more, see <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A delegate is represented by a method signature.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers except that they're type safe.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>They're a kind of disconnected method within the CLR type system.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Learn more in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Generics</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Generics allow the programmer to introduce a <bpt id="p1">*</bpt>type parameter<ept id="p1">*</ept> when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Generics were added to help programmers implement generic data structures.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Before their arrival in order for a type such as the <ph id="ph1">`List`</ph> type to be generic, it would have to work with elements that were of type <ph id="ph2">`object`</ph>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This had various performance and semantic problems, along with possible subtle runtime errors.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <ph id="ph1">`InvalidCastException`</ph> is thrown on working with the list's members.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The following sample shows a basic program running using an instance of <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> types:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Async programming</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Internally, they're based on objects (such as <ph id="ph1">`Task`</ph>), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, see the <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Every operating system includes an application programming interface (API) that provides system services.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to call those APIs.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](/cpp/atl/introduction-to-com)</ept> in managed code.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For more information about native interoperability, see the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop/index.md)</ept> article.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Depending on language support, the CLR lets you access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The following example is a modified version of the <ph id="ph1">`ToString()`</ph> method from the <ph id="ph2">`StringBuilder`</ph> class.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It illustrates how using <ph id="ph1">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Next steps</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of C# features, check out <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of F# features, see <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If you want to get started with writing code of your own, visit <bpt id="p1">[</bpt>Getting Started<ept id="p1">](get-started.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>To learn about important components of .NET, check out <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>