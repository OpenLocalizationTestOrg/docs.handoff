{"content":"---\ntitle: \"Securing Method Access\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"code security, method access\"\n  - \"secure coding, method access\"\n  - \"security [.NET Framework], method access\"\n  - \"method access security\"\nms.assetid: f7c2d6ec-3b18-4e0e-9991-acd97189d818\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Securing Method Access\n[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  \n  \n Some methods might not be suitable to allow arbitrary untrusted code to call. Such methods pose several risks: The method might provide some restricted information; it might believe any information passed to it; it might not do error checking on the parameters; or with the wrong parameters, it might malfunction or do something harmful. You should be aware of these cases and take action to help protect the method.  \n  \n In some cases, you might need to restrict methods that are not intended for public use but still must be public. For example, you might have an interface that needs to be called across your own DLLs and hence must be public, but you do not want to expose it publicly to prevent customers from using it or to prevent malicious code from exploiting the entry point into your component. Another common reason to restrict a method not intended for public use (but that must be public) is to avoid having to document and support what might be a very internal interface.  \n  \n Managed code offers several ways to restrict method access:  \n  \n-   Limit the scope of accessibility to the class, assembly, or derived classes, if they can be trusted. This is the simplest way to limit method access. Note that, in general, derived classes can be less trustworthy than the class they derive from, though in some cases they share the parent class's identity. In particular, do not infer trust from the keyword **protected**, which is not necessarily used in the security context.  \n  \n-   Limit the method access to callers of a specified identity--essentially, any particular [evidence](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7y5x1hcd%28v=vs.100%29) (strong name, publisher, zone, and so on) you choose.  \n  \n-   Limit the method access to callers having whatever permissions you select.  \n  \n Similarly, declarative security allows you to control inheritance of classes. You can use **InheritanceDemand** to do the following:  \n  \n-   Require derived classes to have a specified identity or permission.  \n  \n-   Require derived classes that override specific methods to have a specified identity or permission.  \n  \n The following example shows how to help protect a public class for limited access by requiring that callers be signed with a particular strong name. This example uses the <xref:System.Security.Permissions.StrongNameIdentityPermissionAttribute> with a **Demand** for the strong name. For task-based information on how to sign an assembly with a strong name, see [Creating and Using Strong-Named Assemblies](../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md).  \n  \n```vb  \n<StrongNameIdentityPermissionAttribute(SecurityAction.Demand, PublicKey := \"…hex…\", Name := \"App1\", Version := \"0.0.0.0\")>  _  \nPublic Class Class1  \nEnd Class  \n```  \n  \n```csharp  \n[StrongNameIdentityPermissionAttribute(SecurityAction.Demand, PublicKey=\"…hex…\", Name=\"App1\", Version=\"0.0.0.0\")]  \npublic class Class1  \n{  \n  \n}   \n```  \n  \n## Excluding Classes and Members from Use by Untrusted Code  \n Use the declarations shown in this section to prevent specific classes and methods, as well as properties and events, from being used by partially trusted code. By applying these declarations to a class, you apply the protection to all its methods, properties, and events; however, note that field access is not affected by declarative security. Note also that link demands help protect against only the immediate callers and might still be subject to luring attacks.  \n  \n> [!NOTE]\n>  A new transparency model has been introduced in the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]. The [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md) model identifies secure code with the <xref:System.Security.SecurityCriticalAttribute> attribute. Security-critical code requires both callers and inheritors to be fully trusted. Assemblies that are running under the code access security rules from earlier .NET Framework versions can call level 2 assemblies. In this case, the security-critical attributes will be treated as link demands for full trust.  \n  \n In strong-named assemblies, a [LinkDemand](../../../docs/framework/misc/link-demands.md) is applied to all publicly accessible methods, properties, and events therein to restrict their use to fully trusted callers. To disable this feature, you must apply the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> attribute. Thus, explicitly marking classes to exclude untrusted callers is necessary only for unsigned assemblies or assemblies with this attribute; you can use these declarations to mark a subset of types therein that are not intended for untrusted callers.  \n  \n The following examples show how to prevent classes and members from being used by untrusted code.  \n  \n For public nonsealed classes:  \n  \n```vb  \n<System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name := \"FullTrust\"), _   \nSystem.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name := \"FullTrust\")>  _  \nPublic Class CanDeriveFromMe  \nEnd Class  \n```  \n  \n```csharp  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name=\"FullTrust\")]  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name=\"FullTrust\")]  \npublic class CanDeriveFromMe  \n{  \n}  \n```  \n  \n For public sealed classes:  \n  \n```vb  \n<System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name := \"FullTrust\")>  _  \nNotInheritable Public Class CannotDeriveFromMe  \nEnd Class  \n```  \n  \n```csharp  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name=\"FullTrust\")]  \npublic sealed class CannotDeriveFromMe  \n{  \n}  \n```  \n  \n For public abstract classes:  \n  \n```vb  \n<System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name := \"FullTrust\"), _  \nSystem.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name := \"FullTrust\")>  _  \nMustInherit Public Class CannotCreateInstanceOfMe_CanCastToMe  \nEnd Class  \n```  \n  \n```csharp  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name=\"FullTrust\")]  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name=\"FullTrust\")]  \npublic abstract class CannotCreateInstanceOfMe_CanCastToMe {}  \n```  \n  \n For public virtual functions:  \n  \n```vb  \nClass Base1   \n<System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name:=\"FullTrust\"), System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name:=\"FullTrust\")> _  \n    Public Overridable Sub CanOverrideOrCallMe()  \n    End Sub 'CanOverrideOrCallMe  \nEnd Class 'Base1  \n```  \n  \n```csharp  \nclass Base1   \n{  \n[System.Security.Permissions.PermissionSetAttribute(  \nSystem.Security.Permissions.SecurityAction.InheritanceDemand, Name=\"FullTrust\")]  \n[System.Security.Permissions.PermissionSetAttribute(  \nSystem.Security.Permissions.SecurityAction.LinkDemand, Name=\"FullTrust\")]  \n    public virtual void CanOverrideOrCallMe() {}  \n}  \n```  \n  \n For public abstract functions:  \n  \n```vb  \nMustInherit Class Base2  \n    <System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name:=\"FullTrust\"), System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name:=\"FullTrust\")> _  \n    Public Sub MustOverrideMe()  \n    End Sub  \nEnd Class 'Base2  \n```  \n  \n```csharp  \nabstract class Base2 {  \n[System.Security.Permissions.PermissionSetAttribute(  \nSystem.Security.Permissions.SecurityAction.InheritanceDemand, Name = \"FullTrust\")]  \n[System.Security.Permissions.PermissionSetAttribute(  \nSystem.Security.Permissions.SecurityAction.LinkDemand, Name = \"FullTrust\")]  \npublic abstract void MustOverrideMe();  \n}  \n```  \n  \n For public override functions where the base class does not demand full trust:  \n  \n```vb  \nClass Derived  \n    Inherits Base1  \n<System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.Demand, Name:=\"FullTrust\")> _  \n    Public Overrides Sub CanOverrideOrCallMe()  \n        MyBase.CanOverrideOrCallMe()  \n    End Sub 'CanOverrideOrCallMe  \nEnd Class 'Derived  \n```  \n  \n```csharp  \nclass Derived : Base1  \n{     \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.Demand, Name=\"FullTrust\")]      \n    public override void CanOverrideOrCallMe()   \n    {  \n        base.CanOverrideOrCallMe();  \n    }  \n}  \n```  \n  \n For public override functions where the base class demands full trust:  \n  \n```vb  \nClass Derived  \n    Inherits Base1  \n<System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name:=\"FullTrust\")> _  \n    Public Overrides Sub CanOverrideOrCallMe()  \n        MyBase.CanOverrideOrCallMe()  \n    End Sub 'CanOverrideOrCallMe   \nEnd Class 'Derived  \n```  \n  \n```csharp  \nclass Derived : Base1  \n{     \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name=\"FullTrust\")]      \n    public override void CanOverrideOrCallMe()   \n    {  \n        base.CanOverrideOrCallMe();  \n    }  \n}  \n```  \n  \n For public interfaces:  \n  \n```vb  \nPublic Interface ICanCastToMe  \n    <System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name:=\"FullTrust\"), System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name:=\"FullTrust\")> _  \n    Sub CanImplementMe()  \nEnd Interface 'ICanCastToMe  \n<System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name:=\"FullTrust\"), System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name:=\"FullTrust\")> _  \nClass Implemented  \n    Implements ICanCastToMe  \n    Public Sub CanImplementMe()  \n    End Sub 'CanImplementMe  \n```  \n  \n```csharp  \npublic interface ICanCastToMe   \n{  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name = \"FullTrust\")]  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name = \"FullTrust\")]  \nvoid CanImplementMe();  \n}  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name = \"FullTrust\")]  \n[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name = \"FullTrust\")]  \nclass Implemented : ICanCastToMe  \n{  \n    public void CanImplementMe()  \n    {  \n    }  \n}  \n```  \n  \n## Virtual Internal Overrides or Overloads Overridable Friend  \n  \n> [!NOTE]\n>  This section warns about a security issue when declaring a method as both `virtual` and `internal` (`Overloads` `Overridable` `Friend` in Visual Basic). This warning applies only to the .NET Framework versions 1.0 and 1.1, it does not apply to later versions.  \n  \n In the .NET Framework versions 1.0 and 1.1, you must be aware of a nuance of the type system accessibility when confirming that your code is unavailable to other assemblies. A method that is declared **virtual** and **internal** (**Overloads Overridable Friend** in Visual Basic) can override the parent class's vtable entry and can be used only from within the same assembly because it is internal. However, the accessibility for overriding is determined by the **virtual** keyword, and this can be overridden from another assembly as long as that code has access to the class itself. If the possibility of an override presents a problem, use declarative security to fix it, or remove the **virtual** keyword if it is not strictly required.  \n  \n Note that even if a language compiler prevents these overrides with a compilation error, it is possible for code written with other compilers to override.  \n  \n## See also\n\n- [Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)\n","nodes":[{"pos":[4,345],"embed":true,"restype":"x-metadata","content":"title: \"Securing Method Access\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"code security, method access\"\n  - \"secure coding, method access\"\n  - \"security [.NET Framework], method access\"\n  - \"method access security\"\nms.assetid: f7c2d6ec-3b18-4e0e-9991-acd97189d818\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Securing Method Access","nodes":[{"pos":[0,22],"content":"Securing Method Access","nodes":[{"content":"Securing Method Access","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[352,374],"content":"Securing Method Access","linkify":"Securing Method Access","nodes":[{"content":"Securing Method Access","pos":[0,22]}]},{"content":"Some methods might not be suitable to allow arbitrary untrusted code to call.","pos":[454,531]},{"content":"Such methods pose several risks: The method might provide some restricted information; it might believe any information passed to it; it might not do error checking on the parameters; or with the wrong parameters, it might malfunction or do something harmful.","pos":[532,791]},{"content":"You should be aware of these cases and take action to help protect the method.","pos":[792,870]},{"content":"In some cases, you might need to restrict methods that are not intended for public use but still must be public.","pos":[877,989]},{"content":"For example, you might have an interface that needs to be called across your own DLLs and hence must be public, but you do not want to expose it publicly to prevent customers from using it or to prevent malicious code from exploiting the entry point into your component.","pos":[990,1260]},{"content":"Another common reason to restrict a method not intended for public use (but that must be public) is to avoid having to document and support what might be a very internal interface.","pos":[1261,1441]},{"content":"Managed code offers several ways to restrict method access:","pos":[1448,1507]},{"content":"Limit the scope of accessibility to the class, assembly, or derived classes, if they can be trusted.","pos":[1517,1617]},{"content":"This is the simplest way to limit method access.","pos":[1618,1666]},{"content":"Note that, in general, derived classes can be less trustworthy than the class they derive from, though in some cases they share the parent class's identity.","pos":[1667,1823]},{"content":"In particular, do not infer trust from the keyword <bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept>, which is not necessarily used in the security context.","pos":[1824,1944],"source":" In particular, do not infer trust from the keyword **protected**, which is not necessarily used in the security context."},{"pos":[1954,2199],"content":"Limit the method access to callers of a specified identity--essentially, any particular <bpt id=\"p1\">[</bpt>evidence<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7y5x1hcd%28v=vs.100%29)</ept> (strong name, publisher, zone, and so on) you choose.","source":"Limit the method access to callers of a specified identity--essentially, any particular [evidence](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7y5x1hcd%28v=vs.100%29) (strong name, publisher, zone, and so on) you choose."},{"content":"Limit the method access to callers having whatever permissions you select.","pos":[2209,2283]},{"content":"Similarly, declarative security allows you to control inheritance of classes.","pos":[2290,2367]},{"content":"You can use <bpt id=\"p1\">**</bpt>InheritanceDemand<ept id=\"p1\">**</ept> to do the following:","pos":[2368,2422],"source":" You can use **InheritanceDemand** to do the following:"},{"content":"Require derived classes to have a specified identity or permission.","pos":[2432,2499]},{"content":"Require derived classes that override specific methods to have a specified identity or permission.","pos":[2509,2607]},{"content":"The following example shows how to help protect a public class for limited access by requiring that callers be signed with a particular strong name.","pos":[2614,2762]},{"content":"This example uses the <ph id=\"ph1\">&lt;xref:System.Security.Permissions.StrongNameIdentityPermissionAttribute&gt;</ph> with a <bpt id=\"p1\">**</bpt>Demand<ept id=\"p1\">**</ept> for the strong name.","pos":[2763,2896],"source":" This example uses the <xref:System.Security.Permissions.StrongNameIdentityPermissionAttribute> with a **Demand** for the strong name."},{"content":"For task-based information on how to sign an assembly with a strong name, see <bpt id=\"p1\">[</bpt>Creating and Using Strong-Named Assemblies<ept id=\"p1\">](../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md)</ept>.","pos":[2897,3099],"source":" For task-based information on how to sign an assembly with a strong name, see [Creating and Using Strong-Named Assemblies](../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md)."},{"pos":[3458,3514],"content":"Excluding Classes and Members from Use by Untrusted Code","linkify":"Excluding Classes and Members from Use by Untrusted Code","nodes":[{"content":"Excluding Classes and Members from Use by Untrusted Code","pos":[0,56]}]},{"content":"Use the declarations shown in this section to prevent specific classes and methods, as well as properties and events, from being used by partially trusted code.","pos":[3518,3678]},{"content":"By applying these declarations to a class, you apply the protection to all its methods, properties, and events; however, note that field access is not affected by declarative security.","pos":[3679,3863]},{"content":"Note also that link demands help protect against only the immediate callers and might still be subject to luring attacks.","pos":[3864,3985]},{"pos":[3993,4632],"content":"[!NOTE]\n A new transparency model has been introduced in the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]. The [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md) model identifies secure code with the <xref:System.Security.SecurityCriticalAttribute> attribute. Security-critical code requires both callers and inheritors to be fully trusted. Assemblies that are running under the code access security rules from earlier .NET Framework versions can call level 2 assemblies. In this case, the security-critical attributes will be treated as link demands for full trust.","leadings":["","> "],"nodes":[{"content":"A new transparency model has been introduced in the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]. The [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md) model identifies secure code with the <xref:System.Security.SecurityCriticalAttribute> attribute. Security-critical code requires both callers and inheritors to be fully trusted. Assemblies that are running under the code access security rules from earlier .NET Framework versions can call level 2 assemblies. In this case, the security-critical attributes will be treated as link demands for full trust.","pos":[9,637],"nodes":[{"content":"A new transparency model has been introduced in the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>.","pos":[0,115],"source":"A new transparency model has been introduced in the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]."},{"content":"The <bpt id=\"p1\">[</bpt>Security-Transparent Code, Level 2<ept id=\"p1\">](../../../docs/framework/misc/security-transparent-code-level-2.md)</ept> model identifies secure code with the <ph id=\"ph1\">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attribute.","pos":[116,321],"source":" The [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md) model identifies secure code with the <xref:System.Security.SecurityCriticalAttribute> attribute."},{"content":"Security-critical code requires both callers and inheritors to be fully trusted.","pos":[322,402]},{"content":"Assemblies that are running under the code access security rules from earlier .NET Framework versions can call level 2 assemblies.","pos":[403,533]},{"content":"In this case, the security-critical attributes will be treated as link demands for full trust.","pos":[534,628]}]}]},{"content":"In strong-named assemblies, a <bpt id=\"p1\">[</bpt>LinkDemand<ept id=\"p1\">](../../../docs/framework/misc/link-demands.md)</ept> is applied to all publicly accessible methods, properties, and events therein to restrict their use to fully trusted callers.","pos":[4639,4853],"source":"In strong-named assemblies, a [LinkDemand](../../../docs/framework/misc/link-demands.md) is applied to all publicly accessible methods, properties, and events therein to restrict their use to fully trusted callers."},{"content":"To disable this feature, you must apply the <ph id=\"ph1\">&lt;xref:System.Security.AllowPartiallyTrustedCallersAttribute&gt;</ph> attribute.","pos":[4854,4969],"source":" To disable this feature, you must apply the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> attribute."},{"content":"Thus, explicitly marking classes to exclude untrusted callers is necessary only for unsigned assemblies or assemblies with this attribute; you can use these declarations to mark a subset of types therein that are not intended for untrusted callers.","pos":[4970,5218]},{"content":"The following examples show how to prevent classes and members from being used by untrusted code.","pos":[5225,5322]},{"content":"For public nonsealed classes:","pos":[5329,5358]},{"content":"For public sealed classes:","pos":[6022,6048]},{"content":"For public abstract classes:","pos":[6465,6493]},{"content":"For public virtual functions:","pos":[7214,7243]},{"content":"For public abstract functions:","pos":[8015,8045]},{"content":"For public override functions where the base class does not demand full trust:","pos":[8794,8872]},{"content":"For public override functions where the base class demands full trust:","pos":[9492,9562]},{"content":"For public interfaces:","pos":[10191,10213]},{"pos":[11689,11747],"content":"Virtual Internal Overrides or Overloads Overridable Friend","linkify":"Virtual Internal Overrides or Overloads Overridable Friend","nodes":[{"content":"Virtual Internal Overrides or Overloads Overridable Friend","pos":[0,58]}]},{"pos":[11755,12025],"content":"[!NOTE]\n This section warns about a security issue when declaring a method as both `virtual` and `internal` (`Overloads` `Overridable` `Friend` in Visual Basic). This warning applies only to the .NET Framework versions 1.0 and 1.1, it does not apply to later versions.","leadings":["","> "],"nodes":[{"content":"This section warns about a security issue when declaring a method as both `virtual` and `internal` (`Overloads` `Overridable` `Friend` in Visual Basic). This warning applies only to the .NET Framework versions 1.0 and 1.1, it does not apply to later versions.","pos":[9,268],"nodes":[{"content":"This section warns about a security issue when declaring a method as both <ph id=\"ph1\">`virtual`</ph> and <ph id=\"ph2\">`internal`</ph> (<ph id=\"ph3\">`Overloads`</ph> <ph id=\"ph4\">`Overridable`</ph> <ph id=\"ph5\">`Friend`</ph> in Visual Basic).","pos":[0,152],"source":"This section warns about a security issue when declaring a method as both `virtual` and `internal` (`Overloads` `Overridable` `Friend` in Visual Basic)."},{"content":"This warning applies only to the .NET Framework versions 1.0 and 1.1, it does not apply to later versions.","pos":[153,259]}]}]},{"content":"In the .NET Framework versions 1.0 and 1.1, you must be aware of a nuance of the type system accessibility when confirming that your code is unavailable to other assemblies.","pos":[12032,12205]},{"content":"A method that is declared <bpt id=\"p1\">**</bpt>virtual<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>internal<ept id=\"p2\">**</ept> (<bpt id=\"p3\">**</bpt>Overloads Overridable Friend<ept id=\"p3\">**</ept> in Visual Basic) can override the parent class's vtable entry and can be used only from within the same assembly because it is internal.","pos":[12206,12431],"source":" A method that is declared **virtual** and **internal** (**Overloads Overridable Friend** in Visual Basic) can override the parent class's vtable entry and can be used only from within the same assembly because it is internal."},{"content":"However, the accessibility for overriding is determined by the <bpt id=\"p1\">**</bpt>virtual<ept id=\"p1\">**</ept> keyword, and this can be overridden from another assembly as long as that code has access to the class itself.","pos":[12432,12617],"source":" However, the accessibility for overriding is determined by the **virtual** keyword, and this can be overridden from another assembly as long as that code has access to the class itself."},{"content":"If the possibility of an override presents a problem, use declarative security to fix it, or remove the <bpt id=\"p1\">**</bpt>virtual<ept id=\"p1\">**</ept> keyword if it is not strictly required.","pos":[12618,12773],"source":" If the possibility of an override presents a problem, use declarative security to fix it, or remove the **virtual** keyword if it is not strictly required."},{"content":"Note that even if a language compiler prevents these overrides with a compilation error, it is possible for code written with other compilers to override.","pos":[12780,12934]},{"pos":[12943,12951],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[12955,13042],"content":"<bpt id=\"p1\">[</bpt>Secure Coding Guidelines<ept id=\"p1\">](../../../docs/standard/security/secure-coding-guidelines.md)</ept>","source":"[Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)"}]}