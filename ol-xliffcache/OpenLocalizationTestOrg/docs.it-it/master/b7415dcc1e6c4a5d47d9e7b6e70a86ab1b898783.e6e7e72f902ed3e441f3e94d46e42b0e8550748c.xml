{"content":"---\ntitle: \"HTTP Transport Security\"\nms.date: \"03/30/2017\"\nms.assetid: d3439262-c58e-4d30-9f2b-a160170582bb\n---\n# HTTP Transport Security\nWhen using HTTP as the transport, security is provided by a Secure Sockets Layer (SSL) implementation. SSL is widely used on the Internet to authenticate a service to a client, and then to provide confidentiality (encryption) to the channel. This topic explains how SSL works and how it is implemented in Windows Communication Foundation (WCF).  \n  \n## Basic SSL  \n How SSL works is best explained through a typical scenario, in this case, a bank's Web site. The site allows a customer to log on with a user name and password. After being authenticated, the user can perform transactions, such as view account balances, pay bills, and move money from one account to another.  \n  \n When a user first visits the site, the SSL mechanism begins a series of negotiations, called a *handshake*, with the user's client (in this case, Internet Explorer). SSL first authenticates the bank site to the customer. This is an essential step because customers must first know that they are communicating with the actual site, and not a spoof that tries to lure them into typing in their user name and password. SSL does this authentication by using an SSL certificate provided by a trusted authority, such as VeriSign. The logic goes like this: VeriSign vouches for the identity of the bank site. Because Internet Explorer trusts VeriSign, the site is trusted. If you want to check with VeriSign, you can do so as well by clicking on the VeriSign logo. That presents a statement of authenticity with its expiration date and who it is issued to (the bank site).  \n  \n To initiate a secure session, the client sends the equivalent of a \"hello\" to the server along with a list of cryptographic algorithms it can use to sign, generate hashes, and encrypt and decrypt with. In response, the site sends back an acknowledgment and its choice of one of the algorithms suites. During this initial handshake, both parties send and receive nonces. A *nonce* is a randomly generated piece of data that is used, in combination with the site's public key, to create a hash. A *hash* is a new number that is derived from the two numbers using a standard algorithm, such as SHA1. (The client and the site also exchange messages to agree which hash algorithm to use.) The hash is unique and is used only for the session between the client and the site to encrypt and decrypt messages. Both client and service have the original nonce and the certificate's public key, so both sides can generate the same hash. Therefore, the client validates the hash sent by the service by (a) using the agreed upon algorithm to calculate the hash from the data, and (b) comparing it to the hash sent by the service; if the two match, then the client has assurance that the hash has not been tampered with. The client can then use this hash as a key to encrypt a message that contains yet another new hash. The service can decrypt the message using the hash, and recover this second-to-final hash. The accumulated information (nonces, public key, and other data) is now known to both sides, and a final hash (or master key) can be created. This final key is sent encrypted using the next-to-last hash. The master key is then used to encrypt and decrypt messages for the rest of the session. Because both client and service use the same key, this is also called a *session key*.  \n  \n The session key is also characterized as a symmetric key, or a \"shared secret.\" Having a symmetric key is important because it reduces the computation required by both sides of the transaction. If every message demanded a new exchange of nonces and hashes, performance would deteriorate. Therefore, the ultimate goal of SSL is to use a symmetric key that allows messages to flow freely between the two sides with a greater degree of security and efficiency.  \n  \n The previous description is a simplified version of what happens, because the protocol may vary from site to site. It is also possible that both the client and the site both generate nonces that are algorithmically combined during the handshake to add more complexity, and therefore protection, to the process of exchanging data.  \n  \n### Certificates and Public Key Infrastructure  \n During the handshake, the service also sends its SSL certificate to the client. The certificate contains information, such as its expiration date, issuing authority, and the site's Uniform Resource Identifier (URI). The client compares the URI to the URI it had originally contacted to ensure a match, and also checks the date and issuing authority.  \n  \n Every certificate has two keys, a private key and a public key, and the two are known as an *exchange key pair*. In brief, the private key is known only to the owner of the certificate while the public key is readable from the certificate. Either key can be used to encrypt or decrypt a digest, hash, or other key, but only as contrary operations. For example, if the client encrypts with the public key, only the site can decrypt the message using the private key. Similarly, if the site encrypts with the private key, the client can decrypt with the public key. This provides assurance to the client that the messages are being exchanged only with the possessor of the private key because only messages encrypted with the private key can be decrypted with the public key. The site is assured that it is exchanging messages with a client that has encrypted using the public key. This exchange is secure only for an initial handshake, however, which is why much more is done to create the actual symmetric key. Nevertheless, all communications depend on the service having a valid SSL certificate.  \n  \n## Implementing SSL with WCF  \n HTTP transport security (or SSL) is provided externally to WCF. You can implement SSL in one of two ways; the deciding factor is how your application is hosted:  \n  \n-   If you are using Internet Information Services (IIS) as your WCF host, use the IIS infrastructure to set up an SSL service.  \n  \n-   If you are creating a self-hosted WCF application, you can bind an SSL certificate to the address using the HttpCfg.exe tool.  \n  \n### Using IIS for Transport Security  \n  \n#### IIS 7.0  \n To set up [!INCLUDE[iisver](../../../../includes/iisver-md.md)] as a secure host (using SSL), see [IIS 7.0 Beta: Configuring Secure Sockets Layer in IIS 7.0](https://go.microsoft.com/fwlink/?LinkId=88600).  \n  \n To configure certificates for use with [!INCLUDE[iisver](../../../../includes/iisver-md.md)], see [IIS 7.0 Beta: Configuring Server Certificates in IIS 7.0](https://go.microsoft.com/fwlink/?LinkID=88595).  \n  \n#### IIS 6.0  \n To set up [!INCLUDE[iis601](../../../../includes/iis601-md.md)] as a secure host (using SSL), see [Configuring Secure Sockets Layer](https://go.microsoft.com/fwlink/?LinkId=88601).  \n  \n To configure certificates for use with [!INCLUDE[iis601](../../../../includes/iis601-md.md)], see [Certificates_IIS_SP1_Ops](https://go.microsoft.com/fwlink/?LinkId=88602).  \n  \n### Using HttpCfg for SSL  \n If you are creating a self-hosted WCF application, download the HttpCfg.exe tool, available at the [Windows XP Service Pack 2 Support Tools site](https://go.microsoft.com/fwlink/?LinkId=29002).  \n  \n For more information about using the HttpCfg.exe tool to set up a port with an X.509 certificate, see [How to: Configure a Port with an SSL Certificate](../../../../docs/framework/wcf/feature-details/how-to-configure-a-port-with-an-ssl-certificate.md).  \n  \n## See also\n\n- [Transport Security](../../../../docs/framework/wcf/feature-details/transport-security.md)\n- [Message Security](../../../../docs/framework/wcf/feature-details/message-security-in-wcf.md)\n","nodes":[{"pos":[4,107],"embed":true,"restype":"x-metadata","content":"title: \"HTTP Transport Security\"\nms.date: \"03/30/2017\"\nms.assetid: d3439262-c58e-4d30-9f2b-a160170582bb","nodes":[{"content":"HTTP Transport Security","nodes":[{"pos":[0,23],"content":"HTTP Transport Security","nodes":[{"content":"HTTP Transport Security","pos":[0,23]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[114,137],"content":"HTTP Transport Security","linkify":"HTTP Transport Security","nodes":[{"content":"HTTP Transport Security","pos":[0,23]}]},{"content":"When using HTTP as the transport, security is provided by a Secure Sockets Layer (SSL) implementation.","pos":[138,240]},{"content":"SSL is widely used on the Internet to authenticate a service to a client, and then to provide confidentiality (encryption) to the channel.","pos":[241,379]},{"content":"This topic explains how SSL works and how it is implemented in Windows Communication Foundation (WCF).","pos":[380,482]},{"pos":[491,500],"content":"Basic SSL","linkify":"Basic SSL","nodes":[{"content":"Basic SSL","pos":[0,9]}]},{"content":"How SSL works is best explained through a typical scenario, in this case, a bank's Web site.","pos":[504,596]},{"content":"The site allows a customer to log on with a user name and password.","pos":[597,664]},{"content":"After being authenticated, the user can perform transactions, such as view account balances, pay bills, and move money from one account to another.","pos":[665,812]},{"content":"When a user first visits the site, the SSL mechanism begins a series of negotiations, called a <bpt id=\"p1\">*</bpt>handshake<ept id=\"p1\">*</ept>, with the user's client (in this case, Internet Explorer).","pos":[819,984],"source":"When a user first visits the site, the SSL mechanism begins a series of negotiations, called a *handshake*, with the user's client (in this case, Internet Explorer)."},{"content":"SSL first authenticates the bank site to the customer.","pos":[985,1039]},{"content":"This is an essential step because customers must first know that they are communicating with the actual site, and not a spoof that tries to lure them into typing in their user name and password.","pos":[1040,1234]},{"content":"SSL does this authentication by using an SSL certificate provided by a trusted authority, such as VeriSign.","pos":[1235,1342]},{"content":"The logic goes like this: VeriSign vouches for the identity of the bank site.","pos":[1343,1420]},{"content":"Because Internet Explorer trusts VeriSign, the site is trusted.","pos":[1421,1484]},{"content":"If you want to check with VeriSign, you can do so as well by clicking on the VeriSign logo.","pos":[1485,1576]},{"content":"That presents a statement of authenticity with its expiration date and who it is issued to (the bank site).","pos":[1577,1684]},{"content":"To initiate a secure session, the client sends the equivalent of a \"hello\" to the server along with a list of cryptographic algorithms it can use to sign, generate hashes, and encrypt and decrypt with.","pos":[1691,1892]},{"content":"In response, the site sends back an acknowledgment and its choice of one of the algorithms suites.","pos":[1893,1991]},{"content":"During this initial handshake, both parties send and receive nonces.","pos":[1992,2060]},{"content":"A <bpt id=\"p1\">*</bpt>nonce<ept id=\"p1\">*</ept> is a randomly generated piece of data that is used, in combination with the site's public key, to create a hash.","pos":[2061,2183],"source":" A *nonce* is a randomly generated piece of data that is used, in combination with the site's public key, to create a hash."},{"content":"A <bpt id=\"p1\">*</bpt>hash<ept id=\"p1\">*</ept> is a new number that is derived from the two numbers using a standard algorithm, such as SHA1.","pos":[2184,2287],"source":" A *hash* is a new number that is derived from the two numbers using a standard algorithm, such as SHA1."},{"content":"(The client and the site also exchange messages to agree which hash algorithm to use.) The hash is unique and is used only for the session between the client and the site to encrypt and decrypt messages.","pos":[2288,2491]},{"content":"Both client and service have the original nonce and the certificate's public key, so both sides can generate the same hash.","pos":[2492,2615]},{"content":"Therefore, the client validates the hash sent by the service by (a) using the agreed upon algorithm to calculate the hash from the data, and (b) comparing it to the hash sent by the service; if the two match, then the client has assurance that the hash has not been tampered with.","pos":[2616,2896]},{"content":"The client can then use this hash as a key to encrypt a message that contains yet another new hash.","pos":[2897,2996]},{"content":"The service can decrypt the message using the hash, and recover this second-to-final hash.","pos":[2997,3087]},{"content":"The accumulated information (nonces, public key, and other data) is now known to both sides, and a final hash (or master key) can be created.","pos":[3088,3229]},{"content":"This final key is sent encrypted using the next-to-last hash.","pos":[3230,3291]},{"content":"The master key is then used to encrypt and decrypt messages for the rest of the session.","pos":[3292,3380]},{"content":"Because both client and service use the same key, this is also called a <bpt id=\"p1\">*</bpt>session key<ept id=\"p1\">*</ept>.","pos":[3381,3467],"source":" Because both client and service use the same key, this is also called a *session key*."},{"content":"The session key is also characterized as a symmetric key, or a \"shared secret.\"","pos":[3474,3553]},{"content":"Having a symmetric key is important because it reduces the computation required by both sides of the transaction.","pos":[3554,3667]},{"content":"If every message demanded a new exchange of nonces and hashes, performance would deteriorate.","pos":[3668,3761]},{"content":"Therefore, the ultimate goal of SSL is to use a symmetric key that allows messages to flow freely between the two sides with a greater degree of security and efficiency.","pos":[3762,3931]},{"content":"The previous description is a simplified version of what happens, because the protocol may vary from site to site.","pos":[3938,4052]},{"content":"It is also possible that both the client and the site both generate nonces that are algorithmically combined during the handshake to add more complexity, and therefore protection, to the process of exchanging data.","pos":[4053,4267]},{"pos":[4277,4319],"content":"Certificates and Public Key Infrastructure","linkify":"Certificates and Public Key Infrastructure","nodes":[{"content":"Certificates and Public Key Infrastructure","pos":[0,42]}]},{"content":"During the handshake, the service also sends its SSL certificate to the client.","pos":[4323,4402]},{"content":"The certificate contains information, such as its expiration date, issuing authority, and the site's Uniform Resource Identifier (URI).","pos":[4403,4538]},{"content":"The client compares the URI to the URI it had originally contacted to ensure a match, and also checks the date and issuing authority.","pos":[4539,4672]},{"content":"Every certificate has two keys, a private key and a public key, and the two are known as an <bpt id=\"p1\">*</bpt>exchange key pair<ept id=\"p1\">*</ept>.","pos":[4679,4791],"source":"Every certificate has two keys, a private key and a public key, and the two are known as an *exchange key pair*."},{"content":"In brief, the private key is known only to the owner of the certificate while the public key is readable from the certificate.","pos":[4792,4918]},{"content":"Either key can be used to encrypt or decrypt a digest, hash, or other key, but only as contrary operations.","pos":[4919,5026]},{"content":"For example, if the client encrypts with the public key, only the site can decrypt the message using the private key.","pos":[5027,5144]},{"content":"Similarly, if the site encrypts with the private key, the client can decrypt with the public key.","pos":[5145,5242]},{"content":"This provides assurance to the client that the messages are being exchanged only with the possessor of the private key because only messages encrypted with the private key can be decrypted with the public key.","pos":[5243,5452]},{"content":"The site is assured that it is exchanging messages with a client that has encrypted using the public key.","pos":[5453,5558]},{"content":"This exchange is secure only for an initial handshake, however, which is why much more is done to create the actual symmetric key.","pos":[5559,5689]},{"content":"Nevertheless, all communications depend on the service having a valid SSL certificate.","pos":[5690,5776]},{"pos":[5785,5810],"content":"Implementing SSL with WCF","linkify":"Implementing SSL with WCF","nodes":[{"content":"Implementing SSL with WCF","pos":[0,25]}]},{"content":"HTTP transport security (or SSL) is provided externally to WCF.","pos":[5814,5877]},{"content":"You can implement SSL in one of two ways; the deciding factor is how your application is hosted:","pos":[5878,5974]},{"content":"If you are using Internet Information Services (IIS) as your WCF host, use the IIS infrastructure to set up an SSL service.","pos":[5984,6107]},{"content":"If you are creating a self-hosted WCF application, you can bind an SSL certificate to the address using the HttpCfg.exe tool.","pos":[6117,6242]},{"pos":[6252,6284],"content":"Using IIS for Transport Security","linkify":"Using IIS for Transport Security","nodes":[{"content":"Using IIS for Transport Security","pos":[0,32]}]},{"pos":[6295,6302],"content":"IIS 7.0","linkify":"IIS 7.0","nodes":[{"content":"IIS 7.0","pos":[0,7]}]},{"pos":[6306,6511],"content":"To set up <ph id=\"ph1\">[!INCLUDE[iisver](../../../../includes/iisver-md.md)]</ph> as a secure host (using SSL), see <bpt id=\"p1\">[</bpt>IIS 7.0 Beta: Configuring Secure Sockets Layer in IIS 7.0<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=88600)</ept>.","source":"To set up [!INCLUDE[iisver](../../../../includes/iisver-md.md)] as a secure host (using SSL), see [IIS 7.0 Beta: Configuring Secure Sockets Layer in IIS 7.0](https://go.microsoft.com/fwlink/?LinkId=88600)."},{"pos":[6518,6722],"content":"To configure certificates for use with <ph id=\"ph1\">[!INCLUDE[iisver](../../../../includes/iisver-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>IIS 7.0 Beta: Configuring Server Certificates in IIS 7.0<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkID=88595)</ept>.","source":"To configure certificates for use with [!INCLUDE[iisver](../../../../includes/iisver-md.md)], see [IIS 7.0 Beta: Configuring Server Certificates in IIS 7.0](https://go.microsoft.com/fwlink/?LinkID=88595)."},{"pos":[6733,6740],"content":"IIS 6.0","linkify":"IIS 6.0","nodes":[{"content":"IIS 6.0","pos":[0,7]}]},{"pos":[6744,6924],"content":"To set up <ph id=\"ph1\">[!INCLUDE[iis601](../../../../includes/iis601-md.md)]</ph> as a secure host (using SSL), see <bpt id=\"p1\">[</bpt>Configuring Secure Sockets Layer<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=88601)</ept>.","source":"To set up [!INCLUDE[iis601](../../../../includes/iis601-md.md)] as a secure host (using SSL), see [Configuring Secure Sockets Layer](https://go.microsoft.com/fwlink/?LinkId=88601)."},{"pos":[6931,7103],"content":"To configure certificates for use with <ph id=\"ph1\">[!INCLUDE[iis601](../../../../includes/iis601-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>Certificates_IIS_SP1_Ops<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=88602)</ept>.","source":"To configure certificates for use with [!INCLUDE[iis601](../../../../includes/iis601-md.md)], see [Certificates_IIS_SP1_Ops](https://go.microsoft.com/fwlink/?LinkId=88602)."},{"pos":[7113,7134],"content":"Using HttpCfg for SSL","linkify":"Using HttpCfg for SSL","nodes":[{"content":"Using HttpCfg for SSL","pos":[0,21]}]},{"pos":[7138,7331],"content":"If you are creating a self-hosted WCF application, download the HttpCfg.exe tool, available at the <bpt id=\"p1\">[</bpt>Windows XP Service Pack 2 Support Tools site<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=29002)</ept>.","source":"If you are creating a self-hosted WCF application, download the HttpCfg.exe tool, available at the [Windows XP Service Pack 2 Support Tools site](https://go.microsoft.com/fwlink/?LinkId=29002)."},{"pos":[7338,7590],"content":"For more information about using the HttpCfg.exe tool to set up a port with an X.509 certificate, see <bpt id=\"p1\">[</bpt>How to: Configure a Port with an SSL Certificate<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-configure-a-port-with-an-ssl-certificate.md)</ept>.","source":"For more information about using the HttpCfg.exe tool to set up a port with an X.509 certificate, see [How to: Configure a Port with an SSL Certificate](../../../../docs/framework/wcf/feature-details/how-to-configure-a-port-with-an-ssl-certificate.md)."},{"pos":[7599,7607],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7611,7701],"content":"<bpt id=\"p1\">[</bpt>Transport Security<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/transport-security.md)</ept>","source":"[Transport Security](../../../../docs/framework/wcf/feature-details/transport-security.md)"},{"pos":[7704,7797],"content":"<bpt id=\"p1\">[</bpt>Message Security<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/message-security-in-wcf.md)</ept>","source":"[Message Security](../../../../docs/framework/wcf/feature-details/message-security-in-wcf.md)"}]}