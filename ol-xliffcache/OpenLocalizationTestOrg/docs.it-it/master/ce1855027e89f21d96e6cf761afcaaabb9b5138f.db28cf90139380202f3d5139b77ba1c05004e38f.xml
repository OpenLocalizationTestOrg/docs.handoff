{"content":"---\ntitle: \"Pausing and interrupting threads\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"interrupting threads\"\n  - \"threading [.NET Framework], pausing\"\n  - \"pausing threads\"\nms.assetid: 9fce4859-a19d-4506-b082-7dd0792688ca\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Pausing and interrupting threads\n\nThe most common ways to synchronize the activities of threads are to block and release threads, or to lock objects or regions of code. For more information on these locking and blocking mechanisms, see [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md).  \n  \n You can also have threads put themselves to sleep. When threads are blocked or sleeping, you can use a <xref:System.Threading.ThreadInterruptedException> to break them out of their wait states.  \n  \n## The Thread.Sleep method\n\n Calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method causes the current thread to immediately block for the number of milliseconds or the time interval you pass to the method, and yields the remainder of its time slice to another thread. Once that interval elapses, the sleeping thread resumes execution.  \n  \n One thread cannot call <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> on another thread.  <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> is a static method that always causes the current thread to sleep.  \n  \n Calling <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> with a value of <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> causes a thread to sleep until it is interrupted by another thread that calls the  <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> method on the sleeping thread, or until it is terminated by a call to its <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> method.  The following example illustrates both methods of interrupting a sleeping thread.  \n  \n [!code-csharp[Conceptual.Threading.Resuming#1](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.Threading.Resuming/cs/Sleep1.cs#1)]\n [!code-vb[Conceptual.Threading.Resuming#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.Threading.Resuming/vb/Sleep1.vb#1)]  \n  \n## Interrupting threads\n\n You can interrupt a waiting thread by calling the <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> method on the blocked thread to throw a <xref:System.Threading.ThreadInterruptedException>, which breaks the thread out of the blocking call. The thread should catch the <xref:System.Threading.ThreadInterruptedException> and do whatever is appropriate to continue working. If the thread ignores the exception, the runtime catches the exception and stops the thread.  \n  \n> [!NOTE]\n>  If the target thread is not blocked when <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> is called, the thread is not interrupted until it blocks. If the thread never blocks, it could complete without ever being interrupted.  \n  \n If a wait is a managed wait, then <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> both wake the thread immediately. If a wait is an unmanaged wait (for example, a platform invoke call to the Win32 [WaitForSingleObject](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function), neither <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> nor <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> can take control of the thread until it returns to or calls into managed code. In managed code, the behavior is as follows:  \n  \n-   <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> wakes a thread out of any wait it might be in and causes a <xref:System.Threading.ThreadInterruptedException> to be thrown in the destination thread.  \n  \n-   <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> wakes a thread out of any wait it might be in and causes a <xref:System.Threading.ThreadAbortException> to be thrown on the thread. For details, see [Destroying Threads](../../../docs/standard/threading/destroying-threads.md).  \n  \n## See also\n\n- <xref:System.Threading.Thread>\n- <xref:System.Threading.ThreadInterruptedException>\n- <xref:System.Threading.ThreadAbortException>\n- [Threading](../../../docs/standard/threading/index.md)\n- [Using Threads and Threading](../../../docs/standard/threading/using-threads-and-threading.md)\n- [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md)\n","nodes":[{"pos":[4,334],"embed":true,"restype":"x-metadata","content":"title: \"Pausing and interrupting threads\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"interrupting threads\"\n  - \"threading [.NET Framework], pausing\"\n  - \"pausing threads\"\nms.assetid: 9fce4859-a19d-4506-b082-7dd0792688ca\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Pausing and interrupting threads","nodes":[{"pos":[0,32],"content":"Pausing and interrupting threads","nodes":[{"content":"Pausing and interrupting threads","pos":[0,32]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[341,373],"content":"Pausing and interrupting threads","linkify":"Pausing and interrupting threads","nodes":[{"content":"Pausing and interrupting threads","pos":[0,32]}]},{"content":"The most common ways to synchronize the activities of threads are to block and release threads, or to lock objects or regions of code.","pos":[375,509]},{"content":"For more information on these locking and blocking mechanisms, see <bpt id=\"p1\">[</bpt>Overview of Synchronization Primitives<ept id=\"p1\">](../../../docs/standard/threading/overview-of-synchronization-primitives.md)</ept>.","pos":[510,694],"source":" For more information on these locking and blocking mechanisms, see [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md)."},{"content":"You can also have threads put themselves to sleep.","pos":[701,751]},{"content":"When threads are blocked or sleeping, you can use a <ph id=\"ph1\">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> to break them out of their wait states.","pos":[752,894],"source":" When threads are blocked or sleeping, you can use a <xref:System.Threading.ThreadInterruptedException> to break them out of their wait states."},{"pos":[903,926],"content":"The Thread.Sleep method","linkify":"The Thread.Sleep method","nodes":[{"content":"The Thread.Sleep method","pos":[0,23]}]},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method causes the current thread to immediately block for the number of milliseconds or the time interval you pass to the method, and yields the remainder of its time slice to another thread.","pos":[929,1201],"source":"Calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method causes the current thread to immediately block for the number of milliseconds or the time interval you pass to the method, and yields the remainder of its time slice to another thread."},{"content":"Once that interval elapses, the sleeping thread resumes execution.","pos":[1202,1268]},{"content":"One thread cannot call <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> on another thread.","pos":[1275,1385],"source":"One thread cannot call <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> on another thread."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> is a static method that always causes the current thread to sleep.","pos":[1387,1522],"source":"<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> is a static method that always causes the current thread to sleep."},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> with a value of <ph id=\"ph2\">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> causes a thread to sleep until it is interrupted by another thread that calls the  <ph id=\"ph3\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> method on the sleeping thread, or until it is terminated by a call to its <ph id=\"ph4\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[1529,1998],"source":"Calling <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> with a value of <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> causes a thread to sleep until it is interrupted by another thread that calls the  <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> method on the sleeping thread, or until it is terminated by a call to its <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> method."},{"content":"The following example illustrates both methods of interrupting a sleeping thread.","pos":[2000,2081]},{"pos":[2384,2404],"content":"Interrupting threads","linkify":"Interrupting threads","nodes":[{"content":"Interrupting threads","pos":[0,20]}]},{"content":"You can interrupt a waiting thread by calling the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> method on the blocked thread to throw a <ph id=\"ph2\">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph>, which breaks the thread out of the blocking call.","pos":[2407,2671],"source":"You can interrupt a waiting thread by calling the <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> method on the blocked thread to throw a <xref:System.Threading.ThreadInterruptedException>, which breaks the thread out of the blocking call."},{"content":"The thread should catch the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> and do whatever is appropriate to continue working.","pos":[2672,2802],"source":" The thread should catch the <xref:System.Threading.ThreadInterruptedException> and do whatever is appropriate to continue working."},{"content":"If the thread ignores the exception, the runtime catches the exception and stops the thread.","pos":[2803,2895]},{"pos":[2903,3163],"content":"[!NOTE]\n If the target thread is not blocked when <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> is called, the thread is not interrupted until it blocks. If the thread never blocks, it could complete without ever being interrupted.","leadings":["","> "],"nodes":[{"content":"If the target thread is not blocked when <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> is called, the thread is not interrupted until it blocks. If the thread never blocks, it could complete without ever being interrupted.","pos":[9,258],"nodes":[{"content":"If the target thread is not blocked when <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> is called, the thread is not interrupted until it blocks.","pos":[0,171],"source":"If the target thread is not blocked when <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> is called, the thread is not interrupted until it blocks."},{"content":"If the thread never blocks, it could complete without ever being interrupted.","pos":[172,249]}]}]},{"content":"If a wait is a managed wait, then <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph> both wake the thread immediately.","pos":[3170,3383],"source":"If a wait is a managed wait, then <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> both wake the thread immediately."},{"content":"If a wait is an unmanaged wait (for example, a platform invoke call to the Win32 <bpt id=\"p1\">[</bpt>WaitForSingleObject<ept id=\"p1\">](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject)</ept> function), neither <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> nor <ph id=\"ph2\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph> can take control of the thread until it returns to or calls into managed code.","pos":[3384,3793],"source":" If a wait is an unmanaged wait (for example, a platform invoke call to the Win32 [WaitForSingleObject](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function), neither <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> nor <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> can take control of the thread until it returns to or calls into managed code."},{"content":"In managed code, the behavior is as follows:","pos":[3794,3838]},{"pos":[3848,4070],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> wakes a thread out of any wait it might be in and causes a <ph id=\"ph2\">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> to be thrown in the destination thread.","source":"<xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> wakes a thread out of any wait it might be in and causes a <xref:System.Threading.ThreadInterruptedException> to be thrown in the destination thread."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph> wakes a thread out of any wait it might be in and causes a <ph id=\"ph2\">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> to be thrown on the thread.","pos":[4080,4280],"source":"<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> wakes a thread out of any wait it might be in and causes a <xref:System.Threading.ThreadAbortException> to be thrown on the thread."},{"content":"For details, see <bpt id=\"p1\">[</bpt>Destroying Threads<ept id=\"p1\">](../../../docs/standard/threading/destroying-threads.md)</ept>.","pos":[4281,4375],"source":" For details, see [Destroying Threads](../../../docs/standard/threading/destroying-threads.md)."},{"pos":[4384,4392],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4529,4583],"content":"<bpt id=\"p1\">[</bpt>Threading<ept id=\"p1\">](../../../docs/standard/threading/index.md)</ept>","source":"[Threading](../../../docs/standard/threading/index.md)"},{"pos":[4586,4680],"content":"<bpt id=\"p1\">[</bpt>Using Threads and Threading<ept id=\"p1\">](../../../docs/standard/threading/using-threads-and-threading.md)</ept>","source":"[Using Threads and Threading](../../../docs/standard/threading/using-threads-and-threading.md)"},{"pos":[4683,4799],"content":"<bpt id=\"p1\">[</bpt>Overview of Synchronization Primitives<ept id=\"p1\">](../../../docs/standard/threading/overview-of-synchronization-primitives.md)</ept>","source":"[Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md)"}]}