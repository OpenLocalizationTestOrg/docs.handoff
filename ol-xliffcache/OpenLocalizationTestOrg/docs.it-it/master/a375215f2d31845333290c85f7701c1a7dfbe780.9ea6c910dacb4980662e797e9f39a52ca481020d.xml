{"content":"---\ntitle: Create a REST client using .NET Core\ndescription: This tutorial teaches you a number of features in .NET Core and the C# language.\nms.date: 03/06/2017\nms.assetid: 51033ce2-7a53-4cdd-966d-9da15c8204d2\n---\n\n# REST client\n\n## Introduction\n\nThis tutorial teaches you a number of features in .NET Core and the C# language. You’ll learn:\n\n* The basics of the .NET Core Command Line Interface (CLI).\n* An overview of C# Language features.\n* Managing dependencies with NuGet\n* HTTP Communications\n* Processing JSON information\n* Managing configuration with Attributes.\n\nYou’ll build an application that issues HTTP Requests to a REST\nservice on GitHub. You'll read information in JSON format, and convert\nthat JSON packet into C# objects. Finally, you'll see how to work with\nC# objects.\n\nThere are a lot of features in this tutorial. Let’s build them one by one.\n\nIf you prefer to follow along with the [final sample](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient) for this topic, you can download it. For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).\n\n## Prerequisites\n\nYou’ll need to set up your machine to run .NET core. You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage. You can run this\napplication on Windows, Linux, macOS or in a Docker container.\nYou’ll need to install your favorite code editor. The descriptions below\nuse [Visual Studio Code](https://code.visualstudio.com/), which is an open\nsource, cross platform editor. However, you can use whatever tools you are\ncomfortable with.\n\n## Create the Application\n\nThe first step is to create a new application. Open a command prompt and\ncreate a new directory for your application. Make that the current\ndirectory. Type the command `dotnet new console` at the command prompt. This\ncreates the starter files for a basic \"Hello World\" application.\n\nBefore you start making modifications, let’s go through the steps to run\nthe simple Hello World application. After creating the application, type\n`dotnet restore` ([see note](#dotnet-restore-note)) at the command prompt. This command runs the NuGet\npackage restore process. NuGet is a .NET package manager. This command\ndownloads any of the missing dependencies for your project. As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework. After this initial step, you will only\nneed to run `dotnet restore` ([see note](#dotnet-restore-note)) when you add new dependent packages, or update\nthe versions of any of your dependencies.\n\nAfter restoring packages, you run `dotnet build`. This executes the build\nengine and creates your application. Finally, you execute `dotnet run` to\nrun your application.\n\n## Adding New Dependencies\n\nOne of the key design goals for .NET Core is to minimize the size of\nthe .NET installation. If an application\nneeds additional libraries for some of its features, you add those\ndependencies into your C# project (\\*.csproj) file. For our example, you'll need to add the `System.Runtime.Serialization.Json` package\nso your application can process JSON responses.\n\nOpen your `csproj` project file. The first line of the file should appear as:\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n```\n\nAdd the following immediately after this line:\n\n```xml\n   <ItemGroup>\n      <PackageReference Include=\"System.Runtime.Serialization.Json\" Version=\"4.3.0\" />\n   </ItemGroup>\n```\n\nMost code editors will provide completion for different versions of these\nlibraries. You'll usually want to use the latest version of any package\nthat you add. However, it is important to make sure that the versions\nof all packages match, and that they also match the version of the .NET\nCore Application framework.\n\nAfter you've made these changes, you should run `dotnet restore` ([see note](#dotnet-restore-note)) again so\nthat the package is installed on your system.\n\n## Making Web Requests\n\nNow you're ready to start retrieving data from the web. In this\napplication, you'll read information from the\n[GitHub API](https://developer.github.com/v3/). Let's read information\nabout the projects under the\n[.NET Foundation](https://www.dotnetfoundation.org/) umbrella. You'll\nstart by making the request to the GitHub API to retrieve information\non the projects. The endpoint you'll use is: [https://api.github.com/orgs/dotnet/repos](https://api.github.com/orgs/dotnet/repos). You want to retrieve all the\ninformation about these projects, so you'll use an HTTP GET request.\nYour browser also uses HTTP GET requests, so you can paste that URL into\nyour browser to see what information you'll be receiving and processing.\n\nYou use the <xref:System.Net.Http.HttpClient> class to make web requests. Like all modern .NET\nAPIs, <xref:System.Net.Http.HttpClient> supports only async methods for its long-running APIs.\nStart by making an async method. You'll fill in the implementation as you\nbuild the functionality of the application. Start by opening the `program.cs` file in your project directory and adding the following method to the `Program` class:\n\n```csharp\nprivate static async Task ProcessRepositories()\n{\n}\n```\n\nYou'll need to add a `using` statement at the top of your `Main` method so\nthat the C# compiler recognizes the <xref:System.Threading.Tasks.Task> type:\n\n```csharp\nusing System.Threading.Tasks;\n```\n\nIf you build your project at this point, you'll get a warning generated\nfor this method, because it does not contain any `await` operators and\nwill run synchronously. Ignore that for now; you'll add `await` operators\nas you fill in the method.\n\nNext, rename the namespace defined in the `namespace` statement from its default of `ConsoleApp` to `WebAPIClient`. We'll later define a `repo` class in this namespace.\n\nNext, update the `Main` method to call this method. The\n`ProcessRepositories` method returns a Task, and you shouldn't exit the\nprogram before that task finishes. Therefore, you must use the `Wait`\nmethod to block and wait for the task to finish:\n\n```csharp\nstatic void Main(string[] args)\n{\n    ProcessRepositories().Wait();\n}\n```\n\nNow, you have a program that does nothing, but does it asynchronously. Let's improve it.\n\nFirst you need an object that is capable to retrieve data from the web; you can use\n a <xref:System.Net.Http.HttpClient> to do that. This object handles the request and the responses. Instantiate a single instance of that type in the `Program` class inside the Program.cs file.\n\n```csharp\nnamespace WebAPIClient\n{\n    class Program\n    {\n        private static readonly HttpClient client = new HttpClient();\n\n        static void Main(string[] args)\n        {\n            //...\n        }\n    }\n}\n```\n\nLet's go back to the `ProcessRepositories` method and fill in a first version of it:\n\n```csharp\nprivate static async Task ProcessRepositories()\n{\n    client.DefaultRequestHeaders.Accept.Clear();\n    client.DefaultRequestHeaders.Accept.Add(\n        new MediaTypeWithQualityHeaderValue(\"application/vnd.github.v3+json\"));\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \".NET Foundation Repository Reporter\");\n\n    var stringTask = client.GetStringAsync(\"https://api.github.com/orgs/dotnet/repos\");\n\n    var msg = await stringTask;\n    Console.Write(msg);\n}\n```\n\nYou'll need to also add two new using statements at the top of the file for this to compile:\n\n```csharp\nusing System.Net.Http;\nusing System.Net.Http.Headers;\n```\n\nThis first version makes a web request to read the list of all repositories under the dotnet\nfoundation organization. (The gitHub ID for the .NET Foundation is 'dotnet'). The first few lines set up\nthe <xref:System.Net.Http.HttpClient> for this request. First, it is configured to accept the GitHub JSON responses.\nThis format is simply JSON. The next line adds a User Agent header to all requests from this\nobject. These two headers are checked by the GitHub server code, and are necessary to retrieve\ninformation from GitHub.\n\nAfter you've configured the <xref:System.Net.Http.HttpClient>, you make a web request and retrieve the response. In\nthis first version, you use the <xref:System.Net.Http.HttpClient.GetStringAsync(System.String)?displayProperty=nameWithType> convenience method. This convenience method\nstarts a task that makes the web request, and then when the request returns, it reads the\nresponse stream and extracts the content from the stream. The body of the response is returned\nas a <xref:System.String>. The string is available when the task completes.\n\nThe final two lines of this method await that task, and then print the response to the console.\nBuild the app, and run it. The build warning is gone now, because the `ProcessRepositories` now\ndoes contain an `await` operator. You'll see a long display of JSON formatted text.\n\n## Processing the JSON Result\n\nAt this point, you've written the code to retrieve a response from a web server, and display\nthe text that is contained in that response. Next, let's convert that JSON response into C#\nobjects.\n\nThe JSON Serializer converts JSON data into C# Objects. Your first task is to define a C# class\ntype to contain the information you use from this response. Let's build this slowly, so start with\na simple C# type that contains the name of the repository:\n\n```csharp\nusing System;\n\nnamespace WebAPIClient\n{\n    public class repo\n    {\n        public string name;\n    }\n}\n```\n\nPut the above code in a new file called 'repo.cs'. This version of the class represents the\nsimplest path to process JSON data. The class name and the member name match the names used\nin the JSON packet, instead of following C# conventions. You'll fix that by providing some\nconfiguration attributes later. This class demonstrates another important feature of JSON\nserialization and deserialization: Not all the fields in the JSON packet are part of this class.\nThe JSON serializer will ignore information that is not included in the class type being used.\nThis feature makes it easier to create types that work with only a subset of the fields in\nthe JSON packet.\n\nNow that you've created the type, let's deserialize it. You'll need to create a\n<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> object. This object must know the CLR type expected for the\nJSON packet it retrieves. The packet from GitHub contains a sequence of repositories, so a\n`List<repo>` is the correct type. Add the following line to your `ProcessRepositories` method:\n\n```csharp\nvar serializer = new DataContractJsonSerializer(typeof(List<repo>));\n```\n\nYou're using two new namespaces, so you'll need to add those as well:\n\n```csharp\nusing System.Collections.Generic;\nusing System.Runtime.Serialization.Json;\n```\n\nNext, you'll use the serializer to convert JSON into C# objects. Replace the call to\n<xref:System.Net.Http.HttpClient.GetStringAsync(System.String)> in your `ProcessRepositories` method with the following two lines:\n\n```csharp\nvar streamTask = client.GetStreamAsync(\"https://api.github.com/orgs/dotnet/repos\");\nvar repositories = serializer.ReadObject(await streamTask) as List<repo>;\n```\n\nNotice that you're now using <xref:System.Net.Http.HttpClient.GetStreamAsync(System.String)> instead of <xref:System.Net.Http.HttpClient.GetStringAsync(System.String)>. The serializer\nuses a stream instead of a string as its source. Let's explain a couple features of the C#\nlanguage that are being used in the second line above. The argument to <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)> is an\n`await` expression. Await expressions can appear almost anywhere in your code, even though\nup to now, you've only seen them as part of an assignment statement.\n\nSecondly, the `as` operator converts from the compile time type of `object` to `List<repo>`.\nThe declaration of <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)> declares that it returns an object of type <xref:System.Object?displayProperty=nameWithType>. <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)> will return the type you specified when you constructed it (`List<repo>` in\nthis tutorial). If the conversion does not succeed, the `as` operator evaluates to `null`,\ninstead of throwing an exception.\n\nYou're almost done with this section. Now that you've converted the JSON to C# objects, let's display\nthe name of each repository. Replace the lines that read:\n\n```csharp\nvar msg = await stringTask;   //**Deleted this\nConsole.Write(msg);\n```\n\nwith the following:\n\n```csharp\nforeach (var repo in repositories)\n    Console.WriteLine(repo.name);\n```\n\nCompile and run the application. It will print out the names of the repositories that are part of the\n.NET Foundation.\n\n## Controlling Serialization\n\nBefore you add more features, let's address the `repo` type and make it follow more standard\nC# conventions. You'll do this by annotating the `repo` type with *attributes* that control how\nthe JSON Serializer works. In your case, you'll use these attributes to define a mapping between\nthe JSON key names and the C# class and member names. The two attributes used are the <xref:System.Runtime.Serialization.DataContractAttribute>\nand <xref:System.Runtime.Serialization.DataMemberAttribute> attributes. By convention, all Attribute classes end in the suffix\n`Attribute`. However, you do not need to use that suffix when you apply an attribute.\n\nThe <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes are in a different library, so you'll need to add\nthat library to your C# project file as a dependency. Add the following line to the `<ItemGroup>` section of your project file:\n\n```xml\n<PackageReference Include=\"System.Runtime.Serialization.Primitives\" Version=\"4.3.0\" />\n```\n\nAfter you save the file, run `dotnet restore` ([see note](#dotnet-restore-note)) to retrieve this package.\n\nNext, open the `repo.cs` file. Let's change the name to use Pascal Case, and fully spell out the name\n`Repository`. We still want to map JSON 'repo' nodes to this type, so you'll need to add the\n<xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class declaration. You'll set the `Name` property of the attribute\nto the name of the JSON nodes that map to this type:\n\n```csharp\n[DataContract(Name=\"repo\")]\npublic class Repository\n```\n\nThe <xref:System.Runtime.Serialization.DataContractAttribute> is a member of the <xref:System.Runtime.Serialization> namespace, so you'll\nneed to add the appropriate `using` statement at the top of the file:\n\n```csharp\nusing System.Runtime.Serialization;\n```\n\nYou changed the name of the `repo` class to `Repository`, so you'll need to make the same name change\nin Program.cs (some editors may support a rename refactoring that will make this change automatically:)\n\n```csharp\nvar serializer = new DataContractJsonSerializer(typeof(List<Repository>));\n\n// ...\n\nvar repositories = serializer.ReadObject(await streamTask) as List<Repository>;\n```\n\nNext, let's make the same change with the `name` field by using the <xref:System.Runtime.Serialization.DataMemberAttribute> class. Make\nthe following changes to the declaration of the `name` field in repo.cs:\n\n```csharp\n[DataMember(Name=\"name\")]\npublic string Name;\n```\n\nThis change means you need to change the code that writes the name of each repository in program.cs:\n\n```csharp\nConsole.WriteLine(repo.Name);\n```\n\nDo a `dotnet build` followed by a `dotnet run` to make sure you've got the mappings correct. You should\nsee the same output as before. Before we process more properties from the web server, let's make one\nmore change to the `Repository` class. The `Name` member is a publicly accessible field. That's not\na good object-oriented practice, so let's change it to a property. For our purposes, we don't need\nany specific code to run when getting or setting the property, but changing to a property makes it\neasier to add those changes later without breaking any code that uses the `Repository` class.\n\nRemove the field definition, and replace it with an [auto-implemented property](../programming-guide/classes-and-structs/auto-implemented-properties.md):\n\n```csharp\npublic string Name { get; set; }\n```\n\nThe compiler generates the body of the `get` and `set` accessors, as well as a private field to\nstore the name. It would be similar to the following code that you could type by hand:\n\n```csharp\npublic string Name\n{\n    get { return this._name; }\n    set { this._name = value; }\n}\nprivate string _name;\n```\n\nLet's make one more change before adding new features. The `ProcessRepositories` method can do the async\nwork and return a collection of the repositories. Let's return the `List<Repository>` from that method,\nand move the code that writes the information into the `Main` method.\n\nChange the signature of `ProcessRepositories` to return a task whose result is a list of `Repository`\nobjects:\n\n```csharp\nprivate static async Task<List<Repository>> ProcessRepositories()\n```\n\nThen, just return the repositories after processing the JSON response:\n\n```csharp\nvar repositories = serializer.ReadObject(await streamTask) as List<Repository>;\nreturn repositories;\n```\n\nThe compiler generates the `Task<T>` object for the return because you've marked this method as `async`.\nThen, let's modify the `Main` method so that it captures those results and writes each repository name\nto the console. Your `Main` method now looks like this:\n\n```csharp\npublic static void Main(string[] args)\n{\n    var repositories = ProcessRepositories().Result;\n\n    foreach (var repo in repositories)\n        Console.WriteLine(repo.Name);\n}\n```\n\nAccessing the `Result` property of a Task blocks until the task has completed. Normally, you would prefer\nto `await` the completion of the task, as in the `ProcessRepositories` method, but that isn't allowed in the\n`Main` method.\n\n## Reading More Information\n\nLet's finish this by processing a few more of the properties in the JSON packet that gets sent from the\nGitHub API. You won't want to grab everything, but adding a few properties will demonstrate a few more\nfeatures of the C# language.\n\nLet's start by adding a few more simple types to the `Repository` class definition. Add these properties\nto that class:\n\n```csharp\n[DataMember(Name=\"description\")]\npublic string Description { get; set; }\n\n[DataMember(Name=\"html_url\")]\npublic Uri GitHubHomeUrl { get; set; }\n\n[DataMember(Name=\"homepage\")]\npublic Uri Homepage { get; set; }\n\n[DataMember(Name=\"watchers\")]\npublic int Watchers { get; set; }\n```\n\nThese properties have built-in conversions from the string type (which is what the JSON packets contain) to\nthe target type. The <xref:System.Uri> type may be new to you. It represents a URI, or in this case, a URL. In the case\nof the `Uri` and `int` types, if the JSON packet contains data that does not convert to the target type,\nthe serialization action will throw an exception.\n\nOnce you've added these, update the `Main` method to display those elements:\n\n```csharp\nforeach (var repo in repositories)\n{\n    Console.WriteLine(repo.Name);\n    Console.WriteLine(repo.Description);\n    Console.WriteLine(repo.GitHubHomeUrl);\n    Console.WriteLine(repo.Homepage);\n    Console.WriteLine(repo.Watchers);\n    Console.WriteLine();\n}\n```\n\nAs a final step, let's add the information for the last push operation. This information is formatted in\nthis fashion in the JSON response:\n\n```json\n2016-02-08T21:27:00Z\n```\n\nThat format does not follow any of the standard .NET <xref:System.DateTime> formats. Because of that, you'll need to write\na custom conversion method. You also probably don't want the raw string exposed to users of the `Repository`\nclass. Attributes can help control that as well. First, define a `private` property that will hold the\nstring representation of the date time in your `Repository` class:\n\n```csharp\n[DataMember(Name=\"pushed_at\")]\nprivate string JsonDate { get; set; }\n```\n\nThe <xref:System.Runtime.Serialization.DataMemberAttribute> attribute informs the serializer that this should be processed, even though it is not\na public member. Next, you need to write a public read-only property that converts the string to a\nvalid <xref:System.DateTime> object, and returns that <xref:System.DateTime>:\n\n```csharp\n[IgnoreDataMember]\npublic DateTime LastPush\n{\n    get\n    {\n        return DateTime.ParseExact(JsonDate, \"yyyy-MM-ddTHH:mm:ssZ\", CultureInfo.InvariantCulture);\n    }\n}\n```\n\nLet's go over the new constructs above. The `IgnoreDataMember` attribute instructs the serializer\nthat this type should not be read to or written from any JSON object. This property contains only a\n`get` accessor. There is no `set` accessor. That's how you define a *read-only* property in C#. (Yes,\nyou can create *write-only* properties in C#, but their value is limited.) The <xref:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)>\nmethod parses a string and creates a <xref:System.DateTime> object using a provided date format, and adds additional\nmetadata to the `DateTime` using a `CultureInfo` object. If the parse operation fails, the\nproperty accessor throws an exception.\n\nTo use <xref:System.Globalization.CultureInfo.InvariantCulture>, you will need to add the <xref:System.Globalization> namespace to the `using` statements\nin `repo.cs`:\n\n```csharp\nusing System.Globalization;\n```\n\nFinally, add one more output statement in the console, and you're ready to build and run this app\nagain:\n\n```csharp\nConsole.WriteLine(repo.LastPush);\n```\n\nYour version should now match the [finished sample](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient).\n\n## Conclusion\n\nThis tutorial showed you how to make web requests, parse the result, and display properties of\nthose results. You've also added new packages as dependencies in your project. You've seen some of\nthe features of the C# language that support object-oriented techniques.\n\n<a name=\"dotnet-restore-note\"></a>\n\n[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]\n","nodes":[{"pos":[4,210],"embed":true,"restype":"x-metadata","content":"title: Create a REST client using .NET Core\ndescription: This tutorial teaches you a number of features in .NET Core and the C# language.\nms.date: 03/06/2017\nms.assetid: 51033ce2-7a53-4cdd-966d-9da15c8204d2","nodes":[{"content":"Create a REST client using .NET Core","nodes":[{"pos":[0,36],"content":"Create a REST client using .NET Core","nodes":[{"content":"Create a REST client using .NET Core","pos":[0,36]}]}],"path":["title"],"nosxs":false},{"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","nodes":[{"pos":[0,80],"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","nodes":[{"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","pos":[0,80]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[218,229],"content":"REST client","linkify":"REST client","nodes":[{"content":"REST client","pos":[0,11]}]},{"pos":[234,246],"content":"Introduction","linkify":"Introduction","nodes":[{"content":"Introduction","pos":[0,12]}]},{"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","pos":[248,328]},{"content":"You’ll learn:","pos":[329,342]},{"content":"The basics of the .NET Core Command Line Interface (CLI).","pos":[346,403]},{"content":"An overview of C# Language features.","pos":[406,442]},{"content":"Managing dependencies with NuGet","pos":[445,477]},{"content":"HTTP Communications","pos":[480,499]},{"content":"Processing JSON information","pos":[502,529]},{"content":"Managing configuration with Attributes.","pos":[532,571]},{"content":"You’ll build an application that issues HTTP Requests to a REST service on GitHub.","pos":[573,655],"source":"You’ll build an application that issues HTTP Requests to a REST\nservice on GitHub."},{"content":"You'll read information in JSON format, and convert that JSON packet into C# objects.","pos":[656,741],"source":" You'll read information in JSON format, and convert\nthat JSON packet into C# objects."},{"content":"Finally, you'll see how to work with C# objects.","pos":[742,790],"source":" Finally, you'll see how to work with\nC# objects."},{"content":"There are a lot of features in this tutorial.","pos":[792,837]},{"content":"Let’s build them one by one.","pos":[838,866]},{"content":"If you prefer to follow along with the <bpt id=\"p1\">[</bpt>final sample<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient)</ept> for this topic, you can download it.","pos":[868,1049],"source":"If you prefer to follow along with the [final sample](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient) for this topic, you can download it."},{"content":"For download instructions, see <bpt id=\"p1\">[</bpt>Samples and Tutorials<ept id=\"p1\">](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)</ept>.","pos":[1050,1175],"source":" For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)."},{"pos":[1180,1193],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"You’ll need to set up your machine to run .NET core.","pos":[1195,1247]},{"content":"You can find the installation instructions on the <bpt id=\"p1\">[</bpt>.NET Core<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> page.","pos":[1248,1351],"source":" You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage."},{"content":"You can run this application on Windows, Linux, macOS or in a Docker container.","pos":[1352,1431],"source":" You can run this\napplication on Windows, Linux, macOS or in a Docker container."},{"content":"You’ll need to install your favorite code editor.","pos":[1432,1481],"source":"\nYou’ll need to install your favorite code editor."},{"content":"The descriptions below use <bpt id=\"p1\">[</bpt>Visual Studio Code<ept id=\"p1\">](https://code.visualstudio.com/)</ept>, which is an open source, cross platform editor.","pos":[1482,1610],"source":" The descriptions below\nuse [Visual Studio Code](https://code.visualstudio.com/), which is an open\nsource, cross platform editor."},{"content":"However, you can use whatever tools you are comfortable with.","pos":[1611,1672],"source":" However, you can use whatever tools you are\ncomfortable with."},{"pos":[1677,1699],"content":"Create the Application","linkify":"Create the Application","nodes":[{"content":"Create the Application","pos":[0,22]}]},{"content":"The first step is to create a new application.","pos":[1701,1747]},{"content":"Open a command prompt and create a new directory for your application.","pos":[1748,1818],"source":" Open a command prompt and\ncreate a new directory for your application."},{"content":"Make that the current directory.","pos":[1819,1851],"source":" Make that the current\ndirectory."},{"content":"Type the command <ph id=\"ph1\">`dotnet new console`</ph> at the command prompt.","pos":[1852,1912],"source":" Type the command `dotnet new console` at the command prompt."},{"content":"This creates the starter files for a basic \"Hello World\" application.","pos":[1913,1982],"source":" This\ncreates the starter files for a basic \"Hello World\" application."},{"content":"Before you start making modifications, let’s go through the steps to run the simple Hello World application.","pos":[1984,2092],"source":"Before you start making modifications, let’s go through the steps to run\nthe simple Hello World application."},{"content":"After creating the application, type <ph id=\"ph1\">`dotnet restore`</ph> (<bpt id=\"p1\">[</bpt>see note<ept id=\"p1\">](#dotnet-restore-note)</ept>) at the command prompt.","pos":[2093,2204],"source":" After creating the application, type\n`dotnet restore` ([see note](#dotnet-restore-note)) at the command prompt."},{"content":"This command runs the NuGet package restore process.","pos":[2205,2257],"source":" This command runs the NuGet\npackage restore process."},{"content":"NuGet is a .NET package manager.","pos":[2258,2290]},{"content":"This command downloads any of the missing dependencies for your project.","pos":[2291,2363],"source":" This command\ndownloads any of the missing dependencies for your project."},{"content":"As this is a new project, none of the dependencies are in place, so the first run will download the .NET Core framework.","pos":[2364,2484],"source":" As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework."},{"content":"After this initial step, you will only need to run <ph id=\"ph1\">`dotnet restore`</ph> (<bpt id=\"p1\">[</bpt>see note<ept id=\"p1\">](#dotnet-restore-note)</ept>) when you add new dependent packages, or update the versions of any of your dependencies.","pos":[2485,2676],"source":" After this initial step, you will only\nneed to run `dotnet restore` ([see note](#dotnet-restore-note)) when you add new dependent packages, or update\nthe versions of any of your dependencies."},{"content":"After restoring packages, you run <ph id=\"ph1\">`dotnet build`</ph>.","pos":[2678,2727],"source":"After restoring packages, you run `dotnet build`."},{"content":"This executes the build engine and creates your application.","pos":[2728,2788],"source":" This executes the build\nengine and creates your application."},{"content":"Finally, you execute <ph id=\"ph1\">`dotnet run`</ph> to run your application.","pos":[2789,2847],"source":" Finally, you execute `dotnet run` to\nrun your application."},{"pos":[2852,2875],"content":"Adding New Dependencies","linkify":"Adding New Dependencies","nodes":[{"content":"Adding New Dependencies","pos":[0,23]}]},{"content":"One of the key design goals for .NET Core is to minimize the size of the .NET installation.","pos":[2877,2968],"source":"One of the key design goals for .NET Core is to minimize the size of\nthe .NET installation."},{"content":"If an application needs additional libraries for some of its features, you add those dependencies into your C# project (<ph id=\"ph1\">\\*</ph>.csproj) file.","pos":[2969,3105],"source":" If an application\nneeds additional libraries for some of its features, you add those\ndependencies into your C# project (\\*.csproj) file."},{"content":"For our example, you'll need to add the <ph id=\"ph1\">`System.Runtime.Serialization.Json`</ph> package so your application can process JSON responses.","pos":[3106,3237],"source":" For our example, you'll need to add the `System.Runtime.Serialization.Json` package\nso your application can process JSON responses."},{"content":"Open your <ph id=\"ph1\">`csproj`</ph> project file.","pos":[3239,3271],"source":"Open your `csproj` project file."},{"content":"The first line of the file should appear as:","pos":[3272,3316]},{"content":"Add the following immediately after this line:","pos":[3364,3410]},{"content":"Most code editors will provide completion for different versions of these libraries.","pos":[3542,3626],"source":"Most code editors will provide completion for different versions of these\nlibraries."},{"content":"You'll usually want to use the latest version of any package that you add.","pos":[3627,3701],"source":" You'll usually want to use the latest version of any package\nthat you add."},{"content":"However, it is important to make sure that the versions of all packages match, and that they also match the version of the .NET Core Application framework.","pos":[3702,3857],"source":" However, it is important to make sure that the versions\nof all packages match, and that they also match the version of the .NET\nCore Application framework."},{"pos":[3859,4013],"content":"After you've made these changes, you should run <ph id=\"ph1\">`dotnet restore`</ph> (<bpt id=\"p1\">[</bpt>see note<ept id=\"p1\">](#dotnet-restore-note)</ept>) again so that the package is installed on your system.","source":"After you've made these changes, you should run `dotnet restore` ([see note](#dotnet-restore-note)) again so\nthat the package is installed on your system."},{"pos":[4018,4037],"content":"Making Web Requests","linkify":"Making Web Requests","nodes":[{"content":"Making Web Requests","pos":[0,19]}]},{"content":"Now you're ready to start retrieving data from the web.","pos":[4039,4094]},{"content":"In this application, you'll read information from the <bpt id=\"p1\">[</bpt>GitHub API<ept id=\"p1\">](https://developer.github.com/v3/)</ept>.","pos":[4095,4196],"source":" In this\napplication, you'll read information from the\n[GitHub API](https://developer.github.com/v3/)."},{"content":"Let's read information about the projects under the <bpt id=\"p1\">[</bpt>.NET Foundation<ept id=\"p1\">](https://www.dotnetfoundation.org/)</ept> umbrella.","pos":[4197,4311],"source":" Let's read information\nabout the projects under the\n[.NET Foundation](https://www.dotnetfoundation.org/) umbrella."},{"content":"You'll start by making the request to the GitHub API to retrieve information on the projects.","pos":[4312,4405],"source":" You'll\nstart by making the request to the GitHub API to retrieve information\non the projects."},{"content":"The endpoint you'll use is: <bpt id=\"p1\">[</bpt><ph id=\"ph1\">https://api.github.com/orgs/dotnet/repos</ph><ept id=\"p1\">](https://api.github.com/orgs/dotnet/repos)</ept>.","pos":[4406,4519],"source":" The endpoint you'll use is: [https://api.github.com/orgs/dotnet/repos](https://api.github.com/orgs/dotnet/repos)."},{"content":"You want to retrieve all the information about these projects, so you'll use an HTTP GET request.","pos":[4520,4617],"source":" You want to retrieve all the\ninformation about these projects, so you'll use an HTTP GET request."},{"content":"Your browser also uses HTTP GET requests, so you can paste that URL into your browser to see what information you'll be receiving and processing.","pos":[4618,4763],"source":"\nYour browser also uses HTTP GET requests, so you can paste that URL into\nyour browser to see what information you'll be receiving and processing."},{"content":"You use the <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> class to make web requests.","pos":[4765,4838],"source":"You use the <xref:System.Net.Http.HttpClient> class to make web requests."},{"content":"Like all modern .NET APIs, <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> supports only async methods for its long-running APIs.","pos":[4839,4954],"source":" Like all modern .NET\nAPIs, <xref:System.Net.Http.HttpClient> supports only async methods for its long-running APIs."},{"content":"Start by making an async method.","pos":[4955,4987],"source":"\nStart by making an async method."},{"content":"You'll fill in the implementation as you build the functionality of the application.","pos":[4988,5072],"source":" You'll fill in the implementation as you\nbuild the functionality of the application."},{"content":"Start by opening the <ph id=\"ph1\">`program.cs`</ph> file in your project directory and adding the following method to the <ph id=\"ph2\">`Program`</ph> class:","pos":[5073,5193],"source":" Start by opening the `program.cs` file in your project directory and adding the following method to the `Program` class:"},{"pos":[5262,5413],"content":"You'll need to add a <ph id=\"ph1\">`using`</ph> statement at the top of your <ph id=\"ph2\">`Main`</ph> method so that the C# compiler recognizes the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> type:","source":"You'll need to add a `using` statement at the top of your `Main` method so\nthat the C# compiler recognizes the <xref:System.Threading.Tasks.Task> type:"},{"content":"If you build your project at this point, you'll get a warning generated for this method, because it does not contain any <ph id=\"ph1\">`await`</ph> operators and will run synchronously.","pos":[5460,5626],"source":"If you build your project at this point, you'll get a warning generated\nfor this method, because it does not contain any `await` operators and\nwill run synchronously."},{"content":"Ignore that for now; you'll add <ph id=\"ph1\">`await`</ph> operators as you fill in the method.","pos":[5627,5703],"source":" Ignore that for now; you'll add `await` operators\nas you fill in the method."},{"content":"Next, rename the namespace defined in the <ph id=\"ph1\">`namespace`</ph> statement from its default of <ph id=\"ph2\">`ConsoleApp`</ph> to <ph id=\"ph3\">`WebAPIClient`</ph>.","pos":[5705,5820],"source":"Next, rename the namespace defined in the `namespace` statement from its default of `ConsoleApp` to `WebAPIClient`."},{"content":"We'll later define a <ph id=\"ph1\">`repo`</ph> class in this namespace.","pos":[5821,5873],"source":" We'll later define a `repo` class in this namespace."},{"content":"Next, update the <ph id=\"ph1\">`Main`</ph> method to call this method.","pos":[5875,5926],"source":"Next, update the `Main` method to call this method."},{"content":"The <ph id=\"ph1\">`ProcessRepositories`</ph> method returns a Task, and you shouldn't exit the program before that task finishes.","pos":[5927,6037],"source":" The\n`ProcessRepositories` method returns a Task, and you shouldn't exit the\nprogram before that task finishes."},{"content":"Therefore, you must use the <ph id=\"ph1\">`Wait`</ph> method to block and wait for the task to finish:","pos":[6038,6121],"source":" Therefore, you must use the `Wait`\nmethod to block and wait for the task to finish:"},{"content":"Now, you have a program that does nothing, but does it asynchronously.","pos":[6208,6278]},{"content":"Let's improve it.","pos":[6279,6296]},{"content":"First you need an object that is capable to retrieve data from the web; you can use a <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> to do that.","pos":[6298,6430],"source":"First you need an object that is capable to retrieve data from the web; you can use\n a <xref:System.Net.Http.HttpClient> to do that."},{"content":"This object handles the request and the responses.","pos":[6431,6481]},{"content":"Instantiate a single instance of that type in the <ph id=\"ph1\">`Program`</ph> class inside the Program.cs file.","pos":[6482,6575],"source":" Instantiate a single instance of that type in the `Program` class inside the Program.cs file."},{"pos":[6798,6882],"content":"Let's go back to the <ph id=\"ph1\">`ProcessRepositories`</ph> method and fill in a first version of it:","source":"Let's go back to the `ProcessRepositories` method and fill in a first version of it:"},{"content":"You'll need to also add two new using statements at the top of the file for this to compile:","pos":[7362,7454]},{"content":"This first version makes a web request to read the list of all repositories under the dotnet foundation organization.","pos":[7525,7642],"source":"This first version makes a web request to read the list of all repositories under the dotnet\nfoundation organization."},{"content":"(The gitHub ID for the .NET Foundation is 'dotnet').","pos":[7643,7695]},{"content":"The first few lines set up the <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> for this request.","pos":[7696,7778],"source":" The first few lines set up\nthe <xref:System.Net.Http.HttpClient> for this request."},{"content":"First, it is configured to accept the GitHub JSON responses.","pos":[7779,7839]},{"content":"This format is simply JSON.","pos":[7840,7867],"source":"\nThis format is simply JSON."},{"content":"The next line adds a User Agent header to all requests from this object.","pos":[7868,7940],"source":" The next line adds a User Agent header to all requests from this\nobject."},{"content":"These two headers are checked by the GitHub server code, and are necessary to retrieve information from GitHub.","pos":[7941,8052],"source":" These two headers are checked by the GitHub server code, and are necessary to retrieve\ninformation from GitHub."},{"content":"After you've configured the <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient&gt;</ph>, you make a web request and retrieve the response.","pos":[8054,8166],"source":"After you've configured the <xref:System.Net.Http.HttpClient>, you make a web request and retrieve the response."},{"content":"In this first version, you use the <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient.GetStringAsync(System.String)?displayProperty=nameWithType&gt;</ph> convenience method.","pos":[8167,8314],"source":" In\nthis first version, you use the <xref:System.Net.Http.HttpClient.GetStringAsync(System.String)?displayProperty=nameWithType> convenience method."},{"content":"This convenience method starts a task that makes the web request, and then when the request returns, it reads the response stream and extracts the content from the stream.","pos":[8315,8486],"source":" This convenience method\nstarts a task that makes the web request, and then when the request returns, it reads the\nresponse stream and extracts the content from the stream."},{"content":"The body of the response is returned as a <ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","pos":[8487,8550],"source":" The body of the response is returned\nas a <xref:System.String>."},{"content":"The string is available when the task completes.","pos":[8551,8599]},{"content":"The final two lines of this method await that task, and then print the response to the console.","pos":[8601,8696]},{"content":"Build the app, and run it.","pos":[8697,8723],"source":"\nBuild the app, and run it."},{"content":"The build warning is gone now, because the <ph id=\"ph1\">`ProcessRepositories`</ph> now does contain an <ph id=\"ph2\">`await`</ph> operator.","pos":[8724,8826],"source":" The build warning is gone now, because the `ProcessRepositories` now\ndoes contain an `await` operator."},{"content":"You'll see a long display of JSON formatted text.","pos":[8827,8876]},{"pos":[8881,8907],"content":"Processing the JSON Result","linkify":"Processing the JSON Result","nodes":[{"content":"Processing the JSON Result","pos":[0,26]}]},{"content":"At this point, you've written the code to retrieve a response from a web server, and display the text that is contained in that response.","pos":[8909,9046],"source":"At this point, you've written the code to retrieve a response from a web server, and display\nthe text that is contained in that response."},{"content":"Next, let's convert that JSON response into C# objects.","pos":[9047,9102],"source":" Next, let's convert that JSON response into C#\nobjects."},{"content":"The JSON Serializer converts JSON data into C# Objects.","pos":[9104,9159]},{"content":"Your first task is to define a C# class type to contain the information you use from this response.","pos":[9160,9259],"source":" Your first task is to define a C# class\ntype to contain the information you use from this response."},{"content":"Let's build this slowly, so start with a simple C# type that contains the name of the repository:","pos":[9260,9357],"source":" Let's build this slowly, so start with\na simple C# type that contains the name of the repository:"},{"content":"Put the above code in a new file called 'repo.cs'.","pos":[9478,9528]},{"content":"This version of the class represents the simplest path to process JSON data.","pos":[9529,9605],"source":" This version of the class represents the\nsimplest path to process JSON data."},{"content":"The class name and the member name match the names used in the JSON packet, instead of following C# conventions.","pos":[9606,9718],"source":" The class name and the member name match the names used\nin the JSON packet, instead of following C# conventions."},{"content":"You'll fix that by providing some configuration attributes later.","pos":[9719,9784],"source":" You'll fix that by providing some\nconfiguration attributes later."},{"content":"This class demonstrates another important feature of JSON serialization and deserialization: Not all the fields in the JSON packet are part of this class.","pos":[9785,9939],"source":" This class demonstrates another important feature of JSON\nserialization and deserialization: Not all the fields in the JSON packet are part of this class."},{"content":"The JSON serializer will ignore information that is not included in the class type being used.","pos":[9940,10034],"source":"\nThe JSON serializer will ignore information that is not included in the class type being used."},{"content":"This feature makes it easier to create types that work with only a subset of the fields in the JSON packet.","pos":[10035,10142],"source":"\nThis feature makes it easier to create types that work with only a subset of the fields in\nthe JSON packet."},{"content":"Now that you've created the type, let's deserialize it.","pos":[10144,10199]},{"content":"You'll need to create a <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> object.","pos":[10200,10299],"source":" You'll need to create a\n<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> object."},{"content":"This object must know the CLR type expected for the JSON packet it retrieves.","pos":[10300,10377],"source":" This object must know the CLR type expected for the\nJSON packet it retrieves."},{"content":"The packet from GitHub contains a sequence of repositories, so a <ph id=\"ph1\">`List&lt;repo&gt;`</ph> is the correct type.","pos":[10378,10476],"source":" The packet from GitHub contains a sequence of repositories, so a\n`List<repo>` is the correct type."},{"content":"Add the following line to your <ph id=\"ph1\">`ProcessRepositories`</ph> method:","pos":[10477,10537],"source":" Add the following line to your `ProcessRepositories` method:"},{"content":"You're using two new namespaces, so you'll need to add those as well:","pos":[10623,10692]},{"content":"Next, you'll use the serializer to convert JSON into C# objects.","pos":[10784,10848]},{"content":"Replace the call to <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient.GetStringAsync(System.String)&gt;</ph> in your <ph id=\"ph2\">`ProcessRepositories`</ph> method with the following two lines:","pos":[10849,10999],"source":" Replace the call to\n<xref:System.Net.Http.HttpClient.GetStringAsync(System.String)> in your `ProcessRepositories` method with the following two lines:"},{"content":"Notice that you're now using <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient.GetStreamAsync(System.String)&gt;</ph> instead of <ph id=\"ph2\">&lt;xref:System.Net.Http.HttpClient.GetStringAsync(System.String)&gt;</ph>.","pos":[11174,11342],"source":"Notice that you're now using <xref:System.Net.Http.HttpClient.GetStreamAsync(System.String)> instead of <xref:System.Net.Http.HttpClient.GetStringAsync(System.String)>."},{"content":"The serializer uses a stream instead of a string as its source.","pos":[11343,11406],"source":" The serializer\nuses a stream instead of a string as its source."},{"content":"Let's explain a couple features of the C# language that are being used in the second line above.","pos":[11407,11503],"source":" Let's explain a couple features of the C#\nlanguage that are being used in the second line above."},{"content":"The argument to <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)&gt;</ph> is an <ph id=\"ph2\">`await`</ph> expression.","pos":[11504,11642],"source":" The argument to <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)> is an\n`await` expression."},{"content":"Await expressions can appear almost anywhere in your code, even though up to now, you've only seen them as part of an assignment statement.","pos":[11643,11782],"source":" Await expressions can appear almost anywhere in your code, even though\nup to now, you've only seen them as part of an assignment statement."},{"content":"Secondly, the <ph id=\"ph1\">`as`</ph> operator converts from the compile time type of <ph id=\"ph2\">`object`</ph> to <ph id=\"ph3\">`List&lt;repo&gt;`</ph>.","pos":[11784,11876],"source":"Secondly, the `as` operator converts from the compile time type of `object` to `List<repo>`."},{"content":"The declaration of <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)&gt;</ph> declares that it returns an object of type <ph id=\"ph2\">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.","pos":[11877,12086],"source":"\nThe declaration of <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)> declares that it returns an object of type <xref:System.Object?displayProperty=nameWithType>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)&gt;</ph> will return the type you specified when you constructed it (<ph id=\"ph2\">`List&lt;repo&gt;`</ph> in this tutorial).","pos":[12087,12275],"source":"<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject(System.IO.Stream)> will return the type you specified when you constructed it (`List<repo>` in\nthis tutorial)."},{"content":"If the conversion does not succeed, the <ph id=\"ph1\">`as`</ph> operator evaluates to <ph id=\"ph2\">`null`</ph>, instead of throwing an exception.","pos":[12276,12384],"source":" If the conversion does not succeed, the `as` operator evaluates to `null`,\ninstead of throwing an exception."},{"content":"You're almost done with this section.","pos":[12386,12423]},{"content":"Now that you've converted the JSON to C# objects, let's display the name of each repository.","pos":[12424,12516],"source":" Now that you've converted the JSON to C# objects, let's display\nthe name of each repository."},{"content":"Replace the lines that read:","pos":[12517,12545]},{"content":"with the following:","pos":[12629,12648]},{"content":"Compile and run the application.","pos":[12734,12766]},{"content":"It will print out the names of the repositories that are part of the .NET Foundation.","pos":[12767,12852],"source":" It will print out the names of the repositories that are part of the\n.NET Foundation."},{"pos":[12857,12882],"content":"Controlling Serialization","linkify":"Controlling Serialization","nodes":[{"content":"Controlling Serialization","pos":[0,25]}]},{"content":"Before you add more features, let's address the <ph id=\"ph1\">`repo`</ph> type and make it follow more standard C# conventions.","pos":[12884,12992],"source":"Before you add more features, let's address the `repo` type and make it follow more standard\nC# conventions."},{"content":"You'll do this by annotating the <ph id=\"ph1\">`repo`</ph> type with <bpt id=\"p1\">*</bpt>attributes<ept id=\"p1\">*</ept> that control how the JSON Serializer works.","pos":[12993,13099],"source":" You'll do this by annotating the `repo` type with *attributes* that control how\nthe JSON Serializer works."},{"content":"In your case, you'll use these attributes to define a mapping between the JSON key names and the C# class and member names.","pos":[13100,13223],"source":" In your case, you'll use these attributes to define a mapping between\nthe JSON key names and the C# class and member names."},{"content":"The two attributes used are the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attributes.","pos":[13224,13385],"source":" The two attributes used are the <xref:System.Runtime.Serialization.DataContractAttribute>\nand <xref:System.Runtime.Serialization.DataMemberAttribute> attributes."},{"content":"By convention, all Attribute classes end in the suffix <ph id=\"ph1\">`Attribute`</ph>.","pos":[13386,13453],"source":" By convention, all Attribute classes end in the suffix\n`Attribute`."},{"content":"However, you do not need to use that suffix when you apply an attribute.","pos":[13454,13526]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attributes are in a different library, so you'll need to add that library to your C# project file as a dependency.","pos":[13528,13764],"source":"The <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes are in a different library, so you'll need to add\nthat library to your C# project file as a dependency."},{"content":"Add the following line to the <ph id=\"ph1\">`&lt;ItemGroup&gt;`</ph> section of your project file:","pos":[13765,13838],"source":" Add the following line to the `<ItemGroup>` section of your project file:"},{"pos":[13939,14045],"content":"After you save the file, run <ph id=\"ph1\">`dotnet restore`</ph> (<bpt id=\"p1\">[</bpt>see note<ept id=\"p1\">](#dotnet-restore-note)</ept>) to retrieve this package.","source":"After you save the file, run `dotnet restore` ([see note](#dotnet-restore-note)) to retrieve this package."},{"content":"Next, open the <ph id=\"ph1\">`repo.cs`</ph> file.","pos":[14047,14077],"source":"Next, open the `repo.cs` file."},{"content":"Let's change the name to use Pascal Case, and fully spell out the name <ph id=\"ph1\">`Repository`</ph>.","pos":[14078,14162],"source":" Let's change the name to use Pascal Case, and fully spell out the name\n`Repository`."},{"content":"We still want to map JSON 'repo' nodes to this type, so you'll need to add the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute to the class declaration.","pos":[14163,14335],"source":" We still want to map JSON 'repo' nodes to this type, so you'll need to add the\n<xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class declaration."},{"content":"You'll set the <ph id=\"ph1\">`Name`</ph> property of the attribute to the name of the JSON nodes that map to this type:","pos":[14336,14436],"source":" You'll set the `Name` property of the attribute\nto the name of the JSON nodes that map to this type:"},{"pos":[14505,14712],"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> is a member of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization&gt;</ph> namespace, so you'll need to add the appropriate <ph id=\"ph3\">`using`</ph> statement at the top of the file:","source":"The <xref:System.Runtime.Serialization.DataContractAttribute> is a member of the <xref:System.Runtime.Serialization> namespace, so you'll\nneed to add the appropriate `using` statement at the top of the file:"},{"pos":[14765,14970],"content":"You changed the name of the <ph id=\"ph1\">`repo`</ph> class to <ph id=\"ph2\">`Repository`</ph>, so you'll need to make the same name change in Program.cs (some editors may support a rename refactoring that will make this change automatically:)","source":"You changed the name of the `repo` class to `Repository`, so you'll need to make the same name change\nin Program.cs (some editors may support a rename refactoring that will make this change automatically:)"},{"content":"Next, let's make the same change with the <ph id=\"ph1\">`name`</ph> field by using the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> class.","pos":[15151,15281],"source":"Next, let's make the same change with the `name` field by using the <xref:System.Runtime.Serialization.DataMemberAttribute> class."},{"content":"Make the following changes to the declaration of the <ph id=\"ph1\">`name`</ph> field in repo.cs:","pos":[15282,15359],"source":" Make\nthe following changes to the declaration of the `name` field in repo.cs:"},{"content":"This change means you need to change the code that writes the name of each repository in program.cs:","pos":[15422,15522]},{"content":"Do a <ph id=\"ph1\">`dotnet build`</ph> followed by a <ph id=\"ph2\">`dotnet run`</ph> to make sure you've got the mappings correct.","pos":[15569,15661],"source":"Do a `dotnet build` followed by a `dotnet run` to make sure you've got the mappings correct."},{"content":"You should see the same output as before.","pos":[15662,15703],"source":" You should\nsee the same output as before."},{"content":"Before we process more properties from the web server, let's make one more change to the <ph id=\"ph1\">`Repository`</ph> class.","pos":[15704,15812],"source":" Before we process more properties from the web server, let's make one\nmore change to the `Repository` class."},{"content":"The <ph id=\"ph1\">`Name`</ph> member is a publicly accessible field.","pos":[15813,15862],"source":" The `Name` member is a publicly accessible field."},{"content":"That's not a good object-oriented practice, so let's change it to a property.","pos":[15863,15940],"source":" That's not\na good object-oriented practice, so let's change it to a property."},{"content":"For our purposes, we don't need any specific code to run when getting or setting the property, but changing to a property makes it easier to add those changes later without breaking any code that uses the <ph id=\"ph1\">`Repository`</ph> class.","pos":[15941,16165],"source":" For our purposes, we don't need\nany specific code to run when getting or setting the property, but changing to a property makes it\neasier to add those changes later without breaking any code that uses the `Repository` class."},{"pos":[16167,16320],"content":"Remove the field definition, and replace it with an <bpt id=\"p1\">[</bpt>auto-implemented property<ept id=\"p1\">](../programming-guide/classes-and-structs/auto-implemented-properties.md)</ept>:","source":"Remove the field definition, and replace it with an [auto-implemented property](../programming-guide/classes-and-structs/auto-implemented-properties.md):"},{"content":"The compiler generates the body of the <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessors, as well as a private field to store the name.","pos":[16370,16481],"source":"The compiler generates the body of the `get` and `set` accessors, as well as a private field to\nstore the name."},{"content":"It would be similar to the following code that you could type by hand:","pos":[16482,16552]},{"content":"Let's make one more change before adding new features.","pos":[16677,16731]},{"content":"The <ph id=\"ph1\">`ProcessRepositories`</ph> method can do the async work and return a collection of the repositories.","pos":[16732,16831],"source":" The `ProcessRepositories` method can do the async\nwork and return a collection of the repositories."},{"content":"Let's return the <ph id=\"ph1\">`List&lt;Repository&gt;`</ph> from that method, and move the code that writes the information into the <ph id=\"ph2\">`Main`</ph> method.","pos":[16832,16955],"source":" Let's return the `List<Repository>` from that method,\nand move the code that writes the information into the `Main` method."},{"pos":[16957,17067],"content":"Change the signature of <ph id=\"ph1\">`ProcessRepositories`</ph> to return a task whose result is a list of <ph id=\"ph2\">`Repository`</ph> objects:","source":"Change the signature of `ProcessRepositories` to return a task whose result is a list of `Repository`\nobjects:"},{"content":"Then, just return the repositories after processing the JSON response:","pos":[17150,17220]},{"content":"The compiler generates the <ph id=\"ph1\">`Task&lt;T&gt;`</ph> object for the return because you've marked this method as <ph id=\"ph2\">`async`</ph>.","pos":[17338,17442],"source":"The compiler generates the `Task<T>` object for the return because you've marked this method as `async`."},{"content":"Then, let's modify the <ph id=\"ph1\">`Main`</ph> method so that it captures those results and writes each repository name to the console.","pos":[17443,17561],"source":"\nThen, let's modify the `Main` method so that it captures those results and writes each repository name\nto the console."},{"content":"Your <ph id=\"ph1\">`Main`</ph> method now looks like this:","pos":[17562,17601],"source":" Your `Main` method now looks like this:"},{"content":"Accessing the <ph id=\"ph1\">`Result`</ph> property of a Task blocks until the task has completed.","pos":[17792,17870],"source":"Accessing the `Result` property of a Task blocks until the task has completed."},{"content":"Normally, you would prefer to <ph id=\"ph1\">`await`</ph> the completion of the task, as in the <ph id=\"ph2\">`ProcessRepositories`</ph> method, but that isn't allowed in the <ph id=\"ph3\">`Main`</ph> method.","pos":[17871,18021],"source":" Normally, you would prefer\nto `await` the completion of the task, as in the `ProcessRepositories` method, but that isn't allowed in the\n`Main` method."},{"pos":[18026,18050],"content":"Reading More Information","linkify":"Reading More Information","nodes":[{"content":"Reading More Information","pos":[0,24]}]},{"content":"Let's finish this by processing a few more of the properties in the JSON packet that gets sent from the GitHub API.","pos":[18052,18167],"source":"Let's finish this by processing a few more of the properties in the JSON packet that gets sent from the\nGitHub API."},{"content":"You won't want to grab everything, but adding a few properties will demonstrate a few more features of the C# language.","pos":[18168,18287],"source":" You won't want to grab everything, but adding a few properties will demonstrate a few more\nfeatures of the C# language."},{"content":"Let's start by adding a few more simple types to the <ph id=\"ph1\">`Repository`</ph> class definition.","pos":[18289,18372],"source":"Let's start by adding a few more simple types to the `Repository` class definition."},{"content":"Add these properties to that class:","pos":[18373,18408],"source":" Add these properties\nto that class:"},{"content":"These properties have built-in conversions from the string type (which is what the JSON packets contain) to the target type.","pos":[18698,18822],"source":"These properties have built-in conversions from the string type (which is what the JSON packets contain) to\nthe target type."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Uri&gt;</ph> type may be new to you.","pos":[18823,18868],"source":" The <xref:System.Uri> type may be new to you."},{"content":"It represents a URI, or in this case, a URL.","pos":[18869,18913]},{"content":"In the case of the <ph id=\"ph1\">`Uri`</ph> and <ph id=\"ph2\">`int`</ph> types, if the JSON packet contains data that does not convert to the target type, the serialization action will throw an exception.","pos":[18914,19080],"source":" In the case\nof the `Uri` and `int` types, if the JSON packet contains data that does not convert to the target type,\nthe serialization action will throw an exception."},{"pos":[19082,19158],"content":"Once you've added these, update the <ph id=\"ph1\">`Main`</ph> method to display those elements:","source":"Once you've added these, update the `Main` method to display those elements:"},{"content":"As a final step, let's add the information for the last push operation.","pos":[19433,19504]},{"content":"This information is formatted in this fashion in the JSON response:","pos":[19505,19572],"source":" This information is formatted in\nthis fashion in the JSON response:"},{"content":"That format does not follow any of the standard .NET <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> formats.","pos":[19608,19692],"source":"That format does not follow any of the standard .NET <xref:System.DateTime> formats."},{"content":"Because of that, you'll need to write a custom conversion method.","pos":[19693,19758],"source":" Because of that, you'll need to write\na custom conversion method."},{"content":"You also probably don't want the raw string exposed to users of the <ph id=\"ph1\">`Repository`</ph> class.","pos":[19759,19846],"source":" You also probably don't want the raw string exposed to users of the `Repository`\nclass."},{"content":"Attributes can help control that as well.","pos":[19847,19888]},{"content":"First, define a <ph id=\"ph1\">`private`</ph> property that will hold the string representation of the date time in your <ph id=\"ph2\">`Repository`</ph> class:","pos":[19889,20009],"source":" First, define a `private` property that will hold the\nstring representation of the date time in your `Repository` class:"},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attribute informs the serializer that this should be processed, even though it is not a public member.","pos":[20095,20257],"source":"The <xref:System.Runtime.Serialization.DataMemberAttribute> attribute informs the serializer that this should be processed, even though it is not\na public member."},{"content":"Next, you need to write a public read-only property that converts the string to a valid <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> object, and returns that <ph id=\"ph2\">&lt;xref:System.DateTime&gt;</ph>:","pos":[20258,20417],"source":" Next, you need to write a public read-only property that converts the string to a\nvalid <xref:System.DateTime> object, and returns that <xref:System.DateTime>:"},{"content":"Let's go over the new constructs above.","pos":[20602,20641]},{"content":"The <ph id=\"ph1\">`IgnoreDataMember`</ph> attribute instructs the serializer that this type should not be read to or written from any JSON object.","pos":[20642,20769],"source":" The `IgnoreDataMember` attribute instructs the serializer\nthat this type should not be read to or written from any JSON object."},{"content":"This property contains only a <ph id=\"ph1\">`get`</ph> accessor.","pos":[20770,20815],"source":" This property contains only a\n`get` accessor."},{"content":"There is no <ph id=\"ph1\">`set`</ph> accessor.","pos":[20816,20843],"source":" There is no `set` accessor."},{"content":"That's how you define a <bpt id=\"p1\">*</bpt>read-only<ept id=\"p1\">*</ept> property in C#.","pos":[20844,20895],"source":" That's how you define a *read-only* property in C#."},{"content":"(Yes, you can create <bpt id=\"p1\">*</bpt>write-only<ept id=\"p1\">*</ept> properties in C#, but their value is limited.) The <ph id=\"ph1\">&lt;xref:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)&gt;</ph> method parses a string and creates a <ph id=\"ph2\">&lt;xref:System.DateTime&gt;</ph> object using a provided date format, and adds additional metadata to the <ph id=\"ph3\">`DateTime`</ph> using a <ph id=\"ph4\">`CultureInfo`</ph> object.","pos":[20896,21240],"source":" (Yes,\nyou can create *write-only* properties in C#, but their value is limited.) The <xref:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)>\nmethod parses a string and creates a <xref:System.DateTime> object using a provided date format, and adds additional\nmetadata to the `DateTime` using a `CultureInfo` object."},{"content":"If the parse operation fails, the property accessor throws an exception.","pos":[21241,21313],"source":" If the parse operation fails, the\nproperty accessor throws an exception."},{"pos":[21315,21482],"content":"To use <ph id=\"ph1\">&lt;xref:System.Globalization.CultureInfo.InvariantCulture&gt;</ph>, you will need to add the <ph id=\"ph2\">&lt;xref:System.Globalization&gt;</ph> namespace to the <ph id=\"ph3\">`using`</ph> statements in <ph id=\"ph4\">`repo.cs`</ph>:","source":"To use <xref:System.Globalization.CultureInfo.InvariantCulture>, you will need to add the <xref:System.Globalization> namespace to the `using` statements\nin `repo.cs`:"},{"pos":[21527,21631],"content":"Finally, add one more output statement in the console, and you're ready to build and run this app again:","source":"Finally, add one more output statement in the console, and you're ready to build and run this app\nagain:"},{"pos":[21682,21825],"content":"Your version should now match the <bpt id=\"p1\">[</bpt>finished sample<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient)</ept>.","source":"Your version should now match the [finished sample](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient)."},{"pos":[21830,21840],"content":"Conclusion","linkify":"Conclusion","nodes":[{"content":"Conclusion","pos":[0,10]}]},{"content":"This tutorial showed you how to make web requests, parse the result, and display properties of those results.","pos":[21842,21951],"source":"This tutorial showed you how to make web requests, parse the result, and display properties of\nthose results."},{"content":"You've also added new packages as dependencies in your project.","pos":[21952,22015]},{"content":"You've seen some of the features of the C# language that support object-oriented techniques.","pos":[22016,22108],"source":" You've seen some of\nthe features of the C# language that support object-oriented techniques."}]}