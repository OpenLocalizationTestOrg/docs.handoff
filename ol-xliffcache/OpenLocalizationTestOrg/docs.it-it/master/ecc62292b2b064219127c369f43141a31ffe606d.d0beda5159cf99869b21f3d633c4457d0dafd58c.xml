{"content":"---\ntitle: \"WSTrustChannelFactory and WSTrustChannel\"\nms.date: \"03/30/2017\"\nms.assetid: 96cec467-e963-4132-b18b-7d0b3a2e979f\nauthor: \"BrucePerlerMS\"\n---\n# WSTrustChannelFactory and WSTrustChannel\nIf you are already familiar with Windows Communication Foundation (WCF), you know that a WCF client is already federation aware. By configuring a WCF client with a <xref:System.ServiceModel.WSFederationHttpBinding> or similar custom binding, you can enable federated authentication to a service.\n\n WCF obtains the token that is issued by the security token service (STS) behind the scenes and uses this token to authenticate to the service. The main limitation to this approach is that there is no visibility into the client’s communications with the server. WCF automatically generates the request security token (RST) to the STS based on the issued token parameters on the binding. This means that the client cannot vary the RST parameters per request, inspect the request security token response (RSTR) to get information such as display claims, or cache the token for future use.\n\n Currently, the WCF client is suitable for basic federation scenarios. However, one of the major scenarios that Windows Identity Foundation (WIF) supports requires control over the RST at a level that WCF does not easily allow. Therefore, WIF adds features that give you more control over communication with the STS.\n\n WIF supports the following federation scenarios:\n\n- Using a WCF client without any WIF dependencies to authenticate to a federated service\n\n- Enabling WIF on a WCF client to insert an ActAs or OnBehalfOf element into the RST to the STS\n\n- Using WIF alone to obtain a token from the STS and then enable a WCF client to authenticate with this token. For more information, see [ClaimsAwareWebService](https://go.microsoft.com/fwlink/?LinkID=248406) sample.\n\n The first scenario is self-explanatory: Existing WCF clients will continue to work with WIF relying parties and STSs. This topic discusses the remaining two scenarios.\n\n## Enhancing an Existing WCF Client with ActAs / OnBehalfOf\nIn a typical identity delegation scenario, a client calls a middle-tier service, which then calls a back-end service. The middle-tier service acts as, or acts on behalf of, the client.\n\n> [!TIP]\n> What is the difference between ActAs and OnBehalfOf?\n>\n> From the WS-Trust protocol standpoint:\n>\n> 1. An ActAs RST element indicates that the requestor wants a token that contains claims about two distinct entities: the requestor, and an external entity represented by the token in the ActAs element.\n> 2. An OnBehalfOf RST element indicates that the requestor wants a token that contains claims only about one entity: the external entity represented by the token in the OnBehalfOf element.\n>\n> The ActAs feature is typically used in scenarios that require composite delegation, where the final recipient of the issued token can inspect the entire delegation chain and see not just the client, but all intermediaries. This lets it perform access control, auditing and other related activities based on the entire identity delegation chain. The ActAs feature is commonly used in multi-tiered systems to authenticate and pass information about identities between the tiers without having to pass this information at the application/business logic layer.\n>\n> The OnBehalfOf feature is used in scenarios where only the identity of the original client is important and is effectively the same as the identity impersonation feature available in Windows. When OnBehalfOf is used, the final recipient of the issued token can only see claims about the original client, and the information about intermediaries is not preserved. One common pattern where the OnBehalfOf feature is used is the proxy pattern where the client cannot access the STS directly but instead communicates through a proxy gateway. The proxy gateway authenticates the caller and puts information about the caller into the OnBehalfOf element of the RST message that it then sends to the real STS for processing. The resulting token contains only claims related to the client of the proxy, making the proxy completely transparent to the receiver of the issued token.Note that WIF does not support \\<wsse:SecurityTokenReference> or \\<wsa:EndpointReferences> as a child of \\<wst:OnBehalfOf>. The WS-Trust specification allows for three ways to identify the original requestor (on behalf of whom the proxy is acting). These are:\n>\n> - Security token reference. A reference to a token, either in the message, or possibly retrieved out of band).\n> - Endpoint reference. Used as a key to look up data, again out of band.\n> - Security token. Identifies the original requestor directly.\n>\n> WIF supports only security tokens, either encrypted or unencrypted, as a direct child element of \\<wst:OnBehalfOf>.\n\n This information is conveyed to a WS-Trust issuer using the ActAs and OnBehalfOf token elements in the RST.\n\n WCF exposes an extensibility point on the binding that allows arbitrary XML elements to be added to the RST. However, because the extensibility point is tied to the binding, scenarios that require the RST contents to vary per call must re-create the client for every call, which decreases performance. WIF uses extension methods on the `ChannelFactory` class to allow developers to attach any token that is obtained out of band to the RST. The following code example shows how to take a token that represents the client (such as an X.509, username, or Security Assertion Markup Language (SAML) token) and attach it to the RST that is sent to the issuer.\n\n```csharp\nIHelloService serviceChannel = channelFactory.CreateChannelActingAs<IHelloService>(clientSamlToken);\nserviceChannel.Hello(\"Hi!\");\n```\n\n WIF provides the following benefits:\n\n- The RST can be modified per channel; therefore, middle-tier services do not have to re-create the channel factory for each client, which improves performance.\n\n- This works with existing WCF clients, which makes an easy upgrade path possible for existing WCF middle-tier services that want to enable identity delegation semantics.\n\n However, there is still no visibility into the client’s communication with the STS. We’ll examine this in the third scenario.\n\n## Communicating Directly with an Issuer and Using the Issued Token to Authenticate\nFor some advanced scenarios, enhancing a WCF client is not enough. Developers who use only WCF typically use Message In / Message Out contracts and handle client-side parsing of the issuer response manually.\n\nWIF introduces the <xref:System.ServiceModel.Security.WSTrustChannelFactory> and <xref:System.ServiceModel.Security.WSTrustChannel> classes to let the client communicate directly with a WS-Trust issuer. The <xref:System.ServiceModel.Security.WSTrustChannelFactory> and <xref:System.ServiceModel.Security.WSTrustChannel> classes enable strongly typed RST and RSTR objects to flow between the client and issuer, as shown in the following code example.\n\n```csharp\nWSTrustChannelFactory trustChannelFactory = new WSTrustChannelFactory(stsBinding, stsAddress);\nWSTrustChannel channel = (WSTrustChannel) trustChannelFactory.CreateChannel();\nRequestSecurityToken rst = new RequestSecurityToken(RequestTypes.Issue);\nrst.AppliesTo = new EndpointAddress(serviceAddress);\nRequestSecurityTokenResponse rstr = null;\nSecurityToken token = channel.Issue(rst, out rstr);\n```\n\nNote that the `out` parameter on the <xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A> method allows access to the RSTR for client-side inspection.\n\nSo far, you’ve only seen how to obtain a token. The token that is returned from the <xref:System.ServiceModel.Security.WSTrustChannel> object is a `GenericXmlSecurityToken` that contains all of the information that is necessary for authentication to a relying party. The following code example shows how to use this token.\n\n```csharp\nIHelloService serviceChannel = channelFactory.CreateChannelWithIssuedToken<IHelloService>( token );\nserviceChannel.Hello(\"Hi!\");\n```\n\nThe <xref:System.ServiceModel.ChannelFactory%601.CreateChannelWithIssuedToken%2A> extension method on the `ChannelFactory` object indicates to WIF that you have obtained a token out of band, and that it should stop the normal WCF call to the issuer and instead use the token that you obtained to authenticate to the relying party. This has the following benefits:\n\n- It gives you complete control over the token issuance process.\n\n- It supports ActAs / OnBehalfOf scenarios by directly setting these properties on the outgoing RST.\n\n- It enables dynamic client-side trust decisions to be made based on the contents of the RSTR.\n\n- It lets you cache and reuse the token that is returned from the <xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A> method.\n\n- <xref:System.ServiceModel.Security.WSTrustChannelFactory> and <xref:System.ServiceModel.Security.WSTrustChannel> allow for control of channel caching, fault, and recovery semantics according to WCF best practices.\n\n## See also\n\n- [WIF Features](../../../docs/framework/security/wif-features.md)","nodes":[{"pos":[4,148],"embed":true,"restype":"x-metadata","content":"title: \"WSTrustChannelFactory and WSTrustChannel\"\nms.date: \"03/30/2017\"\nms.assetid: 96cec467-e963-4132-b18b-7d0b3a2e979f\nauthor: \"BrucePerlerMS\"","nodes":[{"content":"WSTrustChannelFactory and WSTrustChannel","nodes":[{"pos":[0,40],"content":"WSTrustChannelFactory and WSTrustChannel","nodes":[{"content":"WSTrustChannelFactory and WSTrustChannel","pos":[0,40]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[155,195],"content":"WSTrustChannelFactory and WSTrustChannel","linkify":"WSTrustChannelFactory and WSTrustChannel","nodes":[{"content":"WSTrustChannelFactory and WSTrustChannel","pos":[0,40]}]},{"content":"If you are already familiar with Windows Communication Foundation (WCF), you know that a WCF client is already federation aware.","pos":[196,324]},{"content":"By configuring a WCF client with a <ph id=\"ph1\">&lt;xref:System.ServiceModel.WSFederationHttpBinding&gt;</ph> or similar custom binding, you can enable federated authentication to a service.","pos":[325,491],"source":" By configuring a WCF client with a <xref:System.ServiceModel.WSFederationHttpBinding> or similar custom binding, you can enable federated authentication to a service."},{"content":"WCF obtains the token that is issued by the security token service (STS) behind the scenes and uses this token to authenticate to the service.","pos":[494,636]},{"content":"The main limitation to this approach is that there is no visibility into the client’s communications with the server.","pos":[637,754]},{"content":"WCF automatically generates the request security token (RST) to the STS based on the issued token parameters on the binding.","pos":[755,879]},{"content":"This means that the client cannot vary the RST parameters per request, inspect the request security token response (RSTR) to get information such as display claims, or cache the token for future use.","pos":[880,1079]},{"content":"Currently, the WCF client is suitable for basic federation scenarios.","pos":[1082,1151]},{"content":"However, one of the major scenarios that Windows Identity Foundation (WIF) supports requires control over the RST at a level that WCF does not easily allow.","pos":[1152,1308]},{"content":"Therefore, WIF adds features that give you more control over communication with the STS.","pos":[1309,1397]},{"content":"WIF supports the following federation scenarios:","pos":[1400,1448]},{"content":"Using a WCF client without any WIF dependencies to authenticate to a federated service","pos":[1452,1538]},{"content":"Enabling WIF on a WCF client to insert an ActAs or OnBehalfOf element into the RST to the STS","pos":[1542,1635]},{"content":"Using WIF alone to obtain a token from the STS and then enable a WCF client to authenticate with this token.","pos":[1639,1747]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>ClaimsAwareWebService<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkID=248406)</ept> sample.","pos":[1748,1853],"source":" For more information, see [ClaimsAwareWebService](https://go.microsoft.com/fwlink/?LinkID=248406) sample."},{"content":"The first scenario is self-explanatory: Existing WCF clients will continue to work with WIF relying parties and STSs.","pos":[1856,1973]},{"content":"This topic discusses the remaining two scenarios.","pos":[1974,2023]},{"pos":[2028,2084],"content":"Enhancing an Existing WCF Client with ActAs / OnBehalfOf","linkify":"Enhancing an Existing WCF Client with ActAs / OnBehalfOf","nodes":[{"content":"Enhancing an Existing WCF Client with ActAs / OnBehalfOf","pos":[0,56]}]},{"content":"In a typical identity delegation scenario, a client calls a middle-tier service, which then calls a back-end service.","pos":[2085,2202]},{"content":"The middle-tier service acts as, or acts on behalf of, the client.","pos":[2203,2269]},{"pos":[2273,2334],"content":"[!TIP]\nWhat is the difference between ActAs and OnBehalfOf?","leadings":["","> "],"nodes":[{"content":"What is the difference between ActAs and OnBehalfOf?","pos":[7,59]}]},{"content":"From the WS-Trust protocol standpoint:","pos":[2339,2377]},{"content":"An ActAs RST element indicates that the requestor wants a token that contains claims about two distinct entities: the requestor, and an external entity represented by the token in the ActAs element.","pos":[2385,2583]},{"content":"An OnBehalfOf RST element indicates that the requestor wants a token that contains claims only about one entity: the external entity represented by the token in the OnBehalfOf element.","pos":[2589,2773]},{"content":"The ActAs feature is typically used in scenarios that require composite delegation, where the final recipient of the issued token can inspect the entire delegation chain and see not just the client, but all intermediaries.","pos":[2778,3000]},{"content":"This lets it perform access control, auditing and other related activities based on the entire identity delegation chain.","pos":[3001,3122]},{"content":"The ActAs feature is commonly used in multi-tiered systems to authenticate and pass information about identities between the tiers without having to pass this information at the application/business logic layer.","pos":[3123,3334]},{"content":"The OnBehalfOf feature is used in scenarios where only the identity of the original client is important and is effectively the same as the identity impersonation feature available in Windows.","pos":[3339,3530]},{"content":"When OnBehalfOf is used, the final recipient of the issued token can only see claims about the original client, and the information about intermediaries is not preserved.","pos":[3531,3701]},{"content":"One common pattern where the OnBehalfOf feature is used is the proxy pattern where the client cannot access the STS directly but instead communicates through a proxy gateway.","pos":[3702,3876]},{"content":"The proxy gateway authenticates the caller and puts information about the caller into the OnBehalfOf element of the RST message that it then sends to the real STS for processing.","pos":[3877,4055]},{"content":"The resulting token contains only claims related to the client of the proxy, making the proxy completely transparent to the receiver of the issued token.Note that WIF does not support <ph id=\"ph1\">\\&lt;</ph>wsse:SecurityTokenReference&gt; or <ph id=\"ph2\">\\&lt;</ph>wsa:EndpointReferences&gt; as a child of <ph id=\"ph3\">\\&lt;</ph>wst:OnBehalfOf&gt;.","pos":[4056,4332],"source":" The resulting token contains only claims related to the client of the proxy, making the proxy completely transparent to the receiver of the issued token.Note that WIF does not support \\<wsse:SecurityTokenReference> or \\<wsa:EndpointReferences> as a child of \\<wst:OnBehalfOf>."},{"content":"The WS-Trust specification allows for three ways to identify the original requestor (on behalf of whom the proxy is acting).","pos":[4333,4457]},{"content":"These are:","pos":[4458,4468]},{"content":"Security token reference.","pos":[4475,4500]},{"content":"A reference to a token, either in the message, or possibly retrieved out of band).","pos":[4501,4583]},{"content":"Endpoint reference.","pos":[4588,4607]},{"content":"Used as a key to look up data, again out of band.","pos":[4608,4657]},{"content":"Security token.","pos":[4662,4677]},{"content":"Identifies the original requestor directly.","pos":[4678,4721]},{"content":"WIF supports only security tokens, either encrypted or unencrypted, as a direct child element of <ph id=\"ph1\">\\&lt;</ph>wst:OnBehalfOf&gt;.","pos":[4726,4841],"source":"WIF supports only security tokens, either encrypted or unencrypted, as a direct child element of \\<wst:OnBehalfOf>."},{"content":"This information is conveyed to a WS-Trust issuer using the ActAs and OnBehalfOf token elements in the RST.","pos":[4844,4951]},{"content":"WCF exposes an extensibility point on the binding that allows arbitrary XML elements to be added to the RST.","pos":[4954,5062]},{"content":"However, because the extensibility point is tied to the binding, scenarios that require the RST contents to vary per call must re-create the client for every call, which decreases performance.","pos":[5063,5255]},{"content":"WIF uses extension methods on the <ph id=\"ph1\">`ChannelFactory`</ph> class to allow developers to attach any token that is obtained out of band to the RST.","pos":[5256,5393],"source":" WIF uses extension methods on the `ChannelFactory` class to allow developers to attach any token that is obtained out of band to the RST."},{"content":"The following code example shows how to take a token that represents the client (such as an X.509, username, or Security Assertion Markup Language (SAML) token) and attach it to the RST that is sent to the issuer.","pos":[5394,5607]},{"content":"WIF provides the following benefits:","pos":[5755,5791]},{"content":"The RST can be modified per channel; therefore, middle-tier services do not have to re-create the channel factory for each client, which improves performance.","pos":[5795,5953]},{"content":"This works with existing WCF clients, which makes an easy upgrade path possible for existing WCF middle-tier services that want to enable identity delegation semantics.","pos":[5957,6125]},{"content":"However, there is still no visibility into the client’s communication with the STS.","pos":[6128,6211]},{"content":"We’ll examine this in the third scenario.","pos":[6212,6253]},{"pos":[6258,6338],"content":"Communicating Directly with an Issuer and Using the Issued Token to Authenticate","linkify":"Communicating Directly with an Issuer and Using the Issued Token to Authenticate","nodes":[{"content":"Communicating Directly with an Issuer and Using the Issued Token to Authenticate","pos":[0,80]}]},{"content":"For some advanced scenarios, enhancing a WCF client is not enough.","pos":[6339,6405]},{"content":"Developers who use only WCF typically use Message In / Message Out contracts and handle client-side parsing of the issuer response manually.","pos":[6406,6546]},{"content":"WIF introduces the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.WSTrustChannelFactory&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Security.WSTrustChannel&gt;</ph> classes to let the client communicate directly with a WS-Trust issuer.","pos":[6548,6750],"source":"WIF introduces the <xref:System.ServiceModel.Security.WSTrustChannelFactory> and <xref:System.ServiceModel.Security.WSTrustChannel> classes to let the client communicate directly with a WS-Trust issuer."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.WSTrustChannelFactory&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Security.WSTrustChannel&gt;</ph> classes enable strongly typed RST and RSTR objects to flow between the client and issuer, as shown in the following code example.","pos":[6751,6997],"source":" The <xref:System.ServiceModel.Security.WSTrustChannelFactory> and <xref:System.ServiceModel.Security.WSTrustChannel> classes enable strongly typed RST and RSTR objects to flow between the client and issuer, as shown in the following code example."},{"pos":[7408,7565],"content":"Note that the <ph id=\"ph1\">`out`</ph> parameter on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A&gt;</ph> method allows access to the RSTR for client-side inspection.","source":"Note that the `out` parameter on the <xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A> method allows access to the RSTR for client-side inspection."},{"content":"So far, you’ve only seen how to obtain a token.","pos":[7567,7614]},{"content":"The token that is returned from the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.WSTrustChannel&gt;</ph> object is a <ph id=\"ph2\">`GenericXmlSecurityToken`</ph> that contains all of the information that is necessary for authentication to a relying party.","pos":[7615,7833],"source":" The token that is returned from the <xref:System.ServiceModel.Security.WSTrustChannel> object is a `GenericXmlSecurityToken` that contains all of the information that is necessary for authentication to a relying party."},{"content":"The following code example shows how to use this token.","pos":[7834,7889]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.ChannelFactory%601.CreateChannelWithIssuedToken%2A&gt;</ph> extension method on the <ph id=\"ph2\">`ChannelFactory`</ph> object indicates to WIF that you have obtained a token out of band, and that it should stop the normal WCF call to the issuer and instead use the token that you obtained to authenticate to the relying party.","pos":[8035,8365],"source":"The <xref:System.ServiceModel.ChannelFactory%601.CreateChannelWithIssuedToken%2A> extension method on the `ChannelFactory` object indicates to WIF that you have obtained a token out of band, and that it should stop the normal WCF call to the issuer and instead use the token that you obtained to authenticate to the relying party."},{"content":"This has the following benefits:","pos":[8366,8398]},{"content":"It gives you complete control over the token issuance process.","pos":[8402,8464]},{"content":"It supports ActAs / OnBehalfOf scenarios by directly setting these properties on the outgoing RST.","pos":[8468,8566]},{"content":"It enables dynamic client-side trust decisions to be made based on the contents of the RSTR.","pos":[8570,8662]},{"pos":[8666,8797],"content":"It lets you cache and reuse the token that is returned from the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A&gt;</ph> method.","source":"It lets you cache and reuse the token that is returned from the <xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A> method."},{"pos":[8801,9014],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.WSTrustChannelFactory&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Security.WSTrustChannel&gt;</ph> allow for control of channel caching, fault, and recovery semantics according to WCF best practices.","source":"<xref:System.ServiceModel.Security.WSTrustChannelFactory> and <xref:System.ServiceModel.Security.WSTrustChannel> allow for control of channel caching, fault, and recovery semantics according to WCF best practices."},{"pos":[9019,9027],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9031,9095],"content":"<bpt id=\"p1\">[</bpt>WIF Features<ept id=\"p1\">](../../../docs/framework/security/wif-features.md)</ept>","source":"[WIF Features](../../../docs/framework/security/wif-features.md)"}]}