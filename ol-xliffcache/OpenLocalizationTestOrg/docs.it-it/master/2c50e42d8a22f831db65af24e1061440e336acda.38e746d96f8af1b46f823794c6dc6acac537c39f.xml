{"content":"---\ntitle: \"Generic Interfaces (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"C# language, generic interfaces\"\n  - \"generics [C#], interfaces\"\nms.assetid: a8fa49a1-6e78-4a09-87e5-84a0b9f5ffbe\ncaps.latest.revision: 28\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Generic Interfaces (C# Programming Guide)\nIt is often useful to define interfaces either for generic collection classes, or for the generic classes that represent items in the collection. The preference for generic classes is to use generic interfaces, such as <xref:System.IComparable%601> rather than <xref:System.IComparable>, in order to avoid boxing and unboxing operations on value types. The .NET Framework class library defines several generic interfaces for use with the collection classes in the <xref:System.Collections.Generic> namespace.  \n  \n When an interface is specified as a constraint on a type parameter, only types that implement the interface can be used. The following code example shows a `SortedList<T>` class that derives from the `GenericList<T>` class. For more information, see [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md). `SortedList<T>` adds the constraint `where T : IComparable<T>`. This enables the `BubbleSort` method in `SortedList<T>` to use the generic <xref:System.IComparable%601.CompareTo%2A> method on list elements. In this example, list elements are a simple class, `Person`, that implements `IComparable<Person>`.  \n  \n [!code-cs[csProgGuideGenerics#29](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_1.cs)]  \n  \n Multiple interfaces can be specified as constraints on a single type, as follows:  \n  \n [!code-cs[csProgGuideGenerics#30](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_2.cs)]  \n  \n An interface can define more than one type parameter, as follows:  \n  \n [!code-cs[csProgGuideGenerics#31](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_3.cs)]  \n  \n The rules of inheritance that apply to classes also apply to interfaces:  \n  \n [!code-cs[csProgGuideGenerics#32](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_4.cs)]  \n  \n Generic interfaces can inherit from non-generic interfaces if the generic interface is contra-variant, which means it only uses its type parameter as a return value. In the .NET Framework class library, <xref:System.Collections.Generic.IEnumerable%601> inherits from <xref:System.Collections.IEnumerable> because <xref:System.Collections.Generic.IEnumerable%601> only uses `T` in the return value of <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> and in the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property getter.  \n  \n Concrete classes can implement closed constructed interfaces, as follows:  \n  \n [!code-cs[csProgGuideGenerics#33](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_5.cs)]  \n  \n Generic classes can implement generic interfaces or closed constructed interfaces as long as the class parameter list supplies all arguments required by the interface, as follows:  \n  \n [!code-cs[csProgGuideGenerics#34](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_6.cs)]  \n  \n The rules that control method overloading are the same for methods within generic classes, generic structs, or generic interfaces. For more information, see [Generic Methods](../../../csharp/programming-guide/generics/generic-methods.md).  \n  \n## See Also  \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)   \n [interface](../../../csharp/language-reference/keywords/interface.md)   \n [Generics](https://msdn.microsoft.com/library/ms172192)","nodes":[{"pos":[4,583],"nodes":[{"content":"Generic Interfaces (C# Programming Guide) | Microsoft Docs","nodes":[{"pos":[0,58],"content":"Generic Interfaces (C# Programming Guide) | Microsoft Docs","nodes":[{"content":"Generic Interfaces (C# Programming Guide) | Microsoft Docs","pos":[0,58]}]}],"pos":[6,67],"yaml":true}],"content":"title: \"Generic Interfaces (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"C# language, generic interfaces\"\n  - \"generics [C#], interfaces\"\nms.assetid: a8fa49a1-6e78-4a09-87e5-84a0b9f5ffbe\ncaps.latest.revision: 28\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","yamlblock":true},{"pos":[590,631],"content":"Generic Interfaces (C# Programming Guide)","linkify":"Generic Interfaces (C# Programming Guide)","nodes":[{"content":"Generic Interfaces (C# Programming Guide)","pos":[0,41]}]},{"content":"It is often useful to define interfaces either for generic collection classes, or for the generic classes that represent items in the collection.","pos":[632,777]},{"content":"The preference for generic classes is to use generic interfaces, such as <ph id=\"ph1\">&lt;xref:System.IComparable%601&gt;</ph> rather than <ph id=\"ph2\">&lt;xref:System.IComparable&gt;</ph>, in order to avoid boxing and unboxing operations on value types.","pos":[778,984],"source":" The preference for generic classes is to use generic interfaces, such as <xref:System.IComparable%601> rather than <xref:System.IComparable>, in order to avoid boxing and unboxing operations on value types."},{"content":"The .NET Framework class library defines several generic interfaces for use with the collection classes in the <ph id=\"ph1\">&lt;xref:System.Collections.Generic&gt;</ph> namespace.","pos":[985,1140],"source":" The .NET Framework class library defines several generic interfaces for use with the collection classes in the <xref:System.Collections.Generic> namespace."},{"content":"When an interface is specified as a constraint on a type parameter, only types that implement the interface can be used.","pos":[1147,1267]},{"content":"The following code example shows a <ph id=\"ph1\">`SortedList&lt;T&gt;`</ph> class that derives from the <ph id=\"ph2\">`GenericList&lt;T&gt;`</ph> class.","pos":[1268,1370],"source":" The following code example shows a `SortedList<T>` class that derives from the `GenericList<T>` class."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept>.","pos":[1371,1496],"source":" For more information, see [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)."},{"content":"<ph id=\"ph1\">`SortedList&lt;T&gt;`</ph> adds the constraint <ph id=\"ph2\">`where T : IComparable&lt;T&gt;`</ph>.","pos":[1497,1560],"source":"`SortedList<T>` adds the constraint `where T : IComparable<T>`."},{"content":"This enables the <ph id=\"ph1\">`BubbleSort`</ph> method in <ph id=\"ph2\">`SortedList&lt;T&gt;`</ph> to use the generic <ph id=\"ph3\">&lt;xref:System.IComparable%601.CompareTo%2A&gt;</ph> method on list elements.","pos":[1561,1703],"source":" This enables the `BubbleSort` method in `SortedList<T>` to use the generic <xref:System.IComparable%601.CompareTo%2A> method on list elements."},{"content":"In this example, list elements are a simple class, <ph id=\"ph1\">`Person`</ph>, that implements <ph id=\"ph2\">`IComparable&lt;Person&gt;`</ph>.","pos":[1704,1803],"source":" In this example, list elements are a simple class, `Person`, that implements `IComparable<Person>`."},{"pos":[1810,1931],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideGenerics#29<ept id=\"p2\">](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_1.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideGenerics#29](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_1.cs)]"},{"content":"Multiple interfaces can be specified as constraints on a single type, as follows:","pos":[1938,2019]},{"pos":[2026,2147],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideGenerics#30<ept id=\"p2\">](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_2.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideGenerics#30](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_2.cs)]"},{"content":"An interface can define more than one type parameter, as follows:","pos":[2154,2219]},{"pos":[2226,2347],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideGenerics#31<ept id=\"p2\">](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_3.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideGenerics#31](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_3.cs)]"},{"content":"The rules of inheritance that apply to classes also apply to interfaces:","pos":[2354,2426]},{"pos":[2433,2554],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideGenerics#32<ept id=\"p2\">](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_4.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideGenerics#32](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_4.cs)]"},{"content":"Generic interfaces can inherit from non-generic interfaces if the generic interface is contra-variant, which means it only uses its type parameter as a return value.","pos":[2561,2726]},{"content":"In the .NET Framework class library, <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> inherits from <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable&gt;</ph> because <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> only uses <ph id=\"ph4\">`T`</ph> in the return value of <ph id=\"ph5\">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> and in the <ph id=\"ph6\">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property getter.","pos":[2727,3116],"source":" In the .NET Framework class library, <xref:System.Collections.Generic.IEnumerable%601> inherits from <xref:System.Collections.IEnumerable> because <xref:System.Collections.Generic.IEnumerable%601> only uses `T` in the return value of <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> and in the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property getter."},{"content":"Concrete classes can implement closed constructed interfaces, as follows:","pos":[3123,3196]},{"pos":[3203,3324],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideGenerics#33<ept id=\"p2\">](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_5.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideGenerics#33](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_5.cs)]"},{"content":"Generic classes can implement generic interfaces or closed constructed interfaces as long as the class parameter list supplies all arguments required by the interface, as follows:","pos":[3331,3510]},{"pos":[3517,3638],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideGenerics#34<ept id=\"p2\">](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_6.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideGenerics#34](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-interfaces_6.cs)]"},{"content":"The rules that control method overloading are the same for methods within generic classes, generic structs, or generic interfaces.","pos":[3645,3775]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Generic Methods<ept id=\"p1\">](../../../csharp/programming-guide/generics/generic-methods.md)</ept>.","pos":[3776,3883],"source":" For more information, see [Generic Methods](../../../csharp/programming-guide/generics/generic-methods.md)."},{"pos":[3892,3900],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[3904,3971],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept><ph id=\"ph1\"> </ph>","pos":[3975,4074],"source":"[Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md) "},{"content":"<bpt id=\"p1\">[</bpt>interface<ept id=\"p1\">](../../../csharp/language-reference/keywords/interface.md)</ept><ph id=\"ph1\"> </ph>","pos":[4078,4148],"source":"[interface](../../../csharp/language-reference/keywords/interface.md) "},{"content":"<bpt id=\"p1\">[</bpt>Generics<ept id=\"p1\">](https://msdn.microsoft.com/library/ms172192)</ept>","pos":[4152,4207],"source":"[Generics](https://msdn.microsoft.com/library/ms172192)"}]}