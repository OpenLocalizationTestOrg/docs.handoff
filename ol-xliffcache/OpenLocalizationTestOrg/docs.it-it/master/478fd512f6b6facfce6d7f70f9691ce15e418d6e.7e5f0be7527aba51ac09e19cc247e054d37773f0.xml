{"content":"---\ntitle: What's New in C# 6 - C# Guide\ndescription: Learn the new features in C# Version 6\nms.date: 12/12/2018\n---\n\n# What's New in C# 6\n\nThe 6.0 release of C# contained many features that improve productivity for developers. The overall effect of these features is that you write more concise code that is also more readable. The syntax contains less ceremony for many common practices. It's easier to see the design intent with less ceremony. Learn these features well, and you'll be more productive and write more readable code. You can concentrate more on your features than on the constructs of the language.\n\nThe rest of this article provides an overview of each of these features, with a link to explore each feature. You can also explore the features in an [interactive exploration on C# 6](../tutorials/exploration/csharp-6.yml) in the tutorials section.\n\n## Read-only auto-properties\n\n*Read-only auto-properties* provide a more concise syntax to create immutable types. You declare the auto-property\nwith only a get accessor:\n\n[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]\n\nThe `FirstName` and `LastName` properties can be set only in the body of a constructor:\n\n[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]\n\nTrying to set `LastName` in another method generates a `CS0200` compilation error:\n\n```csharp\npublic class Student\n{\n    public string LastName { get;  }\n\n    public void ChangeName(string newLastName)\n    {\n        // Generates CS0200: Property or indexer cannot be assigned to -- it is read only\n        LastName = newLastName;\n    }\n}\n```\n\nThis feature enables true language support for creating immutable types and uses the more concise and convenient auto-property syntax.\n\nIf adding this syntax doesn't remove an accessible method, it's a [binary compatible change](version-update-considerations.md#binary-compatible-changes).\n\n## Auto-property initializers\n\n*Auto-property initializers* let you declare the initial value for an auto-property as part of the property declaration.\n\n[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]\n\nThe `Grades` member is initialized where it's declared. That makes it easier to perform the initialization exactly once. The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for `Student` objects.\n\n## Expression-bodied function members\n\nMany members that you write are single statements that could be single expressions. Write an expression-bodied member instead. It works for methods and read-only properties. For example, an override of `ToString()` is often a great candidate:\n\n[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]\n\nYou can also use this syntax for read-only properties:\n\n[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]\n\nChanging an existing member to an expression bodied member is a [binary compatible change](version-update-considerations.md#binary-compatible-changes).\n\n## using static\n\nThe *using static* enhancement enables you to import the static methods of a single class. You specify the class you're using:\n\n[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]\n\nThe <xref:System.Math> does not contain any instance methods. You can also use `using static` to import a class' static methods for a class that has both static and instance methods. One of the most useful examples is <xref:System.String>:\n\n[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]\n\n> [!NOTE]\n> You must use the fully qualified class name, `System.String`  in a static using statement.  You cannot use the `string` keyword instead.\n\nWhen imported from a `static using` statement, extension methods are only in scope when called using the extension method invocation syntax. They aren't in scope when called as a static method. You'll often see this in LINQ queries. You can import the LINQ pattern by importing <xref:System.Linq.Enumerable>, or <xref:System.Linq.Queryable>.\n\n[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]\n\nYou typically call extension methods using extension method invocation expressions. Adding the class name in the rare case where you call them using static method call syntax resolves ambiguity.\n\nThe `static using` directive also imports any nested types. You can reference any nested types without qualification.\n\n## Null-conditional operators\n\nThe *null conditional operator* makes null checks much easier and fluid. Replace the member access `.` with `?.`:\n\n[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]\n\nIn the preceding example, the variable `first` is assigned `null` if the person object is `null`. Otherwise, it is assigned the value of the `FirstName` property. Most importantly, the `?.` means that this line of code doesn't generate a `NullReferenceException` if the `person` variable is `null`. Instead, it short-circuits and returns `null`. You can also use a null conditional operator for array or indexer access. Replace `[]` with `?[]` in the index expression.\n\nThe following expression returns a `string`, regardless of the value of `person`. You often use this construct with the *null coalescing* operator to assign default values when one of the properties is `null`. When the expression short-circuits, the `null` value returned is typed to match the full expression.\n\n[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]\n\nYou can also use `?.` to conditionally invoke methods. The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be `null`.  You'll call the delegate's `Invoke` method using the `?.` operator to access the member. You can see an example in the [delegate patterns](../delegates-patterns.md#handling-null-delegates) article.\n\nThe rules of the `?.` operator ensure that the left-hand side of the operator is evaluated only once. It enables many idioms, including the following example using event handlers:\n\n```csharp\n// preferred in C# 6:\nthis.SomethingHappened?.Invoke(this, eventArgs);\n```\n\nEnsuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the `?.`\n\n## String interpolation\n\nWith C# 6, the new [string interpolation](../language-reference/tokens/interpolated.md) feature enables you to embed expressions in a string. Simply preface the string with `$`and use expressions between `{` and `}` instead of ordinals:\n\n[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]\n\nThis example uses properties for the substituted expressions. You can use any expression. For example, you could compute a student's grade point average as part of the interpolation:\n\n[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]\n\nThe preceding line of code formats the value for `Grades.Average()` as a floating-point number with two decimal places.\n\nOften, you may need to format the string produced using a specific culture. You use the fact that the object produced by a string interpolation can be implicitly converted to <xref:System.FormattableString?displayProperty=nameWithType>. The <xref:System.FormattableString> instance contains the composite format string and the results of evaluating the expressions before converting them to strings. Use the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to specify the culture when formatting a string. The following example produces a string using the German (de-DE) culture. (By default, the German culture uses the ',' character for the decimal separator, and the '.' character as the thousands separator.)\n\n```csharp\nFormattableString str = $\"Average grade is {s.Grades.Average()}\";\nvar gradeStr = str.ToString(new System.Globalization.CultureInfo(\"de-DE\"));\n```\n\nTo get started with string interpolation, see the [String interpolation in C#](../tutorials/exploration/interpolated-strings.yml) interactive tutorial, the [String interpolation](../language-reference/tokens/interpolated.md) article, and the [String interpolation in C#](../tutorials/string-interpolation.md) tutorial.\n\n## Exception filters\n\n*Exception Filters* are clauses that determine when a given catch clause should be applied. If the expression used for an exception filter evaluates to `true`, the catch clause performs its normal processing on an exception. If the\nexpression evaluates to `false`, then the `catch` clause is skipped. One use is to examine information about an exception to determine if a `catch` clause can process the exception:\n\n[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]\n\n## The `nameof` expression\n\nThe `nameof` expression evaluates to the name of a symbol. It's a great way to get tools working whenever you need the name of a variable, a property, or a member field. One of the most common uses for `nameof` is to provide the name of a symbol that caused an exception:\n\n[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]\n\nAnother use is with XAML-based applications that implement the `INotifyPropertyChanged` interface:\n\n[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]\n\n## Await in Catch and Finally blocks\n\nC# 5 had several limitations around where you could place `await` expressions. With C# 6, you can now use `await` in `catch` or `finally` expressions. This is most often used with logging scenarios:\n\n[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]\n\nThe implementation details for adding `await` support inside `catch` and `finally` clauses ensure that the behavior is consistent with the behavior for synchronous code. When code executed in a `catch` or `finally` clause throws, execution looks for a suitable `catch` clause in the next surrounding block. If there was a current exception, that exception is lost. The same happens with awaited expressions in `catch` and `finally` clauses: a suitable `catch` is searched for, and the current exception, if any, is lost.  \n\n> [!NOTE]\n> This behavior is the reason it's recommended to write `catch` and `finally` clauses carefully, to avoid introducing new exceptions.\n\n## Initialize associative collections using indexers\n\n*Index Initializers* is one of two features that make collection initializers more consistent with index usage. In earlier releases of C#, you could use *collection initializers* with sequence style collections, including <xref:System.Collections.Generic.Dictionary%602>, by adding braces around key and value pairs:\n\n[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#CollectionInitializer)]\n\nYou can use them with <xref:System.Collections.Generic.Dictionary%602> collections and other types where the accessible `Add` method accepts more than one argument. The new syntax supports assignment using an index into the collection:\n\n[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]\n\nThis feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.\n\n## Extension `Add` methods in collection initializers\n\nAnother feature that makes collection initialization easier is the ability to use an *extension method* for the `Add` method. This feature was added for parity with Visual Basic. The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.\n\n## Improved overload resolution\n\nThis last feature is one you probably won't notice. There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous. Consider this method:\n\n[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]\n\nIn earlier versions of C#, calling that method using the method group syntax would fail:\n\n[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]\n\nThe earlier compiler couldn't distinguish correctly between `Task.Run(Action)` and `Task.Run(Func<Task>())`. In previous versions, you'd need to use a lambda expression as an argument:\n\n[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]\n\nThe C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is a better choice.\n\n### Deterministic compiler output\n\nThe `-deterministic` option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files.\n\nBy default, every compilation produces unique output on each compilation. The compiler adds a timestamp, and a GUID generated from random numbers. You use this option if you want to compare the byte-for-byte output to ensure consistency across builds.\n\nFor more information, see the [-deterministic compiler option](../language-reference/compiler-options/deterministic-compiler-option.md) article.\n","nodes":[{"pos":[4,112],"embed":true,"restype":"x-metadata","content":"title: What's New in C# 6 - C# Guide\ndescription: Learn the new features in C# Version 6\nms.date: 12/12/2018","nodes":[{"content":"What's New in C# 6 - C# Guide","nodes":[{"pos":[0,29],"content":"What's New in C# 6 - C# Guide","nodes":[{"content":"What's New in C# 6 - C# Guide","pos":[0,29]}]}],"path":["title"],"nosxs":false},{"content":"Learn the new features in C# Version 6","nodes":[{"pos":[0,38],"content":"Learn the new features in C# Version 6","nodes":[{"content":"Learn the new features in C# Version 6","pos":[0,38]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[120,138],"content":"What's New in C# 6","linkify":"What's New in C# 6","nodes":[{"content":"What's New in C# 6","pos":[0,18]}]},{"content":"The 6.0 release of C# contained many features that improve productivity for developers.","pos":[140,227]},{"content":"The overall effect of these features is that you write more concise code that is also more readable.","pos":[228,328]},{"content":"The syntax contains less ceremony for many common practices.","pos":[329,389]},{"content":"It's easier to see the design intent with less ceremony.","pos":[390,446]},{"content":"Learn these features well, and you'll be more productive and write more readable code.","pos":[447,533]},{"content":"You can concentrate more on your features than on the constructs of the language.","pos":[534,615]},{"content":"The rest of this article provides an overview of each of these features, with a link to explore each feature.","pos":[617,726]},{"content":"You can also explore the features in an <bpt id=\"p1\">[</bpt>interactive exploration on C# 6<ept id=\"p1\">](../tutorials/exploration/csharp-6.yml)</ept> in the tutorials section.","pos":[727,865],"source":" You can also explore the features in an [interactive exploration on C# 6](../tutorials/exploration/csharp-6.yml) in the tutorials section."},{"pos":[870,895],"content":"Read-only auto-properties","linkify":"Read-only auto-properties","nodes":[{"content":"Read-only auto-properties","pos":[0,25]}]},{"content":"<bpt id=\"p1\">*</bpt>Read-only auto-properties<ept id=\"p1\">*</ept> provide a more concise syntax to create immutable types.","pos":[897,981],"source":"*Read-only auto-properties* provide a more concise syntax to create immutable types."},{"content":"You declare the auto-property with only a get accessor:","pos":[982,1037],"source":" You declare the auto-property\nwith only a get accessor:"},{"pos":[1152,1239],"content":"The <ph id=\"ph1\">`FirstName`</ph> and <ph id=\"ph2\">`LastName`</ph> properties can be set only in the body of a constructor:","source":"The `FirstName` and `LastName` properties can be set only in the body of a constructor:"},{"pos":[1376,1458],"content":"Trying to set <ph id=\"ph1\">`LastName`</ph> in another method generates a <ph id=\"ph2\">`CS0200`</ph> compilation error:","source":"Trying to set `LastName` in another method generates a `CS0200` compilation error:"},{"content":"This feature enables true language support for creating immutable types and uses the more concise and convenient auto-property syntax.","pos":[1719,1853]},{"pos":[1855,2008],"content":"If adding this syntax doesn't remove an accessible method, it's a <bpt id=\"p1\">[</bpt>binary compatible change<ept id=\"p1\">](version-update-considerations.md#binary-compatible-changes)</ept>.","source":"If adding this syntax doesn't remove an accessible method, it's a [binary compatible change](version-update-considerations.md#binary-compatible-changes)."},{"pos":[2013,2039],"content":"Auto-property initializers","linkify":"Auto-property initializers","nodes":[{"content":"Auto-property initializers","pos":[0,26]}]},{"pos":[2041,2161],"content":"<bpt id=\"p1\">*</bpt>Auto-property initializers<ept id=\"p1\">*</ept> let you declare the initial value for an auto-property as part of the property declaration.","source":"*Auto-property initializers* let you declare the initial value for an auto-property as part of the property declaration."},{"content":"The <ph id=\"ph1\">`Grades`</ph> member is initialized where it's declared.","pos":[2264,2319],"source":"The `Grades` member is initialized where it's declared."},{"content":"That makes it easier to perform the initialization exactly once.","pos":[2320,2384]},{"content":"The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for <ph id=\"ph1\">`Student`</ph> objects.","pos":[2385,2539],"source":" The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for `Student` objects."},{"pos":[2544,2578],"content":"Expression-bodied function members","linkify":"Expression-bodied function members","nodes":[{"content":"Expression-bodied function members","pos":[0,34]}]},{"content":"Many members that you write are single statements that could be single expressions.","pos":[2580,2663]},{"content":"Write an expression-bodied member instead.","pos":[2664,2706]},{"content":"It works for methods and read-only properties.","pos":[2707,2753]},{"content":"For example, an override of <ph id=\"ph1\">`ToString()`</ph> is often a great candidate:","pos":[2754,2822],"source":" For example, an override of `ToString()` is often a great candidate:"},{"content":"You can also use this syntax for read-only properties:","pos":[2945,2999]},{"pos":[3122,3273],"content":"Changing an existing member to an expression bodied member is a <bpt id=\"p1\">[</bpt>binary compatible change<ept id=\"p1\">](version-update-considerations.md#binary-compatible-changes)</ept>.","source":"Changing an existing member to an expression bodied member is a [binary compatible change](version-update-considerations.md#binary-compatible-changes)."},{"pos":[3278,3290],"content":"using static","linkify":"using static","nodes":[{"content":"using static","pos":[0,12]}]},{"content":"The <bpt id=\"p1\">*</bpt>using static<ept id=\"p1\">*</ept> enhancement enables you to import the static methods of a single class.","pos":[3292,3382],"source":"The *using static* enhancement enables you to import the static methods of a single class."},{"content":"You specify the class you're using:","pos":[3383,3418]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Math&gt;</ph> does not contain any instance methods.","pos":[3523,3584],"source":"The <xref:System.Math> does not contain any instance methods."},{"content":"You can also use <ph id=\"ph1\">`using static`</ph> to import a class' static methods for a class that has both static and instance methods.","pos":[3585,3705],"source":" You can also use `using static` to import a class' static methods for a class that has both static and instance methods."},{"content":"One of the most useful examples is <ph id=\"ph1\">&lt;xref:System.String&gt;</ph>:","pos":[3706,3762],"source":" One of the most useful examples is <xref:System.String>:"},{"pos":[3861,4007],"content":"[!NOTE]\nYou must use the fully qualified class name, `System.String`  in a static using statement.  You cannot use the `string` keyword instead.","leadings":["","> "],"nodes":[{"content":"You must use the fully qualified class name, `System.String`  in a static using statement.  You cannot use the `string` keyword instead.","pos":[8,144],"nodes":[{"content":"You must use the fully qualified class name, <ph id=\"ph1\">`System.String`</ph>  in a static using statement.","pos":[0,90],"source":"You must use the fully qualified class name, `System.String`  in a static using statement."},{"content":"You cannot use the <ph id=\"ph1\">`string`</ph> keyword instead.","pos":[92,136],"source":"  You cannot use the `string` keyword instead."}]}]},{"content":"When imported from a <ph id=\"ph1\">`static using`</ph> statement, extension methods are only in scope when called using the extension method invocation syntax.","pos":[4009,4149],"source":"When imported from a `static using` statement, extension methods are only in scope when called using the extension method invocation syntax."},{"content":"They aren't in scope when called as a static method.","pos":[4150,4202]},{"content":"You'll often see this in LINQ queries.","pos":[4203,4241]},{"content":"You can import the LINQ pattern by importing <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable&gt;</ph>, or <ph id=\"ph2\">&lt;xref:System.Linq.Queryable&gt;</ph>.","pos":[4242,4350],"source":" You can import the LINQ pattern by importing <xref:System.Linq.Enumerable>, or <xref:System.Linq.Queryable>."},{"content":"You typically call extension methods using extension method invocation expressions.","pos":[4455,4538]},{"content":"Adding the class name in the rare case where you call them using static method call syntax resolves ambiguity.","pos":[4539,4649]},{"content":"The <ph id=\"ph1\">`static using`</ph> directive also imports any nested types.","pos":[4651,4710],"source":"The `static using` directive also imports any nested types."},{"content":"You can reference any nested types without qualification.","pos":[4711,4768]},{"pos":[4773,4799],"content":"Null-conditional operators","linkify":"Null-conditional operators","nodes":[{"content":"Null-conditional operators","pos":[0,26]}]},{"content":"The <bpt id=\"p1\">*</bpt>null conditional operator<ept id=\"p1\">*</ept> makes null checks much easier and fluid.","pos":[4801,4873],"source":"The *null conditional operator* makes null checks much easier and fluid."},{"content":"Replace the member access <ph id=\"ph1\">`.`</ph> with <ph id=\"ph2\">`?.`</ph>:","pos":[4874,4914],"source":" Replace the member access `.` with `?.`:"},{"content":"In the preceding example, the variable <ph id=\"ph1\">`first`</ph> is assigned <ph id=\"ph2\">`null`</ph> if the person object is <ph id=\"ph3\">`null`</ph>.","pos":[5019,5116],"source":"In the preceding example, the variable `first` is assigned `null` if the person object is `null`."},{"content":"Otherwise, it is assigned the value of the <ph id=\"ph1\">`FirstName`</ph> property.","pos":[5117,5181],"source":" Otherwise, it is assigned the value of the `FirstName` property."},{"content":"Most importantly, the <ph id=\"ph1\">`?.`</ph> means that this line of code doesn't generate a <ph id=\"ph2\">`NullReferenceException`</ph> if the <ph id=\"ph3\">`person`</ph> variable is <ph id=\"ph4\">`null`</ph>.","pos":[5182,5317],"source":" Most importantly, the `?.` means that this line of code doesn't generate a `NullReferenceException` if the `person` variable is `null`."},{"content":"Instead, it short-circuits and returns <ph id=\"ph1\">`null`</ph>.","pos":[5318,5364],"source":" Instead, it short-circuits and returns `null`."},{"content":"You can also use a null conditional operator for array or indexer access.","pos":[5365,5438]},{"content":"Replace <ph id=\"ph1\">`[]`</ph> with <ph id=\"ph2\">`?[]`</ph> in the index expression.","pos":[5439,5487],"source":" Replace `[]` with `?[]` in the index expression."},{"content":"The following expression returns a <ph id=\"ph1\">`string`</ph>, regardless of the value of <ph id=\"ph2\">`person`</ph>.","pos":[5489,5570],"source":"The following expression returns a `string`, regardless of the value of `person`."},{"content":"You often use this construct with the <bpt id=\"p1\">*</bpt>null coalescing<ept id=\"p1\">*</ept> operator to assign default values when one of the properties is <ph id=\"ph1\">`null`</ph>.","pos":[5571,5698],"source":" You often use this construct with the *null coalescing* operator to assign default values when one of the properties is `null`."},{"content":"When the expression short-circuits, the <ph id=\"ph1\">`null`</ph> value returned is typed to match the full expression.","pos":[5699,5799],"source":" When the expression short-circuits, the `null` value returned is typed to match the full expression."},{"content":"You can also use <ph id=\"ph1\">`?.`</ph> to conditionally invoke methods.","pos":[5902,5956],"source":"You can also use `?.` to conditionally invoke methods."},{"content":"The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be <ph id=\"ph1\">`null`</ph>.","pos":[5957,6102],"source":" The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be `null`."},{"content":"You'll call the delegate's <ph id=\"ph1\">`Invoke`</ph> method using the <ph id=\"ph2\">`?.`</ph> operator to access the member.","pos":[6104,6192],"source":"  You'll call the delegate's `Invoke` method using the `?.` operator to access the member."},{"content":"You can see an example in the <bpt id=\"p1\">[</bpt>delegate patterns<ept id=\"p1\">](../delegates-patterns.md#handling-null-delegates)</ept> article.","pos":[6193,6301],"source":" You can see an example in the [delegate patterns](../delegates-patterns.md#handling-null-delegates) article."},{"content":"The rules of the <ph id=\"ph1\">`?.`</ph> operator ensure that the left-hand side of the operator is evaluated only once.","pos":[6303,6404],"source":"The rules of the `?.` operator ensure that the left-hand side of the operator is evaluated only once."},{"content":"It enables many idioms, including the following example using event handlers:","pos":[6405,6482]},{"pos":[6570,6713],"content":"Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the <ph id=\"ph1\">`?.`</ph>","source":"Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the `?.`"},{"pos":[6718,6738],"content":"String interpolation","linkify":"String interpolation","nodes":[{"content":"String interpolation","pos":[0,20]}]},{"content":"With C# 6, the new <bpt id=\"p1\">[</bpt>string interpolation<ept id=\"p1\">](../language-reference/tokens/interpolated.md)</ept> feature enables you to embed expressions in a string.","pos":[6740,6881],"source":"With C# 6, the new [string interpolation](../language-reference/tokens/interpolated.md) feature enables you to embed expressions in a string."},{"content":"Simply preface the string with <ph id=\"ph1\">`$`</ph>and use expressions between <ph id=\"ph2\">`{`</ph> and <ph id=\"ph3\">`}`</ph> instead of ordinals:","pos":[6882,6976],"source":" Simply preface the string with `$`and use expressions between `{` and `}` instead of ordinals:"},{"content":"This example uses properties for the substituted expressions.","pos":[7094,7155]},{"content":"You can use any expression.","pos":[7156,7183]},{"content":"For example, you could compute a student's grade point average as part of the interpolation:","pos":[7184,7276]},{"pos":[7401,7520],"content":"The preceding line of code formats the value for <ph id=\"ph1\">`Grades.Average()`</ph> as a floating-point number with two decimal places.","source":"The preceding line of code formats the value for `Grades.Average()` as a floating-point number with two decimal places."},{"content":"Often, you may need to format the string produced using a specific culture.","pos":[7522,7597]},{"content":"You use the fact that the object produced by a string interpolation can be implicitly converted to <ph id=\"ph1\">&lt;xref:System.FormattableString?displayProperty=nameWithType&gt;</ph>.","pos":[7598,7758],"source":" You use the fact that the object produced by a string interpolation can be implicitly converted to <xref:System.FormattableString?displayProperty=nameWithType>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.FormattableString&gt;</ph> instance contains the composite format string and the results of evaluating the expressions before converting them to strings.","pos":[7759,7921],"source":" The <xref:System.FormattableString> instance contains the composite format string and the results of evaluating the expressions before converting them to strings."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType&gt;</ph> method to specify the culture when formatting a string.","pos":[7922,8079],"source":" Use the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to specify the culture when formatting a string."},{"content":"The following example produces a string using the German (de-DE) culture.","pos":[8080,8153]},{"content":"(By default, the German culture uses the ',' character for the decimal separator, and the '.' character as the thousands separator.)","pos":[8154,8286]},{"pos":[8445,8763],"content":"To get started with string interpolation, see the <bpt id=\"p1\">[</bpt>String interpolation in C#<ept id=\"p1\">](../tutorials/exploration/interpolated-strings.yml)</ept> interactive tutorial, the <bpt id=\"p2\">[</bpt>String interpolation<ept id=\"p2\">](../language-reference/tokens/interpolated.md)</ept> article, and the <bpt id=\"p3\">[</bpt>String interpolation in C#<ept id=\"p3\">](../tutorials/string-interpolation.md)</ept> tutorial.","source":"To get started with string interpolation, see the [String interpolation in C#](../tutorials/exploration/interpolated-strings.yml) interactive tutorial, the [String interpolation](../language-reference/tokens/interpolated.md) article, and the [String interpolation in C#](../tutorials/string-interpolation.md) tutorial."},{"pos":[8768,8785],"content":"Exception filters","linkify":"Exception filters","nodes":[{"content":"Exception filters","pos":[0,17]}]},{"content":"<bpt id=\"p1\">*</bpt>Exception Filters<ept id=\"p1\">*</ept> are clauses that determine when a given catch clause should be applied.","pos":[8787,8878],"source":"*Exception Filters* are clauses that determine when a given catch clause should be applied."},{"content":"If the expression used for an exception filter evaluates to <ph id=\"ph1\">`true`</ph>, the catch clause performs its normal processing on an exception.","pos":[8879,9011],"source":" If the expression used for an exception filter evaluates to `true`, the catch clause performs its normal processing on an exception."},{"content":"If the expression evaluates to <ph id=\"ph1\">`false`</ph>, then the <ph id=\"ph2\">`catch`</ph> clause is skipped.","pos":[9012,9087],"source":" If the\nexpression evaluates to `false`, then the `catch` clause is skipped."},{"content":"One use is to examine information about an exception to determine if a <ph id=\"ph1\">`catch`</ph> clause can process the exception:","pos":[9088,9200],"source":" One use is to examine information about an exception to determine if a `catch` clause can process the exception:"},{"pos":[9314,9337],"content":"The <ph id=\"ph1\">`nameof`</ph> expression","linkify":"The `nameof` expression","source":"The `nameof` expression"},{"content":"The <ph id=\"ph1\">`nameof`</ph> expression evaluates to the name of a symbol.","pos":[9339,9397],"source":"The `nameof` expression evaluates to the name of a symbol."},{"content":"It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.","pos":[9398,9508]},{"content":"One of the most common uses for <ph id=\"ph1\">`nameof`</ph> is to provide the name of a symbol that caused an exception:","pos":[9509,9610],"source":" One of the most common uses for `nameof` is to provide the name of a symbol that caused an exception:"},{"pos":[9708,9806],"content":"Another use is with XAML-based applications that implement the <ph id=\"ph1\">`INotifyPropertyChanged`</ph> interface:","source":"Another use is with XAML-based applications that implement the `INotifyPropertyChanged` interface:"},{"pos":[9910,9943],"content":"Await in Catch and Finally blocks","linkify":"Await in Catch and Finally blocks","nodes":[{"content":"Await in Catch and Finally blocks","pos":[0,33]}]},{"content":"C# 5 had several limitations around where you could place <ph id=\"ph1\">`await`</ph> expressions.","pos":[9945,10023],"source":"C# 5 had several limitations around where you could place `await` expressions."},{"content":"With C# 6, you can now use <ph id=\"ph1\">`await`</ph> in <ph id=\"ph2\">`catch`</ph> or <ph id=\"ph3\">`finally`</ph> expressions.","pos":[10024,10095],"source":" With C# 6, you can now use `await` in `catch` or `finally` expressions."},{"content":"This is most often used with logging scenarios:","pos":[10096,10143]},{"content":"The implementation details for adding <ph id=\"ph1\">`await`</ph> support inside <ph id=\"ph2\">`catch`</ph> and <ph id=\"ph3\">`finally`</ph> clauses ensure that the behavior is consistent with the behavior for synchronous code.","pos":[10248,10417],"source":"The implementation details for adding `await` support inside `catch` and `finally` clauses ensure that the behavior is consistent with the behavior for synchronous code."},{"content":"When code executed in a <ph id=\"ph1\">`catch`</ph> or <ph id=\"ph2\">`finally`</ph> clause throws, execution looks for a suitable <ph id=\"ph3\">`catch`</ph> clause in the next surrounding block.","pos":[10418,10554],"source":" When code executed in a `catch` or `finally` clause throws, execution looks for a suitable `catch` clause in the next surrounding block."},{"content":"If there was a current exception, that exception is lost.","pos":[10555,10612]},{"content":"The same happens with awaited expressions in <ph id=\"ph1\">`catch`</ph> and <ph id=\"ph2\">`finally`</ph> clauses: a suitable <ph id=\"ph3\">`catch`</ph> is searched for, and the current exception, if any, is lost.","pos":[10613,10768],"source":" The same happens with awaited expressions in `catch` and `finally` clauses: a suitable `catch` is searched for, and the current exception, if any, is lost."},{"pos":[10774,10915],"content":"[!NOTE]\nThis behavior is the reason it's recommended to write `catch` and `finally` clauses carefully, to avoid introducing new exceptions.","leadings":["","> "],"nodes":[{"content":"This behavior is the reason it's recommended to write <ph id=\"ph1\">`catch`</ph> and <ph id=\"ph2\">`finally`</ph> clauses carefully, to avoid introducing new exceptions.","pos":[8,139],"source":"This behavior is the reason it's recommended to write `catch` and `finally` clauses carefully, to avoid introducing new exceptions."}]},{"pos":[10920,10969],"content":"Initialize associative collections using indexers","linkify":"Initialize associative collections using indexers","nodes":[{"content":"Initialize associative collections using indexers","pos":[0,49]}]},{"content":"<bpt id=\"p1\">*</bpt>Index Initializers<ept id=\"p1\">*</ept> is one of two features that make collection initializers more consistent with index usage.","pos":[10971,11082],"source":"*Index Initializers* is one of two features that make collection initializers more consistent with index usage."},{"content":"In earlier releases of C#, you could use <bpt id=\"p1\">*</bpt>collection initializers<ept id=\"p1\">*</ept> with sequence style collections, including <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>, by adding braces around key and value pairs:","pos":[11083,11287],"source":" In earlier releases of C#, you could use *collection initializers* with sequence style collections, including <xref:System.Collections.Generic.Dictionary%602>, by adding braces around key and value pairs:"},{"content":"You can use them with <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> collections and other types where the accessible <ph id=\"ph2\">`Add`</ph> method accepts more than one argument.","pos":[11403,11567],"source":"You can use them with <xref:System.Collections.Generic.Dictionary%602> collections and other types where the accessible `Add` method accepts more than one argument."},{"content":"The new syntax supports assignment using an index into the collection:","pos":[11568,11638]},{"content":"This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.","pos":[11760,11916]},{"pos":[11921,11971],"content":"Extension <ph id=\"ph1\">`Add`</ph> methods in collection initializers","linkify":"Extension `Add` methods in collection initializers","source":"Extension `Add` methods in collection initializers"},{"content":"Another feature that makes collection initialization easier is the ability to use an <bpt id=\"p1\">*</bpt>extension method<ept id=\"p1\">*</ept> for the <ph id=\"ph1\">`Add`</ph> method.","pos":[11973,12098],"source":"Another feature that makes collection initialization easier is the ability to use an *extension method* for the `Add` method."},{"content":"This feature was added for parity with Visual Basic.","pos":[12099,12151]},{"content":"The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.","pos":[12152,12289]},{"pos":[12294,12322],"content":"Improved overload resolution","linkify":"Improved overload resolution","nodes":[{"content":"Improved overload resolution","pos":[0,28]}]},{"content":"This last feature is one you probably won't notice.","pos":[12324,12375]},{"content":"There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.","pos":[12376,12516]},{"content":"Consider this method:","pos":[12517,12538]},{"content":"In earlier versions of C#, calling that method using the method group syntax would fail:","pos":[12637,12725]},{"content":"The earlier compiler couldn't distinguish correctly between <ph id=\"ph1\">`Task.Run(Action)`</ph> and <ph id=\"ph2\">`Task.Run(Func&lt;Task&gt;())`</ph>.","pos":[12824,12932],"source":"The earlier compiler couldn't distinguish correctly between `Task.Run(Action)` and `Task.Run(Func<Task>())`."},{"content":"In previous versions, you'd need to use a lambda expression as an argument:","pos":[12933,13008]},{"pos":[13097,13185],"content":"The C# 6 compiler correctly determines that <ph id=\"ph1\">`Task.Run(Func&lt;Task&gt;())`</ph> is a better choice.","source":"The C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is a better choice."},{"pos":[13191,13220],"content":"Deterministic compiler output","linkify":"Deterministic compiler output","nodes":[{"content":"Deterministic compiler output","pos":[0,29]}]},{"pos":[13222,13379],"content":"The <ph id=\"ph1\">`-deterministic`</ph> option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files.","source":"The `-deterministic` option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files."},{"content":"By default, every compilation produces unique output on each compilation.","pos":[13381,13454]},{"content":"The compiler adds a timestamp, and a GUID generated from random numbers.","pos":[13455,13527]},{"content":"You use this option if you want to compare the byte-for-byte output to ensure consistency across builds.","pos":[13528,13632]},{"pos":[13634,13778],"content":"For more information, see the <bpt id=\"p1\">[</bpt>-deterministic compiler option<ept id=\"p1\">](../language-reference/compiler-options/deterministic-compiler-option.md)</ept> article.","source":"For more information, see the [-deterministic compiler option](../language-reference/compiler-options/deterministic-compiler-option.md) article."}]}