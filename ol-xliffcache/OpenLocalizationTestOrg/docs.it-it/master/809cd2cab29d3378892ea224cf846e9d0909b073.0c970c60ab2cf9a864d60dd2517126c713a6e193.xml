{"content":"---\ntitle: \">> operator - C# Reference\"\nms.custom: seodec18\nms.date: 02/12/2019\nf1_keywords: \n  - \">>_CSharpKeyword\"\nhelpviewer_keywords: \n  - \">> operator [C#]\"\n  - \"right shift operator (>>) [C#]\"\nms.assetid: a07f8679-d318-4ef8-b38b-65903efb8056\n---\n# >> operator (C# Reference)\n\nThe right-shift operator `>>` shifts its first operand right by the number of bits defined by its second operand. All integer types support the `>>` operator. However, the type of the second operand must be [int](../keywords/int.md) or a type that has a [predefined implicit numeric conversion](../keywords/implicit-numeric-conversions-table.md) to `int`.\n\nThe right-shift operation discards the low-order bits. The high-order empty bit positions are set based on the type of the first operand as follows:\n\n- If the first operand is of type [int](../keywords/int.md) or [long](../keywords/long.md), the right-shift operator performs an **arithmetic** shift: the value of the most significant bit (the sign bit) of the first operand is propagated to the high-order empty bit positions. That is, the high-order empty bit positions are set to zero if the first operand is non-negative and set to one if it's negative.\n\n- If the first operand is of type [uint](../keywords/uint.md) or [ulong](../keywords/ulong.md), the right-shift operator performs a **logical** shift: the high-order empty bit positions are always set to zero.\n\nThe following example demonstrates that behavior:\n\n[!code-csharp-interactive[right shift example](~/samples/snippets/csharp/language-reference/operators/ShiftOperatorsExamples.cs#RightShift)]\n\n## Shift count\n\nFor the expression `x >> count`, the actual shift count depends on the type of `x` as follows:\n\n- If the type of `x` is [int](../keywords/int.md) or [uint](../keywords/uint.md), the shift count is given by the low-order *five* bits of the second operand. That is, the shift count is computed from `count & 0x1F` (or `count & 0b_1_1111`).\n\n- If the type of `x` is [long](../keywords/long.md) or [ulong](../keywords/ulong.md), the shift count is given by the low-order *six* bits of the second operand. That is, the shift count is computed from `count & 0x3F` (or `count & 0b_11_1111`).\n\nThe following example demonstrates that behavior:\n\n[!code-csharp-interactive[shift count example](~/samples/snippets/csharp/language-reference/operators/ShiftOperatorsExamples.cs#RightShiftByLargeCount)]\n\n## Remarks\n\nShift operations never cause overflows and produce the same results in [checked and unchecked](../keywords/checked-and-unchecked.md) contexts.\n\n## Operator overloadability\n\nUser-defined types can [overload](../keywords/operator.md) the `>>` operator. If a user-defined type `T` overloads the `>>` operator, the type of the first operand must be `T` and the type of the second operand must be `int`. When the `>>` operator is overloaded, the [right-shift assignment operator](right-shift-assignment-operator.md) `>>=` is also implicitly overloaded.\n\n## C# language specification\n\nFor more information, see the [Shift operators](~/_csharplang/spec/expressions.md#shift-operators) section of the [C# language specification](../language-specification/index.md).\n\n## See also\n\n- [C# Reference](../index.md)\n- [C# Programming Guide](../../programming-guide/index.md)\n- [C# operators](index.md)\n- [<< operator](left-shift-operator.md)","nodes":[{"pos":[4,247],"embed":true,"restype":"x-metadata","content":"title: \">> operator - C# Reference\"\nms.custom: seodec18\nms.date: 02/12/2019\nf1_keywords: \n  - \">>_CSharpKeyword\"\nhelpviewer_keywords: \n  - \">> operator [C#]\"\n  - \"right shift operator (>>) [C#]\"\nms.assetid: a07f8679-d318-4ef8-b38b-65903efb8056","nodes":[{"content":">> operator - C# Reference","nodes":[{"pos":[3,26],"content":"operator - C# Reference","nodes":[{"content":"operator - C# Reference","pos":[0,23]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[254,280],"content":">> operator (C# Reference)","linkify":">> operator (C# Reference)","nodes":[{"content":"&gt;&gt; operator (C# Reference)","pos":[0,26],"source":">> operator (C# Reference)"}]},{"content":"The right-shift operator <ph id=\"ph1\">`&gt;&gt;`</ph> shifts its first operand right by the number of bits defined by its second operand.","pos":[282,395],"source":"The right-shift operator `>>` shifts its first operand right by the number of bits defined by its second operand."},{"content":"All integer types support the <ph id=\"ph1\">`&gt;&gt;`</ph> operator.","pos":[396,440],"source":" All integer types support the `>>` operator."},{"content":"However, the type of the second operand must be <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../keywords/int.md)</ept> or a type that has a <bpt id=\"p2\">[</bpt>predefined implicit numeric conversion<ept id=\"p2\">](../keywords/implicit-numeric-conversions-table.md)</ept> to <ph id=\"ph1\">`int`</ph>.","pos":[441,637],"source":" However, the type of the second operand must be [int](../keywords/int.md) or a type that has a [predefined implicit numeric conversion](../keywords/implicit-numeric-conversions-table.md) to `int`."},{"content":"The right-shift operation discards the low-order bits.","pos":[639,693]},{"content":"The high-order empty bit positions are set based on the type of the first operand as follows:","pos":[694,787]},{"content":"If the first operand is of type <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../keywords/int.md)</ept> or <bpt id=\"p2\">[</bpt>long<ept id=\"p2\">](../keywords/long.md)</ept>, the right-shift operator performs an <bpt id=\"p3\">**</bpt>arithmetic<ept id=\"p3\">**</ept> shift: the value of the most significant bit (the sign bit) of the first operand is propagated to the high-order empty bit positions.","pos":[791,1066],"source":"If the first operand is of type [int](../keywords/int.md) or [long](../keywords/long.md), the right-shift operator performs an **arithmetic** shift: the value of the most significant bit (the sign bit) of the first operand is propagated to the high-order empty bit positions."},{"content":"That is, the high-order empty bit positions are set to zero if the first operand is non-negative and set to one if it's negative.","pos":[1067,1196]},{"pos":[1200,1407],"content":"If the first operand is of type <bpt id=\"p1\">[</bpt>uint<ept id=\"p1\">](../keywords/uint.md)</ept> or <bpt id=\"p2\">[</bpt>ulong<ept id=\"p2\">](../keywords/ulong.md)</ept>, the right-shift operator performs a <bpt id=\"p3\">**</bpt>logical<ept id=\"p3\">**</ept> shift: the high-order empty bit positions are always set to zero.","source":"If the first operand is of type [uint](../keywords/uint.md) or [ulong](../keywords/ulong.md), the right-shift operator performs a **logical** shift: the high-order empty bit positions are always set to zero."},{"content":"The following example demonstrates that behavior:","pos":[1409,1458]},{"pos":[1605,1616],"content":"Shift count","linkify":"Shift count","nodes":[{"content":"Shift count","pos":[0,11]}]},{"pos":[1618,1712],"content":"For the expression <ph id=\"ph1\">`x &gt;&gt; count`</ph>, the actual shift count depends on the type of <ph id=\"ph2\">`x`</ph> as follows:","source":"For the expression `x >> count`, the actual shift count depends on the type of `x` as follows:"},{"content":"If the type of <ph id=\"ph1\">`x`</ph> is <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../keywords/int.md)</ept> or <bpt id=\"p2\">[</bpt>uint<ept id=\"p2\">](../keywords/uint.md)</ept>, the shift count is given by the low-order <bpt id=\"p3\">*</bpt>five<ept id=\"p3\">*</ept> bits of the second operand.","pos":[1716,1872],"source":"If the type of `x` is [int](../keywords/int.md) or [uint](../keywords/uint.md), the shift count is given by the low-order *five* bits of the second operand."},{"content":"That is, the shift count is computed from <ph id=\"ph1\">`count &amp; 0x1F`</ph> (or <ph id=\"ph2\">`count &amp; 0b_1_1111`</ph>).","pos":[1873,1955],"source":" That is, the shift count is computed from `count & 0x1F` (or `count & 0b_1_1111`)."},{"content":"If the type of <ph id=\"ph1\">`x`</ph> is <bpt id=\"p1\">[</bpt>long<ept id=\"p1\">](../keywords/long.md)</ept> or <bpt id=\"p2\">[</bpt>ulong<ept id=\"p2\">](../keywords/ulong.md)</ept>, the shift count is given by the low-order <bpt id=\"p3\">*</bpt>six<ept id=\"p3\">*</ept> bits of the second operand.","pos":[1959,2118],"source":"If the type of `x` is [long](../keywords/long.md) or [ulong](../keywords/ulong.md), the shift count is given by the low-order *six* bits of the second operand."},{"content":"That is, the shift count is computed from <ph id=\"ph1\">`count &amp; 0x3F`</ph> (or <ph id=\"ph2\">`count &amp; 0b_11_1111`</ph>).","pos":[2119,2202],"source":" That is, the shift count is computed from `count & 0x3F` (or `count & 0b_11_1111`)."},{"content":"The following example demonstrates that behavior:","pos":[2204,2253]},{"pos":[2412,2419],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2421,2563],"content":"Shift operations never cause overflows and produce the same results in <bpt id=\"p1\">[</bpt>checked and unchecked<ept id=\"p1\">](../keywords/checked-and-unchecked.md)</ept> contexts.","source":"Shift operations never cause overflows and produce the same results in [checked and unchecked](../keywords/checked-and-unchecked.md) contexts."},{"pos":[2568,2592],"content":"Operator overloadability","linkify":"Operator overloadability","nodes":[{"content":"Operator overloadability","pos":[0,24]}]},{"content":"User-defined types can <bpt id=\"p1\">[</bpt>overload<ept id=\"p1\">](../keywords/operator.md)</ept> the <ph id=\"ph1\">`&gt;&gt;`</ph> operator.","pos":[2594,2671],"source":"User-defined types can [overload](../keywords/operator.md) the `>>` operator."},{"content":"If a user-defined type <ph id=\"ph1\">`T`</ph> overloads the <ph id=\"ph2\">`&gt;&gt;`</ph> operator, the type of the first operand must be <ph id=\"ph3\">`T`</ph> and the type of the second operand must be <ph id=\"ph4\">`int`</ph>.","pos":[2672,2819],"source":" If a user-defined type `T` overloads the `>>` operator, the type of the first operand must be `T` and the type of the second operand must be `int`."},{"content":"When the <ph id=\"ph1\">`&gt;&gt;`</ph> operator is overloaded, the <bpt id=\"p1\">[</bpt>right-shift assignment operator<ept id=\"p1\">](right-shift-assignment-operator.md)</ept> <ph id=\"ph2\">`&gt;&gt;=`</ph> is also implicitly overloaded.","pos":[2820,2968],"source":" When the `>>` operator is overloaded, the [right-shift assignment operator](right-shift-assignment-operator.md) `>>=` is also implicitly overloaded."},{"pos":[2973,2998],"content":"C# language specification","linkify":"C# language specification","nodes":[{"content":"C# language specification","pos":[0,25]}]},{"pos":[3000,3178],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Shift operators<ept id=\"p1\">](~/_csharplang/spec/expressions.md#shift-operators)</ept> section of the <bpt id=\"p2\">[</bpt>C# language specification<ept id=\"p2\">](../language-specification/index.md)</ept>.","source":"For more information, see the [Shift operators](~/_csharplang/spec/expressions.md#shift-operators) section of the [C# language specification](../language-specification/index.md)."},{"pos":[3183,3191],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3195,3222],"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../index.md)</ept>","source":"[C# Reference](../index.md)"},{"pos":[3225,3281],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../programming-guide/index.md)"},{"pos":[3284,3308],"content":"<bpt id=\"p1\">[</bpt>C# operators<ept id=\"p1\">](index.md)</ept>","source":"[C# operators](index.md)"},{"pos":[3311,3348],"content":"<bpt id=\"p1\">[</bpt>&lt;&lt; operator<ept id=\"p1\">](left-shift-operator.md)</ept>","source":"[<< operator](left-shift-operator.md)"}]}