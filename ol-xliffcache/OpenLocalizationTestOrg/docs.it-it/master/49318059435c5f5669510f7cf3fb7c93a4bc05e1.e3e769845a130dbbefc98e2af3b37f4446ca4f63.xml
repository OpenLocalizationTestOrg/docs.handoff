{"content":"---\ntitle: \"Optimizing Performance: Object Behavior\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"user interface virtualization [WPF]\"\n  - \"dependency properties [WPF], performance\"\n  - \"event handlers [WPF]\"\n  - \"object performance considerations [WPF]\"\n  - \"Freezable objects [WPF], performance\"\nms.assetid: 73aa2f47-1d73-439a-be1f-78dc4ba2b5bd\n---\n# Optimizing Performance: Object Behavior\nUnderstanding the intrinsic behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] objects will help you make the right tradeoffs between functionality and performance.  \n\n<a name=\"Not_Removing_Event_Handlers\"></a>   \n## Not Removing Event Handlers on Objects may Keep Objects Alive  \n The delegate that an object passes to its event is effectively a reference to that object. Therefore, event handlers can keep objects alive longer than expected. When performing clean up of an object that has registered to listen to an object's event, it is essential to remove that delegate before releasing the object. Keeping unneeded objects alive increases the application's memory usage. This is especially true when the object is the root of a logical tree or a visual tree.  \n  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] introduces a weak event listener pattern for events that can be useful in situations where the object lifetime relationships between source and listener are difficult to keep track of. Some existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] events use this pattern. If you are implementing objects with custom events, this pattern may be of use to you. For details, see [Weak Event Patterns](weak-event-patterns.md).  \n  \n There are several tools, such as the CLR Profiler and the Working Set Viewer, that can provides information on the memory usage of a specified process. The CLR Profiler includes a number of very useful views of the allocation profile, including a histogram of allocated types, allocation and call graphs, a time line showing garbage collections of various generations and the resulting state of the managed heap after those collections, and a call tree showing per-method allocations and assembly loads. For more information, see [.NET Framework Developer Center](https://go.microsoft.com/fwlink/?LinkId=117435).  \n  \n<a name=\"DPs_and_Objects\"></a>   \n## Dependency Properties and Objects  \n In general, accessing a dependency property of a <xref:System.Windows.DependencyObject> is not slower than accessing a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property. While there is a small performance overhead for setting a property value, getting a value is as fast as getting the value from a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property. Offsetting the small performance overhead is the fact that dependency properties support robust features, such as data binding, animation, inheritance, and styling. For more information, see [Dependency Properties Overview](dependency-properties-overview.md).  \n  \n### DependencyProperty Optimizations  \n You should define dependency properties in your application very carefully. If your <xref:System.Windows.DependencyProperty> affects only render type metadata options, rather than other metadata options such as <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, you should mark it as such by overriding its metadata. For more information about overriding or obtaining property metadata, see [Dependency Property Metadata](dependency-property-metadata.md).  \n  \n It may be more efficient to have a property change handler invalidate the measure, arrange, and render passes manually if not all property changes actually affect measure, arrange, and render. For instance, you might decide to re-render a background only when a value is greater than a set limit. In this case, your property change handler would only invalidate render when the value exceeds the set limit.  \n  \n### Making a DependencyProperty Inheritable is Not Free  \n By default, registered dependency properties are non-inheritable. However, you can explicitly make any property inheritable. While this is a useful feature, converting a property to be inheritable impacts performance by increasing the length of time for property invalidation.  \n  \n### Use RegisterClassHandler Carefully  \n While calling <xref:System.Windows.EventManager.RegisterClassHandler%2A> allows you to save your instance state, it is important to be aware that the handler is called on every instance, which can cause performance problems. Only use <xref:System.Windows.EventManager.RegisterClassHandler%2A> when your application requires that you save your instance state.  \n  \n### Set the Default Value for a DependencyProperty during Registration  \n When creating a <xref:System.Windows.DependencyProperty> that requires a default value, set the value using the default metadata passed as a parameter to the <xref:System.Windows.DependencyProperty.Register%2A> method of the <xref:System.Windows.DependencyProperty>. Use this technique rather than setting the property value in a constructor or on each instance of an element.  \n  \n### Set the PropertyMetadata Value using Register  \n When creating a <xref:System.Windows.DependencyProperty>, you have the option of setting the <xref:System.Windows.PropertyMetadata> using either the <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> methods. Although your object could have a static constructor to call <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, this is not the optimal solution and will impact performance. For best performance, set the <xref:System.Windows.PropertyMetadata> during the call to <xref:System.Windows.DependencyProperty.Register%2A>.  \n  \n<a name=\"Freezable_Objects\"></a>   \n## Freezable Objects  \n A <xref:System.Windows.Freezable> is a special type of object that has two states: unfrozen and frozen. Freezing objects whenever possible improves the performance of your application and reduces its working set. For more information, see [Freezable Objects Overview](freezable-objects-overview.md).  \n  \n Each <xref:System.Windows.Freezable> has a <xref:System.Windows.Freezable.Changed> event that is raised whenever it changes. However, change notifications are costly in terms of application performance.  \n  \n Consider the following example in which each <xref:System.Windows.Shapes.Rectangle> uses the same <xref:System.Windows.Media.Brush> object:  \n  \n [!code-csharp[Performance#PerformanceSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet2)]\n [!code-vb[Performance#PerformanceSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet2)]  \n  \n By default, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides an event handler for the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event in order to invalidate the <xref:System.Windows.Shapes.Rectangle> object's <xref:System.Windows.Shapes.Shape.Fill%2A> property. In this case, each time the <xref:System.Windows.Media.SolidColorBrush> has to fire its <xref:System.Windows.Freezable.Changed> event it is required to invoke the callback function for each <xref:System.Windows.Shapes.Rectangle>â€”the accumulation of these callback function invocations impose a significant performance penalty. In addition, it is very performance intensive to add and remove handlers at this point since the application would have to traverse the entire list to do so. If your application scenario never changes the <xref:System.Windows.Media.SolidColorBrush>, you will be paying the cost of maintaining <xref:System.Windows.Freezable.Changed> event handlers unnecessarily.  \n  \n Freezing a <xref:System.Windows.Freezable> can improve its performance, because it no longer needs to expend resources on maintaining change notifications. The table below shows the size of a simple <xref:System.Windows.Media.SolidColorBrush> when its <xref:System.Windows.Freezable.IsFrozen%2A> property is set to `true`, compared to when it is not. This assumes applying one brush to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of ten <xref:System.Windows.Shapes.Rectangle> objects.  \n  \n|**State**|**Size**|  \n|---------------|--------------|  \n|Frozen <xref:System.Windows.Media.SolidColorBrush>|212 Bytes|  \n|Non-frozen <xref:System.Windows.Media.SolidColorBrush>|972 Bytes|  \n  \n The following code sample demonstrates this concept:  \n  \n [!code-csharp[Performance#PerformanceSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet3)]\n [!code-vb[Performance#PerformanceSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet3)]  \n  \n### Changed Handlers on Unfrozen Freezables may Keep Objects Alive  \n The delegate that an object passes to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event is effectively a reference to that object. Therefore, <xref:System.Windows.Freezable.Changed> event handlers can keep objects alive longer than expected. When performing clean up of an object that has registered to listen to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event, it is essential to remove that delegate before releasing the object.  \n  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] also hooks up <xref:System.Windows.Freezable.Changed> events internally. For example, all dependency properties which take <xref:System.Windows.Freezable> as a value will listen to <xref:System.Windows.Freezable.Changed> events automatically. The <xref:System.Windows.Shapes.Shape.Fill%2A> property, which takes a <xref:System.Windows.Media.Brush>, illustrates this concept.  \n  \n [!code-csharp[Performance#PerformanceSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet4)]\n [!code-vb[Performance#PerformanceSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet4)]  \n  \n On the assignment of `myBrush` to `myRectangle.Fill`, a delegate pointing back to the <xref:System.Windows.Shapes.Rectangle> object will be added to the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event. This means the following code does not actually make `myRect` eligible for garbage collection:  \n  \n [!code-csharp[Performance#PerformanceSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet5)]\n [!code-vb[Performance#PerformanceSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet5)]  \n  \n In this case `myBrush` is still keeping `myRectangle` alive and will call back to it when it fires its <xref:System.Windows.Freezable.Changed> event. Note that assigning `myBrush` to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of a new <xref:System.Windows.Shapes.Rectangle> will simply add another event handler to `myBrush`.  \n  \n The recommended way to clean up these types of objects is to remove the <xref:System.Windows.Media.Brush> from the <xref:System.Windows.Shapes.Shape.Fill%2A> property, which will in turn remove the <xref:System.Windows.Freezable.Changed> event handler.  \n  \n [!code-csharp[Performance#PerformanceSnippet6](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet6)]\n [!code-vb[Performance#PerformanceSnippet6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet6)]  \n  \n<a name=\"User_Interface_Virtualization\"></a>   \n## User Interface Virtualization  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] also provides a variation of the <xref:System.Windows.Controls.StackPanel> element that automatically \"virtualizes\" data-bound child content. In this context, the word virtualize refers to a technique by which a subset of objects are generated from a larger number of data items based upon which items are visible on-screen. It is intensive, both in terms of memory and processor, to generate a large number of UI elements when only a few may be on the screen at a given time. <xref:System.Windows.Controls.VirtualizingStackPanel> (through functionality provided by <xref:System.Windows.Controls.VirtualizingPanel>) calculates visible items and works with the <xref:System.Windows.Controls.ItemContainerGenerator> from an <xref:System.Windows.Controls.ItemsControl> (such as <xref:System.Windows.Controls.ListBox> or <xref:System.Windows.Controls.ListView>) to only create elements for visible items.  \n  \n As a performance optimization, visual objects for these items are only generated or kept alive if they are visible on the screen. When they are no longer in the viewable area of the control, the visual objects may be removed. This is not to be confused with data virtualization, where data objects are not all present in the local collection- rather streamed in as needed.  \n  \n The table below shows the elapsed time adding and rendering 5000 <xref:System.Windows.Controls.TextBlock> elements to a <xref:System.Windows.Controls.StackPanel> and a <xref:System.Windows.Controls.VirtualizingStackPanel>. In this scenario, the measurements represent the time between attaching a text string to the <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> property of an <xref:System.Windows.Controls.ItemsControl> object to the time when the panel elements display the text string.  \n  \n|**Host panel**|**Render time (ms)**|  \n|--------------------|----------------------------|  \n|<xref:System.Windows.Controls.StackPanel>|3210|  \n|<xref:System.Windows.Controls.VirtualizingStackPanel>|46|  \n  \n## See also\n\n- [Optimizing WPF Application Performance](optimizing-wpf-application-performance.md)\n- [Planning for Application Performance](planning-for-application-performance.md)\n- [Taking Advantage of Hardware](optimizing-performance-taking-advantage-of-hardware.md)\n- [Layout and Design](optimizing-performance-layout-and-design.md)\n- [2D Graphics and Imaging](optimizing-performance-2d-graphics-and-imaging.md)\n- [Application Resources](optimizing-performance-application-resources.md)\n- [Text](optimizing-performance-text.md)\n- [Data Binding](optimizing-performance-data-binding.md)\n- [Other Performance Recommendations](optimizing-performance-other-recommendations.md)\n","nodes":[{"pos":[4,384],"embed":true,"restype":"x-metadata","content":"title: \"Optimizing Performance: Object Behavior\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"user interface virtualization [WPF]\"\n  - \"dependency properties [WPF], performance\"\n  - \"event handlers [WPF]\"\n  - \"object performance considerations [WPF]\"\n  - \"Freezable objects [WPF], performance\"\nms.assetid: 73aa2f47-1d73-439a-be1f-78dc4ba2b5bd","nodes":[{"content":"Optimizing Performance: Object Behavior","nodes":[{"pos":[0,39],"content":"Optimizing Performance: Object Behavior","nodes":[{"content":"Optimizing Performance: Object Behavior","pos":[0,39]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[391,430],"content":"Optimizing Performance: Object Behavior","linkify":"Optimizing Performance: Object Behavior","nodes":[{"content":"Optimizing Performance: Object Behavior","pos":[0,39]}]},{"pos":[431,638],"content":"Understanding the intrinsic behavior of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> objects will help you make the right tradeoffs between functionality and performance.","source":"Understanding the intrinsic behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] objects will help you make the right tradeoffs between functionality and performance."},{"pos":[691,752],"content":"Not Removing Event Handlers on Objects may Keep Objects Alive","linkify":"Not Removing Event Handlers on Objects may Keep Objects Alive","nodes":[{"content":"Not Removing Event Handlers on Objects may Keep Objects Alive","pos":[0,61]}]},{"content":"The delegate that an object passes to its event is effectively a reference to that object.","pos":[756,846]},{"content":"Therefore, event handlers can keep objects alive longer than expected.","pos":[847,917]},{"content":"When performing clean up of an object that has registered to listen to an object's event, it is essential to remove that delegate before releasing the object.","pos":[918,1076]},{"content":"Keeping unneeded objects alive increases the application's memory usage.","pos":[1077,1149]},{"content":"This is especially true when the object is the root of a logical tree or a visual tree.","pos":[1150,1237]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> introduces a weak event listener pattern for events that can be useful in situations where the object lifetime relationships between source and listener are difficult to keep track of.","pos":[1244,1510],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] introduces a weak event listener pattern for events that can be useful in situations where the object lifetime relationships between source and listener are difficult to keep track of."},{"content":"Some existing <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> events use this pattern.","pos":[1511,1631],"source":" Some existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] events use this pattern."},{"content":"If you are implementing objects with custom events, this pattern may be of use to you.","pos":[1632,1718]},{"content":"For details, see <bpt id=\"p1\">[</bpt>Weak Event Patterns<ept id=\"p1\">](weak-event-patterns.md)</ept>.","pos":[1719,1782],"source":" For details, see [Weak Event Patterns](weak-event-patterns.md)."},{"content":"There are several tools, such as the CLR Profiler and the Working Set Viewer, that can provides information on the memory usage of a specified process.","pos":[1789,1940]},{"content":"The CLR Profiler includes a number of very useful views of the allocation profile, including a histogram of allocated types, allocation and call graphs, a time line showing garbage collections of various generations and the resulting state of the managed heap after those collections, and a call tree showing per-method allocations and assembly loads.","pos":[1941,2292]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>.NET Framework Developer Center<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=117435)</ept>.","pos":[2293,2401],"source":" For more information, see [.NET Framework Developer Center](https://go.microsoft.com/fwlink/?LinkId=117435)."},{"pos":[2444,2477],"content":"Dependency Properties and Objects","linkify":"Dependency Properties and Objects","nodes":[{"content":"Dependency Properties and Objects","pos":[0,33]}]},{"content":"In general, accessing a dependency property of a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> is not slower than accessing a <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> property.","pos":[2481,2679],"source":"In general, accessing a dependency property of a <xref:System.Windows.DependencyObject> is not slower than accessing a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property."},{"content":"While there is a small performance overhead for setting a property value, getting a value is as fast as getting the value from a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> property.","pos":[2680,2888],"source":" While there is a small performance overhead for setting a property value, getting a value is as fast as getting the value from a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property."},{"content":"Offsetting the small performance overhead is the fact that dependency properties support robust features, such as data binding, animation, inheritance, and styling.","pos":[2889,3053]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](dependency-properties-overview.md)</ept>.","pos":[3054,3148],"source":" For more information, see [Dependency Properties Overview](dependency-properties-overview.md)."},{"pos":[3158,3190],"content":"DependencyProperty Optimizations","linkify":"DependencyProperty Optimizations","nodes":[{"content":"DependencyProperty Optimizations","pos":[0,32]}]},{"content":"You should define dependency properties in your application very carefully.","pos":[3194,3269]},{"content":"If your <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> affects only render type metadata options, rather than other metadata options such as <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph>, you should mark it as such by overriding its metadata.","pos":[3270,3526],"source":" If your <xref:System.Windows.DependencyProperty> affects only render type metadata options, rather than other metadata options such as <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, you should mark it as such by overriding its metadata."},{"content":"For more information about overriding or obtaining property metadata, see <bpt id=\"p1\">[</bpt>Dependency Property Metadata<ept id=\"p1\">](dependency-property-metadata.md)</ept>.","pos":[3527,3665],"source":" For more information about overriding or obtaining property metadata, see [Dependency Property Metadata](dependency-property-metadata.md)."},{"content":"It may be more efficient to have a property change handler invalidate the measure, arrange, and render passes manually if not all property changes actually affect measure, arrange, and render.","pos":[3672,3864]},{"content":"For instance, you might decide to re-render a background only when a value is greater than a set limit.","pos":[3865,3968]},{"content":"In this case, your property change handler would only invalidate render when the value exceeds the set limit.","pos":[3969,4078]},{"pos":[4088,4139],"content":"Making a DependencyProperty Inheritable is Not Free","linkify":"Making a DependencyProperty Inheritable is Not Free","nodes":[{"content":"Making a DependencyProperty Inheritable is Not Free","pos":[0,51]}]},{"content":"By default, registered dependency properties are non-inheritable.","pos":[4143,4208]},{"content":"However, you can explicitly make any property inheritable.","pos":[4209,4267]},{"content":"While this is a useful feature, converting a property to be inheritable impacts performance by increasing the length of time for property invalidation.","pos":[4268,4419]},{"pos":[4429,4463],"content":"Use RegisterClassHandler Carefully","linkify":"Use RegisterClassHandler Carefully","nodes":[{"content":"Use RegisterClassHandler Carefully","pos":[0,34]}]},{"content":"While calling <ph id=\"ph1\">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph> allows you to save your instance state, it is important to be aware that the handler is called on every instance, which can cause performance problems.","pos":[4467,4691],"source":"While calling <xref:System.Windows.EventManager.RegisterClassHandler%2A> allows you to save your instance state, it is important to be aware that the handler is called on every instance, which can cause performance problems."},{"content":"Only use <ph id=\"ph1\">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph> when your application requires that you save your instance state.","pos":[4692,4825],"source":" Only use <xref:System.Windows.EventManager.RegisterClassHandler%2A> when your application requires that you save your instance state."},{"pos":[4835,4901],"content":"Set the Default Value for a DependencyProperty during Registration","linkify":"Set the Default Value for a DependencyProperty during Registration","nodes":[{"content":"Set the Default Value for a DependencyProperty during Registration","pos":[0,66]}]},{"content":"When creating a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> that requires a default value, set the value using the default metadata passed as a parameter to the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method of the <ph id=\"ph3\">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.","pos":[4905,5171],"source":"When creating a <xref:System.Windows.DependencyProperty> that requires a default value, set the value using the default metadata passed as a parameter to the <xref:System.Windows.DependencyProperty.Register%2A> method of the <xref:System.Windows.DependencyProperty>."},{"content":"Use this technique rather than setting the property value in a constructor or on each instance of an element.","pos":[5172,5281]},{"pos":[5291,5336],"content":"Set the PropertyMetadata Value using Register","linkify":"Set the PropertyMetadata Value using Register","nodes":[{"content":"Set the PropertyMetadata Value using Register","pos":[0,45]}]},{"content":"When creating a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph>, you have the option of setting the <ph id=\"ph2\">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> using either the <ph id=\"ph3\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> methods.","pos":[5340,5614],"source":"When creating a <xref:System.Windows.DependencyProperty>, you have the option of setting the <xref:System.Windows.PropertyMetadata> using either the <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> methods."},{"content":"Although your object could have a static constructor to call <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, this is not the optimal solution and will impact performance.","pos":[5615,5799],"source":" Although your object could have a static constructor to call <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, this is not the optimal solution and will impact performance."},{"content":"For best performance, set the <ph id=\"ph1\">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> during the call to <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>.","pos":[5800,5941],"source":" For best performance, set the <xref:System.Windows.PropertyMetadata> during the call to <xref:System.Windows.DependencyProperty.Register%2A>."},{"pos":[5986,6003],"content":"Freezable Objects","linkify":"Freezable Objects","nodes":[{"content":"Freezable Objects","pos":[0,17]}]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> is a special type of object that has two states: unfrozen and frozen.","pos":[6007,6110],"source":"A <xref:System.Windows.Freezable> is a special type of object that has two states: unfrozen and frozen."},{"content":"Freezing objects whenever possible improves the performance of your application and reduces its working set.","pos":[6111,6219]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Freezable Objects Overview<ept id=\"p1\">](freezable-objects-overview.md)</ept>.","pos":[6220,6306],"source":" For more information, see [Freezable Objects Overview](freezable-objects-overview.md)."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> has a <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event that is raised whenever it changes.","pos":[6313,6437],"source":"Each <xref:System.Windows.Freezable> has a <xref:System.Windows.Freezable.Changed> event that is raised whenever it changes."},{"content":"However, change notifications are costly in terms of application performance.","pos":[6438,6515]},{"pos":[6522,6661],"content":"Consider the following example in which each <ph id=\"ph1\">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph> uses the same <ph id=\"ph2\">&lt;xref:System.Windows.Media.Brush&gt;</ph> object:","source":"Consider the following example in which each <xref:System.Windows.Shapes.Rectangle> uses the same <xref:System.Windows.Media.Brush> object:"},{"content":"By default, <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> provides an event handler for the <ph id=\"ph2\">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph> object's <ph id=\"ph3\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event in order to invalidate the <ph id=\"ph4\">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph> object's <ph id=\"ph5\">&lt;xref:System.Windows.Shapes.Shape.Fill%2A&gt;</ph> property.","pos":[6973,7327],"source":"By default, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides an event handler for the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event in order to invalidate the <xref:System.Windows.Shapes.Rectangle> object's <xref:System.Windows.Shapes.Shape.Fill%2A> property."},{"content":"In this case, each time the <ph id=\"ph1\">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph> has to fire its <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event it is required to invoke the callback function for each <ph id=\"ph3\">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph>â€”the accumulation of these callback function invocations impose a significant performance penalty.","pos":[7328,7654],"source":" In this case, each time the <xref:System.Windows.Media.SolidColorBrush> has to fire its <xref:System.Windows.Freezable.Changed> event it is required to invoke the callback function for each <xref:System.Windows.Shapes.Rectangle>â€”the accumulation of these callback function invocations impose a significant performance penalty."},{"content":"In addition, it is very performance intensive to add and remove handlers at this point since the application would have to traverse the entire list to do so.","pos":[7655,7812]},{"content":"If your application scenario never changes the <ph id=\"ph1\">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph>, you will be paying the cost of maintaining <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event handlers unnecessarily.","pos":[7813,8017],"source":" If your application scenario never changes the <xref:System.Windows.Media.SolidColorBrush>, you will be paying the cost of maintaining <xref:System.Windows.Freezable.Changed> event handlers unnecessarily."},{"content":"Freezing a <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> can improve its performance, because it no longer needs to expend resources on maintaining change notifications.","pos":[8024,8179],"source":"Freezing a <xref:System.Windows.Freezable> can improve its performance, because it no longer needs to expend resources on maintaining change notifications."},{"content":"The table below shows the size of a simple <ph id=\"ph1\">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph> when its <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.IsFrozen%2A&gt;</ph> property is set to <ph id=\"ph3\">`true`</ph>, compared to when it is not.","pos":[8180,8374],"source":" The table below shows the size of a simple <xref:System.Windows.Media.SolidColorBrush> when its <xref:System.Windows.Freezable.IsFrozen%2A> property is set to `true`, compared to when it is not."},{"content":"This assumes applying one brush to the <ph id=\"ph1\">&lt;xref:System.Windows.Shapes.Shape.Fill%2A&gt;</ph> property of ten <ph id=\"ph2\">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph> objects.","pos":[8375,8520],"source":" This assumes applying one brush to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of ten <xref:System.Windows.Shapes.Rectangle> objects."},{"pos":[8527,8536],"content":"<bpt id=\"p1\">**</bpt>State<ept id=\"p1\">**</ept>","source":"**State**"},{"pos":[8537,8545],"content":"<bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept>","source":"**Size**"},{"pos":[8585,8635],"content":"Frozen <ph id=\"ph1\">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph>","source":"Frozen <xref:System.Windows.Media.SolidColorBrush>"},{"content":"212 Bytes","pos":[8636,8645]},{"pos":[8650,8704],"content":"Non-frozen <ph id=\"ph1\">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph>","source":"Non-frozen <xref:System.Windows.Media.SolidColorBrush>"},{"content":"972 Bytes","pos":[8705,8714]},{"content":"The following code sample demonstrates this concept:","pos":[8722,8774]},{"pos":[9089,9151],"content":"Changed Handlers on Unfrozen Freezables may Keep Objects Alive","linkify":"Changed Handlers on Unfrozen Freezables may Keep Objects Alive","nodes":[{"content":"Changed Handlers on Unfrozen Freezables may Keep Objects Alive","pos":[0,62]}]},{"content":"The delegate that an object passes to a <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> object's <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event is effectively a reference to that object.","pos":[9155,9324],"source":"The delegate that an object passes to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event is effectively a reference to that object."},{"content":"Therefore, <ph id=\"ph1\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event handlers can keep objects alive longer than expected.","pos":[9325,9435],"source":" Therefore, <xref:System.Windows.Freezable.Changed> event handlers can keep objects alive longer than expected."},{"content":"When performing clean up of an object that has registered to listen to a <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> object's <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event, it is essential to remove that delegate before releasing the object.","pos":[9436,9665],"source":" When performing clean up of an object that has registered to listen to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event, it is essential to remove that delegate before releasing the object."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> also hooks up <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> events internally.","pos":[9672,9826],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] also hooks up <xref:System.Windows.Freezable.Changed> events internally."},{"content":"For example, all dependency properties which take <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> as a value will listen to <ph id=\"ph2\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> events automatically.","pos":[9827,9996],"source":" For example, all dependency properties which take <xref:System.Windows.Freezable> as a value will listen to <xref:System.Windows.Freezable.Changed> events automatically."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Shapes.Shape.Fill%2A&gt;</ph> property, which takes a <ph id=\"ph2\">&lt;xref:System.Windows.Media.Brush&gt;</ph>, illustrates this concept.","pos":[9997,10128],"source":" The <xref:System.Windows.Shapes.Shape.Fill%2A> property, which takes a <xref:System.Windows.Media.Brush>, illustrates this concept."},{"content":"On the assignment of <ph id=\"ph1\">`myBrush`</ph> to <ph id=\"ph2\">`myRectangle.Fill`</ph>, a delegate pointing back to the <ph id=\"ph3\">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph> object will be added to the <ph id=\"ph4\">&lt;xref:System.Windows.Media.SolidColorBrush&gt;</ph> object's <ph id=\"ph5\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event.","pos":[10440,10692],"source":"On the assignment of `myBrush` to `myRectangle.Fill`, a delegate pointing back to the <xref:System.Windows.Shapes.Rectangle> object will be added to the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event."},{"content":"This means the following code does not actually make <ph id=\"ph1\">`myRect`</ph> eligible for garbage collection:","pos":[10693,10787],"source":" This means the following code does not actually make `myRect` eligible for garbage collection:"},{"content":"In this case <ph id=\"ph1\">`myBrush`</ph> is still keeping <ph id=\"ph2\">`myRectangle`</ph> alive and will call back to it when it fires its <ph id=\"ph3\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event.","pos":[11099,11248],"source":"In this case `myBrush` is still keeping `myRectangle` alive and will call back to it when it fires its <xref:System.Windows.Freezable.Changed> event."},{"content":"Note that assigning <ph id=\"ph1\">`myBrush`</ph> to the <ph id=\"ph2\">&lt;xref:System.Windows.Shapes.Shape.Fill%2A&gt;</ph> property of a new <ph id=\"ph3\">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph> will simply add another event handler to <ph id=\"ph4\">`myBrush`</ph>.","pos":[11249,11437],"source":" Note that assigning `myBrush` to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of a new <xref:System.Windows.Shapes.Rectangle> will simply add another event handler to `myBrush`."},{"pos":[11444,11696],"content":"The recommended way to clean up these types of objects is to remove the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Brush&gt;</ph> from the <ph id=\"ph2\">&lt;xref:System.Windows.Shapes.Shape.Fill%2A&gt;</ph> property, which will in turn remove the <ph id=\"ph3\">&lt;xref:System.Windows.Freezable.Changed&gt;</ph> event handler.","source":"The recommended way to clean up these types of objects is to remove the <xref:System.Windows.Media.Brush> from the <xref:System.Windows.Shapes.Shape.Fill%2A> property, which will in turn remove the <xref:System.Windows.Freezable.Changed> event handler."},{"pos":[12058,12087],"content":"User Interface Virtualization","linkify":"User Interface Virtualization","nodes":[{"content":"User Interface Virtualization","pos":[0,29]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> also provides a variation of the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> element that automatically \"virtualizes\" data-bound child content.","pos":[12091,12314],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] also provides a variation of the <xref:System.Windows.Controls.StackPanel> element that automatically \"virtualizes\" data-bound child content."},{"content":"In this context, the word virtualize refers to a technique by which a subset of objects are generated from a larger number of data items based upon which items are visible on-screen.","pos":[12315,12497]},{"content":"It is intensive, both in terms of memory and processor, to generate a large number of UI elements when only a few may be on the screen at a given time.","pos":[12498,12649]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Controls.VirtualizingStackPanel&gt;</ph> (through functionality provided by <ph id=\"ph2\">&lt;xref:System.Windows.Controls.VirtualizingPanel&gt;</ph>) calculates visible items and works with the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ItemContainerGenerator&gt;</ph> from an <ph id=\"ph4\">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> (such as <ph id=\"ph5\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> or <ph id=\"ph6\">&lt;xref:System.Windows.Controls.ListView&gt;</ph>) to only create elements for visible items.","pos":[12650,13073],"source":"<xref:System.Windows.Controls.VirtualizingStackPanel> (through functionality provided by <xref:System.Windows.Controls.VirtualizingPanel>) calculates visible items and works with the <xref:System.Windows.Controls.ItemContainerGenerator> from an <xref:System.Windows.Controls.ItemsControl> (such as <xref:System.Windows.Controls.ListBox> or <xref:System.Windows.Controls.ListView>) to only create elements for visible items."},{"content":"As a performance optimization, visual objects for these items are only generated or kept alive if they are visible on the screen.","pos":[13080,13209]},{"content":"When they are no longer in the viewable area of the control, the visual objects may be removed.","pos":[13210,13305]},{"content":"This is not to be confused with data virtualization, where data objects are not all present in the local collection- rather streamed in as needed.","pos":[13306,13452]},{"content":"The table below shows the elapsed time adding and rendering 5000 <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> elements to a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> and a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.VirtualizingStackPanel&gt;</ph>.","pos":[13459,13681],"source":"The table below shows the elapsed time adding and rendering 5000 <xref:System.Windows.Controls.TextBlock> elements to a <xref:System.Windows.Controls.StackPanel> and a <xref:System.Windows.Controls.VirtualizingStackPanel>."},{"content":"In this scenario, the measurements represent the time between attaching a text string to the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ItemsControl.ItemsSource%2A&gt;</ph> property of an <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> object to the time when the panel elements display the text string.","pos":[13682,13960],"source":" In this scenario, the measurements represent the time between attaching a text string to the <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> property of an <xref:System.Windows.Controls.ItemsControl> object to the time when the panel elements display the text string."},{"pos":[13967,13981],"content":"<bpt id=\"p1\">**</bpt>Host panel<ept id=\"p1\">**</ept>","source":"**Host panel**"},{"pos":[13982,14002],"content":"<bpt id=\"p1\">**</bpt>Render time (ms)<ept id=\"p1\">**</ept>","source":"**Render time (ms)**"},{"content":"3210","pos":[14103,14107]},{"content":"46","pos":[14166,14168]},{"pos":[14178,14186],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[14190,14273],"content":"<bpt id=\"p1\">[</bpt>Optimizing WPF Application Performance<ept id=\"p1\">](optimizing-wpf-application-performance.md)</ept>","source":"[Optimizing WPF Application Performance](optimizing-wpf-application-performance.md)"},{"pos":[14276,14355],"content":"<bpt id=\"p1\">[</bpt>Planning for Application Performance<ept id=\"p1\">](planning-for-application-performance.md)</ept>","source":"[Planning for Application Performance](planning-for-application-performance.md)"},{"pos":[14358,14444],"content":"<bpt id=\"p1\">[</bpt>Taking Advantage of Hardware<ept id=\"p1\">](optimizing-performance-taking-advantage-of-hardware.md)</ept>","source":"[Taking Advantage of Hardware](optimizing-performance-taking-advantage-of-hardware.md)"},{"pos":[14447,14511],"content":"<bpt id=\"p1\">[</bpt>Layout and Design<ept id=\"p1\">](optimizing-performance-layout-and-design.md)</ept>","source":"[Layout and Design](optimizing-performance-layout-and-design.md)"},{"pos":[14514,14590],"content":"<bpt id=\"p1\">[</bpt>2D Graphics and Imaging<ept id=\"p1\">](optimizing-performance-2d-graphics-and-imaging.md)</ept>","source":"[2D Graphics and Imaging](optimizing-performance-2d-graphics-and-imaging.md)"},{"pos":[14593,14665],"content":"<bpt id=\"p1\">[</bpt>Application Resources<ept id=\"p1\">](optimizing-performance-application-resources.md)</ept>","source":"[Application Resources](optimizing-performance-application-resources.md)"},{"pos":[14668,14706],"content":"<bpt id=\"p1\">[</bpt>Text<ept id=\"p1\">](optimizing-performance-text.md)</ept>","source":"[Text](optimizing-performance-text.md)"},{"pos":[14709,14763],"content":"<bpt id=\"p1\">[</bpt>Data Binding<ept id=\"p1\">](optimizing-performance-data-binding.md)</ept>","source":"[Data Binding](optimizing-performance-data-binding.md)"},{"pos":[14766,14850],"content":"<bpt id=\"p1\">[</bpt>Other Performance Recommendations<ept id=\"p1\">](optimizing-performance-other-recommendations.md)</ept>","source":"[Other Performance Recommendations](optimizing-performance-other-recommendations.md)"}]}