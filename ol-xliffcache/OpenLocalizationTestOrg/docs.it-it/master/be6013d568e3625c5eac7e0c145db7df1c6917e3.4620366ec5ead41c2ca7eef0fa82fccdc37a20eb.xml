{"content":"---\ntitle: \"Custom lifetime\"\nms.date: \"08/20/2018\"\nms.assetid: 52806c07-b91c-48fe-b992-88a41924f51f\n---\n# Custom lifetime\n\nThis sample demonstrates how to write a Windows Communication Foundation (WCF) extension to provide custom lifetime services for shared WCF service instances.\n\n> [!NOTE]\n> The setup procedure and build instructions for this sample are located at the end of this article.\n\n## Shared instancing\n\nWCF offers several instancing modes for your service instances. The shared instancing mode covered in this article provides a way to share a service instance between multiple channels. Clients can contact a factory method in the service and create a new channel to start communication. The following code snippet shows how a client application creates a new channel to an existing service instance:\n\n```csharp\n// Create a header for the shared instance id\nMessageHeader shareableInstanceContextHeader = MessageHeader.CreateHeader(\n        CustomHeader.HeaderName,\n        CustomHeader.HeaderNamespace,\n        Guid.NewGuid().ToString());\n\n// Create the channel factory\nChannelFactory<IEchoService> channelFactory =\n    new ChannelFactory<IEchoService>(\"echoservice\");\n\n// Create the first channel\nIEchoService proxy = channelFactory.CreateChannel();\n\n// Call an operation to create shared service instance\nusing (new OperationContextScope((IClientChannel)proxy))\n{\n    OperationContext.Current.OutgoingMessageHeaders.Add(shareableInstanceContextHeader);\n    Console.WriteLine(\"Service returned: \" + proxy.Echo(\"Apple\"));\n}\n\n((IChannel)proxy).Close();\n\n// Create the second channel\nIEchoService proxy2 = channelFactory.CreateChannel();\n\n// Call an operation using the same header that will reuse the shared service instance\nusing (new OperationContextScope((IClientChannel)proxy2))\n{\n    OperationContext.Current.OutgoingMessageHeaders.Add(shareableInstanceContextHeader);\n    Console.WriteLine(\"Service returned: \" + proxy2.Echo(\"Apple\"));\n}\n```\n\nUnlike other instancing modes, the shared instancing mode has a unique way of releasing the service instances. By default, when all the channels are closed for an <xref:System.ServiceModel.InstanceContext>, the WCF service runtime checks to see if the service <xref:System.ServiceModel.InstanceContextMode> is configured to <xref:System.ServiceModel.InstanceContextMode.PerCall> or <xref:System.ServiceModel.InstanceContextMode.PerSession>, and if so releases the instance and claims the resources. If a custom <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> is being used, WCF invokes the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method of the provider implementation before releasing the instance. If <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> returns `true` the instance is released, otherwise the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation is responsible for notifying the `Dispatcher` of the idle state by using a callback method. This is done by calling the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A> method of the provider.\n\nThis sample demonstrates how you can delay releasing the <xref:System.ServiceModel.InstanceContext> with an idle timeout of 20 seconds.\n\n## Extending the InstanceContext\n\nIn WCF, <xref:System.ServiceModel.InstanceContext> is the link between the service instance and the `Dispatcher`. WCF allows you to extend this runtime component by adding new state or behavior by using its extensible object pattern. The extensible object pattern is used in WCF to either extend existing runtime classes with new functionality or to add new state features to an object. There are three interfaces in the extensible object pattern: <xref:System.ServiceModel.IExtensibleObject%601>, <xref:System.ServiceModel.IExtension%601>, and <xref:System.ServiceModel.IExtensionCollection%601>.\n\nThe <xref:System.ServiceModel.IExtensibleObject%601> interface is implemented by objects to allow extensions that customize their functionality.\n\nThe <xref:System.ServiceModel.IExtension%601> interface is implemented by objects that can be extensions of classes of type `T`.\n\nAnd finally, the <xref:System.ServiceModel.IExtensionCollection%601> interface is a collection of <xref:System.ServiceModel.IExtension%601> implementations that allows for retrieving an implementation of <xref:System.ServiceModel.IExtension%601> by their type.\n\nTherefore, in order to extend the <xref:System.ServiceModel.InstanceContext>, you must implement the <xref:System.ServiceModel.IExtension%601> interface. In this sample project, the `CustomLeaseExtension` class contains this implementation.\n\n```csharp\nclass CustomLeaseExtension : IExtension<InstanceContext>\n{\n}\n```\n\nThe <xref:System.ServiceModel.IExtension%601> interface has two methods <xref:System.ServiceModel.IExtension%601.Attach%2A> and <xref:System.ServiceModel.IExtension%601.Detach%2A>. As their names imply, these two methods are called when the runtime attaches and detaches the extension to an instance of the <xref:System.ServiceModel.InstanceContext> class. In this sample, the `Attach` method is used to keep track of the <xref:System.ServiceModel.InstanceContext> object that belongs to the current instance of the extension.\n\n```csharp\nInstanceContext owner;\n\npublic void Attach(InstanceContext owner)\n{\n    this.owner = owner;\n}\n```\n\nIn addition, you must add the necessary implementation to the extension to provide the extended lifetime support. Therefore, the `ICustomLease` interface is declared with the desired methods and is implemented in the `CustomLeaseExtension` class.\n\n```csharp\ninterface ICustomLease\n{\n    bool IsIdle { get; }\n    InstanceContextIdleCallback Callback { get; set; }\n}\n\nclass CustomLeaseExtension : IExtension<InstanceContext>, ICustomLease\n{\n}\n```\n\nWhen WCF invokes the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method in the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation, this call is routed to the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method of the `CustomLeaseExtension`. Then, the `CustomLeaseExtension` checks its private state to see whether the <xref:System.ServiceModel.InstanceContext> is idle. If it is idle, it returns `true`. Otherwise, it starts a timer for a specified amount of extended lifetime.\n\n```csharp\npublic bool IsIdle\n{\n  get\n  {\n    lock (thisLock)\n    {\n      if (isIdle)\n      {\n        return true;\n      }\n      else\n      {\n        StartTimer();\n        return false;\n      }\n    }\n  }\n}\n```\n\nIn the timer’s `Elapsed` event, the callback function in the Dispatcher is called in order to start another clean-up cycle.\n\n```csharp\nvoid idleTimer_Elapsed(object sender, ElapsedEventArgs args)\n{\n    lock (thisLock)\n    {\n        StopTimer();\n        isIdle = true;\n        Utility.WriteMessageToConsole(\n            ResourceHelper.GetString(\"MsgLeaseExpired\"));\n        callback(owner);\n    }\n}\n```\n\nThere's no way to renew the running timer when a new message arrives for the instance being moved to the idle state.\n\nThe sample implements <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> to intercept the calls to the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method and route them to the `CustomLeaseExtension`. The <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation is contained in `CustomLifetimeLease` class. The <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method is invoked when WCF is about to release the service instance. However, there is only one instance of a particular `ISharedSessionInstance` implementation in the ServiceBehavior’s <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> collection. This means there's no way of knowing if the <xref:System.ServiceModel.InstanceContext> is closed at the time WCF checks the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method. Therefore, this sample uses thread locking to serialize requests to the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method.\n\n> [!IMPORTANT]\n> Using thread locking is not a recommended approach because serialization can severely affect the performance of your application.\n\nA private member field is used in the `CustomLifetimeLease` class to track the idle state and is returned by the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method. Each time the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method is called, the `isIdle` field is returned and reset to `false`.  It is essential to set this value to `false` in order to make sure the Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A> method.\n\n```csharp\npublic bool IsIdle(InstanceContext instanceContext)\n{\n    get\n    {\n        lock (thisLock)\n        {\n            //...\n            bool idleCopy = isIdle;\n            isIdle = false;\n            return idleCopy;\n        }\n    }\n}\n```\n\nIf the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A?displayProperty=nameWithType> method returns `false`, the Dispatcher registers a callback function by using the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A> method. This method receives a reference to the <xref:System.ServiceModel.InstanceContext> being released. Therefore, the sample code can query the `ICustomLease` type extension and check the `ICustomLease.IsIdle` property in the extended state.\n\n```csharp\npublic void NotifyIdle(InstanceContextIdleCallback callback,\n            InstanceContext instanceContext)\n{\n    lock (thisLock)\n    {\n       ICustomLease customLease =\n           instanceContext.Extensions.Find<ICustomLease>();\n       customLease.Callback = callback;\n       isIdle = customLease.IsIdle;\n       if (isIdle)\n       {\n             callback(instanceContext);\n       }\n    }\n}\n```\n\nBefore the `ICustomLease.IsIdle` property is checked, the Callback property needs to be set as this is essential for `CustomLeaseExtension` to notify the Dispatcher when it becomes idle. If `ICustomLease.IsIdle` returns `true`, the `isIdle` private member is simply set in `CustomLifetimeLease` to `true` and calls the callback method. Because the code holds a lock, other threads can't change the value of this private member. And the next time Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A?displayProperty=nameWithType>, it returns `true` and lets Dispatcher release the instance.\n\nNow that the groundwork for the custom extension is completed, it has to be hooked up to the service model. To hook up the `CustomLeaseExtension` implementation to the <xref:System.ServiceModel.InstanceContext>, WCF provides the <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer> interface to perform the bootstrapping of <xref:System.ServiceModel.InstanceContext>. In the sample, the `CustomLeaseInitializer` class implements this interface and adds an instance of `CustomLeaseExtension` to the <xref:System.ServiceModel.InstanceContext.Extensions%2A> collection from the only method initialization. This method is called by Dispatcher while initializing the <xref:System.ServiceModel.InstanceContext>.\n\n```csharp\npublic void InitializeInstanceContext(InstanceContext instanceContext,\n    System.ServiceModel.Channels.Message message, IContextChannel channel)\n\n    //...\n\n    IExtension<InstanceContext> customLeaseExtension =\n        new CustomLeaseExtension(timeout, headerId);\n    instanceContext.Extensions.Add(customLeaseExtension);\n}\n```\n\n Finally the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation is hooked up to the service model by using the <xref:System.ServiceModel.Description.IServiceBehavior> implementation. This implementation is placed in the `CustomLeaseTimeAttribute` class and it also derives from the <xref:System.Attribute> base class to expose this behavior as an attribute.\n\n```csharp\npublic void ApplyDispatchBehavior(ServiceDescription description,\n           ServiceHostBase serviceHostBase)\n{\n    CustomLifetimeLease customLease = new CustomLifetimeLease(timeout);\n\n    foreach (ChannelDispatcherBase cdb in serviceHostBase.ChannelDispatchers)\n    {\n        ChannelDispatcher cd = cdb as ChannelDispatcher;\n\n        if (cd != null)\n        {\n            foreach (EndpointDispatcher ed in cd.Endpoints)\n            {\n                ed.DispatchRuntime.InstanceContextProvider = customLease;\n            }\n        }\n    }\n}\n```\n\nThis behavior can be added to a sample service class by annotating it with the `CustomLeaseTime` attribute.\n\n```csharp\n[CustomLeaseTime(Timeout = 20000)]\npublic class EchoService : IEchoService\n{\n  //…\n}\n```\n\nWhen you run the sample, the operation requests and responses are displayed in both the service and client console windows. Press ENTER in each console window to shut down the service and client.\n\n### To set up, build, and run the sample\n\n1. Ensure that you've performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](one-time-setup-procedure-for-the-wcf-samples.md).\n\n2. To build the C# or Visual Basic .NET edition of the solution, follow the instructions in [Building the Windows Communication Foundation Samples](building-the-samples.md).\n\n3. To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](running-the-samples.md).\n\n> [!IMPORTANT]\n> The samples may already be installed on your machine. Check for the following (default) directory before continuing.\n>\n> `<InstallDrive>:\\WF_WCF_Samples`\n>\n> If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.\n>\n> `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Instancing\\Lifetime`\n","nodes":[{"pos":[4,99],"embed":true,"restype":"x-metadata","content":"title: \"Custom lifetime\"\nms.date: \"08/20/2018\"\nms.assetid: 52806c07-b91c-48fe-b992-88a41924f51f","nodes":[{"content":"Custom lifetime","nodes":[{"pos":[0,15],"content":"Custom lifetime","nodes":[{"content":"Custom lifetime","pos":[0,15]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[106,121],"content":"Custom lifetime","linkify":"Custom lifetime","nodes":[{"content":"Custom lifetime","pos":[0,15]}]},{"content":"This sample demonstrates how to write a Windows Communication Foundation (WCF) extension to provide custom lifetime services for shared WCF service instances.","pos":[123,281]},{"pos":[285,393],"content":"[!NOTE]\nThe setup procedure and build instructions for this sample are located at the end of this article.","leadings":["","> "],"nodes":[{"content":"The setup procedure and build instructions for this sample are located at the end of this article.","pos":[8,106]}]},{"pos":[398,415],"content":"Shared instancing","linkify":"Shared instancing","nodes":[{"content":"Shared instancing","pos":[0,17]}]},{"content":"WCF offers several instancing modes for your service instances.","pos":[417,480]},{"content":"The shared instancing mode covered in this article provides a way to share a service instance between multiple channels.","pos":[481,601]},{"content":"Clients can contact a factory method in the service and create a new channel to start communication.","pos":[602,702]},{"content":"The following code snippet shows how a client application creates a new channel to an existing service instance:","pos":[703,815]},{"content":"Unlike other instancing modes, the shared instancing mode has a unique way of releasing the service instances.","pos":[1964,2074]},{"content":"By default, when all the channels are closed for an <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph>, the WCF service runtime checks to see if the service <ph id=\"ph2\">&lt;xref:System.ServiceModel.InstanceContextMode&gt;</ph> is configured to <ph id=\"ph3\">&lt;xref:System.ServiceModel.InstanceContextMode.PerCall&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.ServiceModel.InstanceContextMode.PerSession&gt;</ph>, and if so releases the instance and claims the resources.","pos":[2075,2462],"source":" By default, when all the channels are closed for an <xref:System.ServiceModel.InstanceContext>, the WCF service runtime checks to see if the service <xref:System.ServiceModel.InstanceContextMode> is configured to <xref:System.ServiceModel.InstanceContextMode.PerCall> or <xref:System.ServiceModel.InstanceContextMode.PerSession>, and if so releases the instance and claims the resources."},{"content":"If a custom <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider&gt;</ph> is being used, WCF invokes the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method of the provider implementation before releasing the instance.","pos":[2463,2710],"source":" If a custom <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> is being used, WCF invokes the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method of the provider implementation before releasing the instance."},{"content":"If <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> returns <ph id=\"ph2\">`true`</ph> the instance is released, otherwise the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider&gt;</ph> implementation is responsible for notifying the <ph id=\"ph4\">`Dispatcher`</ph> of the idle state by using a callback method.","pos":[2711,3011],"source":" If <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> returns `true` the instance is released, otherwise the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation is responsible for notifying the `Dispatcher` of the idle state by using a callback method."},{"content":"This is done by calling the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A&gt;</ph> method of the provider.","pos":[3012,3140],"source":" This is done by calling the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A> method of the provider."},{"pos":[3142,3277],"content":"This sample demonstrates how you can delay releasing the <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph> with an idle timeout of 20 seconds.","source":"This sample demonstrates how you can delay releasing the <xref:System.ServiceModel.InstanceContext> with an idle timeout of 20 seconds."},{"pos":[3282,3311],"content":"Extending the InstanceContext","linkify":"Extending the InstanceContext","nodes":[{"content":"Extending the InstanceContext","pos":[0,29]}]},{"content":"In WCF, <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph> is the link between the service instance and the <ph id=\"ph2\">`Dispatcher`</ph>.","pos":[3313,3426],"source":"In WCF, <xref:System.ServiceModel.InstanceContext> is the link between the service instance and the `Dispatcher`."},{"content":"WCF allows you to extend this runtime component by adding new state or behavior by using its extensible object pattern.","pos":[3427,3546]},{"content":"The extensible object pattern is used in WCF to either extend existing runtime classes with new functionality or to add new state features to an object.","pos":[3547,3699]},{"content":"There are three interfaces in the extensible object pattern: <ph id=\"ph1\">&lt;xref:System.ServiceModel.IExtensibleObject%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.IExtension%601&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.IExtensionCollection%601&gt;</ph>.","pos":[3700,3910],"source":" There are three interfaces in the extensible object pattern: <xref:System.ServiceModel.IExtensibleObject%601>, <xref:System.ServiceModel.IExtension%601>, and <xref:System.ServiceModel.IExtensionCollection%601>."},{"pos":[3912,4056],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.IExtensibleObject%601&gt;</ph> interface is implemented by objects to allow extensions that customize their functionality.","source":"The <xref:System.ServiceModel.IExtensibleObject%601> interface is implemented by objects to allow extensions that customize their functionality."},{"pos":[4058,4186],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.IExtension%601&gt;</ph> interface is implemented by objects that can be extensions of classes of type <ph id=\"ph2\">`T`</ph>.","source":"The <xref:System.ServiceModel.IExtension%601> interface is implemented by objects that can be extensions of classes of type `T`."},{"pos":[4188,4448],"content":"And finally, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.IExtensionCollection%601&gt;</ph> interface is a collection of <ph id=\"ph2\">&lt;xref:System.ServiceModel.IExtension%601&gt;</ph> implementations that allows for retrieving an implementation of <ph id=\"ph3\">&lt;xref:System.ServiceModel.IExtension%601&gt;</ph> by their type.","source":"And finally, the <xref:System.ServiceModel.IExtensionCollection%601> interface is a collection of <xref:System.ServiceModel.IExtension%601> implementations that allows for retrieving an implementation of <xref:System.ServiceModel.IExtension%601> by their type."},{"content":"Therefore, in order to extend the <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph>, you must implement the <ph id=\"ph2\">&lt;xref:System.ServiceModel.IExtension%601&gt;</ph> interface.","pos":[4450,4603],"source":"Therefore, in order to extend the <xref:System.ServiceModel.InstanceContext>, you must implement the <xref:System.ServiceModel.IExtension%601> interface."},{"content":"In this sample project, the <ph id=\"ph1\">`CustomLeaseExtension`</ph> class contains this implementation.","pos":[4604,4690],"source":" In this sample project, the `CustomLeaseExtension` class contains this implementation."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.IExtension%601&gt;</ph> interface has two methods <ph id=\"ph2\">&lt;xref:System.ServiceModel.IExtension%601.Attach%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.ServiceModel.IExtension%601.Detach%2A&gt;</ph>.","pos":[4768,4948],"source":"The <xref:System.ServiceModel.IExtension%601> interface has two methods <xref:System.ServiceModel.IExtension%601.Attach%2A> and <xref:System.ServiceModel.IExtension%601.Detach%2A>."},{"content":"As their names imply, these two methods are called when the runtime attaches and detaches the extension to an instance of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph> class.","pos":[4949,5124],"source":" As their names imply, these two methods are called when the runtime attaches and detaches the extension to an instance of the <xref:System.ServiceModel.InstanceContext> class."},{"content":"In this sample, the <ph id=\"ph1\">`Attach`</ph> method is used to keep track of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph> object that belongs to the current instance of the extension.","pos":[5125,5294],"source":" In this sample, the `Attach` method is used to keep track of the <xref:System.ServiceModel.InstanceContext> object that belongs to the current instance of the extension."},{"content":"In addition, you must add the necessary implementation to the extension to provide the extended lifetime support.","pos":[5405,5518]},{"content":"Therefore, the <ph id=\"ph1\">`ICustomLease`</ph> interface is declared with the desired methods and is implemented in the <ph id=\"ph2\">`CustomLeaseExtension`</ph> class.","pos":[5519,5651],"source":" Therefore, the `ICustomLease` interface is declared with the desired methods and is implemented in the `CustomLeaseExtension` class."},{"content":"When WCF invokes the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method in the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider&gt;</ph> implementation, this call is routed to the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method of the <ph id=\"ph4\">`CustomLeaseExtension`</ph>.","pos":[5851,6175],"source":"When WCF invokes the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method in the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation, this call is routed to the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method of the `CustomLeaseExtension`."},{"content":"Then, the <ph id=\"ph1\">`CustomLeaseExtension`</ph> checks its private state to see whether the <ph id=\"ph2\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph> is idle.","pos":[6176,6304],"source":" Then, the `CustomLeaseExtension` checks its private state to see whether the <xref:System.ServiceModel.InstanceContext> is idle."},{"content":"If it is idle, it returns <ph id=\"ph1\">`true`</ph>.","pos":[6305,6338],"source":" If it is idle, it returns `true`."},{"content":"Otherwise, it starts a timer for a specified amount of extended lifetime.","pos":[6339,6412]},{"pos":[6624,6747],"content":"In the timer’s <ph id=\"ph1\">`Elapsed`</ph> event, the callback function in the Dispatcher is called in order to start another clean-up cycle.","source":"In the timer’s `Elapsed` event, the callback function in the Dispatcher is called in order to start another clean-up cycle."},{"content":"There's no way to renew the running timer when a new message arrives for the instance being moved to the idle state.","pos":[7027,7143]},{"content":"The sample implements <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider&gt;</ph> to intercept the calls to the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method and route them to the <ph id=\"ph3\">`CustomLeaseExtension`</ph>.","pos":[7145,7385],"source":"The sample implements <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> to intercept the calls to the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method and route them to the `CustomLeaseExtension`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider&gt;</ph> implementation is contained in <ph id=\"ph2\">`CustomLifetimeLease`</ph> class.","pos":[7386,7512],"source":" The <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation is contained in `CustomLifetimeLease` class."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method is invoked when WCF is about to release the service instance.","pos":[7513,7658],"source":" The <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method is invoked when WCF is about to release the service instance."},{"content":"However, there is only one instance of a particular <ph id=\"ph1\">`ISharedSessionInstance`</ph> implementation in the ServiceBehavior’s <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider&gt;</ph> collection.","pos":[7659,7850],"source":" However, there is only one instance of a particular `ISharedSessionInstance` implementation in the ServiceBehavior’s <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> collection."},{"content":"This means there's no way of knowing if the <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph> is closed at the time WCF checks the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method.","pos":[7851,8055],"source":" This means there's no way of knowing if the <xref:System.ServiceModel.InstanceContext> is closed at the time WCF checks the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method."},{"content":"Therefore, this sample uses thread locking to serialize requests to the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method.","pos":[8056,8208],"source":" Therefore, this sample uses thread locking to serialize requests to the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method."},{"pos":[8212,8356],"content":"[!IMPORTANT]\nUsing thread locking is not a recommended approach because serialization can severely affect the performance of your application.","leadings":["","> "],"nodes":[{"content":"Using thread locking is not a recommended approach because serialization can severely affect the performance of your application.","pos":[13,142]}]},{"content":"A private member field is used in the <ph id=\"ph1\">`CustomLifetimeLease`</ph> class to track the idle state and is returned by the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method.","pos":[8358,8551],"source":"A private member field is used in the `CustomLifetimeLease` class to track the idle state and is returned by the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method."},{"content":"Each time the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A&gt;</ph> method is called, the <ph id=\"ph2\">`isIdle`</ph> field is returned and reset to <ph id=\"ph3\">`false`</ph>.","pos":[8552,8709],"source":" Each time the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A> method is called, the `isIdle` field is returned and reset to `false`."},{"content":"It is essential to set this value to <ph id=\"ph1\">`false`</ph> in order to make sure the Dispatcher calls the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A&gt;</ph> method.","pos":[8711,8887],"source":"  It is essential to set this value to `false` in order to make sure the Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A> method."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A?displayProperty=nameWithType&gt;</ph> method returns <ph id=\"ph2\">`false`</ph>, the Dispatcher registers a callback function by using the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A&gt;</ph> method.","pos":[9135,9410],"source":"If the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A?displayProperty=nameWithType> method returns `false`, the Dispatcher registers a callback function by using the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.NotifyIdle%2A> method."},{"content":"This method receives a reference to the <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph> being released.","pos":[9411,9509],"source":" This method receives a reference to the <xref:System.ServiceModel.InstanceContext> being released."},{"content":"Therefore, the sample code can query the <ph id=\"ph1\">`ICustomLease`</ph> type extension and check the <ph id=\"ph2\">`ICustomLease.IsIdle`</ph> property in the extended state.","pos":[9510,9648],"source":" Therefore, the sample code can query the `ICustomLease` type extension and check the `ICustomLease.IsIdle` property in the extended state."},{"content":"Before the <ph id=\"ph1\">`ICustomLease.IsIdle`</ph> property is checked, the Callback property needs to be set as this is essential for <ph id=\"ph2\">`CustomLeaseExtension`</ph> to notify the Dispatcher when it becomes idle.","pos":[10054,10240],"source":"Before the `ICustomLease.IsIdle` property is checked, the Callback property needs to be set as this is essential for `CustomLeaseExtension` to notify the Dispatcher when it becomes idle."},{"content":"If <ph id=\"ph1\">`ICustomLease.IsIdle`</ph> returns <ph id=\"ph2\">`true`</ph>, the <ph id=\"ph3\">`isIdle`</ph> private member is simply set in <ph id=\"ph4\">`CustomLifetimeLease`</ph> to <ph id=\"ph5\">`true`</ph> and calls the callback method.","pos":[10241,10389],"source":" If `ICustomLease.IsIdle` returns `true`, the `isIdle` private member is simply set in `CustomLifetimeLease` to `true` and calls the callback method."},{"content":"Because the code holds a lock, other threads can't change the value of this private member.","pos":[10390,10481]},{"content":"And the next time Dispatcher calls the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A?displayProperty=nameWithType&gt;</ph>, it returns <ph id=\"ph2\">`true`</ph> and lets Dispatcher release the instance.","pos":[10482,10683],"source":" And the next time Dispatcher calls the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider.IsIdle%2A?displayProperty=nameWithType>, it returns `true` and lets Dispatcher release the instance."},{"content":"Now that the groundwork for the custom extension is completed, it has to be hooked up to the service model.","pos":[10685,10792]},{"content":"To hook up the <ph id=\"ph1\">`CustomLeaseExtension`</ph> implementation to the <ph id=\"ph2\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph>, WCF provides the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer&gt;</ph> interface to perform the bootstrapping of <ph id=\"ph4\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph>.","pos":[10793,11065],"source":" To hook up the `CustomLeaseExtension` implementation to the <xref:System.ServiceModel.InstanceContext>, WCF provides the <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer> interface to perform the bootstrapping of <xref:System.ServiceModel.InstanceContext>."},{"content":"In the sample, the <ph id=\"ph1\">`CustomLeaseInitializer`</ph> class implements this interface and adds an instance of <ph id=\"ph2\">`CustomLeaseExtension`</ph> to the <ph id=\"ph3\">&lt;xref:System.ServiceModel.InstanceContext.Extensions%2A&gt;</ph> collection from the only method initialization.","pos":[11066,11300],"source":" In the sample, the `CustomLeaseInitializer` class implements this interface and adds an instance of `CustomLeaseExtension` to the <xref:System.ServiceModel.InstanceContext.Extensions%2A> collection from the only method initialization."},{"content":"This method is called by Dispatcher while initializing the <ph id=\"ph1\">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph>.","pos":[11301,11403],"source":" This method is called by Dispatcher while initializing the <xref:System.ServiceModel.InstanceContext>."},{"content":"Finally the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInstanceContextProvider&gt;</ph> implementation is hooked up to the service model by using the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.IServiceBehavior&gt;</ph> implementation.","pos":[11747,11955],"source":"Finally the <xref:System.ServiceModel.Dispatcher.IInstanceContextProvider> implementation is hooked up to the service model by using the <xref:System.ServiceModel.Description.IServiceBehavior> implementation."},{"content":"This implementation is placed in the <ph id=\"ph1\">`CustomLeaseTimeAttribute`</ph> class and it also derives from the <ph id=\"ph2\">&lt;xref:System.Attribute&gt;</ph> base class to expose this behavior as an attribute.","pos":[11956,12130],"source":" This implementation is placed in the `CustomLeaseTimeAttribute` class and it also derives from the <xref:System.Attribute> base class to expose this behavior as an attribute."},{"pos":[12688,12795],"content":"This behavior can be added to a sample service class by annotating it with the <ph id=\"ph1\">`CustomLeaseTime`</ph> attribute.","source":"This behavior can be added to a sample service class by annotating it with the `CustomLeaseTime` attribute."},{"content":"When you run the sample, the operation requests and responses are displayed in both the service and client console windows.","pos":[12897,13020]},{"content":"Press ENTER in each console window to shut down the service and client.","pos":[13021,13092]},{"pos":[13098,13134],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[13139,13297],"content":"Ensure that you've performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you've performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[13302,13472],"content":"To build the C# or Visual Basic .NET edition of the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](building-the-samples.md)</ept>.","source":"To build the C# or Visual Basic .NET edition of the solution, follow the instructions in [Building the Windows Communication Foundation Samples](building-the-samples.md)."},{"pos":[13477,13646],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](running-the-samples.md)."},{"pos":[13650,13781],"content":"[!IMPORTANT]\nThe samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[13,129],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[0,53]},{"content":"Check for the following (default) directory before continuing.","pos":[54,116]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[13823,14133],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[14134,14184]}]}