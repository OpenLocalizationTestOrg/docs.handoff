{"content":"---\ntitle: Local functions vs. lambda expressions\ndescription: Learn why local functions might be a better choice than lambda expressions.\nms.date: 06/27/2016\nms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3\n---\n# Local functions compared to lambda expressions\n\nAt first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar. In many cases, the choice between using\nlambda expressions and local functions is a matter of style and personal\npreference. However, there are real differences in where you can use one or\nthe other that you should be aware of.\n\nLet's examine the differences between the local function and lambda expression\nimplementations of the factorial algorithm. First the version using a local function:\n\n[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial \"Recursive factorial using local function\")]\n\nContrast that implementation with a version that uses lambda expressions:\n\n[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial \"Recursive factorial using lambda expressions\")]\n\nThe local functions have names. The lambda expressions are anonymous methods\nthat are assigned to variables that are `Func` or `Action` types. When you\ndeclare a local function, the argument types and return type are part of the \nfunction declaration. Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda\nexpression's variable type declaration. Those two differences may\nresult in clearer code.\n\nLocal functions have different rules for definite assignment\nthan lambda expressions. A local function declaration can be referenced\nfrom any code location where it is in scope. A lambda expression must be\nassigned to a delegate variable before it can be accessed (or called through the delegate\nreferencing the lambda expression.) Notice that the version using the\nlambda expression must declare and initialize the lambda expression,\n`nthFactorial` before defining it. Not doing so results in a compile\ntime error for referencing `nthFactorial` before assigning it.\nThese differences mean that recursive algorithms are easier to create\nusing local functions. You can declare and define a local function that\ncalls itself. Lambda expressions must be declared, and assigned a default\nvalue before they can be re-assigned to a body that references the same\nlambda expression.\n\nDefinite assignment rules also affect any variables that are captured\nby the local function or lambda expression. Both local functions and\nlambda expression rules demand that any captured variables are definitely\nassigned at the point when the local function or lambda expression is\nconverted to a delegate. The difference is that lambda expressions are converted\nto delegates when they are declared. Local functions are converted to delegates\nonly when used as a delegate. If you declare a local function and only\nreference it by calling it like a method, it will not be converted to\na delegate. That rule enables you to declare\na local function at any convenient location in its enclosing scope. It's common\nto declare local functions at the end of the parent method, after any return\nstatements.\n\nThird, the compiler can perform static analysis that enables local functions to\ndefinitely assign captured variables in the enclosing scope. Consider this example:\n\n```csharp\nint M()\n{\n    int y;\n    LocalFunction();\n    return y;\n\n    void LocalFunction() => y = 0;\n}\n```\n\nThe compiler can determine that `LocalFunction` definitely assigns `y` when called. Because `LocalFunction` is called before the `return` statement, `y` is definitely\nassigned at the `return` statement.\n\nThe analysis that enables the example analysis enables the fourth difference.\nDepending on their use, local functions can avoid heap allocations that\nare always necessary for lambda expressions. If a local function is never\nconverted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations. \n\nConsider this async example:\n\n[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample \"Task returning method with lambda expression\")]\n\nThe closure for this lambda expression contains the `address`,\n`index` and `name` variables. In the case of local functions, the object\nthat implements the closure may be a `struct` type. That struct type would\nbe passed by reference to the local function. This difference in\nimplementation would save on\nan allocation.\n\nThe instantiation necessary for lambda expressions means extra memory\nallocations, which may be a performance factor in time-critical code paths.\nLocal functions do not incur this overhead. In the example above, the local\nfunctions version has 2 fewer allocations than the lambda expression version.\n\n> [!NOTE]\n> The local function equivalent of this method also uses a class for the closure. Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail. A local function may use a `struct` whereas a lambda will always use a `class`.\n\n[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample \"Task returning method with local function\")]\n\nOne final advantage not demonstrated in this sample is that local\nfunctions can be implemented as iterators, using the `yield return`\nsyntax to produce a sequence of values. The `yield return` statement\nis not allowed in lambda expressions.\n\nWhile local functions may seem redundant to lambda expressions,\nthey actually serve different purposes and have different uses.\nLocal functions are more efficient for the case when you want\nto write a function that is called only from the context of\nanother method.\n","nodes":[{"pos":[4,207],"embed":true,"restype":"x-metadata","content":"title: Local functions vs. lambda expressions\ndescription: Learn why local functions might be a better choice than lambda expressions.\nms.date: 06/27/2016\nms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3","nodes":[{"content":"Local functions vs. lambda expressions","nodes":[{"pos":[0,38],"content":"Local functions vs. lambda expressions","nodes":[{"content":"Local functions vs. lambda expressions","pos":[0,38]}]}],"path":["title"],"nosxs":false},{"content":"Learn why local functions might be a better choice than lambda expressions.","nodes":[{"pos":[0,75],"content":"Learn why local functions might be a better choice than lambda expressions.","nodes":[{"content":"Learn why local functions might be a better choice than lambda expressions.","pos":[0,75]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[214,260],"content":"Local functions compared to lambda expressions","linkify":"Local functions compared to lambda expressions","nodes":[{"content":"Local functions compared to lambda expressions","pos":[0,46]}]},{"content":"At first glance, <bpt id=\"p1\">[</bpt>local functions<ept id=\"p1\">](programming-guide/classes-and-structs/local-functions.md)</ept> and <bpt id=\"p2\">[</bpt>lambda expressions<ept id=\"p2\">](./programming-guide/statements-expressions-operators/lambda-expressions.md)</ept> are very similar.","pos":[262,473],"source":"At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar."},{"content":"In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.","pos":[474,598],"source":" In many cases, the choice between using\nlambda expressions and local functions is a matter of style and personal\npreference."},{"content":"However, there are real differences in where you can use one or the other that you should be aware of.","pos":[599,701],"source":" However, there are real differences in where you can use one or\nthe other that you should be aware of."},{"content":"Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.","pos":[703,825],"source":"Let's examine the differences between the local function and lambda expression\nimplementations of the factorial algorithm."},{"content":"First the version using a local function:","pos":[826,867]},{"content":"Contrast that implementation with a version that uses lambda expressions:","pos":[1035,1108]},{"content":"The local functions have names.","pos":[1269,1300]},{"content":"The lambda expressions are anonymous methods that are assigned to variables that are <ph id=\"ph1\">`Func`</ph> or <ph id=\"ph2\">`Action`</ph> types.","pos":[1301,1411],"source":" The lambda expressions are anonymous methods\nthat are assigned to variables that are `Func` or `Action` types."},{"content":"When you declare a local function, the argument types and return type are part of the function declaration.","pos":[1412,1520],"source":" When you\ndeclare a local function, the argument types and return type are part of the \nfunction declaration."},{"content":"Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.","pos":[1521,1678],"source":" Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda\nexpression's variable type declaration."},{"content":"Those two differences may result in clearer code.","pos":[1679,1728],"source":" Those two differences may\nresult in clearer code."},{"content":"Local functions have different rules for definite assignment than lambda expressions.","pos":[1730,1815],"source":"Local functions have different rules for definite assignment\nthan lambda expressions."},{"content":"A local function declaration can be referenced from any code location where it is in scope.","pos":[1816,1907],"source":" A local function declaration can be referenced\nfrom any code location where it is in scope."},{"content":"A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, <ph id=\"ph1\">`nthFactorial`</ph> before defining it.","pos":[1908,2199],"source":" A lambda expression must be\nassigned to a delegate variable before it can be accessed (or called through the delegate\nreferencing the lambda expression.) Notice that the version using the\nlambda expression must declare and initialize the lambda expression,\n`nthFactorial` before defining it."},{"content":"Not doing so results in a compile time error for referencing <ph id=\"ph1\">`nthFactorial`</ph> before assigning it.","pos":[2200,2296],"source":" Not doing so results in a compile\ntime error for referencing `nthFactorial` before assigning it."},{"content":"These differences mean that recursive algorithms are easier to create using local functions.","pos":[2297,2389],"source":"\nThese differences mean that recursive algorithms are easier to create\nusing local functions."},{"content":"You can declare and define a local function that calls itself.","pos":[2390,2452],"source":" You can declare and define a local function that\ncalls itself."},{"content":"Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.","pos":[2453,2603],"source":" Lambda expressions must be declared, and assigned a default\nvalue before they can be re-assigned to a body that references the same\nlambda expression."},{"content":"Definite assignment rules also affect any variables that are captured by the local function or lambda expression.","pos":[2605,2718],"source":"Definite assignment rules also affect any variables that are captured\nby the local function or lambda expression."},{"content":"Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.","pos":[2719,2912],"source":" Both local functions and\nlambda expression rules demand that any captured variables are definitely\nassigned at the point when the local function or lambda expression is\nconverted to a delegate."},{"content":"The difference is that lambda expressions are converted to delegates when they are declared.","pos":[2913,3005],"source":" The difference is that lambda expressions are converted\nto delegates when they are declared."},{"content":"Local functions are converted to delegates only when used as a delegate.","pos":[3006,3078],"source":" Local functions are converted to delegates\nonly when used as a delegate."},{"content":"If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.","pos":[3079,3201],"source":" If you declare a local function and only\nreference it by calling it like a method, it will not be converted to\na delegate."},{"content":"That rule enables you to declare a local function at any convenient location in its enclosing scope.","pos":[3202,3302],"source":" That rule enables you to declare\na local function at any convenient location in its enclosing scope."},{"content":"It's common to declare local functions at the end of the parent method, after any return statements.","pos":[3303,3403],"source":" It's common\nto declare local functions at the end of the parent method, after any return\nstatements."},{"content":"Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.","pos":[3405,3545],"source":"Third, the compiler can perform static analysis that enables local functions to\ndefinitely assign captured variables in the enclosing scope."},{"content":"Consider this example:","pos":[3546,3568]},{"content":"The compiler can determine that <ph id=\"ph1\">`LocalFunction`</ph> definitely assigns <ph id=\"ph2\">`y`</ph> when called.","pos":[3679,3762],"source":"The compiler can determine that `LocalFunction` definitely assigns `y` when called."},{"content":"Because <ph id=\"ph1\">`LocalFunction`</ph> is called before the <ph id=\"ph2\">`return`</ph> statement, <ph id=\"ph3\">`y`</ph> is definitely assigned at the <ph id=\"ph4\">`return`</ph> statement.","pos":[3763,3881],"source":" Because `LocalFunction` is called before the `return` statement, `y` is definitely\nassigned at the `return` statement."},{"content":"The analysis that enables the example analysis enables the fourth difference.","pos":[3883,3960]},{"content":"Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.","pos":[3961,4077],"source":"\nDepending on their use, local functions can avoid heap allocations that\nare always necessary for lambda expressions."},{"content":"If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.","pos":[4078,4310],"source":" If a local function is never\nconverted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations."},{"content":"Consider this async example:","pos":[4313,4341]},{"content":"The closure for this lambda expression contains the <ph id=\"ph1\">`address`</ph>, <ph id=\"ph2\">`index`</ph> and <ph id=\"ph3\">`name`</ph> variables.","pos":[4499,4591],"source":"The closure for this lambda expression contains the `address`,\n`index` and `name` variables."},{"content":"In the case of local functions, the object that implements the closure may be a <ph id=\"ph1\">`struct`</ph> type.","pos":[4592,4686],"source":" In the case of local functions, the object\nthat implements the closure may be a `struct` type."},{"content":"That struct type would be passed by reference to the local function.","pos":[4687,4755],"source":" That struct type would\nbe passed by reference to the local function."},{"content":"This difference in implementation would save on an allocation.","pos":[4756,4818],"source":" This difference in\nimplementation would save on\nan allocation."},{"content":"The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.","pos":[4820,4965],"source":"The instantiation necessary for lambda expressions means extra memory\nallocations, which may be a performance factor in time-critical code paths."},{"content":"Local functions do not incur this overhead.","pos":[4966,5009],"source":"\nLocal functions do not incur this overhead."},{"content":"In the example above, the local functions version has 2 fewer allocations than the lambda expression version.","pos":[5010,5119],"source":" In the example above, the local\nfunctions version has 2 fewer allocations than the lambda expression version."},{"pos":[5123,5404],"content":"[!NOTE]\nThe local function equivalent of this method also uses a class for the closure. Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail. A local function may use a `struct` whereas a lambda will always use a `class`.","leadings":["","> "],"nodes":[{"content":"The local function equivalent of this method also uses a class for the closure. Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail. A local function may use a `struct` whereas a lambda will always use a `class`.","pos":[8,279],"nodes":[{"content":"The local function equivalent of this method also uses a class for the closure.","pos":[0,79]},{"content":"Whether the closure for a local function is implemented as a <ph id=\"ph1\">`class`</ph> or a <ph id=\"ph2\">`struct`</ph> is an implementation detail.","pos":[80,191],"source":" Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail."},{"content":"A local function may use a <ph id=\"ph1\">`struct`</ph> whereas a lambda will always use a <ph id=\"ph2\">`class`</ph>.","pos":[192,271],"source":" A local function may use a `struct` whereas a lambda will always use a `class`."}]}]},{"content":"One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the <ph id=\"ph1\">`yield return`</ph> syntax to produce a sequence of values.","pos":[5560,5733],"source":"One final advantage not demonstrated in this sample is that local\nfunctions can be implemented as iterators, using the `yield return`\nsyntax to produce a sequence of values."},{"content":"The <ph id=\"ph1\">`yield return`</ph> statement is not allowed in lambda expressions.","pos":[5734,5800],"source":" The `yield return` statement\nis not allowed in lambda expressions."},{"content":"While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.","pos":[5802,5929],"source":"While local functions may seem redundant to lambda expressions,\nthey actually serve different purposes and have different uses."},{"content":"Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.","pos":[5930,6067],"source":"\nLocal functions are more efficient for the case when you want\nto write a function that is called only from the context of\nanother method."}]}