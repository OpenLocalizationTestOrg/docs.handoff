{"content":"---\ntitle: Working with LINQ\ndescription: This tutorial teaches you how to generate sequences with LINQ, write methods for use in LINQ queries, and distinguish between eager and lazy evaluation.\nms.date: 10/29/2018\nms.assetid: 0db12548-82cb-4903-ac88-13103d70aa77\n---\n\n# Working with LINQ\n\n## Introduction\n\nThis tutorial teaches you features in .NET Core and the C# language. You’ll learn:\n\n- How to generate sequences with LINQ.\n- How to write methods that can be easily used in LINQ queries.\n- How to distinguish between eager and lazy evaluation.\n\nYou'll learn these techniques by building an application that demonstrates one of the basic skills of any magician: the [faro shuffle](https://en.wikipedia.org/wiki/Faro_shuffle). Briefly, a faro shuffle is a technique where you split a card deck exactly in half, then the shuffle interleaves each one card from each half to rebuild the original deck.\n\nMagicians use this technique because every card is in a known location after each shuffle, and the order is a repeating pattern.\n\nFor your purposes, it is a light hearted look at manipulating sequences of data. The application you'll build will construct a card deck, and then perform a sequence of shuffles, writing the sequence out each time. You'll also compare the updated order to the original order.\n\nThis tutorial has multiple steps. After each step, you can run the application and see the progress. You can also see the [completed sample](https://github.com/dotnet/samples/blob/master/csharp/getting-started/console-linq) in the dotnet/samples GitHub repository. For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).\n\n## Prerequisites\n\nYou’ll need to setup your machine to run .NET core. You can find the installation instructions on the [.NET Core](https://www.microsoft.com/net/core) page. You can run this application on Windows, Ubuntu Linux, OS X or in a Docker container. You’ll need to install your favorite code editor. The descriptions below use [Visual Studio Code](https://code.visualstudio.com/) which is an open source, cross platform editor. However, you can use whatever tools you are comfortable with.\n\n## Create the Application\n\nThe first step is to create a new application. Open a command prompt and create a new directory for your application. Make that the current directory. Type the command `dotnet new console` at the command prompt. This creates the starter files for a basic \"Hello World\" application.\n\nIf you've never used C# before, [this tutorial](console-teleprompter.md) explains the structure of a C# program. You can read that and then return here to learn more about LINQ.\n\n## Creating the Data Set\n\nBefore you begin, make sure that the following lines are at the top of the `Program.cs` file generated by `dotnet new console`:\n\n```csharp\n// Program.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n```\n\nIf these three lines (`using` statements) aren't at the top of the file, our program will not compile.\n\nNow that you have all of the references that you'll need, consider what constitutes a deck of cards. Commonly, a deck of playing cards has four suits, and each suit has thirteen values. Normally, you might consider creating a `Card` class right off the bat and populating a collection of `Card` objects by hand. With LINQ, you can be more concise than the usual way of dealing with creating a deck of cards. Instead of creating a `Card` class, you can create two sequences to represent suites and ranks, respectively. You'll create a really simple pair of [*iterator methods*](../iterators.md#enumeration-sources-with-iterator-methods) that will generate the ranks and suits as <xref:System.Collections.Generic.IEnumerable%601>s of strings:\n\n```csharp\n// Program.cs\n// The Main() method\n\nstatic IEnumerable<string> Suits()\n{\n    yield return \"clubs\";\n    yield return \"diamonds\";\n    yield return \"hearts\";\n    yield return \"spades\";\n}\n\nstatic IEnumerable<string> Ranks()\n{\n    yield return \"two\";\n    yield return \"three\";\n    yield return \"four\";\n    yield return \"five\";\n    yield return \"six\";\n    yield return \"seven\";\n    yield return \"eight\";\n    yield return \"nine\";\n    yield return \"ten\";\n    yield return \"jack\";\n    yield return \"queen\";\n    yield return \"king\";\n    yield return \"ace\";\n}\n```\n\nPlace these underneath the `Main` method in your `Program.cs` file. These two methods both utilize the `yield return` syntax to produce a sequence as they run. The compiler builds an object that implements <xref:System.Collections.Generic.IEnumerable%601> and generates the sequence of strings as they are requested.\n\nNow, use these iterator methods to create the deck of cards. You'll place the LINQ query in our `Main` method. Here's a look at it:\n\n```csharp\n// Program.cs\nstatic void Main(string[] args)\n{\n    var startingDeck = from s in Suits()\n                       from r in Ranks()\n                       select new { Suit = s, Rank = r };\n\n    // Display each card that we've generated and placed in startingDeck in the console\n    foreach (var card in startingDeck)\n    {\n        Console.WriteLine(card);\n    }\n}\n```\n\nThe multiple `from` clauses produce a <xref:System.Linq.Enumerable.SelectMany%2A>, which creates a single sequence from combining each element in the first sequence with each element in the second sequence. The order is important for our purposes. The first element in the first source sequence (Suits) is combined with every element in the second sequence (Ranks). This produces all thirteen cards of first suit. That process is repeated with each element in the first sequence (Suits). The end result is a deck of cards ordered by suits, followed by values.\n\nIt's important to keep in mind that whether you choose to write your LINQ in the query syntax used above or use method syntax instead, it's always possible to go from one form of syntax to the other. The above query written in query syntax can be written in method syntax as:\n\n```csharp\nvar startingDeck = Suits().SelectMany(suit => Ranks().Select(rank => new { Suit = suit, Rank = rank }));\n```\n\nThe compiler translates LINQ statements written with query syntax into the equivalent method call syntax. Therefore, regardless of your syntax choice, the two versions of the query produce the same result. Choose which syntax works best for your situation: for instance, if you're working in a team where some of the members have difficulty with method syntax, try to prefer using query syntax.\n\nGo ahead and run the sample you've built at this point. It will display all 52 cards in the deck. You may find it very helpful to run this sample under a debugger to observe how the `Suits()` and `Ranks()` methods execute. You can clearly see that each string in each sequence is generated only as it is needed.\n\n![A console window showing the app writing out 52 cards.](./media/working-with-linq/console-52-card-application.png)\n\n## Manipulating the Order\n\nNext, focus on how you're going to shuffle the cards in the deck. The first step in any good shuffle is to split the deck in two. The <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> methods that are part of the LINQ APIs provide that feature for you. Place them underneath the `foreach` loop:\n\n```csharp\n// Program.cs\npublic static void Main(string[] args)\n{\n    var startingDeck = from s in Suits()\n                       from r in Ranks()\n                       select new { Suit = s, Rank = r };\n\n    foreach (var c in startingDeck)\n    {\n        Console.WriteLine(c);\n    }\n\n    // 52 cards in a deck, so 52 / 2 = 26\n    var top = startingDeck.Take(26);\n    var bottom = startingDeck.Skip(26);\n}\n```\n\nHowever, there's no shuffle method to take advantage of in the standard library, so you'll have to write your own. The shuffle method you'll be creating illustrates several techniques that you'll use with LINQ-based programs, so each part of this process will be explained in steps.\n\nIn order to add some functionality to how you interact with the <xref:System.Collections.Generic.IEnumerable%601> you'll get back from LINQ queries, you'll need to write some special kinds of methods called [extension methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md). Briefly, an extension method is a special purpose *static method* that adds new functionality to an already-existing type without having to modify the original type you want to add functionality to.\n\nGive your extension methods a new home by adding a new *static* class file to your program called `Extensions.cs`, and then start building out the first extension method:\n\n```csharp\n// Extensions.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LinqFaroShuffle\n{\n    public static class Extensions\n    {\n        public static IEnumerable<T> InterleaveSequenceWith<T>(this IEnumerable<T> first, IEnumerable<T> second)\n        {\n            // Your implementation will go here soon enough\n        }\n    }\n}\n```\n\nLook at the method signature for a moment, specifically the parameters:\n\n```csharp\npublic static IEnumerable<T> InterleaveSequenceWith<T> (this IEnumerable<T> first, IEnumerable<T> second)\n```\n\nYou can see the addition of the `this` modifier on the first argument to the method. That means you call the method as though it were a member method of the type of the first argument. This method declaration also follows a standard idiom where the input and output types are `IEnumerable<T>`. That practice enables LINQ methods to be chained together to perform more complex queries.\n\nNaturally, since you split the deck into halves, you'll need to join those halves together. In code, this means you'll be enumerating both of the sequences you acquired through <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> at once, *`interleaving`* the elements, and creating one sequence: your now-shuffled deck of cards. Writing a LINQ method that works with two sequences requires that you understand how <xref:System.Collections.Generic.IEnumerable%601> works.\n\nThe <xref:System.Collections.Generic.IEnumerable%601> interface has one method: <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>. The object returned by <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> has a method to move to the next element, and a property that retrieves the current element in the sequence. You will use those two members to enumerate the collection and return the elements. This Interleave method will be an iterator method, so instead of building a collection and returning the collection, you'll use the `yield return` syntax shown above.\n\nHere's the implementation of that method:\n\n[!CODE-csharp[InterleaveSequenceWith](../../../samples/csharp/getting-started/console-linq/extensions.cs?name=snippet1)]\n\nNow that you've written this method, go back to the `Main` method and shuffle the deck once:\n\n```csharp\n// Program.cs\npublic static void Main(string[] args)\n{\n    var startingDeck = from s in Suits()\n                       from r in Ranks()\n                       select new { Suit = s, Rank = r };\n\n    foreach (var c in startingDeck)\n    {\n        Console.WriteLine(c);\n    }\n\n    var top = startingDeck.Take(26);\n    var bottom = startingDeck.Skip(26);\n    var shuffle = top.InterleaveSequenceWith(bottom);\n\n    foreach (var c in shuffle)\n    {\n        Console.WriteLine(c);\n    }\n}\n```\n\n## Comparisons\n\nHow many shuffles it takes to set the deck back to its original order? To find out, you'll need to write a method that determines if two sequences are equal. After you have that method, you'll need to place the code that shuffles the deck in a loop, and check to see when the deck is back in order.\n\nWriting a method to determine if the two sequences are equal should be straightforward. It's a similar structure to the method you wrote to shuffle the deck. Only this time, instead of `yield return`ing each element, you'll compare the matching elements of each sequence. When the entire sequence has been enumerated, if every element matches, the sequences are the same:\n\n[!CODE-csharp[SequenceEquals](../../../samples/csharp/getting-started/console-linq/extensions.cs?name=snippet2)]\n\nThis shows a second LINQ idiom: terminal methods. They take a sequence as input (or in this case, two sequences), and return a single scalar value. When using terminal methods, they are always the final method in a chain of methods for a LINQ query, hence the name \"terminal\".\n\nYou can see this in action when you use it to determine when the deck is back in its original order. Put the shuffle code inside a loop, and stop when the sequence is back in its original order by applying the `SequenceEquals()` method. You can see it would always be the final method in any query, because it returns a single value instead of a sequence:\n\n```csharp\n// Program.cs\nstatic void Main(string[] args)\n{\n    // Query for building the deck\n\n    // Shuffling using InterleaveSequenceWith<T>();\n\n    var times = 0;\n    // We can re-use the shuffle variable from earlier, or you can make a new one\n    shuffle = startingDeck;\n    do\n    {\n        shuffle = shuffle.Take(26).InterleaveSequenceWith(shuffle.Skip(26));\n\n        foreach (var card in shuffle)\n        {\n            Console.WriteLine(card);\n        }\n        Console.WriteLine();\n        times++;\n\n    } while (!startingDeck.SequenceEquals(shuffle));\n\n    Console.WriteLine(times);\n}\n```\n\nRun the code you've got so far and take note of how the deck rearranges on each shuffle. After 8 shuffles (iterations of the do-while loop), the deck returns to the original configuration it was in when you first created it from the starting LINQ query.\n\n## Optimizations\n\nThe sample you've built so far executes an *out shuffle*, where the top and bottom cards stay the same on each run. Let's make one change: we'll use an *in shuffle* instead, where all 52 cards change position. For an in shuffle, you interleave the deck so that the first card in the bottom half becomes the first card in the deck. That means the last card in the top half becomes the bottom card. This is a simple change to a singular line of code. Update the current shuffle query by switching the positions of <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A>. This will change the order of the top and bottom halves of the deck:\n\n```csharp\nshuffle = shuffle.Skip(26).InterleaveSequenceWith(shuffle.Take(26));\n```\n\nRun the program again, and you'll see that it takes 52 iterations for the deck to reorder itself. You'll also start to notice some serious performance degradations as the program continues to run.\n\nThere are a number of reasons for this. You can tackle one of the major causes of this performance drop: inefficient use of [*lazy evaluation*](../programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).\n\nBriefly, lazy evaluation states that the evaluation of a statement is not performed until its value is needed. LINQ queries are statements that are evaluated lazily. The sequences are generated only as the elements are requested. Usually, that's a major benefit of LINQ. However, in a use such as this program, this causes exponential growth in execution time.\n\nRemember that we generated the original deck using a LINQ query. Each shuffle is generated by performing three LINQ queries on the previous deck. All these are performed lazily. That also means they are performed again each time the sequence is requested. By the time you get to the 52nd iteration, you're regenerating the original deck many, many times. Let's write a log to demonstrate this behavior. Then, you'll fix it.\n\nIn your `Extensions.cs` file, type in or copy the method below. This extension method creates a new file called `debug.log` within your project directory and records what query is currently being executed to the log file. This extension method can be appended to any query to mark that the query executed.\n\n[!CODE-csharp[LogQuery](../../../samples/csharp/getting-started/console-linq/extensions.cs?name=snippet3)]\n\nNext, instrument the definition of each query with a log message:\n\n```csharp\n// Program.cs\npublic static void Main(string[] args)\n{\n    var startingDeck = (from s in Suits().LogQuery(\"Suit Generation\")\n                        from r in Ranks().LogQuery(\"Rank Generation\")\n                        select new { Suit = s, Rank = r }).LogQuery(\"Starting Deck\");\n\n    foreach (var c in startingDeck)\n    {\n        Console.WriteLine(c);\n    }\n\n    Console.WriteLine();\n    var times = 0;\n    var shuffle = startingDeck;\n\n    do\n    {\n        // Out shuffle\n        /*\n        shuffle = shuffle.Take(26)\n            .LogQuery(\"Top Half\")\n            .InterleaveSequenceWith(shuffle.Skip(26)\n            .LogQuery(\"Bottom Half\"))\n            .LogQuery(\"Shuffle\");\n        */\n\n        // In shuffle\n        shuffle = shuffle.Skip(26).LogQuery(\"Bottom Half\")\n                .InterleaveSequenceWith(shuffle.Take(26).LogQuery(\"Top Half\"))\n                .LogQuery(\"Shuffle\");\n\n        foreach (var c in shuffle)\n        {\n            Console.WriteLine(c);\n        }\n\n        times++;\n        Console.WriteLine(times);\n    } while (!startingDeck.SequenceEquals(shuffle));\n\n    Console.WriteLine(times);\n}\n```\n\nNotice that you don't log every time you access a query. You log only when you create the original query. The program still takes a long time to run, but now you can see why. If you run out of patience running the in shuffle with logging turned on, switch back to the out shuffle. You'll still see the lazy evaluation effects. In one run, it executes 2592 queries, including all the value and suit generation.\n\nYou can improve the performance of the code here to reduce the number of executions you make. A simple fix you can make is to *cache* the results of the original LINQ query that constructs the deck of cards. Currently, you're executing the queries again and again every time the do-while loop goes through an iteration, re-constructing the deck of cards and reshuffling it every time. To cache the deck of cards, you can leverage the LINQ methods <xref:System.Linq.Enumerable.ToArray%2A> and <xref:System.Linq.Enumerable.ToList%2A>; when you append them to the queries, they'll perform the same actions you've told them to, but now they'll store the results in an array or a list, depending on which method you choose to call. Append the LINQ method <xref:System.Linq.Enumerable.ToArray%2A> to both queries and run the program again:\n\n[!CODE-csharp[Main](../../../samples/csharp/getting-started/console-linq/Program.cs?name=snippet1)]\n\nNow the out shuffle is down to 30 queries. Run again with the in shuffle and you'll see similar improvements: it now executes 162 queries.\n\nPlease note that this example is **designed** to highlight the use cases where lazy evaluation can cause performance difficulties. While it's important to see where lazy evaluation can impact code performance, it's equally important to understand that not all queries should run eagerly. The performance hit you incur without using <xref:System.Linq.Enumerable.ToArray%2A> is because each new arrangement of the deck of cards is built from the previous arrangement. Using lazy evaluation means each new deck configuration is built from the original deck, even executing the code that built the `startingDeck`. That causes a large amount of extra work.\n\nIn practice, some algorithms run well using eager evaluation, and others run well using lazy evaluation. For daily usage, lazy evaluation is usually a better choice when the data source is a separate process, like a database engine. For databases, lazy evaluation allows more complex queries to execute only one round trip to the database process and back to the rest of your code. LINQ is flexible whether you choose to utilize lazy or eager evaluation, so measure your processes and pick whichever kind of evaluation gives you the best performance.\n\n## Conclusion\n\nIn this project, you covered:\n- using LINQ queries to aggregate data into a meaningful sequence\n- writing Extension methods to add our own custom functionality to LINQ queries\n- locating areas in our code where our LINQ queries might run into performance issues like degraded speed\n- lazy and eager evaluation in regards to LINQ queries and the implications they might have on query performance\n\nAside from LINQ, you learned a bit about a technique magicians use for card tricks. Magicians use the Faro shuffle because they can control where every card moves in the deck. Now that you know, don't spoil it for everyone else!\n\nFor more information on LINQ, see:\n- [Language Integrated Query (LINQ)](../programming-guide/concepts/linq/index.md)\n    - [Introduction to LINQ](../programming-guide/concepts/linq/introduction-to-linq.md)\n    - [Getting Started With LINQ in C#](../programming-guide/concepts/linq/getting-started-with-linq.md)\n        - [Basic LINQ Query Operations (C#)](../programming-guide/concepts/linq/basic-linq-query-operations.md)\n        - [Data Transformations With LINQ (C#)](../programming-guide/concepts/linq/data-transformations-with-linq.md)\n        - [Query Syntax and Method Syntax in LINQ (C#)](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)\n        - [C# Features That Support LINQ](../programming-guide/concepts/linq/features-that-support-linq.md)\n","nodes":[{"pos":[4,263],"embed":true,"restype":"x-metadata","content":"title: Working with LINQ\ndescription: This tutorial teaches you how to generate sequences with LINQ, write methods for use in LINQ queries, and distinguish between eager and lazy evaluation.\nms.date: 10/29/2018\nms.assetid: 0db12548-82cb-4903-ac88-13103d70aa77","nodes":[{"content":"Working with LINQ","nodes":[{"pos":[0,17],"content":"Working with LINQ","nodes":[{"content":"Working with LINQ","pos":[0,17]}]}],"path":["title"],"nosxs":false},{"content":"This tutorial teaches you how to generate sequences with LINQ, write methods for use in LINQ queries, and distinguish between eager and lazy evaluation.","nodes":[{"pos":[0,152],"content":"This tutorial teaches you how to generate sequences with LINQ, write methods for use in LINQ queries, and distinguish between eager and lazy evaluation.","nodes":[{"content":"This tutorial teaches you how to generate sequences with LINQ, write methods for use in LINQ queries, and distinguish between eager and lazy evaluation.","pos":[0,152]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[271,288],"content":"Working with LINQ","linkify":"Working with LINQ","nodes":[{"content":"Working with LINQ","pos":[0,17]}]},{"pos":[293,305],"content":"Introduction","linkify":"Introduction","nodes":[{"content":"Introduction","pos":[0,12]}]},{"content":"This tutorial teaches you features in .NET Core and the C# language.","pos":[307,375]},{"content":"You’ll learn:","pos":[376,389]},{"content":"How to generate sequences with LINQ.","pos":[393,429]},{"content":"How to write methods that can be easily used in LINQ queries.","pos":[432,493]},{"content":"How to distinguish between eager and lazy evaluation.","pos":[496,549]},{"content":"You'll learn these techniques by building an application that demonstrates one of the basic skills of any magician: the <bpt id=\"p1\">[</bpt>faro shuffle<ept id=\"p1\">](https://en.wikipedia.org/wiki/Faro_shuffle)</ept>.","pos":[551,730],"source":"You'll learn these techniques by building an application that demonstrates one of the basic skills of any magician: the [faro shuffle](https://en.wikipedia.org/wiki/Faro_shuffle)."},{"content":"Briefly, a faro shuffle is a technique where you split a card deck exactly in half, then the shuffle interleaves each one card from each half to rebuild the original deck.","pos":[731,902]},{"content":"Magicians use this technique because every card is in a known location after each shuffle, and the order is a repeating pattern.","pos":[904,1032]},{"content":"For your purposes, it is a light hearted look at manipulating sequences of data.","pos":[1034,1114]},{"content":"The application you'll build will construct a card deck, and then perform a sequence of shuffles, writing the sequence out each time.","pos":[1115,1248]},{"content":"You'll also compare the updated order to the original order.","pos":[1249,1309]},{"content":"This tutorial has multiple steps.","pos":[1311,1344]},{"content":"After each step, you can run the application and see the progress.","pos":[1345,1411]},{"content":"You can also see the <bpt id=\"p1\">[</bpt>completed sample<ept id=\"p1\">](https://github.com/dotnet/samples/blob/master/csharp/getting-started/console-linq)</ept> in the dotnet/samples GitHub repository.","pos":[1412,1575],"source":" You can also see the [completed sample](https://github.com/dotnet/samples/blob/master/csharp/getting-started/console-linq) in the dotnet/samples GitHub repository."},{"content":"For download instructions, see <bpt id=\"p1\">[</bpt>Samples and Tutorials<ept id=\"p1\">](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)</ept>.","pos":[1576,1701],"source":" For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)."},{"pos":[1706,1719],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"You’ll need to setup your machine to run .NET core.","pos":[1721,1772]},{"content":"You can find the installation instructions on the <bpt id=\"p1\">[</bpt>.NET Core<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> page.","pos":[1773,1876],"source":" You can find the installation instructions on the [.NET Core](https://www.microsoft.com/net/core) page."},{"content":"You can run this application on Windows, Ubuntu Linux, OS X or in a Docker container.","pos":[1877,1962]},{"content":"You’ll need to install your favorite code editor.","pos":[1963,2012]},{"content":"The descriptions below use <bpt id=\"p1\">[</bpt>Visual Studio Code<ept id=\"p1\">](https://code.visualstudio.com/)</ept> which is an open source, cross platform editor.","pos":[2013,2140],"source":" The descriptions below use [Visual Studio Code](https://code.visualstudio.com/) which is an open source, cross platform editor."},{"content":"However, you can use whatever tools you are comfortable with.","pos":[2141,2202]},{"pos":[2207,2229],"content":"Create the Application","linkify":"Create the Application","nodes":[{"content":"Create the Application","pos":[0,22]}]},{"content":"The first step is to create a new application.","pos":[2231,2277]},{"content":"Open a command prompt and create a new directory for your application.","pos":[2278,2348]},{"content":"Make that the current directory.","pos":[2349,2381]},{"content":"Type the command <ph id=\"ph1\">`dotnet new console`</ph> at the command prompt.","pos":[2382,2442],"source":" Type the command `dotnet new console` at the command prompt."},{"content":"This creates the starter files for a basic \"Hello World\" application.","pos":[2443,2512]},{"content":"If you've never used C# before, <bpt id=\"p1\">[</bpt>this tutorial<ept id=\"p1\">](console-teleprompter.md)</ept> explains the structure of a C# program.","pos":[2514,2626],"source":"If you've never used C# before, [this tutorial](console-teleprompter.md) explains the structure of a C# program."},{"content":"You can read that and then return here to learn more about LINQ.","pos":[2627,2691]},{"pos":[2696,2717],"content":"Creating the Data Set","linkify":"Creating the Data Set","nodes":[{"content":"Creating the Data Set","pos":[0,21]}]},{"pos":[2719,2846],"content":"Before you begin, make sure that the following lines are at the top of the <ph id=\"ph1\">`Program.cs`</ph> file generated by <ph id=\"ph2\">`dotnet new console`</ph>:","source":"Before you begin, make sure that the following lines are at the top of the `Program.cs` file generated by `dotnet new console`:"},{"pos":[2944,3046],"content":"If these three lines (<ph id=\"ph1\">`using`</ph> statements) aren't at the top of the file, our program will not compile.","source":"If these three lines (`using` statements) aren't at the top of the file, our program will not compile."},{"content":"Now that you have all of the references that you'll need, consider what constitutes a deck of cards.","pos":[3048,3148]},{"content":"Commonly, a deck of playing cards has four suits, and each suit has thirteen values.","pos":[3149,3233]},{"content":"Normally, you might consider creating a <ph id=\"ph1\">`Card`</ph> class right off the bat and populating a collection of <ph id=\"ph2\">`Card`</ph> objects by hand.","pos":[3234,3359],"source":" Normally, you might consider creating a `Card` class right off the bat and populating a collection of `Card` objects by hand."},{"content":"With LINQ, you can be more concise than the usual way of dealing with creating a deck of cards.","pos":[3360,3455]},{"content":"Instead of creating a <ph id=\"ph1\">`Card`</ph> class, you can create two sequences to represent suites and ranks, respectively.","pos":[3456,3565],"source":" Instead of creating a `Card` class, you can create two sequences to represent suites and ranks, respectively."},{"content":"You'll create a really simple pair of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">*</bpt>iterator methods<ept id=\"p2\">*</ept><ept id=\"p1\">](../iterators.md#enumeration-sources-with-iterator-methods)</ept> that will generate the ranks and suits as <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>s of strings:","pos":[3566,3788],"source":" You'll create a really simple pair of [*iterator methods*](../iterators.md#enumeration-sources-with-iterator-methods) that will generate the ranks and suits as <xref:System.Collections.Generic.IEnumerable%601>s of strings:"},{"content":"Place these underneath the <ph id=\"ph1\">`Main`</ph> method in your <ph id=\"ph2\">`Program.cs`</ph> file.","pos":[4354,4421],"source":"Place these underneath the `Main` method in your `Program.cs` file."},{"content":"These two methods both utilize the <ph id=\"ph1\">`yield return`</ph> syntax to produce a sequence as they run.","pos":[4422,4513],"source":" These two methods both utilize the `yield return` syntax to produce a sequence as they run."},{"content":"The compiler builds an object that implements <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> and generates the sequence of strings as they are requested.","pos":[4514,4670],"source":" The compiler builds an object that implements <xref:System.Collections.Generic.IEnumerable%601> and generates the sequence of strings as they are requested."},{"content":"Now, use these iterator methods to create the deck of cards.","pos":[4672,4732]},{"content":"You'll place the LINQ query in our <ph id=\"ph1\">`Main`</ph> method.","pos":[4733,4782],"source":" You'll place the LINQ query in our `Main` method."},{"content":"Here's a look at it:","pos":[4783,4803]},{"content":"The multiple <ph id=\"ph1\">`from`</ph> clauses produce a <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.SelectMany%2A&gt;</ph>, which creates a single sequence from combining each element in the first sequence with each element in the second sequence.","pos":[5183,5389],"source":"The multiple `from` clauses produce a <xref:System.Linq.Enumerable.SelectMany%2A>, which creates a single sequence from combining each element in the first sequence with each element in the second sequence."},{"content":"The order is important for our purposes.","pos":[5390,5430]},{"content":"The first element in the first source sequence (Suits) is combined with every element in the second sequence (Ranks).","pos":[5431,5548]},{"content":"This produces all thirteen cards of first suit.","pos":[5549,5596]},{"content":"That process is repeated with each element in the first sequence (Suits).","pos":[5597,5670]},{"content":"The end result is a deck of cards ordered by suits, followed by values.","pos":[5671,5742]},{"content":"It's important to keep in mind that whether you choose to write your LINQ in the query syntax used above or use method syntax instead, it's always possible to go from one form of syntax to the other.","pos":[5744,5943]},{"content":"The above query written in query syntax can be written in method syntax as:","pos":[5944,6019]},{"content":"The compiler translates LINQ statements written with query syntax into the equivalent method call syntax.","pos":[6141,6246]},{"content":"Therefore, regardless of your syntax choice, the two versions of the query produce the same result.","pos":[6247,6346]},{"content":"Choose which syntax works best for your situation: for instance, if you're working in a team where some of the members have difficulty with method syntax, try to prefer using query syntax.","pos":[6347,6535]},{"content":"Go ahead and run the sample you've built at this point.","pos":[6537,6592]},{"content":"It will display all 52 cards in the deck.","pos":[6593,6634]},{"content":"You may find it very helpful to run this sample under a debugger to observe how the <ph id=\"ph1\">`Suits()`</ph> and <ph id=\"ph2\">`Ranks()`</ph> methods execute.","pos":[6635,6759],"source":" You may find it very helpful to run this sample under a debugger to observe how the `Suits()` and `Ranks()` methods execute."},{"content":"You can clearly see that each string in each sequence is generated only as it is needed.","pos":[6760,6848]},{"content":"A console window showing the app writing out 52 cards.","pos":[6852,6906]},{"pos":[6971,6993],"content":"Manipulating the Order","linkify":"Manipulating the Order","nodes":[{"content":"Manipulating the Order","pos":[0,22]}]},{"content":"Next, focus on how you're going to shuffle the cards in the deck.","pos":[6995,7060]},{"content":"The first step in any good shuffle is to split the deck in two.","pos":[7061,7124]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph> methods that are part of the LINQ APIs provide that feature for you.","pos":[7125,7277],"source":" The <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> methods that are part of the LINQ APIs provide that feature for you."},{"content":"Place them underneath the <ph id=\"ph1\">`foreach`</ph> loop:","pos":[7278,7319],"source":" Place them underneath the `foreach` loop:"},{"content":"However, there's no shuffle method to take advantage of in the standard library, so you'll have to write your own.","pos":[7732,7846]},{"content":"The shuffle method you'll be creating illustrates several techniques that you'll use with LINQ-based programs, so each part of this process will be explained in steps.","pos":[7847,8014]},{"content":"In order to add some functionality to how you interact with the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> you'll get back from LINQ queries, you'll need to write some special kinds of methods called <bpt id=\"p1\">[</bpt>extension methods<ept id=\"p1\">](../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept>.","pos":[8016,8316],"source":"In order to add some functionality to how you interact with the <xref:System.Collections.Generic.IEnumerable%601> you'll get back from LINQ queries, you'll need to write some special kinds of methods called [extension methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md)."},{"content":"Briefly, an extension method is a special purpose <bpt id=\"p1\">*</bpt>static method<ept id=\"p1\">*</ept> that adds new functionality to an already-existing type without having to modify the original type you want to add functionality to.","pos":[8317,8515],"source":" Briefly, an extension method is a special purpose *static method* that adds new functionality to an already-existing type without having to modify the original type you want to add functionality to."},{"pos":[8517,8687],"content":"Give your extension methods a new home by adding a new <bpt id=\"p1\">*</bpt>static<ept id=\"p1\">*</ept> class file to your program called <ph id=\"ph1\">`Extensions.cs`</ph>, and then start building out the first extension method:","source":"Give your extension methods a new home by adding a new *static* class file to your program called `Extensions.cs`, and then start building out the first extension method:"},{"content":"Look at the method signature for a moment, specifically the parameters:","pos":[9059,9130]},{"content":"You can see the addition of the <ph id=\"ph1\">`this`</ph> modifier on the first argument to the method.","pos":[9253,9337],"source":"You can see the addition of the `this` modifier on the first argument to the method."},{"content":"That means you call the method as though it were a member method of the type of the first argument.","pos":[9338,9437]},{"content":"This method declaration also follows a standard idiom where the input and output types are <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph>.","pos":[9438,9546],"source":" This method declaration also follows a standard idiom where the input and output types are `IEnumerable<T>`."},{"content":"That practice enables LINQ methods to be chained together to perform more complex queries.","pos":[9547,9637]},{"content":"Naturally, since you split the deck into halves, you'll need to join those halves together.","pos":[9639,9730]},{"content":"In code, this means you'll be enumerating both of the sequences you acquired through <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph> at once, <bpt id=\"p1\">*</bpt><ph id=\"ph3\">`interleaving`</ph><ept id=\"p1\">*</ept> the elements, and creating one sequence: your now-shuffled deck of cards.","pos":[9731,9995],"source":" In code, this means you'll be enumerating both of the sequences you acquired through <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> at once, *`interleaving`* the elements, and creating one sequence: your now-shuffled deck of cards."},{"content":"Writing a LINQ method that works with two sequences requires that you understand how <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> works.","pos":[9996,10137],"source":" Writing a LINQ method that works with two sequences requires that you understand how <xref:System.Collections.Generic.IEnumerable%601> works."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface has one method: <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph>.","pos":[10139,10286],"source":"The <xref:System.Collections.Generic.IEnumerable%601> interface has one method: <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>."},{"content":"The object returned by <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> has a method to move to the next element, and a property that retrieves the current element in the sequence.","pos":[10287,10485],"source":" The object returned by <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> has a method to move to the next element, and a property that retrieves the current element in the sequence."},{"content":"You will use those two members to enumerate the collection and return the elements.","pos":[10486,10569]},{"content":"This Interleave method will be an iterator method, so instead of building a collection and returning the collection, you'll use the <ph id=\"ph1\">`yield return`</ph> syntax shown above.","pos":[10570,10736],"source":" This Interleave method will be an iterator method, so instead of building a collection and returning the collection, you'll use the `yield return` syntax shown above."},{"content":"Here's the implementation of that method:","pos":[10738,10779]},{"pos":[10903,10995],"content":"Now that you've written this method, go back to the <ph id=\"ph1\">`Main`</ph> method and shuffle the deck once:","source":"Now that you've written this method, go back to the `Main` method and shuffle the deck once:"},{"pos":[11497,11508],"content":"Comparisons","linkify":"Comparisons","nodes":[{"content":"Comparisons","pos":[0,11]}]},{"content":"How many shuffles it takes to set the deck back to its original order?","pos":[11510,11580]},{"content":"To find out, you'll need to write a method that determines if two sequences are equal.","pos":[11581,11667]},{"content":"After you have that method, you'll need to place the code that shuffles the deck in a loop, and check to see when the deck is back in order.","pos":[11668,11808]},{"content":"Writing a method to determine if the two sequences are equal should be straightforward.","pos":[11810,11897]},{"content":"It's a similar structure to the method you wrote to shuffle the deck.","pos":[11898,11967]},{"content":"Only this time, instead of <ph id=\"ph1\">`yield return`</ph>ing each element, you'll compare the matching elements of each sequence.","pos":[11968,12081],"source":" Only this time, instead of `yield return`ing each element, you'll compare the matching elements of each sequence."},{"content":"When the entire sequence has been enumerated, if every element matches, the sequences are the same:","pos":[12082,12181]},{"content":"This shows a second LINQ idiom: terminal methods.","pos":[12297,12346]},{"content":"They take a sequence as input (or in this case, two sequences), and return a single scalar value.","pos":[12347,12444]},{"content":"When using terminal methods, they are always the final method in a chain of methods for a LINQ query, hence the name \"terminal\".","pos":[12445,12573]},{"content":"You can see this in action when you use it to determine when the deck is back in its original order.","pos":[12575,12675]},{"content":"Put the shuffle code inside a loop, and stop when the sequence is back in its original order by applying the <ph id=\"ph1\">`SequenceEquals()`</ph> method.","pos":[12676,12811],"source":" Put the shuffle code inside a loop, and stop when the sequence is back in its original order by applying the `SequenceEquals()` method."},{"content":"You can see it would always be the final method in any query, because it returns a single value instead of a sequence:","pos":[12812,12930]},{"content":"Run the code you've got so far and take note of how the deck rearranges on each shuffle.","pos":[13532,13620]},{"content":"After 8 shuffles (iterations of the do-while loop), the deck returns to the original configuration it was in when you first created it from the starting LINQ query.","pos":[13621,13785]},{"pos":[13790,13803],"content":"Optimizations","linkify":"Optimizations","nodes":[{"content":"Optimizations","pos":[0,13]}]},{"content":"The sample you've built so far executes an <bpt id=\"p1\">*</bpt>out shuffle<ept id=\"p1\">*</ept>, where the top and bottom cards stay the same on each run.","pos":[13805,13920],"source":"The sample you've built so far executes an *out shuffle*, where the top and bottom cards stay the same on each run."},{"content":"Let's make one change: we'll use an <bpt id=\"p1\">*</bpt>in shuffle<ept id=\"p1\">*</ept> instead, where all 52 cards change position.","pos":[13921,14014],"source":" Let's make one change: we'll use an *in shuffle* instead, where all 52 cards change position."},{"content":"For an in shuffle, you interleave the deck so that the first card in the bottom half becomes the first card in the deck.","pos":[14015,14135]},{"content":"That means the last card in the top half becomes the bottom card.","pos":[14136,14201]},{"content":"This is a simple change to a singular line of code.","pos":[14202,14253]},{"content":"Update the current shuffle query by switching the positions of <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph>.","pos":[14254,14397],"source":" Update the current shuffle query by switching the positions of <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A>."},{"content":"This will change the order of the top and bottom halves of the deck:","pos":[14398,14466]},{"content":"Run the program again, and you'll see that it takes 52 iterations for the deck to reorder itself.","pos":[14552,14649]},{"content":"You'll also start to notice some serious performance degradations as the program continues to run.","pos":[14650,14748]},{"content":"There are a number of reasons for this.","pos":[14750,14789]},{"content":"You can tackle one of the major causes of this performance drop: inefficient use of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">*</bpt>lazy evaluation<ept id=\"p2\">*</ept><ept id=\"p1\">](../programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)</ept>.","pos":[14790,14987],"source":" You can tackle one of the major causes of this performance drop: inefficient use of [*lazy evaluation*](../programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)."},{"content":"Briefly, lazy evaluation states that the evaluation of a statement is not performed until its value is needed.","pos":[14989,15099]},{"content":"LINQ queries are statements that are evaluated lazily.","pos":[15100,15154]},{"content":"The sequences are generated only as the elements are requested.","pos":[15155,15218]},{"content":"Usually, that's a major benefit of LINQ.","pos":[15219,15259]},{"content":"However, in a use such as this program, this causes exponential growth in execution time.","pos":[15260,15349]},{"content":"Remember that we generated the original deck using a LINQ query.","pos":[15351,15415]},{"content":"Each shuffle is generated by performing three LINQ queries on the previous deck.","pos":[15416,15496]},{"content":"All these are performed lazily.","pos":[15497,15528]},{"content":"That also means they are performed again each time the sequence is requested.","pos":[15529,15606]},{"content":"By the time you get to the 52nd iteration, you're regenerating the original deck many, many times.","pos":[15607,15705]},{"content":"Let's write a log to demonstrate this behavior.","pos":[15706,15753]},{"content":"Then, you'll fix it.","pos":[15754,15774]},{"content":"In your <ph id=\"ph1\">`Extensions.cs`</ph> file, type in or copy the method below.","pos":[15776,15839],"source":"In your `Extensions.cs` file, type in or copy the method below."},{"content":"This extension method creates a new file called <ph id=\"ph1\">`debug.log`</ph> within your project directory and records what query is currently being executed to the log file.","pos":[15840,15997],"source":" This extension method creates a new file called `debug.log` within your project directory and records what query is currently being executed to the log file."},{"content":"This extension method can be appended to any query to mark that the query executed.","pos":[15998,16081]},{"content":"Next, instrument the definition of each query with a log message:","pos":[16191,16256]},{"content":"Notice that you don't log every time you access a query.","pos":[17390,17446]},{"content":"You log only when you create the original query.","pos":[17447,17495]},{"content":"The program still takes a long time to run, but now you can see why.","pos":[17496,17564]},{"content":"If you run out of patience running the in shuffle with logging turned on, switch back to the out shuffle.","pos":[17565,17670]},{"content":"You'll still see the lazy evaluation effects.","pos":[17671,17716]},{"content":"In one run, it executes 2592 queries, including all the value and suit generation.","pos":[17717,17799]},{"content":"You can improve the performance of the code here to reduce the number of executions you make.","pos":[17801,17894]},{"content":"A simple fix you can make is to <bpt id=\"p1\">*</bpt>cache<ept id=\"p1\">*</ept> the results of the original LINQ query that constructs the deck of cards.","pos":[17895,18008],"source":" A simple fix you can make is to *cache* the results of the original LINQ query that constructs the deck of cards."},{"content":"Currently, you're executing the queries again and again every time the do-while loop goes through an iteration, re-constructing the deck of cards and reshuffling it every time.","pos":[18009,18185]},{"content":"To cache the deck of cards, you can leverage the LINQ methods <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.ToArray%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph>; when you append them to the queries, they'll perform the same actions you've told them to, but now they'll store the results in an array or a list, depending on which method you choose to call.","pos":[18186,18527],"source":" To cache the deck of cards, you can leverage the LINQ methods <xref:System.Linq.Enumerable.ToArray%2A> and <xref:System.Linq.Enumerable.ToList%2A>; when you append them to the queries, they'll perform the same actions you've told them to, but now they'll store the results in an array or a list, depending on which method you choose to call."},{"content":"Append the LINQ method <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.ToArray%2A&gt;</ph> to both queries and run the program again:","pos":[18528,18634],"source":" Append the LINQ method <xref:System.Linq.Enumerable.ToArray%2A> to both queries and run the program again:"},{"content":"Now the out shuffle is down to 30 queries.","pos":[18737,18779]},{"content":"Run again with the in shuffle and you'll see similar improvements: it now executes 162 queries.","pos":[18780,18875]},{"content":"Please note that this example is <bpt id=\"p1\">**</bpt>designed<ept id=\"p1\">**</ept> to highlight the use cases where lazy evaluation can cause performance difficulties.","pos":[18877,19007],"source":"Please note that this example is **designed** to highlight the use cases where lazy evaluation can cause performance difficulties."},{"content":"While it's important to see where lazy evaluation can impact code performance, it's equally important to understand that not all queries should run eagerly.","pos":[19008,19164]},{"content":"The performance hit you incur without using <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.ToArray%2A&gt;</ph> is because each new arrangement of the deck of cards is built from the previous arrangement.","pos":[19165,19342],"source":" The performance hit you incur without using <xref:System.Linq.Enumerable.ToArray%2A> is because each new arrangement of the deck of cards is built from the previous arrangement."},{"content":"Using lazy evaluation means each new deck configuration is built from the original deck, even executing the code that built the <ph id=\"ph1\">`startingDeck`</ph>.","pos":[19343,19486],"source":" Using lazy evaluation means each new deck configuration is built from the original deck, even executing the code that built the `startingDeck`."},{"content":"That causes a large amount of extra work.","pos":[19487,19528]},{"content":"In practice, some algorithms run well using eager evaluation, and others run well using lazy evaluation.","pos":[19530,19634]},{"content":"For daily usage, lazy evaluation is usually a better choice when the data source is a separate process, like a database engine.","pos":[19635,19762]},{"content":"For databases, lazy evaluation allows more complex queries to execute only one round trip to the database process and back to the rest of your code.","pos":[19763,19911]},{"content":"LINQ is flexible whether you choose to utilize lazy or eager evaluation, so measure your processes and pick whichever kind of evaluation gives you the best performance.","pos":[19912,20080]},{"pos":[20085,20095],"content":"Conclusion","linkify":"Conclusion","nodes":[{"content":"Conclusion","pos":[0,10]}]},{"content":"In this project, you covered:","pos":[20097,20126]},{"content":"using LINQ queries to aggregate data into a meaningful sequence","pos":[20129,20192]},{"content":"writing Extension methods to add our own custom functionality to LINQ queries","pos":[20195,20272]},{"content":"locating areas in our code where our LINQ queries might run into performance issues like degraded speed","pos":[20275,20378]},{"content":"lazy and eager evaluation in regards to LINQ queries and the implications they might have on query performance","pos":[20381,20491]},{"content":"Aside from LINQ, you learned a bit about a technique magicians use for card tricks.","pos":[20493,20576]},{"content":"Magicians use the Faro shuffle because they can control where every card moves in the deck.","pos":[20577,20668]},{"content":"Now that you know, don't spoil it for everyone else!","pos":[20669,20721]},{"content":"For more information on LINQ, see:","pos":[20723,20757]},{"pos":[20760,20839],"content":"<bpt id=\"p1\">[</bpt>Language Integrated Query (LINQ)<ept id=\"p1\">](../programming-guide/concepts/linq/index.md)</ept>","source":"[Language Integrated Query (LINQ)](../programming-guide/concepts/linq/index.md)"},{"pos":[20846,20928],"content":"<bpt id=\"p1\">[</bpt>Introduction to LINQ<ept id=\"p1\">](../programming-guide/concepts/linq/introduction-to-linq.md)</ept>","source":"[Introduction to LINQ](../programming-guide/concepts/linq/introduction-to-linq.md)"},{"pos":[20935,21033],"content":"<bpt id=\"p1\">[</bpt>Getting Started With LINQ in C#<ept id=\"p1\">](../programming-guide/concepts/linq/getting-started-with-linq.md)</ept>","source":"[Getting Started With LINQ in C#](../programming-guide/concepts/linq/getting-started-with-linq.md)"},{"pos":[21044,21145],"content":"<bpt id=\"p1\">[</bpt>Basic LINQ Query Operations (C#)<ept id=\"p1\">](../programming-guide/concepts/linq/basic-linq-query-operations.md)</ept>","source":"[Basic LINQ Query Operations (C#)](../programming-guide/concepts/linq/basic-linq-query-operations.md)"},{"pos":[21156,21263],"content":"<bpt id=\"p1\">[</bpt>Data Transformations With LINQ (C#)<ept id=\"p1\">](../programming-guide/concepts/linq/data-transformations-with-linq.md)</ept>","source":"[Data Transformations With LINQ (C#)](../programming-guide/concepts/linq/data-transformations-with-linq.md)"},{"pos":[21274,21397],"content":"<bpt id=\"p1\">[</bpt>Query Syntax and Method Syntax in LINQ (C#)<ept id=\"p1\">](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)</ept>","source":"[Query Syntax and Method Syntax in LINQ (C#)](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)"},{"pos":[21408,21505],"content":"<bpt id=\"p1\">[</bpt>C# Features That Support LINQ<ept id=\"p1\">](../programming-guide/concepts/linq/features-that-support-linq.md)</ept>","source":"[C# Features That Support LINQ](../programming-guide/concepts/linq/features-that-support-linq.md)"}]}