{"content":"---\ntitle: \"Potential Pitfalls with PLINQ\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"PLINQ queries, pitfalls\"\nms.assetid: 75a38b55-4bc4-488a-87d5-89dbdbdc76a2\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n\n# Potential Pitfalls with PLINQ\n\nIn many cases, PLINQ can provide significant performance improvements over sequential LINQ to Objects queries. However, the work of parallelizing the query execution introduces complexity that can lead to problems that, in sequential code, are not as common or are not encountered at all. This topic lists some practices to avoid when you write PLINQ queries.\n\n## Do Not Assume That Parallel Is Always Faster\n\nParallelization sometimes causes a PLINQ query to run slower than its LINQ to Objects equivalent. The basic rule of thumb is that queries that have few source elements and fast user delegates are unlikely to speedup much. However, because many factors are involved in performance, we recommend that you measure actual results before you decide whether to use PLINQ. For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).\n\n## Avoid Writing to Shared Memory Locations\n\nIn sequential code, it is not uncommon to read from or write to static variables or class fields. However, whenever multiple threads are accessing such variables concurrently, there is a big potential for race conditions. Even though you can use locks to synchronize access to the variable, the cost of synchronization can hurt performance. Therefore, we recommend that you avoid, or at least limit, access to shared state in a PLINQ query as much as possible.\n\n## Avoid Over-Parallelization\n\nBy using the `AsParallel` operator, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads. The benefits of parallelization are further limited by the number of processors on the computer. There is no speedup to be gained by running multiple compute-bound threads on just one processor. Therefore, you must be careful not to over-parallelize a query.\n\nThe most common scenario in which over-parallelization can occur is in nested queries, as shown in the following snippet.\n\n[!code-csharp[PLINQ#20](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#20)]\n[!code-vb[PLINQ#20](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#20)]\n\nIn this case, it is best to parallelize only the outer data source (customers) unless one or more of the following conditions apply:\n\n- The inner data source (cust.Orders) is known to be very long.\n\n- You are performing an expensive computation on each order. (The operation shown in the example is not expensive.)\n\n- The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on `cust.Orders`.\n\nIn all cases, the best way to determine the optimum query shape is to test and measure. For more information, see [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).\n\n## Avoid Calls to Non-Thread-Safe Methods\n\nWriting to non-thread-safe instance methods from a PLINQ query can lead to data corruption which may or may not go undetected in your program. It can also lead to exceptions. In the following example, multiple threads would be attempting to call the `FileStream.Write` method simultaneously, which is not supported by the class.\n\n```vb\nDim fs As FileStream = File.OpenWrite(…)\na.AsParallel().Where(...).OrderBy(...).Select(...).ForAll(Sub(x) fs.Write(x))\n```\n\n```csharp\nFileStream fs = File.OpenWrite(...);\na.AsParallel().Where(...).OrderBy(...).Select(...).ForAll(x => fs.Write(x));\n```\n\n## Limit Calls to Thread-Safe Methods\n\nMost static methods in the .NET Framework are thread-safe and can be called from multiple threads concurrently. However, even in these cases, the synchronization involved can lead to significant slowdown in the query.\n\n> [!NOTE]\n> You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries. Although this method is used in the documentation examples for demonstration purposes, do not use it in PLINQ queries.\n\n## Avoid Unnecessary Ordering Operations\n\nWhen PLINQ executes a query in parallel, it divides the source sequence into partitions that can be operated on concurrently on multiple threads. By default, the order in which the partitions are processed and the results are delivered is not predictable (except for operators such as `OrderBy`). You can instruct PLINQ to preserve the ordering of any source sequence, but this has a negative impact on performance. The best practice, whenever possible, is to structure queries so that they do not rely on order preservation. For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).\n\n## Prefer ForAll to ForEach When It Is Possible\n\nAlthough PLINQ executes a query on multiple threads, if you consume the results in a `foreach` loop (`For Each` in Visual Basic), then the query results must be merged back into one thread and accessed serially by the enumerator. In some cases, this is unavoidable; however, whenever possible, use the `ForAll` method to enable each thread to output its own results, for example, by writing to a thread-safe collection such as <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>.\n\nThe same issue applies to <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> In other words, `source.AsParallel().Where().ForAll(...)` should be strongly preferred to\n\n`Parallel.ForEach(source.AsParallel().Where(), ...)`.\n\n## Be Aware of Thread Affinity Issues\n\nSome technologies, for example, COM interoperability for Single-Threaded Apartment (STA) components, Windows Forms, and Windows Presentation Foundation (WPF), impose thread affinity restrictions that require code to run on a specific thread. For example, in both Windows Forms and WPF, a control can only be accessed on the thread on which it was created. If you try to access the shared state of a Windows Forms control in a PLINQ query, an exception is raised if you are running in the debugger. (This setting can be turned off.) However, if your query is consumed on the UI thread, then you can access the control from the `foreach` loop that enumerates the query results because that code executes on just one thread.\n\n## Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel\n\nIt is important to keep in mind that individual iterations in a <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> or <xref:System.Linq.ParallelEnumerable.ForAll%2A> loop may but do not have to execute in parallel. Therefore, you should avoid writing any code that depends for correctness on parallel execution of iterations or on the execution of iterations in any particular order.\n\nFor example, this code is likely to deadlock:\n\n```vb\nDim mre = New ManualResetEventSlim()\nEnumerable.Range(0, Environment.ProcessorCount * 100).AsParallel().ForAll(Sub(j)\n   If j = Environment.ProcessorCount Then\n       Console.WriteLine(\"Set on {0} with value of {1}\", Thread.CurrentThread.ManagedThreadId, j)\n       mre.Set()\n   Else\n       Console.WriteLine(\"Waiting on {0} with value of {1}\", Thread.CurrentThread.ManagedThreadId, j)\n       mre.Wait()\n   End If\nEnd Sub) ' deadlocks\n```\n\n```csharp\nManualResetEventSlim mre = new ManualResetEventSlim();\nEnumerable.Range(0, Environment.ProcessorCount * 100).AsParallel().ForAll((j) =>\n{\n    if (j == Environment.ProcessorCount)\n    {\n        Console.WriteLine(\"Set on {0} with value of {1}\", Thread.CurrentThread.ManagedThreadId, j);\n        mre.Set();\n    }\n    else\n    {\n        Console.WriteLine(\"Waiting on {0} with value of {1}\", Thread.CurrentThread.ManagedThreadId, j);\n        mre.Wait();\n    }\n}); //deadlocks\n```\n\nIn this example, one iteration sets an event, and all other iterations wait on the event. None of the waiting iterations can complete until the event-setting iteration has completed. However, it is possible that the waiting iterations block all threads that are used to execute the parallel loop, before the event-setting iteration has had a chance to execute. This results in a deadlock – the event-setting iteration will never execute, and the waiting iterations will never wake up.\n\nIn particular, one iteration of a parallel loop should never wait on another iteration of the loop to make progress. If the parallel loop decides to schedule the iterations sequentially but in the opposite order, a deadlock will occur.\n\n## See also\n\n- [Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)\n","nodes":[{"pos":[4,268],"embed":true,"restype":"x-metadata","content":"title: \"Potential Pitfalls with PLINQ\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"PLINQ queries, pitfalls\"\nms.assetid: 75a38b55-4bc4-488a-87d5-89dbdbdc76a2\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Potential Pitfalls with PLINQ","nodes":[{"pos":[0,29],"content":"Potential Pitfalls with PLINQ","nodes":[{"content":"Potential Pitfalls with PLINQ","pos":[0,29]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[276,305],"content":"Potential Pitfalls with PLINQ","linkify":"Potential Pitfalls with PLINQ","nodes":[{"content":"Potential Pitfalls with PLINQ","pos":[0,29]}]},{"content":"In many cases, PLINQ can provide significant performance improvements over sequential LINQ to Objects queries.","pos":[307,417]},{"content":"However, the work of parallelizing the query execution introduces complexity that can lead to problems that, in sequential code, are not as common or are not encountered at all.","pos":[418,595]},{"content":"This topic lists some practices to avoid when you write PLINQ queries.","pos":[596,666]},{"pos":[671,715],"content":"Do Not Assume That Parallel Is Always Faster","linkify":"Do Not Assume That Parallel Is Always Faster","nodes":[{"content":"Do Not Assume That Parallel Is Always Faster","pos":[0,44]}]},{"content":"Parallelization sometimes causes a PLINQ query to run slower than its LINQ to Objects equivalent.","pos":[717,814]},{"content":"The basic rule of thumb is that queries that have few source elements and fast user delegates are unlikely to speedup much.","pos":[815,938]},{"content":"However, because many factors are involved in performance, we recommend that you measure actual results before you decide whether to use PLINQ.","pos":[939,1082]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Understanding Speedup in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)</ept>.","pos":[1083,1221],"source":" For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)."},{"pos":[1226,1266],"content":"Avoid Writing to Shared Memory Locations","linkify":"Avoid Writing to Shared Memory Locations","nodes":[{"content":"Avoid Writing to Shared Memory Locations","pos":[0,40]}]},{"content":"In sequential code, it is not uncommon to read from or write to static variables or class fields.","pos":[1268,1365]},{"content":"However, whenever multiple threads are accessing such variables concurrently, there is a big potential for race conditions.","pos":[1366,1489]},{"content":"Even though you can use locks to synchronize access to the variable, the cost of synchronization can hurt performance.","pos":[1490,1608]},{"content":"Therefore, we recommend that you avoid, or at least limit, access to shared state in a PLINQ query as much as possible.","pos":[1609,1728]},{"pos":[1733,1759],"content":"Avoid Over-Parallelization","linkify":"Avoid Over-Parallelization","nodes":[{"content":"Avoid Over-Parallelization","pos":[0,26]}]},{"content":"By using the <ph id=\"ph1\">`AsParallel`</ph> operator, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads.","pos":[1761,1901],"source":"By using the `AsParallel` operator, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads."},{"content":"The benefits of parallelization are further limited by the number of processors on the computer.","pos":[1902,1998]},{"content":"There is no speedup to be gained by running multiple compute-bound threads on just one processor.","pos":[1999,2096]},{"content":"Therefore, you must be careful not to over-parallelize a query.","pos":[2097,2160]},{"content":"The most common scenario in which over-parallelization can occur is in nested queries, as shown in the following snippet.","pos":[2162,2283]},{"content":"In this case, it is best to parallelize only the outer data source (customers) unless one or more of the following conditions apply:","pos":[2492,2624]},{"content":"The inner data source (cust.Orders) is known to be very long.","pos":[2628,2689]},{"content":"You are performing an expensive computation on each order.","pos":[2693,2751]},{"content":"(The operation shown in the example is not expensive.)","pos":[2752,2806]},{"pos":[2810,2961],"content":"The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on <ph id=\"ph1\">`cust.Orders`</ph>.","source":"The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on `cust.Orders`."},{"content":"In all cases, the best way to determine the optimum query shape is to test and measure.","pos":[2963,3050]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Measure PLINQ Query Performance<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md)</ept>.","pos":[3051,3206],"source":" For more information, see [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md)."},{"pos":[3211,3249],"content":"Avoid Calls to Non-Thread-Safe Methods","linkify":"Avoid Calls to Non-Thread-Safe Methods","nodes":[{"content":"Avoid Calls to Non-Thread-Safe Methods","pos":[0,38]}]},{"content":"Writing to non-thread-safe instance methods from a PLINQ query can lead to data corruption which may or may not go undetected in your program.","pos":[3251,3393]},{"content":"It can also lead to exceptions.","pos":[3394,3425]},{"content":"In the following example, multiple threads would be attempting to call the <ph id=\"ph1\">`FileStream.Write`</ph> method simultaneously, which is not supported by the class.","pos":[3426,3579],"source":" In the following example, multiple threads would be attempting to call the `FileStream.Write` method simultaneously, which is not supported by the class."},{"pos":[3843,3877],"content":"Limit Calls to Thread-Safe Methods","linkify":"Limit Calls to Thread-Safe Methods","nodes":[{"content":"Limit Calls to Thread-Safe Methods","pos":[0,34]}]},{"content":"Most static methods in the .NET Framework are thread-safe and can be called from multiple threads concurrently.","pos":[3879,3990]},{"content":"However, even in these cases, the synchronization involved can lead to significant slowdown in the query.","pos":[3991,4096]},{"pos":[4100,4338],"content":"[!NOTE]\nYou can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries. Although this method is used in the documentation examples for demonstration purposes, do not use it in PLINQ queries.","leadings":["","> "],"nodes":[{"content":"You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries. Although this method is used in the documentation examples for demonstration purposes, do not use it in PLINQ queries.","pos":[8,236],"nodes":[{"content":"You can test for this yourself by inserting some calls to <ph id=\"ph1\">&lt;xref:System.Console.WriteLine%2A&gt;</ph> in your queries.","pos":[0,109],"source":"You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries."},{"content":"Although this method is used in the documentation examples for demonstration purposes, do not use it in PLINQ queries.","pos":[110,228]}]}]},{"pos":[4343,4380],"content":"Avoid Unnecessary Ordering Operations","linkify":"Avoid Unnecessary Ordering Operations","nodes":[{"content":"Avoid Unnecessary Ordering Operations","pos":[0,37]}]},{"content":"When PLINQ executes a query in parallel, it divides the source sequence into partitions that can be operated on concurrently on multiple threads.","pos":[4382,4527]},{"content":"By default, the order in which the partitions are processed and the results are delivered is not predictable (except for operators such as <ph id=\"ph1\">`OrderBy`</ph>).","pos":[4528,4678],"source":" By default, the order in which the partitions are processed and the results are delivered is not predictable (except for operators such as `OrderBy`)."},{"content":"You can instruct PLINQ to preserve the ordering of any source sequence, but this has a negative impact on performance.","pos":[4679,4797]},{"content":"The best practice, whenever possible, is to structure queries so that they do not rely on order preservation.","pos":[4798,4907]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Order Preservation in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)</ept>.","pos":[4908,5040],"source":" For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)."},{"pos":[5045,5089],"content":"Prefer ForAll to ForEach When It Is Possible","linkify":"Prefer ForAll to ForEach When It Is Possible","nodes":[{"content":"Prefer ForAll to ForEach When It Is Possible","pos":[0,44]}]},{"content":"Although PLINQ executes a query on multiple threads, if you consume the results in a <ph id=\"ph1\">`foreach`</ph> loop (<ph id=\"ph2\">`For Each`</ph> in Visual Basic), then the query results must be merged back into one thread and accessed serially by the enumerator.","pos":[5091,5320],"source":"Although PLINQ executes a query on multiple threads, if you consume the results in a `foreach` loop (`For Each` in Visual Basic), then the query results must be merged back into one thread and accessed serially by the enumerator."},{"content":"In some cases, this is unavoidable; however, whenever possible, use the <ph id=\"ph1\">`ForAll`</ph> method to enable each thread to output its own results, for example, by writing to a thread-safe collection such as <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType&gt;</ph>.","pos":[5321,5602],"source":" In some cases, this is unavoidable; however, whenever possible, use the `ForAll` method to enable each thread to output its own results, for example, by writing to a thread-safe collection such as <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>."},{"pos":[5604,5798],"content":"The same issue applies to <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> In other words, <ph id=\"ph2\">`source.AsParallel().Where().ForAll(...)`</ph> should be strongly preferred to","source":"The same issue applies to <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> In other words, `source.AsParallel().Where().ForAll(...)` should be strongly preferred to"},{"pos":[5800,5853],"content":"<ph id=\"ph1\">`Parallel.ForEach(source.AsParallel().Where(), ...)`</ph>.","source":"`Parallel.ForEach(source.AsParallel().Where(), ...)`."},{"pos":[5858,5892],"content":"Be Aware of Thread Affinity Issues","linkify":"Be Aware of Thread Affinity Issues","nodes":[{"content":"Be Aware of Thread Affinity Issues","pos":[0,34]}]},{"content":"Some technologies, for example, COM interoperability for Single-Threaded Apartment (STA) components, Windows Forms, and Windows Presentation Foundation (WPF), impose thread affinity restrictions that require code to run on a specific thread.","pos":[5894,6135]},{"content":"For example, in both Windows Forms and WPF, a control can only be accessed on the thread on which it was created.","pos":[6136,6249]},{"content":"If you try to access the shared state of a Windows Forms control in a PLINQ query, an exception is raised if you are running in the debugger.","pos":[6250,6391]},{"content":"(This setting can be turned off.) However, if your query is consumed on the UI thread, then you can access the control from the <ph id=\"ph1\">`foreach`</ph> loop that enumerates the query results because that code executes on just one thread.","pos":[6392,6615],"source":" (This setting can be turned off.) However, if your query is consumed on the UI thread, then you can access the control from the `foreach` loop that enumerates the query results because that code executes on just one thread."},{"pos":[6620,6703],"content":"Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel","linkify":"Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel","nodes":[{"content":"Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel","pos":[0,83]}]},{"content":"It is important to keep in mind that individual iterations in a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Linq.ParallelEnumerable.ForAll%2A&gt;</ph> loop may but do not have to execute in parallel.","pos":[6705,7023],"source":"It is important to keep in mind that individual iterations in a <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> or <xref:System.Linq.ParallelEnumerable.ForAll%2A> loop may but do not have to execute in parallel."},{"content":"Therefore, you should avoid writing any code that depends for correctness on parallel execution of iterations or on the execution of iterations in any particular order.","pos":[7024,7192]},{"content":"For example, this code is likely to deadlock:","pos":[7194,7239]},{"content":"In this example, one iteration sets an event, and all other iterations wait on the event.","pos":[8172,8261]},{"content":"None of the waiting iterations can complete until the event-setting iteration has completed.","pos":[8262,8354]},{"content":"However, it is possible that the waiting iterations block all threads that are used to execute the parallel loop, before the event-setting iteration has had a chance to execute.","pos":[8355,8532]},{"content":"This results in a deadlock – the event-setting iteration will never execute, and the waiting iterations will never wake up.","pos":[8533,8656]},{"content":"In particular, one iteration of a parallel loop should never wait on another iteration of the loop to make progress.","pos":[8658,8774]},{"content":"If the parallel loop decides to schedule the iterations sequentially but in the opposite order, a deadlock will occur.","pos":[8775,8893]},{"pos":[8898,8906],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8910,9001],"content":"<bpt id=\"p1\">[</bpt>Parallel LINQ (PLINQ)<ept id=\"p1\">](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)</ept>","source":"[Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)"}]}