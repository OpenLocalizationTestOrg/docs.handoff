{"content":"---\ntitle: \"out parameter modifier - C# Reference\"\nms.custom: seodec18\n\nms.date: 03/26/2019\nhelpviewer_keywords: \n  - \"parameters [C#], out\"\n  - \"out parameters [C#]\"\n---\n# out parameter modifier (C# Reference)\nThe `out` keyword causes arguments to be passed by reference. It makes the formal parameter an alias for the argument, which must be a variable. In other words, any operation on the parameter is made on the argument. It is like the [ref](ref.md) keyword, except that `ref` requires that the variable be initialized before it is passed. It is also like the [in](in-parameter-modifier.md) keyword, except that `in` does not allow the called method to modify the argument value. To use an `out` parameter, both the method definition and the calling method must explicitly use the `out` keyword. For example:  \n  \n[!code-csharp-interactive[cs-out-keyword](../../../../samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/OutParameterModifier.cs#1)]  \n\n> [!NOTE] \n> The `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](out-generic-modifier.md).\n  \nVariables passed as `out` arguments do not have to be initialized before being passed in a method call. However, the called method is required to assign a value before the method returns.  \n  \nThe `in`, `ref`, and `out` keywords are not considered part of the method signature for the purpose of overload resolution. Therefore, methods cannot be overloaded if the only difference is that one method takes a `ref` or `in` argument and the other takes an `out` argument. The following code, for example, will not compile:  \n  \n```csharp\nclass CS0663_Example\n{\n    // Compiler error CS0663: \"Cannot define overloaded \n    // methods that differ only on ref and out\".\n    public void SampleMethod(out int i) { }\n    public void SampleMethod(ref int i) { }\n}\n```\n  \nOverloading is legal, however, if one method takes a `ref`, `in`, or `out` argument and the other has none of those modifiers, like this:  \n  \n[!code-csharp[cs-out-keyword](../../../../samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/OutParameterModifier.cs#2)]  \n\nThe compiler chooses the best overload by matching the parameter modifiers at the call site to the parameter modifiers used in the method call.\n \nProperties are not variables and therefore cannot be passed as `out` parameters.\n  \nYou can't use the `in`, `ref`, and `out` keywords for the following kinds of methods:  \n  \n-   Async methods, which you define by using the [async](../../../csharp/language-reference/keywords/async.md) modifier.  \n  \n-   Iterator methods, which include a [yield return](../../../csharp/language-reference/keywords/yield.md) or `yield break` statement.  \n\n## Declaring `out` parameters   \n\nDeclaring a method with `out` arguments is a classic workaround to return multiple values. Beginning with C# 7.0, consider [tuples](../../tuples.md) for similar scenarios. The following example uses `out` to return three variables with a single method call. Note that the third argument is assigned to null. This enables methods to return values optionally.  \n  \n[!code-csharp-interactive[cs-out-keyword](../../../../samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/OutParameterModifier.cs#3)]  \n\n## Calling a method with an `out` argument\n\nIn C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an `out` argument. The following example declares a variable named `number` before it is passed to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,System.Int32@)) method, which attempts to convert a string to a number.\n\n[!code-csharp-interactive[cs-out-keyword](../../../../samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/OutParameterModifier.cs#4)]  \n\nStarting with C# 7.0, you can declare the `out` variable in the argument list of the method call, rather than in a separate variable declaration. This produces more compact, readable code, and also prevents you from inadvertently assigning a value to the variable before the method call. The following example is like the previous example, except that it defines the `number` variable in the call to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,System.Int32@)) method.\n\n[!code-csharp-interactive[cs-out-keyword](../../../../samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/OutParameterModifier.cs#5)]  \n   \nIn the previous example, the `number` variable is strongly typed as an `int`. You can also declare an implicitly typed local variable, as the following example does.\n\n[!code-csharp-interactive[cs-out-keyword](../../../../samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/OutParameterModifier.cs#6)]  \n   \n## C# Language Specification  \n[!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  \n  \n## See also\n\n- [C# Reference](../../../csharp/language-reference/index.md)\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [C# Keywords](../../../csharp/language-reference/keywords/index.md)\n- [Method Parameters](../../../csharp/language-reference/keywords/method-parameters.md)\n","nodes":[{"pos":[4,166],"embed":true,"restype":"x-metadata","content":"title: \"out parameter modifier - C# Reference\"\nms.custom: seodec18\n\nms.date: 03/26/2019\nhelpviewer_keywords: \n  - \"parameters [C#], out\"\n  - \"out parameters [C#]\"","nodes":[{"content":"out parameter modifier - C# Reference","nodes":[{"pos":[0,37],"content":"out parameter modifier - C# Reference","nodes":[{"content":"out parameter modifier - C# Reference","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[173,210],"content":"out parameter modifier (C# Reference)","linkify":"out parameter modifier (C# Reference)","nodes":[{"content":"out parameter modifier (C# Reference)","pos":[0,37]}]},{"content":"The <ph id=\"ph1\">`out`</ph> keyword causes arguments to be passed by reference.","pos":[211,272],"source":"The `out` keyword causes arguments to be passed by reference."},{"content":"It makes the formal parameter an alias for the argument, which must be a variable.","pos":[273,355]},{"content":"In other words, any operation on the parameter is made on the argument.","pos":[356,427]},{"content":"It is like the <bpt id=\"p1\">[</bpt>ref<ept id=\"p1\">](ref.md)</ept> keyword, except that <ph id=\"ph1\">`ref`</ph> requires that the variable be initialized before it is passed.","pos":[428,546],"source":" It is like the [ref](ref.md) keyword, except that `ref` requires that the variable be initialized before it is passed."},{"content":"It is also like the <bpt id=\"p1\">[</bpt>in<ept id=\"p1\">](in-parameter-modifier.md)</ept> keyword, except that <ph id=\"ph1\">`in`</ph> does not allow the called method to modify the argument value.","pos":[547,686],"source":" It is also like the [in](in-parameter-modifier.md) keyword, except that `in` does not allow the called method to modify the argument value."},{"content":"To use an <ph id=\"ph1\">`out`</ph> parameter, both the method definition and the calling method must explicitly use the <ph id=\"ph2\">`out`</ph> keyword.","pos":[687,802],"source":" To use an `out` parameter, both the method definition and the calling method must explicitly use the `out` keyword."},{"content":"For example:","pos":[803,815]},{"pos":[980,1229],"content":"[!NOTE] \nThe `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](out-generic-modifier.md).","leadings":["","> "],"nodes":[{"content":"The `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](out-generic-modifier.md).","pos":[9,247],"nodes":[{"content":"The <ph id=\"ph1\">`out`</ph> keyword can also be used with a generic type parameter to specify that the type parameter is covariant.","pos":[0,113],"source":"The `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant."},{"content":"For more information on the use of the <ph id=\"ph1\">`out`</ph> keyword in this context, see <bpt id=\"p1\">[</bpt>out (Generic Modifier)<ept id=\"p1\">](out-generic-modifier.md)</ept>.","pos":[114,238],"source":" For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](out-generic-modifier.md)."}]}]},{"content":"Variables passed as <ph id=\"ph1\">`out`</ph> arguments do not have to be initialized before being passed in a method call.","pos":[1233,1336],"source":"Variables passed as `out` arguments do not have to be initialized before being passed in a method call."},{"content":"However, the called method is required to assign a value before the method returns.","pos":[1337,1420]},{"content":"The <ph id=\"ph1\">`in`</ph>, <ph id=\"ph2\">`ref`</ph>, and <ph id=\"ph3\">`out`</ph> keywords are not considered part of the method signature for the purpose of overload resolution.","pos":[1426,1549],"source":"The `in`, `ref`, and `out` keywords are not considered part of the method signature for the purpose of overload resolution."},{"content":"Therefore, methods cannot be overloaded if the only difference is that one method takes a <ph id=\"ph1\">`ref`</ph> or <ph id=\"ph2\">`in`</ph> argument and the other takes an <ph id=\"ph3\">`out`</ph> argument.","pos":[1550,1701],"source":" Therefore, methods cannot be overloaded if the only difference is that one method takes a `ref` or `in` argument and the other takes an `out` argument."},{"content":"The following code, for example, will not compile:","pos":[1702,1752]},{"pos":[1994,2131],"content":"Overloading is legal, however, if one method takes a <ph id=\"ph1\">`ref`</ph>, <ph id=\"ph2\">`in`</ph>, or <ph id=\"ph3\">`out`</ph> argument and the other has none of those modifiers, like this:","source":"Overloading is legal, however, if one method takes a `ref`, `in`, or `out` argument and the other has none of those modifiers, like this:"},{"content":"The compiler chooses the best overload by matching the parameter modifiers at the call site to the parameter modifiers used in the method call.","pos":[2282,2425]},{"pos":[2428,2508],"content":"Properties are not variables and therefore cannot be passed as <ph id=\"ph1\">`out`</ph> parameters.","source":"Properties are not variables and therefore cannot be passed as `out` parameters."},{"pos":[2512,2597],"content":"You can't use the <ph id=\"ph1\">`in`</ph>, <ph id=\"ph2\">`ref`</ph>, and <ph id=\"ph3\">`out`</ph> keywords for the following kinds of methods:","source":"You can't use the `in`, `ref`, and `out` keywords for the following kinds of methods:"},{"pos":[2607,2723],"content":"Async methods, which you define by using the <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](../../../csharp/language-reference/keywords/async.md)</ept> modifier.","source":"Async methods, which you define by using the [async](../../../csharp/language-reference/keywords/async.md) modifier."},{"pos":[2733,2863],"content":"Iterator methods, which include a <bpt id=\"p1\">[</bpt>yield return<ept id=\"p1\">](../../../csharp/language-reference/keywords/yield.md)</ept> or <ph id=\"ph1\">`yield break`</ph> statement.","source":"Iterator methods, which include a [yield return](../../../csharp/language-reference/keywords/yield.md) or `yield break` statement."},{"pos":[2870,2896],"content":"Declaring <ph id=\"ph1\">`out`</ph> parameters","linkify":"Declaring `out` parameters","source":"Declaring `out` parameters"},{"content":"Declaring a method with <ph id=\"ph1\">`out`</ph> arguments is a classic workaround to return multiple values.","pos":[2901,2991],"source":"Declaring a method with `out` arguments is a classic workaround to return multiple values."},{"content":"Beginning with C# 7.0, consider <bpt id=\"p1\">[</bpt>tuples<ept id=\"p1\">](../../tuples.md)</ept> for similar scenarios.","pos":[2992,3072],"source":" Beginning with C# 7.0, consider [tuples](../../tuples.md) for similar scenarios."},{"content":"The following example uses <ph id=\"ph1\">`out`</ph> to return three variables with a single method call.","pos":[3073,3158],"source":" The following example uses `out` to return three variables with a single method call."},{"content":"Note that the third argument is assigned to null.","pos":[3159,3208]},{"content":"This enables methods to return values optionally.","pos":[3209,3258]},{"pos":[3424,3463],"content":"Calling a method with an <ph id=\"ph1\">`out`</ph> argument","linkify":"Calling a method with an `out` argument","source":"Calling a method with an `out` argument"},{"content":"In C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an <ph id=\"ph1\">`out`</ph> argument.","pos":[3465,3578],"source":"In C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an `out` argument."},{"content":"The following example declares a variable named <ph id=\"ph1\">`number`</ph> before it is passed to the <bpt id=\"p1\">[</bpt>Int32.TryParse<ept id=\"p1\">](xref:System.Int32.TryParse(System.String,System.Int32@))</ept> method, which attempts to convert a string to a number.","pos":[3579,3792],"source":" The following example declares a variable named `number` before it is passed to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,System.Int32@)) method, which attempts to convert a string to a number."},{"content":"Starting with C# 7.0, you can declare the <ph id=\"ph1\">`out`</ph> variable in the argument list of the method call, rather than in a separate variable declaration.","pos":[3951,4096],"source":"Starting with C# 7.0, you can declare the `out` variable in the argument list of the method call, rather than in a separate variable declaration."},{"content":"This produces more compact, readable code, and also prevents you from inadvertently assigning a value to the variable before the method call.","pos":[4097,4238]},{"content":"The following example is like the previous example, except that it defines the <ph id=\"ph1\">`number`</ph> variable in the call to the <bpt id=\"p1\">[</bpt>Int32.TryParse<ept id=\"p1\">](xref:System.Int32.TryParse(System.String,System.Int32@))</ept> method.","pos":[4239,4436],"source":" The following example is like the previous example, except that it defines the `number` variable in the call to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,System.Int32@)) method."},{"content":"In the previous example, the <ph id=\"ph1\">`number`</ph> variable is strongly typed as an <ph id=\"ph2\">`int`</ph>.","pos":[4598,4675],"source":"In the previous example, the `number` variable is strongly typed as an `int`."},{"content":"You can also declare an implicitly typed local variable, as the following example does.","pos":[4676,4763]},{"pos":[4928,4953],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[5024,5032],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5036,5095],"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept>","source":"[C# Reference](../../../csharp/language-reference/index.md)"},{"pos":[5098,5164],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[5167,5234],"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/index.md)</ept>","source":"[C# Keywords](../../../csharp/language-reference/keywords/index.md)"},{"pos":[5237,5322],"content":"<bpt id=\"p1\">[</bpt>Method Parameters<ept id=\"p1\">](../../../csharp/language-reference/keywords/method-parameters.md)</ept>","source":"[Method Parameters](../../../csharp/language-reference/keywords/method-parameters.md)"}]}