{"content":"---\ntitle: \"Lambda expressions - C# Programming Guide\"\nms.custom: seodec18\nms.date: 03/14/2019\nhelpviewer_keywords: \n  - \"lambda expressions [C#]\"\n  - \"outer variables [C#]\"\n  - \"statement lambda [C#]\"\n  - \"expression lambda [C#]\"\n  - \"expressions [C#], lambda\"\nms.assetid: 57e3ba27-9a82-4067-aca7-5ca446b7bf93\n---\n# Lambda expressions (C# Programming Guide)\n\nA *lambda expression* is a block of code (an expression or a statement block) that is treated as an object. It can be passed as an argument to methods, and it can also be returned by method calls. Lambda expressions are used extensively for:\n\n- Passing the code that is to be executed to asynchronous methods, such as <xref:System.Threading.Tasks.Task.Run(System.Action)?displayProperty=nameWithType>.\n\n- Writing [LINQ query expressions](../../linq/index.md).\n\n- Creating [expression trees](../concepts/expression-trees/index.md).\n\nLambda expressions are code that can be represented either as a delegate, or as an expression tree that compiles to a delegate. The specific delegate type of a lambda expression depends on its parameters and return value. Lambda expressions that don't return a value correspond to a specific `Action` delegate, depending on its number of parameters. Lambda expressions that return a value correspond to a specific `Func` delegate, depending on its number of parameters. For example, a lambda expression that has two parameters but returns no value corresponds to an <xref:System.Action%602> delegate. A lambda expression that has one parameter and returns a value corresponds to <xref:System.Func%602> delegate.\n\nA lambda expression uses `=>`, the [lambda declaration operator](../../language-reference/operators/lambda-operator.md), to separate the lambda's parameter list from its executable code. To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator, and you put the expression or statement block on the other side. For example, the single-line lambda expression `x => x * x` specifies a parameter that’s named `x` and returns the value of `x` squared. You can assign this expression to a delegate type, as the following example shows:\n\n[!code-csharp-interactive[lambda is delegate](~/samples/snippets/csharp/programming-guide/lambda-expressions/Introduction.cs#Delegate)]\n\nYou also can assign a lambda expression to an expression tree type:\n\n[!code-csharp-interactive[lambda is expression tree](~/samples/snippets/csharp/programming-guide/lambda-expressions/Introduction.cs#ExpressionTree)]\n\nOr you can pass it directly as a method argument:\n\n[!code-csharp-interactive[lambda is argument](~/samples/snippets/csharp/programming-guide/lambda-expressions/Introduction.cs#Argument)]\n\nWhen you use method-based syntax to call the <xref:System.Linq.Enumerable.Select%2A?displayProperty=nameWithType> method in the <xref:System.Linq.Enumerable?displayProperty=nameWithType> class (as you do in LINQ to Objects and LINQ to XML) the parameter is a delegate type <xref:System.Func%602?displayProperty=nameWithType>. A lambda expression is the most convenient way to create that delegate. When you call the <xref:System.Linq.Queryable.Select%2A?displayProperty=nameWithType> method in the <xref:System.Linq.Queryable?displayProperty=nameWithType> class (as you do in LINQ to SQL) the parameter type is an expression tree type [`Expression<Func<TSource,TResult>>`](<xref:System.Linq.Expressions.Expression%601>). Again, a lambda expression is just a very concise way to construct that expression tree. The lambdas allow the `Select` calls to look similar although in fact the type of object created from the lambda is different.\n\nAll restrictions that apply to [anonymous methods](anonymous-methods.md) also apply to lambda expressions.\n  \n## Expression lambdas\n\nA lambda expression with an expression on the right side of the `=>` operator is called an *expression lambda*. Expression lambdas are used extensively in the construction of [expression trees](../concepts/expression-trees/index.md). An expression lambda returns the result of the expression and takes the following basic form:\n\n```csharp\n(input-parameters) => expression\n```\n\nThe parentheses are optional only if the lambda has one input parameter; otherwise they are required.\n\nSpecify zero input parameters with empty parentheses:  \n\n[!code-csharp[zero parameters](~/samples/snippets/csharp/programming-guide/lambda-expressions/ExpressionAndStatementLambdas.cs#ZeroParameters)]\n\nTwo or more input parameters are separated by commas enclosed in parentheses:\n\n[!code-csharp[two parameters](~/samples/snippets/csharp/programming-guide/lambda-expressions/ExpressionAndStatementLambdas.cs#TwoParameters)]\n\nSometimes it's impossible for the compiler to infer the input types. You can specify the types explicitly as shown in the following example:\n\n[!code-csharp[explicitly typed parameters](~/samples/snippets/csharp/programming-guide/lambda-expressions/ExpressionAndStatementLambdas.cs#ExplicitlyTypedParameters)]\n\nInput parameter types must be all explicit or all implicit; otherwise, a [CS0748](../../misc/cs0748.md) compiler error occurs.\n\nThe body of an expression lambda can consist of a method call. However, if you are creating expression trees that are evaluated outside the context of the .NET common language runtime, such as in SQL Server, you should not use method calls in lambda expressions. The methods will have no meaning outside the context of the .NET common language runtime.\n\n## Statement lambdas\n\nA statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:\n\n```csharp  \n(input-parameters) => { statement; }\n```\n\nThe body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.\n\n[!code-csharp-interactive[statement lambda](~/samples/snippets/csharp/programming-guide/lambda-expressions/ExpressionAndStatementLambdas.cs#StatementLambda)]\n\nStatement lambdas, like anonymous methods, cannot be used to create expression trees.\n  \n## Async lambdas\n\nYou can easily create lambda expressions and statements that incorporate asynchronous processing by using the [async](../../language-reference/keywords/async.md) and [await](../../language-reference/keywords/await.md) keywords. For example, the following Windows Forms example contains an event handler that calls and awaits an async method, `ExampleMethodAsync`.\n\n```csharp\npublic partial class Form1 : Form\n{\n    public Form1()\n    {\n        InitializeComponent();\n        button1.Click += button1_Click;\n    }\n\n    private async void button1_Click(object sender, EventArgs e)\n    {\n        await ExampleMethodAsync();\n        textBox1.Text += \"\\r\\nControl returned to Click event handler.\\n\";\n    }\n\n    private async Task ExampleMethodAsync()\n    {\n        // The following line simulates a task-returning asynchronous process.\n        await Task.Delay(1000);\n    }\n}\n```\n\nYou can add the same event handler by using an async lambda. To add this handler, add an `async` modifier before the lambda parameter list, as the following example shows:\n\n```csharp\npublic partial class Form1 : Form\n{\n    public Form1()\n    {\n        InitializeComponent();\n        button1.Click += async (sender, e) =>\n        {\n            await ExampleMethodAsync();\n            textBox1.Text += \"\\r\\nControl returned to Click event handler.\\n\";\n        };\n    }\n\n    private async Task ExampleMethodAsync()\n    {\n        // The following line simulates a task-returning asynchronous process.\n        await Task.Delay(1000);\n    }\n}\n```\n\nFor more information about how to create and use async methods, see [Asynchronous Programming with async and await](../concepts/async/index.md).\n\n## Lambda expressions and tuples\n\nStarting with C# 7.0, the C# language provides built-in support for [tuples](../../tuples.md). You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple. In some cases, the C# compiler uses type inference to determine the types of tuple components.\n\nYou define a tuple by enclosing a comma-delimited list of its components in parentheses. The following example uses tuple with three components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with three components that contains the result of the multiplications.\n\n[!code-csharp-interactive[lambda and tuples](~/samples/snippets/csharp/programming-guide/lambda-expressions/LambdasAndTuples.cs#WithoutComponentName)]\n\nOrdinarily, the fields of a tuple are named `Item1`, `Item2`, etc. You can, however, define a tuple with named components, as the following example does.\n\n[!code-csharp-interactive[lambda and named tuples](~/samples/snippets/csharp/programming-guide/lambda-expressions/LambdasAndTuples.cs#WithComponentName)]\n\nFor more information about C# tuples, see [C# tuple types](../../tuples.md).\n\n## Lambdas with the standard query operators\n\nLINQ to Objects, among other implementations, have an input parameter whose type is one of the <xref:System.Func%601> family of generic delegates. These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate. `Func` delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data. For example, consider the <xref:System.Func%602> delegate type:  \n\n```csharp\npublic delegate TResult Func<in T, out TResult>(T arg)\n```\n\nThe delegate can be instantiated as a `Func<int, bool>` instance where `int` is an input parameter and `bool` is the return value. The return value is always specified in the last type parameter. For example, `Func<int, string, bool>` defines a delegate with two input parameters, `int` and `string`, and a return type of `bool`. The following `Func` delegate, when it's invoked, returns Boolean value that indicates whether the input parameter is equal to five:\n\n[!code-csharp-interactive[Func example](~/samples/snippets/csharp/programming-guide/lambda-expressions/LambdasWithQueryMethods.cs#Func)]\n\nYou can also supply a lambda expression when the argument type is an <xref:System.Linq.Expressions.Expression%601>, for example in the standard query operators that are defined in the <xref:System.Linq.Queryable> type. When you specify an <xref:System.Linq.Expressions.Expression%601> argument, the lambda is compiled to an expression tree.\n  \nThe following example uses the <xref:System.Linq.Enumerable.Count%2A> standard query operator:\n\n[!code-csharp-interactive[Count example](~/samples/snippets/csharp/programming-guide/lambda-expressions/LambdasWithQueryMethods.cs#Count)]\n\nThe compiler can infer the type of the input parameter, or you can also specify it explicitly. This particular lambda expression counts those integers (`n`) which when divided by two have a remainder of 1.\n\nThe following example produces a sequence that contains all elements in the `numbers` array that precede the 9, because that's the first number in the sequence that doesn't meet the condition:\n\n[!code-csharp-interactive[TakeWhile example](~/samples/snippets/csharp/programming-guide/lambda-expressions/LambdasWithQueryMethods.cs#TakeWhile)]\n\nThe following example specifies multiple input parameters by enclosing them in parentheses. The method returns all the elements in the `numbers` array until it encounters a number whose value is less than its ordinal position in the array:\n\n[!code-csharp-interactive[TakeWhile example 2](~/samples/snippets/csharp/programming-guide/lambda-expressions/LambdasWithQueryMethods.cs#TakeWhileWithIndex)]\n\n## Type inference in lambda expressions\n\nWhen writing lambdas, you often don't have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors as described in the C# language specification. For most of the standard query operators, the first input is the type of the elements in the source sequence. If you are querying an `IEnumerable<Customer>`, then the input variable is inferred to be a `Customer` object, which means you have access to its methods and properties:  \n\n```csharp\ncustomers.Where(c => c.City == \"London\");\n```\n\nThe general rules for type inference for lambdas are as follows:\n\n- The lambda must contain the same number of parameters as the delegate type.\n\n- Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.\n\n- The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.\n  \nNote that lambda expressions in themselves don't have a type because the common type system has no intrinsic concept of \"lambda expression.\" However, it's sometimes convenient to speak informally of the \"type\" of a lambda expression. In these cases the type refers to the delegate type or <xref:System.Linq.Expressions.Expression> type to which the lambda expression is converted.\n\n## Variable scope in lambda expressions\n\nLambdas can refer to *outer variables* (see [Anonymous methods](anonymous-methods.md)) that are in scope in the method that defines the lambda expression, or in scope in the type that contains the lambda expression. Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected. An outer variable must be definitely assigned before it can be consumed in a lambda expression. The following example demonstrates these rules:\n\n[!code-csharp[variable scope](~/samples/snippets/csharp/programming-guide/lambda-expressions/VariableScopeWithLambdas.cs#VariableScope)]\n\nThe following rules apply to variable scope in lambda expressions:  \n\n- A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.\n\n- Variables introduced within a lambda expression are not visible in the enclosing method.\n\n- A lambda expression cannot directly capture an [in](../../language-reference/keywords/in-parameter-modifier.md), [ref](../../language-reference/keywords/ref.md), or [out](../../language-reference/keywords/out-parameter-modifier.md) parameter from the enclosing method.\n\n- A [return](../../language-reference/keywords/return.md) statement in a lambda expression doesn't cause the enclosing method to return.\n\n- A lambda expression cannot contain a [goto](../../language-reference/keywords/goto.md), [break](../../language-reference/keywords/break.md), or [continue](../../language-reference/keywords/continue.md) statement if the target of that jump statement is outside the lambda expression block. It's also an error to have a jump statement outside the lambda expression block if the target is inside the block.\n\n## C# language specification\n\nFor more information, see the [Anonymous function expressions](~/_csharplang/spec/expressions.md#anonymous-function-expressions) section of the [C# language specification](~/_csharplang/spec/introduction.md).\n\n## Featured book chapter\n\n[Delegates, Events, and Lambda Expressions](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/ff518994%28v=orm.10%29) in [C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/ff518995%28v=orm.10%29)  \n  \n## See also\n\n- [C# Programming Guide](../index.md)\n- [LINQ (Language-Integrated Query)](../concepts/linq/index.md)\n- [Anonymous Methods](anonymous-methods.md)\n- [Expression Trees](../concepts/expression-trees/index.md)\n- [Local functions compared to lambda expressions](../../local-functions-vs-lambdas.md)\n- [Implicitly typed lambda expressions](../../implicitly-typed-lambda-expressions.md)\n- [Visual Studio 2008 C# Samples (see LINQ Sample Queries files and XQuery program)](https://code.msdn.microsoft.com/Visual-Studio-2008-C-d295cdba)\n- [Recursive lambda expressions](https://blogs.msdn.microsoft.com/madst/2007/05/11/recursive-lambda-expressions/)\n","nodes":[{"pos":[4,310],"embed":true,"restype":"x-metadata","content":"title: \"Lambda expressions - C# Programming Guide\"\nms.custom: seodec18\nms.date: 03/14/2019\nhelpviewer_keywords: \n  - \"lambda expressions [C#]\"\n  - \"outer variables [C#]\"\n  - \"statement lambda [C#]\"\n  - \"expression lambda [C#]\"\n  - \"expressions [C#], lambda\"\nms.assetid: 57e3ba27-9a82-4067-aca7-5ca446b7bf93","nodes":[{"content":"Lambda expressions - C# Programming Guide","nodes":[{"pos":[0,41],"content":"Lambda expressions - C# Programming Guide","nodes":[{"content":"Lambda expressions - C# Programming Guide","pos":[0,41]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[317,358],"content":"Lambda expressions (C# Programming Guide)","linkify":"Lambda expressions (C# Programming Guide)","nodes":[{"content":"Lambda expressions (C# Programming Guide)","pos":[0,41]}]},{"content":"A <bpt id=\"p1\">*</bpt>lambda expression<ept id=\"p1\">*</ept> is a block of code (an expression or a statement block) that is treated as an object.","pos":[360,467],"source":"A *lambda expression* is a block of code (an expression or a statement block) that is treated as an object."},{"content":"It can be passed as an argument to methods, and it can also be returned by method calls.","pos":[468,556]},{"content":"Lambda expressions are used extensively for:","pos":[557,601]},{"pos":[605,761],"content":"Passing the code that is to be executed to asynchronous methods, such as <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Run(System.Action)?displayProperty=nameWithType&gt;</ph>.","source":"Passing the code that is to be executed to asynchronous methods, such as <xref:System.Threading.Tasks.Task.Run(System.Action)?displayProperty=nameWithType>."},{"pos":[765,819],"content":"Writing <bpt id=\"p1\">[</bpt>LINQ query expressions<ept id=\"p1\">](../../linq/index.md)</ept>.","source":"Writing [LINQ query expressions](../../linq/index.md)."},{"pos":[823,890],"content":"Creating <bpt id=\"p1\">[</bpt>expression trees<ept id=\"p1\">](../concepts/expression-trees/index.md)</ept>.","source":"Creating [expression trees](../concepts/expression-trees/index.md)."},{"content":"Lambda expressions are code that can be represented either as a delegate, or as an expression tree that compiles to a delegate.","pos":[892,1019]},{"content":"The specific delegate type of a lambda expression depends on its parameters and return value.","pos":[1020,1113]},{"content":"Lambda expressions that don't return a value correspond to a specific <ph id=\"ph1\">`Action`</ph> delegate, depending on its number of parameters.","pos":[1114,1241],"source":" Lambda expressions that don't return a value correspond to a specific `Action` delegate, depending on its number of parameters."},{"content":"Lambda expressions that return a value correspond to a specific <ph id=\"ph1\">`Func`</ph> delegate, depending on its number of parameters.","pos":[1242,1361],"source":" Lambda expressions that return a value correspond to a specific `Func` delegate, depending on its number of parameters."},{"content":"For example, a lambda expression that has two parameters but returns no value corresponds to an <ph id=\"ph1\">&lt;xref:System.Action%602&gt;</ph> delegate.","pos":[1362,1492],"source":" For example, a lambda expression that has two parameters but returns no value corresponds to an <xref:System.Action%602> delegate."},{"content":"A lambda expression that has one parameter and returns a value corresponds to <ph id=\"ph1\">&lt;xref:System.Func%602&gt;</ph> delegate.","pos":[1493,1603],"source":" A lambda expression that has one parameter and returns a value corresponds to <xref:System.Func%602> delegate."},{"content":"A lambda expression uses <ph id=\"ph1\">`=&gt;`</ph>, the <bpt id=\"p1\">[</bpt>lambda declaration operator<ept id=\"p1\">](../../language-reference/operators/lambda-operator.md)</ept>, to separate the lambda's parameter list from its executable code.","pos":[1605,1791],"source":"A lambda expression uses `=>`, the [lambda declaration operator](../../language-reference/operators/lambda-operator.md), to separate the lambda's parameter list from its executable code."},{"content":"To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator, and you put the expression or statement block on the other side.","pos":[1792,1966]},{"content":"For example, the single-line lambda expression <ph id=\"ph1\">`x =&gt; x * x`</ph> specifies a parameter that’s named <ph id=\"ph2\">`x`</ph> and returns the value of <ph id=\"ph3\">`x`</ph> squared.","pos":[1967,2103],"source":" For example, the single-line lambda expression `x => x * x` specifies a parameter that’s named `x` and returns the value of `x` squared."},{"content":"You can assign this expression to a delegate type, as the following example shows:","pos":[2104,2186]},{"content":"You also can assign a lambda expression to an expression tree type:","pos":[2325,2392]},{"content":"Or you can pass it directly as a method argument:","pos":[2544,2593]},{"content":"When you use method-based syntax to call the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Select%2A?displayProperty=nameWithType&gt;</ph> method in the <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable?displayProperty=nameWithType&gt;</ph> class (as you do in LINQ to Objects and LINQ to XML) the parameter is a delegate type <ph id=\"ph3\">&lt;xref:System.Func%602?displayProperty=nameWithType&gt;</ph>.","pos":[2732,3057],"source":"When you use method-based syntax to call the <xref:System.Linq.Enumerable.Select%2A?displayProperty=nameWithType> method in the <xref:System.Linq.Enumerable?displayProperty=nameWithType> class (as you do in LINQ to Objects and LINQ to XML) the parameter is a delegate type <xref:System.Func%602?displayProperty=nameWithType>."},{"content":"A lambda expression is the most convenient way to create that delegate.","pos":[3058,3129]},{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Linq.Queryable.Select%2A?displayProperty=nameWithType&gt;</ph> method in the <ph id=\"ph2\">&lt;xref:System.Linq.Queryable?displayProperty=nameWithType&gt;</ph> class (as you do in LINQ to SQL) the parameter type is an expression tree type <bpt id=\"p1\">[</bpt><ph id=\"ph3\">`Expression&lt;Func&lt;TSource,TResult&gt;&gt;`</ph><ept id=\"p1\">](&lt;xref:System.Linq.Expressions.Expression%601&gt;)</ept>.","pos":[3130,3452],"source":" When you call the <xref:System.Linq.Queryable.Select%2A?displayProperty=nameWithType> method in the <xref:System.Linq.Queryable?displayProperty=nameWithType> class (as you do in LINQ to SQL) the parameter type is an expression tree type [`Expression<Func<TSource,TResult>>`](<xref:System.Linq.Expressions.Expression%601>)."},{"content":"Again, a lambda expression is just a very concise way to construct that expression tree.","pos":[3453,3541]},{"content":"The lambdas allow the <ph id=\"ph1\">`Select`</ph> calls to look similar although in fact the type of object created from the lambda is different.","pos":[3542,3668],"source":" The lambdas allow the `Select` calls to look similar although in fact the type of object created from the lambda is different."},{"pos":[3670,3776],"content":"All restrictions that apply to <bpt id=\"p1\">[</bpt>anonymous methods<ept id=\"p1\">](anonymous-methods.md)</ept> also apply to lambda expressions.","source":"All restrictions that apply to [anonymous methods](anonymous-methods.md) also apply to lambda expressions."},{"pos":[3783,3801],"content":"Expression lambdas","linkify":"Expression lambdas","nodes":[{"content":"Expression lambdas","pos":[0,18]}]},{"content":"A lambda expression with an expression on the right side of the <ph id=\"ph1\">`=&gt;`</ph> operator is called an <bpt id=\"p1\">*</bpt>expression lambda<ept id=\"p1\">*</ept>.","pos":[3803,3914],"source":"A lambda expression with an expression on the right side of the `=>` operator is called an *expression lambda*."},{"content":"Expression lambdas are used extensively in the construction of <bpt id=\"p1\">[</bpt>expression trees<ept id=\"p1\">](../concepts/expression-trees/index.md)</ept>.","pos":[3915,4036],"source":" Expression lambdas are used extensively in the construction of [expression trees](../concepts/expression-trees/index.md)."},{"content":"An expression lambda returns the result of the expression and takes the following basic form:","pos":[4037,4130]},{"content":"The parentheses are optional only if the lambda has one input parameter; otherwise they are required.","pos":[4180,4281]},{"content":"Specify zero input parameters with empty parentheses:","pos":[4283,4336]},{"content":"Two or more input parameters are separated by commas enclosed in parentheses:","pos":[4485,4562]},{"content":"Sometimes it's impossible for the compiler to infer the input types.","pos":[4707,4775]},{"content":"You can specify the types explicitly as shown in the following example:","pos":[4776,4847]},{"pos":[5017,5143],"content":"Input parameter types must be all explicit or all implicit; otherwise, a <bpt id=\"p1\">[</bpt>CS0748<ept id=\"p1\">](../../misc/cs0748.md)</ept> compiler error occurs.","source":"Input parameter types must be all explicit or all implicit; otherwise, a [CS0748](../../misc/cs0748.md) compiler error occurs."},{"content":"The body of an expression lambda can consist of a method call.","pos":[5145,5207]},{"content":"However, if you are creating expression trees that are evaluated outside the context of the .NET common language runtime, such as in SQL Server, you should not use method calls in lambda expressions.","pos":[5208,5407]},{"content":"The methods will have no meaning outside the context of the .NET common language runtime.","pos":[5408,5497]},{"pos":[5502,5519],"content":"Statement lambdas","linkify":"Statement lambdas","nodes":[{"content":"Statement lambdas","pos":[0,17]}]},{"content":"A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:","pos":[5521,5622]},{"content":"The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.","pos":[5678,5817]},{"content":"Statement lambdas, like anonymous methods, cannot be used to create expression trees.","pos":[5978,6063]},{"pos":[6070,6083],"content":"Async lambdas","linkify":"Async lambdas","nodes":[{"content":"Async lambdas","pos":[0,13]}]},{"content":"You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](../../language-reference/keywords/async.md)</ept> and <bpt id=\"p2\">[</bpt>await<ept id=\"p2\">](../../language-reference/keywords/await.md)</ept> keywords.","pos":[6085,6312],"source":"You can easily create lambda expressions and statements that incorporate asynchronous processing by using the [async](../../language-reference/keywords/async.md) and [await](../../language-reference/keywords/await.md) keywords."},{"content":"For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <ph id=\"ph1\">`ExampleMethodAsync`</ph>.","pos":[6313,6448],"source":" For example, the following Windows Forms example contains an event handler that calls and awaits an async method, `ExampleMethodAsync`."},{"content":"You can add the same event handler by using an async lambda.","pos":[6962,7022]},{"content":"To add this handler, add an <ph id=\"ph1\">`async`</ph> modifier before the lambda parameter list, as the following example shows:","pos":[7023,7133],"source":" To add this handler, add an `async` modifier before the lambda parameter list, as the following example shows:"},{"pos":[7604,7748],"content":"For more information about how to create and use async methods, see <bpt id=\"p1\">[</bpt>Asynchronous Programming with async and await<ept id=\"p1\">](../concepts/async/index.md)</ept>.","source":"For more information about how to create and use async methods, see [Asynchronous Programming with async and await](../concepts/async/index.md)."},{"pos":[7753,7782],"content":"Lambda expressions and tuples","linkify":"Lambda expressions and tuples","nodes":[{"content":"Lambda expressions and tuples","pos":[0,29]}]},{"content":"Starting with C# 7.0, the C# language provides built-in support for <bpt id=\"p1\">[</bpt>tuples<ept id=\"p1\">](../../tuples.md)</ept>.","pos":[7784,7878],"source":"Starting with C# 7.0, the C# language provides built-in support for [tuples](../../tuples.md)."},{"content":"You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple.","pos":[7879,7993]},{"content":"In some cases, the C# compiler uses type inference to determine the types of tuple components.","pos":[7994,8088]},{"content":"You define a tuple by enclosing a comma-delimited list of its components in parentheses.","pos":[8090,8178]},{"content":"The following example uses tuple with three components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with three components that contains the result of the multiplications.","pos":[8179,8403]},{"pos":[8557,8710],"content":"Ordinarily, the fields of a tuple are named <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph>, etc. You can, however, define a tuple with named components, as the following example does.","source":"Ordinarily, the fields of a tuple are named `Item1`, `Item2`, etc. You can, however, define a tuple with named components, as the following example does."},{"pos":[8867,8943],"content":"For more information about C# tuples, see <bpt id=\"p1\">[</bpt>C# tuple types<ept id=\"p1\">](../../tuples.md)</ept>.","source":"For more information about C# tuples, see [C# tuple types](../../tuples.md)."},{"pos":[8948,8989],"content":"Lambdas with the standard query operators","linkify":"Lambdas with the standard query operators","nodes":[{"content":"Lambdas with the standard query operators","pos":[0,41]}]},{"content":"LINQ to Objects, among other implementations, have an input parameter whose type is one of the <ph id=\"ph1\">&lt;xref:System.Func%601&gt;</ph> family of generic delegates.","pos":[8991,9137],"source":"LINQ to Objects, among other implementations, have an input parameter whose type is one of the <xref:System.Func%601> family of generic delegates."},{"content":"These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate.","pos":[9138,9261]},{"content":"<ph id=\"ph1\">`Func`</ph> delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data.","pos":[9262,9395],"source":"`Func` delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data."},{"content":"For example, consider the <ph id=\"ph1\">&lt;xref:System.Func%602&gt;</ph> delegate type:","pos":[9396,9459],"source":" For example, consider the <xref:System.Func%602> delegate type:"},{"content":"The delegate can be instantiated as a <ph id=\"ph1\">`Func&lt;int, bool&gt;`</ph> instance where <ph id=\"ph2\">`int`</ph> is an input parameter and <ph id=\"ph3\">`bool`</ph> is the return value.","pos":[9533,9663],"source":"The delegate can be instantiated as a `Func<int, bool>` instance where `int` is an input parameter and `bool` is the return value."},{"content":"The return value is always specified in the last type parameter.","pos":[9664,9728]},{"content":"For example, <ph id=\"ph1\">`Func&lt;int, string, bool&gt;`</ph> defines a delegate with two input parameters, <ph id=\"ph2\">`int`</ph> and <ph id=\"ph3\">`string`</ph>, and a return type of <ph id=\"ph4\">`bool`</ph>.","pos":[9729,9862],"source":" For example, `Func<int, string, bool>` defines a delegate with two input parameters, `int` and `string`, and a return type of `bool`."},{"content":"The following <ph id=\"ph1\">`Func`</ph> delegate, when it's invoked, returns Boolean value that indicates whether the input parameter is equal to five:","pos":[9863,9995],"source":" The following `Func` delegate, when it's invoked, returns Boolean value that indicates whether the input parameter is equal to five:"},{"content":"You can also supply a lambda expression when the argument type is an <ph id=\"ph1\">&lt;xref:System.Linq.Expressions.Expression%601&gt;</ph>, for example in the standard query operators that are defined in the <ph id=\"ph2\">&lt;xref:System.Linq.Queryable&gt;</ph> type.","pos":[10135,10353],"source":"You can also supply a lambda expression when the argument type is an <xref:System.Linq.Expressions.Expression%601>, for example in the standard query operators that are defined in the <xref:System.Linq.Queryable> type."},{"content":"When you specify an <ph id=\"ph1\">&lt;xref:System.Linq.Expressions.Expression%601&gt;</ph> argument, the lambda is compiled to an expression tree.","pos":[10354,10475],"source":" When you specify an <xref:System.Linq.Expressions.Expression%601> argument, the lambda is compiled to an expression tree."},{"pos":[10479,10573],"content":"The following example uses the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Count%2A&gt;</ph> standard query operator:","source":"The following example uses the <xref:System.Linq.Enumerable.Count%2A> standard query operator:"},{"content":"The compiler can infer the type of the input parameter, or you can also specify it explicitly.","pos":[10715,10809]},{"content":"This particular lambda expression counts those integers (<ph id=\"ph1\">`n`</ph>) which when divided by two have a remainder of 1.","pos":[10810,10920],"source":" This particular lambda expression counts those integers (`n`) which when divided by two have a remainder of 1."},{"pos":[10922,11114],"content":"The following example produces a sequence that contains all elements in the <ph id=\"ph1\">`numbers`</ph> array that precede the 9, because that's the first number in the sequence that doesn't meet the condition:","source":"The following example produces a sequence that contains all elements in the `numbers` array that precede the 9, because that's the first number in the sequence that doesn't meet the condition:"},{"content":"The following example specifies multiple input parameters by enclosing them in parentheses.","pos":[11264,11355]},{"content":"The method returns all the elements in the <ph id=\"ph1\">`numbers`</ph> array until it encounters a number whose value is less than its ordinal position in the array:","pos":[11356,11503],"source":" The method returns all the elements in the `numbers` array until it encounters a number whose value is less than its ordinal position in the array:"},{"pos":[11667,11703],"content":"Type inference in lambda expressions","linkify":"Type inference in lambda expressions","nodes":[{"content":"Type inference in lambda expressions","pos":[0,36]}]},{"content":"When writing lambdas, you often don't have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors as described in the C# language specification.","pos":[11705,11942]},{"content":"For most of the standard query operators, the first input is the type of the elements in the source sequence.","pos":[11943,12052]},{"content":"If you are querying an <ph id=\"ph1\">`IEnumerable&lt;Customer&gt;`</ph>, then the input variable is inferred to be a <ph id=\"ph2\">`Customer`</ph> object, which means you have access to its methods and properties:","pos":[12053,12222],"source":" If you are querying an `IEnumerable<Customer>`, then the input variable is inferred to be a `Customer` object, which means you have access to its methods and properties:"},{"content":"The general rules for type inference for lambdas are as follows:","pos":[12283,12347]},{"content":"The lambda must contain the same number of parameters as the delegate type.","pos":[12351,12426]},{"content":"Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.","pos":[12430,12536]},{"content":"The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.","pos":[12540,12641]},{"content":"Note that lambda expressions in themselves don't have a type because the common type system has no intrinsic concept of \"lambda expression.\"","pos":[12645,12785]},{"content":"However, it's sometimes convenient to speak informally of the \"type\" of a lambda expression.","pos":[12786,12878]},{"content":"In these cases the type refers to the delegate type or <ph id=\"ph1\">&lt;xref:System.Linq.Expressions.Expression&gt;</ph> type to which the lambda expression is converted.","pos":[12879,13025],"source":" In these cases the type refers to the delegate type or <xref:System.Linq.Expressions.Expression> type to which the lambda expression is converted."},{"pos":[13030,13066],"content":"Variable scope in lambda expressions","linkify":"Variable scope in lambda expressions","nodes":[{"content":"Variable scope in lambda expressions","pos":[0,36]}]},{"content":"Lambdas can refer to <bpt id=\"p1\">*</bpt>outer variables<ept id=\"p1\">*</ept> (see <bpt id=\"p2\">[</bpt>Anonymous methods<ept id=\"p2\">](anonymous-methods.md)</ept>) that are in scope in the method that defines the lambda expression, or in scope in the type that contains the lambda expression.","pos":[13068,13283],"source":"Lambdas can refer to *outer variables* (see [Anonymous methods](anonymous-methods.md)) that are in scope in the method that defines the lambda expression, or in scope in the type that contains the lambda expression."},{"content":"Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected.","pos":[13284,13450]},{"content":"An outer variable must be definitely assigned before it can be consumed in a lambda expression.","pos":[13451,13546]},{"content":"The following example demonstrates these rules:","pos":[13547,13594]},{"content":"The following rules apply to variable scope in lambda expressions:","pos":[13734,13800]},{"content":"A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.","pos":[13806,13942]},{"content":"Variables introduced within a lambda expression are not visible in the enclosing method.","pos":[13946,14034]},{"pos":[14038,14306],"content":"A lambda expression cannot directly capture an <bpt id=\"p1\">[</bpt>in<ept id=\"p1\">](../../language-reference/keywords/in-parameter-modifier.md)</ept>, <bpt id=\"p2\">[</bpt>ref<ept id=\"p2\">](../../language-reference/keywords/ref.md)</ept>, or <bpt id=\"p3\">[</bpt>out<ept id=\"p3\">](../../language-reference/keywords/out-parameter-modifier.md)</ept> parameter from the enclosing method.","source":"A lambda expression cannot directly capture an [in](../../language-reference/keywords/in-parameter-modifier.md), [ref](../../language-reference/keywords/ref.md), or [out](../../language-reference/keywords/out-parameter-modifier.md) parameter from the enclosing method."},{"pos":[14310,14444],"content":"A <bpt id=\"p1\">[</bpt>return<ept id=\"p1\">](../../language-reference/keywords/return.md)</ept> statement in a lambda expression doesn't cause the enclosing method to return.","source":"A [return](../../language-reference/keywords/return.md) statement in a lambda expression doesn't cause the enclosing method to return."},{"content":"A lambda expression cannot contain a <bpt id=\"p1\">[</bpt>goto<ept id=\"p1\">](../../language-reference/keywords/goto.md)</ept>, <bpt id=\"p2\">[</bpt>break<ept id=\"p2\">](../../language-reference/keywords/break.md)</ept>, or <bpt id=\"p3\">[</bpt>continue<ept id=\"p3\">](../../language-reference/keywords/continue.md)</ept> statement if the target of that jump statement is outside the lambda expression block.","pos":[14448,14736],"source":"A lambda expression cannot contain a [goto](../../language-reference/keywords/goto.md), [break](../../language-reference/keywords/break.md), or [continue](../../language-reference/keywords/continue.md) statement if the target of that jump statement is outside the lambda expression block."},{"content":"It's also an error to have a jump statement outside the lambda expression block if the target is inside the block.","pos":[14737,14851]},{"pos":[14856,14881],"content":"C# language specification","linkify":"C# language specification","nodes":[{"content":"C# language specification","pos":[0,25]}]},{"pos":[14883,15091],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Anonymous function expressions<ept id=\"p1\">](~/_csharplang/spec/expressions.md#anonymous-function-expressions)</ept> section of the <bpt id=\"p2\">[</bpt>C# language specification<ept id=\"p2\">](~/_csharplang/spec/introduction.md)</ept>.","source":"For more information, see the [Anonymous function expressions](~/_csharplang/spec/expressions.md#anonymous-function-expressions) section of the [C# language specification](~/_csharplang/spec/introduction.md)."},{"pos":[15096,15117],"content":"Featured book chapter","linkify":"Featured book chapter","nodes":[{"content":"Featured book chapter","pos":[0,21]}]},{"pos":[15119,15448],"content":"<bpt id=\"p1\">[</bpt>Delegates, Events, and Lambda Expressions<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/ff518994%28v=orm.10%29)</ept> in <bpt id=\"p2\">[</bpt>C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers<ept id=\"p2\">](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/ff518995%28v=orm.10%29)</ept>","source":"[Delegates, Events, and Lambda Expressions](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/ff518994%28v=orm.10%29) in [C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/ff518995%28v=orm.10%29)"},{"pos":[15457,15465],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[15469,15504],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../index.md)</ept>","source":"[C# Programming Guide](../index.md)"},{"pos":[15507,15568],"content":"<bpt id=\"p1\">[</bpt>LINQ (Language-Integrated Query)<ept id=\"p1\">](../concepts/linq/index.md)</ept>","source":"[LINQ (Language-Integrated Query)](../concepts/linq/index.md)"},{"pos":[15571,15612],"content":"<bpt id=\"p1\">[</bpt>Anonymous Methods<ept id=\"p1\">](anonymous-methods.md)</ept>","source":"[Anonymous Methods](anonymous-methods.md)"},{"pos":[15615,15672],"content":"<bpt id=\"p1\">[</bpt>Expression Trees<ept id=\"p1\">](../concepts/expression-trees/index.md)</ept>","source":"[Expression Trees](../concepts/expression-trees/index.md)"},{"pos":[15675,15760],"content":"<bpt id=\"p1\">[</bpt>Local functions compared to lambda expressions<ept id=\"p1\">](../../local-functions-vs-lambdas.md)</ept>","source":"[Local functions compared to lambda expressions](../../local-functions-vs-lambdas.md)"},{"pos":[15763,15846],"content":"<bpt id=\"p1\">[</bpt>Implicitly typed lambda expressions<ept id=\"p1\">](../../implicitly-typed-lambda-expressions.md)</ept>","source":"[Implicitly typed lambda expressions](../../implicitly-typed-lambda-expressions.md)"},{"pos":[15849,15994],"content":"<bpt id=\"p1\">[</bpt>Visual Studio 2008 C# Samples (see LINQ Sample Queries files and XQuery program)<ept id=\"p1\">](https://code.msdn.microsoft.com/Visual-Studio-2008-C-d295cdba)</ept>","source":"[Visual Studio 2008 C# Samples (see LINQ Sample Queries files and XQuery program)](https://code.msdn.microsoft.com/Visual-Studio-2008-C-d295cdba)"},{"pos":[15997,16108],"content":"<bpt id=\"p1\">[</bpt>Recursive lambda expressions<ept id=\"p1\">](https://blogs.msdn.microsoft.com/madst/2007/05/11/recursive-lambda-expressions/)</ept>","source":"[Recursive lambda expressions](https://blogs.msdn.microsoft.com/madst/2007/05/11/recursive-lambda-expressions/)"}]}