{"content":"---\ntitle: \"BlockingCollection Overview\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"BlockingCollection, overview\"\nms.assetid: 987ea3d7-0ad5-4238-8b64-331ce4eb3f0b\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# BlockingCollection Overview\n<xref:System.Collections.Concurrent.BlockingCollection%601> is a thread-safe collection class that provides the following features:  \n  \n-   An implementation of the Producer-Consumer pattern.  \n  \n-   Concurrent adding and taking of items from multiple threads.  \n  \n-   Optional maximum capacity.  \n  \n-   Insertion and removal operations that block when collection is empty or full.  \n  \n-   Insertion and removal \"try\" operations that do not block or that block up to a specified period of time.  \n  \n-   Encapsulates any collection type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>  \n  \n-   Cancellation with cancellation tokens.  \n  \n-   Two kinds of enumeration with `foreach` (`For Each` in Visual Basic):  \n  \n    1.  Read-only enumeration.  \n  \n    2.  Enumeration that removes items as they are enumerated.  \n  \n## Bounding and Blocking Support  \n <xref:System.Collections.Concurrent.BlockingCollection%601> supports bounding and blocking. Bounding means you can set the maximum capacity of the collection. Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.  \n  \n Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed. Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item. A producing thread can call <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> to indicate that no more items will be added. Consumers monitor the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property to know when the collection is empty and no more items will be added. The following example shows a simple BlockingCollection with a bounded capacity of 100. A producer task adds items to the collection as long as some external condition is true, and then calls <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A>. The consumer task takes items until the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property is true.  \n  \n [!code-csharp[CDS_BlockingCollection#04](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#04)]\n [!code-vb[CDS_BlockingCollection#04](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#04)]  \n  \n For a complete example, see [How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md).  \n  \n## Timed Blocking Operations  \n In timed blocking <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> operations on bounded collections, the method tries to add or take an item. If an item is available it is placed into the variable that was passed in by reference, and the method returns true. If no item is retrieved after a specified time-out period the method returns false. The thread is then free to do some other useful work before trying again to access the collection. For an example of timed blocking access, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md).  \n  \n## Cancelling Add and Take Operations  \n Add and Take operations are typically performed in a loop. You can cancel a loop by passing in a <xref:System.Threading.CancellationToken> to the <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> or <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> method, and then checking the value of the token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on each iteration. If the value is true, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop. The following example shows an overload of <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> that takes a cancellation token, and the code that uses it:  \n  \n [!code-csharp[CDS_BlockingCollection#05](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#05)]\n [!code-vb[CDS_BlockingCollection#05](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#05)]  \n  \n For an example of how to add cancellation support, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md).  \n  \n## Specifying the Collection Type  \n When you create a <xref:System.Collections.Concurrent.BlockingCollection%601>, you can specify not only the bounded capacity but also the type of collection to use. For example, you could specify a <xref:System.Collections.Concurrent.ConcurrentQueue%601> for first in-first out (FIFO) behavior, or a <xref:System.Collections.Concurrent.ConcurrentStack%601> for last in-first out (LIFO) behavior. You can use any collection class that implements the <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interface. The default collection type for <xref:System.Collections.Concurrent.BlockingCollection%601> is <xref:System.Collections.Concurrent.ConcurrentQueue%601>. The following code example shows how to create a <xref:System.Collections.Concurrent.BlockingCollection%601> of strings that has a capacity of 1000 and uses a <xref:System.Collections.Concurrent.ConcurrentBag%601>:  \n  \n```vb  \nDim bc = New BlockingCollection(Of String)(New ConcurrentBag(Of String()), 1000)  \n```  \n  \n```csharp  \nBlockingCollection<string> bc = new BlockingCollection<string>(new ConcurrentBag<string>(), 1000 );  \n```  \n  \n For more information, see [How to: Add Bounding and Blocking Functionality to a Collection](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md).  \n  \n## IEnumerable Support  \n <xref:System.Collections.Concurrent.BlockingCollection%601> provides a <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> method that enables consumers to use `foreach` (`For Each` in Visual Basic) to remove items until the collection is completed, which means it is empty and no more items will be added. For more information, see [How to: Use ForEach to Remove Items in a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md).  \n  \n## Using Many BlockingCollections As One  \n For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <xref:System.Collections.Concurrent.BlockingCollection%601> and use the static methods such as <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> that will add to or take from any of the collections in the array. If one collection is blocking, the method immediately tries another until it finds one that can perform the operation. For more information, see [How to: Use Arrays of Blocking Collections in a Pipeline](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md).  \n  \n## See also\n\n- <xref:System.Collections.Concurrent?displayProperty=nameWithType>\n- [Collections and Data Structures](../../../../docs/standard/collections/index.md)\n- [Thread-Safe Collections](../../../../docs/standard/collections/thread-safe/index.md)\n","nodes":[{"pos":[4,270],"embed":true,"restype":"x-metadata","content":"title: \"BlockingCollection Overview\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"BlockingCollection, overview\"\nms.assetid: 987ea3d7-0ad5-4238-8b64-331ce4eb3f0b\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"BlockingCollection Overview","nodes":[{"pos":[0,27],"content":"BlockingCollection Overview","nodes":[{"content":"BlockingCollection Overview","pos":[0,27]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[277,304],"content":"BlockingCollection Overview","linkify":"BlockingCollection Overview","nodes":[{"content":"BlockingCollection Overview","pos":[0,27]}]},{"pos":[305,436],"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is a thread-safe collection class that provides the following features:","source":"<xref:System.Collections.Concurrent.BlockingCollection%601> is a thread-safe collection class that provides the following features:"},{"content":"An implementation of the Producer-Consumer pattern.","pos":[446,497]},{"content":"Concurrent adding and taking of items from multiple threads.","pos":[507,567]},{"content":"Optional maximum capacity.","pos":[577,603]},{"content":"Insertion and removal operations that block when collection is empty or full.","pos":[613,690]},{"content":"Insertion and removal \"try\" operations that do not block or that block up to a specified period of time.","pos":[700,804]},{"pos":[814,931],"content":"Encapsulates any collection type that implements <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>","source":"Encapsulates any collection type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>"},{"content":"Cancellation with cancellation tokens.","pos":[941,979]},{"pos":[989,1058],"content":"Two kinds of enumeration with <ph id=\"ph1\">`foreach`</ph> (<ph id=\"ph2\">`For Each`</ph> in Visual Basic):","source":"Two kinds of enumeration with `foreach` (`For Each` in Visual Basic):"},{"content":"Read-only enumeration.","pos":[1072,1094]},{"content":"Enumeration that removes items as they are enumerated.","pos":[1108,1162]},{"pos":[1171,1200],"content":"Bounding and Blocking Support","linkify":"Bounding and Blocking Support","nodes":[{"content":"Bounding and Blocking Support","pos":[0,29]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> supports bounding and blocking.","pos":[1204,1295],"source":"<xref:System.Collections.Concurrent.BlockingCollection%601> supports bounding and blocking."},{"content":"Bounding means you can set the maximum capacity of the collection.","pos":[1296,1362]},{"content":"Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.","pos":[1363,1575]},{"content":"Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.","pos":[1582,1774]},{"content":"Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.","pos":[1775,1925]},{"content":"A producing thread can call <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph> to indicate that no more items will be added.","pos":[1926,2077],"source":" A producing thread can call <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> to indicate that no more items will be added."},{"content":"Consumers monitor the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> property to know when the collection is empty and no more items will be added.","pos":[2078,2253],"source":" Consumers monitor the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property to know when the collection is empty and no more items will be added."},{"content":"The following example shows a simple BlockingCollection with a bounded capacity of 100.","pos":[2254,2341]},{"content":"A producer task adds items to the collection as long as some external condition is true, and then calls <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph>.","pos":[2342,2524],"source":" A producer task adds items to the collection as long as some external condition is true, and then calls <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A>."},{"content":"The consumer task takes items until the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> property is true.","pos":[2525,2657],"source":" The consumer task takes items until the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property is true."},{"pos":[2963,3139],"content":"For a complete example, see <bpt id=\"p1\">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)</ept>.","source":"For a complete example, see [How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)."},{"pos":[3148,3173],"content":"Timed Blocking Operations","linkify":"Timed Blocking Operations","nodes":[{"content":"Timed Blocking Operations","pos":[0,25]}]},{"content":"In timed blocking <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> operations on bounded collections, the method tries to add or take an item.","pos":[3177,3415],"source":"In timed blocking <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> operations on bounded collections, the method tries to add or take an item."},{"content":"If an item is available it is placed into the variable that was passed in by reference, and the method returns true.","pos":[3416,3532]},{"content":"If no item is retrieved after a specified time-out period the method returns false.","pos":[3533,3616]},{"content":"The thread is then free to do some other useful work before trying again to access the collection.","pos":[3617,3715]},{"content":"For an example of timed blocking access, see the second example in <bpt id=\"p1\">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)</ept>.","pos":[3716,3931],"source":" For an example of timed blocking access, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)."},{"pos":[3940,3974],"content":"Cancelling Add and Take Operations","linkify":"Cancelling Add and Take Operations","nodes":[{"content":"Cancelling Add and Take Operations","pos":[0,34]}]},{"content":"Add and Take operations are typically performed in a loop.","pos":[3978,4036]},{"content":"You can cancel a loop by passing in a <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken&gt;</ph> to the <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method, and then checking the value of the token's <ph id=\"ph4\">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property on each iteration.","pos":[4037,4415],"source":" You can cancel a loop by passing in a <xref:System.Threading.CancellationToken> to the <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> or <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> method, and then checking the value of the token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on each iteration."},{"content":"If the value is true, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.","pos":[4416,4545]},{"content":"The following example shows an overload of <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> that takes a cancellation token, and the code that uses it:","pos":[4546,4718],"source":" The following example shows an overload of <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> that takes a cancellation token, and the code that uses it:"},{"pos":[5024,5249],"content":"For an example of how to add cancellation support, see the second example in <bpt id=\"p1\">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)</ept>.","source":"For an example of how to add cancellation support, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)."},{"pos":[5258,5288],"content":"Specifying the Collection Type","linkify":"Specifying the Collection Type","nodes":[{"content":"Specifying the Collection Type","pos":[0,30]}]},{"content":"When you create a <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, you can specify not only the bounded capacity but also the type of collection to use.","pos":[5292,5456],"source":"When you create a <xref:System.Collections.Concurrent.BlockingCollection%601>, you can specify not only the bounded capacity but also the type of collection to use."},{"content":"For example, you could specify a <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> for first in-first out (FIFO) behavior, or a <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> for last in-first out (LIFO) behavior.","pos":[5457,5687],"source":" For example, you could specify a <xref:System.Collections.Concurrent.ConcurrentQueue%601> for first in-first out (FIFO) behavior, or a <xref:System.Collections.Concurrent.ConcurrentStack%601> for last in-first out (LIFO) behavior."},{"content":"You can use any collection class that implements the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.","pos":[5688,5820],"source":" You can use any collection class that implements the <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interface."},{"content":"The default collection type for <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.","pos":[5821,5973],"source":" The default collection type for <xref:System.Collections.Concurrent.BlockingCollection%601> is <xref:System.Collections.Concurrent.ConcurrentQueue%601>."},{"content":"The following code example shows how to create a <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> of strings that has a capacity of 1000 and uses a <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph>:","pos":[5974,6188],"source":" The following code example shows how to create a <xref:System.Collections.Concurrent.BlockingCollection%601> of strings that has a capacity of 1000 and uses a <xref:System.Collections.Concurrent.ConcurrentBag%601>:"},{"pos":[6418,6597],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Add Bounding and Blocking Functionality to a Collection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)</ept>.","source":"For more information, see [How to: Add Bounding and Blocking Functionality to a Collection](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)."},{"pos":[6606,6625],"content":"IEnumerable Support","linkify":"IEnumerable Support","nodes":[{"content":"IEnumerable Support","pos":[0,19]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> provides a <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph> method that enables consumers to use <ph id=\"ph3\">`foreach`</ph> (<ph id=\"ph4\">`For Each`</ph> in Visual Basic) to remove items until the collection is completed, which means it is empty and no more items will be added.","pos":[6629,6969],"source":"<xref:System.Collections.Concurrent.BlockingCollection%601> provides a <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> method that enables consumers to use `foreach` (`For Each` in Visual Basic) to remove items until the collection is completed, which means it is empty and no more items will be added."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)</ept>.","pos":[6970,7141],"source":" For more information, see [How to: Use ForEach to Remove Items in a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)."},{"pos":[7150,7187],"content":"Using Many BlockingCollections As One","linkify":"Using Many BlockingCollections As One","nodes":[{"content":"Using Many BlockingCollections As One","pos":[0,37]}]},{"content":"For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> and use the static methods such as <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A&gt;</ph> that will add to or take from any of the collections in the array.","pos":[7191,7624],"source":"For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <xref:System.Collections.Concurrent.BlockingCollection%601> and use the static methods such as <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> that will add to or take from any of the collections in the array."},{"content":"If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.","pos":[7625,7743]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)</ept>.","pos":[7744,7924],"source":" For more information, see [How to: Use Arrays of Blocking Collections in a Pipeline](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)."},{"pos":[7933,7941],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8013,8094],"content":"<bpt id=\"p1\">[</bpt>Collections and Data Structures<ept id=\"p1\">](../../../../docs/standard/collections/index.md)</ept>","source":"[Collections and Data Structures](../../../../docs/standard/collections/index.md)"},{"pos":[8097,8182],"content":"<bpt id=\"p1\">[</bpt>Thread-Safe Collections<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/index.md)</ept>","source":"[Thread-Safe Collections](../../../../docs/standard/collections/thread-safe/index.md)"}]}