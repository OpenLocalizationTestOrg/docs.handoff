{"content":"---\ntitle: \"Custom Encoders | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f\ncaps.latest.revision: 15\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Custom Encoders\nThis topic discusses how to create custom encoders.  \n  \n In [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)], you use a *binding* to specify how to transfer data across a network between endpoints. A binding is made up of a sequence of *binding elements*. A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element. A message encoder is represented by a message encoding binding element. Three message encoders are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.  \n  \n A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.  \n  \n Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation. Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer. Transports (for example HTTP) format the message according to the requirements of the transport standard. Encoders (for example Text Xml) just encode the message.  \n  \n When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding. However, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services can be made accessible through multiple endpoints, each with a different message encoder. When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints. Client applications can then choose the endpoint that is best for them. Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.  \n  \n## System-Provided Encoders  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides several system-provided bindings that are designed to cover the most common application scenarios. Each of these bindings combine a transport, message encoder, and other options (security, for example). This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], or create your own custom encoder. The text message encoder supports both a plain XML encoding as well as SOAP encodings. The plain XML encoding mode of the text message encoder is called the POX (\"Plain Old XML\") encoder to distinguish it from the text-based SOAP encoding.  \n  \n [!INCLUDE[crabout](../../../../includes/crabout-md.md)] the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md).  \n  \n## How to Work with System-Provided Encoders  \n An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.  \n  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:  \n  \n-   <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages. A Web service or Web service client can generally understand textual XML. However, transmitting large blocks of binary data as text is not efficient.  \n  \n-   <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages. This is most efficient of the encoding options, but the least interoperable, because it is only supported by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] endpoints.  \n  \n-   <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding. MTOM is an efficient technology for transmitting binary data in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] messages. The MTOM encoder attempts to balance between efficiency and interoperability. The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.  \n  \n The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>. The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoder> instance. Typically, there is only a single instance. However if sessions are used, a different encoder may be provided to each session. The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).  \n  \n The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders. The methods provide for reading a message from a stream or from a <xref:System.Byte> array. Byte arrays are used when the transport is operating in buffered mode. Messages are always written to streams. If the transport must buffer the message, it provides a stream that does the buffering.  \n  \n The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>. The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.  \n  \n Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable. The encoders also expose reader quotas that have secure defaults. See XML Infrastructure for a discussion of the quotas.  \n  \n## Features of System-Provided Encoders  \n There are a number of features provided by the system-provided encoders.  \n  \n### Pooling  \n Each of the encoder implementations tries to pool as much as possible. Reducing allocations is a key way to improve the performance of managed code. To accomplish this pooling, the implementations use the `SynchronizedPool` class. The C# file contains a description of the additional optimizations used by this class.  \n  \n `XmlDictionaryReader` and `XmlDictionaryWriter` instances are pooled and reinitialized to prevent allocating new ones for each message. For the readers, an `OnClose` callback reclaims the reader when `Close()` is called. The encoder also recycles some message state objects used when constructing messages. The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.  \n  \n### Binary Encoding  \n When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message. This is done by prefixing the message with the dynamic dictionary strings. The receiver strips off the strings, adds them to the session, and processes the message. Correctly passing dictionary strings requires that the transport be buffered.  \n  \n The strings are appended to the message by an internal `AddSessionInformationToMessage` method. It adds the strings as UTF-8 to the front of the message prefixed with their length. The entire dictionary header is then prefixed with the length of its data. The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method.  \n  \n In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way. Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream. The idea is that most messages have a certain set of headers that show up in a certain order when generated by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]. The pattern system breaks the message apart based on what it expects. If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML. If not, it falls back to the standard method.  \n  \n### MTOM Encoding  \n The <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`> class has an additional configuration property called <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`.MaxBufferSize%2A>. This places an upper bound on how much data it is allowed to buffer during the process of reading a message. The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.  \n  \n To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden. More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.  \n  \n Internally, the MTOM message encoder uses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s text readers, and is similar to the Text encoder. The main difference is that it optimizes large chunks of binary, or \"Binary Large Objects\" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes. Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.  \n  \n## Writing your own Encoder  \n To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:  \n  \n-   <xref:System.ServiceModel.Channels.MessageEncoder>  \n  \n-   <xref:System.ServiceModel.Channels.MessageEncoderFactory>  \n  \n-   <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  \n  \n Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.  \n  \n-   The key methods of this class that you must override are:  \n  \n-   <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.Message> object and writes it into a <xref:System.IO.Stream> object.  \n  \n-   <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object.  \n  \n It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.  \n  \n Next you need to code a factory class that creates your custom encoder. Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>.  \n  \n Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory.  \n  \n There are two samples provided with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md).  \n  \n## See Also  \n <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>   \n <xref:System.ServiceModel.Channels.MessageEncoderFactory>   \n <xref:System.ServiceModel.Channels.MessageEncoder>   \n [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)   \n [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)   \n [Choosing a Transport](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)","nodes":[{"pos":[12,44],"content":"Custom Encoders | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Custom Encoders | Microsoft Docs","pos":[0,32]}]},{"pos":[343,358],"content":"Custom Encoders","linkify":"Custom Encoders","nodes":[{"content":"Custom Encoders","pos":[0,15]}]},{"content":"This topic discusses how to create custom encoders.","pos":[359,410]},{"content":"In <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph>, you use a <bpt id=\"p1\">*</bpt>binding<ept id=\"p1\">*</ept> to specify how to transfer data across a network between endpoints.","pos":[417,564],"source":"In [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)], you use a *binding* to specify how to transfer data across a network between endpoints."},{"content":"A binding is made up of a sequence of <bpt id=\"p1\">*</bpt>binding elements<ept id=\"p1\">*</ept>.","pos":[565,622],"source":" A binding is made up of a sequence of *binding elements*."},{"content":"A binding includes optional protocol binding elements such as security, a required <bpt id=\"p1\">*</bpt>Message Encoder<ept id=\"p1\">*</ept> binding element, and a required transport binding element.","pos":[623,782],"source":" A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element."},{"content":"A message encoder is represented by a message encoding binding element.","pos":[783,854]},{"content":"Three message encoders are included in <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.","pos":[855,1020],"source":" Three message encoders are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: Binary, Message Transmission Optimization Mechanism (MTOM), and Text."},{"content":"A message encoding binding element serializes an outgoing <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.","pos":[1027,1311],"source":"A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present."},{"content":"Message encoders transform <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instances to and from a wire representation.","pos":[1318,1433],"source":"Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation."},{"content":"Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer.","pos":[1434,1564]},{"content":"Transports (for example HTTP) format the message according to the requirements of the transport standard.","pos":[1565,1670]},{"content":"Encoders (for example Text Xml) just encode the message.","pos":[1671,1727]},{"content":"When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding.","pos":[1734,1853]},{"content":"However, <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services can be made accessible through multiple endpoints, each with a different message encoder.","pos":[1854,2017],"source":" However, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services can be made accessible through multiple endpoints, each with a different message encoder."},{"content":"When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints.","pos":[2018,2148]},{"content":"Client applications can then choose the endpoint that is best for them.","pos":[2149,2220]},{"content":"Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.","pos":[2221,2341]},{"pos":[2350,2374],"content":"System-Provided Encoders","linkify":"System-Provided Encoders","nodes":[{"content":"System-Provided Encoders","pos":[0,24]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> provides several system-provided bindings that are designed to cover the most common application scenarios.","pos":[2378,2541],"source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides several system-provided bindings that are designed to cover the most common application scenarios."},{"content":"Each of these bindings combine a transport, message encoder, and other options (security, for example).","pos":[2542,2645]},{"content":"This topic describes how to extend the <ph id=\"ph1\">`Text`</ph>, <ph id=\"ph2\">`Binary`</ph>, and <ph id=\"ph3\">`MTOM`</ph> message encoders that are included in <ph id=\"ph4\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>, or create your own custom encoder.","pos":[2646,2843],"source":" This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], or create your own custom encoder."},{"content":"The text message encoder supports both a plain XML encoding as well as SOAP encodings.","pos":[2844,2930]},{"content":"The plain XML encoding mode of the text message encoder is called the POX (\"Plain Old XML\") encoder to distinguish it from the text-based SOAP encoding.","pos":[2931,3083]},{"pos":[3090,3353],"content":"<ph id=\"ph1\">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> the combinations of binding elements provided by the system-provided bindings, see the corresponding section in <bpt id=\"p1\">[</bpt>Choosing a Transport<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)</ept>.","source":"[!INCLUDE[crabout](../../../../includes/crabout-md.md)] the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)."},{"pos":[3362,3403],"content":"How to Work with System-Provided Encoders","linkify":"How to Work with System-Provided Encoders","nodes":[{"content":"How to Work with System-Provided Encoders","pos":[0,41]}]},{"content":"An encoding is added to a binding using a class derived from <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement&gt;</ph>.","pos":[3407,3534],"source":"An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>."},{"pos":[3541,3833],"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> provides the following types of binding elements derived from the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement&gt;</ph> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:","source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:"},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement&gt;</ph>: The most interoperable, but the least efficient encoder for XML messages.","pos":[3843,3987],"source":"<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages."},{"content":"A Web service or Web service client can generally understand textual XML.","pos":[3988,4061]},{"content":"However, transmitting large blocks of binary data as text is not efficient.","pos":[4062,4137]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement&gt;</ph>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages.","pos":[4147,4347],"source":"<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages."},{"content":"This is most efficient of the encoding options, but the least interoperable, because it is only supported by <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> endpoints.","pos":[4348,4523],"source":" This is most efficient of the encoding options, but the least interoperable, because it is only supported by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] endpoints."},{"content":"<ph id=\"ph1\">&lt;</ph><ph id=\"ph2\">&lt;!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --&gt;</ph> <ph id=\"ph3\">`System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`</ph>&gt;: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding.","pos":[4533,4859],"source":"<<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding."},{"content":"MTOM is an efficient technology for transmitting binary data in <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> messages.","pos":[4860,4989],"source":" MTOM is an efficient technology for transmitting binary data in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] messages."},{"content":"The MTOM encoder attempts to balance between efficiency and interoperability.","pos":[4990,5067]},{"content":"The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.","pos":[5068,5219]},{"content":"The binding element creates a binary, MTOM, or text <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoderFactory&gt;</ph>.","pos":[5226,5336],"source":"The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>."},{"content":"The factory creates a binary, MTOM, or text <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph> instance.","pos":[5337,5441],"source":" The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoder> instance."},{"content":"Typically, there is only a single instance.","pos":[5442,5485]},{"content":"However if sessions are used, a different encoder may be provided to each session.","pos":[5486,5568]},{"content":"The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).","pos":[5569,5666]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A&gt;</ph> methods are the core of the encoders.","pos":[5673,5851],"source":"The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders."},{"content":"The methods provide for reading a message from a stream or from a <ph id=\"ph1\">&lt;xref:System.Byte&gt;</ph> array.","pos":[5852,5943],"source":" The methods provide for reading a message from a stream or from a <xref:System.Byte> array."},{"content":"Byte arrays are used when the transport is operating in buffered mode.","pos":[5944,6014]},{"content":"Messages are always written to streams.","pos":[6015,6054]},{"content":"If the transport must buffer the message, it provides a stream that does the buffering.","pos":[6055,6142]},{"content":"The rest of the members work with support content, media types, and <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A&gt;</ph>.","pos":[6149,6286],"source":"The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>."},{"content":"The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.","pos":[6287,6454]},{"content":"Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable.","pos":[6461,6589]},{"content":"The encoders also expose reader quotas that have secure defaults.","pos":[6590,6655]},{"content":"See XML Infrastructure for a discussion of the quotas.","pos":[6656,6710]},{"pos":[6719,6755],"content":"Features of System-Provided Encoders","linkify":"Features of System-Provided Encoders","nodes":[{"content":"Features of System-Provided Encoders","pos":[0,36]}]},{"content":"There are a number of features provided by the system-provided encoders.","pos":[6759,6831]},{"pos":[6841,6848],"content":"Pooling","linkify":"Pooling","nodes":[{"content":"Pooling","pos":[0,7]}]},{"content":"Each of the encoder implementations tries to pool as much as possible.","pos":[6852,6922]},{"content":"Reducing allocations is a key way to improve the performance of managed code.","pos":[6923,7000]},{"content":"To accomplish this pooling, the implementations use the <ph id=\"ph1\">`SynchronizedPool`</ph> class.","pos":[7001,7082],"source":" To accomplish this pooling, the implementations use the `SynchronizedPool` class."},{"content":"The C# file contains a description of the additional optimizations used by this class.","pos":[7083,7169]},{"content":"<ph id=\"ph1\">`XmlDictionaryReader`</ph> and <ph id=\"ph2\">`XmlDictionaryWriter`</ph> instances are pooled and reinitialized to prevent allocating new ones for each message.","pos":[7176,7311],"source":"`XmlDictionaryReader` and `XmlDictionaryWriter` instances are pooled and reinitialized to prevent allocating new ones for each message."},{"content":"For the readers, an <ph id=\"ph1\">`OnClose`</ph> callback reclaims the reader when <ph id=\"ph2\">`Close()`</ph> is called.","pos":[7312,7396],"source":" For the readers, an `OnClose` callback reclaims the reader when `Close()` is called."},{"content":"The encoder also recycles some message state objects used when constructing messages.","pos":[7397,7482]},{"content":"The sizes of these pools are configurable by the <ph id=\"ph1\">`MaxReadPoolSize`</ph> and <ph id=\"ph2\">`MaxWritePoolSize`</ph> properties on each of the three classes derived from <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement&gt;</ph>.","pos":[7483,7692],"source":" The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>."},{"pos":[7702,7717],"content":"Binary Encoding","linkify":"Binary Encoding","nodes":[{"content":"Binary Encoding","pos":[0,15]}]},{"content":"When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message.","pos":[7721,7839]},{"content":"This is done by prefixing the message with the dynamic dictionary strings.","pos":[7840,7914]},{"content":"The receiver strips off the strings, adds them to the session, and processes the message.","pos":[7915,8004]},{"content":"Correctly passing dictionary strings requires that the transport be buffered.","pos":[8005,8082]},{"content":"The strings are appended to the message by an internal <ph id=\"ph1\">`AddSessionInformationToMessage`</ph> method.","pos":[8089,8184],"source":"The strings are appended to the message by an internal `AddSessionInformationToMessage` method."},{"content":"It adds the strings as UTF-8 to the front of the message prefixed with their length.","pos":[8185,8269]},{"content":"The entire dictionary header is then prefixed with the length of its data.","pos":[8270,8344]},{"content":"The reverse operation is performed by an internal <ph id=\"ph1\">`ExtractSessionInformationFromMessage`</ph> method.","pos":[8345,8441],"source":" The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method."},{"content":"In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way.","pos":[8448,8557]},{"content":"Instead of creating a reader over the document and processing it, the binary encoder uses the internal <ph id=\"ph1\">`MessagePatterns`</ph> class to deconstruct the binary stream.","pos":[8558,8718],"source":" Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream."},{"content":"The idea is that most messages have a certain set of headers that show up in a certain order when generated by <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.","pos":[8719,8886],"source":" The idea is that most messages have a certain set of headers that show up in a certain order when generated by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]."},{"content":"The pattern system breaks the message apart based on what it expects.","pos":[8887,8956]},{"content":"If it is successful, it initializes a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders&gt;</ph> object without parsing the XML.","pos":[8957,9077],"source":" If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML."},{"content":"If not, it falls back to the standard method.","pos":[9078,9123]},{"pos":[9133,9146],"content":"MTOM Encoding","linkify":"MTOM Encoding","nodes":[{"content":"MTOM Encoding","pos":[0,13]}]},{"content":"The &lt;<ph id=\"ph1\">&lt;!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --&gt;</ph> <ph id=\"ph2\">`System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`</ph>&gt; class has an additional configuration property called &lt;<ph id=\"ph3\">&lt;!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --&gt;</ph> <ph id=\"ph4\">`System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`</ph>.MaxBufferSize%2A&gt;.","pos":[9150,9517],"source":"The <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`> class has an additional configuration property called <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`.MaxBufferSize%2A>."},{"content":"This places an upper bound on how much data it is allowed to buffer during the process of reading a message.","pos":[9518,9626]},{"content":"The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.","pos":[9627,9762]},{"content":"To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for <ph id=\"ph1\">`GetContentType`</ph> (which is also internal) and <ph id=\"ph2\">`WriteMessage`</ph>, which is public and can be overridden.","pos":[9769,9970],"source":"To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden."},{"content":"More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.","pos":[9971,10076]},{"content":"Internally, the MTOM message encoder uses <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>'s text readers, and is similar to the Text encoder.","pos":[10083,10232],"source":"Internally, the MTOM message encoder uses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s text readers, and is similar to the Text encoder."},{"content":"The main difference is that it optimizes large chunks of binary, or \"Binary Large Objects\" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes.","pos":[10233,10423]},{"content":"Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.","pos":[10424,10504]},{"pos":[10513,10537],"content":"Writing your own Encoder","linkify":"Writing your own Encoder","nodes":[{"content":"Writing your own Encoder","pos":[0,24]}]},{"content":"To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:","pos":[10541,10666]},{"content":"Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.","pos":[10875,11173],"source":"Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings."},{"content":"The key methods of this class that you must override are:","pos":[11183,11240]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A&gt;</ph> which takes a <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> object and writes it into a <ph id=\"ph3\">&lt;xref:System.IO.Stream&gt;</ph> object.","pos":[11250,11434],"source":"<xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.Message> object and writes it into a <xref:System.IO.Stream> object."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A&gt;</ph> which takes a <ph id=\"ph2\">&lt;xref:System.IO.Stream&gt;</ph> object and a maximum header size and returns a <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> object.","pos":[11444,11646],"source":"<xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object."},{"content":"It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.","pos":[11653,11789]},{"content":"Next you need to code a factory class that creates your custom encoder.","pos":[11796,11867]},{"content":"Override the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A&gt;</ph> to return an instance of your custom <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph>.","pos":[11868,12038],"source":" Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>."},{"content":"Then connect your custom <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoderFactory&gt;</ph> to the binding element stack used to configure the service or client by overriding the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A&gt;</ph> method to return an instance of this factory.","pos":[12045,12357],"source":"Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory."},{"pos":[12364,12771],"content":"There are two samples provided with <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> that illustrate this process with sample code: <bpt id=\"p1\">[</bpt>Custom Message Encoder: Custom Text Encoder<ept id=\"p1\">](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md)</ept> and <bpt id=\"p2\">[</bpt>Custom Message Encoder: Compression Encoder<ept id=\"p2\">](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md)</ept>.","source":"There are two samples provided with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md)."},{"pos":[12780,12788],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement&gt;</ph>","pos":[12792,12857],"source":"<xref:System.ServiceModel.Channels.MessageEncodingBindingElement> "},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoderFactory&gt;</ph>","pos":[12862,12919],"source":" <xref:System.ServiceModel.Channels.MessageEncoderFactory> "},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph>","pos":[12924,12974],"source":" <xref:System.ServiceModel.Channels.MessageEncoder> "},{"content":"<bpt id=\"p1\"> [</bpt>Data Transfer Architectural Overview<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)</ept><ph id=\"ph1\"> </ph>","pos":[12978,13106],"source":" [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Choosing a Message Encoder<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)</ept><ph id=\"ph1\"> </ph>","pos":[13109,13217],"source":" [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Choosing a Transport<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)</ept>","pos":[13220,13315],"source":" [Choosing a Transport](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)"}]}