{"content":"---\ntitle: \"Security and Remoting Considerations\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"code security, remoting\"\n  - \"remoting, security\"\n  - \"security [.NET Framework], remoting\"\n  - \"secure coding, remoting\"\nms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Security and Remoting Considerations\nRemoting allows you to set up transparent calling between application domains, processes, or computers. However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).  \n  \n Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security. Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.  \n  \n Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](../../../docs/framework/misc/link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks. With remoting, these checks are not enforced. Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.  \n  \n## Protected objects  \n Some objects hold security state in themselves. These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.  \n  \n One example is creating a <xref:System.IO.FileStream> object. The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned. However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.  \n  \n The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.  \n  \n## Application domain crossing issues  \n To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies. However, the policy for those assemblies remains unchanged in the default application domain. If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.  \n  \n An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain. To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value. Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default. Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.  \n  \n Usually, the default application domain creates the child application domains with a control object in each one. The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly. Occasionally, the default application domain calls its proxy to the control object. However, there might be cases in which it is necessary for the control object to call back to the default application domain. In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object. It is the responsibility of the control object to protect this proxy. If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain. For this reason, control objects are always implicitly trusted to keep the proxy private.  \n  \n## See also\n\n- [Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)\n","nodes":[{"pos":[4,306],"embed":true,"restype":"x-metadata","content":"title: \"Security and Remoting Considerations\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"code security, remoting\"\n  - \"remoting, security\"\n  - \"security [.NET Framework], remoting\"\n  - \"secure coding, remoting\"\nms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Security and Remoting Considerations","nodes":[{"pos":[0,36],"content":"Security and Remoting Considerations","nodes":[{"content":"Security and Remoting Considerations","pos":[0,36]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[313,349],"content":"Security and Remoting Considerations","linkify":"Security and Remoting Considerations","nodes":[{"content":"Security and Remoting Considerations","pos":[0,36]}]},{"content":"Remoting allows you to set up transparent calling between application domains, processes, or computers.","pos":[350,453]},{"content":"However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).","pos":[454,606]},{"content":"Any class that is remotable (derived from a <ph id=\"ph1\">&lt;xref:System.MarshalByRefObject&gt;</ph> class) needs to take responsibility for security.","pos":[613,739],"source":"Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security."},{"content":"Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.","pos":[740,977]},{"content":"Generally, you should never expose methods, properties, or events that are protected by declarative <bpt id=\"p1\">[</bpt>LinkDemand<ept id=\"p1\">](../../../docs/framework/misc/link-demands.md)</ept> and <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> security checks.","pos":[984,1231],"source":"Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](../../../docs/framework/misc/link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks."},{"content":"With remoting, these checks are not enforced.","pos":[1232,1277]},{"content":"Other security checks, such as <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityAction.Demand&gt;</ph>, <bpt id=\"p1\">[</bpt>Assert<ept id=\"p1\">](../../../docs/framework/misc/using-the-assert-method.md)</ept>, and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.","pos":[1278,1555],"source":" Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios."},{"pos":[1564,1581],"content":"Protected objects","linkify":"Protected objects","nodes":[{"content":"Protected objects","pos":[0,17]}]},{"content":"Some objects hold security state in themselves.","pos":[1585,1632]},{"content":"These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.","pos":[1633,1762]},{"content":"One example is creating a <ph id=\"ph1\">&lt;xref:System.IO.FileStream&gt;</ph> object.","pos":[1769,1830],"source":"One example is creating a <xref:System.IO.FileStream> object."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> is demanded at the time of creation and, if it succeeds, the file object is returned.","pos":[1831,1972],"source":" The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned."},{"content":"However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.","pos":[1973,2117]},{"pos":[2124,2287],"content":"The simplest defense for such an object is to demand the same <bpt id=\"p1\">**</bpt>FileIOPermission<ept id=\"p1\">**</ept> of any code that seeks to get the object reference through a public API element.","source":"The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element."},{"pos":[2296,2330],"content":"Application domain crossing issues","linkify":"Application domain crossing issues","nodes":[{"content":"Application domain crossing issues","pos":[0,34]}]},{"content":"To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.","pos":[2334,2518]},{"content":"However, the policy for those assemblies remains unchanged in the default application domain.","pos":[2519,2612]},{"content":"If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.","pos":[2613,2846]},{"content":"An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.","pos":[2853,3034]},{"content":"To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.","pos":[3035,3189]},{"content":"Or, if the application domain was just created, the creator has a proxy to the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> object by default.","pos":[3190,3311],"source":" Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default."},{"content":"Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <ph id=\"ph1\">&lt;xref:System.MarshalByRefObject&gt;</ph>) in its domain to application domains with lower levels of trust.","pos":[3312,3603],"source":" Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust."},{"content":"Usually, the default application domain creates the child application domains with a control object in each one.","pos":[3610,3722]},{"content":"The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.","pos":[3723,3895]},{"content":"Occasionally, the default application domain calls its proxy to the control object.","pos":[3896,3979]},{"content":"However, there might be cases in which it is necessary for the control object to call back to the default application domain.","pos":[3980,4105]},{"content":"In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.","pos":[4106,4240]},{"content":"It is the responsibility of the control object to protect this proxy.","pos":[4241,4310]},{"content":"If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.","pos":[4311,4546]},{"content":"For this reason, control objects are always implicitly trusted to keep the proxy private.","pos":[4547,4636]},{"pos":[4645,4653],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4657,4744],"content":"<bpt id=\"p1\">[</bpt>Secure Coding Guidelines<ept id=\"p1\">](../../../docs/standard/security/secure-coding-guidelines.md)</ept>","source":"[Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)"}]}