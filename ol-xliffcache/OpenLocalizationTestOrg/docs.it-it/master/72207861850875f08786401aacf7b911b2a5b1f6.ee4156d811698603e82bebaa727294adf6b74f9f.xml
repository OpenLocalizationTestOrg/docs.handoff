{"content":"---\ntitle: \"Application Startup Time\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"splash screen [WPF], startup time\"\n  - \"WPF [WPF], startup time\"\n  - \"startup time [WPF]\"\n  - \"application startup [WPF]\"\n  - \"performance [WPF], startup time\"\nms.assetid: f0ec58d8-626f-4d8a-9873-c20f95e08b96\n---\n# Application Startup Time\nThe amount of time that is required for a WPF application to start can vary greatly. This topic describes various techniques for reducing the perceived and actual startup time for a Windows Presentation Foundation (WPF) application.  \n  \n## Understanding Cold Startup and Warm Startup  \n Cold startup occurs when your application starts for the first time after a system reboot, or when you start your application, close it, and then start it again after a long period of time. When an application starts, if the required pages (code, static data, registry, etc) are not present in the Windows memory manager's standby list, page faults occur. Disk access is required to bring the pages into memory.  \n  \n Warm startup occurs when most of the pages for the main common language runtime (CLR) components are already loaded in memory, which saves expensive disk access time. That is why a managed application starts faster when it runs a second time.  \n  \n## Implement a Splash Screen  \n In cases where there is a significant, unavoidable delay between starting an application and displaying the first UI, optimize the perceived startup time by using a *splash screen*. This approach displays an image almost immediately after the user starts the application. When the application is ready to display its first UI, the splash screen fades. Starting in the [!INCLUDE[net_v35SP1_short](../../../../includes/net-v35sp1-short-md.md)], you can use the <xref:System.Windows.SplashScreen> class to implement a splash screen. For more information, see [Add a Splash Screen to a WPF Application](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md).  \n  \n You can also implement your own splash screen by using native Win32 graphics. Display your implementation before the <xref:System.Windows.Application.Run%2A> method is called.  \n  \n## Analyze the Startup Code  \n Determine the reason for a slow cold startup. Disk I/O may be responsible, but this is not always the case. In general, you should minimize the use of external resources, such as network, Web services, or disk.  \n  \n Before you test, verify that no other running applications or services use managed code or WPF code.  \n  \n Start your WPF application immediately after a reboot, and determine how long it takes to display. If all subsequent launches of your application (warm startup) are much faster, your cold startup issue is most likely caused by I/O.  \n  \n If your application's cold startup issue is not related to I/O, it is likely that your application performs some lengthy initialization or computation, waits for some event to complete, or requires a lot of JIT compilation at startup. The following sections describe some of these situations in more detail.  \n  \n## Optimize Module Loading  \n Use tools such as Process Explorer (Procexp.exe) and Tlist.exe to determine which modules your application loads. The command `Tlist <pid>` shows all the modules that are loaded by a process.  \n  \n For example, if you are not connecting to the Web and you see that System.Web.dll is loaded, then there is a module in your application that references this assembly. Check to make sure that the reference is necessary.  \n  \n If your application has multiple modules, merge them into a single module. This approach requires less CLR assembly-loading overhead. Fewer assemblies also mean that the CLR maintains less state.  \n  \n## Defer Initialization Operations  \n Consider postponing initialization code until after the main application window is rendered.  \n  \n Be aware that initialization may be performed inside a class constructor, and if the initialization code references other classes, it can cause a cascading effect in which many class constructors are executed.  \n  \n## Avoid Application Configuration  \n Consider avoiding application configuration. For example, if an application has simple configuration requirements and has strict startup time goals, registry entries or a simple INI file may be a faster startup alternative.  \n  \n## Utilize the GAC  \n If an assembly is not installed in the Global Assembly Cache (GAC), there are delays caused by hash verification of strong-named assemblies and by Ngen image validation if a native image for that assembly is available on the computer. Strong-name verification is skipped for all assemblies installed in the GAC. For more information, see [Gacutil.exe (Global Assembly Cache Tool)](../../tools/gacutil-exe-gac-tool.md).  \n  \n## Use Ngen.exe  \n Consider using the Native Image Generator (Ngen.exe) on your application. Using Ngen.exe means trading CPU consumption for more disk access because the native image generated by Ngen.exe is likely to be larger than the MSIL image.  \n  \n To improve the warm startup time, you should always use Ngen.exe on your application, because this avoids the CPU cost of JIT compilation of the application code.  \n  \n In some cold startup scenarios, using Ngen.exe can also be helpful. This is because the JIT compiler (mscorjit.dll) does not have to be loaded.  \n  \n Having both Ngen and JIT modules can have the worst effect. This is because mscorjit.dll must be loaded, and when the JIT compiler works on your code, many pages in the Ngen images must be accessed when the JIT compiler reads the assemblies' metadata.  \n  \n### Ngen and ClickOnce  \n The way you plan to deploy your application can also make a difference in load time. [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] application deployment does not support Ngen. If you decide to use Ngen.exe for your application, you will have to use another deployment mechanism, such as Windows Installer.  \n  \n For more information, see [Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md).  \n  \n### Rebasing and DLL Address Collisions  \n If you use Ngen.exe, be aware that rebasing can occur when the native images are loaded in memory. If a DLL is not loaded at its preferred base address because that address range is already allocated, the Windows loader will load it at another address, which can be a time-consuming operation.  \n  \n You can use the Virtual Address Dump (Vadump.exe) tool to check if there are modules in which all the pages are private. If this is the case, the module may have been rebased to a different address. Therefore, its pages cannot be shared.  \n  \n For more information about how to set the base address, see [Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md).  \n  \n## Optimize Authenticode  \n Authenticode verification adds to the startup time. Authenticode-signed assemblies have to be verified with the certification authority (CA). This verification can be time consuming, because it can require connecting to the network several times to download current certificate revocation lists. It also makes sure that there is a full chain of valid certificates on the path to a trusted root. This can translate to several seconds of delay while the assembly is being loaded.  \n  \n Consider installing the CA certificate on the client computer, or avoid using Authenticode when it is possible. If you know that your application does not need the publisher evidence, you do not have to pay the cost of signature verification.  \n  \n Starting in [!INCLUDE[net_v35_short](../../../../includes/net-v35-short-md.md)], there is a configuration option that allows the Authenticode verification to be bypassed. To do this, add the following setting to the app.exe.config file:  \n  \n```xml  \n<configuration>  \n    <runtime>  \n        <generatePublisherEvidence enabled=\"false\"/>   \n    </runtime>  \n</configuration>  \n```  \n  \n For more information, see [\\<generatePublisherEvidence> Element](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md).  \n  \n## Compare Performance on Windows Vista  \n The memory manager in Windows Vista has a technology called SuperFetch. SuperFetch analyzes memory usage patterns over time to determine the optimal memory content for a specific user. It works continuously to maintain that content at all times.  \n  \n This approach differs from the pre-fetch technique used in Windows XP, which preloads data into memory without analyzing usage patterns. Over time, if the user uses your WPF application frequently on Windows Vista, the cold startup time of your application may improve.  \n  \n## Use AppDomains Efficiently  \n If possible, load assemblies into a domain-neutral code area to make sure that the native image, if one exists, is used in all AppDomains created in the application.  \n  \n For the best performance, enforce efficient cross-domain communication by reducing cross-domain calls. When possible, use calls without arguments or with primitive type arguments.  \n  \n## Use the NeutralResourcesLanguage Attribute  \n Use the <xref:System.Resources.NeutralResourcesLanguageAttribute> to specify the neutral culture for the <xref:System.Resources.ResourceManager>. This approach avoids unsuccessful assembly lookups.  \n  \n## Use the BinaryFormatter Class for Serialization  \n If you must use serialization, use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class instead of the <xref:System.Xml.Serialization.XmlSerializer> class. The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class is implemented in the Base Class Library (BCL) in the mscorlib.dll assembly. The <xref:System.Xml.Serialization.XmlSerializer> is implemented in the System.Xml.dll assembly, which might be an additional DLL to load.  \n  \n If you must use the <xref:System.Xml.Serialization.XmlSerializer> class, you can achieve better performance if you pre-generate the serialization assembly.  \n  \n## Configure ClickOnce to Check for Updates After Startup  \n If your application uses [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)], avoid network access on startup by configuring [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] to check the deployment site for updates after the application starts.  \n  \n If you use the XAML browser application (XBAP) model, keep in mind that [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] checks the deployment site for updates even if the XBAP is already in the [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] cache. For more information, see [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment).  \n  \n## Configure the PresentationFontCache Service to Start Automatically  \n The first WPF application to run after a reboot is the PresentationFontCache service. The service caches the system fonts, improves font access, and improves overall performance. There is an overhead in starting the service, and in some controlled environments, consider configuring the service to start automatically when the system reboots.  \n  \n## Set Data Binding Programmatically  \n Instead of using XAML to set the <xref:System.Windows.FrameworkElement.DataContext%2A> declaratively for the main window, consider setting it programmatically in the <xref:System.Windows.Application.OnActivated%2A> method.  \n  \n## See also\n\n- <xref:System.Windows.SplashScreen>\n- <xref:System.AppDomain>\n- <xref:System.Resources.NeutralResourcesLanguageAttribute>\n- <xref:System.Resources.ResourceManager>\n- [Add a Splash Screen to a WPF Application](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)\n- [Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md)\n- [\\<generatePublisherEvidence> Element](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md)\n","nodes":[{"pos":[4,295],"embed":true,"restype":"x-metadata","content":"title: \"Application Startup Time\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"splash screen [WPF], startup time\"\n  - \"WPF [WPF], startup time\"\n  - \"startup time [WPF]\"\n  - \"application startup [WPF]\"\n  - \"performance [WPF], startup time\"\nms.assetid: f0ec58d8-626f-4d8a-9873-c20f95e08b96","nodes":[{"content":"Application Startup Time","nodes":[{"pos":[0,24],"content":"Application Startup Time","nodes":[{"content":"Application Startup Time","pos":[0,24]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[302,326],"content":"Application Startup Time","linkify":"Application Startup Time","nodes":[{"content":"Application Startup Time","pos":[0,24]}]},{"content":"The amount of time that is required for a WPF application to start can vary greatly.","pos":[327,411]},{"content":"This topic describes various techniques for reducing the perceived and actual startup time for a Windows Presentation Foundation (WPF) application.","pos":[412,559]},{"pos":[568,611],"content":"Understanding Cold Startup and Warm Startup","linkify":"Understanding Cold Startup and Warm Startup","nodes":[{"content":"Understanding Cold Startup and Warm Startup","pos":[0,43]}]},{"content":"Cold startup occurs when your application starts for the first time after a system reboot, or when you start your application, close it, and then start it again after a long period of time.","pos":[615,804]},{"content":"When an application starts, if the required pages (code, static data, registry, etc) are not present in the Windows memory manager's standby list, page faults occur.","pos":[805,970]},{"content":"Disk access is required to bring the pages into memory.","pos":[971,1026]},{"content":"Warm startup occurs when most of the pages for the main common language runtime (CLR) components are already loaded in memory, which saves expensive disk access time.","pos":[1033,1199]},{"content":"That is why a managed application starts faster when it runs a second time.","pos":[1200,1275]},{"pos":[1284,1309],"content":"Implement a Splash Screen","linkify":"Implement a Splash Screen","nodes":[{"content":"Implement a Splash Screen","pos":[0,25]}]},{"content":"In cases where there is a significant, unavoidable delay between starting an application and displaying the first UI, optimize the perceived startup time by using a <bpt id=\"p1\">*</bpt>splash screen<ept id=\"p1\">*</ept>.","pos":[1313,1494],"source":"In cases where there is a significant, unavoidable delay between starting an application and displaying the first UI, optimize the perceived startup time by using a *splash screen*."},{"content":"This approach displays an image almost immediately after the user starts the application.","pos":[1495,1584]},{"content":"When the application is ready to display its first UI, the splash screen fades.","pos":[1585,1664]},{"content":"Starting in the <ph id=\"ph1\">[!INCLUDE[net_v35SP1_short](../../../../includes/net-v35sp1-short-md.md)]</ph>, you can use the <ph id=\"ph2\">&lt;xref:System.Windows.SplashScreen&gt;</ph> class to implement a splash screen.","pos":[1665,1842],"source":" Starting in the [!INCLUDE[net_v35SP1_short](../../../../includes/net-v35sp1-short-md.md)], you can use the <xref:System.Windows.SplashScreen> class to implement a splash screen."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Add a Splash Screen to a WPF Application<ept id=\"p1\">](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)</ept>.","pos":[1843,1983],"source":" For more information, see [Add a Splash Screen to a WPF Application](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)."},{"content":"You can also implement your own splash screen by using native Win32 graphics.","pos":[1990,2067]},{"content":"Display your implementation before the <ph id=\"ph1\">&lt;xref:System.Windows.Application.Run%2A&gt;</ph> method is called.","pos":[2068,2165],"source":" Display your implementation before the <xref:System.Windows.Application.Run%2A> method is called."},{"pos":[2174,2198],"content":"Analyze the Startup Code","linkify":"Analyze the Startup Code","nodes":[{"content":"Analyze the Startup Code","pos":[0,24]}]},{"content":"Determine the reason for a slow cold startup.","pos":[2202,2247]},{"content":"Disk I/O may be responsible, but this is not always the case.","pos":[2248,2309]},{"content":"In general, you should minimize the use of external resources, such as network, Web services, or disk.","pos":[2310,2412]},{"content":"Before you test, verify that no other running applications or services use managed code or WPF code.","pos":[2419,2519]},{"content":"Start your WPF application immediately after a reboot, and determine how long it takes to display.","pos":[2526,2624]},{"content":"If all subsequent launches of your application (warm startup) are much faster, your cold startup issue is most likely caused by I/O.","pos":[2625,2757]},{"content":"If your application's cold startup issue is not related to I/O, it is likely that your application performs some lengthy initialization or computation, waits for some event to complete, or requires a lot of JIT compilation at startup.","pos":[2764,2998]},{"content":"The following sections describe some of these situations in more detail.","pos":[2999,3071]},{"pos":[3080,3103],"content":"Optimize Module Loading","linkify":"Optimize Module Loading","nodes":[{"content":"Optimize Module Loading","pos":[0,23]}]},{"content":"Use tools such as Process Explorer (Procexp.exe) and Tlist.exe to determine which modules your application loads.","pos":[3107,3220]},{"content":"The command <ph id=\"ph1\">`Tlist &lt;pid&gt;`</ph> shows all the modules that are loaded by a process.","pos":[3221,3298],"source":" The command `Tlist <pid>` shows all the modules that are loaded by a process."},{"content":"For example, if you are not connecting to the Web and you see that System.Web.dll is loaded, then there is a module in your application that references this assembly.","pos":[3305,3471]},{"content":"Check to make sure that the reference is necessary.","pos":[3472,3523]},{"content":"If your application has multiple modules, merge them into a single module.","pos":[3530,3604]},{"content":"This approach requires less CLR assembly-loading overhead.","pos":[3605,3663]},{"content":"Fewer assemblies also mean that the CLR maintains less state.","pos":[3664,3725]},{"pos":[3734,3765],"content":"Defer Initialization Operations","linkify":"Defer Initialization Operations","nodes":[{"content":"Defer Initialization Operations","pos":[0,31]}]},{"content":"Consider postponing initialization code until after the main application window is rendered.","pos":[3769,3861]},{"content":"Be aware that initialization may be performed inside a class constructor, and if the initialization code references other classes, it can cause a cascading effect in which many class constructors are executed.","pos":[3868,4077]},{"pos":[4086,4117],"content":"Avoid Application Configuration","linkify":"Avoid Application Configuration","nodes":[{"content":"Avoid Application Configuration","pos":[0,31]}]},{"content":"Consider avoiding application configuration.","pos":[4121,4165]},{"content":"For example, if an application has simple configuration requirements and has strict startup time goals, registry entries or a simple INI file may be a faster startup alternative.","pos":[4166,4344]},{"pos":[4353,4368],"content":"Utilize the GAC","linkify":"Utilize the GAC","nodes":[{"content":"Utilize the GAC","pos":[0,15]}]},{"content":"If an assembly is not installed in the Global Assembly Cache (GAC), there are delays caused by hash verification of strong-named assemblies and by Ngen image validation if a native image for that assembly is available on the computer.","pos":[4372,4606]},{"content":"Strong-name verification is skipped for all assemblies installed in the GAC.","pos":[4607,4683]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Gacutil.exe (Global Assembly Cache Tool)<ept id=\"p1\">](../../tools/gacutil-exe-gac-tool.md)</ept>.","pos":[4684,4790],"source":" For more information, see [Gacutil.exe (Global Assembly Cache Tool)](../../tools/gacutil-exe-gac-tool.md)."},{"pos":[4799,4811],"content":"Use Ngen.exe","linkify":"Use Ngen.exe","nodes":[{"content":"Use Ngen.exe","pos":[0,12]}]},{"content":"Consider using the Native Image Generator (Ngen.exe) on your application.","pos":[4815,4888]},{"content":"Using Ngen.exe means trading CPU consumption for more disk access because the native image generated by Ngen.exe is likely to be larger than the MSIL image.","pos":[4889,5045]},{"content":"To improve the warm startup time, you should always use Ngen.exe on your application, because this avoids the CPU cost of JIT compilation of the application code.","pos":[5052,5214]},{"content":"In some cold startup scenarios, using Ngen.exe can also be helpful.","pos":[5221,5288]},{"content":"This is because the JIT compiler (mscorjit.dll) does not have to be loaded.","pos":[5289,5364]},{"content":"Having both Ngen and JIT modules can have the worst effect.","pos":[5371,5430]},{"content":"This is because mscorjit.dll must be loaded, and when the JIT compiler works on your code, many pages in the Ngen images must be accessed when the JIT compiler reads the assemblies' metadata.","pos":[5431,5622]},{"pos":[5632,5650],"content":"Ngen and ClickOnce","linkify":"Ngen and ClickOnce","nodes":[{"content":"Ngen and ClickOnce","pos":[0,18]}]},{"content":"The way you plan to deploy your application can also make a difference in load time.","pos":[5654,5738]},{"content":"<ph id=\"ph1\">[!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]</ph> application deployment does not support Ngen.","pos":[5739,5848],"source":"[!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] application deployment does not support Ngen."},{"content":"If you decide to use Ngen.exe for your application, you will have to use another deployment mechanism, such as Windows Installer.","pos":[5849,5978]},{"pos":[5985,6095],"content":"For more information, see <bpt id=\"p1\">[</bpt>Ngen.exe (Native Image Generator)<ept id=\"p1\">](../../tools/ngen-exe-native-image-generator.md)</ept>.","source":"For more information, see [Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md)."},{"pos":[6105,6140],"content":"Rebasing and DLL Address Collisions","linkify":"Rebasing and DLL Address Collisions","nodes":[{"content":"Rebasing and DLL Address Collisions","pos":[0,35]}]},{"content":"If you use Ngen.exe, be aware that rebasing can occur when the native images are loaded in memory.","pos":[6144,6242]},{"content":"If a DLL is not loaded at its preferred base address because that address range is already allocated, the Windows loader will load it at another address, which can be a time-consuming operation.","pos":[6243,6437]},{"content":"You can use the Virtual Address Dump (Vadump.exe) tool to check if there are modules in which all the pages are private.","pos":[6444,6564]},{"content":"If this is the case, the module may have been rebased to a different address.","pos":[6565,6642]},{"content":"Therefore, its pages cannot be shared.","pos":[6643,6681]},{"pos":[6688,6832],"content":"For more information about how to set the base address, see <bpt id=\"p1\">[</bpt>Ngen.exe (Native Image Generator)<ept id=\"p1\">](../../tools/ngen-exe-native-image-generator.md)</ept>.","source":"For more information about how to set the base address, see [Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md)."},{"pos":[6841,6862],"content":"Optimize Authenticode","linkify":"Optimize Authenticode","nodes":[{"content":"Optimize Authenticode","pos":[0,21]}]},{"content":"Authenticode verification adds to the startup time.","pos":[6866,6917]},{"content":"Authenticode-signed assemblies have to be verified with the certification authority (CA).","pos":[6918,7007]},{"content":"This verification can be time consuming, because it can require connecting to the network several times to download current certificate revocation lists.","pos":[7008,7161]},{"content":"It also makes sure that there is a full chain of valid certificates on the path to a trusted root.","pos":[7162,7260]},{"content":"This can translate to several seconds of delay while the assembly is being loaded.","pos":[7261,7343]},{"content":"Consider installing the CA certificate on the client computer, or avoid using Authenticode when it is possible.","pos":[7350,7461]},{"content":"If you know that your application does not need the publisher evidence, you do not have to pay the cost of signature verification.","pos":[7462,7592]},{"content":"Starting in <ph id=\"ph1\">[!INCLUDE[net_v35_short](../../../../includes/net-v35-short-md.md)]</ph>, there is a configuration option that allows the Authenticode verification to be bypassed.","pos":[7599,7769],"source":"Starting in [!INCLUDE[net_v35_short](../../../../includes/net-v35-short-md.md)], there is a configuration option that allows the Authenticode verification to be bypassed."},{"content":"To do this, add the following setting to the app.exe.config file:","pos":[7770,7835]},{"pos":[7986,8130],"content":"For more information, see <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>generatePublisherEvidence&gt; Element<ept id=\"p1\">](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md)</ept>.","source":"For more information, see [\\<generatePublisherEvidence> Element](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md)."},{"pos":[8139,8175],"content":"Compare Performance on Windows Vista","linkify":"Compare Performance on Windows Vista","nodes":[{"content":"Compare Performance on Windows Vista","pos":[0,36]}]},{"content":"The memory manager in Windows Vista has a technology called SuperFetch.","pos":[8179,8250]},{"content":"SuperFetch analyzes memory usage patterns over time to determine the optimal memory content for a specific user.","pos":[8251,8363]},{"content":"It works continuously to maintain that content at all times.","pos":[8364,8424]},{"content":"This approach differs from the pre-fetch technique used in Windows XP, which preloads data into memory without analyzing usage patterns.","pos":[8431,8567]},{"content":"Over time, if the user uses your WPF application frequently on Windows Vista, the cold startup time of your application may improve.","pos":[8568,8700]},{"pos":[8709,8735],"content":"Use AppDomains Efficiently","linkify":"Use AppDomains Efficiently","nodes":[{"content":"Use AppDomains Efficiently","pos":[0,26]}]},{"content":"If possible, load assemblies into a domain-neutral code area to make sure that the native image, if one exists, is used in all AppDomains created in the application.","pos":[8739,8904]},{"content":"For the best performance, enforce efficient cross-domain communication by reducing cross-domain calls.","pos":[8911,9013]},{"content":"When possible, use calls without arguments or with primitive type arguments.","pos":[9014,9090]},{"pos":[9099,9141],"content":"Use the NeutralResourcesLanguage Attribute","linkify":"Use the NeutralResourcesLanguage Attribute","nodes":[{"content":"Use the NeutralResourcesLanguage Attribute","pos":[0,42]}]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Resources.NeutralResourcesLanguageAttribute&gt;</ph> to specify the neutral culture for the <ph id=\"ph2\">&lt;xref:System.Resources.ResourceManager&gt;</ph>.","pos":[9145,9290],"source":"Use the <xref:System.Resources.NeutralResourcesLanguageAttribute> to specify the neutral culture for the <xref:System.Resources.ResourceManager>."},{"content":"This approach avoids unsuccessful assembly lookups.","pos":[9291,9342]},{"pos":[9351,9398],"content":"Use the BinaryFormatter Class for Serialization","linkify":"Use the BinaryFormatter Class for Serialization","nodes":[{"content":"Use the BinaryFormatter Class for Serialization","pos":[0,47]}]},{"content":"If you must use serialization, use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&gt;</ph> class instead of the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class.","pos":[9402,9584],"source":"If you must use serialization, use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class instead of the <xref:System.Xml.Serialization.XmlSerializer> class."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&gt;</ph> class is implemented in the Base Class Library (BCL) in the mscorlib.dll assembly.","pos":[9585,9741],"source":" The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class is implemented in the Base Class Library (BCL) in the mscorlib.dll assembly."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is implemented in the System.Xml.dll assembly, which might be an additional DLL to load.","pos":[9742,9880],"source":" The <xref:System.Xml.Serialization.XmlSerializer> is implemented in the System.Xml.dll assembly, which might be an additional DLL to load."},{"pos":[9887,10042],"content":"If you must use the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class, you can achieve better performance if you pre-generate the serialization assembly.","source":"If you must use the <xref:System.Xml.Serialization.XmlSerializer> class, you can achieve better performance if you pre-generate the serialization assembly."},{"pos":[10051,10105],"content":"Configure ClickOnce to Check for Updates After Startup","linkify":"Configure ClickOnce to Check for Updates After Startup","nodes":[{"content":"Configure ClickOnce to Check for Updates After Startup","pos":[0,54]}]},{"pos":[10109,10380],"content":"If your application uses <ph id=\"ph1\">[!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]</ph>, avoid network access on startup by configuring <ph id=\"ph2\">[!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]</ph> to check the deployment site for updates after the application starts.","source":"If your application uses [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)], avoid network access on startup by configuring [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] to check the deployment site for updates after the application starts."},{"content":"If you use the XAML browser application (XBAP) model, keep in mind that <ph id=\"ph1\">[!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]</ph> checks the deployment site for updates even if the XBAP is already in the <ph id=\"ph2\">[!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]</ph> cache.","pos":[10387,10667],"source":"If you use the XAML browser application (XBAP) model, keep in mind that [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] checks the deployment site for updates even if the XBAP is already in the [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] cache."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>ClickOnce Security and Deployment<ept id=\"p1\">](/visualstudio/deployment/clickonce-security-and-deployment)</ept>.","pos":[10668,10790],"source":" For more information, see [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment)."},{"pos":[10799,10865],"content":"Configure the PresentationFontCache Service to Start Automatically","linkify":"Configure the PresentationFontCache Service to Start Automatically","nodes":[{"content":"Configure the PresentationFontCache Service to Start Automatically","pos":[0,66]}]},{"content":"The first WPF application to run after a reboot is the PresentationFontCache service.","pos":[10869,10954]},{"content":"The service caches the system fonts, improves font access, and improves overall performance.","pos":[10955,11047]},{"content":"There is an overhead in starting the service, and in some controlled environments, consider configuring the service to start automatically when the system reboots.","pos":[11048,11211]},{"pos":[11220,11253],"content":"Set Data Binding Programmatically","linkify":"Set Data Binding Programmatically","nodes":[{"content":"Set Data Binding Programmatically","pos":[0,33]}]},{"pos":[11257,11479],"content":"Instead of using XAML to set the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> declaratively for the main window, consider setting it programmatically in the <ph id=\"ph2\">&lt;xref:System.Windows.Application.OnActivated%2A&gt;</ph> method.","source":"Instead of using XAML to set the <xref:System.Windows.FrameworkElement.DataContext%2A> declaratively for the main window, consider setting it programmatically in the <xref:System.Windows.Application.OnActivated%2A> method."},{"pos":[11488,11496],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[11665,11778],"content":"<bpt id=\"p1\">[</bpt>Add a Splash Screen to a WPF Application<ept id=\"p1\">](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)</ept>","source":"[Add a Splash Screen to a WPF Application](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)"},{"pos":[11781,11864],"content":"<bpt id=\"p1\">[</bpt>Ngen.exe (Native Image Generator)<ept id=\"p1\">](../../tools/ngen-exe-native-image-generator.md)</ept>","source":"[Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md)"},{"pos":[11867,11984],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>generatePublisherEvidence&gt; Element<ept id=\"p1\">](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md)</ept>","source":"[\\<generatePublisherEvidence> Element](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md)"}]}