{"content":"---\ntitle: \"Chaining Standard Query Operators Together (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 66f2b0a9-2c23-4735-988e-bbc9dfb55c7b\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\n---\n# Chaining Standard Query Operators Together (C#)\nThis is the final topic in the [Tutorial: Chaining Queries Together (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md) tutorial.  \n  \n The standard query operators can also be chained together. For example, you can interject the <xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName> operator, and it also operates in a lazy fashion. No intermediate results are materialized by it.  \n  \n## Example  \n In this example, the <xref:System.Linq.Enumerable.Where%2A> method is called before calling `ConvertCollectionToUpperCase`. The <xref:System.Linq.Enumerable.Where%2A> method operates in almost exactly the same way as the lazy methods used in previous examples in this tutorial, `ConvertCollectionToUpperCase` and `AppendString`.  \n  \n One difference is that in this case, the <xref:System.Linq.Enumerable.Where%2A> method iterates through its source collection, determines that the first item does not pass the predicate, and then gets the next item, which does pass. It then yields the second item.  \n  \n However, the basic idea is the same: Intermediate collections are not materialized unless they have to be.  \n  \n When query expressions are used, they are converted to calls to the standard query operators, and the same principles apply.  \n  \n All of the examples in this section that are querying Office Open XML documents use the same principle. Deferred execution and lazy evaluation are some of the fundamental concepts that you must understand  to use LINQ (and LINQ to XML) effectively.  \n  \n```csharp  \npublic static class LocalExtensions  \n{  \n    public static IEnumerable<string>  \n      ConvertCollectionToUpperCase(this IEnumerable<string> source)  \n    {  \n        foreach (string str in source)  \n        {  \n            Console.WriteLine(\"ToUpper: source >{0}<\", str);  \n            yield return str.ToUpper();  \n        }  \n    }  \n  \n    public static IEnumerable<string>  \n      AppendString(this IEnumerable<string> source, string stringToAppend)  \n    {  \n        foreach (string str in source)  \n        {  \n            Console.WriteLine(\"AppendString: source >{0}<\", str);  \n            yield return str + stringToAppend;  \n        }  \n    }  \n}  \n  \nclass Program  \n{  \n    static void Main(string[] args)  \n    {  \n        string[] stringArray = { \"abc\", \"def\", \"ghi\" };  \n  \n        IEnumerable<string> q1 =  \n            from s in stringArray.ConvertCollectionToUpperCase()  \n            where s.CompareTo(\"D\") >= 0  \n            select s;  \n  \n        IEnumerable<string> q2 =  \n            from s in q1.AppendString(\"!!!\")  \n            select s;  \n  \n        foreach (string str in q2)  \n        {  \n            Console.WriteLine(\"Main: str >{0}<\", str);  \n            Console.WriteLine();  \n        }  \n    }  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nToUpper: source >abc<  \nToUpper: source >def<  \nAppendString: source >DEF<  \nMain: str >DEF!!!<  \n  \nToUpper: source >ghi<  \nAppendString: source >GHI<  \nMain: str >GHI!!!<  \n```  \n  \n## See Also  \n [Tutorial: Chaining Queries Together (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md)","nodes":[{"pos":[12,76],"content":"Chaining Standard Query Operators Together (C#) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Chaining Standard Query Operators Together (C#) | Microsoft Docs","pos":[0,64]}]},{"pos":[361,408],"content":"Chaining Standard Query Operators Together (C#)","linkify":"Chaining Standard Query Operators Together (C#)","nodes":[{"content":"Chaining Standard Query Operators Together (C#)","pos":[0,47]}]},{"pos":[409,582],"content":"This is the final topic in the <bpt id=\"p1\">[</bpt>Tutorial: Chaining Queries Together (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md)</ept> tutorial.","source":"This is the final topic in the [Tutorial: Chaining Queries Together (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md) tutorial."},{"content":"The standard query operators can also be chained together.","pos":[589,647]},{"content":"For example, you can interject the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName&gt;</ph> operator, and it also operates in a lazy fashion.","pos":[648,796],"source":" For example, you can interject the <xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName> operator, and it also operates in a lazy fashion."},{"content":"No intermediate results are materialized by it.","pos":[797,844]},{"pos":[853,860],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"In this example, the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method is called before calling <ph id=\"ph2\">`ConvertCollectionToUpperCase`</ph>.","pos":[864,987],"source":"In this example, the <xref:System.Linq.Enumerable.Where%2A> method is called before calling `ConvertCollectionToUpperCase`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method operates in almost exactly the same way as the lazy methods used in previous examples in this tutorial, <ph id=\"ph2\">`ConvertCollectionToUpperCase`</ph> and <ph id=\"ph3\">`AppendString`</ph>.","pos":[988,1192],"source":" The <xref:System.Linq.Enumerable.Where%2A> method operates in almost exactly the same way as the lazy methods used in previous examples in this tutorial, `ConvertCollectionToUpperCase` and `AppendString`."},{"content":"One difference is that in this case, the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method iterates through its source collection, determines that the first item does not pass the predicate, and then gets the next item, which does pass.","pos":[1199,1431],"source":"One difference is that in this case, the <xref:System.Linq.Enumerable.Where%2A> method iterates through its source collection, determines that the first item does not pass the predicate, and then gets the next item, which does pass."},{"content":"It then yields the second item.","pos":[1432,1463]},{"content":"However, the basic idea is the same: Intermediate collections are not materialized unless they have to be.","pos":[1470,1576]},{"content":"When query expressions are used, they are converted to calls to the standard query operators, and the same principles apply.","pos":[1583,1707]},{"content":"All of the examples in this section that are querying Office Open XML documents use the same principle.","pos":[1714,1817]},{"content":"Deferred execution and lazy evaluation are some of the fundamental concepts that you must understand  to use LINQ (and LINQ to XML) effectively.","pos":[1818,1962]},{"content":"This example produces the following output:","pos":[3225,3268]},{"pos":[3467,3475],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[3479,3611],"content":"<bpt id=\"p1\">[</bpt>Tutorial: Chaining Queries Together (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md)</ept>","source":"[Tutorial: Chaining Queries Together (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md)"}]}