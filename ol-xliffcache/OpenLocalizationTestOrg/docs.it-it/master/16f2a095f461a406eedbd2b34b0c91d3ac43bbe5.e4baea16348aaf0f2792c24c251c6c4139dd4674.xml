{"content":"---\ntitle: \"Type Design Guidelines\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"type design guidelines\"\n  - \"type design guidelines, about type design guidelines\"\n  - \"class library design guidelines [.NET Framework], type design guidelines\"\n  - \"types [.NET Framework], design guidelines\"\nms.assetid: 6b49314e-8bba-43ea-97ca-4e0255812f95\nauthor: \"KrzysztofCwalina\"\n---\n# Type Design Guidelines\nFrom the CLR perspective, there are only two categories of types—reference types and value types—but for the purpose of a discussion about framework design, we divide types into more logical groups, each with its own specific design rules.  \n  \n Classes are the general case of reference types. They make up the bulk of types in the majority of frameworks. Classes owe their popularity to the rich set of object-oriented features they support and to their general applicability. Base classes and abstract classes are special logical groups related to extensibility.  \n  \n Interfaces are types that can be implemented by both reference types and value types. They can thus serve as roots of polymorphic hierarchies of reference types and value types. In addition, interfaces can be used to simulate multiple inheritance, which is not natively supported by the CLR.  \n  \n Structs are the general case of value types and should be reserved for small, simple types, similar to language primitives.  \n  \n Enums are a special case of value types used to define short sets of values, such as days of the week, console colors, and so on.  \n  \n Static classes are types intended to be containers for static members. They are commonly used to provide shortcuts to other operations.  \n  \n Delegates, exceptions, attributes, arrays, and collections are all special cases of reference types intended for specific uses, and guidelines for their design and usage are discussed elsewhere in this book.  \n  \n **✓ DO** ensure that each type is a well-defined set of related members, not just a random collection of unrelated functionality.  \n  \n## In This Section  \n [Choosing Between Class and Struct](../../../docs/standard/design-guidelines/choosing-between-class-and-struct.md)  \n [Abstract Class Design](../../../docs/standard/design-guidelines/abstract-class.md)  \n [Static Class Design](../../../docs/standard/design-guidelines/static-class.md)  \n [Interface Design](../../../docs/standard/design-guidelines/interface.md)  \n [Struct Design](../../../docs/standard/design-guidelines/struct.md)  \n [Enum Design](../../../docs/standard/design-guidelines/enum.md)  \n [Nested Types](../../../docs/standard/design-guidelines/nested-types.md)  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See also\n\n- [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)\n","nodes":[{"pos":[4,401],"embed":true,"restype":"x-metadata","content":"title: \"Type Design Guidelines\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"type design guidelines\"\n  - \"type design guidelines, about type design guidelines\"\n  - \"class library design guidelines [.NET Framework], type design guidelines\"\n  - \"types [.NET Framework], design guidelines\"\nms.assetid: 6b49314e-8bba-43ea-97ca-4e0255812f95\nauthor: \"KrzysztofCwalina\"","nodes":[{"content":"Type Design Guidelines","nodes":[{"pos":[0,22],"content":"Type Design Guidelines","nodes":[{"content":"Type Design Guidelines","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[408,430],"content":"Type Design Guidelines","linkify":"Type Design Guidelines","nodes":[{"content":"Type Design Guidelines","pos":[0,22]}]},{"content":"From the CLR perspective, there are only two categories of types—reference types and value types—but for the purpose of a discussion about framework design, we divide types into more logical groups, each with its own specific design rules.","pos":[431,670]},{"content":"Classes are the general case of reference types.","pos":[677,725]},{"content":"They make up the bulk of types in the majority of frameworks.","pos":[726,787]},{"content":"Classes owe their popularity to the rich set of object-oriented features they support and to their general applicability.","pos":[788,909]},{"content":"Base classes and abstract classes are special logical groups related to extensibility.","pos":[910,996]},{"content":"Interfaces are types that can be implemented by both reference types and value types.","pos":[1003,1088]},{"content":"They can thus serve as roots of polymorphic hierarchies of reference types and value types.","pos":[1089,1180]},{"content":"In addition, interfaces can be used to simulate multiple inheritance, which is not natively supported by the CLR.","pos":[1181,1294]},{"content":"Structs are the general case of value types and should be reserved for small, simple types, similar to language primitives.","pos":[1301,1424]},{"content":"Enums are a special case of value types used to define short sets of values, such as days of the week, console colors, and so on.","pos":[1431,1560]},{"content":"Static classes are types intended to be containers for static members.","pos":[1567,1637]},{"content":"They are commonly used to provide shortcuts to other operations.","pos":[1638,1702]},{"content":"Delegates, exceptions, attributes, arrays, and collections are all special cases of reference types intended for specific uses, and guidelines for their design and usage are discussed elsewhere in this book.","pos":[1709,1916]},{"pos":[1923,2052],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> ensure that each type is a well-defined set of related members, not just a random collection of unrelated functionality.","source":"**✓ DO** ensure that each type is a well-defined set of related members, not just a random collection of unrelated functionality."},{"pos":[2061,2076],"content":"In This Section","linkify":"In This Section","nodes":[{"content":"In This Section","pos":[0,15]}]},{"content":"<bpt id=\"p1\">[</bpt>Choosing Between Class and Struct<ept id=\"p1\">](../../../docs/standard/design-guidelines/choosing-between-class-and-struct.md)</ept>","pos":[2080,2194],"source":"[Choosing Between Class and Struct](../../../docs/standard/design-guidelines/choosing-between-class-and-struct.md)"},{"content":"<bpt id=\"p1\">[</bpt>Abstract Class Design<ept id=\"p1\">](../../../docs/standard/design-guidelines/abstract-class.md)</ept>","pos":[2198,2281],"source":"[Abstract Class Design](../../../docs/standard/design-guidelines/abstract-class.md)"},{"content":"<bpt id=\"p1\">[</bpt>Static Class Design<ept id=\"p1\">](../../../docs/standard/design-guidelines/static-class.md)</ept>","pos":[2285,2364],"source":"[Static Class Design](../../../docs/standard/design-guidelines/static-class.md)"},{"content":"<bpt id=\"p1\">[</bpt>Interface Design<ept id=\"p1\">](../../../docs/standard/design-guidelines/interface.md)</ept>","pos":[2368,2441],"source":"[Interface Design](../../../docs/standard/design-guidelines/interface.md)"},{"content":"<bpt id=\"p1\">[</bpt>Struct Design<ept id=\"p1\">](../../../docs/standard/design-guidelines/struct.md)</ept>","pos":[2445,2512],"source":"[Struct Design](../../../docs/standard/design-guidelines/struct.md)"},{"content":"<bpt id=\"p1\">[</bpt>Enum Design<ept id=\"p1\">](../../../docs/standard/design-guidelines/enum.md)</ept>","pos":[2516,2579],"source":"[Enum Design](../../../docs/standard/design-guidelines/enum.md)"},{"content":"<bpt id=\"p1\">[</bpt>Nested Types<ept id=\"p1\">](../../../docs/standard/design-guidelines/nested-types.md)</ept>","pos":[2583,2655],"source":"[Nested Types](../../../docs/standard/design-guidelines/nested-types.md)"},{"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","pos":[2659,2726],"source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[2733,3138],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[3147,3155],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3159,3239],"content":"<bpt id=\"p1\">[</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept>","source":"[Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)"}]}