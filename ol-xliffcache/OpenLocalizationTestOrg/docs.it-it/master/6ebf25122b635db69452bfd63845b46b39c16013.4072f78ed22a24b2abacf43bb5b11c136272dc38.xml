{"content":"---\ntitle: \"Friend Assemblies (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: b65ea7de-0801-477a-a39c-e914c2cc107c\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Friend Assemblies (C#)\nA *friend assembly* is an assembly that can access another assembly's [internal](../../../../csharp/language-reference/keywords/internal.md) types and members. If you identify an assembly as a friend assembly, you no longer have to mark types and members as public in order for them to be accessed by other assemblies. This is especially convenient in the following scenarios:  \n  \n-   During unit testing, when test code runs in a separate assembly but requires access to members in the assembly being tested that are marked as `internal` .  \n  \n-   When you are developing a class library and additions to the library are contained in separate assemblies but require access to members in existing assemblies that are marked as `internal` .  \n  \n## Remarks  \n You can use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute to identify one or more friend assemblies for a given assembly. The following example uses the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in assembly A and specifies assembly `AssemblyB` as a friend assembly. This gives assembly `AssemblyB` access to all types and members in assembly A that are marked as `internal`.  \n  \n> [!NOTE]\n>  When you compile an assembly (assembly `AssemblyB`) that will access internal types or internal members of another assembly (assembly *A*), you must explicitly specify the name of the output file (.exe or .dll) by using the **/out** compiler option. This is required because the compiler has not yet generated the name for the assembly it is building at the time it is binding to external references. For more information, see [/out (C#)](../../../../csharp/language-reference/compiler-options/out-compiler-option.md) .  \n  \n```csharp  \nusing System.Runtime.CompilerServices;  \nusing System;  \n  \n[assembly: InternalsVisibleTo(\"AssemblyB\")]  \n  \n// The class is internal by default.  \nclass FriendClass  \n{  \n    public void Test()  \n    {  \n        Console.WriteLine(\"Sample Class\");  \n    }  \n}  \n  \n// Public class that has an internal method.  \npublic class ClassWithFriendMethod  \n{  \n    internal void Test()  \n    {  \n        Console.WriteLine(\"Sample Method\");  \n    }  \n  \n}  \n```  \n  \n Only assemblies that you explicitly specify as friends can access `internal` types and members. For example, if assembly B is a friend of assembly A and assembly C references assembly B, C does not have access to `internal` types in A.  \n  \n The compiler performs some basic validation of the friend assembly name passed to the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute. If assembly *A* declares *B* as a friend assembly, the validation rules are as follows:  \n  \n-   If assembly *A* is strong named, assembly *B* must also be strong named. The friend assembly name that is passed to the attribute must consist of the assembly name and the public key of the strong-name key that is used to sign assembly *B*.  \n  \n     The friend assembly name that is passed to the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute cannot be the strong name of assembly *B*: do not include the assembly version, culture, architecture, or public key token.  \n  \n-   If assembly *A* is not strong named, the friend assembly name should consist of only the assembly name. For more information, see [How to: Create Unsigned Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-unsigned-friend-assemblies.md).  \n  \n-   If assembly *B* is strong named, you must specify the strong-name key for assembly *B* by using the project setting or the command-line `/keyfile` compiler option. For more information, see [How to: Create Signed Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies.md).  \n  \n The <xref:System.Security.Permissions.StrongNameIdentityPermission> class also provides the ability to share types, with the following differences:  \n  \n-   <xref:System.Security.Permissions.StrongNameIdentityPermission> applies to an individual type, while a friend assembly applies to the whole assembly.  \n  \n-   If there are hundreds of types in assembly *A* that you want to share with assembly *B*, you have to add <xref:System.Security.Permissions.StrongNameIdentityPermission> to all of them. If you use a friend assembly, you only need to declare the friend relationship once.  \n  \n-   If you use <xref:System.Security.Permissions.StrongNameIdentityPermission>, the types you want to share have to be declared as public. If you use a friend assembly, the shared types are declared as `internal`.  \n  \n For information about how to access an assembly's `internal` types and methods from a module file (a file with the .netmodule extension), see [/moduleassemblyname (C#)](../../../../csharp/language-reference/compiler-options/moduleassemblyname-compiler-option.md).  \n  \n## See Also  \n <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute>   \n <xref:System.Security.Permissions.StrongNameIdentityPermission>   \n [How to: Create Unsigned Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-unsigned-friend-assemblies.md)   \n [How to: Create Signed Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies.md)   \n [Assemblies and the Global Assembly Cache (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/index.md)   \n [C# Programming Guide](../../../../csharp/programming-guide/index.md)","nodes":[{"pos":[12,51],"content":"Friend Assemblies (C#) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Friend Assemblies (C#) | Microsoft Docs","pos":[0,39]}]},{"pos":[410,432],"content":"Friend Assemblies (C#)","linkify":"Friend Assemblies (C#)","nodes":[{"content":"Friend Assemblies (C#)","pos":[0,22]}]},{"content":"A <bpt id=\"p1\">*</bpt>friend assembly<ept id=\"p1\">*</ept> is an assembly that can access another assembly's <bpt id=\"p2\">[</bpt>internal<ept id=\"p2\">](../../../../csharp/language-reference/keywords/internal.md)</ept> types and members.","pos":[433,592],"source":"A *friend assembly* is an assembly that can access another assembly's [internal](../../../../csharp/language-reference/keywords/internal.md) types and members."},{"content":"If you identify an assembly as a friend assembly, you no longer have to mark types and members as public in order for them to be accessed by other assemblies.","pos":[593,751]},{"content":"This is especially convenient in the following scenarios:","pos":[752,809]},{"pos":[819,974],"content":"During unit testing, when test code runs in a separate assembly but requires access to members in the assembly being tested that are marked as <ph id=\"ph1\">`internal`</ph> .","source":"During unit testing, when test code runs in a separate assembly but requires access to members in the assembly being tested that are marked as `internal` ."},{"pos":[984,1174],"content":"When you are developing a class library and additions to the library are contained in separate assemblies but require access to members in existing assemblies that are marked as <ph id=\"ph1\">`internal`</ph> .","source":"When you are developing a class library and additions to the library are contained in separate assemblies but require access to members in existing assemblies that are marked as `internal` ."},{"pos":[1183,1190],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attribute to identify one or more friend assemblies for a given assembly.","pos":[1194,1350],"source":"You can use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute to identify one or more friend assemblies for a given assembly."},{"content":"The following example uses the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attribute in assembly A and specifies assembly <ph id=\"ph2\">`AssemblyB`</ph> as a friend assembly.","pos":[1351,1529],"source":" The following example uses the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in assembly A and specifies assembly `AssemblyB` as a friend assembly."},{"content":"This gives assembly <ph id=\"ph1\">`AssemblyB`</ph> access to all types and members in assembly A that are marked as <ph id=\"ph2\">`internal`</ph>.","pos":[1530,1638],"source":" This gives assembly `AssemblyB` access to all types and members in assembly A that are marked as `internal`."},{"pos":[1646,2176],"content":"[!NOTE]\n When you compile an assembly (assembly `AssemblyB`) that will access internal types or internal members of another assembly (assembly *A*), you must explicitly specify the name of the output file (.exe or .dll) by using the **/out** compiler option. This is required because the compiler has not yet generated the name for the assembly it is building at the time it is binding to external references. For more information, see [/out (C#)](../../../../csharp/language-reference/compiler-options/out-compiler-option.md) .","leadings":["","> "],"nodes":[{"content":" When you compile an assembly (assembly `AssemblyB`) that will access internal types or internal members of another assembly (assembly *A*), you must explicitly specify the name of the output file (.exe or .dll) by using the **/out** compiler option. This is required because the compiler has not yet generated the name for the assembly it is building at the time it is binding to external references. For more information, see [/out (C#)](../../../../csharp/language-reference/compiler-options/out-compiler-option.md) .","pos":[8,528],"nodes":[{"content":"When you compile an assembly (assembly <ph id=\"ph1\">`AssemblyB`</ph>) that will access internal types or internal members of another assembly (assembly <bpt id=\"p1\">*</bpt>A<ept id=\"p1\">*</ept>), you must explicitly specify the name of the output file (.exe or .dll) by using the <bpt id=\"p2\">**</bpt>/out<ept id=\"p2\">**</ept> compiler option.","pos":[1,250],"source":" When you compile an assembly (assembly `AssemblyB`) that will access internal types or internal members of another assembly (assembly *A*), you must explicitly specify the name of the output file (.exe or .dll) by using the **/out** compiler option."},{"content":"This is required because the compiler has not yet generated the name for the assembly it is building at the time it is binding to external references.","pos":[251,401]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/out (C#)<ept id=\"p1\">](../../../../csharp/language-reference/compiler-options/out-compiler-option.md)</ept> .","pos":[402,520],"source":" For more information, see [/out (C#)](../../../../csharp/language-reference/compiler-options/out-compiler-option.md) ."}]}]},{"content":"Only assemblies that you explicitly specify as friends can access <ph id=\"ph1\">`internal`</ph> types and members.","pos":[2653,2748],"source":"Only assemblies that you explicitly specify as friends can access `internal` types and members."},{"content":"For example, if assembly B is a friend of assembly A and assembly C references assembly B, C does not have access to <ph id=\"ph1\">`internal`</ph> types in A.","pos":[2749,2888],"source":" For example, if assembly B is a friend of assembly A and assembly C references assembly B, C does not have access to `internal` types in A."},{"content":"The compiler performs some basic validation of the friend assembly name passed to the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attribute.","pos":[2895,3058],"source":"The compiler performs some basic validation of the friend assembly name passed to the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute."},{"content":"If assembly <bpt id=\"p1\">*</bpt>A<ept id=\"p1\">*</ept> declares <bpt id=\"p2\">*</bpt>B<ept id=\"p2\">*</ept> as a friend assembly, the validation rules are as follows:","pos":[3059,3146],"source":" If assembly *A* declares *B* as a friend assembly, the validation rules are as follows:"},{"content":"If assembly <bpt id=\"p1\">*</bpt>A<ept id=\"p1\">*</ept> is strong named, assembly <bpt id=\"p2\">*</bpt>B<ept id=\"p2\">*</ept> must also be strong named.","pos":[3156,3228],"source":"If assembly *A* is strong named, assembly *B* must also be strong named."},{"content":"The friend assembly name that is passed to the attribute must consist of the assembly name and the public key of the strong-name key that is used to sign assembly <bpt id=\"p1\">*</bpt>B<ept id=\"p1\">*</ept>.","pos":[3229,3396],"source":" The friend assembly name that is passed to the attribute must consist of the assembly name and the public key of the strong-name key that is used to sign assembly *B*."},{"pos":[3407,3654],"content":"The friend assembly name that is passed to the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attribute cannot be the strong name of assembly <bpt id=\"p1\">*</bpt>B<ept id=\"p1\">*</ept>: do not include the assembly version, culture, architecture, or public key token.","source":"The friend assembly name that is passed to the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute cannot be the strong name of assembly *B*: do not include the assembly version, culture, architecture, or public key token."},{"content":"If assembly <bpt id=\"p1\">*</bpt>A<ept id=\"p1\">*</ept> is not strong named, the friend assembly name should consist of only the assembly name.","pos":[3664,3767],"source":"If assembly *A* is not strong named, the friend assembly name should consist of only the assembly name."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Create Unsigned Friend Assemblies (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-unsigned-friend-assemblies.md)</ept>.","pos":[3768,3949],"source":" For more information, see [How to: Create Unsigned Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-unsigned-friend-assemblies.md)."},{"content":"If assembly <bpt id=\"p1\">*</bpt>B<ept id=\"p1\">*</ept> is strong named, you must specify the strong-name key for assembly <bpt id=\"p2\">*</bpt>B<ept id=\"p2\">*</ept> by using the project setting or the command-line <ph id=\"ph1\">`/keyfile`</ph> compiler option.","pos":[3959,4122],"source":"If assembly *B* is strong named, you must specify the strong-name key for assembly *B* by using the project setting or the command-line `/keyfile` compiler option."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Create Signed Friend Assemblies (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies.md)</ept>.","pos":[4123,4300],"source":" For more information, see [How to: Create Signed Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies.md)."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Security.Permissions.StrongNameIdentityPermission&gt;</ph> class also provides the ability to share types, with the following differences:","pos":[4307,4454],"source":"The <xref:System.Security.Permissions.StrongNameIdentityPermission> class also provides the ability to share types, with the following differences:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Security.Permissions.StrongNameIdentityPermission&gt;</ph> applies to an individual type, while a friend assembly applies to the whole assembly.","pos":[4464,4613],"source":"<xref:System.Security.Permissions.StrongNameIdentityPermission> applies to an individual type, while a friend assembly applies to the whole assembly."},{"content":"If there are hundreds of types in assembly <bpt id=\"p1\">*</bpt>A<ept id=\"p1\">*</ept> that you want to share with assembly <bpt id=\"p2\">*</bpt>B<ept id=\"p2\">*</ept>, you have to add <ph id=\"ph1\">&lt;xref:System.Security.Permissions.StrongNameIdentityPermission&gt;</ph> to all of them.","pos":[4623,4807],"source":"If there are hundreds of types in assembly *A* that you want to share with assembly *B*, you have to add <xref:System.Security.Permissions.StrongNameIdentityPermission> to all of them."},{"content":"If you use a friend assembly, you only need to declare the friend relationship once.","pos":[4808,4892]},{"content":"If you use <ph id=\"ph1\">&lt;xref:System.Security.Permissions.StrongNameIdentityPermission&gt;</ph>, the types you want to share have to be declared as public.","pos":[4902,5036],"source":"If you use <xref:System.Security.Permissions.StrongNameIdentityPermission>, the types you want to share have to be declared as public."},{"content":"If you use a friend assembly, the shared types are declared as <ph id=\"ph1\">`internal`</ph>.","pos":[5037,5111],"source":" If you use a friend assembly, the shared types are declared as `internal`."},{"pos":[5118,5381],"content":"For information about how to access an assembly's <ph id=\"ph1\">`internal`</ph> types and methods from a module file (a file with the .netmodule extension), see <bpt id=\"p1\">[</bpt>/moduleassemblyname (C#)<ept id=\"p1\">](../../../../csharp/language-reference/compiler-options/moduleassemblyname-compiler-option.md)</ept>.","source":"For information about how to access an assembly's `internal` types and methods from a module file (a file with the .netmodule extension), see [/moduleassemblyname (C#)](../../../../csharp/language-reference/compiler-options/moduleassemblyname-compiler-option.md)."},{"pos":[5390,5398],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph>","pos":[5402,5468],"source":"<xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Security.Permissions.StrongNameIdentityPermission&gt;</ph>","pos":[5473,5536],"source":" <xref:System.Security.Permissions.StrongNameIdentityPermission> "},{"content":"<bpt id=\"p1\"> [</bpt>How to: Create Unsigned Friend Assemblies (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-unsigned-friend-assemblies.md)</ept><ph id=\"ph1\"> </ph>","pos":[5540,5696],"source":" [How to: Create Unsigned Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-unsigned-friend-assemblies.md) "},{"content":"<bpt id=\"p1\"> [</bpt>How to: Create Signed Friend Assemblies (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies.md)</ept><ph id=\"ph1\"> </ph>","pos":[5699,5851],"source":" [How to: Create Signed Friend Assemblies (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Assemblies and the Global Assembly Cache (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/assemblies-gac/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5854,5974],"source":" [Assemblies and the Global Assembly Cache (C#)](../../../../csharp/programming-guide/concepts/assemblies-gac/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>C# Programming Guide<ept id=\"p1\">](../../../../csharp/programming-guide/index.md)</ept>","pos":[5977,6047],"source":" [C# Programming Guide](../../../../csharp/programming-guide/index.md)"}]}