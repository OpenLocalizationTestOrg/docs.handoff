{"content":"---\ntitle: \"Benefits of Generics - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generics [C#], benefits\"\nms.assetid: 80f037cd-9ea7-48be-bfc1-219bfb2d4277\n---\n# Benefits of Generics (C# Programming Guide)\nGenerics provide the solution to a limitation in earlier versions of the common language runtime and the C# language in which generalization is accomplished by casting types to and from the universal base type <xref:System.Object>. By creating a generic class, you can create a collection that is type-safe at compile-time.  \n  \n The limitations of using non-generic collection classes can be demonstrated by writing a short program that uses the <xref:System.Collections.ArrayList> collection class from the .NET class library. An instance of the <xref:System.Collections.ArrayList> class can store any reference or value type.  \n  \n [!code-csharp[csProgGuideGenerics#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#4)]  \n  \n But this convenience comes at a cost. Any reference or value type that is added to an <xref:System.Collections.ArrayList> is implicitly upcast to <xref:System.Object>. If the items are value types, they must be boxed when they are added to the list, and unboxed when they are retrieved. Both the casting and the boxing and unboxing operations decrease performance; the effect of boxing and unboxing can be very significant in scenarios where you must iterate over large collections.  \n  \n The other limitation is lack of compile-time type checking; because an <xref:System.Collections.ArrayList> casts everything to <xref:System.Object>, there is no way at compile-time to prevent client code from doing something such as this:  \n  \n [!code-csharp[csProgGuideGenerics#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#5)]  \n  \n Although perfectly acceptable and sometimes intentional if you are creating a heterogeneous collection, combining strings and `ints` in a single <xref:System.Collections.ArrayList> is more likely to be a programming error, and this error will not be detected until runtime.  \n  \n In versions 1.0 and 1.1 of the C# language, you could avoid the dangers of generalized code in the .NET Framework base class library collection classes only by writing your own type specific collections. Of course, because such a class is not reusable for more than one data type, you lose the benefits of generalization, and you have to rewrite the class for each type that will be stored.  \n  \n What <xref:System.Collections.ArrayList> and other similar classes really need is a way for client code to specify, on a per-instance basis, the particular data type that they intend to use. That would eliminate the need for the upcast to <xref:System.Object> and would also make it possible for the compiler to do type checking. In other words, <xref:System.Collections.ArrayList> needs a type parameter. That is exactly what generics provide. In the generic <xref:System.Collections.Generic.List%601> collection, in the <xref:System.Collections.Generic> namespace, the same operation of adding items to the collection resembles this:  \n  \n [!code-csharp[csProgGuideGenerics#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#6)]  \n  \n For client code, the only added syntax with <xref:System.Collections.Generic.List%601> compared to <xref:System.Collections.ArrayList> is the type argument in the declaration and instantiation. In return for this slightly more coding complexity, you can create a list that is not only safer than <xref:System.Collections.ArrayList>, but also significantly faster, especially when the list items are value types.  \n  \n## See also\n\n- <xref:System.Collections.Generic>\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)\n- [Boxing and Unboxing](../../../csharp/programming-guide/types/boxing-and-unboxing.md)\n- [When to Use Generic Collections](../../../standard/collections/when-to-use-generic-collections.md)\n- [Guidelines for Collections](../../../standard/design-guidelines/guidelines-for-collections.md)\n","nodes":[{"pos":[4,197],"embed":true,"restype":"x-metadata","content":"title: \"Benefits of Generics - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generics [C#], benefits\"\nms.assetid: 80f037cd-9ea7-48be-bfc1-219bfb2d4277","nodes":[{"content":"Benefits of Generics - C# Programming Guide","nodes":[{"pos":[0,43],"content":"Benefits of Generics - C# Programming Guide","nodes":[{"content":"Benefits of Generics - C# Programming Guide","pos":[0,43]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[204,247],"content":"Benefits of Generics (C# Programming Guide)","linkify":"Benefits of Generics (C# Programming Guide)","nodes":[{"content":"Benefits of Generics (C# Programming Guide)","pos":[0,43]}]},{"content":"Generics provide the solution to a limitation in earlier versions of the common language runtime and the C# language in which generalization is accomplished by casting types to and from the universal base type <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>.","pos":[248,479],"source":"Generics provide the solution to a limitation in earlier versions of the common language runtime and the C# language in which generalization is accomplished by casting types to and from the universal base type <xref:System.Object>."},{"content":"By creating a generic class, you can create a collection that is type-safe at compile-time.","pos":[480,571]},{"content":"The limitations of using non-generic collection classes can be demonstrated by writing a short program that uses the <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> collection class from the .NET class library.","pos":[578,776],"source":"The limitations of using non-generic collection classes can be demonstrated by writing a short program that uses the <xref:System.Collections.ArrayList> collection class from the .NET class library."},{"content":"An instance of the <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> class can store any reference or value type.","pos":[777,876],"source":" An instance of the <xref:System.Collections.ArrayList> class can store any reference or value type."},{"content":"But this convenience comes at a cost.","pos":[1012,1049]},{"content":"Any reference or value type that is added to an <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> is implicitly upcast to <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[1050,1179],"source":" Any reference or value type that is added to an <xref:System.Collections.ArrayList> is implicitly upcast to <xref:System.Object>."},{"content":"If the items are value types, they must be boxed when they are added to the list, and unboxed when they are retrieved.","pos":[1180,1298]},{"content":"Both the casting and the boxing and unboxing operations decrease performance; the effect of boxing and unboxing can be very significant in scenarios where you must iterate over large collections.","pos":[1299,1494]},{"pos":[1501,1739],"content":"The other limitation is lack of compile-time type checking; because an <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> casts everything to <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, there is no way at compile-time to prevent client code from doing something such as this:","source":"The other limitation is lack of compile-time type checking; because an <xref:System.Collections.ArrayList> casts everything to <xref:System.Object>, there is no way at compile-time to prevent client code from doing something such as this:"},{"pos":[1875,2148],"content":"Although perfectly acceptable and sometimes intentional if you are creating a heterogeneous collection, combining strings and <ph id=\"ph1\">`ints`</ph> in a single <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph> is more likely to be a programming error, and this error will not be detected until runtime.","source":"Although perfectly acceptable and sometimes intentional if you are creating a heterogeneous collection, combining strings and `ints` in a single <xref:System.Collections.ArrayList> is more likely to be a programming error, and this error will not be detected until runtime."},{"content":"In versions 1.0 and 1.1 of the C# language, you could avoid the dangers of generalized code in the .NET Framework base class library collection classes only by writing your own type specific collections.","pos":[2155,2358]},{"content":"Of course, because such a class is not reusable for more than one data type, you lose the benefits of generalization, and you have to rewrite the class for each type that will be stored.","pos":[2359,2545]},{"content":"What <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> and other similar classes really need is a way for client code to specify, on a per-instance basis, the particular data type that they intend to use.","pos":[2552,2742],"source":"What <xref:System.Collections.ArrayList> and other similar classes really need is a way for client code to specify, on a per-instance basis, the particular data type that they intend to use."},{"content":"That would eliminate the need for the upcast to <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> and would also make it possible for the compiler to do type checking.","pos":[2743,2881],"source":" That would eliminate the need for the upcast to <xref:System.Object> and would also make it possible for the compiler to do type checking."},{"content":"In other words, <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> needs a type parameter.","pos":[2882,2957],"source":" In other words, <xref:System.Collections.ArrayList> needs a type parameter."},{"content":"That is exactly what generics provide.","pos":[2958,2996]},{"content":"In the generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> collection, in the <ph id=\"ph2\">&lt;xref:System.Collections.Generic&gt;</ph> namespace, the same operation of adding items to the collection resembles this:","pos":[2997,3187],"source":" In the generic <xref:System.Collections.Generic.List%601> collection, in the <xref:System.Collections.Generic> namespace, the same operation of adding items to the collection resembles this:"},{"content":"For client code, the only added syntax with <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> compared to <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph> is the type argument in the declaration and instantiation.","pos":[3323,3516],"source":"For client code, the only added syntax with <xref:System.Collections.Generic.List%601> compared to <xref:System.Collections.ArrayList> is the type argument in the declaration and instantiation."},{"content":"In return for this slightly more coding complexity, you can create a list that is not only safer than <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph>, but also significantly faster, especially when the list items are value types.","pos":[3517,3734],"source":" In return for this slightly more coding complexity, you can create a list that is not only safer than <xref:System.Collections.ArrayList>, but also significantly faster, especially when the list items are value types."},{"pos":[3743,3751],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3791,3857],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[3860,3958],"content":"<bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept>","source":"[Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)"},{"pos":[3961,4046],"content":"<bpt id=\"p1\">[</bpt>Boxing and Unboxing<ept id=\"p1\">](../../../csharp/programming-guide/types/boxing-and-unboxing.md)</ept>","source":"[Boxing and Unboxing](../../../csharp/programming-guide/types/boxing-and-unboxing.md)"},{"pos":[4049,4148],"content":"<bpt id=\"p1\">[</bpt>When to Use Generic Collections<ept id=\"p1\">](../../../standard/collections/when-to-use-generic-collections.md)</ept>","source":"[When to Use Generic Collections](../../../standard/collections/when-to-use-generic-collections.md)"},{"pos":[4151,4246],"content":"<bpt id=\"p1\">[</bpt>Guidelines for Collections<ept id=\"p1\">](../../../standard/design-guidelines/guidelines-for-collections.md)</ept>","source":"[Guidelines for Collections](../../../standard/design-guidelines/guidelines-for-collections.md)"}]}