{"content":"---\ntitle: What's new in .NET Core 3.0\ndescription: Learn about the new features found in .NET Core 3.0.\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nauthor: thraka\nms.author: adegeo\nms.date: 12/31/2018\n---\n\n# What's new in .NET Core 3.0 (Preview 2)\n\nThis article describes what is new in .NET Core 3.0 (preview 2). One of the biggest enhancements is support for Windows desktop applications (Windows only). By utilizing a .NET Core 3.0 SDK component called Windows Desktop, you can port your Windows Forms and Windows Presentation Foundation (WPF) applications. To be clear, the Windows Desktop component is only supported and included on Windows. For more information, see the section [Windows desktop](#windows-desktop) below.\n\n.NET Core 3.0 adds support for C# 8.0.\n\n[Download and get started with .NET Core 3.0 Preview 2](https://aka.ms/netcore3download) right now on Windows, Mac and Linux. You can see complete details of the release in the [.NET Core 3.0 Preview 2 release notes](https://aka.ms/netcore3releasenotes).\n\nFor more information about what was released with each version, see the following announcements:\n\n- [.NET Core 3.0 Preview 1 announcement](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/)\n- [.NET Core 3.0 Preview 2 announcement](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-2/)\n\n## C# 8\n\n.NET Core 3.0 supports C# 8, and as of .NET Core 3.0 Preview 2, supports these new features. For more information about C# 8.0 features, see the following blog posts:\n\n- [Do more with patterns in C# 8.0](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/)\n- [Take C# 8.0 for a spin](https://devblogs.microsoft.com/dotnet/take-c-8-0-for-a-spin/)\n- [Building C# 8.0](https://devblogs.microsoft.com/dotnet/building-c-8-0/)\n\n### Ranges and indices\n\nThe new `Index` type can be used for indexing. You can create one from an `int` that counts from the beginning, or with a prefix `^` operator (C#) that counts from the end:\n\n```csharp\nIndex i1 = 3;  // number 3 from beginning\nIndex i2 = ^4; // number 4 from end\nint[] a = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nConsole.WriteLine($\"{a[i1]}, {a[i2]}\"); // \"3, 6\"\n```\n\nThere is also a `Range` type, which consists of two `Index` values, one for the start and one for the end, and can be written with a `x..y` range expression (C#). You can then index with a `Range` in order to produce a slice:\n\n```csharp\nvar slice = a[i1..i2]; // { 3, 4, 5 }\n```\n\n### Async streams\n\nThe `IAsyncEnumerable<T>` type is a new asynchronous version of `IEnumerable<T>`. The language lets you `await foreach` over `IAsyncEnumerable<T>` to consume their elements, and use `yield return` to them to produce elements.\n\nThe following example demonstrates both production and consumption of async streams. The `foreach` statement is async and itself uses `yield return` to produce an async stream for callers. This pattern (using `yield return`) is the recommended model for producing async streams.\n\n```csharp\nasync IAsyncEnumerable<int> GetBigResultsAsync()\n{\n    await foreach (var result in GetResultsAsync())\n    {\n        if (result > 20) yield return result; \n    }\n}\n```\n\nIn addition to being able to `await foreach`, you can also create async iterators, for example, an iterator that returns an `IAsyncEnumerable/IAsyncEnumerator` that you can both `await` and `yield` in. For objects that need to be disposed, you can use `IAsyncDisposable`, which various BCL types implement, such as `Stream` and `Timer`.\n\n>[!NOTE]\n>You need .NET Core 3.0 Preview 2 to use async streams if you want to develop with either Visual Studio 2019 Preview 2 or the latest preview of the [C# extension for Visual Studio Code](https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta5). If you are using .NET Core 3.0 Preview 2 at the command line, then everything will work as expected.\n\n### Using Declarations\n\n*Using declarations* are a new way to ensure your object is properly disposed. A *using declaration* keeps the object alive while it is still in scope. Once the object becomes out of scope, it is automatically disposed. This will reduce nested *using statements* and make your code cleaner.\n\n```csharp\nstatic void Main(string[] args)\n{\n    using var options = Parse(args);\n    if (options[\"verbose\"]) { WriteLine(\"Logging...\"); }\n\n} // options disposed here\n```\n\n### Switch Expressions\n\n*Switch expressions* are a cleaner way of doing a *switch statement* but, since it's an expression, returns a value. *Switch expressions* are also fully integrated with pattern matching, and use the discard pattern, `_`, to represent the `default` value.\n\nYou can see the syntax for *switch expressions* in the following example:\n\n```csharp\nstatic string Display(object o) => o switch\n{\n    Point { X: 0, Y: 0 }         => \"origin\",\n    Point { X: var x, Y: var y } => $\"({x}, {y})\",\n    _                            => \"unknown\"\n};\n```\n\nThere are two patterns at play in this example. `o` first matches with the `Point` *type pattern* and then with the *property pattern* inside the *{curly braces}*. The `_` describes the `discard pattern`, which is the same as `default` for *switch statements*.\n\nPatterns enable you to write declarative code that captures your intent instead of procedural code that implements tests for it. The compiler becomes responsible for implementing that boring procedural code and is guaranteed to always do it correctly.\n\nThere will still be cases where *switch statements* will be a better choice than *switch expressions* and patterns can be used with both syntax styles.\n\nFor more information, see [Do more with patterns in C# 8.0](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/).\n\n## IEEE Floating-point improvements\n\nFloating point APIs are in the process of being updated to comply with [IEEE 754-2008 revision](https://en.wikipedia.org/wiki/IEEE_754-2008_revision). The goal of these changes is to expose all \"required\" operations and ensure that they are behaviorally compliant with the IEEE spec.\n\nParsing and formatting fixes:\n\n* Correctly parse and round inputs of any length.\n* Correctly parse and format negative zero.\n* Correctly parse Infinity and NaN by performing a case-insensitive check and allowing an optional preceding `+` where applicable.\n\nNew Math APIs have:\n\n* `BitIncrement/BitDecrement`\\\nCorresponds to the `nextUp` and `nextDown` IEEE operations. They return the smallest floating-point number that compares greater or lesser than the input (respectively). For example, `Math.BitIncrement(0.0)` would return `double.Epsilon`.\n\n* `MaxMagnitude/MinMagnitude`\\\nCorresponds to the `maxNumMag` and `minNumMag` IEEE operations, they return the value that is greater or lesser in magnitude of the two inputs (respectively). For example, `Math.MaxMagnitude(2.0, -3.0)` would return `-3.0`.\n\n* `ILogB`\\\nCorresponds to the `logB` IEEE operation which returns an integral value, it returns the integral base-2 log of the input parameter. This is effectively the same as `floor(log2(x))`, but done with minimal rounding error.\n\n* `ScaleB`\\\nCorresponds to the `scaleB` IEEE operation which takes an integral value, it returns effectively `x * pow(2, n)`, but is done with minimal rounding error.\n\n* `Log2`\\\nCorresponds to the `log2` IEEE operation, it returns the base-2 logarithm. It minimizes rounding error.\n\n* `FusedMultiplyAdd`\\\nCorresponds to the `fma` IEEE operation, it performs a fused multiply add. That is, it does `(x * y) + z` as a single operation, there-by minimizing the rounding error. An example would be `FusedMultiplyAdd(1e308, 2.0, -1e308)` which returns `1e308`. The regular `(1e308 * 2.0) - 1e308` returns `double.PositiveInfinity`.\n\n* `CopySign`\\\nCorresponds to the `copySign` IEEE operation, it returns the value of `x`, but with the sign of `y`.\n\n## .NET Platform Dependent Intrinsics\n\nAPIs have been added that allow access to certain perf-oriented CPU instructions, such as the **SIMD** or **Bit Manipulation instruction** sets. These instructions can help achieve big performance improvements in certain scenarios, such as processing data efficiently in parallel. In addition to exposing the APIs for your programs to use, the .NET libraries have begun using these instructions to improve performance.\n\nThe following CoreCLR PRs demonstrate a few of the intrinsics, either via implementation or use:\n\n* [Implement simple SSE2 hardware intrinsics](https://github.com/dotnet/coreclr/pull/15585)\n* [Implement the SSE hardware intrinsics](https://github.com/dotnet/coreclr/pull/15538)\n* [Arm64 Base HW Intrinsics](https://github.com/dotnet/coreclr/pull/16822)\n* [Use TZCNT and LZCNT for Locate{First|Last}Found{Byte|Char}](https://github.com/dotnet/coreclr/pull/21073)\n\nFor more information, see [.NET Platform Dependent Intrinsics](https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md), which defines an approach for defining this hardware infrastructure, allowing Microsoft, chip vendors, or any other company or individual to define hardware/chip APIs that should be exposed to .NET code.\n\n## Default executables\n\n.NET Core will now build [framework-dependent executables](../deploying/index.md#framework-dependent-executables-fde) by default. This is new for applications that use a globally installed version of .NET Core. Until now, only [self-contained deployments](../deploying/index.md#self-contained-deployments-scd) would produce an executable.\n\nDuring `dotnet build` or `dotnet publish`, an executable is created provided that matches the environment and platform of the SDK you are using. You can expect the same things with these executables as you would other native executables, such as:\n\n* You can double-click on the executable.\n* You can launch the application from a command prompt directly, such as `myapp.exe` on Windows, and `./myapp` on Linux and macOS.\n\n## Build copies dependencies\n\n`dotnet build` now copies NuGet dependencies for your application from the NuGet cache to the build output folder. Previously, dependencies were only copied as part of `dotnet publish`. \n\nThere are some operations, like linking and razor page publishing that will still require publishing.\n\n## Local dotnet tools\n\n>[!WARNING]\n>There was a change in .NET Core Local Tools between .NET Core 3.0 Preview 1 and .NET Core 3.0 Preview 2.  If you tried out local tools in Preview 1 by running a command like `dotnet tool restore` or `dotnet tool install`, you need to delete your local tools cache folder before local tools will work correctly in Preview 2. This folder is located at:\n>\n>On mac, Linux: `rm -r $HOME/.dotnet/toolResolverCache`\n>\n>On Windows: `rmdir /s %USERPROFILE%\\.dotnet\\toolResolverCache`\n>\n>If you do not delete this folder, you will receive an error.\n\nWhile .NET Core 2.1 supported global tools, .NET Core 3.0 now has local tools. Local tools are similar to global tools but are associated with a particular location on disk. This enables per-project and per-repository tooling. Any tool installed locally isn't available globally. Tools are distributed as NuGet packages.\n\nLocal tools rely on a manifest file name `dotnet-tools.json` in your current directory. This manifest file defines the tools to be available at that folder and below. By creating this manifest file at the root of your repository, you ensure anyone cloning your code can restore and use the tools that are needed to successfully work with your code.\n\nTo create a `dotnet-tools.json` manifest file, use:\n\n```console\ndotnet new tool-manifest\n```\n\nAdd a new tool to the local manifest with:\n\n```console\ndotnet tool install <packageId>\n```\n\nYou can also list the tools in the local manifest with:\n\n```console\ndotnet tool list\n```\n\nTo see what tools are installed globally, use:\n\n```console\ndotnet tool list -g\n```\n\nWhen the local tools manifest file is available, but the tools defined in the manifest have not been installed, use the following command to automatically download and install those tools:\n\n```console\ndotnet tool restore\n```\n\nRun a local tool with the following command:\n\n```console\ndotnet tool run <tool-command-name>\n```\n\nWhen a local tool is run, dotnet searches for a manifest up the current directory structure. When a tool manifest file is found, it is searched for the requested tool. If the tool is found in the manifest, but not the cache, the user receives an error and needs to run `dotnet tool restore`.\n\nTo remove a tool from the local tool manifest file, run the following command:\n\n```console\ndotnet tool uninstall <packageId>\n```\n\nThe tool manifest file is designed to allow hand editing – which you might do to update the required version for working with the repository. Here is an example `dotnet-tools.json` file:\n\n```json\n{\n  \"version\": 1,\n  \"isRoot\": true,\n  \"tools\": {\n    \"dotnetsay\": {\n      \"version\": \"2.1.4\",\n      \"commands\": [\n        \"dotnetsay\"\n      ]\n    },\n    \"t-rex\": {\n      \"version\": \"1.0.103\",\n      \"commands\": [\n        \"t-rex\"\n      ]\n    }\n  }\n}\n```\n\nFor both global and local tools, a compatible version of the runtime is required. Many tools currently on NuGet.org target .NET Core Runtime 2.1. To install those globally or locally, you would still need to install the [NET Core 2.1 Runtime](https://dotnet.microsoft.com/download/dotnet-core/2.1).\n\n## Windows desktop\n\nStarting with .NET Core 3.0 Preview 1, you can build Windows desktop applications using WPF and Windows Forms. These frameworks also support using modern controls and Fluent styling from the Windows UI XAML Library (WinUI) via [XAML islands](/windows/uwp/xaml-platform/xaml-host-controls).\n\nThe Windows Desktop component is part of the Windows .NET Core 3.0 SDK.\n\nYou can create a new WPF or Windows Forms app with the following `dotnet` commands:\n\n```console\ndotnet new wpf\ndotnet new winforms\n```\n\nVisual Studio 2019 Preview 2 adds **New Project** templates for .NET Core 3.0 Windows Forms and WPF. Designers are still not yet supported. And you can open, launch, and debug these projects in Visual Studio 2019.\n\nVisual Studio 2017 15.9 adds the ability to [enable .NET Core previews](https://devblogs.microsoft.com/dotnet/net-core-tooling-update-for-visual-studio-2017-version-15-9/), but you need to turn that feature on, and it's not a supported scenario.\n\nThe new projects are the same as existing .NET Core projects, with a couple additions. Here is the comparison of the basic .NET Core console project and a basic Windows Forms and WPF project.\n\nIn a .NET Core console project, the project uses the `Microsoft.NET.Sdk` SDK and declares a dependency on .NET Core 3.0 via the `netcoreapp3.0` target framework. To create a Windows Desktop app, use the `Microsoft.NET.Sdk.WindowsDesktop` SDK and choose which UI framework to use:\n\n```diff\n-<Project Sdk=\"Microsoft.NET.Sdk\">\n+<Project Sdk=\"Microsoft.NET.Sdk.WindowsDesktop\">\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>netcoreapp3.0</TargetFramework>\n+   <UseWPF>true</UseWPF>\n  </PropertyGroup>\n</Project>\n```\n\nTo choose Windows Forms over WPF, set `UseWindowsForms` instead of `UseWPF`:\n\n```diff\n<Project Sdk=\"Microsoft.NET.Sdk.WindowsDesktop\">\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>netcoreapp3.0</TargetFramework>\n-   <UseWPF>true</UseWPF>\n+   <UseWindowsForms>true</UseWindowsForms>\n  </PropertyGroup>\n</Project>\n```\n\nBoth `UseWPF` and `UseWindowsForms` can be set to `true` if the app uses both frameworks, for example when a Windows Forms dialog is hosting a WPF control.\n\nPlease share your feedback on the [dotnet/winforms](https://github.com/dotnet/winforms/issues),  [dotnet/wpf](https://github.com/dotnet/wpf/issues) and [dotnet/core](https://github.com/dotnet/core/issues) repos.\n\n## MSIX Deployment for Windows Desktop\n\n[MSIX](https://docs.microsoft.com/windows/msix/) is a new Windows app package format. It can be used to deploy .NET Core 3.0 desktop applications to Windows 10.\n\nThe [Windows Application Packaging Project](https://docs.microsoft.com/windows/uwp/porting/desktop-to-uwp-packaging-dot-net), available in Visual Studio 2019 Preview 2, allows you to create MSIX packages with [self-contained](../deploying/index.md#self-contained-deployments-scd) .NET Core applications.\n\n>Note: The .NET Core project file must specify the supported runtimes in the `<RuntimeIdentifiers>` property:\n```xml\n<RuntimeIdentifiers>win-x86;win-x64</RuntimeIdentifiers>\n```\n\n## Fast built-in JSON support\n\nThe .NET ecosystem has relied on [**Json.NET**](https://www.newtonsoft.com/json) and other popular JSON libraries, which continue to be good choices. **Json.NET** uses .NET strings as its base datatype, which are UTF-16 under the hood.\n\nThe new built-in JSON support is high-performance, low allocation, and based on `Span<byte>`. Three new main JSON-related types have been added to .NET Core 3.0 the `System.Text.Json` namespace.\n\n### Utf8JsonReader\n\n`System.Text.Json.Utf8JsonReader` is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a `ReadOnlySpan<byte>`. The `Utf8JsonReader` is a foundational, low-level type, that can be leveraged to build custom parsers and deserializers. Reading through a JSON payload using the new `Utf8JsonReader` is 2x faster than using the reader from **Json.NET**. It does not allocate until you need to actualize JSON tokens as (UTF-16) strings.\n\nThis new API will include the following components:\n\n* In Preview 1: JSON reader (sequential access)\n* Coming next: JSON writer, DOM (random access), poco serializer, poco deserializer\n\nHere is the basic reader loop for the `Utf8JsonReader` that can be used as a starting point:\n\n```csharp\nusing System.Text.Json;\n\npublic static void Utf8JsonReaderLoop(ReadOnlySpan<byte> dataUtf8)\n{\n    var json = new Utf8JsonReader(dataUtf8, isFinalBlock: true, state: default);\n\n    while (json.Read())\n    {\n        JsonTokenType tokenType = json.TokenType;\n        ReadOnlySpan<byte> valueSpan = json.ValueSpan;\n        switch (tokenType)\n        {\n            case JsonTokenType.StartObject:\n            case JsonTokenType.EndObject:\n                break;\n            case JsonTokenType.StartArray:\n            case JsonTokenType.EndArray:\n                break;\n            case JsonTokenType.PropertyName:\n                break;\n            case JsonTokenType.String:\n                string valueString = json.GetStringValue();\n                break;\n            case JsonTokenType.Number:\n                if (!json.TryGetInt32Value(out int valueInteger))\n                {\n                    throw new FormatException();\n                }\n                break;\n            case JsonTokenType.True:\n            case JsonTokenType.False:\n                bool valueBool = json.GetBooleanValue();\n                break;\n            case JsonTokenType.Null:\n                break;\n            default:\n                throw new ArgumentException();\n        }\n    }\n\n    dataUtf8 = dataUtf8.Slice((int)json.BytesConsumed);\n    JsonReaderState state = json.CurrentState;\n}\n```\n\n### Utf8JsonWriter\n\n`System.Text.Json.Utf8JsonWriter` provides a high-performance, non-cached, forward-only way to write UTF-8 encoded JSON text from common .NET types like `String`, `Int32`, and `DateTime`. Like the reader, the writer is a foundational, low-level type, that can be leveraged to build custom serializers. Writing a JSON payload using the new `Utf8JsonWriter` is 30-80% faster than using the writer from **Json.NET** and does not allocate.\n\nHere is a sample usage of the `Utf8JsonWriter` that can be used as a starting point:\n\n```csharp\nstatic int WriteJson(IBufferWriter<byte> output, long[] extraData)\n{\n    var json = new Utf8JsonWriter(output, state: default);\n\n    json.WriteStartObject();\n\n    json.WriteNumber(\"age\", 15, escape: false);\n    json.WriteString(\"date\", DateTime.Now);\n    json.WriteString(\"first\", \"John\");\n    json.WriteString(\"last\", \"Smith\");\n\n    json.WriteStartArray(\"phoneNumbers\", escape: false);\n    json.WriteStringValue(\"425-000-1212\", escape: false);\n    json.WriteStringValue(\"425-000-1213\");\n    json.WriteEndArray();\n\n    json.WriteStartObject(\"address\");\n    json.WriteString(\"street\", \"1 Microsoft Way\");\n    json.WriteString(\"city\", \"Redmond\");\n    json.WriteNumber(\"zip\", 98052);\n    json.WriteEndObject();\n\n    json.WriteStartArray(\"ExtraArray\");\n    for (var i = 0; i < extraData.Length; i++)\n    {\n        json.WriteNumberValue(extraData[i]);\n    }\n    json.WriteEndArray();\n\n    json.WriteEndObject();\n\n    json.Flush(isFinalBlock: true);\n\n    return (int)json.BytesWritten;\n}\n```\n\nThe `Utf8JsonWriter` accepts `IBufferWriter<byte>` as the output location to synchronously write the json data into, and you as the caller need to provide a concrete implementation. The platform does not currently include an implementation of this interface. For an example of `IBufferWriter<byte>`, see [https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35](https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35)\n\n### JsonDocument\n\n`System.Text.Json.JsonDocument` is built on top of the `Utf8JsonReader`. The `JsonDocument` provides the ability to parse JSON data and build a read-only Document Object Model (DOM) that can be queried to support random access and enumeration. The JSON elements that compose the data can be accessed via the `JsonElement` type which is exposed by the `JsonDocument` as a property called `RootElement`. The `JsonElement` contains the JSON array and object enumerators along with APIs to convert JSON text to common .NET types. Parsing a typical JSON payload and accessing all its members using the `JsonDocument` is 2-3x faster than **Json.NET** with very little allocations for data that is reasonably sized (i.e. < 1 MB).\n\nHere is a sample usage of the `JsonDocument` and `JsonElement` that can be used as a starting point:\n\n```csharp\nstatic double ParseJson()\n{\n    const string json = \" [ { \\\"name\\\": \\\"John\\\" }, [ \\\"425-000-1212\\\", 15 ], { \\\"grades\\\": [ 90, 80, 100, 75 ] } ]\";\n\n    double average = -1;\n\n    using (JsonDocument doc = JsonDocument.Parse(json))\n    {\n        JsonElement root = doc.RootElement;\n        JsonElement info = root[1];\n\n        string phoneNumber = info[0].GetString();\n        int age = info[1].GetInt32();\n\n        JsonElement grades = root[2].GetProperty(\"grades\");\n\n        double sum = 0;\n        foreach (JsonElement grade in grades.EnumerateArray())\n        {\n            sum += grade.GetInt32();\n        }\n\n        int numberOfCourses = grades.GetArrayLength();\n        average = sum / numberOfCourses;\n    }\n\n    return average;\n}\n```\n\n## Assembly Unloadability\n\nAssembly unloadability is a new capability of `AssemblyLoadContext`. This new feature is largely transparent from an API perspective, exposed with just a few new APIs. It enables a loader context to be unloaded, releasing all memory for instantiated types, static fields and for the assembly itself. An application should be able to load and unload assemblies via this mechanism forever without experiencing a memory leak.\n\nThis new capability can be used for scenarios similar to:\n\n* Plugin scenarios where dynamic plugin loading and unloading is required. \n* Dynamically compiling, running and then flushing code. Useful for web sites, scripting engines, etc.\n* Loading assemblies for introspection (like ReflectionOnlyLoad), although [MetadataLoadContext](#type-metadataloadcontext) (released in Preview 1) will be a better choice in many cases.\n\nFor more information, see the [Using Unloadability](https://github.com/dotnet/coreclr/pull/22221) document.\n\nAssembly unloading requires significant care to ensure that all references to managed objects from outside a loader context are understood and managed. When the loader context is requested to be unloaded, any outside references need to have been unreferenced so that the loader context is self-consistent only to itself.\n\nAssembly unloadability was provided in the .NET Framework by Application Domains (AppDomains), which are not supported with .NET Core. AppDomains had both benefits and limitations compared to this new model. Consider this new loader model to be more flexible and higher performant when compared to AppDomains.\n\n## Windows Native Interop\n\nWindows offers a rich native API, in the form of flat C APIs, COM, and WinRT. Since .NET Core 1.0, **P/Invoke** has been supported. Now with .NET Core 3.0, support for the ability to **CoCreate COM APIs** and **Activate WinRT APIs** has been added.\n\nYou can see an example of using COM with the [Excel Demo source code](https://github.com/dotnet/samples/tree/master/core/extensions/ExcelDemo).\n\n## Type: SequenceReader\n\nIn .NET Core 3.0, `System.Buffers.SequenceReader` has been added which can be used as a reader for `ReadOnlySequence<T>`. This allows easy, high performance, low allocation parsing of `System.IO.Pipelines` data that can cross multiple backing buffers. \n\nThe following example breaks an input `Sequence` into valid `CR/LF` delimited lines:\n\n```csharp\nprivate static ReadOnlySpan<byte> CRLF => new byte[] { (byte)'\\r', (byte)'\\n' };\n\npublic static void ReadLines(ReadOnlySequence<byte> sequence)\n{\n    SequenceReader<byte> reader = new SequenceReader<byte>(sequence);\n\n    while (!reader.End)\n    {\n        if (!reader.TryReadToAny(out ReadOnlySpan<byte> line, CRLF, advancePastDelimiter:false))\n        {\n            // Couldn't find another delimiter\n            // ...\n        }\n\n        if (!reader.IsNext(CRLF, advancePast: true))\n        {\n            // Not a good CR/LF pair\n            // ...\n        }\n\n        // line is valid, process\n        ProcessLine(line);\n    }\n}\n```\n\n## Type: MetadataLoadContext\n\nThe `MetadataLoadContext` type has been added that enables reading assembly metadata without affecting the caller’s application domain. Assemblies are read as data, including assemblies built for different architectures and platforms than the current runtime environment. `MetadataLoadContext` overlaps with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad*>, which is only available in the .NET Framework.\n\n`MetdataLoadContext` is available in the [System.Reflection.MetadataLoadContext package](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext). It is a .NET Standard 2.0 package.\n\nThe `MetadataLoadContext` exposes APIs similar to the <xref:System.Runtime.Loader.AssemblyLoadContext> type, but is not based on that type. Much like <xref:System.Runtime.Loader.AssemblyLoadContext>, the `MetadataLoadContext` enables loading assemblies within an isolated assembly loading universe. `MetdataLoadContext` APIs return <xref:System.Reflection.Assembly> objects, enabling the use of familiar reflection APIs. Execution-oriented APIs, such as [MethodBase.Invoke](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/src/System/Reflection/TypeLoading/Methods/RoMethod.cs#L127), are not allowed and will throw InvalidOperationException.\n\nThe following sample demonstrates how to find concrete types in an assembly that implements a given interface:\n\n```csharp\nvar paths = new string[] {@\"C:\\myapp\\mscorlib.dll\", @\"C:\\myapp\\myapp.dll\"};\nvar resolver = new PathAssemblyResolver(paths);\nusing (var lc = new MetadataLoadContext(resolver))\n{\n    Assembly a = lc.LoadFromAssemblyName(\"myapp\");\n    Type myInterface = a.GetType(\"MyApp.IPluginInterface\");\n    foreach (Type t in a.GetTypes())\n    {\n        if (t.IsClass && myInterface.IsAssignableFrom(t))\n            Console.WriteLine($\"Class {t.FullName} implements IPluginInterface\");\n    }\n}\n```\n\nScenarios for `MetadataLoadContext` include design-time features, build-time tooling, and runtime light-up features that need to inspect a set of assemblies as data and have all file locks and memory freed after inspection is performed.\n\nThe `MetadataLoadContext` has a resolver class passed to its constructor. The resolver's job is to load an `Assembly` given its `AssemblyName`. The resolver class derives from the abstract `MetadataAssemblyResolver` class. An implementation of the resolver for path-based scenarios is provided with `PathAssemblyResolver`.\n\nThe [MetadataLoadContext tests](https://github.com/dotnet/corefx/tree/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests) demonstrate many use cases. The [Assembly tests](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests/Assembly/AssemblyTests.cs) are a good place to start.\n\n## TLS 1.3 & OpenSSL 1.1.1 on Linux\n\n.NET Core will now take advantage of [TLS 1.3 support in OpenSSL 1.1.1](https://www.openssl.org/blog/blog/2018/09/11/release111/), when it is available in a given environment. There are multiple benefits of TLS 1.3, per the [OpenSSL team](https://www.openssl.org/blog/blog/2018/09/11/release111/):\n\n* Improved connection times due to a reduction in the number of round trips required between the client and server.\n\n* Improved security due to the removal of various obsolete and insecure cryptographic algorithms and encryption of more of the connection handshake.\n\n.NET Core 3.0 Preview 1 is capable of utilizing **OpenSSL 1.1.1**, **OpenSSL 1.1.0**, or **OpenSSL 1.0.2** (whatever the best version found is, on a Linux system).  When **OpenSSL 1.1.1** is available the SslStream and HttpClient types will use **TLS 1.3** when using `SslProtocols.None` (system default protocols), assuming both the client and server support **TLS 1.3**.\n\nThe following sample demonstrates .NET Core 3.0 Preview 1 on Ubuntu 18.10 connecting to <https://www.cloudflare.com>:\n\n```csharp\nusing System;\nusing System.Net.Security;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace tlstest\n{\n    class Program\n    {\n        static async Task Main()\n        {\n            using (TcpClient tcpClient = new TcpClient())\n            {\n                string targetHost = \"www.cloudflare.com\";\n\n                await tcpClient.ConnectAsync(targetHost, 443);\n\n                using (SslStream sslStream = new SslStream(tcpClient.GetStream()))\n                {\n                    await sslStream.AuthenticateAsClientAsync(targetHost);\n                    await Console.Out.WriteLineAsync($\"Connected to {targetHost} with {sslStream.SslProtocol}\");\n                }\n            }\n        }\n    }\n}\n```\n\n```console\nuser@comp-ubuntu1810:~/tlstest$ dotnet run\nConnected to www.cloudflare.com with Tls13\nuser@comp-ubuntu1810:~/tlstest$ openssl version\nOpenSSL 1.1.1  11 Sep 2018\n```\n\n>[!IMPORTANT]\n>Windows and macOS do not yet support **TLS 1.3**. .NET Core 3.0 will support **TLS 1.3** on these operating systems when support becomes available.\n\n## Cryptography\n\nSupport has been added for **AES-GCM** and **AES-CCM** ciphers, implemented via `System.Security.Cryptography.AesGcm` and `System.Security.Cryptography.AesCcm`. These algorithms are both [Authenticated Encryption with Association Data (AEAD) algorithms](https://en.wikipedia.org/wiki/Authenticated_encryption), and the first Authenticated Encryption (AE) algorithms added to .NET Core.\n\nThe following code demonstrates using **AesGcm** cipher to encrypt and decrypt random data.\n\nThe code for **AesCcm** would look almost identical (only the class variable names would be different).\n\n```csharp\n// key should be: pre-known, derived, or transported via another channel, such as RSA encryption\nbyte[] key = new byte[16];\nRandomNumberGenerator.Fill(key);\n\nbyte[] nonce = new byte[12];\nRandomNumberGenerator.Fill(nonce);\n\n// normally this would be your data\nbyte[] dataToEncrypt = new byte[1234];\nbyte[] associatedData = new byte[333];\nRandomNumberGenerator.Fill(dataToEncrypt);\nRandomNumberGenerator.Fill(associatedData);\n\n// these will be filled during the encryption\nbyte[] tag = new byte[16];\nbyte[] ciphertext = new byte[dataToEncrypt.Length];\n\nusing (AesGcm aesGcm = new AesGcm(key))\n{\n    aesGcm.Encrypt(nonce, dataToEncrypt, ciphertext, tag, associatedData);\n}\n\n// tag, nonce, ciphertext, associatedData should be sent to the other part\n\nbyte[] decryptedData = new byte[ciphertext.Length];\n\nusing (AesGcm aesGcm = new AesGcm(key))\n{\n    aesGcm.Decrypt(nonce, ciphertext, tag, decryptedData, associatedData);\n}\n\n// do something with the data\n// this should always print that data is the same\nConsole.WriteLine($\"AES-GCM: Decrypted data is{(dataToEncrypt.SequenceEqual(decryptedData) ? \"the same as\" : \"different than\")} original data.\");\n```\n\n## Cryptographic Key Import/Export\n\n.NET Core 3.0 Preview 1 supports the import and export of asymmetric public and private keys from standard formats, without needing to use an X.509 certificate.\n\nAll key types (RSA, DSA, ECDsa, ECDiffieHellman) support the **X.509 SubjectPublicKeyInfo** format for public keys, and the **PKCS#8 PrivateKeyInfo** and **PKCS#8 EncryptedPrivateKeyInfo** formats for private keys. RSA additionally supports **PKCS#1 RSAPublicKey** and **PKCS#1 RSAPrivateKey**. The export methods all produce DER-encoded binary data, and the import methods expect the same. If a key is stored in the text-friendly PEM format, the caller will need to base64-decode the content before calling an import method.\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Security.Cryptography;\n\nnamespace rsakeyprint\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            using (RSA rsa = RSA.Create())\n            {\n                byte[] keyBytes = File.ReadAllBytes(args[0]);\n                rsa.ImportRSAPrivateKey(keyBytes, out int bytesRead);\n \n                Console.WriteLine($\"Read {bytesRead} bytes, {keyBytes.Length-bytesRead} extra byte(s) in file.\");\n                RSAParameters rsaParameters = rsa.ExportParameters(true);\n                Console.WriteLine(BitConverter.ToString(rsaParameters.D));\n            }\n        }\n    }\n}\n```\n\n```console\nuser@comp-ubuntu1810:~/rsakeyprint$ echo Making a small key to save on screen space.\nMaking a small key to save on screen space.\nuser@comp-ubuntu1810:~/rsakeyprint$ openssl genrsa 768 | openssl rsa -outform der -out rsa.key\nGenerating RSA private key, 768 bit long modulus (2 primes)\n..+++++++\n........+++++++\ne is 65537 (0x010001)\nwriting RSA key\nuser@comp-ubuntu1810:~/rsakeyprint$ dotnet run rsa.key\nRead 461 bytes, 0 extra byte(s) in file.\n0F-D0-82-34-F8-13-38-4A-7F-C7-52-4A-F6-93-F8-FB-6D-98-7A-6A-04-3B-BC-35-8C-7D-AC-A5-A3-6E-AD-C1-66-30-81-2C-2A-DE-DA-60-03-6A-2C-D9-76-15-7F-61-97-57-\n79-E1-6E-45-62-C3-83-04-97-CB-32-EF-C5-17-5F-99-60-92-AE-B6-34-6F-30-06-03-AC-BF-15-24-43-84-EB-83-60-EF-4D-3B-BD-D9-5D-56-26-F0-51-CE-F1\nuser@comp-ubuntu1810:~/rsakeyprint$ openssl rsa -in rsa.key -inform der -text -noout | grep -A7 private\nprivateExponent:\n    0f:d0:82:34:f8:13:38:4a:7f:c7:52:4a:f6:93:f8:\n    fb:6d:98:7a:6a:04:3b:bc:35:8c:7d:ac:a5:a3:6e:\n    ad:c1:66:30:81:2c:2a:de:da:60:03:6a:2c:d9:76:\n    15:7f:61:97:57:79:e1:6e:45:62:c3:83:04:97:cb:\n    32:ef:c5:17:5f:99:60:92:ae:b6:34:6f:30:06:03:\n    ac:bf:15:24:43:84:eb:83:60:ef:4d:3b:bd:d9:5d:\n    56:26:f0:51:ce:f1\n```\n\nPKCS#8 files can be inspected with the `System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo` class.\n\nPFX/PKCS#12 files can be inspected and manipulated with `System.Security.Cryptography.Pkcs.Pkcs12Info` and `System.Security.Cryptography.Pkcs.Pkcs12Builder`, respectively.\n\n## SerialPort for Linux\n\n.NET Core 3.0 now supports <xref:System.IO.Ports.SerialPort?displayProperty=nameWithType> on Linux.\n\nPreviously, .NET Core only supported using the `SerialPort` type on Windows.\n\n## More BCL Improvements\n\nThe `Span<T>`, `Memory<T>`, and related types that were introduced in .NET Core 2.1, have been optimized in .NET Core 3.0. Common operations such as span construction, slicing, parsing, and formatting now perform better. \n\nAdditionally, types like `String` have seen under-the-cover improvements to make them more efficient when used as keys with `Dictionary<TKey, TValue>` and other collections. No code changes are required to benefit from these improvements.\n\nThe following improvements are also new in .NET Core 3 Preview 1:\n\n* Brotli support built in to HttpClient\n* ThreadPool.UnsafeQueueWorkItem(IThreadPoolWorkItem)\n* Unsafe.Unbox\n* CancellationToken.Unregister\n* Complex arithmetic operators\n* Socket APIs for TCP keep alive\n* StringBuilder.GetChunks\n* IPEndPoint parsing\n* RandomNumberGenerator.GetInt32\n\n## Tiered compilation\n\n[Tiered compilation](https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/) is on by default with .NET Core 3.0. It is a feature that enables the runtime to more adaptively use the Just-In-Time (JIT) compiler to get better performance, both at startup and to maximize throughput.\n\nThis feature was added as an opt-in feature in [.NET Core 2.1](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-1/) and then was enabled by default in [.NET Core 2.2 Preview 2](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-2-preview-2/). Subsequently, it has been reverted back to opt in with the .NET Core 2.2 release.\n\n## ARM64 Linux support\n\nSupport has been added for ARM64 for Linux. The primary use case for ARM64 is currently with IoT scenarios.\n\nAlpine, Debian and Ubuntu [Docker images are available for .NET Core for ARM64](https://hub.docker.com/r/microsoft/dotnet/).\n\nPlease check [.NET Core ARM64 Status](https://github.com/dotnet/announcements/issues/82) for more information.\n\n>[!NOTE]\n> **ARM64** Windows support isn't yet available.\n\n## Install .NET Core 3.0 Previews on Linux with Snap\n\nSnap is the preferred way to install and try .NET Core previews on [Linux distributions that support Snap](https://docs.snapcraft.io/installing-snapd/6735).\n\nAfter configuring Snap on your system, run the following command to install the [.NET Core SDK 3.0 Preview SDK](https://snapcraft.io/dotnet-sdk).\n\n```console\nsudo snap install dotnet-sdk --beta --classic\n```\n \nWhen .NET Core in installed using the Snap package, the default .NET Core command is `dotnet-sdk.dotnet`, as opposed to just `dotnet`. The benefit of the namespaced command is that it will not conflict with a globally installed .NET Core version you may have. This command can be aliased to `dotnet` with:\n\n```console\nsudo snap alias dotnet-sdk.dotnet dotnet\n```\n\nSome distros require an additional step to enable access to the SSL certificate. See our [Linux Setup](https://github.com/dotnet/core/blob/master/Documentation/linux-setup.md) for details.\n\n## GPIO Support for Raspberry Pi\n\nTwo new packages have been released to NuGet that you can use for GPIO programming.\n\n* [System.Device.Gpio](https://www.nuget.org/packages/System.Device.Gpio/0.1.0-prerelease.19078.2)\n* [Iot.Device.Bindings](https://www.nuget.org/packages/Iot.Device.Bindings/0.1.0-prerelease.19078.2)\n\nThe GPIO Packages includes APIs for GPIO, SPI, I2C and PWM devices. The IoT bindings package includes [device bindings](https://github.com/dotnet/iot/blob/master/src/devices/README.md) for various chips and sensors, the same ones available at [dotnet/iot - src/devices](https://github.com/dotnet/iot/tree/master/src/devices).\n\nThe updated serial port APIs that were announced as part of .NET Core 3.0 Preview 1 are not part of these packages but are available as part of the .NET Core platform.\n\n## Platform Support\n\n.NET Core 3 will be supported on the following operating systems:\n\n* Windows Client: 7, 8.1, 10 (1607+)\n* Windows Server: 2012 R2 SP1+\n* macOS: 10.12+\n* RHEL: 6+\n* Fedora: 26+\n* Ubuntu: 16.04+\n* Debian: 9+\n* SLES: 12+\n* openSUSE: 42.3+\n* Alpine: 3.8+\n\nChip support follows:\n\n* x64 on Windows, macOS, and Linux\n* x86 on Windows\n* ARM32 on Windows and Linux\n* ARM64 on Linux\n\nFor Linux, ARM32 is supported on Debian 9+ and Ubuntu 16.04+. For ARM64, it is the same as ARM32 with the addition of Alpine 3.8. These are the same versions of those distros as is supported for X64.\n\nDocker images for .NET Core 3.0 are available at [microsoft/dotnet on Docker Hub](https://hub.docker.com/r/microsoft/dotnet/). Microsoft is currently in the process of adopting [Microsoft Container Registry (MCR)](https://cloudblogs.microsoft.com/opensource/2019/01/17/improved-discovery-experience-microsoft-containers-docker-hub/) and it is expected that the final .NET Core 3.0 images will only be published to MCR.\n","nodes":[{"pos":[4,191],"embed":true,"restype":"x-metadata","content":"title: What's new in .NET Core 3.0\ndescription: Learn about the new features found in .NET Core 3.0.\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nauthor: thraka\nms.author: adegeo\nms.date: 12/31/2018","nodes":[{"content":"What's new in .NET Core 3.0","nodes":[{"pos":[0,27],"content":"What's new in .NET Core 3.0","nodes":[{"content":"What's new in .NET Core 3.0","pos":[0,27]}]}],"path":["title"],"nosxs":false},{"content":"Learn about the new features found in .NET Core 3.0.","nodes":[{"pos":[0,52],"content":"Learn about the new features found in .NET Core 3.0.","nodes":[{"content":"Learn about the new features found in .NET Core 3.0.","pos":[0,52]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[199,238],"content":"What's new in .NET Core 3.0 (Preview 2)","linkify":"What's new in .NET Core 3.0 (Preview 2)","nodes":[{"content":"What's new in .NET Core 3.0 (Preview 2)","pos":[0,39]}]},{"content":"This article describes what is new in .NET Core 3.0 (preview 2).","pos":[240,304]},{"content":"One of the biggest enhancements is support for Windows desktop applications (Windows only).","pos":[305,396]},{"content":"By utilizing a .NET Core 3.0 SDK component called Windows Desktop, you can port your Windows Forms and Windows Presentation Foundation (WPF) applications.","pos":[397,551]},{"content":"To be clear, the Windows Desktop component is only supported and included on Windows.","pos":[552,637]},{"content":"For more information, see the section <bpt id=\"p1\">[</bpt>Windows desktop<ept id=\"p1\">](#windows-desktop)</ept> below.","pos":[638,718],"source":" For more information, see the section [Windows desktop](#windows-desktop) below."},{"content":".NET Core 3.0 adds support for C# 8.0.","pos":[720,758]},{"content":"<bpt id=\"p1\">[</bpt>Download and get started with .NET Core 3.0 Preview 2<ept id=\"p1\">](https://aka.ms/netcore3download)</ept> right now on Windows, Mac and Linux.","pos":[760,885],"source":"[Download and get started with .NET Core 3.0 Preview 2](https://aka.ms/netcore3download) right now on Windows, Mac and Linux."},{"content":"You can see complete details of the release in the <bpt id=\"p1\">[</bpt>.NET Core 3.0 Preview 2 release notes<ept id=\"p1\">](https://aka.ms/netcore3releasenotes)</ept>.","pos":[886,1014],"source":" You can see complete details of the release in the [.NET Core 3.0 Preview 2 release notes](https://aka.ms/netcore3releasenotes)."},{"content":"For more information about what was released with each version, see the following announcements:","pos":[1016,1112]},{"pos":[1116,1271],"content":"<bpt id=\"p1\">[</bpt>.NET Core 3.0 Preview 1 announcement<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/)</ept>","source":"[.NET Core 3.0 Preview 1 announcement](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/)"},{"pos":[1274,1384],"content":"<bpt id=\"p1\">[</bpt>.NET Core 3.0 Preview 2 announcement<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-2/)</ept>","source":"[.NET Core 3.0 Preview 2 announcement](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-2/)"},{"pos":[1389,1393],"content":"C# 8","linkify":"C# 8","nodes":[{"content":"C# 8","pos":[0,4]}]},{"content":".NET Core 3.0 supports C# 8, and as of .NET Core 3.0 Preview 2, supports these new features.","pos":[1395,1487]},{"content":"For more information about C# 8.0 features, see the following blog posts:","pos":[1488,1561]},{"pos":[1565,1669],"content":"<bpt id=\"p1\">[</bpt>Do more with patterns in C# 8.0<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/)</ept>","source":"[Do more with patterns in C# 8.0](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/)"},{"pos":[1672,1758],"content":"<bpt id=\"p1\">[</bpt>Take C# 8.0 for a spin<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/take-c-8-0-for-a-spin/)</ept>","source":"[Take C# 8.0 for a spin](https://devblogs.microsoft.com/dotnet/take-c-8-0-for-a-spin/)"},{"pos":[1761,1833],"content":"<bpt id=\"p1\">[</bpt>Building C# 8.0<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/building-c-8-0/)</ept>","source":"[Building C# 8.0](https://devblogs.microsoft.com/dotnet/building-c-8-0/)"},{"pos":[1839,1857],"content":"Ranges and indices","linkify":"Ranges and indices","nodes":[{"content":"Ranges and indices","pos":[0,18]}]},{"content":"The new <ph id=\"ph1\">`Index`</ph> type can be used for indexing.","pos":[1859,1905],"source":"The new `Index` type can be used for indexing."},{"content":"You can create one from an <ph id=\"ph1\">`int`</ph> that counts from the beginning, or with a prefix <ph id=\"ph2\">`^`</ph> operator (C#) that counts from the end:","pos":[1906,2031],"source":" You can create one from an `int` that counts from the beginning, or with a prefix `^` operator (C#) that counts from the end:"},{"content":"There is also a <ph id=\"ph1\">`Range`</ph> type, which consists of two <ph id=\"ph2\">`Index`</ph> values, one for the start and one for the end, and can be written with a <ph id=\"ph3\">`x..y`</ph> range expression (C#).","pos":[2220,2382],"source":"There is also a `Range` type, which consists of two `Index` values, one for the start and one for the end, and can be written with a `x..y` range expression (C#)."},{"content":"You can then index with a <ph id=\"ph1\">`Range`</ph> in order to produce a slice:","pos":[2383,2445],"source":" You can then index with a `Range` in order to produce a slice:"},{"pos":[2504,2517],"content":"Async streams","linkify":"Async streams","nodes":[{"content":"Async streams","pos":[0,13]}]},{"content":"The <ph id=\"ph1\">`IAsyncEnumerable&lt;T&gt;`</ph> type is a new asynchronous version of <ph id=\"ph2\">`IEnumerable&lt;T&gt;`</ph>.","pos":[2519,2600],"source":"The `IAsyncEnumerable<T>` type is a new asynchronous version of `IEnumerable<T>`."},{"content":"The language lets you <ph id=\"ph1\">`await foreach`</ph> over <ph id=\"ph2\">`IAsyncEnumerable&lt;T&gt;`</ph> to consume their elements, and use <ph id=\"ph3\">`yield return`</ph> to them to produce elements.","pos":[2601,2744],"source":" The language lets you `await foreach` over `IAsyncEnumerable<T>` to consume their elements, and use `yield return` to them to produce elements."},{"content":"The following example demonstrates both production and consumption of async streams.","pos":[2746,2830]},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement is async and itself uses <ph id=\"ph2\">`yield return`</ph> to produce an async stream for callers.","pos":[2831,2934],"source":" The `foreach` statement is async and itself uses `yield return` to produce an async stream for callers."},{"content":"This pattern (using <ph id=\"ph1\">`yield return`</ph>) is the recommended model for producing async streams.","pos":[2935,3024],"source":" This pattern (using `yield return`) is the recommended model for producing async streams."},{"content":"In addition to being able to <ph id=\"ph1\">`await foreach`</ph>, you can also create async iterators, for example, an iterator that returns an <ph id=\"ph2\">`IAsyncEnumerable/IAsyncEnumerator`</ph> that you can both <ph id=\"ph3\">`await`</ph> and <ph id=\"ph4\">`yield`</ph> in.","pos":[3205,3406],"source":"In addition to being able to `await foreach`, you can also create async iterators, for example, an iterator that returns an `IAsyncEnumerable/IAsyncEnumerator` that you can both `await` and `yield` in."},{"content":"For objects that need to be disposed, you can use <ph id=\"ph1\">`IAsyncDisposable`</ph>, which various BCL types implement, such as <ph id=\"ph2\">`Stream`</ph> and <ph id=\"ph3\">`Timer`</ph>.","pos":[3407,3541],"source":" For objects that need to be disposed, you can use `IAsyncDisposable`, which various BCL types implement, such as `Stream` and `Timer`."},{"pos":[3544,3913],"content":"[!NOTE]\nYou need .NET Core 3.0 Preview 2 to use async streams if you want to develop with either Visual Studio 2019 Preview 2 or the latest preview of the [C# extension for Visual Studio Code](https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta5). If you are using .NET Core 3.0 Preview 2 at the command line, then everything will work as expected.","leadings":["",">"],"nodes":[{"content":"You need .NET Core 3.0 Preview 2 to use async streams if you want to develop with either Visual Studio 2019 Preview 2 or the latest preview of the [C# extension for Visual Studio Code](https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta5). If you are using .NET Core 3.0 Preview 2 at the command line, then everything will work as expected.","pos":[8,368],"nodes":[{"content":"You need .NET Core 3.0 Preview 2 to use async streams if you want to develop with either Visual Studio 2019 Preview 2 or the latest preview of the <bpt id=\"p1\">[</bpt>C# extension for Visual Studio Code<ept id=\"p1\">](https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta5)</ept>.","pos":[0,259],"source":"You need .NET Core 3.0 Preview 2 to use async streams if you want to develop with either Visual Studio 2019 Preview 2 or the latest preview of the [C# extension for Visual Studio Code](https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta5)."},{"content":"If you are using .NET Core 3.0 Preview 2 at the command line, then everything will work as expected.","pos":[260,360]}]}]},{"pos":[3919,3937],"content":"Using Declarations","linkify":"Using Declarations","nodes":[{"content":"Using Declarations","pos":[0,18]}]},{"content":"<bpt id=\"p1\">*</bpt>Using declarations<ept id=\"p1\">*</ept> are a new way to ensure your object is properly disposed.","pos":[3939,4017],"source":"*Using declarations* are a new way to ensure your object is properly disposed."},{"content":"A <bpt id=\"p1\">*</bpt>using declaration<ept id=\"p1\">*</ept> keeps the object alive while it is still in scope.","pos":[4018,4090],"source":" A *using declaration* keeps the object alive while it is still in scope."},{"content":"Once the object becomes out of scope, it is automatically disposed.","pos":[4091,4158]},{"content":"This will reduce nested <bpt id=\"p1\">*</bpt>using statements<ept id=\"p1\">*</ept> and make your code cleaner.","pos":[4159,4229],"source":" This will reduce nested *using statements* and make your code cleaner."},{"pos":[4406,4424],"content":"Switch Expressions","linkify":"Switch Expressions","nodes":[{"content":"Switch Expressions","pos":[0,18]}]},{"content":"<bpt id=\"p1\">*</bpt>Switch expressions<ept id=\"p1\">*</ept> are a cleaner way of doing a <bpt id=\"p2\">*</bpt>switch statement<ept id=\"p2\">*</ept> but, since it's an expression, returns a value.","pos":[4426,4542],"source":"*Switch expressions* are a cleaner way of doing a *switch statement* but, since it's an expression, returns a value."},{"content":"<bpt id=\"p1\">*</bpt>Switch expressions<ept id=\"p1\">*</ept> are also fully integrated with pattern matching, and use the discard pattern, <ph id=\"ph1\">`_`</ph>, to represent the <ph id=\"ph2\">`default`</ph> value.","pos":[4543,4680],"source":"*Switch expressions* are also fully integrated with pattern matching, and use the discard pattern, `_`, to represent the `default` value."},{"pos":[4682,4755],"content":"You can see the syntax for <bpt id=\"p1\">*</bpt>switch expressions<ept id=\"p1\">*</ept> in the following example:","source":"You can see the syntax for *switch expressions* in the following example:"},{"content":"There are two patterns at play in this example.","pos":[4964,5011]},{"content":"<ph id=\"ph1\">`o`</ph> first matches with the <ph id=\"ph2\">`Point`</ph> <bpt id=\"p1\">*</bpt>type pattern<ept id=\"p1\">*</ept> and then with the <bpt id=\"p2\">*</bpt>property pattern<ept id=\"p2\">*</ept> inside the <bpt id=\"p3\">*</bpt>{curly braces}<ept id=\"p3\">*</ept>.","pos":[5012,5127],"source":"`o` first matches with the `Point` *type pattern* and then with the *property pattern* inside the *{curly braces}*."},{"content":"The <ph id=\"ph1\">`_`</ph> describes the <ph id=\"ph2\">`discard pattern`</ph>, which is the same as <ph id=\"ph3\">`default`</ph> for <bpt id=\"p1\">*</bpt>switch statements<ept id=\"p1\">*</ept>.","pos":[5128,5224],"source":" The `_` describes the `discard pattern`, which is the same as `default` for *switch statements*."},{"content":"Patterns enable you to write declarative code that captures your intent instead of procedural code that implements tests for it.","pos":[5226,5354]},{"content":"The compiler becomes responsible for implementing that boring procedural code and is guaranteed to always do it correctly.","pos":[5355,5477]},{"pos":[5479,5630],"content":"There will still be cases where <bpt id=\"p1\">*</bpt>switch statements<ept id=\"p1\">*</ept> will be a better choice than <bpt id=\"p2\">*</bpt>switch expressions<ept id=\"p2\">*</ept> and patterns can be used with both syntax styles.","source":"There will still be cases where *switch statements* will be a better choice than *switch expressions* and patterns can be used with both syntax styles."},{"pos":[5632,5763],"content":"For more information, see <bpt id=\"p1\">[</bpt>Do more with patterns in C# 8.0<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/)</ept>.","source":"For more information, see [Do more with patterns in C# 8.0](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/)."},{"pos":[5768,5800],"content":"IEEE Floating-point improvements","linkify":"IEEE Floating-point improvements","nodes":[{"content":"IEEE Floating-point improvements","pos":[0,32]}]},{"content":"Floating point APIs are in the process of being updated to comply with <bpt id=\"p1\">[</bpt>IEEE 754-2008 revision<ept id=\"p1\">](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)</ept>.","pos":[5802,5952],"source":"Floating point APIs are in the process of being updated to comply with [IEEE 754-2008 revision](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)."},{"content":"The goal of these changes is to expose all \"required\" operations and ensure that they are behaviorally compliant with the IEEE spec.","pos":[5953,6085]},{"content":"Parsing and formatting fixes:","pos":[6087,6116]},{"content":"Correctly parse and round inputs of any length.","pos":[6120,6167]},{"content":"Correctly parse and format negative zero.","pos":[6170,6211]},{"pos":[6214,6342],"content":"Correctly parse Infinity and NaN by performing a case-insensitive check and allowing an optional preceding <ph id=\"ph1\">`+`</ph> where applicable.","source":"Correctly parse Infinity and NaN by performing a case-insensitive check and allowing an optional preceding `+` where applicable."},{"content":"New Math APIs have:","pos":[6344,6363]},{"content":"Corresponds to the <ph id=\"ph1\">`nextUp`</ph> and <ph id=\"ph2\">`nextDown`</ph> IEEE operations.","pos":[6396,6455],"source":"Corresponds to the `nextUp` and `nextDown` IEEE operations."},{"content":"They return the smallest floating-point number that compares greater or lesser than the input (respectively).","pos":[6456,6565]},{"content":"For example, <ph id=\"ph1\">`Math.BitIncrement(0.0)`</ph> would return <ph id=\"ph2\">`double.Epsilon`</ph>.","pos":[6566,6634],"source":" For example, `Math.BitIncrement(0.0)` would return `double.Epsilon`."},{"content":"Corresponds to the <ph id=\"ph1\">`maxNumMag`</ph> and <ph id=\"ph2\">`minNumMag`</ph> IEEE operations, they return the value that is greater or lesser in magnitude of the two inputs (respectively).","pos":[6667,6825],"source":"Corresponds to the `maxNumMag` and `minNumMag` IEEE operations, they return the value that is greater or lesser in magnitude of the two inputs (respectively)."},{"content":"For example, <ph id=\"ph1\">`Math.MaxMagnitude(2.0, -3.0)`</ph> would return <ph id=\"ph2\">`-3.0`</ph>.","pos":[6826,6890],"source":" For example, `Math.MaxMagnitude(2.0, -3.0)` would return `-3.0`."},{"content":"Corresponds to the <ph id=\"ph1\">`logB`</ph> IEEE operation which returns an integral value, it returns the integral base-2 log of the input parameter.","pos":[6903,7035],"source":"Corresponds to the `logB` IEEE operation which returns an integral value, it returns the integral base-2 log of the input parameter."},{"content":"This is effectively the same as <ph id=\"ph1\">`floor(log2(x))`</ph>, but done with minimal rounding error.","pos":[7036,7123],"source":" This is effectively the same as `floor(log2(x))`, but done with minimal rounding error."},{"content":"Corresponds to the <ph id=\"ph1\">`scaleB`</ph> IEEE operation which takes an integral value, it returns effectively <ph id=\"ph2\">`x * pow(2, n)`</ph>, but is done with minimal rounding error.","pos":[7137,7291],"source":"Corresponds to the `scaleB` IEEE operation which takes an integral value, it returns effectively `x * pow(2, n)`, but is done with minimal rounding error."},{"content":"Corresponds to the <ph id=\"ph1\">`log2`</ph> IEEE operation, it returns the base-2 logarithm.","pos":[7303,7377],"source":"Corresponds to the `log2` IEEE operation, it returns the base-2 logarithm."},{"content":"It minimizes rounding error.","pos":[7378,7406]},{"content":"Corresponds to the <ph id=\"ph1\">`fma`</ph> IEEE operation, it performs a fused multiply add.","pos":[7430,7504],"source":"Corresponds to the `fma` IEEE operation, it performs a fused multiply add."},{"content":"That is, it does <ph id=\"ph1\">`(x * y) + z`</ph> as a single operation, there-by minimizing the rounding error.","pos":[7505,7598],"source":" That is, it does `(x * y) + z` as a single operation, there-by minimizing the rounding error."},{"content":"An example would be <ph id=\"ph1\">`FusedMultiplyAdd(1e308, 2.0, -1e308)`</ph> which returns <ph id=\"ph2\">`1e308`</ph>.","pos":[7599,7680],"source":" An example would be `FusedMultiplyAdd(1e308, 2.0, -1e308)` which returns `1e308`."},{"content":"The regular <ph id=\"ph1\">`(1e308 * 2.0) - 1e308`</ph> returns <ph id=\"ph2\">`double.PositiveInfinity`</ph>.","pos":[7681,7751],"source":" The regular `(1e308 * 2.0) - 1e308` returns `double.PositiveInfinity`."},{"content":"Corresponds to the <ph id=\"ph1\">`copySign`</ph> IEEE operation, it returns the value of <ph id=\"ph2\">`x`</ph>, but with the sign of <ph id=\"ph3\">`y`</ph>.","pos":[7767,7867],"source":"Corresponds to the `copySign` IEEE operation, it returns the value of `x`, but with the sign of `y`."},{"pos":[7872,7906],"content":".NET Platform Dependent Intrinsics","linkify":".NET Platform Dependent Intrinsics","nodes":[{"content":".NET Platform Dependent Intrinsics","pos":[0,34]}]},{"content":"APIs have been added that allow access to certain perf-oriented CPU instructions, such as the <bpt id=\"p1\">**</bpt>SIMD<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>Bit Manipulation instruction<ept id=\"p2\">**</ept> sets.","pos":[7908,8052],"source":"APIs have been added that allow access to certain perf-oriented CPU instructions, such as the **SIMD** or **Bit Manipulation instruction** sets."},{"content":"These instructions can help achieve big performance improvements in certain scenarios, such as processing data efficiently in parallel.","pos":[8053,8188]},{"content":"In addition to exposing the APIs for your programs to use, the .NET libraries have begun using these instructions to improve performance.","pos":[8189,8326]},{"content":"The following CoreCLR PRs demonstrate a few of the intrinsics, either via implementation or use:","pos":[8328,8424]},{"pos":[8428,8517],"content":"<bpt id=\"p1\">[</bpt>Implement simple SSE2 hardware intrinsics<ept id=\"p1\">](https://github.com/dotnet/coreclr/pull/15585)</ept>","source":"[Implement simple SSE2 hardware intrinsics](https://github.com/dotnet/coreclr/pull/15585)"},{"pos":[8520,8605],"content":"<bpt id=\"p1\">[</bpt>Implement the SSE hardware intrinsics<ept id=\"p1\">](https://github.com/dotnet/coreclr/pull/15538)</ept>","source":"[Implement the SSE hardware intrinsics](https://github.com/dotnet/coreclr/pull/15538)"},{"pos":[8608,8680],"content":"<bpt id=\"p1\">[</bpt>Arm64 Base HW Intrinsics<ept id=\"p1\">](https://github.com/dotnet/coreclr/pull/16822)</ept>","source":"[Arm64 Base HW Intrinsics](https://github.com/dotnet/coreclr/pull/16822)"},{"pos":[8683,8789],"content":"<bpt id=\"p1\">[</bpt>Use TZCNT and LZCNT for Locate{First|Last}Found{Byte|Char}<ept id=\"p1\">](https://github.com/dotnet/coreclr/pull/21073)</ept>","source":"[Use TZCNT and LZCNT for Locate{First|Last}Found{Byte|Char}](https://github.com/dotnet/coreclr/pull/21073)"},{"pos":[8791,9137],"content":"For more information, see <bpt id=\"p1\">[</bpt>.NET Platform Dependent Intrinsics<ept id=\"p1\">](https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md)</ept>, which defines an approach for defining this hardware infrastructure, allowing Microsoft, chip vendors, or any other company or individual to define hardware/chip APIs that should be exposed to .NET code.","source":"For more information, see [.NET Platform Dependent Intrinsics](https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md), which defines an approach for defining this hardware infrastructure, allowing Microsoft, chip vendors, or any other company or individual to define hardware/chip APIs that should be exposed to .NET code."},{"pos":[9142,9161],"content":"Default executables","linkify":"Default executables","nodes":[{"content":"Default executables","pos":[0,19]}]},{"content":".NET Core will now build <bpt id=\"p1\">[</bpt>framework-dependent executables<ept id=\"p1\">](../deploying/index.md#framework-dependent-executables-fde)</ept> by default.","pos":[9163,9292],"source":".NET Core will now build [framework-dependent executables](../deploying/index.md#framework-dependent-executables-fde) by default."},{"content":"This is new for applications that use a globally installed version of .NET Core.","pos":[9293,9373]},{"content":"Until now, only <bpt id=\"p1\">[</bpt>self-contained deployments<ept id=\"p1\">](../deploying/index.md#self-contained-deployments-scd)</ept> would produce an executable.","pos":[9374,9501],"source":" Until now, only [self-contained deployments](../deploying/index.md#self-contained-deployments-scd) would produce an executable."},{"content":"During <ph id=\"ph1\">`dotnet build`</ph> or <ph id=\"ph2\">`dotnet publish`</ph>, an executable is created provided that matches the environment and platform of the SDK you are using.","pos":[9503,9647],"source":"During `dotnet build` or `dotnet publish`, an executable is created provided that matches the environment and platform of the SDK you are using."},{"content":"You can expect the same things with these executables as you would other native executables, such as:","pos":[9648,9749]},{"content":"You can double-click on the executable.","pos":[9753,9792]},{"pos":[9795,9923],"content":"You can launch the application from a command prompt directly, such as <ph id=\"ph1\">`myapp.exe`</ph> on Windows, and <ph id=\"ph2\">`./myapp`</ph> on Linux and macOS.","source":"You can launch the application from a command prompt directly, such as `myapp.exe` on Windows, and `./myapp` on Linux and macOS."},{"pos":[9928,9953],"content":"Build copies dependencies","linkify":"Build copies dependencies","nodes":[{"content":"Build copies dependencies","pos":[0,25]}]},{"content":"<ph id=\"ph1\">`dotnet build`</ph> now copies NuGet dependencies for your application from the NuGet cache to the build output folder.","pos":[9955,10069],"source":"`dotnet build` now copies NuGet dependencies for your application from the NuGet cache to the build output folder."},{"content":"Previously, dependencies were only copied as part of <ph id=\"ph1\">`dotnet publish`</ph>.","pos":[10070,10140],"source":" Previously, dependencies were only copied as part of `dotnet publish`."},{"content":"There are some operations, like linking and razor page publishing that will still require publishing.","pos":[10143,10244]},{"pos":[10249,10267],"content":"Local dotnet tools","linkify":"Local dotnet tools","nodes":[{"content":"Local dotnet tools","pos":[0,18]}]},{"pos":[10270,10632],"content":"[!WARNING]\nThere was a change in .NET Core Local Tools between .NET Core 3.0 Preview 1 and .NET Core 3.0 Preview 2.  If you tried out local tools in Preview 1 by running a command like `dotnet tool restore` or `dotnet tool install`, you need to delete your local tools cache folder before local tools will work correctly in Preview 2. This folder is located at:","leadings":["",">"],"nodes":[{"content":"There was a change in .NET Core Local Tools between .NET Core 3.0 Preview 1 and .NET Core 3.0 Preview 2.  If you tried out local tools in Preview 1 by running a command like `dotnet tool restore` or `dotnet tool install`, you need to delete your local tools cache folder before local tools will work correctly in Preview 2. This folder is located at:","pos":[11,361],"nodes":[{"content":"There was a change in .NET Core Local Tools between .NET Core 3.0 Preview 1 and .NET Core 3.0 Preview 2.","pos":[0,104]},{"content":"If you tried out local tools in Preview 1 by running a command like <ph id=\"ph1\">`dotnet tool restore`</ph> or <ph id=\"ph2\">`dotnet tool install`</ph>, you need to delete your local tools cache folder before local tools will work correctly in Preview 2.","pos":[106,323],"source":"  If you tried out local tools in Preview 1 by running a command like `dotnet tool restore` or `dotnet tool install`, you need to delete your local tools cache folder before local tools will work correctly in Preview 2."},{"content":"This folder is located at:","pos":[324,350]}]}]},{"pos":[10636,10690],"content":"On mac, Linux: <ph id=\"ph1\">`rm -r $HOME/.dotnet/toolResolverCache`</ph>","source":"On mac, Linux: `rm -r $HOME/.dotnet/toolResolverCache`"},{"pos":[10694,10756],"content":"On Windows: <ph id=\"ph1\">`rmdir /s %USERPROFILE%\\.dotnet\\toolResolverCache`</ph>","source":"On Windows: `rmdir /s %USERPROFILE%\\.dotnet\\toolResolverCache`"},{"content":"If you do not delete this folder, you will receive an error.","pos":[10760,10820]},{"content":"While .NET Core 2.1 supported global tools, .NET Core 3.0 now has local tools.","pos":[10822,10900]},{"content":"Local tools are similar to global tools but are associated with a particular location on disk.","pos":[10901,10995]},{"content":"This enables per-project and per-repository tooling.","pos":[10996,11048]},{"content":"Any tool installed locally isn't available globally.","pos":[11049,11101]},{"content":"Tools are distributed as NuGet packages.","pos":[11102,11142]},{"content":"Local tools rely on a manifest file name <ph id=\"ph1\">`dotnet-tools.json`</ph> in your current directory.","pos":[11144,11231],"source":"Local tools rely on a manifest file name `dotnet-tools.json` in your current directory."},{"content":"This manifest file defines the tools to be available at that folder and below.","pos":[11232,11310]},{"content":"By creating this manifest file at the root of your repository, you ensure anyone cloning your code can restore and use the tools that are needed to successfully work with your code.","pos":[11311,11492]},{"pos":[11494,11545],"content":"To create a <ph id=\"ph1\">`dotnet-tools.json`</ph> manifest file, use:","source":"To create a `dotnet-tools.json` manifest file, use:"},{"content":"Add a new tool to the local manifest with:","pos":[11588,11630]},{"content":"You can also list the tools in the local manifest with:","pos":[11680,11735]},{"content":"To see what tools are installed globally, use:","pos":[11770,11816]},{"content":"When the local tools manifest file is available, but the tools defined in the manifest have not been installed, use the following command to automatically download and install those tools:","pos":[11854,12042]},{"content":"Run a local tool with the following command:","pos":[12080,12124]},{"content":"When a local tool is run, dotnet searches for a manifest up the current directory structure.","pos":[12178,12270]},{"content":"When a tool manifest file is found, it is searched for the requested tool.","pos":[12271,12345]},{"content":"If the tool is found in the manifest, but not the cache, the user receives an error and needs to run <ph id=\"ph1\">`dotnet tool restore`</ph>.","pos":[12346,12469],"source":" If the tool is found in the manifest, but not the cache, the user receives an error and needs to run `dotnet tool restore`."},{"content":"To remove a tool from the local tool manifest file, run the following command:","pos":[12471,12549]},{"content":"The tool manifest file is designed to allow hand editing – which you might do to update the required version for working with the repository.","pos":[12601,12742]},{"content":"Here is an example <ph id=\"ph1\">`dotnet-tools.json`</ph> file:","pos":[12743,12787],"source":" Here is an example `dotnet-tools.json` file:"},{"content":"For both global and local tools, a compatible version of the runtime is required.","pos":[13050,13131]},{"content":"Many tools currently on NuGet.org target .NET Core Runtime 2.1.","pos":[13132,13195]},{"content":"To install those globally or locally, you would still need to install the <bpt id=\"p1\">[</bpt>NET Core 2.1 Runtime<ept id=\"p1\">](https://dotnet.microsoft.com/download/dotnet-core/2.1)</ept>.","pos":[13196,13348],"source":" To install those globally or locally, you would still need to install the [NET Core 2.1 Runtime](https://dotnet.microsoft.com/download/dotnet-core/2.1)."},{"pos":[13353,13368],"content":"Windows desktop","linkify":"Windows desktop","nodes":[{"content":"Windows desktop","pos":[0,15]}]},{"content":"Starting with .NET Core 3.0 Preview 1, you can build Windows desktop applications using WPF and Windows Forms.","pos":[13370,13480]},{"content":"These frameworks also support using modern controls and Fluent styling from the Windows UI XAML Library (WinUI) via <bpt id=\"p1\">[</bpt>XAML islands<ept id=\"p1\">](/windows/uwp/xaml-platform/xaml-host-controls)</ept>.","pos":[13481,13659],"source":" These frameworks also support using modern controls and Fluent styling from the Windows UI XAML Library (WinUI) via [XAML islands](/windows/uwp/xaml-platform/xaml-host-controls)."},{"content":"The Windows Desktop component is part of the Windows .NET Core 3.0 SDK.","pos":[13661,13732]},{"pos":[13734,13817],"content":"You can create a new WPF or Windows Forms app with the following <ph id=\"ph1\">`dotnet`</ph> commands:","source":"You can create a new WPF or Windows Forms app with the following `dotnet` commands:"},{"content":"Visual Studio 2019 Preview 2 adds <bpt id=\"p1\">**</bpt>New Project<ept id=\"p1\">**</ept> templates for .NET Core 3.0 Windows Forms and WPF.","pos":[13870,13970],"source":"Visual Studio 2019 Preview 2 adds **New Project** templates for .NET Core 3.0 Windows Forms and WPF."},{"content":"Designers are still not yet supported.","pos":[13971,14009]},{"content":"And you can open, launch, and debug these projects in Visual Studio 2019.","pos":[14010,14083]},{"pos":[14085,14330],"content":"Visual Studio 2017 15.9 adds the ability to <bpt id=\"p1\">[</bpt>enable .NET Core previews<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/net-core-tooling-update-for-visual-studio-2017-version-15-9/)</ept>, but you need to turn that feature on, and it's not a supported scenario.","source":"Visual Studio 2017 15.9 adds the ability to [enable .NET Core previews](https://devblogs.microsoft.com/dotnet/net-core-tooling-update-for-visual-studio-2017-version-15-9/), but you need to turn that feature on, and it's not a supported scenario."},{"content":"The new projects are the same as existing .NET Core projects, with a couple additions.","pos":[14332,14418]},{"content":"Here is the comparison of the basic .NET Core console project and a basic Windows Forms and WPF project.","pos":[14419,14523]},{"content":"In a .NET Core console project, the project uses the <ph id=\"ph1\">`Microsoft.NET.Sdk`</ph> SDK and declares a dependency on .NET Core 3.0 via the <ph id=\"ph2\">`netcoreapp3.0`</ph> target framework.","pos":[14525,14686],"source":"In a .NET Core console project, the project uses the `Microsoft.NET.Sdk` SDK and declares a dependency on .NET Core 3.0 via the `netcoreapp3.0` target framework."},{"content":"To create a Windows Desktop app, use the <ph id=\"ph1\">`Microsoft.NET.Sdk.WindowsDesktop`</ph> SDK and choose which UI framework to use:","pos":[14687,14804],"source":" To create a Windows Desktop app, use the `Microsoft.NET.Sdk.WindowsDesktop` SDK and choose which UI framework to use:"},{"pos":[15064,15140],"content":"To choose Windows Forms over WPF, set <ph id=\"ph1\">`UseWindowsForms`</ph> instead of <ph id=\"ph2\">`UseWPF`</ph>:","source":"To choose Windows Forms over WPF, set `UseWindowsForms` instead of `UseWPF`:"},{"pos":[15408,15563],"content":"Both <ph id=\"ph1\">`UseWPF`</ph> and <ph id=\"ph2\">`UseWindowsForms`</ph> can be set to <ph id=\"ph3\">`true`</ph> if the app uses both frameworks, for example when a Windows Forms dialog is hosting a WPF control.","source":"Both `UseWPF` and `UseWindowsForms` can be set to `true` if the app uses both frameworks, for example when a Windows Forms dialog is hosting a WPF control."},{"pos":[15565,15776],"content":"Please share your feedback on the <bpt id=\"p1\">[</bpt>dotnet/winforms<ept id=\"p1\">](https://github.com/dotnet/winforms/issues)</ept>,  <bpt id=\"p2\">[</bpt>dotnet/wpf<ept id=\"p2\">](https://github.com/dotnet/wpf/issues)</ept> and <bpt id=\"p3\">[</bpt>dotnet/core<ept id=\"p3\">](https://github.com/dotnet/core/issues)</ept> repos.","source":"Please share your feedback on the [dotnet/winforms](https://github.com/dotnet/winforms/issues),  [dotnet/wpf](https://github.com/dotnet/wpf/issues) and [dotnet/core](https://github.com/dotnet/core/issues) repos."},{"pos":[15781,15816],"content":"MSIX Deployment for Windows Desktop","linkify":"MSIX Deployment for Windows Desktop","nodes":[{"content":"MSIX Deployment for Windows Desktop","pos":[0,35]}]},{"content":"<bpt id=\"p1\">[</bpt>MSIX<ept id=\"p1\">](https://docs.microsoft.com/windows/msix/)</ept> is a new Windows app package format.","pos":[15818,15903],"source":"[MSIX](https://docs.microsoft.com/windows/msix/) is a new Windows app package format."},{"content":"It can be used to deploy .NET Core 3.0 desktop applications to Windows 10.","pos":[15904,15978]},{"pos":[15980,16283],"content":"The <bpt id=\"p1\">[</bpt>Windows Application Packaging Project<ept id=\"p1\">](https://docs.microsoft.com/windows/uwp/porting/desktop-to-uwp-packaging-dot-net)</ept>, available in Visual Studio 2019 Preview 2, allows you to create MSIX packages with <bpt id=\"p2\">[</bpt>self-contained<ept id=\"p2\">](../deploying/index.md#self-contained-deployments-scd)</ept> .NET Core applications.","source":"The [Windows Application Packaging Project](https://docs.microsoft.com/windows/uwp/porting/desktop-to-uwp-packaging-dot-net), available in Visual Studio 2019 Preview 2, allows you to create MSIX packages with [self-contained](../deploying/index.md#self-contained-deployments-scd) .NET Core applications."},{"pos":[16286,16394],"content":"Note: The .NET Core project file must specify the supported runtimes in the <ph id=\"ph1\">`&lt;RuntimeIdentifiers&gt;`</ph> property:","source":"Note: The .NET Core project file must specify the supported runtimes in the `<RuntimeIdentifiers>` property:"},{"pos":[16467,16493],"content":"Fast built-in JSON support","linkify":"Fast built-in JSON support","nodes":[{"content":"Fast built-in JSON support","pos":[0,26]}]},{"content":"The .NET ecosystem has relied on <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Json.NET<ept id=\"p2\">**</ept><ept id=\"p1\">](https://www.newtonsoft.com/json)</ept> and other popular JSON libraries, which continue to be good choices.","pos":[16495,16644],"source":"The .NET ecosystem has relied on [**Json.NET**](https://www.newtonsoft.com/json) and other popular JSON libraries, which continue to be good choices."},{"content":"<bpt id=\"p1\">**</bpt>Json.NET<ept id=\"p1\">**</ept> uses .NET strings as its base datatype, which are UTF-16 under the hood.","pos":[16645,16730],"source":"**Json.NET** uses .NET strings as its base datatype, which are UTF-16 under the hood."},{"content":"The new built-in JSON support is high-performance, low allocation, and based on <ph id=\"ph1\">`Span&lt;byte&gt;`</ph>.","pos":[16732,16825],"source":"The new built-in JSON support is high-performance, low allocation, and based on `Span<byte>`."},{"content":"Three new main JSON-related types have been added to .NET Core 3.0 the <ph id=\"ph1\">`System.Text.Json`</ph> namespace.","pos":[16826,16926],"source":" Three new main JSON-related types have been added to .NET Core 3.0 the `System.Text.Json` namespace."},{"pos":[16932,16946],"content":"Utf8JsonReader","linkify":"Utf8JsonReader","nodes":[{"content":"Utf8JsonReader","pos":[0,14]}]},{"content":"<ph id=\"ph1\">`System.Text.Json.Utf8JsonReader`</ph> is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a <ph id=\"ph2\">`ReadOnlySpan&lt;byte&gt;`</ph>.","pos":[16948,17103],"source":"`System.Text.Json.Utf8JsonReader` is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a `ReadOnlySpan<byte>`."},{"content":"The <ph id=\"ph1\">`Utf8JsonReader`</ph> is a foundational, low-level type, that can be leveraged to build custom parsers and deserializers.","pos":[17104,17224],"source":" The `Utf8JsonReader` is a foundational, low-level type, that can be leveraged to build custom parsers and deserializers."},{"content":"Reading through a JSON payload using the new <ph id=\"ph1\">`Utf8JsonReader`</ph> is 2x faster than using the reader from <bpt id=\"p1\">**</bpt>Json.NET<ept id=\"p1\">**</ept>.","pos":[17225,17340],"source":" Reading through a JSON payload using the new `Utf8JsonReader` is 2x faster than using the reader from **Json.NET**."},{"content":"It does not allocate until you need to actualize JSON tokens as (UTF-16) strings.","pos":[17341,17422]},{"content":"This new API will include the following components:","pos":[17424,17475]},{"content":"In Preview 1: JSON reader (sequential access)","pos":[17479,17524]},{"content":"Coming next: JSON writer, DOM (random access), poco serializer, poco deserializer","pos":[17527,17608]},{"pos":[17610,17702],"content":"Here is the basic reader loop for the <ph id=\"ph1\">`Utf8JsonReader`</ph> that can be used as a starting point:","source":"Here is the basic reader loop for the `Utf8JsonReader` that can be used as a starting point:"},{"pos":[19095,19109],"content":"Utf8JsonWriter","linkify":"Utf8JsonWriter","nodes":[{"content":"Utf8JsonWriter","pos":[0,14]}]},{"content":"<ph id=\"ph1\">`System.Text.Json.Utf8JsonWriter`</ph> provides a high-performance, non-cached, forward-only way to write UTF-8 encoded JSON text from common .NET types like <ph id=\"ph2\">`String`</ph>, <ph id=\"ph3\">`Int32`</ph>, and <ph id=\"ph4\">`DateTime`</ph>.","pos":[19111,19298],"source":"`System.Text.Json.Utf8JsonWriter` provides a high-performance, non-cached, forward-only way to write UTF-8 encoded JSON text from common .NET types like `String`, `Int32`, and `DateTime`."},{"content":"Like the reader, the writer is a foundational, low-level type, that can be leveraged to build custom serializers.","pos":[19299,19412]},{"content":"Writing a JSON payload using the new <ph id=\"ph1\">`Utf8JsonWriter`</ph> is 30-80% faster than using the writer from <bpt id=\"p1\">**</bpt>Json.NET<ept id=\"p1\">**</ept> and does not allocate.","pos":[19413,19546],"source":" Writing a JSON payload using the new `Utf8JsonWriter` is 30-80% faster than using the writer from **Json.NET** and does not allocate."},{"pos":[19548,19632],"content":"Here is a sample usage of the <ph id=\"ph1\">`Utf8JsonWriter`</ph> that can be used as a starting point:","source":"Here is a sample usage of the `Utf8JsonWriter` that can be used as a starting point:"},{"content":"The <ph id=\"ph1\">`Utf8JsonWriter`</ph> accepts <ph id=\"ph2\">`IBufferWriter&lt;byte&gt;`</ph> as the output location to synchronously write the json data into, and you as the caller need to provide a concrete implementation.","pos":[20631,20812],"source":"The `Utf8JsonWriter` accepts `IBufferWriter<byte>` as the output location to synchronously write the json data into, and you as the caller need to provide a concrete implementation."},{"content":"The platform does not currently include an implementation of this interface.","pos":[20813,20889]},{"content":"For an example of <ph id=\"ph1\">`IBufferWriter&lt;byte&gt;`</ph>, see <bpt id=\"p1\">[</bpt><ph id=\"ph2\">https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35</ph><ept id=\"p1\">](https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35)</ept>","pos":[20890,21071],"source":" For an example of `IBufferWriter<byte>`, see [https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35](https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35)"},{"pos":[21077,21089],"content":"JsonDocument","linkify":"JsonDocument","nodes":[{"content":"JsonDocument","pos":[0,12]}]},{"content":"<ph id=\"ph1\">`System.Text.Json.JsonDocument`</ph> is built on top of the <ph id=\"ph2\">`Utf8JsonReader`</ph>.","pos":[21091,21163],"source":"`System.Text.Json.JsonDocument` is built on top of the `Utf8JsonReader`."},{"content":"The <ph id=\"ph1\">`JsonDocument`</ph> provides the ability to parse JSON data and build a read-only Document Object Model (DOM) that can be queried to support random access and enumeration.","pos":[21164,21334],"source":" The `JsonDocument` provides the ability to parse JSON data and build a read-only Document Object Model (DOM) that can be queried to support random access and enumeration."},{"content":"The JSON elements that compose the data can be accessed via the <ph id=\"ph1\">`JsonElement`</ph> type which is exposed by the <ph id=\"ph2\">`JsonDocument`</ph> as a property called <ph id=\"ph3\">`RootElement`</ph>.","pos":[21335,21492],"source":" The JSON elements that compose the data can be accessed via the `JsonElement` type which is exposed by the `JsonDocument` as a property called `RootElement`."},{"content":"The <ph id=\"ph1\">`JsonElement`</ph> contains the JSON array and object enumerators along with APIs to convert JSON text to common .NET types.","pos":[21493,21616],"source":" The `JsonElement` contains the JSON array and object enumerators along with APIs to convert JSON text to common .NET types."},{"content":"Parsing a typical JSON payload and accessing all its members using the <ph id=\"ph1\">`JsonDocument`</ph> is 2-3x faster than <bpt id=\"p1\">**</bpt>Json.NET<ept id=\"p1\">**</ept> with very little allocations for data that is reasonably sized (i.e. &lt; 1 MB).","pos":[21617,21813],"source":" Parsing a typical JSON payload and accessing all its members using the `JsonDocument` is 2-3x faster than **Json.NET** with very little allocations for data that is reasonably sized (i.e. < 1 MB)."},{"pos":[21815,21915],"content":"Here is a sample usage of the <ph id=\"ph1\">`JsonDocument`</ph> and <ph id=\"ph2\">`JsonElement`</ph> that can be used as a starting point:","source":"Here is a sample usage of the `JsonDocument` and `JsonElement` that can be used as a starting point:"},{"pos":[22671,22693],"content":"Assembly Unloadability","linkify":"Assembly Unloadability","nodes":[{"content":"Assembly Unloadability","pos":[0,22]}]},{"content":"Assembly unloadability is a new capability of <ph id=\"ph1\">`AssemblyLoadContext`</ph>.","pos":[22695,22763],"source":"Assembly unloadability is a new capability of `AssemblyLoadContext`."},{"content":"This new feature is largely transparent from an API perspective, exposed with just a few new APIs.","pos":[22764,22862]},{"content":"It enables a loader context to be unloaded, releasing all memory for instantiated types, static fields and for the assembly itself.","pos":[22863,22994]},{"content":"An application should be able to load and unload assemblies via this mechanism forever without experiencing a memory leak.","pos":[22995,23117]},{"content":"This new capability can be used for scenarios similar to:","pos":[23119,23176]},{"content":"Plugin scenarios where dynamic plugin loading and unloading is required.","pos":[23180,23252]},{"content":"Dynamically compiling, running and then flushing code.","pos":[23256,23310]},{"content":"Useful for web sites, scripting engines, etc.","pos":[23311,23356]},{"pos":[23359,23543],"content":"Loading assemblies for introspection (like ReflectionOnlyLoad), although <bpt id=\"p1\">[</bpt>MetadataLoadContext<ept id=\"p1\">](#type-metadataloadcontext)</ept> (released in Preview 1) will be a better choice in many cases.","source":"Loading assemblies for introspection (like ReflectionOnlyLoad), although [MetadataLoadContext](#type-metadataloadcontext) (released in Preview 1) will be a better choice in many cases."},{"pos":[23545,23652],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Using Unloadability<ept id=\"p1\">](https://github.com/dotnet/coreclr/pull/22221)</ept> document.","source":"For more information, see the [Using Unloadability](https://github.com/dotnet/coreclr/pull/22221) document."},{"content":"Assembly unloading requires significant care to ensure that all references to managed objects from outside a loader context are understood and managed.","pos":[23654,23805]},{"content":"When the loader context is requested to be unloaded, any outside references need to have been unreferenced so that the loader context is self-consistent only to itself.","pos":[23806,23974]},{"content":"Assembly unloadability was provided in the .NET Framework by Application Domains (AppDomains), which are not supported with .NET Core.","pos":[23976,24110]},{"content":"AppDomains had both benefits and limitations compared to this new model.","pos":[24111,24183]},{"content":"Consider this new loader model to be more flexible and higher performant when compared to AppDomains.","pos":[24184,24285]},{"pos":[24290,24312],"content":"Windows Native Interop","linkify":"Windows Native Interop","nodes":[{"content":"Windows Native Interop","pos":[0,22]}]},{"content":"Windows offers a rich native API, in the form of flat C APIs, COM, and WinRT.","pos":[24314,24391]},{"content":"Since .NET Core 1.0, <bpt id=\"p1\">**</bpt>P/Invoke<ept id=\"p1\">**</ept> has been supported.","pos":[24392,24445],"source":" Since .NET Core 1.0, **P/Invoke** has been supported."},{"content":"Now with .NET Core 3.0, support for the ability to <bpt id=\"p1\">**</bpt>CoCreate COM APIs<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Activate WinRT APIs<ept id=\"p2\">**</ept> has been added.","pos":[24446,24562],"source":" Now with .NET Core 3.0, support for the ability to **CoCreate COM APIs** and **Activate WinRT APIs** has been added."},{"pos":[24564,24707],"content":"You can see an example of using COM with the <bpt id=\"p1\">[</bpt>Excel Demo source code<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/core/extensions/ExcelDemo)</ept>.","source":"You can see an example of using COM with the [Excel Demo source code](https://github.com/dotnet/samples/tree/master/core/extensions/ExcelDemo)."},{"pos":[24712,24732],"content":"Type: SequenceReader","linkify":"Type: SequenceReader","nodes":[{"content":"Type: SequenceReader","pos":[0,20]}]},{"content":"In .NET Core 3.0, <ph id=\"ph1\">`System.Buffers.SequenceReader`</ph> has been added which can be used as a reader for <ph id=\"ph2\">`ReadOnlySequence&lt;T&gt;`</ph>.","pos":[24734,24855],"source":"In .NET Core 3.0, `System.Buffers.SequenceReader` has been added which can be used as a reader for `ReadOnlySequence<T>`."},{"content":"This allows easy, high performance, low allocation parsing of <ph id=\"ph1\">`System.IO.Pipelines`</ph> data that can cross multiple backing buffers.","pos":[24856,24985],"source":" This allows easy, high performance, low allocation parsing of `System.IO.Pipelines` data that can cross multiple backing buffers."},{"pos":[24988,25072],"content":"The following example breaks an input <ph id=\"ph1\">`Sequence`</ph> into valid <ph id=\"ph2\">`CR/LF`</ph> delimited lines:","source":"The following example breaks an input `Sequence` into valid `CR/LF` delimited lines:"},{"pos":[25722,25747],"content":"Type: MetadataLoadContext","linkify":"Type: MetadataLoadContext","nodes":[{"content":"Type: MetadataLoadContext","pos":[0,25]}]},{"content":"The <ph id=\"ph1\">`MetadataLoadContext`</ph> type has been added that enables reading assembly metadata without affecting the caller’s application domain.","pos":[25749,25884],"source":"The `MetadataLoadContext` type has been added that enables reading assembly metadata without affecting the caller’s application domain."},{"content":"Assemblies are read as data, including assemblies built for different architectures and platforms than the current runtime environment.","pos":[25885,26020]},{"content":"<ph id=\"ph1\">`MetadataLoadContext`</ph> overlaps with the <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad*&gt;</ph>, which is only available in the .NET Framework.","pos":[26021,26162],"source":"`MetadataLoadContext` overlaps with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad*>, which is only available in the .NET Framework."},{"content":"<ph id=\"ph1\">`MetdataLoadContext`</ph> is available in the <bpt id=\"p1\">[</bpt>System.Reflection.MetadataLoadContext package<ept id=\"p1\">](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext)</ept>.","pos":[26164,26323],"source":"`MetdataLoadContext` is available in the [System.Reflection.MetadataLoadContext package](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext)."},{"content":"It is a .NET Standard 2.0 package.","pos":[26324,26358]},{"content":"The <ph id=\"ph1\">`MetadataLoadContext`</ph> exposes APIs similar to the <ph id=\"ph2\">&lt;xref:System.Runtime.Loader.AssemblyLoadContext&gt;</ph> type, but is not based on that type.","pos":[26360,26499],"source":"The `MetadataLoadContext` exposes APIs similar to the <xref:System.Runtime.Loader.AssemblyLoadContext> type, but is not based on that type."},{"content":"Much like <ph id=\"ph1\">&lt;xref:System.Runtime.Loader.AssemblyLoadContext&gt;</ph>, the <ph id=\"ph2\">`MetadataLoadContext`</ph> enables loading assemblies within an isolated assembly loading universe.","pos":[26500,26658],"source":" Much like <xref:System.Runtime.Loader.AssemblyLoadContext>, the `MetadataLoadContext` enables loading assemblies within an isolated assembly loading universe."},{"content":"<ph id=\"ph1\">`MetdataLoadContext`</ph> APIs return <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly&gt;</ph> objects, enabling the use of familiar reflection APIs.","pos":[26659,26780],"source":"`MetdataLoadContext` APIs return <xref:System.Reflection.Assembly> objects, enabling the use of familiar reflection APIs."},{"content":"Execution-oriented APIs, such as <bpt id=\"p1\">[</bpt>MethodBase.Invoke<ept id=\"p1\">](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/src/System/Reflection/TypeLoading/Methods/RoMethod.cs#L127)</ept>, are not allowed and will throw InvalidOperationException.","pos":[26781,27039],"source":" Execution-oriented APIs, such as [MethodBase.Invoke](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/src/System/Reflection/TypeLoading/Methods/RoMethod.cs#L127), are not allowed and will throw InvalidOperationException."},{"content":"The following sample demonstrates how to find concrete types in an assembly that implements a given interface:","pos":[27041,27151]},{"pos":[27647,27883],"content":"Scenarios for <ph id=\"ph1\">`MetadataLoadContext`</ph> include design-time features, build-time tooling, and runtime light-up features that need to inspect a set of assemblies as data and have all file locks and memory freed after inspection is performed.","source":"Scenarios for `MetadataLoadContext` include design-time features, build-time tooling, and runtime light-up features that need to inspect a set of assemblies as data and have all file locks and memory freed after inspection is performed."},{"content":"The <ph id=\"ph1\">`MetadataLoadContext`</ph> has a resolver class passed to its constructor.","pos":[27885,27958],"source":"The `MetadataLoadContext` has a resolver class passed to its constructor."},{"content":"The resolver's job is to load an <ph id=\"ph1\">`Assembly`</ph> given its <ph id=\"ph2\">`AssemblyName`</ph>.","pos":[27959,28028],"source":" The resolver's job is to load an `Assembly` given its `AssemblyName`."},{"content":"The resolver class derives from the abstract <ph id=\"ph1\">`MetadataAssemblyResolver`</ph> class.","pos":[28029,28107],"source":" The resolver class derives from the abstract `MetadataAssemblyResolver` class."},{"content":"An implementation of the resolver for path-based scenarios is provided with <ph id=\"ph1\">`PathAssemblyResolver`</ph>.","pos":[28108,28207],"source":" An implementation of the resolver for path-based scenarios is provided with `PathAssemblyResolver`."},{"content":"The <bpt id=\"p1\">[</bpt>MetadataLoadContext tests<ept id=\"p1\">](https://github.com/dotnet/corefx/tree/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests)</ept> demonstrate many use cases.","pos":[28209,28372],"source":"The [MetadataLoadContext tests](https://github.com/dotnet/corefx/tree/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests) demonstrate many use cases."},{"content":"The <bpt id=\"p1\">[</bpt>Assembly tests<ept id=\"p1\">](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests/Assembly/AssemblyTests.cs)</ept> are a good place to start.","pos":[28373,28550],"source":" The [Assembly tests](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests/Assembly/AssemblyTests.cs) are a good place to start."},{"pos":[28555,28587],"content":"TLS 1.3 & OpenSSL 1.1.1 on Linux","linkify":"TLS 1.3 & OpenSSL 1.1.1 on Linux","nodes":[{"content":"TLS 1.3 &amp; OpenSSL 1.1.1 on Linux","pos":[0,32],"source":"TLS 1.3 & OpenSSL 1.1.1 on Linux"}]},{"content":".NET Core will now take advantage of <bpt id=\"p1\">[</bpt>TLS 1.3 support in OpenSSL 1.1.1<ept id=\"p1\">](https://www.openssl.org/blog/blog/2018/09/11/release111/)</ept>, when it is available in a given environment.","pos":[28589,28764],"source":".NET Core will now take advantage of [TLS 1.3 support in OpenSSL 1.1.1](https://www.openssl.org/blog/blog/2018/09/11/release111/), when it is available in a given environment."},{"content":"There are multiple benefits of TLS 1.3, per the <bpt id=\"p1\">[</bpt>OpenSSL team<ept id=\"p1\">](https://www.openssl.org/blog/blog/2018/09/11/release111/)</ept>:","pos":[28765,28886],"source":" There are multiple benefits of TLS 1.3, per the [OpenSSL team](https://www.openssl.org/blog/blog/2018/09/11/release111/):"},{"content":"Improved connection times due to a reduction in the number of round trips required between the client and server.","pos":[28890,29003]},{"content":"Improved security due to the removal of various obsolete and insecure cryptographic algorithms and encryption of more of the connection handshake.","pos":[29007,29153]},{"content":".NET Core 3.0 Preview 1 is capable of utilizing <bpt id=\"p1\">**</bpt>OpenSSL 1.1.1<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>OpenSSL 1.1.0<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>OpenSSL 1.0.2<ept id=\"p3\">**</ept> (whatever the best version found is, on a Linux system).","pos":[29155,29318],"source":".NET Core 3.0 Preview 1 is capable of utilizing **OpenSSL 1.1.1**, **OpenSSL 1.1.0**, or **OpenSSL 1.0.2** (whatever the best version found is, on a Linux system)."},{"content":"When <bpt id=\"p1\">**</bpt>OpenSSL 1.1.1<ept id=\"p1\">**</ept> is available the SslStream and HttpClient types will use <bpt id=\"p2\">**</bpt>TLS 1.3<ept id=\"p2\">**</ept> when using <ph id=\"ph1\">`SslProtocols.None`</ph> (system default protocols), assuming both the client and server support <bpt id=\"p3\">**</bpt>TLS 1.3<ept id=\"p3\">**</ept>.","pos":[29320,29527],"source":"  When **OpenSSL 1.1.1** is available the SslStream and HttpClient types will use **TLS 1.3** when using `SslProtocols.None` (system default protocols), assuming both the client and server support **TLS 1.3**."},{"pos":[29529,29646],"content":"The following sample demonstrates .NET Core 3.0 Preview 1 on Ubuntu 18.10 connecting to <ph id=\"ph1\">&lt;https://www.cloudflare.com&gt;</ph>:","source":"The following sample demonstrates .NET Core 3.0 Preview 1 on Ubuntu 18.10 connecting to <https://www.cloudflare.com>:"},{"pos":[30560,30721],"content":"[!IMPORTANT]\nWindows and macOS do not yet support **TLS 1.3**. .NET Core 3.0 will support **TLS 1.3** on these operating systems when support becomes available.","leadings":["",">"],"nodes":[{"content":"Windows and macOS do not yet support **TLS 1.3**. .NET Core 3.0 will support **TLS 1.3** on these operating systems when support becomes available.","pos":[13,160],"nodes":[{"content":"Windows and macOS do not yet support <bpt id=\"p1\">**</bpt>TLS 1.3<ept id=\"p1\">**</ept>.","pos":[0,49],"source":"Windows and macOS do not yet support **TLS 1.3**."},{"content":".NET Core 3.0 will support <bpt id=\"p1\">**</bpt>TLS 1.3<ept id=\"p1\">**</ept> on these operating systems when support becomes available.","pos":[50,147],"source":" .NET Core 3.0 will support **TLS 1.3** on these operating systems when support becomes available."}]}]},{"pos":[30726,30738],"content":"Cryptography","linkify":"Cryptography","nodes":[{"content":"Cryptography","pos":[0,12]}]},{"content":"Support has been added for <bpt id=\"p1\">**</bpt>AES-GCM<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>AES-CCM<ept id=\"p2\">**</ept> ciphers, implemented via <ph id=\"ph1\">`System.Security.Cryptography.AesGcm`</ph> and <ph id=\"ph2\">`System.Security.Cryptography.AesCcm`</ph>.","pos":[30740,30900],"source":"Support has been added for **AES-GCM** and **AES-CCM** ciphers, implemented via `System.Security.Cryptography.AesGcm` and `System.Security.Cryptography.AesCcm`."},{"content":"These algorithms are both <bpt id=\"p1\">[</bpt>Authenticated Encryption with Association Data (AEAD) algorithms<ept id=\"p1\">](https://en.wikipedia.org/wiki/Authenticated_encryption)</ept>, and the first Authenticated Encryption (AE) algorithms added to .NET Core.","pos":[30901,31125],"source":" These algorithms are both [Authenticated Encryption with Association Data (AEAD) algorithms](https://en.wikipedia.org/wiki/Authenticated_encryption), and the first Authenticated Encryption (AE) algorithms added to .NET Core."},{"pos":[31127,31218],"content":"The following code demonstrates using <bpt id=\"p1\">**</bpt>AesGcm<ept id=\"p1\">**</ept> cipher to encrypt and decrypt random data.","source":"The following code demonstrates using **AesGcm** cipher to encrypt and decrypt random data."},{"pos":[31220,31323],"content":"The code for <bpt id=\"p1\">**</bpt>AesCcm<ept id=\"p1\">**</ept> would look almost identical (only the class variable names would be different).","source":"The code for **AesCcm** would look almost identical (only the class variable names would be different)."},{"pos":[32489,32520],"content":"Cryptographic Key Import/Export","linkify":"Cryptographic Key Import/Export","nodes":[{"content":"Cryptographic Key Import/Export","pos":[0,31]}]},{"content":".NET Core 3.0 Preview 1 supports the import and export of asymmetric public and private keys from standard formats, without needing to use an X.509 certificate.","pos":[32522,32682]},{"content":"All key types (RSA, DSA, ECDsa, ECDiffieHellman) support the <bpt id=\"p1\">**</bpt>X.509 SubjectPublicKeyInfo<ept id=\"p1\">**</ept> format for public keys, and the <bpt id=\"p2\">**</bpt>PKCS#8 PrivateKeyInfo<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>PKCS#8 EncryptedPrivateKeyInfo<ept id=\"p3\">**</ept> formats for private keys.","pos":[32684,32898],"source":"All key types (RSA, DSA, ECDsa, ECDiffieHellman) support the **X.509 SubjectPublicKeyInfo** format for public keys, and the **PKCS#8 PrivateKeyInfo** and **PKCS#8 EncryptedPrivateKeyInfo** formats for private keys."},{"content":"RSA additionally supports <bpt id=\"p1\">**</bpt>PKCS#1 RSAPublicKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>PKCS#1 RSAPrivateKey<ept id=\"p2\">**</ept>.","pos":[32899,32978],"source":" RSA additionally supports **PKCS#1 RSAPublicKey** and **PKCS#1 RSAPrivateKey**."},{"content":"The export methods all produce DER-encoded binary data, and the import methods expect the same.","pos":[32979,33074]},{"content":"If a key is stored in the text-friendly PEM format, the caller will need to base64-decode the content before calling an import method.","pos":[33075,33209]},{"pos":[35070,35171],"content":"PKCS#8 files can be inspected with the <ph id=\"ph1\">`System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo`</ph> class.","source":"PKCS#8 files can be inspected with the `System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo` class."},{"pos":[35173,35344],"content":"PFX/PKCS#12 files can be inspected and manipulated with <ph id=\"ph1\">`System.Security.Cryptography.Pkcs.Pkcs12Info`</ph> and <ph id=\"ph2\">`System.Security.Cryptography.Pkcs.Pkcs12Builder`</ph>, respectively.","source":"PFX/PKCS#12 files can be inspected and manipulated with `System.Security.Cryptography.Pkcs.Pkcs12Info` and `System.Security.Cryptography.Pkcs.Pkcs12Builder`, respectively."},{"pos":[35349,35369],"content":"SerialPort for Linux","linkify":"SerialPort for Linux","nodes":[{"content":"SerialPort for Linux","pos":[0,20]}]},{"pos":[35371,35470],"content":".NET Core 3.0 now supports <ph id=\"ph1\">&lt;xref:System.IO.Ports.SerialPort?displayProperty=nameWithType&gt;</ph> on Linux.","source":".NET Core 3.0 now supports <xref:System.IO.Ports.SerialPort?displayProperty=nameWithType> on Linux."},{"pos":[35472,35548],"content":"Previously, .NET Core only supported using the <ph id=\"ph1\">`SerialPort`</ph> type on Windows.","source":"Previously, .NET Core only supported using the `SerialPort` type on Windows."},{"pos":[35553,35574],"content":"More BCL Improvements","linkify":"More BCL Improvements","nodes":[{"content":"More BCL Improvements","pos":[0,21]}]},{"content":"The <ph id=\"ph1\">`Span&lt;T&gt;`</ph>, <ph id=\"ph2\">`Memory&lt;T&gt;`</ph>, and related types that were introduced in .NET Core 2.1, have been optimized in .NET Core 3.0.","pos":[35576,35698],"source":"The `Span<T>`, `Memory<T>`, and related types that were introduced in .NET Core 2.1, have been optimized in .NET Core 3.0."},{"content":"Common operations such as span construction, slicing, parsing, and formatting now perform better.","pos":[35699,35796]},{"content":"Additionally, types like <ph id=\"ph1\">`String`</ph> have seen under-the-cover improvements to make them more efficient when used as keys with <ph id=\"ph2\">`Dictionary&lt;TKey, TValue&gt;`</ph> and other collections.","pos":[35799,35972],"source":"Additionally, types like `String` have seen under-the-cover improvements to make them more efficient when used as keys with `Dictionary<TKey, TValue>` and other collections."},{"content":"No code changes are required to benefit from these improvements.","pos":[35973,36037]},{"content":"The following improvements are also new in .NET Core 3 Preview 1:","pos":[36039,36104]},{"content":"Brotli support built in to HttpClient","pos":[36108,36145]},{"content":"ThreadPool.UnsafeQueueWorkItem(IThreadPoolWorkItem)","pos":[36148,36199]},{"content":"Unsafe.Unbox","pos":[36202,36214]},{"content":"CancellationToken.Unregister","pos":[36217,36245]},{"content":"Complex arithmetic operators","pos":[36248,36276]},{"content":"Socket APIs for TCP keep alive","pos":[36279,36309]},{"content":"StringBuilder.GetChunks","pos":[36312,36335]},{"content":"IPEndPoint parsing","pos":[36338,36356]},{"content":"RandomNumberGenerator.GetInt32","pos":[36359,36389]},{"pos":[36394,36412],"content":"Tiered compilation","linkify":"Tiered compilation","nodes":[{"content":"Tiered compilation","pos":[0,18]}]},{"content":"<bpt id=\"p1\">[</bpt>Tiered compilation<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/)</ept> is on by default with .NET Core 3.0.","pos":[36414,36554],"source":"[Tiered compilation](https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/) is on by default with .NET Core 3.0."},{"content":"It is a feature that enables the runtime to more adaptively use the Just-In-Time (JIT) compiler to get better performance, both at startup and to maximize throughput.","pos":[36555,36721]},{"content":"This feature was added as an opt-in feature in <bpt id=\"p1\">[</bpt>.NET Core 2.1<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-1/)</ept> and then was enabled by default in <bpt id=\"p2\">[</bpt>.NET Core 2.2 Preview 2<ept id=\"p2\">](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-2-preview-2/)</ept>.","pos":[36723,36985],"source":"This feature was added as an opt-in feature in [.NET Core 2.1](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-1/) and then was enabled by default in [.NET Core 2.2 Preview 2](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-2-preview-2/)."},{"content":"Subsequently, it has been reverted back to opt in with the .NET Core 2.2 release.","pos":[36986,37067]},{"pos":[37072,37091],"content":"ARM64 Linux support","linkify":"ARM64 Linux support","nodes":[{"content":"ARM64 Linux support","pos":[0,19]}]},{"content":"Support has been added for ARM64 for Linux.","pos":[37093,37136]},{"content":"The primary use case for ARM64 is currently with IoT scenarios.","pos":[37137,37200]},{"pos":[37202,37326],"content":"Alpine, Debian and Ubuntu <bpt id=\"p1\">[</bpt>Docker images are available for .NET Core for ARM64<ept id=\"p1\">](https://hub.docker.com/r/microsoft/dotnet/)</ept>.","source":"Alpine, Debian and Ubuntu [Docker images are available for .NET Core for ARM64](https://hub.docker.com/r/microsoft/dotnet/)."},{"pos":[37328,37438],"content":"Please check <bpt id=\"p1\">[</bpt>.NET Core ARM64 Status<ept id=\"p1\">](https://github.com/dotnet/announcements/issues/82)</ept> for more information.","source":"Please check [.NET Core ARM64 Status](https://github.com/dotnet/announcements/issues/82) for more information."},{"pos":[37441,37497],"content":"[!NOTE]\n**ARM64** Windows support isn't yet available.","leadings":["","> "],"nodes":[{"content":"<bpt id=\"p1\">**</bpt>ARM64<ept id=\"p1\">**</ept> Windows support isn't yet available.","pos":[8,54],"source":"**ARM64** Windows support isn't yet available."}]},{"pos":[37502,37551],"content":"Install .NET Core 3.0 Previews on Linux with Snap","linkify":"Install .NET Core 3.0 Previews on Linux with Snap","nodes":[{"content":"Install .NET Core 3.0 Previews on Linux with Snap","pos":[0,49]}]},{"pos":[37553,37709],"content":"Snap is the preferred way to install and try .NET Core previews on <bpt id=\"p1\">[</bpt>Linux distributions that support Snap<ept id=\"p1\">](https://docs.snapcraft.io/installing-snapd/6735)</ept>.","source":"Snap is the preferred way to install and try .NET Core previews on [Linux distributions that support Snap](https://docs.snapcraft.io/installing-snapd/6735)."},{"pos":[37711,37856],"content":"After configuring Snap on your system, run the following command to install the <bpt id=\"p1\">[</bpt>.NET Core SDK 3.0 Preview SDK<ept id=\"p1\">](https://snapcraft.io/dotnet-sdk)</ept>.","source":"After configuring Snap on your system, run the following command to install the [.NET Core SDK 3.0 Preview SDK](https://snapcraft.io/dotnet-sdk)."},{"content":"When .NET Core in installed using the Snap package, the default .NET Core command is <ph id=\"ph1\">`dotnet-sdk.dotnet`</ph>, as opposed to just <ph id=\"ph2\">`dotnet`</ph>.","pos":[37921,38055],"source":"When .NET Core in installed using the Snap package, the default .NET Core command is `dotnet-sdk.dotnet`, as opposed to just `dotnet`."},{"content":"The benefit of the namespaced command is that it will not conflict with a globally installed .NET Core version you may have.","pos":[38056,38180]},{"content":"This command can be aliased to <ph id=\"ph1\">`dotnet`</ph> with:","pos":[38181,38226],"source":" This command can be aliased to `dotnet` with:"},{"content":"Some distros require an additional step to enable access to the SSL certificate.","pos":[38285,38365]},{"content":"See our <bpt id=\"p1\">[</bpt>Linux Setup<ept id=\"p1\">](https://github.com/dotnet/core/blob/master/Documentation/linux-setup.md)</ept> for details.","pos":[38366,38473],"source":" See our [Linux Setup](https://github.com/dotnet/core/blob/master/Documentation/linux-setup.md) for details."},{"pos":[38478,38507],"content":"GPIO Support for Raspberry Pi","linkify":"GPIO Support for Raspberry Pi","nodes":[{"content":"GPIO Support for Raspberry Pi","pos":[0,29]}]},{"content":"Two new packages have been released to NuGet that you can use for GPIO programming.","pos":[38509,38592]},{"pos":[38596,38692],"content":"<bpt id=\"p1\">[</bpt>System.Device.Gpio<ept id=\"p1\">](https://www.nuget.org/packages/System.Device.Gpio/0.1.0-prerelease.19078.2)</ept>","source":"[System.Device.Gpio](https://www.nuget.org/packages/System.Device.Gpio/0.1.0-prerelease.19078.2)"},{"pos":[38695,38793],"content":"<bpt id=\"p1\">[</bpt>Iot.Device.Bindings<ept id=\"p1\">](https://www.nuget.org/packages/Iot.Device.Bindings/0.1.0-prerelease.19078.2)</ept>","source":"[Iot.Device.Bindings](https://www.nuget.org/packages/Iot.Device.Bindings/0.1.0-prerelease.19078.2)"},{"content":"The GPIO Packages includes APIs for GPIO, SPI, I2C and PWM devices.","pos":[38795,38862]},{"content":"The IoT bindings package includes <bpt id=\"p1\">[</bpt>device bindings<ept id=\"p1\">](https://github.com/dotnet/iot/blob/master/src/devices/README.md)</ept> for various chips and sensors, the same ones available at <bpt id=\"p2\">[</bpt>dotnet/iot - src/devices<ept id=\"p2\">](https://github.com/dotnet/iot/tree/master/src/devices)</ept>.","pos":[38863,39120],"source":" The IoT bindings package includes [device bindings](https://github.com/dotnet/iot/blob/master/src/devices/README.md) for various chips and sensors, the same ones available at [dotnet/iot - src/devices](https://github.com/dotnet/iot/tree/master/src/devices)."},{"content":"The updated serial port APIs that were announced as part of .NET Core 3.0 Preview 1 are not part of these packages but are available as part of the .NET Core platform.","pos":[39122,39289]},{"pos":[39294,39310],"content":"Platform Support","linkify":"Platform Support","nodes":[{"content":"Platform Support","pos":[0,16]}]},{"content":".NET Core 3 will be supported on the following operating systems:","pos":[39312,39377]},{"content":"Windows Client: 7, 8.1, 10 (1607+)","pos":[39381,39415]},{"content":"Windows Server: 2012 R2 SP1+","pos":[39418,39446]},{"content":"macOS: 10.12+","pos":[39449,39462]},{"content":"RHEL: 6+","pos":[39465,39473]},{"content":"Fedora: 26+","pos":[39476,39487]},{"content":"Ubuntu: 16.04+","pos":[39490,39504]},{"content":"Debian: 9+","pos":[39507,39517]},{"content":"SLES: 12+","pos":[39520,39529]},{"content":"openSUSE: 42.3+","pos":[39532,39547]},{"content":"Alpine: 3.8+","pos":[39550,39562]},{"content":"Chip support follows:","pos":[39564,39585]},{"content":"x64 on Windows, macOS, and Linux","pos":[39589,39621]},{"content":"x86 on Windows","pos":[39624,39638]},{"content":"ARM32 on Windows and Linux","pos":[39641,39667]},{"content":"ARM64 on Linux","pos":[39670,39684]},{"content":"For Linux, ARM32 is supported on Debian 9+ and Ubuntu 16.04+.","pos":[39686,39747]},{"content":"For ARM64, it is the same as ARM32 with the addition of Alpine 3.8.","pos":[39748,39815]},{"content":"These are the same versions of those distros as is supported for X64.","pos":[39816,39885]},{"content":"Docker images for .NET Core 3.0 are available at <bpt id=\"p1\">[</bpt>microsoft/dotnet on Docker Hub<ept id=\"p1\">](https://hub.docker.com/r/microsoft/dotnet/)</ept>.","pos":[39887,40013],"source":"Docker images for .NET Core 3.0 are available at [microsoft/dotnet on Docker Hub](https://hub.docker.com/r/microsoft/dotnet/)."},{"content":"Microsoft is currently in the process of adopting <bpt id=\"p1\">[</bpt>Microsoft Container Registry (MCR)<ept id=\"p1\">](https://cloudblogs.microsoft.com/opensource/2019/01/17/improved-discovery-experience-microsoft-containers-docker-hub/)</ept> and it is expected that the final .NET Core 3.0 images will only be published to MCR.","pos":[40014,40305],"source":" Microsoft is currently in the process of adopting [Microsoft Container Registry (MCR)](https://cloudblogs.microsoft.com/opensource/2019/01/17/improved-discovery-experience-microsoft-containers-docker-hub/) and it is expected that the final .NET Core 3.0 images will only be published to MCR."}]}