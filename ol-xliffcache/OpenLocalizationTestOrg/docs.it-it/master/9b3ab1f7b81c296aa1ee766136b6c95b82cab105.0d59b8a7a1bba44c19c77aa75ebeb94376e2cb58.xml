{"content":"---\ntitle: \"How to: Control the Fill of a Composite Shape\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"shapes [WPF], composite [WPF], controlling fill\"\n  - \"composite shapes [WPF], controlling fill\"\n  - \"graphics [WPF], composite shapes\"\n  - \"fill [WPF], controlling\"\nms.assetid: c1c94575-9eca-48a5-a49a-2ec65259f229\n---\n# How to: Control the Fill of a Composite Shape\nThe <xref:System.Windows.Media.GeometryGroup.FillRule%2A> property of a <xref:System.Windows.Media.GeometryGroup> or a <xref:System.Windows.Media.PathGeometry>, specifies a \"rule\" which the composite shape uses to determine whether a given point is part of the geometry. There are two possible values for <xref:System.Windows.Media.FillRule>: <xref:System.Windows.Media.FillRule.EvenOdd> and <xref:System.Windows.Media.FillRule.Nonzero>. The following sections will describe how to use these two rules.  \n  \n **EvenOdd:** This rule determines whether a point is in the fill region by drawing a ray from that point to infinity in any direction and counting the number of path segments within the given shape that the ray crosses. If this number is odd, the point is inside; if even, the point is outside.  \n  \n For example, the XAML below creates a composite shape made up of a series of concentric rings (target) with a <xref:System.Windows.Media.GeometryGroup.FillRule%2A> set to <xref:System.Windows.Media.FillRule.EvenOdd>.  \n  \n [!code-xaml[GeometriesMiscSnippets_snip#FillRuleEvenOddValue](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/FillRuleExample.xaml#fillruleevenoddvalue)]  \n  \n The following illustration shows the shape created in the previous example.  \n  \n ![Screenshot: FillRule Property of EvenOdd](./media/fillruleevenoddfirstone.png \"FillRuleEvenOddFirstOne\")  \n  \n In the illustration above, notice that the center and 3rd ring are not filled. This is because a ray drawn from any point within either of those two rings passes through an even number of segments. See illustration below:  \n  \n ![Diagram: FillRule property value of EvenOdd](./media/fillruleevenodd2.png \"FillRuleEvenOdd2\")  \n  \n **NonZero:** This rule determines whether a point is in the fill region of the path by drawing a ray from that point to infinity in any direction and then examining the places where a segment of the shape crosses the ray. Starting with a count of zero, add one each time a Segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left. After counting the crossings, if the result is zero then the point is outside the path. Otherwise, it is inside.  \n  \n [!code-xaml[GeometriesMiscSnippets_snip#FillRuleNonZeroValueEllipseGeometry](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/FillRuleExample.xaml#fillrulenonzerovalueellipsegeometry)]  \n  \n Using the example above, a value of <xref:System.Windows.Media.FillRule.Nonzero> for <xref:System.Windows.Media.GeometryGroup.FillRule%2A> gives the following illustration as a result:  \n  \n ![Screenshot: FillRule value of NonZero](./media/fillrulenonzero1.png \"FillRuleNonZero1\")  \n  \n As you can see, all the rings are filled. This is because all the segments are running in the same direction and so a ray drawn from any point will cross one or more segments and the sum of the crossings will not equal zero. For example, in the illustration below, the red arrows represent the direction the segments are drawn and the white arrow represents an arbitrary ray running from a point in the innermost ring. Starting with a value of zero, for each segment that the ray crosses, a value of one is added because the segment crosses the ray from left to right.  \n  \n ![Diagram: FillRule property value equal to NonZero](./media/fillrulenonzero2.png \"FillRuleNonZero2\")  \n  \n To better demonstrate the behavior of <xref:System.Windows.Media.FillRule.Nonzero> rule a more complex shape with segments running in different directions is required. The XAML code below creates a similar shape as the previous example except that it is created with a <xref:System.Windows.Media.PathGeometry> rather then a <xref:System.Windows.Media.EllipseGeometry> which creates four concentric arcs rather then fully closed concentric circles.  \n  \n [!code-xaml[GeometriesMiscSnippets_snip#FillRuleNonZeroValuePathGeometry](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/FillRuleExample.xaml#fillrulenonzerovaluepathgeometry)]  \n  \n The following illustration shows the shape created in the previous example.  \n  \n ![Screenshot: FillRule property value of NonZero](./media/fillrulenonzero3.png \"FillRuleNonZero3\")  \n  \n Notice that the third arc from the center is not filled. The illustration below shows why this is. In the illustration, the red arrows represent the direction the segments are drawn. The two white arrows represent two arbitrary rays that move out from a point in the \"non-filled\" region. As can be seen from the illustration, the sum of the values from a given ray crossing the segments in its path is zero. As defined above, a sum of zero means that the point is not part of the geometry (not part of the fill) while a sum that is *not* zero, including a negative value, is part of the geometry.  \n  \n ![Diagram: FillRule property value of NonZero](./media/fillrulenonzero4.png \"FillRuleNonZero4\")  \n  \n **Note:** For the purposes of <xref:System.Windows.Media.FillRule>, all shapes are considered closed. If there is a gap in a segment, draw an imaginary line to close it. In the example above, there are small gaps in the rings. Given this, one might expect a ray that runs through the gap to give a different result then a ray running in another direction. Below is an enlarged illustration of one of these gaps and the \"imaginary segment\" (segment that is drawn for purposes of applying the <xref:System.Windows.Media.FillRule>) that closes it.  \n  \n ![Diagram: For FillRule, segments are always closed](./media/fillruleclosedshapes.png \"FillRuleClosedShapes\")  \n  \n## Example  \n  \n## See also\n\n- [Create a Composite Shape](how-to-create-a-composite-shape.md)\n- [Geometry Overview](geometry-overview.md)\n","nodes":[{"pos":[4,321],"embed":true,"restype":"x-metadata","content":"title: \"How to: Control the Fill of a Composite Shape\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"shapes [WPF], composite [WPF], controlling fill\"\n  - \"composite shapes [WPF], controlling fill\"\n  - \"graphics [WPF], composite shapes\"\n  - \"fill [WPF], controlling\"\nms.assetid: c1c94575-9eca-48a5-a49a-2ec65259f229","nodes":[{"content":"How to: Control the Fill of a Composite Shape","nodes":[{"pos":[0,45],"content":"How to: Control the Fill of a Composite Shape","nodes":[{"content":"How to: Control the Fill of a Composite Shape","pos":[0,45]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[328,373],"content":"How to: Control the Fill of a Composite Shape","linkify":"How to: Control the Fill of a Composite Shape","nodes":[{"content":"How to: Control the Fill of a Composite Shape","pos":[0,45]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.GeometryGroup.FillRule%2A&gt;</ph> property of a <ph id=\"ph2\">&lt;xref:System.Windows.Media.GeometryGroup&gt;</ph> or a <ph id=\"ph3\">&lt;xref:System.Windows.Media.PathGeometry&gt;</ph>, specifies a \"rule\" which the composite shape uses to determine whether a given point is part of the geometry.","pos":[374,644],"source":"The <xref:System.Windows.Media.GeometryGroup.FillRule%2A> property of a <xref:System.Windows.Media.GeometryGroup> or a <xref:System.Windows.Media.PathGeometry>, specifies a \"rule\" which the composite shape uses to determine whether a given point is part of the geometry."},{"content":"There are two possible values for <ph id=\"ph1\">&lt;xref:System.Windows.Media.FillRule&gt;</ph>: <ph id=\"ph2\">&lt;xref:System.Windows.Media.FillRule.EvenOdd&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Media.FillRule.Nonzero&gt;</ph>.","pos":[645,811],"source":" There are two possible values for <xref:System.Windows.Media.FillRule>: <xref:System.Windows.Media.FillRule.EvenOdd> and <xref:System.Windows.Media.FillRule.Nonzero>."},{"content":"The following sections will describe how to use these two rules.","pos":[812,876]},{"content":"<bpt id=\"p1\">**</bpt>EvenOdd:<ept id=\"p1\">**</ept> This rule determines whether a point is in the fill region by drawing a ray from that point to infinity in any direction and counting the number of path segments within the given shape that the ray crosses.","pos":[883,1102],"source":"**EvenOdd:** This rule determines whether a point is in the fill region by drawing a ray from that point to infinity in any direction and counting the number of path segments within the given shape that the ray crosses."},{"content":"If this number is odd, the point is inside; if even, the point is outside.","pos":[1103,1177]},{"pos":[1184,1400],"content":"For example, the XAML below creates a composite shape made up of a series of concentric rings (target) with a <ph id=\"ph1\">&lt;xref:System.Windows.Media.GeometryGroup.FillRule%2A&gt;</ph> set to <ph id=\"ph2\">&lt;xref:System.Windows.Media.FillRule.EvenOdd&gt;</ph>.","source":"For example, the XAML below creates a composite shape made up of a series of concentric rings (target) with a <xref:System.Windows.Media.GeometryGroup.FillRule%2A> set to <xref:System.Windows.Media.FillRule.EvenOdd>."},{"content":"The following illustration shows the shape created in the previous example.","pos":[1592,1667]},{"pos":[1674,1780],"content":"<bpt id=\"p1\">![</bpt>Screenshot: FillRule Property of EvenOdd<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/fillruleevenoddfirstone.png \"</bpt>FillRuleEvenOddFirstOne<ept id=\"p2\">\")</ept>","source":"![Screenshot: FillRule Property of EvenOdd](./media/fillruleevenoddfirstone.png \"FillRuleEvenOddFirstOne\")"},{"content":"In the illustration above, notice that the center and 3rd ring are not filled.","pos":[1787,1865]},{"content":"This is because a ray drawn from any point within either of those two rings passes through an even number of segments.","pos":[1866,1984]},{"content":"See illustration below:","pos":[1985,2008]},{"pos":[2015,2110],"content":"<bpt id=\"p1\">![</bpt>Diagram: FillRule property value of EvenOdd<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/fillruleevenodd2.png \"</bpt>FillRuleEvenOdd2<ept id=\"p2\">\")</ept>","source":"![Diagram: FillRule property value of EvenOdd](./media/fillruleevenodd2.png \"FillRuleEvenOdd2\")"},{"content":"<bpt id=\"p1\">**</bpt>NonZero:<ept id=\"p1\">**</ept> This rule determines whether a point is in the fill region of the path by drawing a ray from that point to infinity in any direction and then examining the places where a segment of the shape crosses the ray.","pos":[2117,2338],"source":"**NonZero:** This rule determines whether a point is in the fill region of the path by drawing a ray from that point to infinity in any direction and then examining the places where a segment of the shape crosses the ray."},{"content":"Starting with a count of zero, add one each time a Segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left.","pos":[2339,2510]},{"content":"After counting the crossings, if the result is zero then the point is outside the path.","pos":[2511,2598]},{"content":"Otherwise, it is inside.","pos":[2599,2623]},{"pos":[2845,3029],"content":"Using the example above, a value of <ph id=\"ph1\">&lt;xref:System.Windows.Media.FillRule.Nonzero&gt;</ph> for <ph id=\"ph2\">&lt;xref:System.Windows.Media.GeometryGroup.FillRule%2A&gt;</ph> gives the following illustration as a result:","source":"Using the example above, a value of <xref:System.Windows.Media.FillRule.Nonzero> for <xref:System.Windows.Media.GeometryGroup.FillRule%2A> gives the following illustration as a result:"},{"pos":[3036,3125],"content":"<bpt id=\"p1\">![</bpt>Screenshot: FillRule value of NonZero<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/fillrulenonzero1.png \"</bpt>FillRuleNonZero1<ept id=\"p2\">\")</ept>","source":"![Screenshot: FillRule value of NonZero](./media/fillrulenonzero1.png \"FillRuleNonZero1\")"},{"content":"As you can see, all the rings are filled.","pos":[3132,3173]},{"content":"This is because all the segments are running in the same direction and so a ray drawn from any point will cross one or more segments and the sum of the crossings will not equal zero.","pos":[3174,3356]},{"content":"For example, in the illustration below, the red arrows represent the direction the segments are drawn and the white arrow represents an arbitrary ray running from a point in the innermost ring.","pos":[3357,3550]},{"content":"Starting with a value of zero, for each segment that the ray crosses, a value of one is added because the segment crosses the ray from left to right.","pos":[3551,3700]},{"pos":[3707,3808],"content":"<bpt id=\"p1\">![</bpt>Diagram: FillRule property value equal to NonZero<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/fillrulenonzero2.png \"</bpt>FillRuleNonZero2<ept id=\"p2\">\")</ept>","source":"![Diagram: FillRule property value equal to NonZero](./media/fillrulenonzero2.png \"FillRuleNonZero2\")"},{"content":"To better demonstrate the behavior of <ph id=\"ph1\">&lt;xref:System.Windows.Media.FillRule.Nonzero&gt;</ph> rule a more complex shape with segments running in different directions is required.","pos":[3815,3982],"source":"To better demonstrate the behavior of <xref:System.Windows.Media.FillRule.Nonzero> rule a more complex shape with segments running in different directions is required."},{"content":"The XAML code below creates a similar shape as the previous example except that it is created with a <ph id=\"ph1\">&lt;xref:System.Windows.Media.PathGeometry&gt;</ph> rather then a <ph id=\"ph2\">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph> which creates four concentric arcs rather then fully closed concentric circles.","pos":[3983,4262],"source":" The XAML code below creates a similar shape as the previous example except that it is created with a <xref:System.Windows.Media.PathGeometry> rather then a <xref:System.Windows.Media.EllipseGeometry> which creates four concentric arcs rather then fully closed concentric circles."},{"content":"The following illustration shows the shape created in the previous example.","pos":[4478,4553]},{"pos":[4560,4658],"content":"<bpt id=\"p1\">![</bpt>Screenshot: FillRule property value of NonZero<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/fillrulenonzero3.png \"</bpt>FillRuleNonZero3<ept id=\"p2\">\")</ept>","source":"![Screenshot: FillRule property value of NonZero](./media/fillrulenonzero3.png \"FillRuleNonZero3\")"},{"content":"Notice that the third arc from the center is not filled.","pos":[4665,4721]},{"content":"The illustration below shows why this is.","pos":[4722,4763]},{"content":"In the illustration, the red arrows represent the direction the segments are drawn.","pos":[4764,4847]},{"content":"The two white arrows represent two arbitrary rays that move out from a point in the \"non-filled\" region.","pos":[4848,4952]},{"content":"As can be seen from the illustration, the sum of the values from a given ray crossing the segments in its path is zero.","pos":[4953,5072]},{"content":"As defined above, a sum of zero means that the point is not part of the geometry (not part of the fill) while a sum that is <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> zero, including a negative value, is part of the geometry.","pos":[5073,5261],"source":" As defined above, a sum of zero means that the point is not part of the geometry (not part of the fill) while a sum that is *not* zero, including a negative value, is part of the geometry."},{"pos":[5268,5363],"content":"<bpt id=\"p1\">![</bpt>Diagram: FillRule property value of NonZero<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/fillrulenonzero4.png \"</bpt>FillRuleNonZero4<ept id=\"p2\">\")</ept>","source":"![Diagram: FillRule property value of NonZero](./media/fillrulenonzero4.png \"FillRuleNonZero4\")"},{"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> For the purposes of <ph id=\"ph1\">&lt;xref:System.Windows.Media.FillRule&gt;</ph>, all shapes are considered closed.","pos":[5370,5471],"source":"**Note:** For the purposes of <xref:System.Windows.Media.FillRule>, all shapes are considered closed."},{"content":"If there is a gap in a segment, draw an imaginary line to close it.","pos":[5472,5539]},{"content":"In the example above, there are small gaps in the rings.","pos":[5540,5596]},{"content":"Given this, one might expect a ray that runs through the gap to give a different result then a ray running in another direction.","pos":[5597,5725]},{"content":"Below is an enlarged illustration of one of these gaps and the \"imaginary segment\" (segment that is drawn for purposes of applying the <ph id=\"ph1\">&lt;xref:System.Windows.Media.FillRule&gt;</ph>) that closes it.","pos":[5726,5914],"source":" Below is an enlarged illustration of one of these gaps and the \"imaginary segment\" (segment that is drawn for purposes of applying the <xref:System.Windows.Media.FillRule>) that closes it."},{"pos":[5921,6030],"content":"<bpt id=\"p1\">![</bpt>Diagram: For FillRule, segments are always closed<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/fillruleclosedshapes.png \"</bpt>FillRuleClosedShapes<ept id=\"p2\">\")</ept>","source":"![Diagram: For FillRule, segments are always closed](./media/fillruleclosedshapes.png \"FillRuleClosedShapes\")"},{"pos":[6039,6046],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6055,6063],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6067,6129],"content":"<bpt id=\"p1\">[</bpt>Create a Composite Shape<ept id=\"p1\">](how-to-create-a-composite-shape.md)</ept>","source":"[Create a Composite Shape](how-to-create-a-composite-shape.md)"},{"pos":[6132,6173],"content":"<bpt id=\"p1\">[</bpt>Geometry Overview<ept id=\"p1\">](geometry-overview.md)</ept>","source":"[Geometry Overview](geometry-overview.md)"}]}