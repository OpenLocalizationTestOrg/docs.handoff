{"content":"---\ntitle: Inheritance in C#\ndescription: Learn to use inheritance in C# libraries and applications.\nkeywords: inheritance (C#), base classes, derived classes, abstract base classes\nauthor: rpetrusha\nmanager: wpickett\nms.author: ronpet\nms.date: 03/06/2017\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31\n---\n# Inheritance in C# and .NET #\n\n## Introduction ##\n\nThis tutorial introduces you to inheritance in C#. Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.\n\n## Prerequisites ##\n\nThis tutorial assumes that you've installed .NET Core. For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core). You also need a code editor. This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.\n\n## Running the examples ##\n\nTo create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line. Follow these steps for each example:\n\n1. Create a directory to store the example.\n\n1. Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.\n\n1. Copy and paste the code from the example into your code editor.\n\n1. Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.\n\n1. Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.\n\n## Background: What is inheritance? ##\n\n*Inheritance* is one of the fundamental attributes of object-oriented programming. It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class. The class whose members are inherited is called the *base class*. The class that inherits the members of the base class is called the *derived class*.\n\nC# and .NET support *single inheritance* only. That is, a class can only inherit from a single class. However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types. In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`. Because inheritance is transitive, the members of type `A` are available to type `D`.\n\nNot all members of a base class are inherited by derived classes. The following members are not inherited:\n\n- [Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.\n\n- [Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class. Each class must define its own constructors.\n\n- [Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.\n\nWhile all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility. A member's accessibility affects its visibility for derived classes as follows:\n\n- [Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class. Otherwise, they are not visible in derived classes. In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`. The private `A.value` field is visible in A.B. However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: \"'A.value' is inaccessible due to its protection level.\"\n\n   [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]\n\n- [Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.\n\n- [Internal](../language-reference/keywords/protected.md) members are visible only in derived classes that are located in the same assembly as the base class. They are not visible in derived classes located in a different assembly from the base class.\n\n- [Public] (../language-reference/keywords/protected.md) members are visible in derived classes and are part of the derived class' public interface. Public inherited members can be called just as if they were defined in the derived class. In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`. The example then calls `Method1` as if it were an instance method on `B`.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]\n\nDerived classes can also *override* inherited members by providing an alternate implementation. In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword. By default, base class members are not marked as `virtual` and cannot be overridden. Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: \"<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.\n\n   ```csharp\n   public class A\n   {\n      public void Method1()\n      {\n         // Do something.\n      }\n   }\n\n   public class B : A\n   {\n      public override void Method1()  // Generates CS0506.\n      {\n         // Do something else.\n      }\n   }\n   ```\n\nIn some cases, a derived class *must* override the base class implementation. Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them. Attempting to compile the following example generates compiler error CS0534, \"<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`.\n\n   ```csharp\n   public abstract class A\n   {\n      public abstract void Method1();\n   }\n\n   public class B : A                  // Generates CS0534.\n   {\n      public void Method3()\n      {\n         // Do something.\n      }\n   }\n   ```\n\nInheritance applies only to classes and interfaces. Other type categories (structs, delegates, and enums) do not support inheritance. Because of this, attempting to compile code like the following produces compiler error CS0527: \"Type 'ValueType' in interface list is not an interface.\" The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.\n\n   ```csharp\n   using System;\n\n   public struct ValueStructure : ValueType       // Generates CS0527.\n   {\n   }\n   ```\n\n## Implicit inheritance ##\n\nBesides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from @System.Object or a type derived from it. This ensures that common functionality is available to any type.\n\nTo see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]\n\nWe can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type. Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members. One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler. The eight seven are members of @System.Object, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]\n\nImplicit inheritance from the @System.Object class makes these methods available to the `SimpleClass` class:\n\n- The public `ToString` method, which converts a `SimpleClass` object to its string representation, the fully qualified type name. In this case, the `ToString` method returns the string \"SimpleClass\".\n\n- Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method. By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.\n\n- The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.\n\n- The public `GetType` method, which returns a @System.Type object that represents the `SimpleClass` type.\n\n- The protected @System.Object.Finalize method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.\n\n- The protected @System.Object.MemberwiseClone method, which creates a shallow clone of the current object.\n\nBecause of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class. For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from @System.Object.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]\n\nThe following table lists the categories of types that you can create in C# and the types from which they implicitly inherit. Each base type makes a different set of members available through inheritance to implicitly derived types.\n\n| Type category | Implicitly inherits from... |\n| :--- | :---: | ---: |\n| class | @System.Object |\n| struct | @System.ValueType, @System.Object |\n| enum | @System.Enum, System.ValueType, @System.Object |\n| delegate | @System.MulticastDelegate, @System.Delegate, @System.Object |\n\n## Inheritance and an \"is a\" relationship ##\n\nOrdinarily, inheritance is used to express an \"is a\" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class. For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.\n\n   [!NOTE] A class or struct can implement one more interfaces. While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a \"can do\" relationship) between an interface and its implementing type than inheritance. An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.\n\nNote that \"is a\" also expresses the relationship between a type and a specific instantiation of that type. In the following example, `Automobile` is a class that has three unique read-only properties: `Moke`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture. Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the @System.Object.ToString method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]\n\nIn this case, we should not rely on inheritance to represent specific car makes and models. For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company. Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]\n\nAn is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.\n\n## Designing the base class and derived classes ##\n\nLet's look at the process of designing a base class and its derived classes. In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`. We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.\n\n### The base `Publication` class ###\n\nIn designing our `Publication` class, we need to make several design decisions:\n\n- What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes.\n\n   In this case, the `Publication` class will provide method implementations. The [Designing abstract base classes amd their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override. Derived classes are free to provide any implementation that is suitable for the derived type.\n\n   The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes. Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types. If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class. The need to maintain duplicated code in multiple locations is a potential source of bugs.\n\n   Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications. Derived classes then implement members that are unique to the particular kinds of publication that they represent.\n\n- How far to extend our class hierarchy. Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes? For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.\n\n   For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`. We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.\n\n- Whether it makes sense to instantiate the base class. If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class. If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, \"Cannot create an instance of the abstract class or interface.\" If an attempt is made to instantiate the class by using reflection, the reflection method throws a @System.MemberAccessException. Otherwise, our `Publication` class can be instantiated by calling its class constructor.\n\n   By default, a base class can be instantiated by calling its class constructor. Note that we do not have to explicitly define a class constructor. If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.\n\n   For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.\n\n- Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation. We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method. By default, methods defined in the base class are *not* overridable.\n\n- Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes. By default, any class can serve as a base class. We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes. Attempting to derive from a sealed class generated compiler error CS0509, \"cannot derive from sealed type <typeName>\".\n\n   For our example, we'll mark our derived class as `sealed`.\n\nThe following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property. In addition to the members that it inherits from @System.Object, the `Publication` class defines the following unique members and member overrides:\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]\n\n- A constructor\n\n  Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:\n\n  ```csharp\n  var publication = new Publication(\"Tiddlywinks for Experts\", \"Fun and Games\",\n                                    PublicationType.Book);\n  ```\n\n  However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.\n\n- Two publication-related properties\n\n  `Title` is a read-only @System.String property whose value is supplied by calling the `Publication` constructor, which stores the value in a private field named `pubTitle`.\n\n  `Pages` is a read-write @System.Int32 property that indicates how many total pages the publication has. The value is stored in a private field named `totalPages`. It must be a positive number or an @System.ArgumentOutOfRangeException is thrown.\n\n- Publisher-related members\n\n  Two read-only properties, `Publisher` and `Type`, return the value of the private `pubName` and `pubType` fields. The values are originally supplied by the call to the `Publication` class constructor.\n\n- Publishing-related members\n\n  Two methods, `Publish` and `GetPublicationDate`, set and return the publication date. The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field. The `GetPublicationDate` method returns the string \"NYP\" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.\n\n- Copyright-related members\n\n  The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the private `copyrName` and `copyrDate` fields. The values can be retrieved from the `CopyrightName` and `CopyrightDate` properties.\n\n- An override of the `ToString` method\n\n  If a type does not override the @System.Object.ToString method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another. The `Publication` class overrides @System.Object.ToString to return the value of the `Title` property.\n\nThe following figure illustrates the relationship between our base `Publication` class and its implicitly inherited @System.Object class.\n\n![The Object and Publication classes](media/publication-class.jpg)\n\n### The `Book` class ###\n\nThe `Book` class represents a book as a specialized type of publication. The following example shows the source code for the `Book` class.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]\n\nIn addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:\n\n- Two constructors\n\n  The two `Book` constructors share three common parameters. Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor. The third is *author*, which is stored to a private `authorName` field. One constructor includes an *isbn* parameter, which is stored to the private `id` field.\n\n  The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor. This is a common pattern in defining constructors; constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.\n\n  The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor. If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.\n\n- A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number. The ISBN is supplied as an argument to one of the `Book` constructors and is stored in the private `id` field.\n\n- A read-only `Author` property. The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field.\n\n- Two read-only price-related properties, `Price` and `Currency`. Their values are provided as arguments in a `SetPrice` method call. The price is stored in a private field, `bookPrice`. The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field. ISO currency symbols can be retrieved from the @System.Globalization.RegionInfo.ISOCurrencySymbol property.\n\n- A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields. These are the values returned by the `Price` and `Currency` properties.\n\n- Overrides to the `ToString` method (inherited from `Publication`) and the @System.Object.Equals(System.Object) and @System.Object.GetHashCode methods (inherited from @System.Object).\n\n  Unless it is overridden, the @System.Object.Equals(System.Object) method tests for reference equality. That is, two object variables are considered to be equal if they refer to the same object. In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.\n\n  When you override the @System.Object.Equals(System.Object) method, you must also override the @System.Object.GetHashCode method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval. The hash code should return a value that's consistent with the test for equality. Since we've overridden @System.Object.Equals(System.Object) to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the @System.String.GetHashCode method of the string returned by the `ISBN` property.\n\nThe following figure illustrates the relationship between the `Book` class and `Publication`, its base class.\n\n![Publication and Book classes](media/book-class.jpg)\n\nWe can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]\n\n## <a name=\"abstract\"></a> Designing abstract base classes and their derived classes ##\n\nIn the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code. In many cases, however, the base class is not expected to provide an implementation. Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement. Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.\n\nFor example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape. The way in which these properties are calculated, however, depends completely on the specific shape. The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.\n\nThe following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`. Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword. In this case, `Shape` also overrides the @System.Object.ToString method to return the name of the type, rather than its fully qualified name. And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class. When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]\n\nWe can then derive some classes from `Shape` that represent specific shapes. The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`. Each uses a formula unique for that particular shape to compute the area and perimeter. Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]\n\nThe following example uses objects derived from `Shape`. It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values. Note that the runtime retrieves values from the overridden properties of the derived types. The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`. \n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]\n\n## See also ##\n\n[Classes and objects](../tour-of-csharp/classes-and-objects.md)</br>\n[Inheritance (C# Programming Guide)](../programming-guide/classes-and-structs/inheritance.md)\n","nodes":[{"pos":[4,398],"embed":true,"restype":"x-metadata","content":"title: Inheritance in C#\ndescription: Learn to use inheritance in C# libraries and applications.\nkeywords: inheritance (C#), base classes, derived classes, abstract base classes\nauthor: rpetrusha\nmanager: wpickett\nms.author: ronpet\nms.date: 03/06/2017\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31","nodes":[{"content":"Inheritance in C#","nodes":[{"pos":[0,17],"content":"Inheritance in C#","nodes":[{"content":"Inheritance in C#","pos":[0,17]}]}],"path":["title"],"nosxs":false},{"content":"Learn to use inheritance in C# libraries and applications.","nodes":[{"pos":[0,58],"content":"Learn to use inheritance in C# libraries and applications.","nodes":[{"content":"Learn to use inheritance in C# libraries and applications.","pos":[0,58]}]}],"path":["description"],"nosxs":false},{"content":"inheritance (C#), base classes, derived classes, abstract base classes","nodes":[{"pos":[0,70],"content":"inheritance (C#), base classes, derived classes, abstract base classes","nodes":[{"content":"inheritance (C#), base classes, derived classes, abstract base classes","pos":[0,70]}]}],"path":["keywords"],"nosxs":false}],"yml":true},{"pos":[405,431],"content":"Inheritance in C# and .NET","linkify":"Inheritance in C# and .NET","nodes":[{"content":"Inheritance in C# and .NET","pos":[0,26]}]},{"pos":[438,450],"content":"Introduction","linkify":"Introduction","nodes":[{"content":"Introduction","pos":[0,12]}]},{"content":"This tutorial introduces you to inheritance in C#.","pos":[455,505]},{"content":"Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.","pos":[506,749]},{"pos":[754,767],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"This tutorial assumes that you've installed .NET Core.","pos":[772,826]},{"content":"For installation instructions, see <bpt id=\"p1\">[</bpt>.NET Core installation guide<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept>.","pos":[827,929],"source":" For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core)."},{"content":"You also need a code editor.","pos":[930,958]},{"content":"This tutorial uses <bpt id=\"p1\">[</bpt>Visual Studio Code<ept id=\"p1\">](https://code.visualstudio.com)</ept>, although you can use any code editor of your choice.","pos":[959,1083],"source":" This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice."},{"pos":[1088,1108],"content":"Running the examples","linkify":"Running the examples","nodes":[{"content":"Running the examples","pos":[0,20]}]},{"content":"To create and run the examples in this tutorial, you use the <bpt id=\"p1\">[</bpt>dotnet<ept id=\"p1\">](../../core/tools/dotnet.md)</ept> utility from the command line.","pos":[1113,1241],"source":"To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line."},{"content":"Follow these steps for each example:","pos":[1242,1278]},{"content":"Create a directory to store the example.","pos":[1283,1323]},{"pos":[1328,1453],"content":"Enter the <bpt id=\"p1\">[</bpt>dotnet new console<ept id=\"p1\">](../../core/tools/dotnet-new.md)</ept> command at a command prompt to create a new .NET Core project.","source":"Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project."},{"content":"Copy and paste the code from the example into your code editor.","pos":[1458,1521]},{"pos":[1526,1665],"content":"Enter the <bpt id=\"p1\">[</bpt>dotnet restore<ept id=\"p1\">](../../core/tools/dotnet-restore.md)</ept> command from the command line to load or restore the project's dependencies.","source":"Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies."},{"pos":[1670,1768],"content":"Enter the <bpt id=\"p1\">[</bpt>dotnet run<ept id=\"p1\">](../../core/tools/dotnet-run.md)</ept> command to compile and execute the example.","source":"Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example."},{"pos":[1773,1805],"content":"Background: What is inheritance?","linkify":"Background: What is inheritance?","nodes":[{"content":"Background: What is inheritance?","pos":[0,32]}]},{"content":"<bpt id=\"p1\">*</bpt>Inheritance<ept id=\"p1\">*</ept> is one of the fundamental attributes of object-oriented programming.","pos":[1810,1892],"source":"*Inheritance* is one of the fundamental attributes of object-oriented programming."},{"content":"It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.","pos":[1893,2007]},{"content":"The class whose members are inherited is called the <bpt id=\"p1\">*</bpt>base class<ept id=\"p1\">*</ept>.","pos":[2008,2073],"source":" The class whose members are inherited is called the *base class*."},{"content":"The class that inherits the members of the base class is called the <bpt id=\"p1\">*</bpt>derived class<ept id=\"p1\">*</ept>.","pos":[2074,2158],"source":" The class that inherits the members of the base class is called the *derived class*."},{"content":"C# and .NET support <bpt id=\"p1\">*</bpt>single inheritance<ept id=\"p1\">*</ept> only.","pos":[2160,2206],"source":"C# and .NET support *single inheritance* only."},{"content":"That is, a class can only inherit from a single class.","pos":[2207,2261]},{"content":"However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.","pos":[2262,2369]},{"content":"In other words, type <ph id=\"ph1\">`D`</ph> can inherit from type <ph id=\"ph2\">`C`</ph>, which inherits from type <ph id=\"ph3\">`B`</ph>, which inherits from the base class type <ph id=\"ph4\">`A`</ph>.","pos":[2370,2496],"source":" In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`."},{"content":"Because inheritance is transitive, the members of type <ph id=\"ph1\">`A`</ph> are available to type <ph id=\"ph2\">`D`</ph>.","pos":[2497,2582],"source":" Because inheritance is transitive, the members of type `A` are available to type `D`."},{"content":"Not all members of a base class are inherited by derived classes.","pos":[2584,2649]},{"content":"The following members are not inherited:","pos":[2650,2690]},{"pos":[2694,2826],"content":"<bpt id=\"p1\">[</bpt>Static constructors<ept id=\"p1\">](../programming-guide/classes-and-structs/static-constructors.md)</ept>, which initialize the static data of a class.","source":"[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class."},{"content":"<bpt id=\"p1\">[</bpt>Instance constructors<ept id=\"p1\">](../programming-guide/classes-and-structs/constructors.md)</ept>, which you call to create a new instance of the class.","pos":[2830,2966],"source":"[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class."},{"content":"Each class must define its own constructors.","pos":[2967,3011]},{"pos":[3015,3170],"content":"<bpt id=\"p1\">[</bpt>Finalizers<ept id=\"p1\">](../programming-guide/classes-and-structs/destructors.md)</ept>, which are called by the runtime's garbage collector to destroy instances of a class.","source":"[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class."},{"content":"While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.","pos":[3172,3309]},{"content":"A member's accessibility affects its visibility for derived classes as follows:","pos":[3310,3389]},{"content":"<bpt id=\"p1\">[</bpt>Private<ept id=\"p1\">](../language-reference/keywords/private.md)</ept> members are visible only in derived classes that are nested in their base class.","pos":[3393,3526],"source":"[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class."},{"content":"Otherwise, they are not visible in derived classes.","pos":[3527,3578]},{"content":"In the following example, <ph id=\"ph1\">`A.B`</ph> is a nested class that derives from <ph id=\"ph2\">`A`</ph>, and <ph id=\"ph3\">`C`</ph> derives from <ph id=\"ph4\">`A`</ph>.","pos":[3579,3677],"source":" In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`."},{"content":"The private <ph id=\"ph1\">`A.value`</ph> field is visible in A.B.","pos":[3678,3724],"source":" The private `A.value` field is visible in A.B."},{"content":"However, if you remove the comments from the <ph id=\"ph1\">`C.GetValue`</ph> method and attempt to compile the example, it produces compiler error CS0122: \"'A.value' is inaccessible due to its protection level.\"","pos":[3725,3917],"source":" However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: \"'A.value' is inaccessible due to its protection level.\""},{"pos":[4022,4123],"content":"<bpt id=\"p1\">[</bpt>Protected<ept id=\"p1\">](../language-reference/keywords/protected.md)</ept> members are visible only in derived classes.","source":"[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes."},{"content":"<bpt id=\"p1\">[</bpt>Internal<ept id=\"p1\">](../language-reference/keywords/protected.md)</ept> members are visible only in derived classes that are located in the same assembly as the base class.","pos":[4127,4283],"source":"[Internal](../language-reference/keywords/protected.md) members are visible only in derived classes that are located in the same assembly as the base class."},{"content":"They are not visible in derived classes located in a different assembly from the base class.","pos":[4284,4376]},{"content":"[Public] (../language-reference/keywords/protected.md) members are visible in derived classes and are part of the derived class' public interface.","pos":[4380,4526]},{"content":"Public inherited members can be called just as if they were defined in the derived class.","pos":[4527,4616]},{"content":"In the following example, class <ph id=\"ph1\">`A`</ph> defines a method named <ph id=\"ph2\">`Method1`</ph>, and class <ph id=\"ph3\">`B`</ph> inherits from class <ph id=\"ph4\">`A`</ph>.","pos":[4617,4725],"source":" In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`."},{"content":"The example then calls <ph id=\"ph1\">`Method1`</ph> as if it were an instance method on <ph id=\"ph2\">`B`</ph>.","pos":[4726,4799],"source":" The example then calls `Method1` as if it were an instance method on `B`."},{"content":"Derived classes can also <bpt id=\"p1\">*</bpt>override<ept id=\"p1\">*</ept> inherited members by providing an alternate implementation.","pos":[4898,4993],"source":"Derived classes can also *override* inherited members by providing an alternate implementation."},{"content":"In order to be able to override a member, the member in the base class must be marked with the <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../language-reference/keywords/virtual.md)</ept> keyword.","pos":[4994,5150],"source":" In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword."},{"content":"By default, base class members are not marked as <ph id=\"ph1\">`virtual`</ph> and cannot be overridden.","pos":[5151,5235],"source":" By default, base class members are not marked as `virtual` and cannot be overridden."},{"content":"Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: \"<ph id=\"ph1\">&lt;member&gt;</ph> cannot override inherited member <ph id=\"ph2\">&lt;member&gt;</ph> because it is not marked virtual, abstract, or override.","pos":[5236,5453],"source":" Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: \"<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override."},{"content":"In some cases, a derived class <bpt id=\"p1\">*</bpt>must<ept id=\"p1\">*</ept> override the base class implementation.","pos":[5713,5790],"source":"In some cases, a derived class *must* override the base class implementation."},{"content":"Base class members marked with the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> keyword require that derived classes override them.","pos":[5791,5932],"source":" Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them."},{"content":"Attempting to compile the following example generates compiler error CS0534, \"<ph id=\"ph1\">&lt;class&gt;</ph> does not implement inherited abstract member <ph id=\"ph2\">&lt;member&gt;</ph>', because class <ph id=\"ph3\">`B`</ph> provides no implementation for <ph id=\"ph4\">`A.Method1`</ph>.","pos":[5933,6136],"source":" Attempting to compile the following example generates compiler error CS0534, \"<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`."},{"content":"Inheritance applies only to classes and interfaces.","pos":[6375,6426]},{"content":"Other type categories (structs, delegates, and enums) do not support inheritance.","pos":[6427,6508]},{"content":"Because of this, attempting to compile code like the following produces compiler error CS0527: \"Type 'ValueType' in interface list is not an interface.\"","pos":[6509,6661]},{"content":"The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.","pos":[6662,6790]},{"pos":[6915,6935],"content":"Implicit inheritance","linkify":"Implicit inheritance","nodes":[{"content":"Implicit inheritance","pos":[0,20]}]},{"content":"Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <ph id=\"ph1\">@System.Object</ph> or a type derived from it.","pos":[6940,7112],"source":"Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from @System.Object or a type derived from it."},{"content":"This ensures that common functionality is available to any type.","pos":[7113,7177]},{"pos":[7179,7301],"content":"To see what implicit inheritance means, let's define a new class, <ph id=\"ph1\">`SimpleClass`</ph>, that is simply an empty class definition:","source":"To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:"},{"content":"We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the <ph id=\"ph1\">`SimpleClass`</ph> type.","pos":[7405,7576],"source":"We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type."},{"content":"Although we haven't defined any members in our <ph id=\"ph1\">`SimpleClass`</ph> class, output from the example indicates that it actually has nine members.","pos":[7577,7713],"source":" Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members."},{"content":"One of these is a parameterless (or default) constructor that is automatically supplied for the <ph id=\"ph1\">`SimpleClass`</ph> type by the C# compiler.","pos":[7714,7848],"source":" One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler."},{"content":"The eight seven are members of <ph id=\"ph1\">@System.Object</ph>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.","pos":[7849,7997],"source":" The eight seven are members of @System.Object, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit."},{"pos":[8101,8209],"content":"Implicit inheritance from the <ph id=\"ph1\">@System.Object</ph> class makes these methods available to the <ph id=\"ph2\">`SimpleClass`</ph> class:","source":"Implicit inheritance from the @System.Object class makes these methods available to the `SimpleClass` class:"},{"content":"The public <ph id=\"ph1\">`ToString`</ph> method, which converts a <ph id=\"ph2\">`SimpleClass`</ph> object to its string representation, the fully qualified type name.","pos":[8213,8341],"source":"The public `ToString` method, which converts a `SimpleClass` object to its string representation, the fully qualified type name."},{"content":"In this case, the <ph id=\"ph1\">`ToString`</ph> method returns the string \"SimpleClass\".","pos":[8342,8411],"source":" In this case, the `ToString` method returns the string \"SimpleClass\"."},{"content":"Three methods that test for equality of two objects: the public instance <ph id=\"ph1\">`Equals(Object)`</ph> method, the public static <ph id=\"ph2\">`Equals(Object, Object)`</ph> method, and the public static <ph id=\"ph3\">`ReferenceEquals(Object, Object)`</ph> method.","pos":[8415,8627],"source":"Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method."},{"content":"By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.","pos":[8628,8756]},{"pos":[8760,8885],"content":"The public <ph id=\"ph1\">`GetHashCode`</ph> method, which computes a value that allows an instance of the type to be used in hashed collections.","source":"The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections."},{"pos":[8889,8993],"content":"The public <ph id=\"ph1\">`GetType`</ph> method, which returns a <ph id=\"ph2\">@System.Type</ph> object that represents the <ph id=\"ph3\">`SimpleClass`</ph> type.","source":"The public `GetType` method, which returns a @System.Type object that represents the `SimpleClass` type."},{"content":"The protected <ph id=\"ph1\">@System.Object.Finalize</ph> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.","pos":[8997,9156],"source":"The protected @System.Object.Finalize method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector."},{"content":"The protected <ph id=\"ph1\">@System.Object.MemberwiseClone</ph> method, which creates a shallow clone of the current object.","pos":[9160,9265],"source":"The protected @System.Object.MemberwiseClone method, which creates a shallow clone of the current object."},{"content":"Because of implicit inheritance, we can call any inherited member from a <ph id=\"ph1\">`SimpleClass`</ph> object just as if it was actually a member defined in the <ph id=\"ph2\">`SimpleClass`</ph> class.","pos":[9267,9432],"source":"Because of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class."},{"content":"For instance, the following example calls the <ph id=\"ph1\">`SimpleClass.ToString`</ph> method, which <ph id=\"ph2\">`SimpleClass`</ph> inherits from <ph id=\"ph3\">@System.Object</ph>.","pos":[9433,9559],"source":" For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from @System.Object."},{"content":"The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.","pos":[9664,9789]},{"content":"Each base type makes a different set of members available through inheritance to implicitly derived types.","pos":[9790,9896]},{"content":"Type category","pos":[9900,9913]},{"content":"Implicitly inherits from...","pos":[9916,9943]},{"content":"class","pos":[9972,9977]},{"content":"struct","pos":[9999,10005]},{"content":"<ph id=\"ph1\">@System.ValueType</ph>, <ph id=\"ph2\">@System.Object</ph>","pos":[10008,10041],"source":"@System.ValueType, @System.Object"},{"content":"enum","pos":[10046,10050]},{"content":"<ph id=\"ph1\">@System.Enum</ph>, System.ValueType, <ph id=\"ph2\">@System.Object</ph>","pos":[10053,10099],"source":"@System.Enum, System.ValueType, @System.Object"},{"content":"delegate","pos":[10104,10112]},{"content":"<ph id=\"ph1\">@System.MulticastDelegate</ph>, <ph id=\"ph2\">@System.Delegate</ph>, <ph id=\"ph3\">@System.Object</ph>","pos":[10115,10174],"source":"@System.MulticastDelegate, @System.Delegate, @System.Object"},{"pos":[10181,10219],"content":"Inheritance and an \"is a\" relationship","linkify":"Inheritance and an \"is a\" relationship","nodes":[{"content":"Inheritance and an \"is a\" relationship","pos":[0,38]}]},{"content":"Ordinarily, inheritance is used to express an \"is a\" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.","pos":[10224,10460]},{"content":"For example, the <ph id=\"ph1\">`Publication`</ph> class represents a publication of any kind, and the <ph id=\"ph2\">`Book`</ph> and <ph id=\"ph3\">`Magazine`</ph> classes represent specific types of publications.","pos":[10461,10615],"source":" For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications."},{"content":"A class or struct can implement one more interfaces.","pos":[10628,10680]},{"content":"While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a \"can do\" relationship) between an interface and its implementing type than inheritance.","pos":[10681,10958]},{"content":"An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.","pos":[10959,11194]},{"content":"Note that \"is a\" also expresses the relationship between a type and a specific instantiation of that type.","pos":[11196,11302]},{"content":"In the following example, <ph id=\"ph1\">`Automobile`</ph> is a class that has three unique read-only properties: <ph id=\"ph2\">`Moke`</ph>, the manufacturer of the automobile; <ph id=\"ph3\">`Model`</ph>, the kind of automobile; and <ph id=\"ph4\">`Year`</ph>, its year of manufacture.","pos":[11303,11510],"source":" In the following example, `Automobile` is a class that has three unique read-only properties: `Moke`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture."},{"content":"Our <ph id=\"ph1\">`Automobile`</ph> class also has a constructor whose arguments are assigned to the property values, and it overrides the <ph id=\"ph2\">@System.Object.ToString</ph> method to produce a string that uniquely identifies the <ph id=\"ph3\">`Automobile`</ph> instance rather than the <ph id=\"ph4\">`Automobile`</ph> class.","pos":[11511,11768],"source":" Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the @System.Object.ToString method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class."},{"content":"In this case, we should not rely on inheritance to represent specific car makes and models.","pos":[11865,11956]},{"content":"For example, we do not need to define a <ph id=\"ph1\">`Packard`</ph> type to represent automobiles manufactured by the Packard Motor Car Company.","pos":[11957,12083],"source":" For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company."},{"content":"Instead, we can represent them by creating an <ph id=\"ph1\">`Automobile`</ph> object with the appropriate values passed to its class constructor, as the following example does.","pos":[12084,12241],"source":" Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does."},{"content":"An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.","pos":[12338,12552]},{"pos":[12557,12601],"content":"Designing the base class and derived classes","linkify":"Designing the base class and derived classes","nodes":[{"content":"Designing the base class and derived classes","pos":[0,44]}]},{"content":"Let's look at the process of designing a base class and its derived classes.","pos":[12606,12682]},{"content":"In this section, we'll define a base class, <ph id=\"ph1\">`Publication`</ph>, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a <ph id=\"ph2\">`Book`</ph> class that derives from <ph id=\"ph3\">`Publication`</ph>.","pos":[12683,12920],"source":" In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`."},{"content":"We could easily extend the example to define other derived classes, such as <ph id=\"ph1\">`Magazine`</ph>, <ph id=\"ph2\">`Journal`</ph>, <ph id=\"ph3\">`Newspaper`</ph>, and <ph id=\"ph4\">`Article`</ph>.","pos":[12921,13047],"source":" We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`."},{"pos":[13053,13081],"content":"The base <ph id=\"ph1\">`Publication`</ph> class","linkify":"The base `Publication` class","source":"The base `Publication` class"},{"pos":[13087,13166],"content":"In designing our <ph id=\"ph1\">`Publication`</ph> class, we need to make several design decisions:","source":"In designing our `Publication` class, we need to make several design decisions:"},{"pos":[13170,13398],"content":"What members to include in our base <ph id=\"ph1\">`Publication`</ph> class, and whether the <ph id=\"ph2\">`Publication`</ph> members provide method implementations, or whether <ph id=\"ph3\">`Publication`</ph> is an abstract base class that serves as a template for its derived classes.","source":"What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes."},{"content":"In this case, the <ph id=\"ph1\">`Publication`</ph> class will provide method implementations.","pos":[13403,13477],"source":"In this case, the `Publication` class will provide method implementations."},{"content":"The <bpt id=\"p1\">[</bpt>Designing abstract base classes amd their derived classes<ept id=\"p1\">](#abstract)</ept> section contains an example that uses an abstract base class to define the methods that derived classes must override.","pos":[13478,13671],"source":" The [Designing abstract base classes amd their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override."},{"content":"Derived classes are free to provide any implementation that is suitable for the derived type.","pos":[13672,13765]},{"content":"The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.","pos":[13770,13973]},{"content":"Therefore, we should add members to <ph id=\"ph1\">`Publication`</ph> if their code is likely to be shared by some or most specialized <ph id=\"ph2\">`Publication`</ph> types.","pos":[13974,14109],"source":" Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types."},{"content":"If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.","pos":[14110,14285]},{"content":"The need to maintain duplicated code in multiple locations is a potential source of bugs.","pos":[14286,14375]},{"content":"Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the <ph id=\"ph1\">`Publication`</ph> class only the data and functionality that is common to all or to most publications.","pos":[14380,14609],"source":"Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications."},{"content":"Derived classes then implement members that are unique to the particular kinds of publication that they represent.","pos":[14610,14724]},{"content":"How far to extend our class hierarchy.","pos":[14728,14766]},{"content":"Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?","pos":[14767,14891]},{"content":"For example, <ph id=\"ph1\">`Publication`</ph> could be a base class of <ph id=\"ph2\">`Periodical`</ph>, which in turn is a base class of <ph id=\"ph3\">`Magazine`</ph>, <ph id=\"ph4\">`Journal`</ph> and <ph id=\"ph5\">`Newspaper`</ph>.","pos":[14892,15029],"source":" For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`."},{"content":"For our example, we'll use the simple hierarchy of a <ph id=\"ph1\">`Publication`</ph> class and a single derived classes, <ph id=\"ph2\">`Book`</ph>.","pos":[15034,15144],"source":"For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`."},{"content":"We could easily extend the example to create a number of additional   classes that derive from <ph id=\"ph1\">`Publication`</ph>, such as <ph id=\"ph2\">`Magazine`</ph> and <ph id=\"ph3\">`Article`</ph>.","pos":[15145,15288],"source":" We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`."},{"content":"Whether it makes sense to instantiate the base class.","pos":[15292,15345]},{"content":"If it does not, we should apply the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> keyword to the class.","pos":[15346,15458],"source":" If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class."},{"content":"If an attempt is made to instantiate a class marked with the <ph id=\"ph1\">`abstract`</ph> keyword by a direct call to its class constructor, the C# compiler generates error CS0144, \"Cannot create an instance of the abstract class or interface.\"","pos":[15459,15685],"source":" If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, \"Cannot create an instance of the abstract class or interface.\""},{"content":"If an attempt is made to instantiate the class by using reflection, the reflection method throws a <ph id=\"ph1\">@System.MemberAccessException</ph>.","pos":[15686,15815],"source":" If an attempt is made to instantiate the class by using reflection, the reflection method throws a @System.MemberAccessException."},{"content":"Otherwise, our <ph id=\"ph1\">`Publication`</ph> class can be instantiated by calling its class constructor.","pos":[15816,15904],"source":" Otherwise, our `Publication` class can be instantiated by calling its class constructor."},{"content":"By default, a base class can be instantiated by calling its class constructor.","pos":[15909,15987]},{"content":"Note that we do not have to explicitly define a class constructor.","pos":[15988,16054]},{"content":"If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.","pos":[16055,16186]},{"pos":[16191,16335],"content":"For our example, we'll mark the <ph id=\"ph1\">`Publication`</ph> class as <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> so that it cannot be instantiated.","source":"For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated."},{"content":"Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.","pos":[16339,16505]},{"content":"We have to use the <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../language-reference/keywords/virtual.md)</ept> keyword to allow derived classes to override a base class method.","pos":[16506,16643],"source":" We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method."},{"content":"By default, methods defined in the base class are <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> overridable.","pos":[16644,16712],"source":" By default, methods defined in the base class are *not* overridable."},{"content":"Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.","pos":[16716,16869]},{"content":"By default, any class can serve as a base class.","pos":[16870,16918]},{"content":"We can apply the <bpt id=\"p1\">[</bpt>sealed<ept id=\"p1\">](../language-reference/keywords/sealed.md)</ept> keyword to indicate that a class cannot serve as a base class for any additional classes.","pos":[16919,17076],"source":" We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes."},{"content":"Attempting to derive from a sealed class generated compiler error CS0509, \"cannot derive from sealed type <ph id=\"ph1\">&lt;typeName&gt;</ph>\".","pos":[17077,17195],"source":" Attempting to derive from a sealed class generated compiler error CS0509, \"cannot derive from sealed type <typeName>\"."},{"pos":[17200,17258],"content":"For our example, we'll mark our derived class as <ph id=\"ph1\">`sealed`</ph>.","source":"For our example, we'll mark our derived class as `sealed`."},{"content":"The following example shows the source code for the <ph id=\"ph1\">`Publication`</ph> class, as well as a <ph id=\"ph2\">`PublicationType`</ph> enumeration that is returned by the <ph id=\"ph3\">`Publication.PublicationType`</ph> property.","pos":[17260,17439],"source":"The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property."},{"content":"In addition to the members that it inherits from <ph id=\"ph1\">@System.Object</ph>, the <ph id=\"ph2\">`Publication`</ph> class defines the following unique members and member overrides:","pos":[17440,17587],"source":" In addition to the members that it inherits from @System.Object, the `Publication` class defines the following unique members and member overrides:"},{"content":"A constructor","pos":[17698,17711]},{"pos":[17715,17826],"content":"Because the <ph id=\"ph1\">`Publication`</ph> class is <ph id=\"ph2\">`abstract`</ph>, it cannot be instantiated directly from code like the following:","source":"Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:"},{"pos":[17988,18124],"content":"However, its instance constructor can be called directly from derived class constructors, as the source code for the <ph id=\"ph1\">`Book`</ph> class shows.","source":"However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows."},{"content":"Two publication-related properties","pos":[18128,18162]},{"pos":[18166,18338],"content":"<ph id=\"ph1\">`Title`</ph> is a read-only <ph id=\"ph2\">@System.String</ph> property whose value is supplied by calling the <ph id=\"ph3\">`Publication`</ph> constructor, which stores the value in a private field named <ph id=\"ph4\">`pubTitle`</ph>.","source":"`Title` is a read-only @System.String property whose value is supplied by calling the `Publication` constructor, which stores the value in a private field named `pubTitle`."},{"content":"<ph id=\"ph1\">`Pages`</ph> is a read-write <ph id=\"ph2\">@System.Int32</ph> property that indicates how many total pages the publication has.","pos":[18342,18445],"source":"`Pages` is a read-write @System.Int32 property that indicates how many total pages the publication has."},{"content":"The value is stored in a private field named <ph id=\"ph1\">`totalPages`</ph>.","pos":[18446,18504],"source":" The value is stored in a private field named `totalPages`."},{"content":"It must be a positive number or an <ph id=\"ph1\">@System.ArgumentOutOfRangeException</ph> is thrown.","pos":[18505,18586],"source":" It must be a positive number or an @System.ArgumentOutOfRangeException is thrown."},{"content":"Publisher-related members","pos":[18590,18615]},{"content":"Two read-only properties, <ph id=\"ph1\">`Publisher`</ph> and <ph id=\"ph2\">`Type`</ph>, return the value of the private <ph id=\"ph3\">`pubName`</ph> and <ph id=\"ph4\">`pubType`</ph> fields.","pos":[18619,18732],"source":"Two read-only properties, `Publisher` and `Type`, return the value of the private `pubName` and `pubType` fields."},{"content":"The values are originally supplied by the call to the <ph id=\"ph1\">`Publication`</ph> class constructor.","pos":[18733,18819],"source":" The values are originally supplied by the call to the `Publication` class constructor."},{"content":"Publishing-related members","pos":[18823,18849]},{"content":"Two methods, <ph id=\"ph1\">`Publish`</ph> and <ph id=\"ph2\">`GetPublicationDate`</ph>, set and return the publication date.","pos":[18853,18938],"source":"Two methods, `Publish` and `GetPublicationDate`, set and return the publication date."},{"content":"The <ph id=\"ph1\">`Publish`</ph> method sets a private  <ph id=\"ph2\">`published`</ph> flag to <ph id=\"ph3\">`true`</ph> when it is called and assigns the date passed to it as an argument to the private <ph id=\"ph4\">`datePublished`</ph> field.","pos":[18939,19107],"source":" The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field."},{"content":"The <ph id=\"ph1\">`GetPublicationDate`</ph> method returns the string \"NYP\" if the <ph id=\"ph2\">`published`</ph> flag is <ph id=\"ph3\">`false`</ph>, and the value of the <ph id=\"ph4\">`datePublished`</ph> field if it is <ph id=\"ph5\">`true`</ph>.","pos":[19108,19260],"source":" The `GetPublicationDate` method returns the string \"NYP\" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`."},{"content":"Copyright-related members","pos":[19264,19289]},{"content":"The <ph id=\"ph1\">`Copyright`</ph> method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the private <ph id=\"ph2\">`copyrName`</ph> and <ph id=\"ph3\">`copyrDate`</ph> fields.","pos":[19293,19465],"source":"The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the private `copyrName` and `copyrDate` fields."},{"content":"The values can be retrieved from the <ph id=\"ph1\">`CopyrightName`</ph> and <ph id=\"ph2\">`CopyrightDate`</ph> properties.","pos":[19466,19550],"source":" The values can be retrieved from the `CopyrightName` and `CopyrightDate` properties."},{"pos":[19554,19590],"content":"An override of the <ph id=\"ph1\">`ToString`</ph> method","source":"An override of the `ToString` method"},{"content":"If a type does not override the <ph id=\"ph1\">@System.Object.ToString</ph> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.","pos":[19594,19775],"source":"If a type does not override the @System.Object.ToString method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another."},{"content":"The <ph id=\"ph1\">`Publication`</ph> class overrides <ph id=\"ph2\">@System.Object.ToString</ph> to return the value of the <ph id=\"ph3\">`Title`</ph> property.","pos":[19776,19878],"source":" The `Publication` class overrides @System.Object.ToString to return the value of the `Title` property."},{"pos":[19880,20017],"content":"The following figure illustrates the relationship between our base <ph id=\"ph1\">`Publication`</ph> class and its implicitly inherited <ph id=\"ph2\">@System.Object</ph> class.","source":"The following figure illustrates the relationship between our base `Publication` class and its implicitly inherited @System.Object class."},{"content":"The Object and Publication classes","pos":[20021,20055]},{"pos":[20091,20107],"content":"The <ph id=\"ph1\">`Book`</ph> class","linkify":"The `Book` class","source":"The `Book` class"},{"content":"The <ph id=\"ph1\">`Book`</ph> class represents a book as a specialized type of publication.","pos":[20113,20185],"source":"The `Book` class represents a book as a specialized type of publication."},{"content":"The following example shows the source code for the <ph id=\"ph1\">`Book`</ph> class.","pos":[20186,20251],"source":" The following example shows the source code for the `Book` class."},{"pos":[20360,20499],"content":"In addition to the members that it inherits from <ph id=\"ph1\">`Publication`</ph>, the <ph id=\"ph2\">`Book`</ph> class defines the following unique members and member overrides:","source":"In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:"},{"content":"Two constructors","pos":[20503,20519]},{"content":"The two <ph id=\"ph1\">`Book`</ph> constructors share three common parameters.","pos":[20523,20581],"source":"The two `Book` constructors share three common parameters."},{"content":"Two, <bpt id=\"p1\">*</bpt>title<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>publisher<ept id=\"p2\">*</ept>, correspond to parameters of the <ph id=\"ph1\">`Publication`</ph> constructor.","pos":[20582,20670],"source":" Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor."},{"content":"The third is <bpt id=\"p1\">*</bpt>author<ept id=\"p1\">*</ept>, which is stored to a private <ph id=\"ph1\">`authorName`</ph> field.","pos":[20671,20742],"source":" The third is *author*, which is stored to a private `authorName` field."},{"content":"One constructor includes an <bpt id=\"p1\">*</bpt>isbn<ept id=\"p1\">*</ept> parameter, which is stored to the private <ph id=\"ph1\">`id`</ph> field.","pos":[20743,20831],"source":" One constructor includes an *isbn* parameter, which is stored to the private `id` field."},{"content":"The first constructor uses the <bpt id=\"p1\">[</bpt>this<ept id=\"p1\">](../language-reference/keywords/this.md)</ept> keyword to call the other constructor.","pos":[20835,20951],"source":"The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor."},{"content":"This is a common pattern in defining constructors; constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.","pos":[20952,21129]},{"content":"The second constructor uses the <bpt id=\"p1\">[</bpt>base<ept id=\"p1\">](../language-reference/keywords/base.md)</ept> keyword to pass the title and publisher name to the base class constructor.","pos":[21133,21287],"source":"The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor."},{"content":"If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.","pos":[21288,21474]},{"content":"A read-only <ph id=\"ph1\">`ISBN`</ph> property, which returns the <ph id=\"ph2\">`Book`</ph> object's International Standard Book Number, a unique 10- or 13-digit number.","pos":[21478,21609],"source":"A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number."},{"content":"The ISBN is supplied as an argument to one of the <ph id=\"ph1\">`Book`</ph> constructors and is stored in the private <ph id=\"ph2\">`id`</ph> field.","pos":[21610,21720],"source":" The ISBN is supplied as an argument to one of the `Book` constructors and is stored in the private `id` field."},{"content":"A read-only <ph id=\"ph1\">`Author`</ph> property.","pos":[21724,21754],"source":"A read-only `Author` property."},{"content":"The author name is supplied as an argument to both <ph id=\"ph1\">`Book`</ph> constructors and is stored in the private <ph id=\"ph2\">`authorName`</ph> field.","pos":[21755,21874],"source":" The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field."},{"content":"Two read-only price-related properties, <ph id=\"ph1\">`Price`</ph> and <ph id=\"ph2\">`Currency`</ph>.","pos":[21878,21941],"source":"Two read-only price-related properties, `Price` and `Currency`."},{"content":"Their values are provided as arguments in a <ph id=\"ph1\">`SetPrice`</ph> method call.","pos":[21942,22009],"source":" Their values are provided as arguments in a `SetPrice` method call."},{"content":"The price is stored in a private field, <ph id=\"ph1\">`bookPrice`</ph>.","pos":[22010,22062],"source":" The price is stored in a private field, `bookPrice`."},{"content":"The <ph id=\"ph1\">`Currency`</ph> property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private <ph id=\"ph2\">`ISOCurrencySymbol`</ph> field.","pos":[22063,22220],"source":" The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field."},{"content":"ISO currency symbols can be retrieved from the <ph id=\"ph1\">@System.Globalization.RegionInfo.ISOCurrencySymbol</ph> property.","pos":[22221,22328],"source":" ISO currency symbols can be retrieved from the @System.Globalization.RegionInfo.ISOCurrencySymbol property."},{"content":"A <ph id=\"ph1\">`SetPrice`</ph> method, which sets the values of the <ph id=\"ph2\">`bookPrice`</ph> and <ph id=\"ph3\">`ISOCurrencySymbol`</ph> fields.","pos":[22332,22425],"source":"A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields."},{"content":"These are the values returned by the <ph id=\"ph1\">`Price`</ph> and <ph id=\"ph2\">`Currency`</ph> properties.","pos":[22426,22497],"source":" These are the values returned by the `Price` and `Currency` properties."},{"pos":[22501,22683],"content":"Overrides to the <ph id=\"ph1\">`ToString`</ph> method (inherited from <ph id=\"ph2\">`Publication`</ph>) and the <ph id=\"ph3\">@System.Object.Equals</ph>(System.Object) and <ph id=\"ph4\">@System.Object.GetHashCode</ph> methods (inherited from <ph id=\"ph5\">@System.Object</ph>).","source":"Overrides to the `ToString` method (inherited from `Publication`) and the @System.Object.Equals(System.Object) and @System.Object.GetHashCode methods (inherited from @System.Object)."},{"content":"Unless it is overridden, the <ph id=\"ph1\">@System.Object.Equals</ph>(System.Object) method tests for reference equality.","pos":[22687,22789],"source":"Unless it is overridden, the @System.Object.Equals(System.Object) method tests for reference equality."},{"content":"That is, two object variables are considered to be equal if they refer to the same object.","pos":[22790,22880]},{"content":"In the case of the <ph id=\"ph1\">`Book`</ph> class, on the other hand, two <ph id=\"ph2\">`Book`</ph> objects should be equal if they have the same ISBN.","pos":[22881,22995],"source":" In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN."},{"content":"When you override the <ph id=\"ph1\">@System.Object.Equals</ph>(System.Object) method, you must also override the <ph id=\"ph2\">@System.Object.GetHashCode</ph> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.","pos":[22999,23233],"source":"When you override the @System.Object.Equals(System.Object) method, you must also override the @System.Object.GetHashCode method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval."},{"content":"The hash code should return a value that's consistent with the test for equality.","pos":[23234,23315]},{"content":"Since we've overridden <ph id=\"ph1\">@System.Object.Equals</ph>(System.Object) to return <ph id=\"ph2\">`true`</ph> if the ISBN properties of two <ph id=\"ph3\">`Book`</ph> objects are equal, we return the hash code computed by calling the <ph id=\"ph4\">@System.String.GetHashCode</ph> method of the string returned by the <ph id=\"ph5\">`ISBN`</ph> property.","pos":[23316,23577],"source":" Since we've overridden @System.Object.Equals(System.Object) to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the @System.String.GetHashCode method of the string returned by the `ISBN` property."},{"pos":[23579,23688],"content":"The following figure illustrates the relationship between the <ph id=\"ph1\">`Book`</ph> class and <ph id=\"ph2\">`Publication`</ph>, its base class.","source":"The following figure illustrates the relationship between the `Book` class and `Publication`, its base class."},{"content":"Publication and Book classes","pos":[23692,23720]},{"pos":[23745,23967],"content":"We can now instantiate a <ph id=\"ph1\">`Book`</ph> object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type <ph id=\"ph2\">`Publication`</ph> or of type <ph id=\"ph3\">`Book`</ph>, as the following example shows.","source":"We can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows."},{"pos":[24078,24159],"content":"<bpt id=\"p1\">&lt;a name=\"abstract\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Designing abstract base classes and their derived classes","linkify":"<a name=\"abstract\"></a> Designing abstract base classes and their derived classes","source":"<a name=\"abstract\"></a> Designing abstract base classes and their derived classes"},{"content":"In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.","pos":[24164,24308]},{"content":"In many cases, however, the base class is not expected to provide an implementation.","pos":[24309,24393]},{"content":"Instead, the base class is an <bpt id=\"p1\">*</bpt>abstract class<ept id=\"p1\">*</ept>; it serves as a template that defines the members that each derived class must implement.","pos":[24394,24530],"source":" Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement."},{"content":"Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.","pos":[24531,24643]},{"content":"For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.","pos":[24645,24824]},{"content":"The way in which these properties are calculated, however, depends completely on the specific shape.","pos":[24825,24925]},{"content":"The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.","pos":[24926,25055]},{"content":"The following example defines an abstract base class named <ph id=\"ph1\">`Shape`</ph> that defines two properties: <ph id=\"ph2\">`Area`</ph> and <ph id=\"ph3\">`Perimeter`</ph>.","pos":[25057,25176],"source":"The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`."},{"content":"Note that, in addition to marking the class with the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> keyword, each instance member is also marked with the <bpt id=\"p2\">[</bpt>abstract<ept id=\"p2\">](../language-reference/keywords/abstract.md)</ept> keyword.","pos":[25177,25402],"source":" Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword."},{"content":"In this case, <ph id=\"ph1\">`Shape`</ph> also overrides the <ph id=\"ph2\">@System.Object.ToString</ph> method to return the name of the type, rather than its fully qualified name.","pos":[25403,25544],"source":" In this case, `Shape` also overrides the @System.Object.ToString method to return the name of the type, rather than its fully qualified name."},{"content":"And it defines two static members, <ph id=\"ph1\">`GetArea`</ph> and <ph id=\"ph2\">`GetPerimeter`</ph>, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.","pos":[25545,25707],"source":" And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class."},{"content":"When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.","pos":[25708,25839]},{"content":"We can then derive some classes from <ph id=\"ph1\">`Shape`</ph> that represent specific shapes.","pos":[25937,26013],"source":"We can then derive some classes from `Shape` that represent specific shapes."},{"content":"The following example defines three classes, <ph id=\"ph1\">`Triangle`</ph>, <ph id=\"ph2\">`Rectangle`</ph>, and <ph id=\"ph3\">`Circle`</ph>.","pos":[26014,26097],"source":" The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`."},{"content":"Each uses a formula unique for that particular shape to compute the area and perimeter.","pos":[26098,26185]},{"content":"Some of the derived classes also define properties, such as <ph id=\"ph1\">`Rectangle.Diagonal`</ph> and <ph id=\"ph2\">`Circle.Diameter`</ph>, that are unique to the shape that they represent.","pos":[26186,26339],"source":" Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent."},{"content":"The following example uses objects derived from <ph id=\"ph1\">`Shape`</ph>.","pos":[26437,26493],"source":"The following example uses objects derived from `Shape`."},{"content":"It instantiates an array of objects derived from <ph id=\"ph1\">`Shape`</ph> and calls the static methods of the <ph id=\"ph2\">`Shape`</ph> class, which wraps return <ph id=\"ph3\">`Shape`</ph> property values.","pos":[26494,26645],"source":" It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values."},{"content":"Note that the runtime retrieves values from the overridden properties of the derived types.","pos":[26646,26737]},{"content":"The example also casts each <ph id=\"ph1\">`Shape`</ph> object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of <ph id=\"ph2\">`Shape`</ph>.","pos":[26738,26901],"source":" The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`."},{"pos":[27003,27011],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Classes and objects<ept id=\"p1\">](../tour-of-csharp/classes-and-objects.md)</ept>","pos":[27016,27079],"source":"[Classes and objects](../tour-of-csharp/classes-and-objects.md)"},{"content":"<bpt id=\"p1\">[</bpt>Inheritance (C# Programming Guide)<ept id=\"p1\">](../programming-guide/classes-and-structs/inheritance.md)</ept>","pos":[27085,27178],"source":"[Inheritance (C# Programming Guide)](../programming-guide/classes-and-structs/inheritance.md)"}]}