{"content":"---\ntitle: \"Code Contracts | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"Code contracts\"\nms.assetid: 84526045-496f-489d-8517-a258cf76f040\ncaps.latest.revision: 15\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# Code Contracts\nCode contracts provide a way to specify preconditions, postconditions, and object invariants in your code. Preconditions are requirements that must be met when entering a method or property. Postconditions describe expectations at the time the method or property code exits. Object invariants describe the expected state for a class that is in a good state.  \n  \n Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer. The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.  \n  \n The benefits of code contracts include the following:  \n  \n-   Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.  \n  \n-   Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.  \n  \n-   Static verification: The static checker can decide whether there are any contract violations without running the program. It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.  \n  \n-   Reference documentation: The documentation generator augments existing XML documentation files with contract information. There are also style sheets that can be used with [Sandcastle](http://go.microsoft.com/fwlink/?LinkID=169253) so that the generated documentation pages have contract sections.  \n  \n All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler. A Visual Studio add-in lets you specify the level of code contract analysis to be performed. The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format. Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.  \n  \n Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive. CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.  \n  \n For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.  \n  \n## Preconditions  \n You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=fullName> method. Preconditions specify state when a method is invoked. They are generally used to specify valid parameter values. All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method. The condition must have no side-effects. The run-time behavior of failed preconditions is determined by the runtime analyzer.  \n  \n For example, the following precondition expresses that parameter `x` must be non-null.  \n  \n `Contract.Requires( x != null );`  \n  \n If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.  \n  \n `Contract.Requires<ArgumentNullException>( x != null, \"x\" );`  \n  \n### Legacy Requires Statements  \n Most code contains some parameter validation in the form of `if`-`then`-`throw` code. The contract tools recognize these statements as preconditions in the following cases:  \n  \n-   The statements appear before any other statements in a method.  \n  \n-   The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.  \n  \n When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements. If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=fullName> method.  \n  \n```  \nif ( x == null ) throw new ...  \nContract.EndContractBlock(); // All previous \"if\" checks are preconditions  \n```  \n  \n Note that the condition in the preceding test is a negated precondition. (The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement. The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules. However, the type of the exception thrown must be as visible as the method in which the contract occurs.  \n  \n## Postconditions  \n Postconditions are contracts for the state of a method when it terminates. The postcondition is checked just before exiting a method. The run-time behavior of failed postconditions is determined by the runtime analyzer.  \n  \n Unlike preconditions, postconditions may reference members with less visibility. A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.  \n  \n### Standard Postconditions  \n You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method. Postconditions express a condition that must be `true` upon normal termination of the method.  \n  \n `Contract.Ensures( this .F > 0 );`  \n  \n### Exceptional Postconditions  \n Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method. You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=fullName> method, as the following example shows.  \n  \n `Contract.EnsuresOnThrow<T>( this.F > 0 );`  \n  \n The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.  \n  \n There are some exception types that are difficult to use in an exceptional postcondition. For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception. You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.  \n  \n### Special Postconditions  \n The following methods may be used only within postconditions:  \n  \n-   You can refer to method return values in postconditions by using the expression `Contract. Result<T>()`, where `T` is replaced by the return type of the method. When the compiler is unable to infer the type, you must explicitly provide it. For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 < Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract. Result<T>()` in their postconditions.  \n  \n-   A prestate value in a postcondition refers to the value of an expression at the start of a method or property. It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`. You can omit the generic type argument whenever the compiler is able to infer its type. (For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear. An old expression cannot contain another old expression. Most importantly, an old expression must refer to a value that existed in the method's precondition state. In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`. Here are several instances of that rule.  \n  \n    -   The value must exist in the method's precondition state. In order to reference a field on an object, the preconditions must guarantee that that object is always non-null.  \n  \n    -   You cannot refer to the method's return value in an old expression:  \n  \n        ```  \n        Contract.OldValue(Contract.Result<int>() + x) // ERROR  \n        ```  \n  \n    -   You cannot refer to `out` parameters in an old expression.  \n  \n    -   An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:  \n  \n        ```  \n        Contract. ForAll (0,Contract. Result<int>(),  \n        i => Contract.OldValue(xs[i]) > 3 ); // ERROR  \n        ```  \n  \n    -   An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:  \n  \n        ```  \n        Contract. ForAll (0, xs .Length, i => Contract.OldValue(xs[i]) > 3); // OK  \n        Contract. ForAll (0, xs .Length, i => Contract.OldValue(i) > 3 ); // ERROR  \n        ```  \n  \n    -   An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:  \n  \n        ```  \n        Method( ... (T t) => Contract.OldValue(... t ...) ... ); // ERROR  \n        ```  \n  \n    -   `Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions. To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.  \n  \n        ```  \n        public void OutParam(out int x) f  \n        Contract.Ensures(Contract.ValueAtReturn(out x) == 3);  \n        x = 3;  \n        ```  \n  \n         As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type. The contract rewriter replaces the method call with the value of the `out` parameter. The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions. The argument to the method must be an `out` parameter or a field of a structure `out` parameter. The latter is also useful when referring to fields in the postcondition of a structure constructor.  \n  \n        > [!NOTE]\n        >  Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition. Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error. However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.  \n  \n## Invariants  \n Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client. They express the conditions under which the object is considered to be correct.  \n  \n The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute. The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.  \n  \n```  \n[ContractInvariantMethod]  \nprotected void ObjectInvariant ()   \n{  \nContract.Invariant ( this.y >= 0 );  \nContract.Invariant ( this.x > this.y );  \n...  \n}  \n```  \n  \n Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol. During run-time checking, invariants are checked at the end of each public method. If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled. Instead, the check occurs only at the end of the outermost method call to that class. This also happens if the class is re-entered because of a call to a method on another class. Invariants are not checked for object finalizers or for any methods that implement the <xref:System.IDisposable.Dispose%2A> method.  \n  \n<a name=\"usage_guidelines\"></a>   \n## Usage Guidelines  \n  \n### Contract Ordering  \n The following table shows the order of elements you should use when you write method contracts.  \n  \n|`If-then-throw statements`|Backward-compatible public preconditions|  \n|-|-|  \n|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|All public preconditions.|  \n|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|All public (normal) postconditions.|  \n|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|All public exceptional postconditions.|  \n|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|All private/internal (normal) postconditions.|  \n|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|All private/internal exceptional postconditions.|  \n|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.|  \n  \n<a name=\"purity\"></a>   \n### Purity  \n All methods that are called within a contract must be pure; that is, they must not update any preexisting state. A pure method is allowed to modify objects that have been created after entry into the pure method.  \n  \n Code contract tools currently assume that the following code elements are pure:  \n  \n-   Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.  \n  \n-   Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).  \n  \n-   Property get accessors.  \n  \n-   Operators (static methods whose names start with \"op\", and that have one or two parameters and a non-void return type).  \n  \n-   Any method whose fully qualified name begins with \"System.Diagnostics.Contracts.Contract\", \"System.String\", \"System.IO.Path\", or \"System.Type\".  \n  \n-   Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>. The delegate types <xref:System.Predicate%601?displayProperty=fullName> and <xref:System.Comparison%601?displayProperty=fullName> are considered pure.  \n  \n<a name=\"visibility\"></a>   \n### Visibility  \n All members mentioned in a contract must be at least as visible as the method in which they appear. For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method. However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.  \n  \n## Example  \n The following example shows the use of code contracts.  \n  \n [!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]\n [!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]","nodes":[{"pos":[4,437],"embed":true,"restype":"x-metadata","content":"title: \"Code Contracts | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"Code contracts\"\nms.assetid: 84526045-496f-489d-8517-a258cf76f040\ncaps.latest.revision: 15\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","nodes":[{"content":"Code Contracts | Microsoft Docs","nodes":[{"pos":[0,31],"content":"Code Contracts | Microsoft Docs","nodes":[{"content":"Code Contracts | Microsoft Docs","pos":[0,31]}]}],"path":["title"]}],"yml":true},{"pos":[444,458],"content":"Code Contracts","linkify":"Code Contracts","nodes":[{"content":"Code Contracts","pos":[0,14]}]},{"content":"Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.","pos":[459,565]},{"content":"Preconditions are requirements that must be met when entering a method or property.","pos":[566,649]},{"content":"Postconditions describe expectations at the time the method or property code exits.","pos":[650,733]},{"content":"Object invariants describe the expected state for a class that is in a good state.","pos":[734,816]},{"content":"Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.","pos":[823,945]},{"content":"The classes for code contracts can be found in the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts&gt;</ph> namespace.","pos":[946,1043],"source":" The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace."},{"content":"The benefits of code contracts include the following:","pos":[1050,1103]},{"content":"Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.","pos":[1113,1231]},{"content":"Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.","pos":[1241,1410]},{"content":"Static verification: The static checker can decide whether there are any contract violations without running the program.","pos":[1420,1541]},{"content":"It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.","pos":[1542,1643]},{"content":"Reference documentation: The documentation generator augments existing XML documentation files with contract information.","pos":[1653,1774]},{"content":"There are also style sheets that can be used with <bpt id=\"p1\">[</bpt>Sandcastle<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=169253)</ept> so that the generated documentation pages have contract sections.","pos":[1775,1950],"source":" There are also style sheets that can be used with [Sandcastle](http://go.microsoft.com/fwlink/?LinkID=169253) so that the generated documentation pages have contract sections."},{"content":"All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.","pos":[1957,2085]},{"content":"A Visual Studio add-in lets you specify the level of code contract analysis to be performed.","pos":[2086,2178]},{"content":"The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.","pos":[2179,2374]},{"content":"Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.","pos":[2375,2486]},{"content":"Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the <ph id=\"ph1\">`#define`</ph> directive.","pos":[2493,2696],"source":"Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive."},{"content":"CONTRACTS_FULL lets you write contracts in your code without using <ph id=\"ph1\">`#ifdef`</ph> directives; you can produce different builds, some with contracts, and some without.","pos":[2697,2857],"source":" CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without."},{"pos":[2864,3023],"content":"For tools and detailed instructions for using code contracts, see <bpt id=\"p1\">[</bpt>Code Contracts<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.","source":"For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site."},{"pos":[3032,3045],"content":"Preconditions","linkify":"Preconditions","nodes":[{"content":"Preconditions","pos":[0,13]}]},{"content":"You can express preconditions by using the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=fullName&gt;</ph> method.","pos":[3049,3181],"source":"You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=fullName> method."},{"content":"Preconditions specify state when a method is invoked.","pos":[3182,3235]},{"content":"They are generally used to specify valid parameter values.","pos":[3236,3294]},{"content":"All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.","pos":[3295,3475]},{"content":"The condition must have no side-effects.","pos":[3476,3516]},{"content":"The run-time behavior of failed preconditions is determined by the runtime analyzer.","pos":[3517,3601]},{"pos":[3608,3694],"content":"For example, the following precondition expresses that parameter <ph id=\"ph1\">`x`</ph> must be non-null.","source":"For example, the following precondition expresses that parameter `x` must be non-null."},{"content":"If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> as follows.","pos":[3741,3922],"source":"If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows."},{"pos":[4000,4026],"content":"Legacy Requires Statements","linkify":"Legacy Requires Statements","nodes":[{"content":"Legacy Requires Statements","pos":[0,26]}]},{"content":"Most code contains some parameter validation in the form of <ph id=\"ph1\">`if`</ph><ph id=\"ph2\">-</ph><ph id=\"ph3\">`then`</ph><ph id=\"ph4\">-</ph><ph id=\"ph5\">`throw`</ph> code.","pos":[4030,4115],"source":"Most code contains some parameter validation in the form of `if`-`then`-`throw` code."},{"content":"The contract tools recognize these statements as preconditions in the following cases:","pos":[4116,4202]},{"content":"The statements appear before any other statements in a method.","pos":[4212,4274]},{"content":"The entire set of such statements is followed by an explicit <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> method call, such as a call to the <ph id=\"ph2\">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> method.","pos":[4284,4679],"source":"The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method."},{"content":"When <ph id=\"ph1\">`if`</ph><ph id=\"ph2\">-</ph><ph id=\"ph3\">`then`</ph><ph id=\"ph4\">-</ph><ph id=\"ph5\">`throw`</ph> statements appear in this form, the tools recognize them as legacy <ph id=\"ph6\">`requires`</ph> statements.","pos":[4686,4800],"source":"When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements."},{"content":"If no other contracts follow the <ph id=\"ph1\">`if`</ph><ph id=\"ph2\">-</ph><ph id=\"ph3\">`then`</ph><ph id=\"ph4\">-</ph><ph id=\"ph5\">`throw`</ph> sequence, end the code with the <ph id=\"ph6\">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=fullName&gt;</ph> method.","pos":[4801,4983],"source":" If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=fullName> method."},{"content":"Note that the condition in the preceding test is a negated precondition.","pos":[5115,5187]},{"content":"(The actual precondition would be <ph id=\"ph1\">`x != null`</ph>.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no <ph id=\"ph2\">`else`</ph> clauses, and the body of the <ph id=\"ph3\">`then`</ph> clause must be a single <ph id=\"ph4\">`throw`</ph> statement.","pos":[5188,5449],"source":" (The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement."},{"content":"The <ph id=\"ph1\">`if`</ph> test is subject to both purity and visibility rules (see <bpt id=\"p1\">[</bpt>Usage Guidelines<ept id=\"p1\">](#usage_guidelines)</ept>), but the <ph id=\"ph2\">`throw`</ph> expression is subject only to purity rules.","pos":[5450,5615],"source":" The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules."},{"content":"However, the type of the exception thrown must be as visible as the method in which the contract occurs.","pos":[5616,5720]},{"pos":[5729,5743],"content":"Postconditions","linkify":"Postconditions","nodes":[{"content":"Postconditions","pos":[0,14]}]},{"content":"Postconditions are contracts for the state of a method when it terminates.","pos":[5747,5821]},{"content":"The postcondition is checked just before exiting a method.","pos":[5822,5880]},{"content":"The run-time behavior of failed postconditions is determined by the runtime analyzer.","pos":[5881,5966]},{"content":"Unlike preconditions, postconditions may reference members with less visibility.","pos":[5973,6053]},{"content":"A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.","pos":[6054,6256]},{"pos":[6266,6289],"content":"Standard Postconditions","linkify":"Standard Postconditions","nodes":[{"content":"Standard Postconditions","pos":[0,23]}]},{"content":"You can express standard postconditions by using the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> method.","pos":[6293,6409],"source":"You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method."},{"content":"Postconditions express a condition that must be <ph id=\"ph1\">`true`</ph> upon normal termination of the method.","pos":[6410,6503],"source":" Postconditions express a condition that must be `true` upon normal termination of the method."},{"pos":[6554,6580],"content":"Exceptional Postconditions","linkify":"Exceptional Postconditions","nodes":[{"content":"Exceptional Postconditions","pos":[0,26]}]},{"content":"Exceptional postconditions are postconditions that should be <ph id=\"ph1\">`true`</ph> when a particular exception is thrown by a method.","pos":[6584,6702],"source":"Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method."},{"content":"You can specify these postconditions by using the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=fullName&gt;</ph> method, as the following example shows.","pos":[6703,6880],"source":" You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=fullName> method, as the following example shows."},{"pos":[6937,7044],"content":"The argument is the condition that must be <ph id=\"ph1\">`true`</ph> whenever an exception that is a subtype of <ph id=\"ph2\">`T`</ph> is thrown.","source":"The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown."},{"content":"There are some exception types that are difficult to use in an exceptional postcondition.","pos":[7051,7140]},{"content":"For example, using the type <ph id=\"ph1\">&lt;xref:System.Exception&gt;</ph> for <ph id=\"ph2\">`T`</ph> requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.","pos":[7141,7372],"source":" For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception."},{"content":"You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <ph id=\"ph1\">&lt;xref:System.InvalidTimeZoneException&gt;</ph> is thrown for a <ph id=\"ph2\">&lt;xref:System.TimeZoneInfo&gt;</ph> method call.","pos":[7373,7605],"source":" You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call."},{"pos":[7615,7637],"content":"Special Postconditions","linkify":"Special Postconditions","nodes":[{"content":"Special Postconditions","pos":[0,22]}]},{"content":"The following methods may be used only within postconditions:","pos":[7641,7702]},{"content":"You can refer to method return values in postconditions by using the expression <ph id=\"ph1\">`Contract. Result&lt;T&gt;()`</ph>, where <ph id=\"ph2\">`T`</ph> is replaced by the return type of the method.","pos":[7712,7872],"source":"You can refer to method return values in postconditions by using the expression `Contract. Result<T>()`, where `T` is replaced by the return type of the method."},{"content":"When the compiler is unable to infer the type, you must explicitly provide it.","pos":[7873,7951]},{"content":"For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: <ph id=\"ph1\">`Contract.Ensures(0 &lt; Contract.Result&lt;int&gt;())`</ph> Methods with a return type of <ph id=\"ph2\">`void`</ph> cannot refer to <ph id=\"ph3\">`Contract. Result&lt;T&gt;()`</ph> in their postconditions.","pos":[7952,8242],"source":" For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 < Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract. Result<T>()` in their postconditions."},{"content":"A prestate value in a postcondition refers to the value of an expression at the start of a method or property.","pos":[8252,8362]},{"content":"It uses the expression <ph id=\"ph1\">`Contract.OldValue&lt;T&gt;(e)`</ph>, where <ph id=\"ph2\">`T`</ph> is the type of <ph id=\"ph3\">`e`</ph>.","pos":[8363,8442],"source":" It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`."},{"content":"You can omit the generic type argument whenever the compiler is able to infer its type.","pos":[8443,8530]},{"content":"(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in <ph id=\"ph1\">`e`</ph> and the contexts in which an old expression may appear.","pos":[8531,8726],"source":" (For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear."},{"content":"An old expression cannot contain another old expression.","pos":[8727,8783]},{"content":"Most importantly, an old expression must refer to a value that existed in the method's precondition state.","pos":[8784,8890]},{"content":"In other words, it must be an expression that can be evaluated as long as the method's precondition is <ph id=\"ph1\">`true`</ph>.","pos":[8891,9001],"source":" In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`."},{"content":"Here are several instances of that rule.","pos":[9002,9042]},{"content":"The value must exist in the method's precondition state.","pos":[9056,9112]},{"content":"In order to reference a field on an object, the preconditions must guarantee that that object is always non-null.","pos":[9113,9226]},{"content":"You cannot refer to the method's return value in an old expression:","pos":[9240,9307]},{"pos":[9417,9475],"content":"You cannot refer to <ph id=\"ph1\">`out`</ph> parameters in an old expression.","source":"You cannot refer to `out` parameters in an old expression."},{"content":"An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:","pos":[9489,9632]},{"content":"An old expression cannot refer to the parameter of the anonymous delegate in a <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Diagnostics.Contracts.Contract.Exists%2A&gt;</ph> call unless it is used as an indexer or argument to a method call:","pos":[9788,10046],"source":"An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:"},{"content":"An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Diagnostics.Contracts.Contract.Exists%2A&gt;</ph> method:","pos":[10261,10596],"source":"An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:"},{"content":"<ph id=\"ph1\">`Out`</ph> parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to <ph id=\"ph2\">`out`</ph> parameters in postconditions.","pos":[10717,10889],"source":"`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions."},{"content":"To solve this problem, the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> class provides the <ph id=\"ph2\">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> method, which allows a postcondition based on an <ph id=\"ph3\">`out`</ph> parameter.","pos":[10890,11108],"source":" To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter."},{"content":"As with the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> method, you can omit the generic type parameter whenever the compiler is able to infer its type.","pos":[11279,11444],"source":"As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type."},{"content":"The contract rewriter replaces the method call with the value of the <ph id=\"ph1\">`out`</ph> parameter.","pos":[11445,11530],"source":" The contract rewriter replaces the method call with the value of the `out` parameter."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> method may appear only in postconditions.","pos":[11531,11638],"source":" The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions."},{"content":"The argument to the method must be an <ph id=\"ph1\">`out`</ph> parameter or a field of a structure <ph id=\"ph2\">`out`</ph> parameter.","pos":[11639,11735],"source":" The argument to the method must be an `out` parameter or a field of a structure `out` parameter."},{"content":"The latter is also useful when referring to fields in the postcondition of a structure constructor.","pos":[11736,11835]},{"pos":[11851,12344],"content":"[!NOTE]\nCurrently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition. Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error. However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.","leadings":["","        >  "],"nodes":[{"content":"Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition. Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error. However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.","pos":[8,482],"nodes":[{"content":"Currently, the code contract analysis tools do not check whether <ph id=\"ph1\">`out`</ph> parameters are initialized properly and disregard their mention in the postcondition.","pos":[0,156],"source":"Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition."},{"content":"Therefore, in the previous example, if the line after the contract had used the value of <ph id=\"ph1\">`x`</ph> instead of assigning an integer to it, a compiler would not issue the correct error.","pos":[157,334],"source":" Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error."},{"content":"However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.","pos":[335,474]}]}]},{"pos":[12353,12363],"content":"Invariants","linkify":"Invariants","nodes":[{"content":"Invariants","pos":[0,10]}]},{"content":"Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.","pos":[12367,12493]},{"content":"They express the conditions under which the object is considered to be correct.","pos":[12494,12573]},{"content":"The invariant methods are identified by being marked with the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attribute.","pos":[12580,12721],"source":"The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute."},{"content":"The invariant methods must contain no code except for a sequence of calls to the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> method, each of which specifies an individual invariant, as shown in the following example.","pos":[12722,12952],"source":" The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example."},{"content":"Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.","pos":[13133,13212]},{"content":"During run-time checking, invariants are checked at the end of each public method.","pos":[13213,13295]},{"content":"If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.","pos":[13296,13448]},{"content":"Instead, the check occurs only at the end of the outermost method call to that class.","pos":[13449,13534]},{"content":"This also happens if the class is re-entered because of a call to a method on another class.","pos":[13535,13627]},{"content":"Invariants are not checked for object finalizers or for any methods that implement the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[13628,13759],"source":" Invariants are not checked for object finalizers or for any methods that implement the <xref:System.IDisposable.Dispose%2A> method."},{"pos":[13803,13819],"content":"Usage Guidelines","linkify":"Usage Guidelines","nodes":[{"content":"Usage Guidelines","pos":[0,16]}]},{"pos":[13829,13846],"content":"Contract Ordering","linkify":"Contract Ordering","nodes":[{"content":"Contract Ordering","pos":[0,17]}]},{"content":"The following table shows the order of elements you should use when you write method contracts.","pos":[13850,13945]},{"content":"Backward-compatible public preconditions","pos":[13979,14019]},{"content":"All public preconditions.","pos":[14089,14114]},{"content":"All public (normal) postconditions.","pos":[14175,14210]},{"content":"All public exceptional postconditions.","pos":[14278,14316]},{"content":"All private/internal (normal) postconditions.","pos":[14377,14422]},{"content":"All private/internal exceptional postconditions.","pos":[14490,14538]},{"pos":[14608,14825],"content":"If using <ph id=\"ph1\">`if`</ph><ph id=\"ph2\">-</ph><ph id=\"ph3\">`then`</ph><ph id=\"ph4\">-</ph><ph id=\"ph5\">`throw`</ph> style preconditions without any other contracts, place a call to <ph id=\"ph6\">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> to indicate that all previous if checks are preconditions.","source":"If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions."},{"pos":[14861,14867],"content":"Purity","linkify":"Purity","nodes":[{"content":"Purity","pos":[0,6]}]},{"content":"All methods that are called within a contract must be pure; that is, they must not update any preexisting state.","pos":[14871,14983]},{"content":"A pure method is allowed to modify objects that have been created after entry into the pure method.","pos":[14984,15083]},{"content":"Code contract tools currently assume that the following code elements are pure:","pos":[15090,15169]},{"content":"Methods that are marked with the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.PureAttribute&gt;</ph>.","pos":[15179,15262],"source":"Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>."},{"content":"Types that are marked with the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.PureAttribute&gt;</ph> (the attribute applies to all the type's methods).","pos":[15272,15403],"source":"Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods)."},{"content":"Property get accessors.","pos":[15413,15436]},{"content":"Operators (static methods whose names start with \"op\", and that have one or two parameters and a non-void return type).","pos":[15446,15565]},{"content":"Any method whose fully qualified name begins with \"System.Diagnostics.Contracts.Contract\", \"System.String\", \"System.IO.Path\", or \"System.Type\".","pos":[15575,15718]},{"content":"Any invoked delegate, provided that the delegate type itself is attributed with the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.PureAttribute&gt;</ph>.","pos":[15728,15862],"source":"Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>."},{"content":"The delegate types <ph id=\"ph1\">&lt;xref:System.Predicate%601?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Comparison%601?displayProperty=fullName&gt;</ph> are considered pure.","pos":[15863,16013],"source":" The delegate types <xref:System.Predicate%601?displayProperty=fullName> and <xref:System.Comparison%601?displayProperty=fullName> are considered pure."},{"pos":[16052,16062],"content":"Visibility","linkify":"Visibility","nodes":[{"content":"Visibility","pos":[0,10]}]},{"content":"All members mentioned in a contract must be at least as visible as the method in which they appear.","pos":[16066,16165]},{"content":"For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.","pos":[16166,16322]},{"content":"However, if the field is marked with the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute&gt;</ph>, it is exempt from these rules.","pos":[16323,16467],"source":" However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules."},{"pos":[16476,16483],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows the use of code contracts.","pos":[16487,16541]}]}