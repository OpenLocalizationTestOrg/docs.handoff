{"content":"---\ntitle: \"Choosing Between Class and Struct\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"class library design guidelines [.NET Framework], structures\"\n  - \"class library design guidelines [.NET Framework], classes\"\n  - \"structures [.NET Framework], vs. classes\"\n  - \"classes [.NET Framework], design guidelines\"\n  - \"type design guidelines, structures\"\n  - \"structures [.NET Framework], design guidelines\"\n  - \"classes [.NET Framework], vs. structures\"\n  - \"type design guidelines, classes\"\nms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f\nauthor: \"KrzysztofCwalina\"\n---\n# Choosing Between Class and Struct\nOne of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type). Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.  \n  \n The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated. Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.  \n  \n Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap. Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type. Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays. In addition, in a majority of cases value type arrays exhibit much better locality of reference.  \n  \n The next difference is related to memory usage. Value types get boxed when cast to a reference type or one of the interfaces they implement. They get unboxed when cast back to the value type. Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.  In contrast, no such boxing occurs as reference types are cast. (For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).\n  \n Next, reference type assignments copy the reference, whereas value type assignments copy the entire value. Therefore, assignments of large reference types are cheaper than assignments of large value types.  \n  \n Finally, reference types are passed by reference, whereas value types are passed by value. Changes to an instance of a reference type affect all references pointing to the instance. Value type instances are copied when they are passed by value. When an instance of a value type is changed, it of course does not affect any of its copies. Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users. Therefore, value types should be immutable.  \n  \n As a rule of thumb, the majority of types in a framework should be classes. There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.  \n  \n **✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.  \n  \n **X AVOID** defining a struct unless the type has all of the following characteristics:  \n  \n-   It logically represents a single value, similar to primitive types (`int`, `double`, etc.).  \n  \n-   It has an instance size under 16 bytes.  \n  \n-   It is immutable.  \n  \n-   It will not have to be boxed frequently.  \n  \n In all other cases, you should define your types as classes.  \n  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See also\n\n- [Type Design Guidelines](../../../docs/standard/design-guidelines/type.md)\n- [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)\n","nodes":[{"pos":[4,604],"embed":true,"restype":"x-metadata","content":"title: \"Choosing Between Class and Struct\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"class library design guidelines [.NET Framework], structures\"\n  - \"class library design guidelines [.NET Framework], classes\"\n  - \"structures [.NET Framework], vs. classes\"\n  - \"classes [.NET Framework], design guidelines\"\n  - \"type design guidelines, structures\"\n  - \"structures [.NET Framework], design guidelines\"\n  - \"classes [.NET Framework], vs. structures\"\n  - \"type design guidelines, classes\"\nms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f\nauthor: \"KrzysztofCwalina\"","nodes":[{"content":"Choosing Between Class and Struct","nodes":[{"pos":[0,33],"content":"Choosing Between Class and Struct","nodes":[{"content":"Choosing Between Class and Struct","pos":[0,33]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[611,644],"content":"Choosing Between Class and Struct","linkify":"Choosing Between Class and Struct","nodes":[{"content":"Choosing Between Class and Struct","pos":[0,33]}]},{"content":"One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).","pos":[645,798]},{"content":"Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.","pos":[799,921]},{"content":"The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.","pos":[928,1249]},{"content":"Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.","pos":[1250,1383]},{"content":"Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.","pos":[1390,1552]},{"content":"Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.","pos":[1553,1668]},{"content":"Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.","pos":[1669,1808]},{"content":"In addition, in a majority of cases value type arrays exhibit much better locality of reference.","pos":[1809,1905]},{"content":"The next difference is related to memory usage.","pos":[1912,1959]},{"content":"Value types get boxed when cast to a reference type or one of the interfaces they implement.","pos":[1960,2052]},{"content":"They get unboxed when cast back to the value type.","pos":[2053,2103]},{"content":"Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.","pos":[2104,2330]},{"content":"In contrast, no such boxing occurs as reference types are cast.","pos":[2332,2395]},{"content":"(For more information, see <bpt id=\"p1\">[</bpt>Boxing and Unboxing<ept id=\"p1\">](../../csharp/programming-guide/types/boxing-and-unboxing.md)</ept>).","pos":[2396,2507],"source":" (For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md))."},{"content":"Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.","pos":[2512,2618]},{"content":"Therefore, assignments of large reference types are cheaper than assignments of large value types.","pos":[2619,2717]},{"content":"Finally, reference types are passed by reference, whereas value types are passed by value.","pos":[2724,2814]},{"content":"Changes to an instance of a reference type affect all references pointing to the instance.","pos":[2815,2905]},{"content":"Value type instances are copied when they are passed by value.","pos":[2906,2968]},{"content":"When an instance of a value type is changed, it of course does not affect any of its copies.","pos":[2969,3061]},{"content":"Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.","pos":[3062,3267]},{"content":"Therefore, value types should be immutable.","pos":[3268,3311]},{"content":"As a rule of thumb, the majority of types in a framework should be classes.","pos":[3318,3393]},{"content":"There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.","pos":[3394,3515]},{"pos":[3522,3676],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.","source":"**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects."},{"pos":[3683,3770],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> defining a struct unless the type has all of the following characteristics:","source":"**X AVOID** defining a struct unless the type has all of the following characteristics:"},{"pos":[3780,3871],"content":"It logically represents a single value, similar to primitive types (<ph id=\"ph1\">`int`</ph>, <ph id=\"ph2\">`double`</ph>, etc.).","source":"It logically represents a single value, similar to primitive types (`int`, `double`, etc.)."},{"content":"It has an instance size under 16 bytes.","pos":[3881,3920]},{"content":"It is immutable.","pos":[3930,3946]},{"content":"It will not have to be boxed frequently.","pos":[3956,3996]},{"content":"In all other cases, you should define your types as classes.","pos":[4003,4063]},{"pos":[4070,4137],"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[4144,4549],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[4558,4566],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4570,4644],"content":"<bpt id=\"p1\">[</bpt>Type Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/type.md)</ept>","source":"[Type Design Guidelines](../../../docs/standard/design-guidelines/type.md)"},{"pos":[4647,4727],"content":"<bpt id=\"p1\">[</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept>","source":"[Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)"}]}