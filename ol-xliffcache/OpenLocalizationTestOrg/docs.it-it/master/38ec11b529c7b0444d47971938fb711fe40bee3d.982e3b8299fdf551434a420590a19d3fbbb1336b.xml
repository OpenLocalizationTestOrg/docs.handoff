{"content":"---\ntitle: \"Migrating from .NET Remoting to WCF\"\nms.date: \"03/30/2017\"\nms.assetid: 16902a42-ef80-40e9-8c4c-90e61ddfdfe5\n---\n# Migrating from .NET Remoting to WCF\nThis article describes how to migrate an application that uses .NET Remoting to use Windows Communication Foundation (WCF). It compares similar concepts between these products and then describes how to accomplish several common Remoting scenarios in WCF.  \n  \n .NET Remoting is a legacy product that is supported only for backward compatibility. It is not secure across mixed-trust environments because it cannot maintain the separate trust levels between client and server. For example, you should never expose a .NET Remoting endpoint to the Internet or to untrusted clients. We recommend existing Remoting applications be migrated to newer and more secure technologies. If the application’s design uses only HTTP and is RESTful, we recommend ASP.NET Web API. For more information, see ASP.NET Web API. If the application is based on SOAP or requires non-Http protocols such as TCP, we recommend WCF.  \n\n## Comparing .NET Remoting to WCF  \n This section compares the basic building blocks of .NET Remoting with their WCF equivalents. We will use these building blocks later to create some common client-server scenarios in WCF.The following chart summarizes the main similarities and differences between .NET Remoting and WCF.  \n  \n||.NET Remoting|WCF|  \n|-|-------------------|---------|  \n|Server type|Subclass MarshalByRefObject|Mark with [ServiceContract] attribute|  \n|Service operations|Public methods on server type|Mark with [OperationContract] attribute|  \n|Serialization|ISerializable or [Serializable]|DataContractSerializer or XmlSerializer|  \n|Objects passed|By-value or by-reference|By-value only|  \n|Errors/exceptions|Any serializable exception|FaultContract\\<TDetail>|  \n|Client proxy objects|Strongly typed transparent proxies are created automatically from MarshalByRefObjects|Strongly typed proxies are generated on-demand using ChannelFactory\\<TChannel>|  \n|Platform required|Both client and server must use Microsoft OS and .NET|Cross-platform|  \n|Message format|Private|Industry standards (SOAP, WS-*, etc.)|  \n  \n### Server Implementation Comparison  \n  \n#### Creating a Server in .NET Remoting  \n .NET Remoting server types must derive from MarshalByRefObject and define methods the client can call, like the following:  \n  \n```csharp\npublic class RemotingServer : MarshalByRefObject  \n{  \n    public Customer GetCustomer(int customerId) { … }  \n}  \n```  \n  \n The public methods of this server type become the public contract available to clients.  There is no separation between the server’s public interface and its implementation – one type handles both.  \n  \n Once the server type has been defined, it can be made available to clients, like in the following example:  \n  \n```csharp\nTcpChannel channel = new TcpChannel(8080);  \nChannelServices.RegisterChannel(channel, ensureSecurity : true);  \nRemotingConfiguration.RegisterWellKnownServiceType(  \n    typeof(RemotingServer),   \n    \"RemotingServer\",   \n    WellKnownObjectMode.Singleton);  \nConsole.WriteLine(\"RemotingServer is running.  Press ENTER to terminate...\");  \nConsole.ReadLine();  \n```  \n  \n There are many ways to make the Remoting type available as a server, including using configuration files. This is just one example.  \n  \n#### Creating a Server in WCF  \n The equivalent step in WCF involves creating two types -- the public \"service contract\" and the concrete implementation. The first is declared as an interface marked with [ServiceContract]. Methods available to clients are marked with [OperationContract]:  \n  \n```csharp\n[ServiceContract]  \npublic interface IWCFServer  \n{  \n    [OperationContract]  \n    Customer GetCustomer(int customerId);  \n}  \n```  \n  \n The server’s implementation is defined in a separate concrete class, like in the following example:  \n  \n```csharp\npublic class WCFServer : IWCFServer  \n{  \n    public Customer GetCustomer(int customerId) { … }  \n}  \n```  \n  \n Once these types have been defined, the WCF server can be made available to clients, like in the following example:  \n  \n```csharp\nNetTcpBinding binding = new NetTcpBinding();  \nUri baseAddress = new Uri(\"net.tcp://localhost:8000/wcfserver\");  \n  \nusing (ServiceHost serviceHost = new ServiceHost(typeof(WCFServer), baseAddress))  \n{  \n    serviceHost.AddServiceEndpoint(typeof(IWCFServer), binding, baseAddress);  \n    serviceHost.Open();  \n  \n    Console.WriteLine($\"The WCF server is ready at {baseAddress}.\");\n    Console.WriteLine(\"Press <ENTER> to terminate service...\");  \n    Console.WriteLine();  \n    Console.ReadLine();  \n}  \n```  \n  \n> [!NOTE]\n>  TCP is used in both examples to keep them as similar as possible. Refer to the scenario walk-throughs later in this topic for examples using HTTP.  \n  \n There are many ways to configure and to host WCF services. This is just one example, known as \"self-hosted\". For more information, see the following topics:  \n  \n-   [How to: Define a Service Contract](how-to-define-a-wcf-service-contract.md)  \n  \n-   [Configuring Services Using Configuration Files](configuring-services-using-configuration-files.md)  \n  \n-   [Hosting Services](hosting-services.md)  \n  \n### Client Implementation Comparison  \n  \n#### Creating a Client in .NET Remoting  \n Once a .NET Remoting server object has been made available, it can be consumed by clients, like in the following example:  \n  \n```csharp\nTcpChannel channel = new TcpChannel();  \nChannelServices.RegisterChannel(channel, ensureSecurity : true);  \nRemotingServer server = (RemotingServer)Activator.GetObject(  \n                            typeof(RemotingServer),   \n                            \"tcp://localhost:8080/RemotingServer\");  \n  \nRemotingCustomer customer = server.GetCustomer(42);  \nConsole.WriteLine($\"Customer {customer.FirstName} {customer.LastName} received.\");\n```  \n  \n The RemotingServer instance returned from Activator.GetObject() is known as a \"transparent proxy.\" It implements the public API for the RemotingServer type on the client, but all the methods call the server object running in a different process or machine.  \n  \n#### Creating a Client in WCF  \n The equivalent step in WCF involves using a channel factory to create the proxy explicitly. Like Remoting, the proxy object can be used to invoke operations on the server, like in the following example:  \n  \n```csharp\nNetTcpBinding binding = new NetTcpBinding();  \nString url = \"net.tcp://localhost:8000/wcfserver\";  \nEndpointAddress address = new EndpointAddress(url);  \nChannelFactory<IWCFServer> channelFactory =   \n    new ChannelFactory<IWCFServer>(binding, address);  \nIWCFServer server = channelFactory.CreateChannel();  \n  \nCustomer customer = server.GetCustomer(42);  \nConsole.WriteLine($\"  Customer {customer.FirstName} {customer.LastName} received.\");\n```  \n  \n This example shows programming at the channel level because it is most similar to the Remoting example. Also available is the **Add Service Reference** approach in Visual Studio that generates code to simplify client programming. For more information, see the following topics:  \n  \n-   [Client Channel-Level Programming](./extending/client-channel-level-programming.md)  \n  \n-   [How to: Add, Update, or Remove a Service Reference](/visualstudio/data-tools/how-to-add-update-or-remove-a-wcf-data-service-reference)  \n  \n### Serialization Usage  \n Both .NET Remoting and WCF use serialization to send objects between client and server, but they differ in these important ways:  \n  \n1.  They use different serializers and conventions to indicate what to serialize.  \n  \n2.  .NET Remoting supports \"by reference\" serialization that allows method or property access on one tier to execute code on the other tier, which is across security boundaries. This capability exposes security vulnerabilities and is one of the main reasons why Remoting endpoints should never be exposed to untrusted clients.  \n  \n3.  Serialization used by Remoting is opt-out (explicitly exclude what not to serialize) and WCF serialization is opt-in (explicitly mark which members to serialize).  \n  \n#### Serialization in .NET Remoting  \n .NET Remoting supports two ways to serialize and deserialize objects between the client and server:  \n  \n-   *By value* – the values of the object are serialized across tier boundaries, and a new instance of that object is created on the other tier. Any calls to methods or properties of that new instance execute only locally and do not affect the original object or tier.  \n  \n-   *By reference* – a special \"object reference\" is serialized across tier boundaries. When one tier interacts with methods or properties of that object, it communicates back to the original object on the original tier. By-reference objects can flow in either direction – server to client, or client to server.  \n  \n By-value types in Remoting are marked with the [Serializable] attribute or implement ISerializable, like in the following example:  \n  \n```csharp\n[Serializable]  \npublic class RemotingCustomer  \n{  \n    public string FirstName { get; set; }  \n    public string LastName { get; set; }  \n    public int CustomerId { get; set; }  \n}  \n```  \n  \n By-reference types derive from the MarshalByRefObject class, like in the following example:  \n  \n```csharp\npublic class RemotingCustomerReference : MarshalByRefObject  \n{  \n    public string FirstName { get; set; }  \n    public string LastName { get; set; }  \n    public int CustomerId { get; set; }  \n}  \n```  \n  \n It is extremely important to understand the implications of Remoting’s by-reference objects. If either tier (client or server) sends a by-reference object to the other tier, all method calls execute back on the tier owning the object. For example, a client calling methods on a by-reference object returned by the server will execute code on the server. Similarly, a server calling methods on a by-reference object provided by the client will execute code back on the client. For this reason, the use of .NET Remoting is recommended only within fully-trusted environments. Exposing a public .NET Remoting endpoint to untrusted clients will make a Remoting server vulnerable to attack.  \n  \n#### Serialization in WCF  \n WCF supports only by-value serialization. The most common way to define a type to exchange between client and server is like in the following example:  \n  \n```csharp\n[DataContract]  \npublic class WCFCustomer  \n{  \n    [DataMember]  \n    public string FirstName { get; set; }  \n  \n    [DataMember]  \n    public string LastName { get; set; }  \n  \n    [DataMember]  \n    public int CustomerId { get; set; }  \n}  \n```  \n  \n The [DataContract] attribute identifies this type as one that can be serialized and deserialized between client and server. The [DataMember] attribute identifies the individual properties or fields to serialize.  \n  \n When WCF sends an object across tiers, it serializes only the values and creates a new instance of the object on the other tier. Any interactions with the values of the object occur only locally – they do not communicate with the other tier the way .NET Remoting by-reference objects do. For more information, see [Serialization and Deserialization](./feature-details/serialization-and-deserialization.md).  \n  \n### Exception Handling Capabilities  \n  \n#### Exceptions in .NET Remoting  \n Exceptions thrown by a Remoting server are serialized, sent to the client, and thrown locally on the client like any other exception. Custom exceptions can be created by sub-classing the Exception type and marking it with [Serializable].   Most framework exceptions are already marked in this way, allowing most to be thrown by the server, serialized, and re-thrown on the client. Though this design is convenient during development, server-side information can inadvertently be disclosed to the client. This is one of many reasons Remoting should be used only in fully-trusted environments.  \n  \n#### Exceptions and Faults in WCF  \n WCF does not allow arbitrary exception types to be returned from the server to the client because it could lead to inadvertent information disclosure. If a service operation throws an unexpected exception, it causes a general purpose FaultException to be thrown on the client. This exception does not carry any information why or where the problem occurred, and for some applications this is sufficient. Applications that need to communicate richer error information to the client do this by defining a fault contract.  \n  \n To do this, first create a [DataContract] type to carry the fault information.  \n  \n```csharp\n[DataContract]  \npublic class CustomerServiceFault  \n{  \n    [DataMember]  \n    public string ErrorMessage { get; set; }  \n  \n    [DataMember]  \n    public int CustomerId {get;set;}  \n}  \n```  \n  \n Specify the fault contract to use for each service operation.  \n  \n```csharp\n[ServiceContract]  \npublic interface IWCFServer  \n{  \n    [OperationContract]  \n    [FaultContract(typeof(CustomerServiceFault))]  \n    Customer GetCustomer(int customerId);  \n}  \n```  \n  \n The server reports error conditions by throwing a FaultException.  \n  \n```csharp\nthrow new FaultException<CustomerServiceFault>(  \n    new CustomerServiceFault() {   \n        CustomerId = customerId,   \n        ErrorMessage = \"Illegal customer Id\"   \n    });  \n```  \n  \n And whenever the client makes a request to the server, it can catch faults as normal exceptions.  \n  \n```csharp\ntry  \n{  \n    Customer customer = server.GetCustomer(-1);  \n}  \ncatch (FaultException<CustomerServiceFault> fault)  \n{  \n    Console.WriteLine($\"Fault received: {fault.Detail.ErrorMessage}\");\n}  \n```  \n  \n For more information about fault contracts, see <xref:System.ServiceModel.FaultException>.  \n  \n### Security Considerations  \n  \n#### Security in .NET Remoting  \n Some .NET Remoting channels support security features such as authentication and encryption at the channel layer (IPC and TCP). The HTTP channel relies on Internet Information Services (IIS) for both authentication and encryption. Despite this support, you should consider .NET Remoting an unsecure communication protocol and use it only within fully-trusted environments. Never expose a public Remoting endpoint to the Internet or untrusted clients.  \n  \n#### Security in WCF  \n WCF was designed with security in mind, in part to address the kinds of vulnerabilities found in .NET Remoting. WCF offers security at both the transport and message level, and offers many options for authentication, authorization, encryption, and so on. For more information, see the following topics:  \n  \n-   [Security](./feature-details/security.md)  \n  \n-   [WCF Security Guidance](./feature-details/security-guidance-and-best-practices.md)  \n  \n## Migrating to WCF  \n  \n### Why Migrate from Remoting to WCF?  \n  \n-   **.NET Remoting is a legacy product.** As described in [.NET Remoting](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507%28v=vs.100%29), it is considered a legacy product and is not recommended for new development. WCF or ASP.NET Web API are recommended for new and existing applications.  \n  \n-   **WCF uses cross-platform standards.** WCF was designed with cross-platform interoperability in mind and supports many industry standards (SOAP, WS-Security, WS-Trust, etc.). A WCF service can interoperate with clients running on operating systems other than Windows. Remoting was designed primarily for environments where both the server and client applications run using the .NET framework on a Windows operating system.  \n  \n-   **WCF has built-in security.** WCF was designed with security in mind and offers many options for authentication, transport level security, message level security, etc. Remoting was designed to make it easy for applications to interoperate but was not designed to be secure in non-trusted environments. WCF was designed to work in both trusted and non-trusted environments.  \n  \n### Migration Recommendations  \n The following are the recommended steps to migrate from .NET Remoting to WCF:  \n  \n-   **Create the service contract.** Define your service interface types, and mark them with the [ServiceContract] attribute.Mark all the methods the clients will be allowed to call with [OperationContract].  \n  \n-   **Create the data contract.** Define the data types that will be exchanged between server and client, and mark them with the [DataContract] attribute. Mark all the fields and properties the client will be allowed to use with [DataMember].  \n  \n-   **Create the fault contract (optional).** Create the types that will be exchanged between server and client when errors are encountered. Mark these types with [DataContract] and [DataMember] to make them serializable. For all service operations you marked with [OperationContract], also mark them with [FaultContract] to indicate which errors they may return.  \n  \n-   **Configure and host the service.** Once the service contract has been created, the next step is to configure a binding to expose the service at an endpoint. For more information, see [Endpoints: Addresses, Bindings, and Contracts](./feature-details/endpoints-addresses-bindings-and-contracts.md).  \n  \n Once a Remoting application has been migrated to WCF, it is still important to remove dependencies on .NET Remoting. This ensures that any Remoting vulnerabilities are removed from the application. These steps include the following:  \n  \n-   **Discontinue use of MarshalByRefObject.** The MarshalByRefObject type exists only for Remoting and is not used by WCF. Any application types that sub-class MarshalByRefObject should be removed or changed.  \n  \n-   **Discontinue use of [Serializable] and ISerializable.** The [Serializable] attribute and ISerializable interface were originally designed to serialize types within trusted environments, and they are used by Remoting. WCF serialization relies on types being marked with [DataContract] and [DataMember]. Data types used by an application should be modified to use [DataContract] and not to use ISerializable or [Serializable].  \n  \n### Migration Scenarios  \n Now let’s see how to accomplish the following common Remoting scenarios in WCF:  \n  \n1.  Server returns an object by-value to the client  \n  \n2.  Server returns an object by-reference to the client  \n  \n3.  Client sends an object by-value to the server  \n  \n> [!NOTE]\n>  Sending an object by-reference from the client to the server is not allowed in WCF.  \n  \n When reading through these scenarios, assume our baseline interfaces for .NET Remoting look like the following example. The .NET Remoting implementation is not important here because we want to illustrate only how to use WCF to implement equivalent functionality.  \n  \n```csharp\npublic class RemotingServer : MarshalByRefObject  \n{  \n    // Demonstrates server returning object by-value  \n    public Customer GetCustomer(int customerId) {…}  \n  \n    // Demonstrates server returning object by-reference  \n    public CustomerReference GetCustomerReference(int customerId) {…}  \n  \n    // Demonstrates client passing object to server by-value  \n    public bool UpdateCustomer(Customer customer) {…}  \n}  \n```  \n  \n#### Scenario 1: Service Returns an Object by Value  \n This scenario demonstrates a server returning an object to the client by value. WCF always returns objects from the server by value, so the following steps simply describe how to build a normal WCF service.  \n  \n1.  Start by defining a public interface for the WCF service and mark it with the [ServiceContract] attribute. We use [OperationContract] to identify the server-side methods our client will call.  \n  \n   ```csharp\n   [ServiceContract]  \n   public interface ICustomerService  \n   {  \n       [OperationContract]  \n       Customer GetCustomer(int customerId);  \n  \n       [OperationContract]  \n       bool UpdateCustomer(Customer customer);  \n   }  \n   ```  \n  \n2.  The next step is to create the data contract for this service. We do this by creating classes (not interfaces) marked with the [DataContract] attribute. The individual properties or fields we want visible to both client and server are marked with [DataMember]. If we want derived types to be allowed, we must use the [KnownType] attribute to identify them. The only types WCF will allow to be serialized or deserialized for this service are those in the service interface and these \"known types\". Attempting to exchange any other type not in this list will be rejected.  \n  \n   ```csharp\n   [DataContract]  \n   [KnownType(typeof(PremiumCustomer))]  \n   public class Customer  \n   {  \n       [DataMember]  \n       public string FirstName { get; set; }  \n  \n       [DataMember]  \n       public string LastName { get; set; }  \n  \n       [DataMember]  \n       public int CustomerId { get; set; }  \n   }  \n  \n   [DataContract]  \n   public class PremiumCustomer : Customer   \n   {  \n       [DataMember]  \n       public int AccountId { get; set; }  \n   }  \n   ```  \n  \n3.  Next, we provide the implementation for the service interface.  \n  \n   ```csharp  \n   public class CustomerService : ICustomerService  \n   {  \n       public Customer GetCustomer(int customerId)  \n       {  \n           // read from database  \n       }  \n  \n       public bool UpdateCustomer(Customer customer)  \n       {  \n           // write to database  \n       }  \n   }  \n   ```  \n  \n4.  To run the WCF service, we need to declare an endpoint that exposes that service interface at a specific URL using a specific WCF binding. This is typically done by adding the following sections to the server project’s web.config file.  \n  \n    ```xml  \n    <configuration>  \n      <system.serviceModel>  \n        <services>  \n          <service name=\"Server.CustomerService\">  \n            <endpoint address=\"http://localhost:8083/CustomerService\"  \n                      binding=\"basicHttpBinding\"  \n                      contract=\"Shared.ICustomerService\" />  \n          </service>  \n        </services>  \n      </system.serviceModel>  \n    </configuration>  \n    ```  \n  \n5.  The WCF service can then be started with the following code:  \n  \n   ```csharp\n   ServiceHost customerServiceHost = new ServiceHost(typeof(CustomerService));  \n       customerServiceHost.Open();  \n   ```  \n  \n     When this ServiceHost is started, it uses the web.config file to establish the proper contract, binding and endpoint. For more information about configuration files, see [Configuring Services Using Configuration Files](./configuring-services-using-configuration-files.md). This style of starting the server is known as self-hosting. To learn more about other choices for hosting WCF services, see [Hosting Services](./hosting-services.md).  \n  \n6.  The client project’s app.config must declare matching binding information for the service’s endpoint. The easiest way to do this in Visual Studio is to use **Add Service Reference**, which will automatically update the app.config file. Alternatively, these same changes can be added manually.  \n  \n    ```xml  \n    <configuration>  \n      <system.serviceModel>  \n        <client>  \n          <endpoint name=\"customerservice\"  \n                    address=\"http://localhost:8083/CustomerService\"  \n                    binding=\"basicHttpBinding\"  \n                    contract=\"Shared.ICustomerService\"/>  \n        </client>  \n      </system.serviceModel>  \n    </configuration>  \n    ```  \n  \n     For more information about using **Add Service Reference**, see [How to: Add, Update, or Remove a Service Reference](/visualstudio/data-tools/how-to-add-update-or-remove-a-wcf-data-service-reference).  \n  \n7.  Now we can call the WCF service from the client. We do this by creating a channel factory for that service, asking it for a channel, and directly calling the method we want on that channel. We can do this because the channel implements the service’s interface and handles the underlying request/reply logic for us. The return value from that method call is the deserialized copy of the server’s response.  \n  \n   ```csharp\n   ChannelFactory<ICustomerService> factory =  \n       new ChannelFactory<ICustomerService>(\"customerservice\");  \n   ICustomerService service = factory.CreateChannel();  \n   Customer customer = service.GetCustomer(42);  \n   Console.WriteLine($\"  Customer {customer.FirstName} {customer.LastName} received.\");\n   ```  \n  \n Objects returned by WCF from the server to the client are always by value. The objects are deserialized copies of the data sent by the server. The client can call methods on these local copies without any danger of invoking server code through callbacks.  \n  \n#### Scenario 2: Server Returns an Object By Reference  \n This scenario demonstrates the server providing an object to the client by reference. In .NET Remoting, this is handled automatically for any type derived from MarshalByRefObject, which is serialized by-reference. An example of this scenario is allowing multiple clients to have independent sessionful server-side objects. As previously mentioned, objects returned by a WCF service are always by value, so there is no direct equivalent of a by-reference object, but it is possible to achieve something similar to by-reference semantics using an <xref:System.ServiceModel.EndpointAddress10> object. This is a serializable by-value object that can be used by the client to obtain a sessionful by-reference object on the server. This enables the scenario of having multiple clients with independent sessionful server-side objects.  \n  \n1.  First, we need to define a WCF service contract that corresponds to the sessionful object itself.  \n  \n   ```csharp\n   [ServiceContract(SessionMode = SessionMode.Allowed)]  \n       public interface ISessionBoundObject  \n       {  \n           [OperationContract]  \n           string GetCurrentValue();  \n  \n           [OperationContract]  \n           void SetCurrentValue(string value);  \n       }  \n   ```  \n  \n    > [!TIP]\n    >  Notice that the sessionful object is marked with [ServiceContract], making it a normal WCF service interface. Setting the SessionMode property indicates it will be a sessionful service. In WCF, a session is a way of correlating multiple messages sent between two endpoints. This means that once a client obtains a connection to this service, a session will be established between the client and the server. The client will use a single unique instance of the server-side object for all its interactions within this single session.  \n  \n2.  Next, we need to provide the implementation of this service interface. By denoting it with [ServiceBehavior] and setting the InstanceContextMode, we tell WCF we want to use a unique instance of this type for an each session.  \n  \n   ```csharp\n   [ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]  \n       public class MySessionBoundObject : ISessionBoundObject  \n       {  \n           private string _value;  \n  \n           public string GetCurrentValue()  \n           {  \n               return _value;  \n           }  \n  \n           public void SetCurrentValue(string val)  \n           {  \n               _value = val;  \n           }  \n  \n       }  \n   ```  \n  \n3.  Now we need a way to obtain an instance of this sessionful object. We do this by creating another WCF service interface that returns an EndpointAddress10 object. This is a serializable form of an endpoint that the client can use to create the sessionful object.  \n  \n   ```csharp\n   [ServiceContract]  \n       public interface ISessionBoundFactory  \n       {  \n           [OperationContract]  \n           EndpointAddress10 GetInstanceAddress();  \n       }  \n   ```  \n  \n     And we implement this WCF service:  \n  \n   ```csharp\n   public class SessionBoundFactory : ISessionBoundFactory  \n       {  \n           public static ChannelFactory<ISessionBoundObject> _factory =   \n               new ChannelFactory<ISessionBoundObject>(\"sessionbound\");  \n \n           public SessionBoundFactory()  \n           {  \n           }  \n  \n           public EndpointAddress10 GetInstanceAddress()  \n           {  \n               IClientChannel channel = (IClientChannel)_factory.CreateChannel();  \n               return EndpointAddress10.FromEndpointAddress(channel.RemoteAddress);  \n           }  \n       }  \n   ```  \n  \n     This implementation maintains a singleton channel factory to create sessionful objects. When GetInstanceAddress() is called, it creates a channel and creates an EndpointAddress10 object that effectively points to the remote address associated with this channel. EndpointAddress10 is simply a data type that can be returned to the client by-value.  \n  \n4.  We need to modify the server’s configuration file by doing the following two things as shown in the example below:  \n  \n    1.  Declare a \\<client> section that describes the endpoint for the sessionful object. This is necessary because the server also acts as a client in this situation.  \n  \n    2.  Declare endpoints for the factory and sessionful object. This is necessary to allow the client to communicate with the service endpoints to acquire the EndpointAddress10 and to create the sessionful channel.  \n  \n    ```xml  \n    <configuration>  \n      <system.serviceModel>  \n         <client>  \n          <endpoint name=\"sessionbound\"  \n                    address=\"net.tcp://localhost:8081/SessionBoundObject\"  \n                    binding=\"netTcpBinding\"  \n                    contract=\"Shared.ISessionBoundObject\"/>  \n        </client>  \n        <services>  \n          <service name=\"Server.CustomerService\">  \n            <endpoint address=\"http://localhost:8083/CustomerService\"  \n                      binding=\"basicHttpBinding\"  \n                      contract=\"Shared.ICustomerService\" />  \n          </service>  \n          <service name=\"Server.MySessionBoundObject\">  \n            <endpoint address=\"net.tcp://localhost:8081/SessionBoundObject\"  \n                      binding=\"netTcpBinding\"  \n                      contract=\"Shared.ISessionBoundObject\" />  \n          </service>  \n          <service name=\"Server.SessionBoundFactory\">  \n            <endpoint address=\"net.tcp://localhost:8081/SessionBoundFactory\"  \n                      binding=\"netTcpBinding\"  \n                      contract=\"Shared.ISessionBoundFactory\" />  \n          </service>  \n        </services>  \n      </system.serviceModel>  \n    </configuration>  \n    ```  \n  \n     And then we can start these services:  \n  \n   ```csharp\n   ServiceHost factoryHost = new ServiceHost(typeof(SessionBoundFactory));  \n   factoryHost.Open();  \n  \n   ServiceHost sessionHost = new ServiceHost(typeof(MySessionBoundObject));  \n   sessionHost.Open();  \n   ```  \n  \n5.  We configure the client by declaring these same endpoints in its project’s app.config file.  \n  \n    ```xml  \n    <configuration>  \n      <system.serviceModel>  \n        <client>  \n          <endpoint name=\"customerservice\"  \n                    address=\"http://localhost:8083/CustomerService\"  \n                    binding=\"basicHttpBinding\"  \n                    contract=\"Shared.ICustomerService\"/>  \n          <endpoint name=\"sessionbound\"  \n                    address=\"net.tcp://localhost:8081/SessionBoundObject\"  \n                    binding=\"netTcpBinding\"  \n                    contract=\"Shared.ISessionBoundObject\"/>  \n          <endpoint name=\"factory\"  \n                    address=\"net.tcp://localhost:8081/SessionBoundFactory\"  \n                    binding=\"netTcpBinding\"  \n                    contract=\"Shared.ISessionBoundFactory\"/>  \n        </client>  \n      </system.serviceModel>  \n    </configuration>  \n    ```  \n  \n6.  In order to create and use this sessionful object, the client must do the following steps:  \n  \n    1.  Create a channel to the ISessionBoundFactory service.  \n  \n    2.  Use that channel to invoke that service to obtain an EndpointAddress10.  \n  \n    3.  Use the EndpointAddress10 to create a channel to obtain a sessionful object.  \n  \n    4.  Interact with the sessionful object to demonstrate it remains the same instance across multiple calls.  \n  \n   ```csharp\n   ChannelFactory<ISessionBoundFactory> channelFactory =   \n       new ChannelFactory<ISessionBoundFactory>(\"factory\");  \n   ISessionBoundFactory sessionFactory = channelFactory.CreateChannel();  \n  \n   EndpointAddress10 address1 = sessionFactory.GetInstanceAddress();  \n   EndpointAddress10 address2 = sessionFactory.GetInstanceAddress();  \n  \n   ChannelFactory<ISessionBoundObject> sessionObjectFactory1 =   \n       new ChannelFactory<ISessionBoundObject>(new NetTcpBinding(),   \n                                               address1.ToEndpointAddress());  \n   ChannelFactory<ISessionBoundObject> sessionObjectFactory2 =   \n       new ChannelFactory<ISessionBoundObject>(new NetTcpBinding(),   \n                                               address2.ToEndpointAddress());  \n  \n   ISessionBoundObject sessionInstance1 = sessionObjectFactory1.CreateChannel();  \n   ISessionBoundObject sessionInstance2 = sessionObjectFactory2.CreateChannel();  \n  \n   sessionInstance1.SetCurrentValue(\"Hello\");  \n   sessionInstance2.SetCurrentValue(\"World\");  \n  \n   if (sessionInstance1.GetCurrentValue() == \"Hello\" &&  \n       sessionInstance2.GetCurrentValue() == \"World\")  \n   {  \n       Console.WriteLine(\"sessionful server object works as expected\");  \n   }  \n   ```  \n  \n WCF always returns objects by value, but it is possible to support the equivalent of by-reference semantics through the use of EndpointAddress10. This permits the client to request a sessionful WCF service instance, after which it can interact with it like any other WCF service.  \n  \n#### Scenario 3: Client Sends Server a By-Value Instance  \n This scenario demonstrates the client sending a non-primitive object instance to the server by value. Because WCF only sends objects by value, this scenario demonstrates normal WCF usage.  \n  \n1.  Use the same WCF Service from Scenario 1.  \n  \n2.  Use the client to create a new by-value object (Customer), create a channel to communicate with the ICustomerService service, and send the object to it.  \n  \n   ```csharp\n   ChannelFactory<ICustomerService> factory =  \n       new ChannelFactory<ICustomerService>(\"customerservice\");  \n   ICustomerService service = factory.CreateChannel();  \n   PremiumCustomer customer = new PremiumCustomer {   \n   FirstName = \"Bob\",   \n   LastName = \"Jones\",   \n   CustomerId = 43,   \n   AccountId = 99};  \n   bool success = service.UpdateCustomer(customer);  \n   Console.WriteLine($\"  Server returned {success}.\");\n   ```  \n  \n     The customer object will be serialized, and sent to the server, where it is deserialized into a new copy of that object.  \n  \n    > [!NOTE]\n    >  This code also illustrates sending a derived type (PremiumCustomer). The service interface expects a Customer object, but the [KnownType] attribute on the Customer class indicated PremiumCustomer was also allowed. WCF will fail any attempt to serialize or deserialize any other type through this service interface.  \n  \n Normal WCF exchanges of data are by value. This guarantees that invoking methods on one of these data objects executes only locally – it will not invoke code on the other tier. While it is possible to achieve something like by-reference objects returned *from* the server, it is not possible for a client to pass a by-reference object *to* the server. A scenario that requires a conversation back and forth between client and server can be achieved in WCF using a duplex service. For more information, see [Duplex Services](./feature-details/duplex-services.md).  \n  \n## Summary  \n .NET Remoting is a communication framework intended to be used only within fully-trusted environments. It is a legacy product and supported only for backward compatibility. It should not be used to build new applications. Conversely, WCF was designed with security in mind and is recommended for new and existing applications. Microsoft recommends that existing Remoting applications be migrated to use WCF or ASP.NET Web API instead.\n","nodes":[{"pos":[4,119],"embed":true,"restype":"x-metadata","content":"title: \"Migrating from .NET Remoting to WCF\"\nms.date: \"03/30/2017\"\nms.assetid: 16902a42-ef80-40e9-8c4c-90e61ddfdfe5","nodes":[{"content":"Migrating from .NET Remoting to WCF","nodes":[{"pos":[0,35],"content":"Migrating from .NET Remoting to WCF","nodes":[{"content":"Migrating from .NET Remoting to WCF","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[126,161],"content":"Migrating from .NET Remoting to WCF","linkify":"Migrating from .NET Remoting to WCF","nodes":[{"content":"Migrating from .NET Remoting to WCF","pos":[0,35]}]},{"content":"This article describes how to migrate an application that uses .NET Remoting to use Windows Communication Foundation (WCF).","pos":[162,285]},{"content":"It compares similar concepts between these products and then describes how to accomplish several common Remoting scenarios in WCF.","pos":[286,416]},{"content":".NET Remoting is a legacy product that is supported only for backward compatibility.","pos":[423,507]},{"content":"It is not secure across mixed-trust environments because it cannot maintain the separate trust levels between client and server.","pos":[508,636]},{"content":"For example, you should never expose a .NET Remoting endpoint to the Internet or to untrusted clients.","pos":[637,739]},{"content":"We recommend existing Remoting applications be migrated to newer and more secure technologies.","pos":[740,834]},{"content":"If the application’s design uses only HTTP and is RESTful, we recommend ASP.NET Web API.","pos":[835,923]},{"content":"For more information, see ASP.NET Web API.","pos":[924,966]},{"content":"If the application is based on SOAP or requires non-Http protocols such as TCP, we recommend WCF.","pos":[967,1064]},{"pos":[1071,1101],"content":"Comparing .NET Remoting to WCF","linkify":"Comparing .NET Remoting to WCF","nodes":[{"content":"Comparing .NET Remoting to WCF","pos":[0,30]}]},{"content":"This section compares the basic building blocks of .NET Remoting with their WCF equivalents.","pos":[1105,1197]},{"content":"We will use these building blocks later to create some common client-server scenarios in WCF.The following chart summarizes the main similarities and differences between .NET Remoting and WCF.","pos":[1198,1390]},{"content":".NET Remoting","pos":[1398,1411]},{"content":"WCF","pos":[1412,1415]},{"content":"Server type","pos":[1456,1467]},{"content":"Subclass MarshalByRefObject","pos":[1468,1495]},{"content":"Mark with [ServiceContract] attribute","pos":[1496,1533]},{"content":"Service operations","pos":[1538,1556]},{"content":"Public methods on server type","pos":[1557,1586]},{"content":"Mark with [OperationContract] attribute","pos":[1587,1626]},{"content":"Serialization","pos":[1631,1644]},{"content":"ISerializable or [Serializable]","pos":[1645,1676]},{"content":"DataContractSerializer or XmlSerializer","pos":[1677,1716]},{"content":"Objects passed","pos":[1721,1735]},{"content":"By-value or by-reference","pos":[1736,1760]},{"content":"By-value only","pos":[1761,1774]},{"content":"Errors/exceptions","pos":[1779,1796]},{"content":"Any serializable exception","pos":[1797,1823]},{"content":"FaultContract<ph id=\"ph1\">\\&lt;</ph>TDetail&gt;","pos":[1824,1847],"source":"FaultContract\\<TDetail>"},{"content":"Client proxy objects","pos":[1852,1872]},{"content":"Strongly typed transparent proxies are created automatically from MarshalByRefObjects","pos":[1873,1958]},{"content":"Strongly typed proxies are generated on-demand using ChannelFactory<ph id=\"ph1\">\\&lt;</ph>TChannel&gt;","pos":[1959,2037],"source":"Strongly typed proxies are generated on-demand using ChannelFactory\\<TChannel>"},{"content":"Platform required","pos":[2042,2059]},{"content":"Both client and server must use Microsoft OS and .NET","pos":[2060,2113]},{"content":"Cross-platform","pos":[2114,2128]},{"content":"Message format","pos":[2133,2147]},{"content":"Private","pos":[2148,2155]},{"content":"Industry standards (SOAP, WS-*, etc.)","pos":[2156,2193]},{"pos":[2204,2236],"content":"Server Implementation Comparison","linkify":"Server Implementation Comparison","nodes":[{"content":"Server Implementation Comparison","pos":[0,32]}]},{"pos":[2247,2281],"content":"Creating a Server in .NET Remoting","linkify":"Creating a Server in .NET Remoting","nodes":[{"content":"Creating a Server in .NET Remoting","pos":[0,34]}]},{"content":".NET Remoting server types must derive from MarshalByRefObject and define methods the client can call, like the following:","pos":[2285,2407]},{"content":"The public methods of this server type become the public contract available to clients.","pos":[2548,2635]},{"content":"There is no separation between the server’s public interface and its implementation – one type handles both.","pos":[2637,2745]},{"content":"Once the server type has been defined, it can be made available to clients, like in the following example:","pos":[2752,2858]},{"content":"There are many ways to make the Remoting type available as a server, including using configuration files.","pos":[3246,3351]},{"content":"This is just one example.","pos":[3352,3377]},{"pos":[3388,3412],"content":"Creating a Server in WCF","linkify":"Creating a Server in WCF","nodes":[{"content":"Creating a Server in WCF","pos":[0,24]}]},{"content":"The equivalent step in WCF involves creating two types -- the public \"service contract\" and the concrete implementation.","pos":[3416,3536]},{"content":"The first is declared as an interface marked with [ServiceContract].","pos":[3537,3605]},{"content":"Methods available to clients are marked with [OperationContract]:","pos":[3606,3671]},{"content":"The server’s implementation is defined in a separate concrete class, like in the following example:","pos":[3825,3924]},{"content":"Once these types have been defined, the WCF server can be made available to clients, like in the following example:","pos":[4052,4167]},{"pos":[4700,4857],"content":"[!NOTE]\n TCP is used in both examples to keep them as similar as possible. Refer to the scenario walk-throughs later in this topic for examples using HTTP.","leadings":["","> "],"nodes":[{"content":"TCP is used in both examples to keep them as similar as possible. Refer to the scenario walk-throughs later in this topic for examples using HTTP.","pos":[9,155],"nodes":[{"content":"TCP is used in both examples to keep them as similar as possible.","pos":[0,65]},{"content":"Refer to the scenario walk-throughs later in this topic for examples using HTTP.","pos":[66,146]}]}]},{"content":"There are many ways to configure and to host WCF services.","pos":[4864,4922]},{"content":"This is just one example, known as \"self-hosted\".","pos":[4923,4972]},{"content":"For more information, see the following topics:","pos":[4973,5020]},{"pos":[5030,5106],"content":"<bpt id=\"p1\">[</bpt>How to: Define a Service Contract<ept id=\"p1\">](how-to-define-a-wcf-service-contract.md)</ept>","source":"[How to: Define a Service Contract](how-to-define-a-wcf-service-contract.md)"},{"pos":[5116,5215],"content":"<bpt id=\"p1\">[</bpt>Configuring Services Using Configuration Files<ept id=\"p1\">](configuring-services-using-configuration-files.md)</ept>","source":"[Configuring Services Using Configuration Files](configuring-services-using-configuration-files.md)"},{"pos":[5225,5264],"content":"<bpt id=\"p1\">[</bpt>Hosting Services<ept id=\"p1\">](hosting-services.md)</ept>","source":"[Hosting Services](hosting-services.md)"},{"pos":[5274,5306],"content":"Client Implementation Comparison","linkify":"Client Implementation Comparison","nodes":[{"content":"Client Implementation Comparison","pos":[0,32]}]},{"pos":[5317,5351],"content":"Creating a Client in .NET Remoting","linkify":"Creating a Client in .NET Remoting","nodes":[{"content":"Creating a Client in .NET Remoting","pos":[0,34]}]},{"content":"Once a .NET Remoting server object has been made available, it can be consumed by clients, like in the following example:","pos":[5355,5476]},{"content":"The RemotingServer instance returned from Activator.GetObject() is known as a \"transparent proxy.\"","pos":[5938,6036]},{"content":"It implements the public API for the RemotingServer type on the client, but all the methods call the server object running in a different process or machine.","pos":[6037,6194]},{"pos":[6205,6229],"content":"Creating a Client in WCF","linkify":"Creating a Client in WCF","nodes":[{"content":"Creating a Client in WCF","pos":[0,24]}]},{"content":"The equivalent step in WCF involves using a channel factory to create the proxy explicitly.","pos":[6233,6324]},{"content":"Like Remoting, the proxy object can be used to invoke operations on the server, like in the following example:","pos":[6325,6435]},{"content":"This example shows programming at the channel level because it is most similar to the Remoting example.","pos":[6906,7009]},{"content":"Also available is the <bpt id=\"p1\">**</bpt>Add Service Reference<ept id=\"p1\">**</ept> approach in Visual Studio that generates code to simplify client programming.","pos":[7010,7135],"source":" Also available is the **Add Service Reference** approach in Visual Studio that generates code to simplify client programming."},{"content":"For more information, see the following topics:","pos":[7136,7183]},{"pos":[7193,7276],"content":"<bpt id=\"p1\">[</bpt>Client Channel-Level Programming<ept id=\"p1\">](./extending/client-channel-level-programming.md)</ept>","source":"[Client Channel-Level Programming](./extending/client-channel-level-programming.md)"},{"pos":[7286,7421],"content":"<bpt id=\"p1\">[</bpt>How to: Add, Update, or Remove a Service Reference<ept id=\"p1\">](/visualstudio/data-tools/how-to-add-update-or-remove-a-wcf-data-service-reference)</ept>","source":"[How to: Add, Update, or Remove a Service Reference](/visualstudio/data-tools/how-to-add-update-or-remove-a-wcf-data-service-reference)"},{"pos":[7431,7450],"content":"Serialization Usage","linkify":"Serialization Usage","nodes":[{"content":"Serialization Usage","pos":[0,19]}]},{"content":"Both .NET Remoting and WCF use serialization to send objects between client and server, but they differ in these important ways:","pos":[7454,7582]},{"content":"They use different serializers and conventions to indicate what to serialize.","pos":[7592,7669]},{"content":".NET Remoting supports \"by reference\" serialization that allows method or property access on one tier to execute code on the other tier, which is across security boundaries.","pos":[7679,7852]},{"content":"This capability exposes security vulnerabilities and is one of the main reasons why Remoting endpoints should never be exposed to untrusted clients.","pos":[7853,8001]},{"content":"Serialization used by Remoting is opt-out (explicitly exclude what not to serialize) and WCF serialization is opt-in (explicitly mark which members to serialize).","pos":[8011,8173]},{"pos":[8184,8214],"content":"Serialization in .NET Remoting","linkify":"Serialization in .NET Remoting","nodes":[{"content":"Serialization in .NET Remoting","pos":[0,30]}]},{"content":".NET Remoting supports two ways to serialize and deserialize objects between the client and server:","pos":[8218,8317]},{"content":"<bpt id=\"p1\">*</bpt>By value<ept id=\"p1\">*</ept> – the values of the object are serialized across tier boundaries, and a new instance of that object is created on the other tier.","pos":[8327,8467],"source":"*By value* – the values of the object are serialized across tier boundaries, and a new instance of that object is created on the other tier."},{"content":"Any calls to methods or properties of that new instance execute only locally and do not affect the original object or tier.","pos":[8468,8591]},{"content":"<bpt id=\"p1\">*</bpt>By reference<ept id=\"p1\">*</ept> – a special \"object reference\" is serialized across tier boundaries.","pos":[8601,8684],"source":"*By reference* – a special \"object reference\" is serialized across tier boundaries."},{"content":"When one tier interacts with methods or properties of that object, it communicates back to the original object on the original tier.","pos":[8685,8817]},{"content":"By-reference objects can flow in either direction – server to client, or client to server.","pos":[8818,8908]},{"content":"By-value types in Remoting are marked with the [Serializable] attribute or implement ISerializable, like in the following example:","pos":[8915,9045]},{"content":"By-reference types derive from the MarshalByRefObject class, like in the following example:","pos":[9257,9348]},{"content":"It is extremely important to understand the implications of Remoting’s by-reference objects.","pos":[9573,9665]},{"content":"If either tier (client or server) sends a by-reference object to the other tier, all method calls execute back on the tier owning the object.","pos":[9666,9807]},{"content":"For example, a client calling methods on a by-reference object returned by the server will execute code on the server.","pos":[9808,9926]},{"content":"Similarly, a server calling methods on a by-reference object provided by the client will execute code back on the client.","pos":[9927,10048]},{"content":"For this reason, the use of .NET Remoting is recommended only within fully-trusted environments.","pos":[10049,10145]},{"content":"Exposing a public .NET Remoting endpoint to untrusted clients will make a Remoting server vulnerable to attack.","pos":[10146,10257]},{"pos":[10268,10288],"content":"Serialization in WCF","linkify":"Serialization in WCF","nodes":[{"content":"Serialization in WCF","pos":[0,20]}]},{"content":"WCF supports only by-value serialization.","pos":[10292,10333]},{"content":"The most common way to define a type to exchange between client and server is like in the following example:","pos":[10334,10442]},{"content":"The [DataContract] attribute identifies this type as one that can be serialized and deserialized between client and server.","pos":[10712,10835]},{"content":"The [DataMember] attribute identifies the individual properties or fields to serialize.","pos":[10836,10923]},{"content":"When WCF sends an object across tiers, it serializes only the values and creates a new instance of the object on the other tier.","pos":[10930,11058]},{"content":"Any interactions with the values of the object occur only locally – they do not communicate with the other tier the way .NET Remoting by-reference objects do.","pos":[11059,11217]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Serialization and Deserialization<ept id=\"p1\">](./feature-details/serialization-and-deserialization.md)</ept>.","pos":[11218,11336],"source":" For more information, see [Serialization and Deserialization](./feature-details/serialization-and-deserialization.md)."},{"pos":[11346,11377],"content":"Exception Handling Capabilities","linkify":"Exception Handling Capabilities","nodes":[{"content":"Exception Handling Capabilities","pos":[0,31]}]},{"pos":[11388,11415],"content":"Exceptions in .NET Remoting","linkify":"Exceptions in .NET Remoting","nodes":[{"content":"Exceptions in .NET Remoting","pos":[0,27]}]},{"content":"Exceptions thrown by a Remoting server are serialized, sent to the client, and thrown locally on the client like any other exception.","pos":[11419,11552]},{"content":"Custom exceptions can be created by sub-classing the Exception type and marking it with [Serializable].","pos":[11553,11656]},{"content":"Most framework exceptions are already marked in this way, allowing most to be thrown by the server, serialized, and re-thrown on the client.","pos":[11659,11799]},{"content":"Though this design is convenient during development, server-side information can inadvertently be disclosed to the client.","pos":[11800,11922]},{"content":"This is one of many reasons Remoting should be used only in fully-trusted environments.","pos":[11923,12010]},{"pos":[12021,12049],"content":"Exceptions and Faults in WCF","linkify":"Exceptions and Faults in WCF","nodes":[{"content":"Exceptions and Faults in WCF","pos":[0,28]}]},{"content":"WCF does not allow arbitrary exception types to be returned from the server to the client because it could lead to inadvertent information disclosure.","pos":[12053,12203]},{"content":"If a service operation throws an unexpected exception, it causes a general purpose FaultException to be thrown on the client.","pos":[12204,12329]},{"content":"This exception does not carry any information why or where the problem occurred, and for some applications this is sufficient.","pos":[12330,12456]},{"content":"Applications that need to communicate richer error information to the client do this by defining a fault contract.","pos":[12457,12571]},{"content":"To do this, first create a [DataContract] type to carry the fault information.","pos":[12578,12656]},{"content":"Specify the fault contract to use for each service operation.","pos":[12870,12931]},{"content":"The server reports error conditions by throwing a FaultException.","pos":[13137,13202]},{"content":"And whenever the client makes a request to the server, it can catch faults as normal exceptions.","pos":[13408,13504]},{"pos":[13726,13816],"content":"For more information about fault contracts, see <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException&gt;</ph>.","source":"For more information about fault contracts, see <xref:System.ServiceModel.FaultException>."},{"pos":[13826,13849],"content":"Security Considerations","linkify":"Security Considerations","nodes":[{"content":"Security Considerations","pos":[0,23]}]},{"pos":[13860,13885],"content":"Security in .NET Remoting","linkify":"Security in .NET Remoting","nodes":[{"content":"Security in .NET Remoting","pos":[0,25]}]},{"content":"Some .NET Remoting channels support security features such as authentication and encryption at the channel layer (IPC and TCP).","pos":[13889,14016]},{"content":"The HTTP channel relies on Internet Information Services (IIS) for both authentication and encryption.","pos":[14017,14119]},{"content":"Despite this support, you should consider .NET Remoting an unsecure communication protocol and use it only within fully-trusted environments.","pos":[14120,14261]},{"content":"Never expose a public Remoting endpoint to the Internet or untrusted clients.","pos":[14262,14339]},{"pos":[14350,14365],"content":"Security in WCF","linkify":"Security in WCF","nodes":[{"content":"Security in WCF","pos":[0,15]}]},{"content":"WCF was designed with security in mind, in part to address the kinds of vulnerabilities found in .NET Remoting.","pos":[14369,14480]},{"content":"WCF offers security at both the transport and message level, and offers many options for authentication, authorization, encryption, and so on.","pos":[14481,14623]},{"content":"For more information, see the following topics:","pos":[14624,14671]},{"pos":[14681,14722],"content":"<bpt id=\"p1\">[</bpt>Security<ept id=\"p1\">](./feature-details/security.md)</ept>","source":"[Security](./feature-details/security.md)"},{"pos":[14732,14814],"content":"<bpt id=\"p1\">[</bpt>WCF Security Guidance<ept id=\"p1\">](./feature-details/security-guidance-and-best-practices.md)</ept>","source":"[WCF Security Guidance](./feature-details/security-guidance-and-best-practices.md)"},{"pos":[14823,14839],"content":"Migrating to WCF","linkify":"Migrating to WCF","nodes":[{"content":"Migrating to WCF","pos":[0,16]}]},{"pos":[14849,14882],"content":"Why Migrate from Remoting to WCF?","linkify":"Why Migrate from Remoting to WCF?","nodes":[{"content":"Why Migrate from Remoting to WCF?","pos":[0,33]}]},{"content":"<bpt id=\"p1\">**</bpt>.NET Remoting is a legacy product.<ept id=\"p1\">**</ept>","pos":[14892,14930],"source":"**.NET Remoting is a legacy product.**"},{"content":"As described in <bpt id=\"p1\">[</bpt>.NET Remoting<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507%28v=vs.100%29)</ept>, it is considered a legacy product and is not recommended for new development.","pos":[14931,15134],"source":" As described in [.NET Remoting](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507%28v=vs.100%29), it is considered a legacy product and is not recommended for new development."},{"content":"WCF or ASP.NET Web API are recommended for new and existing applications.","pos":[15135,15208]},{"content":"<bpt id=\"p1\">**</bpt>WCF uses cross-platform standards.<ept id=\"p1\">**</ept>","pos":[15218,15256],"source":"**WCF uses cross-platform standards.**"},{"content":"WCF was designed with cross-platform interoperability in mind and supports many industry standards (SOAP, WS-Security, WS-Trust, etc.).","pos":[15257,15392]},{"content":"A WCF service can interoperate with clients running on operating systems other than Windows.","pos":[15393,15485]},{"content":"Remoting was designed primarily for environments where both the server and client applications run using the .NET framework on a Windows operating system.","pos":[15486,15640]},{"content":"<bpt id=\"p1\">**</bpt>WCF has built-in security.<ept id=\"p1\">**</ept>","pos":[15650,15680],"source":"**WCF has built-in security.**"},{"content":"WCF was designed with security in mind and offers many options for authentication, transport level security, message level security, etc. Remoting was designed to make it easy for applications to interoperate but was not designed to be secure in non-trusted environments.","pos":[15681,15952]},{"content":"WCF was designed to work in both trusted and non-trusted environments.","pos":[15953,16023]},{"pos":[16033,16058],"content":"Migration Recommendations","linkify":"Migration Recommendations","nodes":[{"content":"Migration Recommendations","pos":[0,25]}]},{"content":"The following are the recommended steps to migrate from .NET Remoting to WCF:","pos":[16062,16139]},{"content":"<bpt id=\"p1\">**</bpt>Create the service contract.<ept id=\"p1\">**</ept>","pos":[16149,16181],"source":"**Create the service contract.**"},{"content":"Define your service interface types, and mark them with the [ServiceContract] attribute.Mark all the methods the clients will be allowed to call with [OperationContract].","pos":[16182,16352]},{"content":"<bpt id=\"p1\">**</bpt>Create the data contract.<ept id=\"p1\">**</ept>","pos":[16362,16391],"source":"**Create the data contract.**"},{"content":"Define the data types that will be exchanged between server and client, and mark them with the [DataContract] attribute.","pos":[16392,16512]},{"content":"Mark all the fields and properties the client will be allowed to use with [DataMember].","pos":[16513,16600]},{"content":"<bpt id=\"p1\">**</bpt>Create the fault contract (optional).<ept id=\"p1\">**</ept>","pos":[16610,16651],"source":"**Create the fault contract (optional).**"},{"content":"Create the types that will be exchanged between server and client when errors are encountered.","pos":[16652,16746]},{"content":"Mark these types with [DataContract] and [DataMember] to make them serializable.","pos":[16747,16827]},{"content":"For all service operations you marked with [OperationContract], also mark them with [FaultContract] to indicate which errors they may return.","pos":[16828,16969]},{"content":"<bpt id=\"p1\">**</bpt>Configure and host the service.<ept id=\"p1\">**</ept>","pos":[16979,17014],"source":"**Configure and host the service.**"},{"content":"Once the service contract has been created, the next step is to configure a binding to expose the service at an endpoint.","pos":[17015,17136]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Endpoints: Addresses, Bindings, and Contracts<ept id=\"p1\">](./feature-details/endpoints-addresses-bindings-and-contracts.md)</ept>.","pos":[17137,17276],"source":" For more information, see [Endpoints: Addresses, Bindings, and Contracts](./feature-details/endpoints-addresses-bindings-and-contracts.md)."},{"content":"Once a Remoting application has been migrated to WCF, it is still important to remove dependencies on .NET Remoting.","pos":[17283,17399]},{"content":"This ensures that any Remoting vulnerabilities are removed from the application.","pos":[17400,17480]},{"content":"These steps include the following:","pos":[17481,17515]},{"content":"<bpt id=\"p1\">**</bpt>Discontinue use of MarshalByRefObject.<ept id=\"p1\">**</ept>","pos":[17525,17567],"source":"**Discontinue use of MarshalByRefObject.**"},{"content":"The MarshalByRefObject type exists only for Remoting and is not used by WCF.","pos":[17568,17644]},{"content":"Any application types that sub-class MarshalByRefObject should be removed or changed.","pos":[17645,17730]},{"content":"<bpt id=\"p1\">**</bpt>Discontinue use of [Serializable] and ISerializable.<ept id=\"p1\">**</ept>","pos":[17740,17796],"source":"**Discontinue use of [Serializable] and ISerializable.**"},{"content":"The [Serializable] attribute and ISerializable interface were originally designed to serialize types within trusted environments, and they are used by Remoting.","pos":[17797,17957]},{"content":"WCF serialization relies on types being marked with [DataContract] and [DataMember].","pos":[17958,18042]},{"content":"Data types used by an application should be modified to use [DataContract] and not to use ISerializable or [Serializable].","pos":[18043,18165]},{"pos":[18175,18194],"content":"Migration Scenarios","linkify":"Migration Scenarios","nodes":[{"content":"Migration Scenarios","pos":[0,19]}]},{"content":"Now let’s see how to accomplish the following common Remoting scenarios in WCF:","pos":[18198,18277]},{"content":"Server returns an object by-value to the client","pos":[18287,18334]},{"content":"Server returns an object by-reference to the client","pos":[18344,18395]},{"content":"Client sends an object by-value to the server","pos":[18405,18450]},{"pos":[18458,18552],"content":"[!NOTE]\n Sending an object by-reference from the client to the server is not allowed in WCF.","leadings":["","> "],"nodes":[{"content":"Sending an object by-reference from the client to the server is not allowed in WCF.","pos":[9,92]}]},{"content":"When reading through these scenarios, assume our baseline interfaces for .NET Remoting look like the following example.","pos":[18559,18678]},{"content":"The .NET Remoting implementation is not important here because we want to illustrate only how to use WCF to implement equivalent functionality.","pos":[18679,18822]},{"pos":[19276,19322],"content":"Scenario 1: Service Returns an Object by Value","linkify":"Scenario 1: Service Returns an Object by Value","nodes":[{"content":"Scenario 1: Service Returns an Object by Value","pos":[0,46]}]},{"content":"This scenario demonstrates a server returning an object to the client by value.","pos":[19326,19405]},{"content":"WCF always returns objects from the server by value, so the following steps simply describe how to build a normal WCF service.","pos":[19406,19532]},{"content":"Start by defining a public interface for the WCF service and mark it with the [ServiceContract] attribute.","pos":[19542,19648]},{"content":"We use [OperationContract] to identify the server-side methods our client will call.","pos":[19649,19733]},{"content":"The next step is to create the data contract for this service.","pos":[20001,20063]},{"content":"We do this by creating classes (not interfaces) marked with the [DataContract] attribute.","pos":[20064,20153]},{"content":"The individual properties or fields we want visible to both client and server are marked with [DataMember].","pos":[20154,20261]},{"content":"If we want derived types to be allowed, we must use the [KnownType] attribute to identify them.","pos":[20262,20357]},{"content":"The only types WCF will allow to be serialized or deserialized for this service are those in the service interface and these \"known types\".","pos":[20358,20497]},{"content":"Attempting to exchange any other type not in this list will be rejected.","pos":[20498,20570]},{"content":"Next, we provide the implementation for the service interface.","pos":[21067,21129]},{"content":"To run the WCF service, we need to declare an endpoint that exposes that service interface at a specific URL using a specific WCF binding.","pos":[21457,21595]},{"content":"This is typically done by adding the following sections to the server project’s web.config file.","pos":[21596,21692]},{"content":"The WCF service can then be started with the following code:","pos":[22137,22197]},{"content":"When this ServiceHost is started, it uses the web.config file to establish the proper contract, binding and endpoint.","pos":[22351,22468]},{"content":"For more information about configuration files, see <bpt id=\"p1\">[</bpt>Configuring Services Using Configuration Files<ept id=\"p1\">](./configuring-services-using-configuration-files.md)</ept>.","pos":[22469,22623],"source":" For more information about configuration files, see [Configuring Services Using Configuration Files](./configuring-services-using-configuration-files.md)."},{"content":"This style of starting the server is known as self-hosting.","pos":[22624,22683]},{"content":"To learn more about other choices for hosting WCF services, see <bpt id=\"p1\">[</bpt>Hosting Services<ept id=\"p1\">](./hosting-services.md)</ept>.","pos":[22684,22790],"source":" To learn more about other choices for hosting WCF services, see [Hosting Services](./hosting-services.md)."},{"content":"The client project’s app.config must declare matching binding information for the service’s endpoint.","pos":[22800,22901]},{"content":"The easiest way to do this in Visual Studio is to use <bpt id=\"p1\">**</bpt>Add Service Reference<ept id=\"p1\">**</ept>, which will automatically update the app.config file.","pos":[22902,23035],"source":" The easiest way to do this in Visual Studio is to use **Add Service Reference**, which will automatically update the app.config file."},{"content":"Alternatively, these same changes can be added manually.","pos":[23036,23092]},{"pos":[23497,23697],"content":"For more information about using <bpt id=\"p1\">**</bpt>Add Service Reference<ept id=\"p1\">**</ept>, see <bpt id=\"p2\">[</bpt>How to: Add, Update, or Remove a Service Reference<ept id=\"p2\">](/visualstudio/data-tools/how-to-add-update-or-remove-a-wcf-data-service-reference)</ept>.","source":"For more information about using **Add Service Reference**, see [How to: Add, Update, or Remove a Service Reference](/visualstudio/data-tools/how-to-add-update-or-remove-a-wcf-data-service-reference)."},{"content":"Now we can call the WCF service from the client.","pos":[23707,23755]},{"content":"We do this by creating a channel factory for that service, asking it for a channel, and directly calling the method we want on that channel.","pos":[23756,23896]},{"content":"We can do this because the channel implements the service’s interface and handles the underlying request/reply logic for us.","pos":[23897,24021]},{"content":"The return value from that method call is the deserialized copy of the server’s response.","pos":[24022,24111]},{"content":"Objects returned by WCF from the server to the client are always by value.","pos":[24452,24526]},{"content":"The objects are deserialized copies of the data sent by the server.","pos":[24527,24594]},{"content":"The client can call methods on these local copies without any danger of invoking server code through callbacks.","pos":[24595,24706]},{"pos":[24717,24766],"content":"Scenario 2: Server Returns an Object By Reference","linkify":"Scenario 2: Server Returns an Object By Reference","nodes":[{"content":"Scenario 2: Server Returns an Object By Reference","pos":[0,49]}]},{"content":"This scenario demonstrates the server providing an object to the client by reference.","pos":[24770,24855]},{"content":"In .NET Remoting, this is handled automatically for any type derived from MarshalByRefObject, which is serialized by-reference.","pos":[24856,24983]},{"content":"An example of this scenario is allowing multiple clients to have independent sessionful server-side objects.","pos":[24984,25092]},{"content":"As previously mentioned, objects returned by a WCF service are always by value, so there is no direct equivalent of a by-reference object, but it is possible to achieve something similar to by-reference semantics using an <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> object.","pos":[25093,25367],"source":" As previously mentioned, objects returned by a WCF service are always by value, so there is no direct equivalent of a by-reference object, but it is possible to achieve something similar to by-reference semantics using an <xref:System.ServiceModel.EndpointAddress10> object."},{"content":"This is a serializable by-value object that can be used by the client to obtain a sessionful by-reference object on the server.","pos":[25368,25495]},{"content":"This enables the scenario of having multiple clients with independent sessionful server-side objects.","pos":[25496,25597]},{"content":"First, we need to define a WCF service contract that corresponds to the sessionful object itself.","pos":[25607,25704]},{"pos":[26024,26568],"content":"[!TIP]\nNotice that the sessionful object is marked with [ServiceContract], making it a normal WCF service interface. Setting the SessionMode property indicates it will be a sessionful service. In WCF, a session is a way of correlating multiple messages sent between two endpoints. This means that once a client obtains a connection to this service, a session will be established between the client and the server. The client will use a single unique instance of the server-side object for all its interactions within this single session.","leadings":["","    >  "],"nodes":[{"content":"Notice that the sessionful object is marked with [ServiceContract], making it a normal WCF service interface. Setting the SessionMode property indicates it will be a sessionful service. In WCF, a session is a way of correlating multiple messages sent between two endpoints. This means that once a client obtains a connection to this service, a session will be established between the client and the server. The client will use a single unique instance of the server-side object for all its interactions within this single session.","pos":[7,537],"nodes":[{"content":"Notice that the sessionful object is marked with [ServiceContract], making it a normal WCF service interface.","pos":[0,109]},{"content":"Setting the SessionMode property indicates it will be a sessionful service.","pos":[110,185]},{"content":"In WCF, a session is a way of correlating multiple messages sent between two endpoints.","pos":[186,273]},{"content":"This means that once a client obtains a connection to this service, a session will be established between the client and the server.","pos":[274,406]},{"content":"The client will use a single unique instance of the server-side object for all its interactions within this single session.","pos":[407,530]}]}]},{"content":"Next, we need to provide the implementation of this service interface.","pos":[26578,26648]},{"content":"By denoting it with [ServiceBehavior] and setting the InstanceContextMode, we tell WCF we want to use a unique instance of this type for an each session.","pos":[26649,26802]},{"content":"Now we need a way to obtain an instance of this sessionful object.","pos":[27267,27333]},{"content":"We do this by creating another WCF service interface that returns an EndpointAddress10 object.","pos":[27334,27428]},{"content":"This is a serializable form of an endpoint that the client can use to create the sessionful object.","pos":[27429,27528]},{"content":"And we implement this WCF service:","pos":[27742,27776]},{"content":"This implementation maintains a singleton channel factory to create sessionful objects.","pos":[28380,28467]},{"content":"When GetInstanceAddress() is called, it creates a channel and creates an EndpointAddress10 object that effectively points to the remote address associated with this channel.","pos":[28468,28641]},{"content":"EndpointAddress10 is simply a data type that can be returned to the client by-value.","pos":[28642,28726]},{"content":"We need to modify the server’s configuration file by doing the following two things as shown in the example below:","pos":[28736,28850]},{"content":"Declare a <ph id=\"ph1\">\\&lt;</ph>client&gt; section that describes the endpoint for the sessionful object.","pos":[28864,28946],"source":"Declare a \\<client> section that describes the endpoint for the sessionful object."},{"content":"This is necessary because the server also acts as a client in this situation.","pos":[28947,29024]},{"content":"Declare endpoints for the factory and sessionful object.","pos":[29038,29094]},{"content":"This is necessary to allow the client to communicate with the service endpoints to acquire the EndpointAddress10 and to create the sessionful channel.","pos":[29095,29245]},{"content":"And then we can start these services:","pos":[30500,30537]},{"content":"We configure the client by declaring these same endpoints in its project’s app.config file.","pos":[30780,30871]},{"content":"In order to create and use this sessionful object, the client must do the following steps:","pos":[31724,31814]},{"content":"Create a channel to the ISessionBoundFactory service.","pos":[31828,31881]},{"content":"Use that channel to invoke that service to obtain an EndpointAddress10.","pos":[31895,31966]},{"content":"Use the EndpointAddress10 to create a channel to obtain a sessionful object.","pos":[31980,32056]},{"content":"Interact with the sessionful object to demonstrate it remains the same instance across multiple calls.","pos":[32070,32172]},{"content":"WCF always returns objects by value, but it is possible to support the equivalent of by-reference semantics through the use of EndpointAddress10.","pos":[33456,33601]},{"content":"This permits the client to request a sessionful WCF service instance, after which it can interact with it like any other WCF service.","pos":[33602,33735]},{"pos":[33746,33797],"content":"Scenario 3: Client Sends Server a By-Value Instance","linkify":"Scenario 3: Client Sends Server a By-Value Instance","nodes":[{"content":"Scenario 3: Client Sends Server a By-Value Instance","pos":[0,51]}]},{"content":"This scenario demonstrates the client sending a non-primitive object instance to the server by value.","pos":[33801,33902]},{"content":"Because WCF only sends objects by value, this scenario demonstrates normal WCF usage.","pos":[33903,33988]},{"content":"Use the same WCF Service from Scenario 1.","pos":[33998,34039]},{"content":"Use the client to create a new by-value object (Customer), create a channel to communicate with the ICustomerService service, and send the object to it.","pos":[34049,34201]},{"content":"The customer object will be serialized, and sent to the server, where it is deserialized into a new copy of that object.","pos":[34668,34788]},{"pos":[34800,35129],"content":"[!NOTE]\nThis code also illustrates sending a derived type (PremiumCustomer). The service interface expects a Customer object, but the [KnownType] attribute on the Customer class indicated PremiumCustomer was also allowed. WCF will fail any attempt to serialize or deserialize any other type through this service interface.","leadings":["","    >  "],"nodes":[{"content":"This code also illustrates sending a derived type (PremiumCustomer). The service interface expects a Customer object, but the [KnownType] attribute on the Customer class indicated PremiumCustomer was also allowed. WCF will fail any attempt to serialize or deserialize any other type through this service interface.","pos":[8,322],"nodes":[{"content":"This code also illustrates sending a derived type (PremiumCustomer).","pos":[0,68]},{"content":"The service interface expects a Customer object, but the [KnownType] attribute on the Customer class indicated PremiumCustomer was also allowed.","pos":[69,213]},{"content":"WCF will fail any attempt to serialize or deserialize any other type through this service interface.","pos":[214,314]}]}]},{"content":"Normal WCF exchanges of data are by value.","pos":[35136,35178]},{"content":"This guarantees that invoking methods on one of these data objects executes only locally – it will not invoke code on the other tier.","pos":[35179,35312]},{"content":"While it is possible to achieve something like by-reference objects returned <bpt id=\"p1\">*</bpt>from<ept id=\"p1\">*</ept> the server, it is not possible for a client to pass a by-reference object <bpt id=\"p2\">*</bpt>to<ept id=\"p2\">*</ept> the server.","pos":[35313,35487],"source":" While it is possible to achieve something like by-reference objects returned *from* the server, it is not possible for a client to pass a by-reference object *to* the server."},{"content":"A scenario that requires a conversation back and forth between client and server can be achieved in WCF using a duplex service.","pos":[35488,35615]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Duplex Services<ept id=\"p1\">](./feature-details/duplex-services.md)</ept>.","pos":[35616,35698],"source":" For more information, see [Duplex Services](./feature-details/duplex-services.md)."},{"pos":[35707,35714],"content":"Summary","linkify":"Summary","nodes":[{"content":"Summary","pos":[0,7]}]},{"content":".NET Remoting is a communication framework intended to be used only within fully-trusted environments.","pos":[35718,35820]},{"content":"It is a legacy product and supported only for backward compatibility.","pos":[35821,35890]},{"content":"It should not be used to build new applications.","pos":[35891,35939]},{"content":"Conversely, WCF was designed with security in mind and is recommended for new and existing applications.","pos":[35940,36044]},{"content":"Microsoft recommends that existing Remoting applications be migrated to use WCF or ASP.NET Web API instead.","pos":[36045,36152]}]}