{"content":"---\ntitle: \"Programming with Nodes (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: c38df0f2-c805-431a-93ff-9103a4284c2f\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Programming with Nodes (C#)\n[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] developers who need to write programs such as an XML editor, a transform system, or a report writer often need to write programs that work at a finer level of granularity than elements and attributes. They often need to work at the node level, manipulating text nodes, processing instructions, and comments. This topic provides some details about programming at the node level.  \n  \n## Node Details  \n There are a number of details of programming that a programmer working at the node level should know.  \n  \n### Parent Property of Children Nodes of XDocument is Set to Null  \n The <xref:System.Xml.Linq.XObject.Parent%2A> property contains the parent <xref:System.Xml.Linq.XElement>, not the parent node. Child nodes of <xref:System.Xml.Linq.XDocument> have no parent <xref:System.Xml.Linq.XElement>. Their parent is the document, so the <xref:System.Xml.Linq.XObject.Parent%2A> property for those nodes is set to null.  \n  \n The following example demonstrates this:  \n  \n```csharp  \nXDocument doc = XDocument.Parse(@\"<!-- a comment --><Root/>\");  \nConsole.WriteLine(doc.Nodes().OfType<XComment>().First().Parent == null);  \nConsole.WriteLine(doc.Root.Parent == null);  \n```  \n  \n This example produces the following output:  \n  \n```  \nTrue  \nTrue  \n```  \n  \n### Adjacent Text Nodes are Possible  \n In a number of XML programming models, adjacent text nodes are always merged. This is sometimes called normalization of text nodes. [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] does not normalize text nodes. If you add two text nodes to the same element, it will result in adjacent text nodes. However, if you add content specified as a string rather than as an <xref:System.Xml.Linq.XText> node, [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] might merge the string with an adjacent text node.  \n  \n The following example demonstrates this:  \n  \n```csharp  \nXElement xmlTree = new XElement(\"Root\", \"Content\");  \n  \nConsole.WriteLine(xmlTree.Nodes().OfType<XText>().Count());  \n  \n// this does not add a new text node  \nxmlTree.Add(\"new content\");  \nConsole.WriteLine(xmlTree.Nodes().OfType<XText>().Count());  \n  \n// this does add a new, adjacent text node  \nxmlTree.Add(new XText(\"more text\"));  \nConsole.WriteLine(xmlTree.Nodes().OfType<XText>().Count());  \n```  \n  \n This example produces the following output:  \n  \n```  \n1  \n1  \n2  \n```  \n  \n### Empty Text Nodes are Possible  \n In some XML programming models, text nodes are guaranteed to not contain the empty string. The reasoning is that such a text node has no impact on serialization of the XML. However, for the same reason that adjacent text nodes are possible, if you remove the text from a text node by setting its value to the empty string, the text node itself will not be deleted.  \n  \n```csharp  \nXElement xmlTree = new XElement(\"Root\", \"Content\");  \nXText textNode = xmlTree.Nodes().OfType<XText>().First();  \n  \n// the following line does not cause the removal of the text node.  \ntextNode.Value = \"\";  \n  \nXText textNode2 = xmlTree.Nodes().OfType<XText>().First();  \nConsole.WriteLine(\">>{0}<<\", textNode2);   \n```  \n  \n This example produces the following output:  \n  \n```  \n>><<  \n```  \n  \n### An Empty Text Node Impacts Serialization  \n If an element contains only a child text node that is empty, it is serialized with the long tag syntax: `<Child></Child>`. If an element contains no child nodes whatsoever, it is serialized with the short tag syntax: `<Child />`.  \n  \n```csharp  \nXElement child1 = new XElement(\"Child1\",  \n    new XText(\"\")  \n);  \nXElement child2 = new XElement(\"Child2\");  \nConsole.WriteLine(child1);  \nConsole.WriteLine(child2);   \n```  \n  \n This example produces the following output:  \n  \n```  \n<Child1></Child1>  \n<Child2 />  \n```  \n  \n### Namespaces are Attributes in the LINQ to XML Tree  \n Even though namespace declarations have identical syntax to attributes, in some programming interfaces, such as XSLT and XPath, namespace declarations are not considered to be attributes. However, in [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)], namespaces are stored as <xref:System.Xml.Linq.XAttribute> objects in the XML tree. If you iterate through the attributes for an element that contains a namespace declaration, you will see the namespace declaration as one of the items in the returned collection.  \n  \n The <xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A> property indicates whether an attribute is a namespace declaration.  \n  \n```csharp  \nXElement root = XElement.Parse(  \n@\"<Root  \n    xmlns='http://www.adventure-works.com'  \n    xmlns:fc='www.fourthcoffee.com'  \n    AnAttribute='abc'/>\");  \nforeach (XAttribute att in root.Attributes())  \n    Console.WriteLine(\"{0}  IsNamespaceDeclaration:{1}\", att, att.IsNamespaceDeclaration);  \n```  \n  \n This example produces the following output:  \n  \n```  \nxmlns=\"http://www.adventure-works.com\"  IsNamespaceDeclaration:True  \nxmlns:fc=\"www.fourthcoffee.com\"  IsNamespaceDeclaration:True  \nAnAttribute=\"abc\"  IsNamespaceDeclaration:False  \n```  \n  \n### XPath Axis Methods Do Not Return Child White Space of XDocument  \n [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] allows for child text nodes of an <xref:System.Xml.Linq.XDocument>, as long as the text nodes contain only white space. However, the XPath object model does not include white space as child nodes of a document, so when you iterate through the children of an <xref:System.Xml.Linq.XDocument> using the <xref:System.Xml.Linq.XContainer.Nodes%2A> axis, white space text nodes will be returned. However, when you iterate through the children of an <xref:System.Xml.Linq.XDocument> using the XPath axis methods, white space text nodes will not be returned.  \n  \n```csharp  \n// Create a document with some white space child nodes of the document.  \nXDocument root = XDocument.Parse(  \n@\"<?xml version='1.0' encoding='utf-8' standalone='yes'?>  \n  \n<Root/>  \n  \n<!--a comment-->  \n\", LoadOptions.PreserveWhitespace);  \n  \n// count the white space child nodes using LINQ to XML  \nConsole.WriteLine(root.Nodes().OfType<XText>().Count());  \n  \n// count the white space child nodes using XPathEvaluate  \nConsole.WriteLine(((IEnumerable)root.XPathEvaluate(\"text()\")).OfType<XText>().Count());   \n```  \n  \n This example produces the following output:  \n  \n```  \n3  \n0  \n```  \n  \n### XDeclaration Objects are not Nodes  \n When you iterate through the children nodes of an <xref:System.Xml.Linq.XDocument>, you will not see the XML declaration object. It is a property of the document, not a child node of it.  \n  \n```csharp  \nXDocument doc = new XDocument(  \n    new XDeclaration(\"1.0\", \"utf-8\", \"yes\"),  \n    new XElement(\"Root\")  \n);  \ndoc.Save(\"Temp.xml\");  \nConsole.WriteLine(File.ReadAllText(\"Temp.xml\"));  \n  \n// this shows that there is only one child node of the document  \nConsole.WriteLine(doc.Nodes().Count());  \n```  \n  \n This example produces the following output:  \n  \n```  \n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>  \n<Root />  \n1  \n```  \n  \n## See Also  \n [Advanced LINQ to XML Programming (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)","nodes":[{"pos":[4,408],"embed":true,"restype":"x-metadata","content":"title: \"Programming with Nodes (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: c38df0f2-c805-431a-93ff-9103a4284c2f\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","nodes":[{"content":"Programming with Nodes (C#) | Microsoft Docs","nodes":[{"pos":[0,44],"content":"Programming with Nodes (C#) | Microsoft Docs","nodes":[{"content":"Programming with Nodes (C#) | Microsoft Docs","pos":[0,44]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[415,442],"content":"Programming with Nodes (C#)","linkify":"Programming with Nodes (C#)","nodes":[{"content":"Programming with Nodes (C#)","pos":[0,27]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> developers who need to write programs such as an XML editor, a transform system, or a report writer often need to write programs that work at a finer level of granularity than elements and attributes.","pos":[443,746],"source":"[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] developers who need to write programs such as an XML editor, a transform system, or a report writer often need to write programs that work at a finer level of granularity than elements and attributes."},{"content":"They often need to work at the node level, manipulating text nodes, processing instructions, and comments.","pos":[747,853]},{"content":"This topic provides some details about programming at the node level.","pos":[854,923]},{"pos":[932,944],"content":"Node Details","linkify":"Node Details","nodes":[{"content":"Node Details","pos":[0,12]}]},{"content":"There are a number of details of programming that a programmer working at the node level should know.","pos":[948,1049]},{"pos":[1059,1120],"content":"Parent Property of Children Nodes of XDocument is Set to Null","linkify":"Parent Property of Children Nodes of XDocument is Set to Null","nodes":[{"content":"Parent Property of Children Nodes of XDocument is Set to Null","pos":[0,61]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;</ph> property contains the parent <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, not the parent node.","pos":[1124,1251],"source":"The <xref:System.Xml.Linq.XObject.Parent%2A> property contains the parent <xref:System.Xml.Linq.XElement>, not the parent node."},{"content":"Child nodes of <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> have no parent <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.","pos":[1252,1347],"source":" Child nodes of <xref:System.Xml.Linq.XDocument> have no parent <xref:System.Xml.Linq.XElement>."},{"content":"Their parent is the document, so the <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;</ph> property for those nodes is set to null.","pos":[1348,1466],"source":" Their parent is the document, so the <xref:System.Xml.Linq.XObject.Parent%2A> property for those nodes is set to null."},{"content":"The following example demonstrates this:","pos":[1473,1513]},{"content":"This example produces the following output:","pos":[1728,1771]},{"pos":[1810,1842],"content":"Adjacent Text Nodes are Possible","linkify":"Adjacent Text Nodes are Possible","nodes":[{"content":"Adjacent Text Nodes are Possible","pos":[0,32]}]},{"content":"In a number of XML programming models, adjacent text nodes are always merged.","pos":[1846,1923]},{"content":"This is sometimes called normalization of text nodes.","pos":[1924,1977]},{"content":"<ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> does not normalize text nodes.","pos":[1978,2111],"source":"[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] does not normalize text nodes."},{"content":"If you add two text nodes to the same element, it will result in adjacent text nodes.","pos":[2112,2197]},{"content":"However, if you add content specified as a string rather than as an <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XText&gt;</ph> node, <ph id=\"ph2\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> might merge the string with an adjacent text node.","pos":[2198,2454],"source":" However, if you add content specified as a string rather than as an <xref:System.Xml.Linq.XText> node, [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] might merge the string with an adjacent text node."},{"content":"The following example demonstrates this:","pos":[2461,2501]},{"content":"This example produces the following output:","pos":[2931,2974]},{"pos":[3011,3040],"content":"Empty Text Nodes are Possible","linkify":"Empty Text Nodes are Possible","nodes":[{"content":"Empty Text Nodes are Possible","pos":[0,29]}]},{"content":"In some XML programming models, text nodes are guaranteed to not contain the empty string.","pos":[3044,3134]},{"content":"The reasoning is that such a text node has no impact on serialization of the XML.","pos":[3135,3216]},{"content":"However, for the same reason that adjacent text nodes are possible, if you remove the text from a text node by setting its value to the empty string, the text node itself will not be deleted.","pos":[3217,3408]},{"content":"This example produces the following output:","pos":[3753,3796]},{"pos":[3828,3868],"content":"An Empty Text Node Impacts Serialization","linkify":"An Empty Text Node Impacts Serialization","nodes":[{"content":"An Empty Text Node Impacts Serialization","pos":[0,40]}]},{"content":"If an element contains only a child text node that is empty, it is serialized with the long tag syntax: <ph id=\"ph1\">`&lt;Child&gt;&lt;/Child&gt;`</ph>.","pos":[3872,3994],"source":"If an element contains only a child text node that is empty, it is serialized with the long tag syntax: `<Child></Child>`."},{"content":"If an element contains no child nodes whatsoever, it is serialized with the short tag syntax: <ph id=\"ph1\">`&lt;Child /&gt;`</ph>.","pos":[3995,4101],"source":" If an element contains no child nodes whatsoever, it is serialized with the short tag syntax: `<Child />`."},{"content":"This example produces the following output:","pos":[4300,4343]},{"pos":[4401,4450],"content":"Namespaces are Attributes in the LINQ to XML Tree","linkify":"Namespaces are Attributes in the LINQ to XML Tree","nodes":[{"content":"Namespaces are Attributes in the LINQ to XML Tree","pos":[0,49]}]},{"content":"Even though namespace declarations have identical syntax to attributes, in some programming interfaces, such as XSLT and XPath, namespace declarations are not considered to be attributes.","pos":[4454,4641]},{"content":"However, in <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, namespaces are stored as <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> objects in the XML tree.","pos":[4642,4841],"source":" However, in [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)], namespaces are stored as <xref:System.Xml.Linq.XAttribute> objects in the XML tree."},{"content":"If you iterate through the attributes for an element that contains a namespace declaration, you will see the namespace declaration as one of the items in the returned collection.","pos":[4842,5020]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt;</ph> property indicates whether an attribute is a namespace declaration.","pos":[5027,5158],"source":"The <xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A> property indicates whether an attribute is a namespace declaration."},{"content":"This example produces the following output:","pos":[5483,5526]},{"pos":[5734,5797],"content":"XPath Axis Methods Do Not Return Child White Space of XDocument","linkify":"XPath Axis Methods Do Not Return Child White Space of XDocument","nodes":[{"content":"XPath Axis Methods Do Not Return Child White Space of XDocument","pos":[0,63]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> allows for child text nodes of an <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XDocument&gt;</ph>, as long as the text nodes contain only white space.","pos":[5801,6023],"source":"[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] allows for child text nodes of an <xref:System.Xml.Linq.XDocument>, as long as the text nodes contain only white space."},{"content":"However, the XPath object model does not include white space as child nodes of a document, so when you iterate through the children of an <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> using the <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt;</ph> axis, white space text nodes will be returned.","pos":[6024,6294],"source":" However, the XPath object model does not include white space as child nodes of a document, so when you iterate through the children of an <xref:System.Xml.Linq.XDocument> using the <xref:System.Xml.Linq.XContainer.Nodes%2A> axis, white space text nodes will be returned."},{"content":"However, when you iterate through the children of an <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> using the XPath axis methods, white space text nodes will not be returned.","pos":[6295,6455],"source":" However, when you iterate through the children of an <xref:System.Xml.Linq.XDocument> using the XPath axis methods, white space text nodes will not be returned."},{"content":"This example produces the following output:","pos":[6998,7041]},{"pos":[7074,7108],"content":"XDeclaration Objects are not Nodes","linkify":"XDeclaration Objects are not Nodes","nodes":[{"content":"XDeclaration Objects are not Nodes","pos":[0,34]}]},{"content":"When you iterate through the children nodes of an <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XDocument&gt;</ph>, you will not see the XML declaration object.","pos":[7112,7240],"source":"When you iterate through the children nodes of an <xref:System.Xml.Linq.XDocument>, you will not see the XML declaration object."},{"content":"It is a property of the document, not a child node of it.","pos":[7241,7298]},{"content":"This example produces the following output:","pos":[7624,7667]},{"pos":[7764,7772],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[7776,7903],"content":"<bpt id=\"p1\">[</bpt>Advanced LINQ to XML Programming (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept>","source":"[Advanced LINQ to XML Programming (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)"}]}