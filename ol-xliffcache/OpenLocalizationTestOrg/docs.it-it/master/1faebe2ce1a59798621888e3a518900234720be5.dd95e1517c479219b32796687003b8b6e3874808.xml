{"content":"---\ntitle: \"ref keyword - C# Reference\"\nms.custom: seodec18\n\nms.date: 03/26/2019\nf1_keywords: \n  - \"ref_CSharpKeyword\"\n  - \"ref\"\nhelpviewer_keywords: \n  - \"parameters [C#], ref\"\n  - \"ref keyword [C#]\"\n---\n# ref (C# Reference)\n\nThe `ref` keyword indicates a value that is passed by reference. It is used in four different contexts:\n\n- In a method signature and in a method call, to pass an argument to a method by reference. For more information, see [Passing an argument by reference](#passing-an-argument-by-reference).\n- In a method signature, to return a value to the caller by reference. For more information, see [Reference return values](#reference-return-values).\n- In a member body, to indicate that a reference return value is stored locally as a reference that the caller intends to modify or, in general, a local variable accesses another value by reference. For more information, see [Ref locals](#ref-locals).\n- In a `struct` declaration to declare a `ref struct` or a `ref readonly struct`. For more information, see [ref struct types](#ref-struct-types).\n\n## Passing an argument by reference\n\nWhen used in a method's parameter list, the `ref` keyword indicates that an argument is passed by reference, not by value. The `ref` keyword makes the formal parameter an alias for the argument, which must be a variable. In other words, any operation on the parameter is made on the argument. For example, if the caller passes a local variable expression or an array element access expression, and the called method replaces the object to which the ref parameter refers, then the caller’s local variable or the array element now refers to the new object when the method returns.\n\n> [!NOTE]\n> Do not confuse the concept of passing by reference with the concept of reference types. The two concepts are not the same. A method parameter can be modified by `ref` regardless of whether it is a value type or a reference type. There is no boxing of a value type when it is passed by reference.  \n\nTo use a `ref` parameter, both the method definition and the calling method must explicitly use the `ref` keyword, as shown in the following example.  \n\n[!code-csharp-interactive[csrefKeywordsMethodParams#6](~/samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/RefParameterModifier.cs#1)]\n\nAn argument that is passed to a `ref` or `in` parameter must be initialized before it is passed. This differs from [out](out-parameter-modifier.md) parameters, whose arguments do not have to be explicitly initialized before they are passed.\n\nMembers of a class can't have signatures that differ only by `ref`, `in`, or `out`. A compiler error occurs if the only difference between two members of a type is that one of them has a `ref` parameter and the other has an `out`, or `in` parameter. The following code, for example, doesn't compile.  \n\n```csharp\nclass CS0663_Example\n{\n    // Compiler error CS0663: \"Cannot define overloaded \n    // methods that differ only on ref and out\".\n    public void SampleMethod(out int i) { }\n    public void SampleMethod(ref int i) { }\n}\n```\n\nHowever, methods can be overloaded when one method has a `ref`, `in`, or `out` parameter and the other has a value parameter, as shown in the following example.\n  \n[!code-csharp[csrefKeywordsMethodParams#6](~/samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/RefParameterModifier.cs#2)]\n  \n In other situations that require signature matching, such as hiding or overriding, `in`, `ref`, and `out` are part of the signature and don't match each other.  \n  \n Properties are not variables. They are methods, and cannot be passed to `ref` parameters.  \n  \n You can't use the `ref`, `in`, and `out` keywords for the following kinds of methods:  \n  \n- Async methods, which you define by using the [async](async.md) modifier.  \n- Iterator methods, which include a [yield return](yield.md) or `yield break` statement.  \n\n## Passing an argument by reference: An example\n\nThe previous examples pass value types by reference. You can also use the `ref` keyword to pass reference types by reference. Passing a reference type by reference enables the called method to replace the object to which the reference parameter refers in the caller. The storage location of the object is passed to the method as the value of the reference parameter. If you change the value in the storage location of the parameter (to point to a new object), you also change the storage location to which the caller refers. The following example passes an instance of a reference type as a `ref` parameter.\n  \n[!code-csharp[csrefKeywordsMethodParams#6](~/samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/RefParameterModifier.cs#3)]\n\nFor more information about how to pass reference types by value and by reference, see [Passing Reference-Type Parameters](../../programming-guide/classes-and-structs/passing-reference-type-parameters.md).\n  \n## Reference return values\n\nReference return values (or ref returns) are values that a method returns by reference to the caller. That is, the caller can modify the value returned by a method, and that change is reflected in the state of the object that contains the method.\n\nA reference return value is defined by using the `ref` keyword:\n\n- In the method signature. For example, the following method signature indicates that the `GetCurrentPrice` method returns a <xref:System.Decimal> value by reference.\n\n```csharp\npublic ref decimal GetCurrentPrice()\n```\n\n- Between the `return` token and the variable returned in a `return` statement in the method. For example:\n\n```csharp\nreturn ref DecimalArray[0];\n```\n\nIn order for the caller to modify the object's state, the reference return value must be stored to a variable that is explicitly defined as a [ref local](#ref-locals).\n\nThe called method may also declare the return value as `ref readonly` to return the value by reference, and enforce that the calling code cannot modify the returned value. The calling method can avoid copying the returned valued by storing the value in a local [ref readonly](#ref-readonly-locals) variable.\n\nFor an example, see [A ref returns and ref locals example](#a-ref-returns-and-ref-locals-example).\n\n## Ref locals\n\nA ref local variable is used to refer to values returned using `return ref`. A ref local variable cannot be initialized to a non-ref return value. In other words, the right hand side of the initialization must be a reference. Any modifications to the value of the ref local are reflected in the state of the object whose method returned the value by reference.\n\nYou define a ref local by using the `ref` keyword before the variable declaration, as well as immediately before the call to the method that returns the value by reference.\n\nFor example, the following statement defines a ref local value that is returned by a method named `GetEstimatedValue`:\n\n```csharp\nref decimal estValue = ref Building.GetEstimatedValue();\n```\n\nYou can access a value by reference in the same way. In some cases, accessing a value by reference increases performance by avoiding a potentially expensive copy operation. For example, the following statement shows how one can define a ref local value that is used to reference a value.\n\n```csharp\nref VeryLargeStruct reflocal = ref veryLargeStruct;\n```\n\nNote that in both examples the `ref` keyword must be used in both places, or the compiler generates error CS8172, \"Cannot initialize a by-reference variable with a value.\"\n\nBeginning with C# 7.3, the iteration variable of the `foreach` statement can be ref local or ref readonly local variable. For more information, see the [foreach statement](foreach-in.md) article.\n\n## Ref readonly locals\n\nA ref readonly local is used to refer to values returned by the method or property that has `ref readonly` in its signature and uses `return ref`. A `ref readonly` variable combines the properties of a `ref` local variable with a `readonly` variable: it is an alias to the storage it's assigned to, and it cannot be modified. \n\n## A ref returns and ref locals example\n\nThe following example defines a `Book` class that has two <xref:System.String> fields, `Title` and `Author`. It also defines a `BookCollection` class that includes a private array of `Book` objects. Individual book objects are returned by reference by calling its `GetBookByTitle` method.\n\n[!code-csharp[csrefKeywordsMethodParams#6](~/samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/RefParameterModifier.cs#4)]\n\nWhen the caller stores the value returned by the `GetBookByTitle` method as a ref local, changes that the caller makes to the return value are reflected in the `BookCollection` object, as the following example shows.\n\n[!code-csharp[csrefKeywordsMethodParams#6](~/samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/RefParameterModifier.cs#5)]\n\n## Ref struct types\n\nAdding the `ref` modifier to a `struct` declaration defines that instances of that type must be stack allocated. In other words, instances of these types can never be created on the\nheap as a member of another class. The primary motivation for this feature was <xref:System.Span%601> and related structures.\n\nThe goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.\n\n- You can't box a `ref struct`. You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.\n- `ref struct` types cannot implement interfaces.\n- You can't declare a `ref struct` as a member of a class or a normal struct.\n- You cannot declare local variables that are `ref struct` types in async methods. You can declare them in synchronous methods that return <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601> or `Task`-like types.\n- You cannot declare `ref struct` local variables in iterators.\n- You cannot capture `ref struct` variables in lambda expressions or local functions.\n\nThese restrictions ensure you don't accidentally use a `ref struct` in a manner that could promote it to the managed heap.\n\nYou can combine modifiers to declare a struct as `readonly ref`. A `readonly ref struct` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.\n\n## C# language specification\n\n[!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  \n  \n## See also\n\n- [Write safe efficient code](../../write-safe-efficient-code.md)\n- [Ref returns and ref locals](../../programming-guide/classes-and-structs/ref-returns.md)\n- [Conditional ref expression](../operators/conditional-operator.md#conditional-ref-expression)\n- [ref assignment operator](../operators/assignment-operator.md#ref-assignment-operator)\n- [Passing Parameters](../../programming-guide/classes-and-structs/passing-parameters.md)\n- [Method Parameters](method-parameters.md)\n- [C# Reference](../index.md)\n- [C# Programming Guide](../../programming-guide/index.md)\n- [C# Keywords](index.md)\n","nodes":[{"pos":[4,200],"embed":true,"restype":"x-metadata","content":"title: \"ref keyword - C# Reference\"\nms.custom: seodec18\n\nms.date: 03/26/2019\nf1_keywords: \n  - \"ref_CSharpKeyword\"\n  - \"ref\"\nhelpviewer_keywords: \n  - \"parameters [C#], ref\"\n  - \"ref keyword [C#]\"","nodes":[{"content":"ref keyword - C# Reference","nodes":[{"pos":[0,26],"content":"ref keyword - C# Reference","nodes":[{"content":"ref keyword - C# Reference","pos":[0,26]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[207,225],"content":"ref (C# Reference)","linkify":"ref (C# Reference)","nodes":[{"content":"ref (C# Reference)","pos":[0,18]}]},{"content":"The <ph id=\"ph1\">`ref`</ph> keyword indicates a value that is passed by reference.","pos":[227,291],"source":"The `ref` keyword indicates a value that is passed by reference."},{"content":"It is used in four different contexts:","pos":[292,330]},{"content":"In a method signature and in a method call, to pass an argument to a method by reference.","pos":[334,423]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Passing an argument by reference<ept id=\"p1\">](#passing-an-argument-by-reference)</ept>.","pos":[424,520],"source":" For more information, see [Passing an argument by reference](#passing-an-argument-by-reference)."},{"content":"In a method signature, to return a value to the caller by reference.","pos":[523,591]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Reference return values<ept id=\"p1\">](#reference-return-values)</ept>.","pos":[592,670],"source":" For more information, see [Reference return values](#reference-return-values)."},{"content":"In a member body, to indicate that a reference return value is stored locally as a reference that the caller intends to modify or, in general, a local variable accesses another value by reference.","pos":[673,869]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Ref locals<ept id=\"p1\">](#ref-locals)</ept>.","pos":[870,922],"source":" For more information, see [Ref locals](#ref-locals)."},{"content":"In a <ph id=\"ph1\">`struct`</ph> declaration to declare a <ph id=\"ph2\">`ref struct`</ph> or a <ph id=\"ph3\">`ref readonly struct`</ph>.","pos":[925,1004],"source":"In a `struct` declaration to declare a `ref struct` or a `ref readonly struct`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>ref struct types<ept id=\"p1\">](#ref-struct-types)</ept>.","pos":[1005,1069],"source":" For more information, see [ref struct types](#ref-struct-types)."},{"pos":[1074,1106],"content":"Passing an argument by reference","linkify":"Passing an argument by reference","nodes":[{"content":"Passing an argument by reference","pos":[0,32]}]},{"content":"When used in a method's parameter list, the <ph id=\"ph1\">`ref`</ph> keyword indicates that an argument is passed by reference, not by value.","pos":[1108,1230],"source":"When used in a method's parameter list, the `ref` keyword indicates that an argument is passed by reference, not by value."},{"content":"The <ph id=\"ph1\">`ref`</ph> keyword makes the formal parameter an alias for the argument, which must be a variable.","pos":[1231,1328],"source":" The `ref` keyword makes the formal parameter an alias for the argument, which must be a variable."},{"content":"In other words, any operation on the parameter is made on the argument.","pos":[1329,1400]},{"content":"For example, if the caller passes a local variable expression or an array element access expression, and the called method replaces the object to which the ref parameter refers, then the caller’s local variable or the array element now refers to the new object when the method returns.","pos":[1401,1686]},{"pos":[1690,1995],"content":"[!NOTE]\nDo not confuse the concept of passing by reference with the concept of reference types. The two concepts are not the same. A method parameter can be modified by `ref` regardless of whether it is a value type or a reference type. There is no boxing of a value type when it is passed by reference.","leadings":["","> "],"nodes":[{"content":"Do not confuse the concept of passing by reference with the concept of reference types. The two concepts are not the same. A method parameter can be modified by `ref` regardless of whether it is a value type or a reference type. There is no boxing of a value type when it is passed by reference.","pos":[8,303],"nodes":[{"content":"Do not confuse the concept of passing by reference with the concept of reference types.","pos":[0,87]},{"content":"The two concepts are not the same.","pos":[88,122]},{"content":"A method parameter can be modified by <ph id=\"ph1\">`ref`</ph> regardless of whether it is a value type or a reference type.","pos":[123,228],"source":" A method parameter can be modified by `ref` regardless of whether it is a value type or a reference type."},{"content":"There is no boxing of a value type when it is passed by reference.","pos":[229,295]}]}]},{"pos":[1999,2148],"content":"To use a <ph id=\"ph1\">`ref`</ph> parameter, both the method definition and the calling method must explicitly use the <ph id=\"ph2\">`ref`</ph> keyword, as shown in the following example.","source":"To use a `ref` parameter, both the method definition and the calling method must explicitly use the `ref` keyword, as shown in the following example."},{"content":"An argument that is passed to a <ph id=\"ph1\">`ref`</ph> or <ph id=\"ph2\">`in`</ph> parameter must be initialized before it is passed.","pos":[2310,2406],"source":"An argument that is passed to a `ref` or `in` parameter must be initialized before it is passed."},{"content":"This differs from <bpt id=\"p1\">[</bpt>out<ept id=\"p1\">](out-parameter-modifier.md)</ept> parameters, whose arguments do not have to be explicitly initialized before they are passed.","pos":[2407,2550],"source":" This differs from [out](out-parameter-modifier.md) parameters, whose arguments do not have to be explicitly initialized before they are passed."},{"content":"Members of a class can't have signatures that differ only by <ph id=\"ph1\">`ref`</ph>, <ph id=\"ph2\">`in`</ph>, or <ph id=\"ph3\">`out`</ph>.","pos":[2552,2635],"source":"Members of a class can't have signatures that differ only by `ref`, `in`, or `out`."},{"content":"A compiler error occurs if the only difference between two members of a type is that one of them has a <ph id=\"ph1\">`ref`</ph> parameter and the other has an <ph id=\"ph2\">`out`</ph>, or <ph id=\"ph3\">`in`</ph> parameter.","pos":[2636,2801],"source":" A compiler error occurs if the only difference between two members of a type is that one of them has a `ref` parameter and the other has an `out`, or `in` parameter."},{"content":"The following code, for example, doesn't compile.","pos":[2802,2851]},{"pos":[3089,3249],"content":"However, methods can be overloaded when one method has a <ph id=\"ph1\">`ref`</ph>, <ph id=\"ph2\">`in`</ph>, or <ph id=\"ph3\">`out`</ph> parameter and the other has a value parameter, as shown in the following example.","source":"However, methods can be overloaded when one method has a `ref`, `in`, or `out` parameter and the other has a value parameter, as shown in the following example."},{"pos":[3402,3561],"content":"In other situations that require signature matching, such as hiding or overriding, <ph id=\"ph1\">`in`</ph>, <ph id=\"ph2\">`ref`</ph>, and <ph id=\"ph3\">`out`</ph> are part of the signature and don't match each other.","source":"In other situations that require signature matching, such as hiding or overriding, `in`, `ref`, and `out` are part of the signature and don't match each other."},{"content":"Properties are not variables.","pos":[3568,3597]},{"content":"They are methods, and cannot be passed to <ph id=\"ph1\">`ref`</ph> parameters.","pos":[3598,3657],"source":" They are methods, and cannot be passed to `ref` parameters."},{"pos":[3664,3749],"content":"You can't use the <ph id=\"ph1\">`ref`</ph>, <ph id=\"ph2\">`in`</ph>, and <ph id=\"ph3\">`out`</ph> keywords for the following kinds of methods:","source":"You can't use the `ref`, `in`, and `out` keywords for the following kinds of methods:"},{"pos":[3757,3829],"content":"Async methods, which you define by using the <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](async.md)</ept> modifier.","source":"Async methods, which you define by using the [async](async.md) modifier."},{"pos":[3834,3920],"content":"Iterator methods, which include a <bpt id=\"p1\">[</bpt>yield return<ept id=\"p1\">](yield.md)</ept> or <ph id=\"ph1\">`yield break`</ph> statement.","source":"Iterator methods, which include a [yield return](yield.md) or `yield break` statement."},{"pos":[3927,3971],"content":"Passing an argument by reference: An example","linkify":"Passing an argument by reference: An example","nodes":[{"content":"Passing an argument by reference: An example","pos":[0,44]}]},{"content":"The previous examples pass value types by reference.","pos":[3973,4025]},{"content":"You can also use the <ph id=\"ph1\">`ref`</ph> keyword to pass reference types by reference.","pos":[4026,4098],"source":" You can also use the `ref` keyword to pass reference types by reference."},{"content":"Passing a reference type by reference enables the called method to replace the object to which the reference parameter refers in the caller.","pos":[4099,4239]},{"content":"The storage location of the object is passed to the method as the value of the reference parameter.","pos":[4240,4339]},{"content":"If you change the value in the storage location of the parameter (to point to a new object), you also change the storage location to which the caller refers.","pos":[4340,4497]},{"content":"The following example passes an instance of a reference type as a <ph id=\"ph1\">`ref`</ph> parameter.","pos":[4498,4580],"source":" The following example passes an instance of a reference type as a `ref` parameter."},{"pos":[4730,4934],"content":"For more information about how to pass reference types by value and by reference, see <bpt id=\"p1\">[</bpt>Passing Reference-Type Parameters<ept id=\"p1\">](../../programming-guide/classes-and-structs/passing-reference-type-parameters.md)</ept>.","source":"For more information about how to pass reference types by value and by reference, see [Passing Reference-Type Parameters](../../programming-guide/classes-and-structs/passing-reference-type-parameters.md)."},{"pos":[4941,4964],"content":"Reference return values","linkify":"Reference return values","nodes":[{"content":"Reference return values","pos":[0,23]}]},{"content":"Reference return values (or ref returns) are values that a method returns by reference to the caller.","pos":[4966,5067]},{"content":"That is, the caller can modify the value returned by a method, and that change is reflected in the state of the object that contains the method.","pos":[5068,5212]},{"pos":[5214,5277],"content":"A reference return value is defined by using the <ph id=\"ph1\">`ref`</ph> keyword:","source":"A reference return value is defined by using the `ref` keyword:"},{"content":"In the method signature.","pos":[5281,5305]},{"content":"For example, the following method signature indicates that the <ph id=\"ph1\">`GetCurrentPrice`</ph> method returns a <ph id=\"ph2\">&lt;xref:System.Decimal&gt;</ph> value by reference.","pos":[5306,5445],"source":" For example, the following method signature indicates that the `GetCurrentPrice` method returns a <xref:System.Decimal> value by reference."},{"content":"Between the <ph id=\"ph1\">`return`</ph> token and the variable returned in a <ph id=\"ph2\">`return`</ph> statement in the method.","pos":[5501,5592],"source":"Between the `return` token and the variable returned in a `return` statement in the method."},{"content":"For example:","pos":[5593,5605]},{"pos":[5650,5817],"content":"In order for the caller to modify the object's state, the reference return value must be stored to a variable that is explicitly defined as a <bpt id=\"p1\">[</bpt>ref local<ept id=\"p1\">](#ref-locals)</ept>.","source":"In order for the caller to modify the object's state, the reference return value must be stored to a variable that is explicitly defined as a [ref local](#ref-locals)."},{"content":"The called method may also declare the return value as <ph id=\"ph1\">`ref readonly`</ph> to return the value by reference, and enforce that the calling code cannot modify the returned value.","pos":[5819,5990],"source":"The called method may also declare the return value as `ref readonly` to return the value by reference, and enforce that the calling code cannot modify the returned value."},{"content":"The calling method can avoid copying the returned valued by storing the value in a local <bpt id=\"p1\">[</bpt>ref readonly<ept id=\"p1\">](#ref-readonly-locals)</ept> variable.","pos":[5991,6126],"source":" The calling method can avoid copying the returned valued by storing the value in a local [ref readonly](#ref-readonly-locals) variable."},{"pos":[6128,6226],"content":"For an example, see <bpt id=\"p1\">[</bpt>A ref returns and ref locals example<ept id=\"p1\">](#a-ref-returns-and-ref-locals-example)</ept>.","source":"For an example, see [A ref returns and ref locals example](#a-ref-returns-and-ref-locals-example)."},{"pos":[6231,6241],"content":"Ref locals","linkify":"Ref locals","nodes":[{"content":"Ref locals","pos":[0,10]}]},{"content":"A ref local variable is used to refer to values returned using <ph id=\"ph1\">`return ref`</ph>.","pos":[6243,6319],"source":"A ref local variable is used to refer to values returned using `return ref`."},{"content":"A ref local variable cannot be initialized to a non-ref return value.","pos":[6320,6389]},{"content":"In other words, the right hand side of the initialization must be a reference.","pos":[6390,6468]},{"content":"Any modifications to the value of the ref local are reflected in the state of the object whose method returned the value by reference.","pos":[6469,6603]},{"pos":[6605,6777],"content":"You define a ref local by using the <ph id=\"ph1\">`ref`</ph> keyword before the variable declaration, as well as immediately before the call to the method that returns the value by reference.","source":"You define a ref local by using the `ref` keyword before the variable declaration, as well as immediately before the call to the method that returns the value by reference."},{"pos":[6779,6897],"content":"For example, the following statement defines a ref local value that is returned by a method named <ph id=\"ph1\">`GetEstimatedValue`</ph>:","source":"For example, the following statement defines a ref local value that is returned by a method named `GetEstimatedValue`:"},{"content":"You can access a value by reference in the same way.","pos":[6971,7023]},{"content":"In some cases, accessing a value by reference increases performance by avoiding a potentially expensive copy operation.","pos":[7024,7143]},{"content":"For example, the following statement shows how one can define a ref local value that is used to reference a value.","pos":[7144,7258]},{"pos":[7327,7498],"content":"Note that in both examples the <ph id=\"ph1\">`ref`</ph> keyword must be used in both places, or the compiler generates error CS8172, \"Cannot initialize a by-reference variable with a value.\"","source":"Note that in both examples the `ref` keyword must be used in both places, or the compiler generates error CS8172, \"Cannot initialize a by-reference variable with a value.\""},{"content":"Beginning with C# 7.3, the iteration variable of the <ph id=\"ph1\">`foreach`</ph> statement can be ref local or ref readonly local variable.","pos":[7500,7621],"source":"Beginning with C# 7.3, the iteration variable of the `foreach` statement can be ref local or ref readonly local variable."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>foreach statement<ept id=\"p1\">](foreach-in.md)</ept> article.","pos":[7622,7695],"source":" For more information, see the [foreach statement](foreach-in.md) article."},{"pos":[7700,7719],"content":"Ref readonly locals","linkify":"Ref readonly locals","nodes":[{"content":"Ref readonly locals","pos":[0,19]}]},{"content":"A ref readonly local is used to refer to values returned by the method or property that has <ph id=\"ph1\">`ref readonly`</ph> in its signature and uses <ph id=\"ph2\">`return ref`</ph>.","pos":[7721,7867],"source":"A ref readonly local is used to refer to values returned by the method or property that has `ref readonly` in its signature and uses `return ref`."},{"content":"A <ph id=\"ph1\">`ref readonly`</ph> variable combines the properties of a <ph id=\"ph2\">`ref`</ph> local variable with a <ph id=\"ph3\">`readonly`</ph> variable: it is an alias to the storage it's assigned to, and it cannot be modified.","pos":[7868,8046],"source":" A `ref readonly` variable combines the properties of a `ref` local variable with a `readonly` variable: it is an alias to the storage it's assigned to, and it cannot be modified."},{"pos":[8052,8088],"content":"A ref returns and ref locals example","linkify":"A ref returns and ref locals example","nodes":[{"content":"A ref returns and ref locals example","pos":[0,36]}]},{"content":"The following example defines a <ph id=\"ph1\">`Book`</ph> class that has two <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> fields, <ph id=\"ph3\">`Title`</ph> and <ph id=\"ph4\">`Author`</ph>.","pos":[8090,8198],"source":"The following example defines a `Book` class that has two <xref:System.String> fields, `Title` and `Author`."},{"content":"It also defines a <ph id=\"ph1\">`BookCollection`</ph> class that includes a private array of <ph id=\"ph2\">`Book`</ph> objects.","pos":[8199,8288],"source":" It also defines a `BookCollection` class that includes a private array of `Book` objects."},{"content":"Individual book objects are returned by reference by calling its <ph id=\"ph1\">`GetBookByTitle`</ph> method.","pos":[8289,8378],"source":" Individual book objects are returned by reference by calling its `GetBookByTitle` method."},{"pos":[8526,8742],"content":"When the caller stores the value returned by the <ph id=\"ph1\">`GetBookByTitle`</ph> method as a ref local, changes that the caller makes to the return value are reflected in the <ph id=\"ph2\">`BookCollection`</ph> object, as the following example shows.","source":"When the caller stores the value returned by the `GetBookByTitle` method as a ref local, changes that the caller makes to the return value are reflected in the `BookCollection` object, as the following example shows."},{"pos":[8893,8909],"content":"Ref struct types","linkify":"Ref struct types","nodes":[{"content":"Ref struct types","pos":[0,16]}]},{"content":"Adding the <ph id=\"ph1\">`ref`</ph> modifier to a <ph id=\"ph2\">`struct`</ph> declaration defines that instances of that type must be stack allocated.","pos":[8911,9023],"source":"Adding the `ref` modifier to a `struct` declaration defines that instances of that type must be stack allocated."},{"content":"In other words, instances of these types can never be created on the heap as a member of another class.","pos":[9024,9127],"source":" In other words, instances of these types can never be created on the\nheap as a member of another class."},{"content":"The primary motivation for this feature was <ph id=\"ph1\">&lt;xref:System.Span%601&gt;</ph> and related structures.","pos":[9128,9218],"source":" The primary motivation for this feature was <xref:System.Span%601> and related structures."},{"pos":[9220,9369],"content":"The goal of keeping a <ph id=\"ph1\">`ref struct`</ph> type as a stack-allocated variable introduces several rules that the compiler enforces for all <ph id=\"ph2\">`ref struct`</ph> types.","source":"The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types."},{"content":"You can't box a <ph id=\"ph1\">`ref struct`</ph>.","pos":[9373,9402],"source":"You can't box a `ref struct`."},{"content":"You cannot assign a <ph id=\"ph1\">`ref struct`</ph> type to a variable of type <ph id=\"ph2\">`object`</ph>, <ph id=\"ph3\">`dynamic`</ph>, or any interface type.","pos":[9403,9506],"source":" You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type."},{"pos":[9509,9556],"content":"<ph id=\"ph1\">`ref struct`</ph> types cannot implement interfaces.","source":"`ref struct` types cannot implement interfaces."},{"pos":[9559,9634],"content":"You can't declare a <ph id=\"ph1\">`ref struct`</ph> as a member of a class or a normal struct.","source":"You can't declare a `ref struct` as a member of a class or a normal struct."},{"content":"You cannot declare local variables that are <ph id=\"ph1\">`ref struct`</ph> types in async methods.","pos":[9637,9717],"source":"You cannot declare local variables that are `ref struct` types in async methods."},{"content":"You can declare them in synchronous methods that return <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> or <ph id=\"ph3\">`Task`</ph>-like types.","pos":[9718,9870],"source":" You can declare them in synchronous methods that return <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601> or `Task`-like types."},{"pos":[9873,9934],"content":"You cannot declare <ph id=\"ph1\">`ref struct`</ph> local variables in iterators.","source":"You cannot declare `ref struct` local variables in iterators."},{"pos":[9937,10020],"content":"You cannot capture <ph id=\"ph1\">`ref struct`</ph> variables in lambda expressions or local functions.","source":"You cannot capture `ref struct` variables in lambda expressions or local functions."},{"pos":[10022,10144],"content":"These restrictions ensure you don't accidentally use a <ph id=\"ph1\">`ref struct`</ph> in a manner that could promote it to the managed heap.","source":"These restrictions ensure you don't accidentally use a `ref struct` in a manner that could promote it to the managed heap."},{"content":"You can combine modifiers to declare a struct as <ph id=\"ph1\">`readonly ref`</ph>.","pos":[10146,10210],"source":"You can combine modifiers to declare a struct as `readonly ref`."},{"content":"A <ph id=\"ph1\">`readonly ref struct`</ph> combines the benefits and restrictions of <ph id=\"ph2\">`ref struct`</ph> and <ph id=\"ph3\">`readonly struct`</ph> declarations.","pos":[10211,10325],"source":" A `readonly ref struct` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations."},{"pos":[10330,10355],"content":"C# language specification","linkify":"C# language specification","nodes":[{"content":"C# language specification","pos":[0,25]}]},{"pos":[10425,10433],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10437,10500],"content":"<bpt id=\"p1\">[</bpt>Write safe efficient code<ept id=\"p1\">](../../write-safe-efficient-code.md)</ept>","source":"[Write safe efficient code](../../write-safe-efficient-code.md)"},{"pos":[10503,10591],"content":"<bpt id=\"p1\">[</bpt>Ref returns and ref locals<ept id=\"p1\">](../../programming-guide/classes-and-structs/ref-returns.md)</ept>","source":"[Ref returns and ref locals](../../programming-guide/classes-and-structs/ref-returns.md)"},{"pos":[10594,10687],"content":"<bpt id=\"p1\">[</bpt>Conditional ref expression<ept id=\"p1\">](../operators/conditional-operator.md#conditional-ref-expression)</ept>","source":"[Conditional ref expression](../operators/conditional-operator.md#conditional-ref-expression)"},{"pos":[10690,10776],"content":"<bpt id=\"p1\">[</bpt>ref assignment operator<ept id=\"p1\">](../operators/assignment-operator.md#ref-assignment-operator)</ept>","source":"[ref assignment operator](../operators/assignment-operator.md#ref-assignment-operator)"},{"pos":[10779,10866],"content":"<bpt id=\"p1\">[</bpt>Passing Parameters<ept id=\"p1\">](../../programming-guide/classes-and-structs/passing-parameters.md)</ept>","source":"[Passing Parameters](../../programming-guide/classes-and-structs/passing-parameters.md)"},{"pos":[10869,10910],"content":"<bpt id=\"p1\">[</bpt>Method Parameters<ept id=\"p1\">](method-parameters.md)</ept>","source":"[Method Parameters](method-parameters.md)"},{"pos":[10913,10940],"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../index.md)</ept>","source":"[C# Reference](../index.md)"},{"pos":[10943,10999],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../programming-guide/index.md)"},{"pos":[11002,11025],"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](index.md)</ept>","source":"[C# Keywords](index.md)"}]}