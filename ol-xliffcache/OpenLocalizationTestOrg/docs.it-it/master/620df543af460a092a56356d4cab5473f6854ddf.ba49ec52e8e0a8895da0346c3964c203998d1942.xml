{"content":"---\ntitle: \"Threads and Threading | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"multiple threads\"\n  - \"threading [.NET Framework]\"\n  - \"threading [.NET Framework], multiple threads\"\nms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1\ncaps.latest.revision: 14\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Threads and Threading\nOperating systems use processes to separate the different applications that they are executing. Threads are the basic unit to which an operating system allocates processor time, and more than one thread can be executing code inside that process. Each thread maintains exception handlers, a scheduling priority, and a set of structures the system uses to save the thread context until it is scheduled. The thread context includes all the information the thread needs to seamlessly resume execution, including the thread's set of CPU registers and stack, in the address space of the thread's host process.  \n  \n The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <xref:System.AppDomain?displayProperty=fullName>. One or more managed threads (represented by <xref:System.Threading.Thread?displayProperty=fullName>) can run in one or any number of application domains within the same managed process. Although each application domain is started with a single thread, code in that application domain can create additional application domains and additional threads. The result is that a managed thread can move freely between application domains inside the same managed process; you might have only one thread moving among several application domains.  \n  \n An operating system that supports preemptive multitasking creates the effect of simultaneous execution of multiple threads from multiple processes. It does this by dividing the available processor time among the threads that need it, allocating a processor time slice to each thread one after another. The currently executing thread is suspended when its time slice elapses, and another thread resumes running. When the system switches from one thread to another, it saves the thread context of the preempted thread and reloads the saved thread context of the next thread in the thread queue.  \n  \n The length of the time slice depends on the operating system and the processor. Because each time slice is small, multiple threads appear to be executing at the same time, even if there is only one processor. This is actually the case on multiprocessor systems, where the executable threads are distributed among the available processors.  \n  \n## When To Use Multiple Threads  \n Software that requires user interaction must react to the user's activities as rapidly as possible to provide a rich user experience. At the same time, however, it must do the calculations necessary to present data to the user as fast as possible. If your application uses only one thread of execution, you can combine [asynchronous programming](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) with[.NET Framework remoting](http://msdn.microsoft.com/en-us/eccb1d31-0a22-417a-97fd-f4f1f3aa4462) or [XML Web services](http://msdn.microsoft.com/en-us/1e64af78-d705-4384-b08d-591a45f4379c) created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application. If you are doing intensive input/output work, you can also use I/O completion ports to increase your application's responsiveness.  \n  \n### Advantages of Multiple Threads  \n Using more than one thread, however, is the most powerful technique available to increase responsiveness to the user and process the data necessary to get the job done at almost the same time. On a computer with one processor, multiple threads can create this effect, taking advantage of the small periods of time in between user events to process the data in the background. For example, a user can edit a spreadsheet while another thread is recalculating other parts of the spreadsheet within the same application.  \n  \n Without modification, the same application would dramatically increase user satisfaction when run on a computer with more than one processor. Your single application domain could use multiple threads to accomplish the following tasks:  \n  \n-   Communicate over a network, to a Web server, and to a database.  \n  \n-   Perform operations that take a large amount of time.  \n  \n-   Distinguish tasks of varying priority. For example, a high-priority thread manages time-critical tasks, and a low-priority thread performs other tasks.  \n  \n-   Allow the user interface to remain responsive, while allocating time to background tasks.  \n  \n### Disadvantages of Multiple Threads  \n It is recommended that you use as few threads as possible, thereby minimizing the use of operating-system resources and improving performance. Threading also has resource requirements and potential conflicts to be considered when designing your application. The resource requirements are as follows:  \n  \n-   The system consumes memory for the context information required by processes, **AppDomain** objects, and threads. Therefore, the number of processes, **AppDomain** objects, and threads that can be created is limited by available memory.  \n  \n-   Keeping track of a large number of threads consumes significant processor time. If there are too many threads, most of them will not make significant progress. If most of the current threads are in one process, threads in other processes are scheduled less frequently.  \n  \n-   Controlling code execution with many threads is complex, and can be a source of many bugs.  \n  \n-   Destroying threads requires knowing what could happen and handling those issues.  \n  \n Providing shared access to resources can create conflicts. To avoid conflicts, you must synchronize, or control the access to, shared resources. Failure to synchronize access properly (in the same or different application domains) can lead to problems such as deadlocks (in which two threads stop responding while each waits for the other to complete) and race conditions (when an anomalous result occurs due to an unexpected critical dependence on the timing of two events). The system provides synchronization objects that can be used to coordinate resource sharing among multiple threads. Reducing the number of threads makes it easier to synchronize resources.  \n  \n Resources that require synchronization include:  \n  \n-   System resources (such as communications ports).  \n  \n-   Resources shared by multiple processes (such as file handles).  \n  \n-   The resources of a single application domain (such as global, static, and instance fields) accessed by multiple threads.  \n  \n### Threading and Application Design  \n In general, using the <xref:System.Threading.ThreadPool> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks. However, there are a number of reasons to create your own threads:  \n  \n-   If you need a task to have a particular priority.  \n  \n-   If you have a task that might run a long time (and therefore block other tasks).  \n  \n-   If you need to place threads into a single-threaded apartment (all **ThreadPool** threads are in the multithreaded apartment).  \n  \n-   If you need a stable identity associated with the thread. For example, you should use a dedicated thread to abort that thread, suspend it, or discover it by name.  \n  \n-   If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <xref:System.ComponentModel.BackgroundWorker> component that communicates using events, with cross-thread marshaling to the user-interface thread.  \n  \n### Threading and Exceptions  \n Do handle exceptions in threads. Unhandled exceptions in threads, even background threads, generally terminate the process. There are three exceptions to this rule:  \n  \n-   A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called.  \n  \n-   An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain is being unloaded.  \n  \n-   The common language runtime or a host process terminates the thread.  \n  \n For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md).  \n  \n> [!NOTE]\n>  In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads. This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.  \n  \n## See Also  \n <xref:System.Threading.ThreadPool>   \n <xref:System.ComponentModel.BackgroundWorker>   \n [Synchronizing Data for Multithreading](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)   \n [The Managed Thread Pool](../../../docs/standard/threading/the-managed-thread-pool.md)","nodes":[{"pos":[12,50],"content":"Threads and Threading | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Threads and Threading | Microsoft Docs","pos":[0,38]}]},{"pos":[471,492],"content":"Threads and Threading","linkify":"Threads and Threading","nodes":[{"content":"Threads and Threading","pos":[0,21]}]},{"content":"Operating systems use processes to separate the different applications that they are executing.","pos":[493,588]},{"content":"Threads are the basic unit to which an operating system allocates processor time, and more than one thread can be executing code inside that process.","pos":[589,738]},{"content":"Each thread maintains exception handlers, a scheduling priority, and a set of structures the system uses to save the thread context until it is scheduled.","pos":[739,893]},{"content":"The thread context includes all the information the thread needs to seamlessly resume execution, including the thread's set of CPU registers and stack, in the address space of the thread's host process.","pos":[894,1096]},{"content":"The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <ph id=\"ph1\">&lt;xref:System.AppDomain?displayProperty=fullName&gt;</ph>.","pos":[1103,1300],"source":"The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <xref:System.AppDomain?displayProperty=fullName>."},{"content":"One or more managed threads (represented by <ph id=\"ph1\">&lt;xref:System.Threading.Thread?displayProperty=fullName&gt;</ph>) can run in one or any number of application domains within the same managed process.","pos":[1301,1486],"source":" One or more managed threads (represented by <xref:System.Threading.Thread?displayProperty=fullName>) can run in one or any number of application domains within the same managed process."},{"content":"Although each application domain is started with a single thread, code in that application domain can create additional application domains and additional threads.","pos":[1487,1650]},{"content":"The result is that a managed thread can move freely between application domains inside the same managed process; you might have only one thread moving among several application domains.","pos":[1651,1836]},{"content":"An operating system that supports preemptive multitasking creates the effect of simultaneous execution of multiple threads from multiple processes.","pos":[1843,1990]},{"content":"It does this by dividing the available processor time among the threads that need it, allocating a processor time slice to each thread one after another.","pos":[1991,2144]},{"content":"The currently executing thread is suspended when its time slice elapses, and another thread resumes running.","pos":[2145,2253]},{"content":"When the system switches from one thread to another, it saves the thread context of the preempted thread and reloads the saved thread context of the next thread in the thread queue.","pos":[2254,2435]},{"content":"The length of the time slice depends on the operating system and the processor.","pos":[2442,2521]},{"content":"Because each time slice is small, multiple threads appear to be executing at the same time, even if there is only one processor.","pos":[2522,2650]},{"content":"This is actually the case on multiprocessor systems, where the executable threads are distributed among the available processors.","pos":[2651,2780]},{"pos":[2789,2817],"content":"When To Use Multiple Threads","linkify":"When To Use Multiple Threads","nodes":[{"content":"When To Use Multiple Threads","pos":[0,28]}]},{"content":"Software that requires user interaction must react to the user's activities as rapidly as possible to provide a rich user experience.","pos":[2821,2954]},{"content":"At the same time, however, it must do the calculations necessary to present data to the user as fast as possible.","pos":[2955,3068]},{"content":"If your application uses only one thread of execution, you can combine <bpt id=\"p1\">[</bpt>asynchronous programming<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept> with<bpt id=\"p2\">[</bpt>.NET Framework remoting<ept id=\"p2\">](http://msdn.microsoft.com/en-us/eccb1d31-0a22-417a-97fd-f4f1f3aa4462)</ept> or <bpt id=\"p3\">[</bpt>XML Web services<ept id=\"p3\">](http://msdn.microsoft.com/en-us/1e64af78-d705-4384-b08d-591a45f4379c)</ept> created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application.","pos":[3069,3660],"source":" If your application uses only one thread of execution, you can combine [asynchronous programming](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) with[.NET Framework remoting](http://msdn.microsoft.com/en-us/eccb1d31-0a22-417a-97fd-f4f1f3aa4462) or [XML Web services](http://msdn.microsoft.com/en-us/1e64af78-d705-4384-b08d-591a45f4379c) created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application."},{"content":"If you are doing intensive input/output work, you can also use I/O completion ports to increase your application's responsiveness.","pos":[3661,3791]},{"pos":[3801,3831],"content":"Advantages of Multiple Threads","linkify":"Advantages of Multiple Threads","nodes":[{"content":"Advantages of Multiple Threads","pos":[0,30]}]},{"content":"Using more than one thread, however, is the most powerful technique available to increase responsiveness to the user and process the data necessary to get the job done at almost the same time.","pos":[3835,4027]},{"content":"On a computer with one processor, multiple threads can create this effect, taking advantage of the small periods of time in between user events to process the data in the background.","pos":[4028,4210]},{"content":"For example, a user can edit a spreadsheet while another thread is recalculating other parts of the spreadsheet within the same application.","pos":[4211,4351]},{"content":"Without modification, the same application would dramatically increase user satisfaction when run on a computer with more than one processor.","pos":[4358,4499]},{"content":"Your single application domain could use multiple threads to accomplish the following tasks:","pos":[4500,4592]},{"content":"Communicate over a network, to a Web server, and to a database.","pos":[4602,4665]},{"content":"Perform operations that take a large amount of time.","pos":[4675,4727]},{"content":"Distinguish tasks of varying priority.","pos":[4737,4775]},{"content":"For example, a high-priority thread manages time-critical tasks, and a low-priority thread performs other tasks.","pos":[4776,4888]},{"content":"Allow the user interface to remain responsive, while allocating time to background tasks.","pos":[4898,4987]},{"pos":[4997,5030],"content":"Disadvantages of Multiple Threads","linkify":"Disadvantages of Multiple Threads","nodes":[{"content":"Disadvantages of Multiple Threads","pos":[0,33]}]},{"content":"It is recommended that you use as few threads as possible, thereby minimizing the use of operating-system resources and improving performance.","pos":[5034,5176]},{"content":"Threading also has resource requirements and potential conflicts to be considered when designing your application.","pos":[5177,5291]},{"content":"The resource requirements are as follows:","pos":[5292,5333]},{"content":"The system consumes memory for the context information required by processes, <bpt id=\"p1\">**</bpt>AppDomain<ept id=\"p1\">**</ept> objects, and threads.","pos":[5343,5456],"source":"The system consumes memory for the context information required by processes, **AppDomain** objects, and threads."},{"content":"Therefore, the number of processes, <bpt id=\"p1\">**</bpt>AppDomain<ept id=\"p1\">**</ept> objects, and threads that can be created is limited by available memory.","pos":[5457,5579],"source":" Therefore, the number of processes, **AppDomain** objects, and threads that can be created is limited by available memory."},{"content":"Keeping track of a large number of threads consumes significant processor time.","pos":[5589,5668]},{"content":"If there are too many threads, most of them will not make significant progress.","pos":[5669,5748]},{"content":"If most of the current threads are in one process, threads in other processes are scheduled less frequently.","pos":[5749,5857]},{"content":"Controlling code execution with many threads is complex, and can be a source of many bugs.","pos":[5867,5957]},{"content":"Destroying threads requires knowing what could happen and handling those issues.","pos":[5967,6047]},{"content":"Providing shared access to resources can create conflicts.","pos":[6054,6112]},{"content":"To avoid conflicts, you must synchronize, or control the access to, shared resources.","pos":[6113,6198]},{"content":"Failure to synchronize access properly (in the same or different application domains) can lead to problems such as deadlocks (in which two threads stop responding while each waits for the other to complete) and race conditions (when an anomalous result occurs due to an unexpected critical dependence on the timing of two events).","pos":[6199,6529]},{"content":"The system provides synchronization objects that can be used to coordinate resource sharing among multiple threads.","pos":[6530,6645]},{"content":"Reducing the number of threads makes it easier to synchronize resources.","pos":[6646,6718]},{"content":"Resources that require synchronization include:","pos":[6725,6772]},{"content":"System resources (such as communications ports).","pos":[6782,6830]},{"content":"Resources shared by multiple processes (such as file handles).","pos":[6840,6902]},{"content":"The resources of a single application domain (such as global, static, and instance fields) accessed by multiple threads.","pos":[6912,7032]},{"pos":[7042,7074],"content":"Threading and Application Design","linkify":"Threading and Application Design","nodes":[{"content":"Threading and Application Design","pos":[0,32]}]},{"content":"In general, using the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks.","pos":[7078,7314],"source":"In general, using the <xref:System.Threading.ThreadPool> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks."},{"content":"However, there are a number of reasons to create your own threads:","pos":[7315,7381]},{"content":"If you need a task to have a particular priority.","pos":[7391,7440]},{"content":"If you have a task that might run a long time (and therefore block other tasks).","pos":[7450,7530]},{"pos":[7540,7666],"content":"If you need to place threads into a single-threaded apartment (all <bpt id=\"p1\">**</bpt>ThreadPool<ept id=\"p1\">**</ept> threads are in the multithreaded apartment).","source":"If you need to place threads into a single-threaded apartment (all **ThreadPool** threads are in the multithreaded apartment)."},{"content":"If you need a stable identity associated with the thread.","pos":[7676,7733]},{"content":"For example, you should use a dedicated thread to abort that thread, suspend it, or discover it by name.","pos":[7734,7838]},{"content":"If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> component that communicates using events, with cross-thread marshaling to the user-interface thread.","pos":[7848,8113],"source":"If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <xref:System.ComponentModel.BackgroundWorker> component that communicates using events, with cross-thread marshaling to the user-interface thread."},{"pos":[8123,8147],"content":"Threading and Exceptions","linkify":"Threading and Exceptions","nodes":[{"content":"Threading and Exceptions","pos":[0,24]}]},{"content":"Do handle exceptions in threads.","pos":[8151,8183]},{"content":"Unhandled exceptions in threads, even background threads, generally terminate the process.","pos":[8184,8274]},{"content":"There are three exceptions to this rule:","pos":[8275,8315]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is thrown in a thread because <ph id=\"ph2\">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> was called.","pos":[8325,8453],"source":"A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called."},{"content":"An <ph id=\"ph1\">&lt;xref:System.AppDomainUnloadedException&gt;</ph> is thrown in a thread because the application domain is being unloaded.","pos":[8463,8578],"source":"An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain is being unloaded."},{"content":"The common language runtime or a host process terminates the thread.","pos":[8588,8656]},{"pos":[8663,8788],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exceptions in Managed Threads<ept id=\"p1\">](../../../docs/standard/threading/exceptions-in-managed-threads.md)</ept>.","source":"For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md)."},{"pos":[8796,9064],"content":"[!NOTE]\n In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads. This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.","leadings":["","> "],"nodes":[{"content":" In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads. This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.","pos":[8,266],"nodes":[{"content":"In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads.","pos":[1,140]},{"content":"This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.","pos":[141,258]}]}]},{"pos":[9073,9081],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph>","pos":[9085,9119],"source":"<xref:System.Threading.ThreadPool> "},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>","pos":[9124,9169],"source":" <xref:System.ComponentModel.BackgroundWorker> "},{"content":"<bpt id=\"p1\"> [</bpt>Synchronizing Data for Multithreading<ept id=\"p1\">](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)</ept><ph id=\"ph1\"> </ph>","pos":[9173,9289],"source":" [Synchronizing Data for Multithreading](../../../docs/standard/threading/synchronizing-data-for-multithreading.md) "},{"content":"<bpt id=\"p1\"> [</bpt>The Managed Thread Pool<ept id=\"p1\">](../../../docs/standard/threading/the-managed-thread-pool.md)</ept>","pos":[9292,9379],"source":" [The Managed Thread Pool](../../../docs/standard/threading/the-managed-thread-pool.md)"}]}