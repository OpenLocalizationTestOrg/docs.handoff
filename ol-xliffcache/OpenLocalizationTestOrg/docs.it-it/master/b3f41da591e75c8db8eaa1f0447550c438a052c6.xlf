<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="the-regular-expression-object-model.md" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b2a8af3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b3f41da591e75c8db8eaa1f0447550c438a052c6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\the-regular-expression-object-model.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5d8fa1d31a407279e8542b26d17da859ffe60d2e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d48430388506a8ce5085bb00b0bd4aea29f6cafb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>The Regular Expression Object Model | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>The Regular Expression Object Model</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="introduction"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> This topic describes the object model used in working with .NET regular expressions.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The Regular Expression Engine<ept id="p1">](#Engine)</ept></source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The MatchCollection and Match Objects<ept id="p1">](#Match_and_MCollection)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The Group Collection<ept id="p1">](#GroupCollection)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The Captured Group<ept id="p1">](#the_captured_group)</ept></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The Capture Collection<ept id="p1">](#CaptureCollection)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The Individual Capture<ept id="p1">](#the_individual_capture)</ept></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The Regular Expression Engine</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The regular expression engine in .NET is represented by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The regular expression engine is responsible for parsing and compiling a regular expression, and for performing operations that match the regular expression pattern with an input string.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The engine is the central component in the .NET regular expression object model.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can use the regular expression engine in either of two ways:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By calling the static methods of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The method parameters include the input string and the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The regular expression engine caches regular expressions that are used in static method calls, so repeated calls to static regular expression methods that use the same regular expression offer relatively good performance.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>By instantiating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object, by passing a regular expression to the class constructor.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable (read-only) and represents a regular expression engine that is tightly coupled with a single regular expression.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Because regular expressions used by <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instances are not cached, you should not instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object multiple times with the same regular expression.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can call the methods of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class to perform the following operations:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Determine whether a string matches a regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Extract a single match or the first match.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Extract all matches.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Replace a matched substring.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Split a single string into an array of strings.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>These operations are described in the following sections.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Matching a Regular Expression Pattern</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method returns <ph id="ph2">`true`</ph> if the string matches the pattern, or <ph id="ph3">`false`</ph> if it does not.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is often used to validate string input.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, the following code ensures that a string matches a valid social security number in the United States.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#1<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/validate1.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#1<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/validate1.vb#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^\d{3}-\d{2}-\d{4}$`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Match the beginning of the input string.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Match three decimal digits.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Match a hyphen.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Match a hyphen.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Extracting a Single Match or the First Match</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=fullName&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that contains information about the first substring that matches a regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Match.Success`</ph> property returns <ph id="ph2">`true`</ph>, indicating that a match was found, you can retrieve information about subsequent matches by calling the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>These method calls can continue until the <ph id="ph1">`Match.Success`</ph> property returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For example, the following code uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=fullName&gt;</ph> method to find the first occurrence of a duplicated word in a string.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=fullName&gt;</ph> method to find any additional occurrences.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The example examines the <ph id="ph1">`Match.Success`</ph> property after each method call to determine whether the current match was successful and whether a call to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=fullName&gt;</ph> method should follow.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#2<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/match1.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#2<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/match1.vb#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\w+)\W+(\1)\b`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Begin the match on a word boundary.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Match one or more non-word characters.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Match the first captured string.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Extracting All Matches</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=fullName&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object that contains information about all matches that the regular expression engine found in the input string.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example, the previous example could be rewritten to call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method instead of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#3<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/matches1.cs#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#3<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/matches1.vb#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Replacing a Matched Substring</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=fullName&gt;</ph> method replaces each substring that matches the regular expression pattern with a specified string or regular expression pattern, and returns the entire input string with replacements.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, the following code adds a U.S. currency symbol before a decimal number in a string.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#4<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/replace1.cs#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#4<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/replace1.vb#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\d+\.\d{2}\b`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The replacement pattern <ph id="ph1">`$$$&amp;`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Replacement string</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The dollar sign ($) character.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The entire matched substring.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Splitting a Single String into an Array of Strings</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName&gt;</ph> method splits the input string at the positions defined by a regular expression match.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, the following code places the items in a numbered list into a string array.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/split1.cs#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#5<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/split1.vb#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\d{1,2}\.\s`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Match one or two decimal digits.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The MatchCollection and Match Objects</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Regex methods return two objects that are part of the regular expression object model: the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object, and the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The Match Collection</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=fullName&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object that contains <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects that represent all the matches that the regular expression engine found, in the order in which they occur in the input string.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If there are no matches, the method returns a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object with no members.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A?displayProperty=fullName&gt;</ph> property lets you access individual members of the collection by index, from zero to one less than the value of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A&gt;</ph> is the collection's indexer (in C#) and default property (in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>By default, the call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=fullName&gt;</ph> method uses lazy evaluation to populate the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Access to properties that require a fully populated collection, such as the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A?displayProperty=fullName&gt;</ph> properties, may involve a performance penalty.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>As a result, we recommend that you access the collection by using the <ph id="ph1">&lt;xref:System.Collections.IEnumerator&gt;</ph> object that is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Individual languages provide constructs, such as <ph id="ph1">`For``Each`</ph> in Visual Basic and <ph id="ph2">`foreach`</ph> in C#, that wrap the collection's <ph id="ph3">&lt;xref:System.Collections.IEnumerator&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=fullName&gt;</ph> method to populate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object with all the matches found in an input string.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The example enumerates the collection, copies the matches to a string array, and records the character positions in an integer array.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#6<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/matchcollection1.cs#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#6<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/matchcollection1.vb#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The Match</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> class represents the result of a single regular expression match.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>You can access <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in two ways:</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>By retrieving them from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object that is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>To retrieve individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects, iterate the collection by using a <ph id="ph2">`foreach`</ph> (in C#) or <ph id="ph3">`For Each`</ph>...<ph id="ph4">`Next`</ph> (in Visual Basic) construct, or use the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A?displayProperty=fullName&gt;</ph> property to retrieve a specific <ph id="ph6">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object either by index or by name.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>You can also retrieve individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects from the collection by iterating the collection by index, from zero to one less that the number of objects in the collection.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>However, this method does not take advantage of lazy evaluation, because it accesses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The following example retrieves individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects from a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object by iterating the collection using the <ph id="ph3">`foreach`</ph> or <ph id="ph4">`For Each`</ph>...<ph id="ph5">`Next`</ph> construct.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The regular expression simply matches the string "abc" in the input string.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#7<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/match2.cs#7)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#7<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/match2.vb#7)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>By calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=fullName&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that represents the first match in a string or a portion of a string.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>You can determine whether the match has been found by retrieving the value of the <ph id="ph1">`Match.Success`</ph> property.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>To retrieve <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects that represent subsequent matches, call the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=fullName&gt;</ph> method repeatedly, until the <ph id="ph3">`Success`</ph> property of the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object is <ph id="ph5">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=fullName&gt;</ph> methods to match the string "abc" in the input string.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#8<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/match3.cs#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#8<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/match3.vb#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Two properties of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> class return collection objects:</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=fullName&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object that contains information about the substrings that match capturing groups in the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Match.Captures`</ph> property returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> object that is of limited use.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The collection is not populated for a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object whose <ph id="ph2">`Success`</ph> property is <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Otherwise, it contains a single <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture&gt;</ph> object that has the same information as the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For more information about these objects, see the <bpt id="p1">[</bpt>The Group Collection<ept id="p1">](#GroupCollection)</ept> and <bpt id="p2">[</bpt>The Capture Collection<ept id="p2">](#CaptureCollection)</ept> sections later in this topic.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Two additional properties of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> class provide information about the match.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Match.Value`</ph> property returns the substring in the input string that matches the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Match.Index`</ph> property returns the zero-based starting position of the matched string in the input string.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> class also has two pattern-matching methods:</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=fullName&gt;</ph> method finds the match after the match represented by the current <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object, and returns a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that represents that match.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=fullName&gt;</ph> method performs a specified replacement operation on the matched string and returns the result.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=fullName&gt;</ph> method to prepend a $ symbol and a space before every number that includes two fractional digits.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#9<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/result1.cs#9)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#9<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/result1.vb#9)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\d+(,\d{3})*\.\d{2}\b`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of a comma followed by three decimal digits.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Match the decimal point character.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The replacement pattern <ph id="ph1">`$$ $&amp;`</ph> indicates that the matched substring should be replaced by a dollar sign ($) symbol (the <ph id="ph2">`$$`</ph> pattern), a space, and the value of the match (the <ph id="ph3">`$&amp;`</ph> pattern).</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#introduction)</ept></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The Group Collection</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=fullName&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object that contains <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> objects that represent captured groups in a single match.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object in the collection (at index 0) represents the entire match.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Each object that follows represents the results of a single capturing group.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>You can retrieve individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> objects in the collection by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>You can retrieve unnamed groups by their ordinal position in the collection, and retrieve named groups either by name or by ordinal position.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Unnamed captures appear first in the collection, and are indexed from left to right in the order in which they appear in the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Named captures are indexed after unnamed captures, from left to right in the order in which they appear in the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>To determine what numbered groups are available in the collection returned for a particular regular expression matching method, you can call the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>To determine what named groups are available in the collection, you can call the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNames%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Both methods are particularly useful in general-purpose routines that analyze the matches found by any regular expression.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=fullName&gt;</ph> property is the indexer of the collection in C# and the collection object's default property in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>This means that individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> objects can be accessed by index (or by name, in the case of named groups) as follows:</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#13<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/groupsyntax1.cs#13)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#13<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/groupsyntax1.vb#13)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses grouping constructs to capture the month, day, and year of a date.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#10<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/groupcollection1.cs#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#10<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/groupcollection1.vb#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\w+)\s(\d{1,2}),\s(\d{4})\b`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Match one or two decimal digits.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Match a comma.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#introduction)</ept></source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The Captured Group</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> class represents the result from a single capturing group.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Group objects that represent the capturing groups defined in a regular expression are returned by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object returned by the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A&gt;</ph> property is the indexer (in C#) and the default property (in Visual Basic) of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can also retrieve individual members by iterating the collection using the <ph id="ph1">`foreach`</ph> or <ph id="ph2">`For``Each`</ph> construct.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>For an example, see the previous section.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The following example uses nested grouping constructs to capture substrings into groups.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(a(b))c`</ph> matches the string "abc".</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>It assigns the substring "ab" to the first capturing group, and the substring "b" to the second capturing group.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>RegularExpressions.Classes#6<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Classes/cs/Example.cs#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>RegularExpressions.Classes#6<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Classes/vb/Example.vb#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The following example uses named grouping constructs to capture substrings from a string that contains data in the format "DATANAME:VALUE", which the regular expression splits at the colon (:).</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>RegularExpressions.Classes#8<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Classes/cs/Example.cs#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>RegularExpressions.Classes#8<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Classes/vb/Example.vb#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(?&lt;name&gt;\w+):(?&lt;value&gt;\w+)`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The name of this capturing group is <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match a colon.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The name of this capturing group is <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The properties of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> class provide information about the captured group: The <ph id="ph2">`Group.Value`</ph> property contains the captured substring, the <ph id="ph3">`Group.Index`</ph> property indicates the starting position of the captured group in the input text, the <ph id="ph4">`Group.Length`</ph> property contains the length of the captured text, and the <ph id="ph5">`Group.Success`</ph> property indicates whether a substring matched the pattern defined by the capturing group.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Applying quantifiers to a group (for more information, see <bpt id="p1">[</bpt>Quantifiers<ept id="p1">](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)</ept>) modifies the relationship of one capture per capturing group in two ways:</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`*`</ph> or <ph id="ph2">`*?`</ph> quantifier (which specifies zero or more matches) is applied to a group, a capturing group may not have a match in the input string.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>When there is no captured text, the properties of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object are set as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Group property</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>In the regular expression pattern <ph id="ph1">`aaa(bbb)*ccc`</ph>, the first capturing group (the substring "bbb") can be matched zero or more times.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Because the input string "aaaccc" matches the pattern, the capturing group does not have a match.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#11<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/nocapture1.cs#11)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#11<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/nocapture1.vb#11)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Quantifiers can match multiple occurrences of a pattern that is defined by a capturing group.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">`Value`</ph> and <ph id="ph2">`Length`</ph> properties of a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object contain information only about the last captured substring.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>For example, the following regular expression matches a single sentence that ends in a period.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>It uses two grouping constructs: The first captures individual words along with a white-space character; the second captures individual words.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, although the regular expression succeeds in capturing an entire sentence, the second capturing group captures only the last word.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#12<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/lastcapture1.cs#12)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#12<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/lastcapture1.vb#12)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#introduction)</ept></source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The Capture Collection</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object contains information only about the last capture.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>However, the entire set of captures made by a capturing group is still available from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> object that is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Each member of the collection is a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture&gt;</ph> object that represents a capture made by that capturing group, in the order in which they were captured (and, therefore, in the order in which the captured strings were matched from left to right in the input string).</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>You can retrieve individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture&gt;</ph> objects from the collection in either of two ways:</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>By iterating through the collection using a construct such as <ph id="ph1">`foreach`</ph> (in C#) or <ph id="ph2">`For``Each`</ph> (in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>By using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.CaptureCollection.Item%2A?displayProperty=fullName&gt;</ph> property to retrieve a specific object by index.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.CaptureCollection.Item%2A&gt;</ph> property is the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> object's default property (in Visual Basic) or indexer (in C#).</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>If a quantifier is not applied to a capturing group, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> object contains a single <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture&gt;</ph> object that is of little interest, because it provides information about the same match as its <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>If a quantifier is applied to a capturing group, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> object contains all captures made by the capturing group, and the last member of the collection represents the same capture as the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For example, if you use the regular expression pattern <ph id="ph1">`((a(b))c)+`</ph> (where the + quantifier specifies one or more matches) to capture matches from the string "abcabcabc", the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> object for each <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object contains three members.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#14<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/capturecollection1.cs#14)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#14<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/capturecollection1.vb#14)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The following example uses the regular expression <ph id="ph1">`(Abc)+`</ph> to find one or more consecutive runs of the string "Abc" in the string "XYZAbcAbcAbcXYZAbcAb".</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=fullName&gt;</ph> property to return multiple groups of captured substrings.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>RegularExpressions.Classes#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Classes/cs/Example.cs#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>RegularExpressions.Classes#5<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Classes/vb/Example.vb#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#introduction)</ept></source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The Individual Capture</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture&gt;</ph> class contains the results from a single subexpression capture.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=fullName&gt;</ph> property contains the matched text, and the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=fullName&gt;</ph> property indicates the zero-based position in the input string at which the matched substring begins.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The following example parses an input string for the temperature of selected cities.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A comma (",") is used to separate a city and its temperature, and a semicolon (";") is used to separate each city's data.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The entire input string represents a single match.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>In the regular expression pattern <ph id="ph1">`((\w+(\s\w+)*),(\d+);)+`</ph>, which is used to parse the string, the city name is assigned to the second capturing group, and the temperature is assigned to the fourth capturing group.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#16<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/cs/capture1.cs#16)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.ObjectModel#16<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.objectmodel/vb/capture1.vb#16)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The regular expression is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of a white-space character followed by one or more word characters.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>This pattern matches multi-word city names.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by zero or more occurrences of a white-space character and one or more word characters.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Match a comma.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Match one or more digits.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>This is the fourth capturing group.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Match a semicolon.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Match the pattern of a word followed by any additional words followed by a comma, one or more digits, and a semicolon, one or more times.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions&gt;</ph></source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET Regular Expressions<ept id="p1">](../../../docs/standard/base-types/regular-expressions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>