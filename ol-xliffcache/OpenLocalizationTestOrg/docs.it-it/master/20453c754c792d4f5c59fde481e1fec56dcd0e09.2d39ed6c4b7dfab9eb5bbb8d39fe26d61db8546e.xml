{"content":"---\ntitle: \"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)\"\nms.date: 07/20/2015\nms.assetid: 20c8a917-0552-4514-b489-0b8b6a4c3b4c\n---\n# How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)\nThis example shows five queries related to file size in bytes:  \n  \n-   How to retrieve the size in bytes of the largest file.  \n  \n-   How to retrieve the size in bytes of the smallest file.  \n  \n-   How to retrieve the <xref:System.IO.FileInfo> object largest or smallest file from one or more folders under a specified root folder.  \n  \n-   How to retrieve a sequence such as the 10 largest files.  \n  \n-   How to order files into groups based on their file size in bytes, ignoring files that are less than a specified size.  \n  \n## Example  \n The following example contains five separate queries that show how to query and group files, depending on their file size in bytes. You can easily modify these examples to base the query on some other property of the <xref:System.IO.FileInfo> object.  \n  \n```csharp  \nclass QueryBySize  \n{  \n    static void Main(string[] args)  \n    {  \n        QueryFilesBySize();  \n        Console.WriteLine(\"Press any key to exit\");  \n        Console.ReadKey();  \n    }  \n  \n    private static void QueryFilesBySize()  \n    {  \n        string startFolder = @\"c:\\program files\\Microsoft Visual Studio 9.0\\\";  \n  \n        // Take a snapshot of the file system.  \n        System.IO.DirectoryInfo dir = new System.IO.DirectoryInfo(startFolder);  \n  \n        // This method assumes that the application has discovery permissions  \n        // for all folders under the specified path.  \n        IEnumerable<System.IO.FileInfo> fileList = dir.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);  \n  \n        //Return the size of the largest file  \n        long maxSize =  \n            (from file in fileList  \n             let len = GetFileLength(file)  \n             select len)  \n             .Max();  \n  \n        Console.WriteLine(\"The length of the largest file under {0} is {1}\",  \n            startFolder, maxSize);  \n  \n        // Return the FileInfo object for the largest file  \n        // by sorting and selecting from beginning of list  \n        System.IO.FileInfo longestFile =  \n            (from file in fileList  \n             let len = GetFileLength(file)  \n             where len > 0  \n             orderby len descending  \n             select file)  \n            .First();  \n  \n        Console.WriteLine(\"The largest file under {0} is {1} with a length of {2} bytes\",  \n                            startFolder, longestFile.FullName, longestFile.Length);  \n  \n        //Return the FileInfo of the smallest file  \n        System.IO.FileInfo smallestFile =  \n            (from file in fileList  \n             let len = GetFileLength(file)  \n             where len > 0  \n             orderby len ascending  \n             select file).First();  \n  \n        Console.WriteLine(\"The smallest file under {0} is {1} with a length of {2} bytes\",  \n                            startFolder, smallestFile.FullName, smallestFile.Length);  \n  \n        //Return the FileInfos for the 10 largest files  \n        // queryTenLargest is an IEnumerable<System.IO.FileInfo>  \n        var queryTenLargest =  \n            (from file in fileList  \n             let len = GetFileLength(file)  \n             orderby len descending  \n             select file).Take(10);  \n  \n        Console.WriteLine(\"The 10 largest files under {0} are:\", startFolder);  \n  \n        foreach (var v in queryTenLargest)  \n        {  \n            Console.WriteLine(\"{0}: {1} bytes\", v.FullName, v.Length);  \n        }  \n  \n        // Group the files according to their size, leaving out  \n        // files that are less than 200000 bytes.   \n        var querySizeGroups =  \n            from file in fileList  \n            let len = GetFileLength(file)  \n            where len > 0  \n            group file by (len / 100000) into fileGroup  \n            where fileGroup.Key >= 2  \n            orderby fileGroup.Key descending  \n            select fileGroup;  \n  \n        foreach (var filegroup in querySizeGroups)  \n        {  \n            Console.WriteLine(filegroup.Key.ToString() + \"00000\");  \n            foreach (var item in filegroup)  \n            {  \n                Console.WriteLine(\"\\t{0}: {1}\", item.Name, item.Length);  \n            }  \n        }  \n    }  \n  \n    // This method is used to swallow the possible exception  \n    // that can be raised when accessing the FileInfo.Length property.  \n    // In this particular case, it is safe to swallow the exception.  \n    static long GetFileLength(System.IO.FileInfo fi)  \n    {  \n        long retval;  \n        try  \n        {  \n            retval = fi.Length;  \n        }  \n        catch (System.IO.FileNotFoundException)  \n        {  \n            // If a file is no longer present,  \n            // just add zero bytes to the total.  \n            retval = 0;  \n        }  \n        return retval;  \n    }  \n  \n}  \n```  \n  \n To return one or more complete <xref:System.IO.FileInfo> objects, the query first must examine each one in the data source, and then sort them by the value of their Length property. Then it can return the single one or the sequence with the greatest lengths. Use <xref:System.Linq.Enumerable.First%2A> to return the first element in a list. Use <xref:System.Linq.Enumerable.Take%2A> to return the first n number of elements. Specify a descending sort order to put the smallest elements at the start of the list.  \n  \n The query calls out to a separate method to obtain the file size in bytes in order to consume the possible exception that will be raised in the case where a file was deleted on another thread in the time period since the <xref:System.IO.FileInfo> object was created in the call to `GetFiles`. Even through the <xref:System.IO.FileInfo> object has already been created, the exception can occur because a <xref:System.IO.FileInfo> object will try to refresh its <xref:System.IO.FileInfo.Length%2A> property by using the most current size in bytes the first time the property is accessed. By putting this operation in a try-catch block outside the query, we follow the rule of avoiding operations in queries that can cause side-effects. In general, great care must be taken when consuming exceptions, to make sure that an application is not left in an unknown state.  \n  \n## Compiling the Code  \n Create a project that targets the .NET Framework  version 3.5 or higher, with a reference to System.Core.dll and `using` directives for the System.Linq and System.IO namespaces.  \n  \n## See also\n\n- [LINQ to Objects (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-objects.md)\n- [LINQ and File Directories (C#)](../../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)\n","nodes":[{"pos":[4,157],"embed":true,"restype":"x-metadata","content":"title: \"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)\"\nms.date: 07/20/2015\nms.assetid: 20c8a917-0552-4514-b489-0b8b6a4c3b4c","nodes":[{"content":"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)","nodes":[{"pos":[0,75],"content":"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)","nodes":[{"content":"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)","pos":[0,75]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[164,239],"content":"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)","linkify":"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)","nodes":[{"content":"How to: Query for the Largest File or Files in a Directory Tree (LINQ) (C#)","pos":[0,75]}]},{"content":"This example shows five queries related to file size in bytes:","pos":[240,302]},{"content":"How to retrieve the size in bytes of the largest file.","pos":[312,366]},{"content":"How to retrieve the size in bytes of the smallest file.","pos":[376,431]},{"pos":[441,574],"content":"How to retrieve the <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> object largest or smallest file from one or more folders under a specified root folder.","source":"How to retrieve the <xref:System.IO.FileInfo> object largest or smallest file from one or more folders under a specified root folder."},{"content":"How to retrieve a sequence such as the 10 largest files.","pos":[584,640]},{"content":"How to order files into groups based on their file size in bytes, ignoring files that are less than a specified size.","pos":[650,767]},{"pos":[776,783],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example contains five separate queries that show how to query and group files, depending on their file size in bytes.","pos":[787,918]},{"content":"You can easily modify these examples to base the query on some other property of the <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> object.","pos":[919,1037],"source":" You can easily modify these examples to base the query on some other property of the <xref:System.IO.FileInfo> object."},{"content":"To return one or more complete <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> objects, the query first must examine each one in the data source, and then sort them by the value of their Length property.","pos":[5027,5208],"source":"To return one or more complete <xref:System.IO.FileInfo> objects, the query first must examine each one in the data source, and then sort them by the value of their Length property."},{"content":"Then it can return the single one or the sequence with the greatest lengths.","pos":[5209,5285]},{"content":"Use <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.First%2A&gt;</ph> to return the first element in a list.","pos":[5286,5367],"source":" Use <xref:System.Linq.Enumerable.First%2A> to return the first element in a list."},{"content":"Use <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> to return the first n number of elements.","pos":[5368,5451],"source":" Use <xref:System.Linq.Enumerable.Take%2A> to return the first n number of elements."},{"content":"Specify a descending sort order to put the smallest elements at the start of the list.","pos":[5452,5538]},{"content":"The query calls out to a separate method to obtain the file size in bytes in order to consume the possible exception that will be raised in the case where a file was deleted on another thread in the time period since the <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> object was created in the call to <ph id=\"ph2\">`GetFiles`</ph>.","pos":[5545,5837],"source":"The query calls out to a separate method to obtain the file size in bytes in order to consume the possible exception that will be raised in the case where a file was deleted on another thread in the time period since the <xref:System.IO.FileInfo> object was created in the call to `GetFiles`."},{"content":"Even through the <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> object has already been created, the exception can occur because a <ph id=\"ph2\">&lt;xref:System.IO.FileInfo&gt;</ph> object will try to refresh its <ph id=\"ph3\">&lt;xref:System.IO.FileInfo.Length%2A&gt;</ph> property by using the most current size in bytes the first time the property is accessed.","pos":[5838,6130],"source":" Even through the <xref:System.IO.FileInfo> object has already been created, the exception can occur because a <xref:System.IO.FileInfo> object will try to refresh its <xref:System.IO.FileInfo.Length%2A> property by using the most current size in bytes the first time the property is accessed."},{"content":"By putting this operation in a try-catch block outside the query, we follow the rule of avoiding operations in queries that can cause side-effects.","pos":[6131,6278]},{"content":"In general, great care must be taken when consuming exceptions, to make sure that an application is not left in an unknown state.","pos":[6279,6408]},{"pos":[6417,6435],"content":"Compiling the Code","linkify":"Compiling the Code","nodes":[{"content":"Compiling the Code","pos":[0,18]}]},{"pos":[6439,6616],"content":"Create a project that targets the .NET Framework  version 3.5 or higher, with a reference to System.Core.dll and <ph id=\"ph1\">`using`</ph> directives for the System.Linq and System.IO namespaces.","source":"Create a project that targets the .NET Framework  version 3.5 or higher, with a reference to System.Core.dll and `using` directives for the System.Linq and System.IO namespaces."},{"pos":[6625,6633],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6637,6730],"content":"<bpt id=\"p1\">[</bpt>LINQ to Objects (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/linq-to-objects.md)</ept>","source":"[LINQ to Objects (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-objects.md)"},{"pos":[6733,6846],"content":"<bpt id=\"p1\">[</bpt>LINQ and File Directories (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)</ept>","source":"[LINQ and File Directories (C#)](../../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)"}]}