{"content":"---\ntitle: \"Creating Prototypes in Managed Code\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\n  - \"cpp\"\nhelpviewer_keywords: \n  - \"prototypes in managed code\"\n  - \"COM interop, DLL functions\"\n  - \"unmanaged functions\"\n  - \"platform invoke, creating prototypes\"\n  - \"COM interop, platform invoke\"\n  - \"interoperation with unmanaged code, DLL functions\"\n  - \"interoperation with unmanaged code, platform invoke\"\n  - \"platform invoke, object fields\"\n  - \"DLL functions\"\n  - \"object fields in platform invoke\"\nms.assetid: ecdcf25d-cae3-4f07-a2b6-8397ac6dc42d\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Creating Prototypes in Managed Code\nThis topic describes how to access unmanaged functions and introduces several attribute fields that annotate method definition in managed code. For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see [Marshaling Data with Platform Invoke](marshaling-data-with-platform-invoke.md).  \n  \n Before you can access an unmanaged DLL function from managed code, you need to know the name of the function and the name of the DLL that exports it. With this information, you can begin to write the managed definition for an unmanaged function that is implemented in a DLL. Furthermore, you can adjust the way that platform invoke creates the function and marshals data to and from the function.  \n  \n> [!NOTE]\n>  Windows API functions that allocate a string enable you to free the string by using a method such as `LocalFree`. Platform invoke handles such parameters differently. For platform invoke calls, make the parameter an `IntPtr` type instead of a `String` type. Use methods that are provided by the <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> class to convert the type to a string manually and free it manually.  \n  \n## Declaration Basics  \n Managed definitions to unmanaged functions are language-dependent, as you can see in the following examples. For more complete code examples, see [Platform Invoke Examples](platform-invoke-examples.md).  \n  \n```vb\nImports System\n\nFriend Class WindowsAPI\n    Friend Shared Declare Auto Function MessageBox Lib \"user32.dll\" (\n        ByVal hWnd As IntPtr,\n        ByVal lpText As String,\n        ByVal lpCaption As String,\n        ByVal uType As UInteger) As Integer\nEnd Class\n```\n  \n To apply the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, or <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields to a [!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] declaration, you must use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute instead of the `Declare` statement.  \n  \n```vb\nImports System\nImports System.Runtime.InteropServices\n\nFriend Class WindowsAPI\n    <DllImport(\"user32.dll\", CharSet:=CharSet.Auto)>\n    Friend Shared Function MessageBox(\n        ByVal hWnd As IntPtr,\n        ByVal lpText As String,\n        ByVal lpCaption As String,\n        ByVal uType As UInteger) As Integer\n    End Function\nEnd Class\n```\n  \n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\ninternal static class WindowsAPI\n{\n    [DllImport(\"user32.dll\")]\n    internal static extern int MessageBox(\n        IntPtr hWnd, string lpText, string lpCaption, uint uType);\n}\n```\n  \n```cpp\nusing namespace System;\nusing namespace System::Runtime::InteropServices;\n\n[DllImport(\"user32.dll\")]\nextern \"C\" int MessageBox(\n    IntPtr hWnd, String* lpText, String* lpCaption, unsigned int uType);\n```\n  \n## Adjusting the Definition  \n Whether you set them explicitly or not, attribute fields are at work defining the behavior of managed code. Platform invoke operates according to the default values set on various fields that exist as metadata in an assembly. You can alter this default behavior by adjusting the values of one or more fields. In many cases, you use the <xref:System.Runtime.InteropServices.DllImportAttribute> to set a value.  \n  \n The following table lists the complete set of attribute fields that pertain to platform invoke. For each field, the table includes the default value and a link to information on how to use these fields to define unmanaged DLL functions.  \n  \n|Field|Description|  \n|-----------|-----------------|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>|Enables or disables best-fit mapping.|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>|Specifies the calling convention to use in passing method arguments. The default is `WinAPI`, which corresponds to `__stdcall` for the 32-bit Intel-based platforms.|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.CharSet>|Controls name mangling and the way that string arguments should be marshaled to the function. The default is `CharSet.Ansi`.|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint>|Specifies the DLL entry point to be called.|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>|Controls whether an entry point should be modified to correspond to the character set. The default value varies by programming language.|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>|Controls whether the managed method signature should be transformed into an unmanaged signature that returns an HRESULT and has an additional [out, retval] argument for the return value.<br /><br /> The default is `true` (the signature should not be transformed).|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>|Enables the caller to use the `Marshal.GetLastWin32Error` API function to determine whether an error occurred while executing the method. In Visual Basic, the default is `true`; in C# and C++, the default is `false`.|  \n|<xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar>|Controls throwing of an exception on an unmappable Unicode character that is converted to an ANSI \"?\" character.|  \n  \n For detailed reference information, see <xref:System.Runtime.InteropServices.DllImportAttribute>.  \n  \n## Platform invoke security considerations  \n The `Assert`, `Deny`, and `PermitOnly` members of the <xref:System.Security.Permissions.SecurityAction> enumeration are referred to as *stack walk modifiers*. These members are ignored if they are used as declarative attributes on platform invoke declarations and COM Interface Definition Language (IDL) statements.  \n  \n### Platform Invoke Examples  \n The platform invoke samples in this section illustrate the use of the `RegistryPermission` attribute with the stack walk modifiers.  \n  \n In the following code example, the <xref:System.Security.Permissions.SecurityAction>`Assert`, `Deny`, and `PermitOnly` modifiers are ignored.  \n  \n```  \n[DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]  \n    private static extern bool CallRegistryPermissionAssert();  \n  \n[DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n[RegistryPermission(SecurityAction.Deny, Unrestricted = true)]  \n    private static extern bool CallRegistryPermissionDeny();  \n  \n[DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n[RegistryPermission(SecurityAction.PermitOnly, Unrestricted = true)]  \n    private static extern bool CallRegistryPermissionDeny();  \n```  \n  \n However, the `Demand` modifier in the following example is accepted.  \n  \n```  \n[DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n[RegistryPermission(SecurityAction.Demand, Unrestricted = true)]  \n    private static extern bool CallRegistryPermissionDeny();  \n```  \n  \n <xref:System.Security.Permissions.SecurityAction> modifiers do work correctly if they are placed on a class that contains (wraps) the platform invoke call.  \n  \n```cpp  \n      [RegistryPermission(SecurityAction.Demand, Unrestricted = true)]  \npublic ref class PInvokeWrapper  \n{  \npublic:  \n[DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n    private static extern bool CallRegistryPermissionDeny();  \n};  \n```  \n  \n```csharp  \n[RegistryPermission(SecurityAction.Demand, Unrestricted = true)]  \nclass PInvokeWrapper  \n{  \n[DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n    private static extern bool CallRegistryPermissionDeny();  \n}  \n```  \n  \n <xref:System.Security.Permissions.SecurityAction> modifiers also work correctly in a nested scenario where they are placed on the caller of the platform invoke call:  \n  \n```cpp  \n      {  \npublic ref class PInvokeWrapper  \npublic:  \n    [DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n    private static extern bool CallRegistryPermissionDeny();  \n  \n    [RegistryPermission(SecurityAction.Demand, Unrestricted = true)]  \n    public static bool CallRegistryPermission()  \n    {  \n     return CallRegistryPermissionInternal();  \n    }  \n};  \n```  \n  \n```csharp  \nclass PInvokeScenario  \n{  \n    [DllImport(\"MyClass.dll\", EntryPoint = \"CallRegistryPermission\")]  \n    private static extern bool CallRegistryPermissionInternal();  \n  \n    [RegistryPermission(SecurityAction.Assert, Unrestricted = true)]  \n    public static bool CallRegistryPermission()  \n    {  \n     return CallRegistryPermissionInternal();  \n    }  \n}  \n```  \n  \n#### COM Interop Examples  \n The COM interop samples in this section illustrate the use of the `RegistryPermission` attribute with the stack walk modifiers.  \n  \n The following COM interop interface declarations ignore the `Assert`, `Deny`, and `PermitOnly` modifiers, similarly to the platform invoke examples in the previous section.  \n  \n```  \n[ComImport, Guid(\"12345678-43E6-43c9-9A13-47F40B338DE0\")]  \ninterface IAssertStubsItf  \n{  \n[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]  \n    bool CallRegistryPermission();  \n[FileIOPermission(SecurityAction.Assert, Unrestricted = true)]  \n    bool CallFileIoPermission();  \n}  \n  \n[ComImport, Guid(\"12345678-43E6-43c9-9A13-47F40B338DE0\")]  \ninterface IDenyStubsItf  \n{  \n[RegistryPermission(SecurityAction.Deny, Unrestricted = true)]  \n    bool CallRegistryPermission();  \n[FileIOPermission(SecurityAction.Deny, Unrestricted = true)]  \n    bool CallFileIoPermission();  \n}  \n  \n[ComImport, Guid(\"12345678-43E6-43c9-9A13-47F40B338DE0\")]  \ninterface IAssertStubsItf  \n{  \n[RegistryPermission(SecurityAction.PermitOnly, Unrestricted = true)]  \n    bool CallRegistryPermission();  \n[FileIOPermission(SecurityAction.PermitOnly, Unrestricted = true)]  \n    bool CallFileIoPermission();  \n}  \n```  \n  \n Additionally, the `Demand` modifier is not accepted in COM interop interface declaration scenarios, as shown in the following example.  \n  \n```  \n[ComImport, Guid(\"12345678-43E6-43c9-9A13-47F40B338DE0\")]  \ninterface IDemandStubsItf  \n{  \n[RegistryPermission(SecurityAction.Demand, Unrestricted = true)]  \n    bool CallRegistryPermission();  \n[FileIOPermission(SecurityAction.Demand, Unrestricted = true)]  \n    bool CallFileIoPermission();  \n}  \n```  \n  \n## See also\n\n- [Consuming Unmanaged DLL Functions](consuming-unmanaged-dll-functions.md)\n- [Specifying an Entry Point](specifying-an-entry-point.md)\n- [Specifying a Character Set](specifying-a-character-set.md)\n- [Platform Invoke Examples](platform-invoke-examples.md)\n- [Platform Invoke Security Considerations](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb397754(v=vs.100))\n- [Identifying Functions in DLLs](identifying-functions-in-dlls.md)\n- [Creating a Class to Hold DLL Functions](creating-a-class-to-hold-dll-functions.md)\n- [Calling a DLL Function](calling-a-dll-function.md)\n","nodes":[{"pos":[4,605],"embed":true,"restype":"x-metadata","content":"title: \"Creating Prototypes in Managed Code\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\n  - \"cpp\"\nhelpviewer_keywords: \n  - \"prototypes in managed code\"\n  - \"COM interop, DLL functions\"\n  - \"unmanaged functions\"\n  - \"platform invoke, creating prototypes\"\n  - \"COM interop, platform invoke\"\n  - \"interoperation with unmanaged code, DLL functions\"\n  - \"interoperation with unmanaged code, platform invoke\"\n  - \"platform invoke, object fields\"\n  - \"DLL functions\"\n  - \"object fields in platform invoke\"\nms.assetid: ecdcf25d-cae3-4f07-a2b6-8397ac6dc42d\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Creating Prototypes in Managed Code","nodes":[{"pos":[0,35],"content":"Creating Prototypes in Managed Code","nodes":[{"content":"Creating Prototypes in Managed Code","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[612,647],"content":"Creating Prototypes in Managed Code","linkify":"Creating Prototypes in Managed Code","nodes":[{"content":"Creating Prototypes in Managed Code","pos":[0,35]}]},{"content":"This topic describes how to access unmanaged functions and introduces several attribute fields that annotate method definition in managed code.","pos":[648,791]},{"content":"For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see <bpt id=\"p1\">[</bpt>Marshaling Data with Platform Invoke<ept id=\"p1\">](marshaling-data-with-platform-invoke.md)</ept>.","pos":[792,980],"source":" For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see [Marshaling Data with Platform Invoke](marshaling-data-with-platform-invoke.md)."},{"content":"Before you can access an unmanaged DLL function from managed code, you need to know the name of the function and the name of the DLL that exports it.","pos":[987,1136]},{"content":"With this information, you can begin to write the managed definition for an unmanaged function that is implemented in a DLL.","pos":[1137,1261]},{"content":"Furthermore, you can adjust the way that platform invoke creates the function and marshals data to and from the function.","pos":[1262,1383]},{"pos":[1391,1840],"content":"[!NOTE]\n Windows API functions that allocate a string enable you to free the string by using a method such as `LocalFree`. Platform invoke handles such parameters differently. For platform invoke calls, make the parameter an `IntPtr` type instead of a `String` type. Use methods that are provided by the <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> class to convert the type to a string manually and free it manually.","leadings":["","> "],"nodes":[{"content":"Windows API functions that allocate a string enable you to free the string by using a method such as `LocalFree`. Platform invoke handles such parameters differently. For platform invoke calls, make the parameter an `IntPtr` type instead of a `String` type. Use methods that are provided by the <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> class to convert the type to a string manually and free it manually.","pos":[9,447],"nodes":[{"content":"Windows API functions that allocate a string enable you to free the string by using a method such as <ph id=\"ph1\">`LocalFree`</ph>.","pos":[0,113],"source":"Windows API functions that allocate a string enable you to free the string by using a method such as `LocalFree`."},{"content":"Platform invoke handles such parameters differently.","pos":[114,166]},{"content":"For platform invoke calls, make the parameter an <ph id=\"ph1\">`IntPtr`</ph> type instead of a <ph id=\"ph2\">`String`</ph> type.","pos":[167,257],"source":" For platform invoke calls, make the parameter an `IntPtr` type instead of a `String` type."},{"content":"Use methods that are provided by the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType&gt;</ph> class to convert the type to a string manually and free it manually.","pos":[258,438],"source":" Use methods that are provided by the <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> class to convert the type to a string manually and free it manually."}]}]},{"pos":[1849,1867],"content":"Declaration Basics","linkify":"Declaration Basics","nodes":[{"content":"Declaration Basics","pos":[0,18]}]},{"content":"Managed definitions to unmanaged functions are language-dependent, as you can see in the following examples.","pos":[1871,1979]},{"content":"For more complete code examples, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](platform-invoke-examples.md)</ept>.","pos":[1980,2073],"source":" For more complete code examples, see [Platform Invoke Examples](platform-invoke-examples.md)."},{"pos":[2354,3012],"content":"To apply the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError&gt;</ph>, or <ph id=\"ph6\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar&gt;</ph> fields to a <ph id=\"ph7\">[!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)]</ph> declaration, you must use the <ph id=\"ph8\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> attribute instead of the <ph id=\"ph9\">`Declare`</ph> statement.","source":"To apply the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, or <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields to a [!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] declaration, you must use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute instead of the `Declare` statement."},{"pos":[3835,3859],"content":"Adjusting the Definition","linkify":"Adjusting the Definition","nodes":[{"content":"Adjusting the Definition","pos":[0,24]}]},{"content":"Whether you set them explicitly or not, attribute fields are at work defining the behavior of managed code.","pos":[3863,3970]},{"content":"Platform invoke operates according to the default values set on various fields that exist as metadata in an assembly.","pos":[3971,4088]},{"content":"You can alter this default behavior by adjusting the values of one or more fields.","pos":[4089,4171]},{"content":"In many cases, you use the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> to set a value.","pos":[4172,4271],"source":" In many cases, you use the <xref:System.Runtime.InteropServices.DllImportAttribute> to set a value."},{"content":"The following table lists the complete set of attribute fields that pertain to platform invoke.","pos":[4278,4373]},{"content":"For each field, the table includes the default value and a link to information on how to use these fields to define unmanaged DLL functions.","pos":[4374,4514]},{"content":"Field","pos":[4521,4526]},{"content":"Description","pos":[4527,4538]},{"content":"Enables or disables best-fit mapping.","pos":[4649,4686]},{"content":"Specifies the calling convention to use in passing method arguments.","pos":[4766,4834]},{"content":"The default is <ph id=\"ph1\">`WinAPI`</ph>, which corresponds to <ph id=\"ph2\">`__stdcall`</ph> for the 32-bit Intel-based platforms.","pos":[4835,4930],"source":" The default is `WinAPI`, which corresponds to `__stdcall` for the 32-bit Intel-based platforms."},{"content":"Controls name mangling and the way that string arguments should be marshaled to the function.","pos":[5000,5093]},{"content":"The default is <ph id=\"ph1\">`CharSet.Ansi`</ph>.","pos":[5094,5124],"source":" The default is `CharSet.Ansi`."},{"content":"Specifies the DLL entry point to be called.","pos":[5197,5240]},{"content":"Controls whether an entry point should be modified to correspond to the character set.","pos":[5316,5402]},{"content":"The default value varies by programming language.","pos":[5403,5452]},{"content":"Controls whether the managed method signature should be transformed into an unmanaged signature that returns an HRESULT and has an additional [out, retval] argument for the return value.","pos":[5526,5712]},{"content":"The default is <ph id=\"ph1\">`true`</ph> (the signature should not be transformed).","pos":[5725,5789],"source":"The default is `true` (the signature should not be transformed)."},{"content":"Enables the caller to use the <ph id=\"ph1\">`Marshal.GetLastWin32Error`</ph> API function to determine whether an error occurred while executing the method.","pos":[5864,6001],"source":"Enables the caller to use the `Marshal.GetLastWin32Error` API function to determine whether an error occurred while executing the method."},{"content":"In Visual Basic, the default is <ph id=\"ph1\">`true`</ph>; in C# and C++, the default is <ph id=\"ph2\">`false`</ph>.","pos":[6002,6080],"source":" In Visual Basic, the default is `true`; in C# and C++, the default is `false`."},{"content":"Controls throwing of an exception on an unmappable Unicode character that is converted to an ANSI \"?\" character.","pos":[6164,6276]},{"pos":[6284,6381],"content":"For detailed reference information, see <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>.","source":"For detailed reference information, see <xref:System.Runtime.InteropServices.DllImportAttribute>."},{"pos":[6390,6429],"content":"Platform invoke security considerations","linkify":"Platform invoke security considerations","nodes":[{"content":"Platform invoke security considerations","pos":[0,39]}]},{"content":"The <ph id=\"ph1\">`Assert`</ph>, <ph id=\"ph2\">`Deny`</ph>, and <ph id=\"ph3\">`PermitOnly`</ph> members of the <ph id=\"ph4\">&lt;xref:System.Security.Permissions.SecurityAction&gt;</ph> enumeration are referred to as <bpt id=\"p1\">*</bpt>stack walk modifiers<ept id=\"p1\">*</ept>.","pos":[6433,6591],"source":"The `Assert`, `Deny`, and `PermitOnly` members of the <xref:System.Security.Permissions.SecurityAction> enumeration are referred to as *stack walk modifiers*."},{"content":"These members are ignored if they are used as declarative attributes on platform invoke declarations and COM Interface Definition Language (IDL) statements.","pos":[6592,6748]},{"pos":[6758,6782],"content":"Platform Invoke Examples","linkify":"Platform Invoke Examples","nodes":[{"content":"Platform Invoke Examples","pos":[0,24]}]},{"pos":[6786,6917],"content":"The platform invoke samples in this section illustrate the use of the <ph id=\"ph1\">`RegistryPermission`</ph> attribute with the stack walk modifiers.","source":"The platform invoke samples in this section illustrate the use of the `RegistryPermission` attribute with the stack walk modifiers."},{"pos":[6924,7065],"content":"In the following code example, the <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityAction&gt;</ph><ph id=\"ph2\">`Assert`</ph>, <ph id=\"ph3\">`Deny`</ph>, and <ph id=\"ph4\">`PermitOnly`</ph> modifiers are ignored.","source":"In the following code example, the <xref:System.Security.Permissions.SecurityAction>`Assert`, `Deny`, and `PermitOnly` modifiers are ignored."},{"pos":[7691,7759],"content":"However, the <ph id=\"ph1\">`Demand`</ph> modifier in the following example is accepted.","source":"However, the `Demand` modifier in the following example is accepted."},{"pos":[7979,8134],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityAction&gt;</ph> modifiers do work correctly if they are placed on a class that contains (wraps) the platform invoke call.","source":"<xref:System.Security.Permissions.SecurityAction> modifiers do work correctly if they are placed on a class that contains (wraps) the platform invoke call."},{"pos":[8666,8831],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityAction&gt;</ph> modifiers also work correctly in a nested scenario where they are placed on the caller of the platform invoke call:","source":"<xref:System.Security.Permissions.SecurityAction> modifiers also work correctly in a nested scenario where they are placed on the caller of the platform invoke call:"},{"pos":[9622,9642],"content":"COM Interop Examples","linkify":"COM Interop Examples","nodes":[{"content":"COM Interop Examples","pos":[0,20]}]},{"pos":[9646,9773],"content":"The COM interop samples in this section illustrate the use of the <ph id=\"ph1\">`RegistryPermission`</ph> attribute with the stack walk modifiers.","source":"The COM interop samples in this section illustrate the use of the `RegistryPermission` attribute with the stack walk modifiers."},{"pos":[9780,9952],"content":"The following COM interop interface declarations ignore the <ph id=\"ph1\">`Assert`</ph>, <ph id=\"ph2\">`Deny`</ph>, and <ph id=\"ph3\">`PermitOnly`</ph> modifiers, similarly to the platform invoke examples in the previous section.","source":"The following COM interop interface declarations ignore the `Assert`, `Deny`, and `PermitOnly` modifiers, similarly to the platform invoke examples in the previous section."},{"pos":[10882,11016],"content":"Additionally, the <ph id=\"ph1\">`Demand`</ph> modifier is not accepted in COM interop interface declaration scenarios, as shown in the following example.","source":"Additionally, the `Demand` modifier is not accepted in COM interop interface declaration scenarios, as shown in the following example."},{"pos":[11340,11348],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[11352,11425],"content":"<bpt id=\"p1\">[</bpt>Consuming Unmanaged DLL Functions<ept id=\"p1\">](consuming-unmanaged-dll-functions.md)</ept>","source":"[Consuming Unmanaged DLL Functions](consuming-unmanaged-dll-functions.md)"},{"pos":[11428,11485],"content":"<bpt id=\"p1\">[</bpt>Specifying an Entry Point<ept id=\"p1\">](specifying-an-entry-point.md)</ept>","source":"[Specifying an Entry Point](specifying-an-entry-point.md)"},{"pos":[11488,11547],"content":"<bpt id=\"p1\">[</bpt>Specifying a Character Set<ept id=\"p1\">](specifying-a-character-set.md)</ept>","source":"[Specifying a Character Set](specifying-a-character-set.md)"},{"pos":[11550,11605],"content":"<bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](platform-invoke-examples.md)</ept>","source":"[Platform Invoke Examples](platform-invoke-examples.md)"},{"pos":[11608,11738],"content":"<bpt id=\"p1\">[</bpt>Platform Invoke Security Considerations<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb397754(v=vs.100))</ept>","source":"[Platform Invoke Security Considerations](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb397754(v=vs.100))"},{"pos":[11741,11806],"content":"<bpt id=\"p1\">[</bpt>Identifying Functions in DLLs<ept id=\"p1\">](identifying-functions-in-dlls.md)</ept>","source":"[Identifying Functions in DLLs](identifying-functions-in-dlls.md)"},{"pos":[11809,11892],"content":"<bpt id=\"p1\">[</bpt>Creating a Class to Hold DLL Functions<ept id=\"p1\">](creating-a-class-to-hold-dll-functions.md)</ept>","source":"[Creating a Class to Hold DLL Functions](creating-a-class-to-hold-dll-functions.md)"},{"pos":[11895,11946],"content":"<bpt id=\"p1\">[</bpt>Calling a DLL Function<ept id=\"p1\">](calling-a-dll-function.md)</ept>","source":"[Calling a DLL Function](calling-a-dll-function.md)"}]}