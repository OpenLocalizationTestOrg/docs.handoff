{"content":"---\ntitle: \"Secure Coding Guidelines for Unmanaged Code\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"code security, unmanaged code\"\n  - \"unmanaged code, securing\"\n  - \"security [.NET Framework], unmanaged code\"\n  - \"secure coding, unmanaged code\"\nms.assetid: a8d15139-d368-4c9c-a747-ba757781117c\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Secure Coding Guidelines for Unmanaged Code\nSome library code needs to call into unmanaged code (for example, native code APIs, such as Win32). Because this means going outside the security perimeter for managed code, due caution is required. If your code is security-neutral, both your code and any code that calls it must have unmanaged code permission (<xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified).  \n  \n However, it is often unreasonable for your caller to have such powerful permissions. In such cases, your trusted code can be the go-between, similar to the managed wrapper or library code described in [Securing Wrapper Code](../../../docs/framework/misc/securing-wrapper-code.md). If the underlying unmanaged code functionality is totally safe, it can be directly exposed; otherwise, a suitable permission check (demand) is required first.  \n  \n When your code calls into unmanaged code but you do not want to require your callers to have permission to access unmanaged code, you must assert that right. An assertion blocks the stack walk at your frame. You must be careful that you do not create a security hole in this process. Usually, this means that you must demand a suitable permission of your callers and then use unmanaged code to perform only what that permission allows and no more. In some cases (for example, a get time-of-day function), unmanaged code can be directly exposed to callers without any security checks. In any case, any code that asserts must take responsibility for security.  \n  \n Because any managed code that provides a code path into native code is a potential target for malicious code, determining which unmanaged code can be safely used and how it must be used requires extreme care. Generally, unmanaged code should never be directly exposed to partially trusted callers. There are two primary considerations in evaluating the safety of unmanaged code use in libraries that are callable by partially trusted code:  \n  \n-   **Functionality**. Does the unmanaged API provide functionality that does not allow callers to perform potentially dangerous operations? Code access security uses permissions to enforce access to resources, so consider whether the API uses files, a user interface, or threading, or whether it exposes protected information. If it does, the managed code wrapping it must demand the necessary permissions before allowing it to be entered. Additionally, while not protected by a permission, memory access must be confined to strict type safety.  \n  \n-   **Parameter checking**. A common attack passes unexpected parameters to exposed unmanaged code API methods in an attempt to cause them to operate out of specification. Buffer overruns using out-of-range index or offset values are one common example of this type of attack, as are any parameters that might exploit a bug in the underlying code. Thus, even if the unmanaged code API is functionally safe (after necessary demands) for partially trusted callers, managed code must also check parameter validity exhaustively to ensure that no unintended calls are possible from malicious code using the managed code wrapper layer.  \n  \n## Using SuppressUnmanagedCodeSecurityAttribute  \n There is a performance aspect to asserting and then calling unmanaged code. For every such call, the security system automatically demands unmanaged code permission, resulting in a stack walk each time. If you assert and immediately call unmanaged code, the stack walk can be meaningless: it consists of your assert and your unmanaged code call.  \n  \n A custom attribute called <xref:System.Security.SuppressUnmanagedCodeSecurityAttribute> can be applied to unmanaged code entry points to disable the normal security check that demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permission specified. Extreme caution must always be taken when doing this, because this action creates an open door into unmanaged code with no runtime security checks. It should be noted that even with **SuppressUnmanagedCodeSecurityAttribute** applied, there is a one-time security check that happens at just-in-time (JIT) compilation to ensure that the immediate caller has permission to call unmanaged code.  \n  \n If you use the **SuppressUnmanagedCodeSecurityAttribute**, check the following points:  \n  \n-   Make the unmanaged code entry point internal or otherwise inaccessible outside your code.  \n  \n-   Any call into unmanaged code is a potential security hole. Make sure your code is not a portal for malicious code to indirectly call into unmanaged code and avoid a security check. Demand permissions, if appropriate.  \n  \n-   Use a naming convention to explicitly identify when you are creating a dangerous path into unmanaged code, as described in the section below..  \n  \n## Naming convention for unmanaged code methods  \n A useful and highly recommended convention has been established for naming unmanaged code methods. All unmanaged code methods are separated into three categories: **safe**, **native**, and **unsafe**. These keywords can be used as class names within which the various kinds of unmanaged code entry points are defined. In source code, these keywords should be added to the class name, as in `Safe.GetTimeOfDay`, `Native.Xyz`, or `Unsafe.DangerousAPI`, for example. Each of these keywords provides useful security information for developers using that class, as described in the following table.  \n  \n|Keyword|Security considerations|  \n|-------------|-----------------------------|  \n|**safe**|Completely harmless for any code, even malicious code, to call. Can be used just like other managed code. For example, a function that gets the time of day is typically safe.|  \n|**native**|Security-neutral; that is, unmanaged code that requires unmanaged code permission to call. Security is checked, which stops an unauthorized caller.|  \n|**unsafe**|Potentially dangerous unmanaged code entry point with security suppressed. Developers should use the greatest caution when using such unmanaged code, making sure that other protections are in place to prevent a security vulnerability. Developers must be responsible, as this keyword overrides the security system.|  \n  \n## See also\n\n- [Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)\n","nodes":[{"pos":[4,337],"embed":true,"restype":"x-metadata","content":"title: \"Secure Coding Guidelines for Unmanaged Code\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"code security, unmanaged code\"\n  - \"unmanaged code, securing\"\n  - \"security [.NET Framework], unmanaged code\"\n  - \"secure coding, unmanaged code\"\nms.assetid: a8d15139-d368-4c9c-a747-ba757781117c\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Secure Coding Guidelines for Unmanaged Code","nodes":[{"pos":[0,43],"content":"Secure Coding Guidelines for Unmanaged Code","nodes":[{"content":"Secure Coding Guidelines for Unmanaged Code","pos":[0,43]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[344,387],"content":"Secure Coding Guidelines for Unmanaged Code","linkify":"Secure Coding Guidelines for Unmanaged Code","nodes":[{"content":"Secure Coding Guidelines for Unmanaged Code","pos":[0,43]}]},{"content":"Some library code needs to call into unmanaged code (for example, native code APIs, such as Win32).","pos":[388,487]},{"content":"Because this means going outside the security perimeter for managed code, due caution is required.","pos":[488,586]},{"content":"If your code is security-neutral, both your code and any code that calls it must have unmanaged code permission (<ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode&gt;</ph> flag specified).","pos":[587,851],"source":" If your code is security-neutral, both your code and any code that calls it must have unmanaged code permission (<xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified)."},{"content":"However, it is often unreasonable for your caller to have such powerful permissions.","pos":[858,942]},{"content":"In such cases, your trusted code can be the go-between, similar to the managed wrapper or library code described in <bpt id=\"p1\">[</bpt>Securing Wrapper Code<ept id=\"p1\">](../../../docs/framework/misc/securing-wrapper-code.md)</ept>.","pos":[943,1138],"source":" In such cases, your trusted code can be the go-between, similar to the managed wrapper or library code described in [Securing Wrapper Code](../../../docs/framework/misc/securing-wrapper-code.md)."},{"content":"If the underlying unmanaged code functionality is totally safe, it can be directly exposed; otherwise, a suitable permission check (demand) is required first.","pos":[1139,1297]},{"content":"When your code calls into unmanaged code but you do not want to require your callers to have permission to access unmanaged code, you must assert that right.","pos":[1304,1461]},{"content":"An assertion blocks the stack walk at your frame.","pos":[1462,1511]},{"content":"You must be careful that you do not create a security hole in this process.","pos":[1512,1587]},{"content":"Usually, this means that you must demand a suitable permission of your callers and then use unmanaged code to perform only what that permission allows and no more.","pos":[1588,1751]},{"content":"In some cases (for example, a get time-of-day function), unmanaged code can be directly exposed to callers without any security checks.","pos":[1752,1887]},{"content":"In any case, any code that asserts must take responsibility for security.","pos":[1888,1961]},{"content":"Because any managed code that provides a code path into native code is a potential target for malicious code, determining which unmanaged code can be safely used and how it must be used requires extreme care.","pos":[1968,2176]},{"content":"Generally, unmanaged code should never be directly exposed to partially trusted callers.","pos":[2177,2265]},{"content":"There are two primary considerations in evaluating the safety of unmanaged code use in libraries that are callable by partially trusted code:","pos":[2266,2407]},{"content":"<bpt id=\"p1\">**</bpt>Functionality<ept id=\"p1\">**</ept>.","pos":[2417,2435],"source":"**Functionality**."},{"content":"Does the unmanaged API provide functionality that does not allow callers to perform potentially dangerous operations?","pos":[2436,2553]},{"content":"Code access security uses permissions to enforce access to resources, so consider whether the API uses files, a user interface, or threading, or whether it exposes protected information.","pos":[2554,2740]},{"content":"If it does, the managed code wrapping it must demand the necessary permissions before allowing it to be entered.","pos":[2741,2853]},{"content":"Additionally, while not protected by a permission, memory access must be confined to strict type safety.","pos":[2854,2958]},{"content":"<bpt id=\"p1\">**</bpt>Parameter checking<ept id=\"p1\">**</ept>.","pos":[2968,2991],"source":"**Parameter checking**."},{"content":"A common attack passes unexpected parameters to exposed unmanaged code API methods in an attempt to cause them to operate out of specification.","pos":[2992,3135]},{"content":"Buffer overruns using out-of-range index or offset values are one common example of this type of attack, as are any parameters that might exploit a bug in the underlying code.","pos":[3136,3311]},{"content":"Thus, even if the unmanaged code API is functionally safe (after necessary demands) for partially trusted callers, managed code must also check parameter validity exhaustively to ensure that no unintended calls are possible from malicious code using the managed code wrapper layer.","pos":[3312,3593]},{"pos":[3602,3646],"content":"Using SuppressUnmanagedCodeSecurityAttribute","linkify":"Using SuppressUnmanagedCodeSecurityAttribute","nodes":[{"content":"Using SuppressUnmanagedCodeSecurityAttribute","pos":[0,44]}]},{"content":"There is a performance aspect to asserting and then calling unmanaged code.","pos":[3650,3725]},{"content":"For every such call, the security system automatically demands unmanaged code permission, resulting in a stack walk each time.","pos":[3726,3852]},{"content":"If you assert and immediately call unmanaged code, the stack walk can be meaningless: it consists of your assert and your unmanaged code call.","pos":[3853,3995]},{"content":"A custom attribute called <ph id=\"ph1\">&lt;xref:System.Security.SuppressUnmanagedCodeSecurityAttribute&gt;</ph> can be applied to unmanaged code entry points to disable the normal security check that demands <ph id=\"ph2\">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode&gt;</ph> permission specified.","pos":[4002,4342],"source":"A custom attribute called <xref:System.Security.SuppressUnmanagedCodeSecurityAttribute> can be applied to unmanaged code entry points to disable the normal security check that demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permission specified."},{"content":"Extreme caution must always be taken when doing this, because this action creates an open door into unmanaged code with no runtime security checks.","pos":[4343,4490]},{"content":"It should be noted that even with <bpt id=\"p1\">**</bpt>SuppressUnmanagedCodeSecurityAttribute<ept id=\"p1\">**</ept> applied, there is a one-time security check that happens at just-in-time (JIT) compilation to ensure that the immediate caller has permission to call unmanaged code.","pos":[4491,4733],"source":" It should be noted that even with **SuppressUnmanagedCodeSecurityAttribute** applied, there is a one-time security check that happens at just-in-time (JIT) compilation to ensure that the immediate caller has permission to call unmanaged code."},{"pos":[4740,4826],"content":"If you use the <bpt id=\"p1\">**</bpt>SuppressUnmanagedCodeSecurityAttribute<ept id=\"p1\">**</ept>, check the following points:","source":"If you use the **SuppressUnmanagedCodeSecurityAttribute**, check the following points:"},{"content":"Make the unmanaged code entry point internal or otherwise inaccessible outside your code.","pos":[4836,4925]},{"content":"Any call into unmanaged code is a potential security hole.","pos":[4935,4993]},{"content":"Make sure your code is not a portal for malicious code to indirectly call into unmanaged code and avoid a security check.","pos":[4994,5115]},{"content":"Demand permissions, if appropriate.","pos":[5116,5151]},{"content":"Use a naming convention to explicitly identify when you are creating a dangerous path into unmanaged code, as described in the section below..","pos":[5161,5303]},{"pos":[5312,5356],"content":"Naming convention for unmanaged code methods","linkify":"Naming convention for unmanaged code methods","nodes":[{"content":"Naming convention for unmanaged code methods","pos":[0,44]}]},{"content":"A useful and highly recommended convention has been established for naming unmanaged code methods.","pos":[5360,5458]},{"content":"All unmanaged code methods are separated into three categories: <bpt id=\"p1\">**</bpt>safe<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>native<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>unsafe<ept id=\"p3\">**</ept>.","pos":[5459,5560],"source":" All unmanaged code methods are separated into three categories: **safe**, **native**, and **unsafe**."},{"content":"These keywords can be used as class names within which the various kinds of unmanaged code entry points are defined.","pos":[5561,5677]},{"content":"In source code, these keywords should be added to the class name, as in <ph id=\"ph1\">`Safe.GetTimeOfDay`</ph>, <ph id=\"ph2\">`Native.Xyz`</ph>, or <ph id=\"ph3\">`Unsafe.DangerousAPI`</ph>, for example.","pos":[5678,5823],"source":" In source code, these keywords should be added to the class name, as in `Safe.GetTimeOfDay`, `Native.Xyz`, or `Unsafe.DangerousAPI`, for example."},{"content":"Each of these keywords provides useful security information for developers using that class, as described in the following table.","pos":[5824,5953]},{"content":"Keyword","pos":[5960,5967]},{"content":"Security considerations","pos":[5968,5991]},{"pos":[6044,6052],"content":"<bpt id=\"p1\">**</bpt>safe<ept id=\"p1\">**</ept>","source":"**safe**"},{"content":"Completely harmless for any code, even malicious code, to call.","pos":[6053,6116]},{"content":"Can be used just like other managed code.","pos":[6117,6158]},{"content":"For example, a function that gets the time of day is typically safe.","pos":[6159,6227]},{"pos":[6232,6242],"content":"<bpt id=\"p1\">**</bpt>native<ept id=\"p1\">**</ept>","source":"**native**"},{"content":"Security-neutral; that is, unmanaged code that requires unmanaged code permission to call.","pos":[6243,6333]},{"content":"Security is checked, which stops an unauthorized caller.","pos":[6334,6390]},{"pos":[6395,6405],"content":"<bpt id=\"p1\">**</bpt>unsafe<ept id=\"p1\">**</ept>","source":"**unsafe**"},{"content":"Potentially dangerous unmanaged code entry point with security suppressed.","pos":[6406,6480]},{"content":"Developers should use the greatest caution when using such unmanaged code, making sure that other protections are in place to prevent a security vulnerability.","pos":[6481,6640]},{"content":"Developers must be responsible, as this keyword overrides the security system.","pos":[6641,6719]},{"pos":[6729,6737],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6741,6828],"content":"<bpt id=\"p1\">[</bpt>Secure Coding Guidelines<ept id=\"p1\">](../../../docs/standard/security/secure-coding-guidelines.md)</ept>","source":"[Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)"}]}