<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="libraries.md" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9dd1d8477f8e34e79ff521463972e26a21ad1dfd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tutorials\libraries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a567e8347c580998b2d796db61b8d5eeec8ac715</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">468c75123746d096ae6a1690da6daf1498aa2d37</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Developing Libraries with Cross Platform Tools</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn how to create .NET Core libraries using the .NET Core CLI tools.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>You'll create a library that supports multiple frameworks.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Developing Libraries with Cross Platform Tools</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This article covers how to write libraries for .NET using cross-platform CLI tools.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The CLI provides an efficient and low-level experience that works across any supported OS.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can still build libraries with Visual Studio, and if that is your preferred experience <bpt id="p1">[</bpt>refer to the Visual Studio guide<ept id="p1">](libraries-with-vs.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You need <bpt id="p1">[</bpt>the .NET Core SDK and CLI<ept id="p1">](https://www.microsoft.com/net/core)</ept> installed on your machine.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For the sections of this document dealing with .NET Framework versions, you need the <bpt id="p1">[</bpt>.NET Framework<ept id="p1">](https://dotnet.microsoft.com)</ept> installed on a Windows machine.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Additionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the <bpt id="p1">[</bpt>.NET download archives page<ept id="p1">](https://dotnet.microsoft.com/download/archives)</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Refer to this table:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>.NET Framework Version</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>What to download</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.6.1 Targeting Pack</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>4.6</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.6 Targeting Pack</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>4.5.2</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5.2 Developer Pack</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5.1 Developer Pack</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>4.5</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Windows Software Development Kit for Windows 8</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>4.0</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Windows SDK for Windows 7 and .NET Framework 4</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>2.0, 3.0, and 3.5</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>.NET Framework 3.5 SP1 Runtime (or Windows 8+ version)</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>How to target the .NET Standard</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If you're not quite familiar with the .NET Standard, refer to the <bpt id="p1">[</bpt>.NET Standard<ept id="p1">](../../standard/net-standard.md)</ept> to learn more.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In that article, there is a table which maps .NET Standard versions to various implementations:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Here's what this table means for the purposes of creating a library:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The version of the .NET Standard you pick will be a tradeoff between access to the newest APIs and the ability to target more .NET implementations and .NET Standard versions.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You control the range of targetable platforms and versions by picking a version of <ph id="ph1">`netstandardX.X`</ph> (Where <ph id="ph2">`X.X`</ph> is a version number) and adding it to your project file (<ph id="ph3">`.csproj`</ph> or <ph id="ph4">`.fsproj`</ph>).</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You have three primary options when targeting the .NET Standard, depending on your needs.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can use the default version of the .NET Standard supplied by templates - <ph id="ph1">`netstandard1.4`</ph> - which gives you access to most APIs on .NET Standard while still being compatible with UWP, .NET Framework 4.6.1, and the forthcoming .NET Standard 2.0.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can use a lower or higher version of the .NET Standard by modifying the value in the <ph id="ph1">`TargetFramework`</ph> node of your project file.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>.NET Standard versions are backward compatible.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>That means that <ph id="ph1">`netstandard1.0`</ph> libraries run on <ph id="ph2">`netstandard1.1`</ph> platforms and higher.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, there is no forward compatibility - lower .NET Standard platforms cannot reference higher ones.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This means that <ph id="ph1">`netstandard1.0`</ph> libraries cannot reference libraries targeting <ph id="ph2">`netstandard1.1`</ph> or higher.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Select the Standard version that has the right mix of APIs and platform support for your needs.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>We recommend <ph id="ph1">`netstandard1.4`</ph> for now.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, <ph id="ph1">`System.Drawing`</ph>), read the following sections and learn how to multitarget.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How to target the .NET Framework</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>These instructions assume you have the .NET Framework installed on your machine.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> to get dependencies installed.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Keep in mind that some of the .NET Framework versions used here are no longer in support.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>.NET Framework Support Lifecycle Policy FAQ<ept id="p1">](https://support.microsoft.com/gp/framework_faq/en-us)</ept> about unsupported versions.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If you want to reach the maximum number of developers and projects, use the .NET Framework 4.0 as your baseline target.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To target the .NET Framework, you will need to begin by using the correct Target Framework Moniker (TFM) that corresponds to the .NET Framework version you wish to support.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You then insert this TFM into the <ph id="ph1">`TargetFramework`</ph> section of your project file.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, here's how you would write a library which targets the .NET Framework 4.0:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Although this compiled only for the .NET Framework 4, you can use the library on newer versions of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>How to Multitarget</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following instructions assume you have the .NET Framework installed on your machine.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> section to learn which dependencies you need to install and where to download them from.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You may need to target older versions of the .NET Framework when your project supports both the .NET Framework and .NET Core.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In this scenario, if you want to use newer APIs and language constructs for the newer targets, use <ph id="ph1">`#if`</ph> directives in your code.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You also might need to add different packages and dependencies for each platform you're targeting to include the different APIs needed for each case.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a library that performs networking operations over HTTP.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the <ph id="ph1">`HttpClient`</ph> class from the <ph id="ph2">`System.Net.Http`</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>However, earlier versions of the .NET Framework don't have the <ph id="ph1">`HttpClient`</ph> class, so you could use the <ph id="ph2">`WebClient`</ph> class from the <ph id="ph3">`System.Net`</ph> namespace for those instead.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Your project file could look like this:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You'll notice three major changes here:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`TargetFramework`</ph> node has been replaced by <ph id="ph2">`TargetFrameworks`</ph>, and three TFMs are expressed inside.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>There is an <ph id="ph1">`&lt;ItemGroup&gt;`</ph> node for the <ph id="ph2">`net40`</ph> target pulling in one .NET Framework reference.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>There is an <ph id="ph1">`&lt;ItemGroup&gt;`</ph> node for the <ph id="ph2">`net45`</ph> target pulling in two .NET Framework references.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The build system is aware of the following preprocessor symbols used in <ph id="ph1">`#if`</ph> directives:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Here is an example making use of conditional compilation per-target:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you build this project with <ph id="ph1">`dotnet build`</ph>, you'll notice three directories under the <ph id="ph2">`bin/`</ph> folder:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Each of these contain the <ph id="ph1">`.dll`</ph> files for each target.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>How to test libraries on .NET Core</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>It's important to be able to test across platforms.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can use either <bpt id="p1">[</bpt>xUnit<ept id="p1">](https://xunit.github.io/)</ept> or MSTest out of the box.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Both are perfectly suitable for unit testing your library on .NET Core.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>How you set up your solution with test projects will depend on the <bpt id="p1">[</bpt>structure of your solution<ept id="p1">](#structuring-a-solution)</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following example assumes that the test and source directories live in the same top-level directory.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This uses some <bpt id="p1">[</bpt>.NET Core CLI commands<ept id="p1">](../tools/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>dotnet new<ept id="p1">](../tools/dotnet-new.md)</ept> and <bpt id="p2">[</bpt>dotnet sln<ept id="p2">](../tools/dotnet-sln.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Set up your solution.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can do so with the following commands:</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This will create projects and link them together in a solution.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Your directory for <ph id="ph1">`SolutionWithSrcAndTest`</ph> should look like this:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Navigate to the test project's directory and add a reference to <ph id="ph1">`MyProject.Test`</ph> from <ph id="ph2">`MyProject`</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Restore packages and build projects:</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Verify that xUnit runs by executing the <ph id="ph1">`dotnet test`</ph> command.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If you chose to use MSTest, then the MSTest console runner should run instead.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can now test your library across all platforms using command line tools.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To continue testing now that you have everything set up, testing your library is very simple:</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Make changes to your library.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Run tests from the command line, in your test directory, with <ph id="ph1">`dotnet test`</ph> command.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Your code will be automatically rebuilt when you invoke <ph id="ph1">`dotnet test`</ph> command.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>How to use multiple projects</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A common need for larger libraries is to place functionality in different projects.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Imagine you wished to build a library which could be consumed in idiomatic C# and F#.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>That would mean that consumers of your library consume them in ways which are natural to C# or F#.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, in C# you might consume the library like this:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In F#, it might look like this:</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Consumption scenarios like this mean that the APIs being accessed have to have a different structure for C# and F#.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A common approach to accomplishing this is to factor all of the logic of a library into a core project, with C# and F# projects defining the API layers that call into that core project.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The rest of the section will use the following names:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> - A core project which contains all logic for the library</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> - A project with public APIs intended for consumption in C#</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.FSharp<ept id="p1">**</ept> - A project with public APIs intended for consumption in F#</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You can run the following commands in your terminal to produce the same structure as this guide:</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>This will add the three projects above and a solution file which links them together.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Creating the solution file and linking projects will allow you to restore and build projects from a top-level.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Project-to-project referencing</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The best way to reference a project is to use the .NET Core CLI to add a project reference.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>From the <bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> and <bpt id="p2">**</bpt>AwesomeLibrary.FSharp<ept id="p2">**</ept> project directories, you can run the following command:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The project files for both <bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> and <bpt id="p2">**</bpt>AwesomeLibrary.FSharp<ept id="p2">**</ept> will now reference <bpt id="p3">**</bpt>AwesomeLibrary.Core<ept id="p3">**</ept> as a <ph id="ph1">`ProjectReference`</ph> target.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can verify this by inspecting the project files and seeing the following in them:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>You can add this section to each project file manually if you prefer not to use the .NET Core CLI.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Structuring a solution</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Another important aspect of multi-project solutions is establishing a good overall project structure.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>You can organize code however you like, and as long as you link each project to your solution file with <ph id="ph1">`dotnet sln add`</ph>, you will be able to run <ph id="ph2">`dotnet restore`</ph> and <ph id="ph3">`dotnet build`</ph> at the solution level.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>