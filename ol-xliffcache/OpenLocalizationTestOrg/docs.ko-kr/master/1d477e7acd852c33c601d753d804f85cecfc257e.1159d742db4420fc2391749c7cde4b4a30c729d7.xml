{"content":"---\ntitle: \"Identifying Functions in DLLs | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"platform invoke, identifying functions\"\n  - \"COM interop, DLL functions\"\n  - \"unmanaged functions\"\n  - \"COM interop, platform invoke\"\n  - \"interoperation with unmanaged code, DLL functions\"\n  - \"interoperation with unmanaged code, platform invoke\"\n  - \"identifying DLL functions\"\n  - \"DLL functions\"\nms.assetid: 3e3f6780-6d90-4413-bad7-ba641220364d\ncaps.latest.revision: 9\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Identifying Functions in DLLs\nThe identity of a DLL function consists of the following elements:  \n  \n-   Function name or ordinal  \n  \n-   Name of the DLL file in which the implementation can be found  \n  \n For example, specifying the **MessageBox** function in the User32.dll identifies the function (**MessageBox**) and its location (User32.dll, User32, or user32). The Microsoft Windows application programming interface (Win32 API) can contain two versions of each function that handles characters and strings: a 1-byte character ANSI version and a 2-byte character Unicode version. When unspecified, the character set, represented by the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> field, defaults to ANSI. Some functions can have more than two versions.  \n  \n **MessageBoxA** is the ANSI entry point for the **MessageBox** function; **MessageBoxW** is the Unicode version. You can list function names for a specific DLL, such as user32.dll, by running a variety of command-line tools. For example, you can use `dumpbin /exports user32.dll` or `link /dump /exports user32.dll` to obtain function names.  \n  \n You can rename an unmanaged function to whatever you like within your code as long as you map the new name to the original entry point in the DLL. For instructions on renaming an unmanaged DLL function in managed source code, see the [Specifying an Entry Point](../../../docs/framework/interop/specifying-an-entry-point.md).  \n  \n Platform invoke enables you to control a significant portion of the operating system by calling functions in the Win32 API and other DLLs. In addition to the Win32 API, there are numerous other APIs and DLLs available to you through platform invoke.  \n  \n The following table describes several commonly used DLLs in the Win32 API.  \n  \n|DLL|Description of Contents|  \n|---------|-----------------------------|  \n|GDI32.dll|Graphics Device Interface (GDI) functions for device output, such as those for drawing and font management.|  \n|Kernel32.dll|Low-level operating system functions for memory management and resource handling.|  \n|User32.dll|Windows management functions for message handling, timers, menus, and communications.|  \n  \n For complete documentation on the Win32 API, see the Platform SDK. For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see [Marshaling Data with Platform Invoke](../../../docs/framework/interop/marshaling-data-with-platform-invoke.md).  \n  \n## See Also  \n [Consuming Unmanaged DLL Functions](../../../docs/framework/interop/consuming-unmanaged-dll-functions.md)   \n [Specifying an Entry Point](../../../docs/framework/interop/specifying-an-entry-point.md)   \n [Creating a Class to Hold DLL Functions](../../../docs/framework/interop/creating-a-class-to-hold-dll-functions.md)   \n [Creating Prototypes in Managed Code](../../../docs/framework/interop/creating-prototypes-in-managed-code.md)   \n [Calling a DLL Function](../../../docs/framework/interop/calling-a-dll-function.md)","nodes":[{"pos":[4,738],"nodes":[{"content":"Identifying Functions in DLLs | Microsoft Docs","nodes":[{"pos":[0,46],"content":"Identifying Functions in DLLs | Microsoft Docs","nodes":[{"content":"Identifying Functions in DLLs | Microsoft Docs","pos":[0,46]}]}],"pos":[6,55],"yaml":true}],"content":"title: \"Identifying Functions in DLLs | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"platform invoke, identifying functions\"\n  - \"COM interop, DLL functions\"\n  - \"unmanaged functions\"\n  - \"COM interop, platform invoke\"\n  - \"interoperation with unmanaged code, DLL functions\"\n  - \"interoperation with unmanaged code, platform invoke\"\n  - \"identifying DLL functions\"\n  - \"DLL functions\"\nms.assetid: 3e3f6780-6d90-4413-bad7-ba641220364d\ncaps.latest.revision: 9\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","yamlblock":true},{"pos":[745,774],"content":"Identifying Functions in DLLs","linkify":"Identifying Functions in DLLs","nodes":[{"content":"Identifying Functions in DLLs","pos":[0,29]}]},{"content":"The identity of a DLL function consists of the following elements:","pos":[775,841]},{"content":"Function name or ordinal","pos":[851,875]},{"content":"Name of the DLL file in which the implementation can be found","pos":[885,946]},{"content":"For example, specifying the <bpt id=\"p1\">**</bpt>MessageBox<ept id=\"p1\">**</ept> function in the User32.dll identifies the function (<bpt id=\"p2\">**</bpt>MessageBox<ept id=\"p2\">**</ept>) and its location (User32.dll, User32, or user32).","pos":[953,1113],"source":"For example, specifying the **MessageBox** function in the User32.dll identifies the function (**MessageBox**) and its location (User32.dll, User32, or user32)."},{"content":"The Microsoft Windows application programming interface (Win32 API) can contain two versions of each function that handles characters and strings: a 1-byte character ANSI version and a 2-byte character Unicode version.","pos":[1114,1332]},{"content":"When unspecified, the character set, represented by the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.CharSet&gt;</ph> field, defaults to ANSI.","pos":[1333,1478],"source":" When unspecified, the character set, represented by the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> field, defaults to ANSI."},{"content":"Some functions can have more than two versions.","pos":[1479,1526]},{"content":"<bpt id=\"p1\">**</bpt>MessageBoxA<ept id=\"p1\">**</ept> is the ANSI entry point for the <bpt id=\"p2\">**</bpt>MessageBox<ept id=\"p2\">**</ept> function; <bpt id=\"p3\">**</bpt>MessageBoxW<ept id=\"p3\">**</ept> is the Unicode version.","pos":[1533,1645],"source":"**MessageBoxA** is the ANSI entry point for the **MessageBox** function; **MessageBoxW** is the Unicode version."},{"content":"You can list function names for a specific DLL, such as user32.dll, by running a variety of command-line tools.","pos":[1646,1757]},{"content":"For example, you can use <ph id=\"ph1\">`dumpbin /exports user32.dll`</ph> or <ph id=\"ph2\">`link /dump /exports user32.dll`</ph> to obtain function names.","pos":[1758,1874],"source":" For example, you can use `dumpbin /exports user32.dll` or `link /dump /exports user32.dll` to obtain function names."},{"content":"You can rename an unmanaged function to whatever you like within your code as long as you map the new name to the original entry point in the DLL.","pos":[1881,2027]},{"content":"For instructions on renaming an unmanaged DLL function in managed source code, see the <bpt id=\"p1\">[</bpt>Specifying an Entry Point<ept id=\"p1\">](../../../docs/framework/interop/specifying-an-entry-point.md)</ept>.","pos":[2028,2205],"source":" For instructions on renaming an unmanaged DLL function in managed source code, see the [Specifying an Entry Point](../../../docs/framework/interop/specifying-an-entry-point.md)."},{"content":"Platform invoke enables you to control a significant portion of the operating system by calling functions in the Win32 API and other DLLs.","pos":[2212,2350]},{"content":"In addition to the Win32 API, there are numerous other APIs and DLLs available to you through platform invoke.","pos":[2351,2461]},{"content":"The following table describes several commonly used DLLs in the Win32 API.","pos":[2468,2542]},{"content":"DLL","pos":[2549,2552]},{"content":"Description of Contents","pos":[2553,2576]},{"content":"GDI32.dll","pos":[2625,2634]},{"content":"Graphics Device Interface (GDI) functions for device output, such as those for drawing and font management.","pos":[2635,2742]},{"content":"Kernel32.dll","pos":[2747,2759]},{"content":"Low-level operating system functions for memory management and resource handling.","pos":[2760,2841]},{"content":"User32.dll","pos":[2846,2856]},{"content":"Windows management functions for message handling, timers, menus, and communications.","pos":[2857,2942]},{"content":"For complete documentation on the Win32 API, see the Platform SDK.","pos":[2950,3016]},{"content":"For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see <bpt id=\"p1\">[</bpt>Marshaling Data with Platform Invoke<ept id=\"p1\">](../../../docs/framework/interop/marshaling-data-with-platform-invoke.md)</ept>.","pos":[3017,3237],"source":" For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see [Marshaling Data with Platform Invoke](../../../docs/framework/interop/marshaling-data-with-platform-invoke.md)."},{"pos":[3246,3254],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Consuming Unmanaged DLL Functions<ept id=\"p1\">](../../../docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept><ph id=\"ph1\"> </ph>","pos":[3258,3364],"source":"[Consuming Unmanaged DLL Functions](../../../docs/framework/interop/consuming-unmanaged-dll-functions.md) "},{"content":"<bpt id=\"p1\">[</bpt>Specifying an Entry Point<ept id=\"p1\">](../../../docs/framework/interop/specifying-an-entry-point.md)</ept><ph id=\"ph1\"> </ph>","pos":[3368,3458],"source":"[Specifying an Entry Point](../../../docs/framework/interop/specifying-an-entry-point.md) "},{"content":"<bpt id=\"p1\">[</bpt>Creating a Class to Hold DLL Functions<ept id=\"p1\">](../../../docs/framework/interop/creating-a-class-to-hold-dll-functions.md)</ept><ph id=\"ph1\"> </ph>","pos":[3462,3578],"source":"[Creating a Class to Hold DLL Functions](../../../docs/framework/interop/creating-a-class-to-hold-dll-functions.md) "},{"content":"<bpt id=\"p1\">[</bpt>Creating Prototypes in Managed Code<ept id=\"p1\">](../../../docs/framework/interop/creating-prototypes-in-managed-code.md)</ept><ph id=\"ph1\"> </ph>","pos":[3582,3692],"source":"[Creating Prototypes in Managed Code](../../../docs/framework/interop/creating-prototypes-in-managed-code.md) "},{"content":"<bpt id=\"p1\">[</bpt>Calling a DLL Function<ept id=\"p1\">](../../../docs/framework/interop/calling-a-dll-function.md)</ept>","pos":[3696,3779],"source":"[Calling a DLL Function](../../../docs/framework/interop/calling-a-dll-function.md)"}]}