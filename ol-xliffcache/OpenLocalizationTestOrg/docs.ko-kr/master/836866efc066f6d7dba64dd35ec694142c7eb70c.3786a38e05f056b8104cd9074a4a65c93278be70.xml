{"content":"---\ntitle: The Standard .NET Event Pattern\ndescription: The Standard .NET Event Pattern\nkeywords: .NET, .NET Core\nauthor: BillWagner\nms.author: wiwagn\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 8a3133d6-4ef2-46f9-9c8d-a8ea8898e4c9\n---\n\n# The Standard .NET Event Pattern\n\n[Previous](events-overview.md)\n\n.NET events generally follow a few known patterns. Standardizing\non these patterns means that developers can leverage knowledge of\nthose standard patterns, which can be applied to any .NET event program.\n\nLet's go through these standard patterns so you will have all\nthe knowledge you need to create standard event sources, and\nsubscribe and process standard events in your code.\n\n## Event Delegate Signatures\n\nThe standard signature for a .NET event delegate is:\n\n```csharp\nvoid OnEventRaised(object sender, EventArgs args);\n```\n\nThe return type is void. Events are based on delegates and are\nmulticast delegates. That supports multiple subscribers for any\nevent source. The single return value from a method doesn't scale\nto multiple event subscribers. Which return value does the event\nsource see after raising an event? Later in this article you'll\nsee how to create event protocols that support event subscribers\nthat report information to the event source.\n\nThe argument list contains two arguments: the sender, and the event\narguments. The compile time type of `sender` is `System.Object`,\neven though you likely know a more derived type that would always\nbe correct. By convention, use `object`.\n\nThe second argument has typically been a type that is derived from\n`System.EventArgs`. (You'll see in the \n[next section](modern-events.md) that this convention is no longer\nenforced.) If your event type does not need any additional\narguments, you will still provide both arguments.\nThere is a special value, `EventArgs.Empty` that you should use to\ndenote that your event does not contain any additional information.\n\nLet's build a class that lists files in a directory, or any of its\nsubdirectories that follow a pattern. This component raises an event\nfor each file found that matches the pattern.\n\nUsing an event model provides some design advantages. You can create\nmultiple event listeners that perform different actions when a sought\nfile is found. Combining the different listeners can create more\nrobust algorithms.\n\nHere is the initial event argument declaration for finding a sought\nfile: \n\n```csharp\npublic class FileFoundArgs : EventArgs\n{\n    public string FoundFile { get; }\n\n    public FileFoundArgs(string fileName)\n    {\n        FoundFile = fileName;\n    }\n}\n```\n\nEven though this type looks like a small, data-only type, you should\nfollow the convention and make it a reference (`class`) type. That\nmeans the argument object will be passed by reference, and any\nupdates to the data will be viewed by all subscribers. The first\nversion is an immutable object. You should prefer to make the\nproperties in your event argument type immutable. That way, one\nsubscriber cannot change the values before another subscriber sees\nthem. (There are exceptions to this, as you'll see below.)  \n\nNext, we need to create the event declaration in the FileSearcher\nclass. Leveraging the `EventHandler<T>` type means that you don't\nneed to create yet another type definition. You simply use a generic\nspecialization.\n\nLet's fill out the FileSearcher class to search for files that match\na pattern, and raise the correct event when a match is discovered.\n\n```csharp\npublic class FileSearcher\n{\n    public event EventHandler<FileFoundArgs> FileFound;\n\n    public void Search(string directory, string searchPattern)\n    {\n        foreach (var file in Directory.EnumerateFiles(directory, searchPattern))\n        {\n            FileFound?.Invoke(this, new FileFoundArgs(file));\n        }\n    }\n}\n```\n\n## Definining and Raising Field-Like Events\n\nThe simplest way to add an event to your class is to declare that\nevent as a public field, as in the above example:\n\n```csharp\npublic event EventHandler<FileFoundArgs> FileFound;\n```\n\nThis looks like it's declaring a public field, which would appear to\nbe bad object oriented practice. You want to protect data access\nthrough properties, or methods. While this make look like a bad\npractice, the code generated by the compiler does create wrappers so\nthat the event objects can only be accessed in safe ways. The only\noperations available on a field-like event are add handler:\n\n```csharp\nEventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>\n    Console.WriteLine(eventArgs.FoundFile);\nlister.FileFound += onFIleFound;\n```\n\nand remove handler:\n\n```csharp\nlister.FileFound -= onFileFound;\n```\n\nNote that there's a local variable for the handler. If you used\nthe body of the lambda, the remove would not work correctly. It would\nbe a different instance of the delegate, and silently do nothing.\n\nCode outside the class cannot raise the event, nor can it perform any\nother operations.\n\n## Returning Values from Event Subscribers\n\nYour simple version is working fine. Let's add another feature:\nCancellation.\n\nWhen you raise the found event, listeners should be able to stop\nfurther processing, if this file is that last one sought.\n\nThe event handlers do not return a value, so you need to communicate\nthat in another way. The standard event pattern uses the EventArgs\nobject to include fields that event subscribers can use to\ncommunicate cancel.\n\nThere are two different patterns that could be used, based on the\nsemantics of the Cancel contract. In both cases, you'll add a boolean\nfield to the EventArguments for the found file event. \n\nOne pattern would allow any one subscriber to cancel the operation.\nFor this pattern, the new field is initialized to `false`. Any\nsubscriber can change it to `true`. After all subscribers have seen\nthe event raised, the FileSearcher component examines the boolean\nvalue and takes action.\n\nThe second pattern would only cancel the operation if all subscribers\nwanted the operation cancelled. In this pattern, the new field is\ninitialized to indicate the operation should cancel, and any\nsubscriber could change it to indicate the operation should continue.\nAfter all subscribers have seen the event raised, the FileSearcher\ncomponent examines the boolean and takes action. There is one extra\nstep in this pattern: the component needs to know if any subscribers\nhave seen the event. If there are no subscribers, the field would\nindicate a cancel incorrectly.\n\nLet's implement the first version for this sample. You need to add a\nboolean field to the FileFoundEventArgs type:\n\n```csharp\npublic class FileFoundArgs : EventArgs\n{\n    public string FoundFile { get; }\n    public bool CancelRequested { get; set; }\n\n    public FileFoundArgs(string fileName)\n    {\n        FoundFile = fileName;\n    }\n}\n```\n\nThis new Field should be initialized to false, so you don't cancel\nfor no reason. That is the default value for a boolean field, so that\nhappens automatically. The only other change to the component is to\ncheck the flag after raising the event to see if any of the\nsubscribers have requested a cancellation:\n\n```csharp\npublic void List(string directory, string searchPattern)\n{\n    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))\n    {\n        var args = new FileFoundArgs(file);\n        FileFound?.Invoke(this, args);\n        if (args.CancelRequested)\n            break;\n    }\n}\n```\n\nOne advantage of this pattern is that it isn't a breaking change.\nNone of the subscribers requested a cancel before, and they still are\nnot. None of the subscriber code needs updating unless they want to\nsupport the new cancel protocol. It's very loosely coupled.\n\nLet's update the subscriber so that it requests a cancellation once\nit finds the first executable:\n\n```csharp\nEventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>\n{\n    Console.WriteLine(eventArgs.FoundFile);\n    eventArgs.CancelRequested = true;\n};\n```\n\n## Adding Another Event Declaration\n\nLet's add one more feature, and demonstrate other language idioms\nfor events. Let's add an overload of the `Search()` method that\ntraverses all subdirectories in search of files.\n\nThis could get to be a lengthy operation in a directory with many\nsub-directories. Let's add an event that gets raised when each new\ndirectory search begins. This enables subscribers to track progress,\nand update the user as to progress. All the samples you've created so\nfar are public. Let's make this one an internal event. That means you\ncan also make the types used for the arguments internal as well.\n\nYou'll start by creating the new EventArgs derived class for\nreporting the new directory and progress. \n\n```csharp\ninternal class SearchDirectoryArgs : EventArgs\n{\n    internal string CurrentSearchDirectory { get; }\n    internal int TotalDirs { get; }\n    internal int CompletedDirs { get; }\n\n    internal SearchDirectoryArgs(string dir, int totalDirs, int completedDirs)\n    {\n        CurrentSearchDirectory = dir;\n        TotalDirs = totalDirs;\n        CompletedDirs = completedDirs;\n    }\n}\n``` \n\nAgain, you can follow the recommendations to make an immutable\nreference type for the event arguments.\n\nNext, define the event. This time, you'll use a different syntax. In\naddition to using the field syntax, you can explicitly create the\nproperty, with add and remove handlers. In this sample, you won't\nneed extra code in those handlers in this project, but this shows how\nyou would create them.\n\n```csharp\ninternal event EventHandler<SearchDirectoryArgs> DirectoryChanged\n{\n    add { directoryChanged += value; }\n    remove { directoryChanged -= value; }\n}\nprivate EventHandler<SearchDirectoryArgs> directoryChanged;\n```\n\nIn may ways, the code you write here mirrors the code the compiler\ngenerates for the field event definitions you've seen earlier. You\ncreate the event using syntax very similar to that used for\n[properties](properties.md). Notice that the handlers have different\nnames: `add` and `remove`. These are called to subscribe to the event,\nor unsubscribe from the event. Notice that you also must declare a\nprivate backing field to store the event variable. It is initialized\nto null.\n\nNext, let's add the overload of the Search() method that traverses\nsubdirectories and raises both events. The easiest way to accomplish\nthis is to use a default argument to specify that you want to search\nall directories:\n\n```csharp\npublic void Search(string directory, string searchPattern, bool searchSubDirs = false)\n{\n    if (searchSubDirs)\n    {\n        var allDirectories = Directory.GetDirectories(directory, \"*.*\", SearchOption.AllDirectories);\n        var completedDirs = 0;\n        var totalDirs = allDirectories.Length + 1;\n        foreach (var dir in allDirectories)\n        {\n            directoryChanged?.Invoke(this,\n                new SearchDirectoryArgs(dir, totalDirs, completedDirs++));\n            // Recursively search this child directory:\n            SearchDirectory(dir, searchPattern);\n        }\n        // Include the Current Directory:\n        directoryChanged?.Invoke(this,\n            new SearchDirectoryArgs(directory, totalDirs, completedDirs++));\n        SearchDirectory(directory, searchPattern);\n    }\n    else\n    {\n        SearchDirectory(directory, searchPattern);\n    }\n}\n\nprivate void SearchDirectory(string directory, string searchPattern)\n{\n    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))\n    {\n        var args = new FileFoundArgs(file);\n        FileFound?.Invoke(this, args);\n        if (args.CancelRequested)\n            break;\n    }\n}\n```\n\nAt this point, you can run the application calling the overload for\nsearching all sub-directories. There are no subscribers on the new\n`ChangeDirectory` event, but using the `?.Invoke()` idiom ensures\nthat this works correctly.\n\n Let's add a handler to write a line that shows the progress in the\n console window. \n\n```csharp\nlister.DirectoryChanged += (sender, eventArgs) =>\n{\n    Console.Write($\"Entering '{eventArgs.CurrentSearchDirectory}'.\");\n    Console.WriteLine($\" {eventArgs.CompletedDirs} of {eventArgs.TotalDirs} completed...\");\n};\n```\n\nYou've seen patterns that are followed throughout the .NET ecosystem.\nBy learning these patterns and conventions, you'll be writing\nidiomatic C# and .NET quickly.\n\nNext, you'll see some changes in these patterns in the most recent\nrelease of .NET.\n\n[Next](modern-events.md)\n","nodes":[{"pos":[11,42],"content":"The Standard .NET Event Pattern","needQuote":true,"needEscape":true,"nodes":[{"content":"The Standard .NET Event Pattern","pos":[0,31]}]},{"pos":[56,87],"content":"The Standard .NET Event Pattern","needQuote":true,"needEscape":true,"nodes":[{"content":"The Standard .NET Event Pattern","pos":[0,31]}]},{"pos":[98,113],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[308,339],"content":"The Standard .NET Event Pattern","linkify":"The Standard .NET Event Pattern","nodes":[{"content":"The Standard .NET Event Pattern","pos":[0,31]}]},{"pos":[341,371],"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](events-overview.md)</ept>","source":"[Previous](events-overview.md)"},{"content":".NET events generally follow a few known patterns.","pos":[373,423]},{"content":"Standardizing on these patterns means that developers can leverage knowledge of those standard patterns, which can be applied to any .NET event program.","pos":[424,576],"source":" Standardizing\non these patterns means that developers can leverage knowledge of\nthose standard patterns, which can be applied to any .NET event program."},{"pos":[578,752],"content":"Let's go through these standard patterns so you will have all the knowledge you need to create standard event sources, and subscribe and process standard events in your code.","source":"Let's go through these standard patterns so you will have all\nthe knowledge you need to create standard event sources, and\nsubscribe and process standard events in your code."},{"pos":[757,782],"content":"Event Delegate Signatures","linkify":"Event Delegate Signatures","nodes":[{"content":"Event Delegate Signatures","pos":[0,25]}]},{"content":"The standard signature for a .NET event delegate is:","pos":[784,836]},{"content":"The return type is void.","pos":[904,928]},{"content":"Events are based on delegates and are multicast delegates.","pos":[929,987],"source":" Events are based on delegates and are\nmulticast delegates."},{"content":"That supports multiple subscribers for any event source.","pos":[988,1044],"source":" That supports multiple subscribers for any\nevent source."},{"content":"The single return value from a method doesn't scale to multiple event subscribers.","pos":[1045,1127],"source":" The single return value from a method doesn't scale\nto multiple event subscribers."},{"content":"Which return value does the event source see after raising an event?","pos":[1128,1196],"source":" Which return value does the event\nsource see after raising an event?"},{"content":"Later in this article you'll see how to create event protocols that support event subscribers that report information to the event source.","pos":[1197,1335],"source":" Later in this article you'll\nsee how to create event protocols that support event subscribers\nthat report information to the event source."},{"content":"The argument list contains two arguments: the sender, and the event arguments.","pos":[1337,1415],"source":"The argument list contains two arguments: the sender, and the event\narguments."},{"content":"The compile time type of <ph id=\"ph1\">`sender`</ph> is <ph id=\"ph2\">`System.Object`</ph>, even though you likely know a more derived type that would always be correct.","pos":[1416,1547],"source":" The compile time type of `sender` is `System.Object`,\neven though you likely know a more derived type that would always\nbe correct."},{"content":"By convention, use <ph id=\"ph1\">`object`</ph>.","pos":[1548,1576],"source":" By convention, use `object`."},{"content":"The second argument has typically been a type that is derived from <ph id=\"ph1\">`System.EventArgs`</ph>.","pos":[1578,1664],"source":"The second argument has typically been a type that is derived from\n`System.EventArgs`."},{"content":"(You'll see in the <bpt id=\"p1\">[</bpt>next section<ept id=\"p1\">](modern-events.md)</ept> that this convention is no longer enforced.) If your event type does not need any additional arguments, you will still provide both arguments.","pos":[1665,1860],"source":" (You'll see in the \n[next section](modern-events.md) that this convention is no longer\nenforced.) If your event type does not need any additional\narguments, you will still provide both arguments."},{"content":"There is a special value, <ph id=\"ph1\">`EventArgs.Empty`</ph> that you should use to denote that your event does not contain any additional information.","pos":[1861,1995],"source":"\nThere is a special value, `EventArgs.Empty` that you should use to\ndenote that your event does not contain any additional information."},{"content":"Let's build a class that lists files in a directory, or any of its subdirectories that follow a pattern.","pos":[1997,2101],"source":"Let's build a class that lists files in a directory, or any of its\nsubdirectories that follow a pattern."},{"content":"This component raises an event for each file found that matches the pattern.","pos":[2102,2178],"source":" This component raises an event\nfor each file found that matches the pattern."},{"content":"Using an event model provides some design advantages.","pos":[2180,2233]},{"content":"You can create multiple event listeners that perform different actions when a sought file is found.","pos":[2234,2333],"source":" You can create\nmultiple event listeners that perform different actions when a sought\nfile is found."},{"content":"Combining the different listeners can create more robust algorithms.","pos":[2334,2402],"source":" Combining the different listeners can create more\nrobust algorithms."},{"pos":[2404,2477],"content":"Here is the initial event argument declaration for finding a sought file:","source":"Here is the initial event argument declaration for finding a sought\nfile:"},{"content":"Even though this type looks like a small, data-only type, you should follow the convention and make it a reference (<ph id=\"ph1\">`class`</ph>) type.","pos":[2660,2790],"source":"Even though this type looks like a small, data-only type, you should\nfollow the convention and make it a reference (`class`) type."},{"content":"That means the argument object will be passed by reference, and any updates to the data will be viewed by all subscribers.","pos":[2791,2913],"source":" That\nmeans the argument object will be passed by reference, and any\nupdates to the data will be viewed by all subscribers."},{"content":"The first version is an immutable object.","pos":[2914,2955],"source":" The first\nversion is an immutable object."},{"content":"You should prefer to make the properties in your event argument type immutable.","pos":[2956,3035],"source":" You should prefer to make the\nproperties in your event argument type immutable."},{"content":"That way, one subscriber cannot change the values before another subscriber sees them.","pos":[3036,3122],"source":" That way, one\nsubscriber cannot change the values before another subscriber sees\nthem."},{"content":"(There are exceptions to this, as you'll see below.)","pos":[3123,3175]},{"content":"Next, we need to create the event declaration in the FileSearcher class.","pos":[3179,3251],"source":"Next, we need to create the event declaration in the FileSearcher\nclass."},{"content":"Leveraging the <ph id=\"ph1\">`EventHandler&lt;T&gt;`</ph> type means that you don't need to create yet another type definition.","pos":[3252,3354],"source":" Leveraging the `EventHandler<T>` type means that you don't\nneed to create yet another type definition."},{"content":"You simply use a generic specialization.","pos":[3355,3395],"source":" You simply use a generic\nspecialization."},{"pos":[3397,3532],"content":"Let's fill out the FileSearcher class to search for files that match a pattern, and raise the correct event when a match is discovered.","source":"Let's fill out the FileSearcher class to search for files that match\na pattern, and raise the correct event when a match is discovered."},{"pos":[3877,3917],"content":"Definining and Raising Field-Like Events","linkify":"Definining and Raising Field-Like Events","nodes":[{"content":"Definining and Raising Field-Like Events","pos":[0,40]}]},{"pos":[3919,4034],"content":"The simplest way to add an event to your class is to declare that event as a public field, as in the above example:","source":"The simplest way to add an event to your class is to declare that\nevent as a public field, as in the above example:"},{"content":"This looks like it's declaring a public field, which would appear to be bad object oriented practice.","pos":[4103,4204],"source":"This looks like it's declaring a public field, which would appear to\nbe bad object oriented practice."},{"content":"You want to protect data access through properties, or methods.","pos":[4205,4268],"source":" You want to protect data access\nthrough properties, or methods."},{"content":"While this make look like a bad practice, the code generated by the compiler does create wrappers so that the event objects can only be accessed in safe ways.","pos":[4269,4427],"source":" While this make look like a bad\npractice, the code generated by the compiler does create wrappers so\nthat the event objects can only be accessed in safe ways."},{"content":"The only operations available on a field-like event are add handler:","pos":[4428,4496],"source":" The only\noperations available on a field-like event are add handler:"},{"content":"and remove handler:","pos":[4655,4674]},{"content":"Note that there's a local variable for the handler.","pos":[4724,4775]},{"content":"If you used the body of the lambda, the remove would not work correctly.","pos":[4776,4848],"source":" If you used\nthe body of the lambda, the remove would not work correctly."},{"content":"It would be a different instance of the delegate, and silently do nothing.","pos":[4849,4923],"source":" It would\nbe a different instance of the delegate, and silently do nothing."},{"pos":[4925,5012],"content":"Code outside the class cannot raise the event, nor can it perform any other operations.","source":"Code outside the class cannot raise the event, nor can it perform any\nother operations."},{"pos":[5017,5056],"content":"Returning Values from Event Subscribers","linkify":"Returning Values from Event Subscribers","nodes":[{"content":"Returning Values from Event Subscribers","pos":[0,39]}]},{"content":"Your simple version is working fine.","pos":[5058,5094]},{"content":"Let's add another feature: Cancellation.","pos":[5095,5135],"source":" Let's add another feature:\nCancellation."},{"pos":[5137,5259],"content":"When you raise the found event, listeners should be able to stop further processing, if this file is that last one sought.","source":"When you raise the found event, listeners should be able to stop\nfurther processing, if this file is that last one sought."},{"content":"The event handlers do not return a value, so you need to communicate that in another way.","pos":[5261,5350],"source":"The event handlers do not return a value, so you need to communicate\nthat in another way."},{"content":"The standard event pattern uses the EventArgs object to include fields that event subscribers can use to communicate cancel.","pos":[5351,5475],"source":" The standard event pattern uses the EventArgs\nobject to include fields that event subscribers can use to\ncommunicate cancel."},{"content":"There are two different patterns that could be used, based on the semantics of the Cancel contract.","pos":[5477,5576],"source":"There are two different patterns that could be used, based on the\nsemantics of the Cancel contract."},{"content":"In both cases, you'll add a boolean field to the EventArguments for the found file event.","pos":[5577,5666],"source":" In both cases, you'll add a boolean\nfield to the EventArguments for the found file event."},{"content":"One pattern would allow any one subscriber to cancel the operation.","pos":[5669,5736]},{"content":"For this pattern, the new field is initialized to <ph id=\"ph1\">`false`</ph>.","pos":[5737,5795],"source":"\nFor this pattern, the new field is initialized to `false`."},{"content":"Any subscriber can change it to <ph id=\"ph1\">`true`</ph>.","pos":[5796,5835],"source":" Any\nsubscriber can change it to `true`."},{"content":"After all subscribers have seen the event raised, the FileSearcher component examines the boolean value and takes action.","pos":[5836,5957],"source":" After all subscribers have seen\nthe event raised, the FileSearcher component examines the boolean\nvalue and takes action."},{"content":"The second pattern would only cancel the operation if all subscribers wanted the operation cancelled.","pos":[5959,6060],"source":"The second pattern would only cancel the operation if all subscribers\nwanted the operation cancelled."},{"content":"In this pattern, the new field is initialized to indicate the operation should cancel, and any subscriber could change it to indicate the operation should continue.","pos":[6061,6225],"source":" In this pattern, the new field is\ninitialized to indicate the operation should cancel, and any\nsubscriber could change it to indicate the operation should continue."},{"content":"After all subscribers have seen the event raised, the FileSearcher component examines the boolean and takes action.","pos":[6226,6341],"source":"\nAfter all subscribers have seen the event raised, the FileSearcher\ncomponent examines the boolean and takes action."},{"content":"There is one extra step in this pattern: the component needs to know if any subscribers have seen the event.","pos":[6342,6450],"source":" There is one extra\nstep in this pattern: the component needs to know if any subscribers\nhave seen the event."},{"content":"If there are no subscribers, the field would indicate a cancel incorrectly.","pos":[6451,6526],"source":" If there are no subscribers, the field would\nindicate a cancel incorrectly."},{"content":"Let's implement the first version for this sample.","pos":[6528,6578]},{"content":"You need to add a boolean field to the FileFoundEventArgs type:","pos":[6579,6642],"source":" You need to add a\nboolean field to the FileFoundEventArgs type:"},{"content":"This new Field should be initialized to false, so you don't cancel for no reason.","pos":[6870,6951],"source":"This new Field should be initialized to false, so you don't cancel\nfor no reason."},{"content":"That is the default value for a boolean field, so that happens automatically.","pos":[6952,7029],"source":" That is the default value for a boolean field, so that\nhappens automatically."},{"content":"The only other change to the component is to check the flag after raising the event to see if any of the subscribers have requested a cancellation:","pos":[7030,7177],"source":" The only other change to the component is to\ncheck the flag after raising the event to see if any of the\nsubscribers have requested a cancellation:"},{"content":"One advantage of this pattern is that it isn't a breaking change.","pos":[7480,7545]},{"content":"None of the subscribers requested a cancel before, and they still are not.","pos":[7546,7620],"source":"\nNone of the subscribers requested a cancel before, and they still are\nnot."},{"content":"None of the subscriber code needs updating unless they want to support the new cancel protocol.","pos":[7621,7716],"source":" None of the subscriber code needs updating unless they want to\nsupport the new cancel protocol."},{"content":"It's very loosely coupled.","pos":[7717,7743]},{"pos":[7745,7843],"content":"Let's update the subscriber so that it requests a cancellation once it finds the first executable:","source":"Let's update the subscriber so that it requests a cancellation once\nit finds the first executable:"},{"pos":[8015,8047],"content":"Adding Another Event Declaration","linkify":"Adding Another Event Declaration","nodes":[{"content":"Adding Another Event Declaration","pos":[0,32]}]},{"content":"Let's add one more feature, and demonstrate other language idioms for events.","pos":[8049,8126],"source":"Let's add one more feature, and demonstrate other language idioms\nfor events."},{"content":"Let's add an overload of the <ph id=\"ph1\">`Search()`</ph> method that traverses all subdirectories in search of files.","pos":[8127,8227],"source":" Let's add an overload of the `Search()` method that\ntraverses all subdirectories in search of files."},{"content":"This could get to be a lengthy operation in a directory with many sub-directories.","pos":[8229,8311],"source":"This could get to be a lengthy operation in a directory with many\nsub-directories."},{"content":"Let's add an event that gets raised when each new directory search begins.","pos":[8312,8386],"source":" Let's add an event that gets raised when each new\ndirectory search begins."},{"content":"This enables subscribers to track progress, and update the user as to progress.","pos":[8387,8466],"source":" This enables subscribers to track progress,\nand update the user as to progress."},{"content":"All the samples you've created so far are public.","pos":[8467,8516],"source":" All the samples you've created so\nfar are public."},{"content":"Let's make this one an internal event.","pos":[8517,8555]},{"content":"That means you can also make the types used for the arguments internal as well.","pos":[8556,8635],"source":" That means you\ncan also make the types used for the arguments internal as well."},{"pos":[8637,8739],"content":"You'll start by creating the new EventArgs derived class for reporting the new directory and progress.","source":"You'll start by creating the new EventArgs derived class for\nreporting the new directory and progress."},{"pos":[9137,9239],"content":"Again, you can follow the recommendations to make an immutable reference type for the event arguments.","source":"Again, you can follow the recommendations to make an immutable\nreference type for the event arguments."},{"content":"Next, define the event.","pos":[9241,9264]},{"content":"This time, you'll use a different syntax.","pos":[9265,9306]},{"content":"In addition to using the field syntax, you can explicitly create the property, with add and remove handlers.","pos":[9307,9415],"source":" In\naddition to using the field syntax, you can explicitly create the\nproperty, with add and remove handlers."},{"content":"In this sample, you won't need extra code in those handlers in this project, but this shows how you would create them.","pos":[9416,9534],"source":" In this sample, you won't\nneed extra code in those handlers in this project, but this shows how\nyou would create them."},{"content":"In may ways, the code you write here mirrors the code the compiler generates for the field event definitions you've seen earlier.","pos":[9762,9891],"source":"In may ways, the code you write here mirrors the code the compiler\ngenerates for the field event definitions you've seen earlier."},{"content":"You create the event using syntax very similar to that used for <bpt id=\"p1\">[</bpt>properties<ept id=\"p1\">](properties.md)</ept>.","pos":[9892,9984],"source":" You\ncreate the event using syntax very similar to that used for\n[properties](properties.md)."},{"content":"Notice that the handlers have different names: <ph id=\"ph1\">`add`</ph> and <ph id=\"ph2\">`remove`</ph>.","pos":[9985,10051],"source":" Notice that the handlers have different\nnames: `add` and `remove`."},{"content":"These are called to subscribe to the event, or unsubscribe from the event.","pos":[10052,10126],"source":" These are called to subscribe to the event,\nor unsubscribe from the event."},{"content":"Notice that you also must declare a private backing field to store the event variable.","pos":[10127,10213],"source":" Notice that you also must declare a\nprivate backing field to store the event variable."},{"content":"It is initialized to null.","pos":[10214,10240],"source":" It is initialized\nto null."},{"content":"Next, let's add the overload of the Search() method that traverses subdirectories and raises both events.","pos":[10242,10347],"source":"Next, let's add the overload of the Search() method that traverses\nsubdirectories and raises both events."},{"content":"The easiest way to accomplish this is to use a default argument to specify that you want to search all directories:","pos":[10348,10463],"source":" The easiest way to accomplish\nthis is to use a default argument to specify that you want to search\nall directories:"},{"content":"At this point, you can run the application calling the overload for searching all sub-directories.","pos":[11657,11755],"source":"At this point, you can run the application calling the overload for\nsearching all sub-directories."},{"content":"There are no subscribers on the new <ph id=\"ph1\">`ChangeDirectory`</ph> event, but using the <ph id=\"ph2\">`?.Invoke()`</ph> idiom ensures that this works correctly.","pos":[11756,11884],"source":" There are no subscribers on the new\n`ChangeDirectory` event, but using the `?.Invoke()` idiom ensures\nthat this works correctly."},{"pos":[11887,11970],"content":"Let's add a handler to write a line that shows the progress in the console window.","source":"Let's add a handler to write a line that shows the progress in the\n console window."},{"content":"You've seen patterns that are followed throughout the .NET ecosystem.","pos":[12205,12274]},{"content":"By learning these patterns and conventions, you'll be writing idiomatic C# and .NET quickly.","pos":[12275,12367],"source":"\nBy learning these patterns and conventions, you'll be writing\nidiomatic C# and .NET quickly."},{"pos":[12369,12452],"content":"Next, you'll see some changes in these patterns in the most recent release of .NET.","source":"Next, you'll see some changes in these patterns in the most recent\nrelease of .NET."},{"pos":[12454,12478],"content":"<bpt id=\"p1\">[</bpt>Next<ept id=\"p1\">](modern-events.md)</ept>","source":"[Next](modern-events.md)"}]}