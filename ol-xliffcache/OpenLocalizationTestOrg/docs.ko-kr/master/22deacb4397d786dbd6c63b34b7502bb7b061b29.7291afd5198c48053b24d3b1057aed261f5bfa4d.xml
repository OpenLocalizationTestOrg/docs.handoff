{"content":"---\ntitle: \"Cleaning Up Unmanaged Resources | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Close method\"\n  - \"Dispose method\"\n  - \"garbage collector\"\n  - \"garbage collection, unmanaged resources\"\n  - \"cleanup operations\"\n  - \"explicit cleanups\"\n  - \"unmanaged resource cleanup\"\n  - \"Finalize method\"\nms.assetid: a17b0066-71c2-4ba4-9822-8e19332fc213\ncaps.latest.revision: 19\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Cleaning Up Unmanaged Resources\nFor the majority of the objects that your app creates, you can rely on .NET's garbage collector to handle memory management. However, when you create objects that include unmanaged resources, you must explicitly release those resources when you finish using them in your app. The most common types of unmanaged resource are objects that wrap operating system resources, such as files, windows, network connections, or database connections. Although the garbage collector is able to track the lifetime of an object that encapsulates an unmanaged resource, it doesn't know how to release and clean up the unmanaged resource.  \n  \n If your types use unmanaged resources, you should do the following:  \n  \n-   Implement the [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md). This requires that you provide an <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to enable the deterministic release of  unmanaged resources. A consumer of your type calls <xref:System.IDisposable.Dispose%2A> when the object (and the resources it uses) is no longer needed. The <xref:System.IDisposable.Dispose%2A> method immediately releases the unmanaged resources.  \n  \n-   Provide for your unmanaged resources to be released in the event that a consumer of your type forgets to call <xref:System.IDisposable.Dispose%2A>. There are two ways to do this:  \n  \n    -   Use a safe handle to wrap your unmanaged resource. This is the recommended technique. Safe handles are derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class and include a robust <xref:System.Object.Finalize%2A> method. When you use a safe handle, you simply implement the <xref:System.IDisposable> interface and call your safe handle's <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method in your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation. The safe handle's finalizer is called automatically by the garbage collector if its <xref:System.IDisposable.Dispose%2A> method is not called.  \n  \n         —or—  \n  \n    -   Override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method. Finalization enables the non-deterministic release of unmanaged resources when the consumer of a type fails to call <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> to dispose of them deterministically. However, because object finalization can be a complex and error-prone operation, we recommend that you use a safe handle instead of providing your own finalizer.  \n  \n Consumers of your type can then call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation directly to free memory used by unmanaged resources. When you properly implement a <xref:System.IDisposable.Dispose%2A> method, either your safe handle's <xref:System.Object.Finalize%2A> method or your own override of the <xref:System.Object.Finalize%2A?displayProperty=fullName> method becomes a safeguard to clean up resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.  \n  \n## In This Section  \n [Implementing a Dispose Method](../../../docs/standard/garbage-collection/implementing-dispose.md)  \n Describes how to implement the [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md) for releasing unmanaged resources.  \n  \n [Using Objects That Implement IDisposable](../../../docs/standard/garbage-collection/using-objects.md)  \n Describes how consumers of a type ensure that its <xref:System.IDisposable.Dispose%2A> implementation is called. We recommend using the C# `using` statement or the Visual Basic `Using` statement to do this.  \n  \n## Reference  \n <xref:System.IDisposable?displayProperty=fullName>  \n Defines the <xref:System.IDisposable.Dispose%2A> method for releasing unmanaged resources.  \n  \n <xref:System.Object.Finalize%2A?displayProperty=fullName>  \n Provides for object finalization if unmanaged resources are not released by the <xref:System.IDisposable.Dispose%2A> method.  \n  \n <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>  \n Suppresses finalization. This method is customarily called from a `Dispose` method to prevent a finalizer from executing.","nodes":[{"pos":[12,60],"content":"Cleaning Up Unmanaged Resources | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Cleaning Up Unmanaged Resources | Microsoft Docs","pos":[0,48]}]},{"pos":[588,619],"content":"Cleaning Up Unmanaged Resources","linkify":"Cleaning Up Unmanaged Resources","nodes":[{"content":"Cleaning Up Unmanaged Resources","pos":[0,31]}]},{"content":"For the majority of the objects that your app creates, you can rely on .NET's garbage collector to handle memory management.","pos":[620,744]},{"content":"However, when you create objects that include unmanaged resources, you must explicitly release those resources when you finish using them in your app.","pos":[745,895]},{"content":"The most common types of unmanaged resource are objects that wrap operating system resources, such as files, windows, network connections, or database connections.","pos":[896,1059]},{"content":"Although the garbage collector is able to track the lifetime of an object that encapsulates an unmanaged resource, it doesn't know how to release and clean up the unmanaged resource.","pos":[1060,1242]},{"content":"If your types use unmanaged resources, you should do the following:","pos":[1249,1316]},{"content":"Implement the <bpt id=\"p1\">[</bpt>dispose pattern<ept id=\"p1\">](../../../docs/standard/design-guidelines/dispose-pattern.md)</ept>.","pos":[1326,1419],"source":"Implement the [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md)."},{"content":"This requires that you provide an <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation to enable the deterministic release of  unmanaged resources.","pos":[1420,1591],"source":" This requires that you provide an <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to enable the deterministic release of  unmanaged resources."},{"content":"A consumer of your type calls <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> when the object (and the resources it uses) is no longer needed.","pos":[1592,1723],"source":" A consumer of your type calls <xref:System.IDisposable.Dispose%2A> when the object (and the resources it uses) is no longer needed."},{"content":"The <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method immediately releases the unmanaged resources.","pos":[1724,1817],"source":" The <xref:System.IDisposable.Dispose%2A> method immediately releases the unmanaged resources."},{"content":"Provide for your unmanaged resources to be released in the event that a consumer of your type forgets to call <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>.","pos":[1827,1974],"source":"Provide for your unmanaged resources to be released in the event that a consumer of your type forgets to call <xref:System.IDisposable.Dispose%2A>."},{"content":"There are two ways to do this:","pos":[1975,2005]},{"content":"Use a safe handle to wrap your unmanaged resource.","pos":[2019,2069]},{"content":"This is the recommended technique.","pos":[2070,2104]},{"content":"Safe handles are derived from the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph> class and include a robust <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.","pos":[2105,2280],"source":" Safe handles are derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class and include a robust <xref:System.Object.Finalize%2A> method."},{"content":"When you use a safe handle, you simply implement the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface and call your safe handle's <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method in your <ph id=\"ph3\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation.","pos":[2281,2550],"source":" When you use a safe handle, you simply implement the <xref:System.IDisposable> interface and call your safe handle's <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method in your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation."},{"content":"The safe handle's finalizer is called automatically by the garbage collector if its <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.","pos":[2551,2693],"source":" The safe handle's finalizer is called automatically by the garbage collector if its <xref:System.IDisposable.Dispose%2A> method is not called."},{"content":"—or—","pos":[2708,2712]},{"content":"Override the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[2726,2804],"source":"Override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method."},{"content":"Finalization enables the non-deterministic release of unmanaged resources when the consumer of a type fails to call <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> to dispose of them deterministically.","pos":[2805,3020],"source":" Finalization enables the non-deterministic release of unmanaged resources when the consumer of a type fails to call <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> to dispose of them deterministically."},{"content":"However, because object finalization can be a complex and error-prone operation, we recommend that you use a safe handle instead of providing your own finalizer.","pos":[3021,3182]},{"content":"Consumers of your type can then call your <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation directly to free memory used by unmanaged resources.","pos":[3189,3360],"source":"Consumers of your type can then call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation directly to free memory used by unmanaged resources."},{"content":"When you properly implement a <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method, either your safe handle's <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method or your own override of the <ph id=\"ph3\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method becomes a safeguard to clean up resources in the event that the <ph id=\"ph4\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.","pos":[3361,3717],"source":" When you properly implement a <xref:System.IDisposable.Dispose%2A> method, either your safe handle's <xref:System.Object.Finalize%2A> method or your own override of the <xref:System.Object.Finalize%2A?displayProperty=fullName> method becomes a safeguard to clean up resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called."},{"pos":[3726,3741],"content":"In This Section","linkify":"In This Section","nodes":[{"content":"In This Section","pos":[0,15]}]},{"content":"<bpt id=\"p1\">[</bpt>Implementing a Dispose Method<ept id=\"p1\">](../../../docs/standard/garbage-collection/implementing-dispose.md)</ept>","pos":[3745,3843],"source":"[Implementing a Dispose Method](../../../docs/standard/garbage-collection/implementing-dispose.md)"},{"content":"Describes how to implement the <bpt id=\"p1\">[</bpt>dispose pattern<ept id=\"p1\">](../../../docs/standard/design-guidelines/dispose-pattern.md)</ept> for releasing unmanaged resources.","pos":[3847,3991],"source":" Describes how to implement the [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md) for releasing unmanaged resources."},{"content":"<bpt id=\"p1\">[</bpt>Using Objects That Implement IDisposable<ept id=\"p1\">](../../../docs/standard/garbage-collection/using-objects.md)</ept>","pos":[3998,4100],"source":"[Using Objects That Implement IDisposable](../../../docs/standard/garbage-collection/using-objects.md)"},{"content":"Describes how consumers of a type ensure that its <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation is called.","pos":[4104,4216],"source":" Describes how consumers of a type ensure that its <xref:System.IDisposable.Dispose%2A> implementation is called."},{"content":"We recommend using the C# <ph id=\"ph1\">`using`</ph> statement or the Visual Basic <ph id=\"ph2\">`Using`</ph> statement to do this.","pos":[4217,4310],"source":" We recommend using the C# `using` statement or the Visual Basic `Using` statement to do this."},{"pos":[4319,4328],"content":"Reference","linkify":"Reference","nodes":[{"content":"Reference","pos":[0,9]}]},{"content":"Defines the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method for releasing unmanaged resources.","pos":[4386,4476],"source":"Defines the <xref:System.IDisposable.Dispose%2A> method for releasing unmanaged resources."},{"content":"Provides for object finalization if unmanaged resources are not released by the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[4544,4668],"source":"Provides for object finalization if unmanaged resources are not released by the <xref:System.IDisposable.Dispose%2A> method."},{"content":"Suppresses finalization.","pos":[4740,4764]},{"content":"This method is customarily called from a <ph id=\"ph1\">`Dispose`</ph> method to prevent a finalizer from executing.","pos":[4765,4861],"source":" This method is customarily called from a `Dispose` method to prevent a finalizer from executing."}]}