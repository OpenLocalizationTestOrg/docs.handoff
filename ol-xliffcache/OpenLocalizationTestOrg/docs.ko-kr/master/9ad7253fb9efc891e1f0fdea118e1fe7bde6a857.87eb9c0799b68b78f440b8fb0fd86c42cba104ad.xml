{"content":"---\ntitle: \"Inheritance - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"abstract methods [C#]\"\n  - \"abstract classes [C#]\"\n  - \"inheritance [C#]\"\n  - \"derived classes [C#]\"\n  - \"virtual methods [C#]\"\n  - \"C# language, inheritance\"\nms.assetid: 81d64ee4-50f9-4d6c-a8dc-257c348d2eea\n---\n# Inheritance (C# Programming Guide)\n\nInheritance, together with encapsulation and polymorphism, is one of the three primary characteristics of object-oriented programming. Inheritance enables you to create new classes that reuse, extend, and modify the behavior that is defined in other classes. The class whose members are inherited is called the *base class*, and the class that inherits those members is called the *derived class*. A derived class can have only one direct base class. However, inheritance is transitive. If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the members declared in ClassB and ClassA.  \n  \n> [!NOTE]\n>  Structs do not support inheritance, but they can implement interfaces. For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).  \n  \n Conceptually, a derived class is a specialization of the base class. For example, if you have a base class `Animal`, you might have one derived class that is named `Mammal` and another derived class that is named `Reptile`. A `Mammal` is an `Animal`, and a `Reptile` is an `Animal`, but each derived class represents different specializations of the base class.  \n  \n When you define a class to derive from another class, the derived class implicitly gains all the members of the base class, except for its constructors and finalizers. The derived class can thereby reuse the code in the base class without having to re-implement it. In the derived class, you can add more members. In this manner, the derived class extends the functionality of the base class.  \n  \n The following illustration shows a class `WorkItem` that represents an item of work in some business process. Like all classes, it derives from <xref:System.Object?displayProperty=nameWithType> and inherits all its methods. `WorkItem` adds five members of its own. These include a constructor, because constructors are not inherited. Class `ChangeRequest` inherits from `WorkItem` and represents a particular kind of work item. `ChangeRequest` adds two more members to the members that it inherits from `WorkItem` and from <xref:System.Object>. It must add its own constructor, and it also adds `originalItemID`. Property `originalItemID` enables the `ChangeRequest` instance to be associated with the original `WorkItem` to which the change request applies.  \n  \n ![Diagram that shows class inheritance](./media/inheritance/class-inheritance-diagram.png)  \n  \n The following example shows how the class relationships demonstrated in the previous illustration are expressed in C#. The example also shows how `WorkItem` overrides the virtual method <xref:System.Object.ToString%2A?displayProperty=nameWithType>, and how the `ChangeRequest` class inherits the `WorkItem` implementation of the method.  \n  \n [!code-csharp[csProgGuideInheritance#49](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#49)]  \n  \n## Abstract and Virtual Methods  \n When a base class declares a method as [virtual](../../../csharp/language-reference/keywords/virtual.md), a derived class can [override](../../../csharp/language-reference/keywords/override.md) the method with its own implementation. If a base class declares a member as [abstract](../../../csharp/language-reference/keywords/abstract.md), that method must be overridden in any non-abstract class that directly inherits from that class. If a derived class is itself abstract, it inherits abstract members without implementing them. Abstract and virtual members are the basis for polymorphism, which is the second primary characteristic of object-oriented programming. For more information, see [Polymorphism](../../../csharp/programming-guide/classes-and-structs/polymorphism.md).  \n  \n## Abstract Base Classes  \n You can declare a class as [abstract](../../../csharp/language-reference/keywords/abstract.md) if you want to prevent direct instantiation by using the [new](../../../csharp/language-reference/keywords/new.md) keyword. If you do this, the class can be used only if a new class is derived from it. An abstract class can contain one or more method signatures that themselves are declared as abstract. These signatures specify the parameters and return value but have no implementation (method body). An abstract class does not have to contain abstract members; however, if a class does contain an abstract member, the class itself must be declared as abstract. Derived classes that are not abstract themselves must provide the implementation for any abstract methods from an abstract base class. For more information, see [Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  \n  \n## Interfaces  \n An *interface* is a reference type that is somewhat similar to an abstract base class that consists of only abstract members. When a class implements an interface, it must provide an implementation for all the members of the interface. A class can implement multiple interfaces even though it can derive from only a single direct base class.  \n  \n Interfaces are used to define specific capabilities for classes that do not necessarily have an \"is a\" relationship. For example, the <xref:System.IEquatable%601?displayProperty=nameWithType> interface can be implemented by any class or struct that has to enable client code to determine whether two objects of the type are equivalent (however the type defines equivalence). <xref:System.IEquatable%601> does not imply the same kind of \"is a\" relationship that exists between a base class and a derived class (for example, a `Mammal` is an `Animal`). For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).  \n  \n## Preventing Further Derivation  \n A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as [sealed](../../../csharp/language-reference/keywords/sealed.md). For more information, see [Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  \n  \n## Derived Class Hiding of Base Class Members  \n A derived class can hide base class members by declaring members with the same name and signature. The [new](../../../csharp/language-reference/keywords/new.md) modifier can be used to explicitly indicate that the member is not intended to be an override of the base member. The use of [new](../../../csharp/language-reference/keywords/new.md) is not required, but a compiler warning will be generated if [new](../../../csharp/language-reference/keywords/new.md) is not used. For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md) and [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).  \n  \n## See also\n\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)\n- [class](../../../csharp/language-reference/keywords/class.md)\n- [struct](../../../csharp/language-reference/keywords/struct.md)\n","nodes":[{"pos":[4,322],"embed":true,"restype":"x-metadata","content":"title: \"Inheritance - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"abstract methods [C#]\"\n  - \"abstract classes [C#]\"\n  - \"inheritance [C#]\"\n  - \"derived classes [C#]\"\n  - \"virtual methods [C#]\"\n  - \"C# language, inheritance\"\nms.assetid: 81d64ee4-50f9-4d6c-a8dc-257c348d2eea","nodes":[{"content":"Inheritance - C# Programming Guide","nodes":[{"pos":[0,34],"content":"Inheritance - C# Programming Guide","nodes":[{"content":"Inheritance - C# Programming Guide","pos":[0,34]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[329,363],"content":"Inheritance (C# Programming Guide)","linkify":"Inheritance (C# Programming Guide)","nodes":[{"content":"Inheritance (C# Programming Guide)","pos":[0,34]}]},{"content":"Inheritance, together with encapsulation and polymorphism, is one of the three primary characteristics of object-oriented programming.","pos":[365,499]},{"content":"Inheritance enables you to create new classes that reuse, extend, and modify the behavior that is defined in other classes.","pos":[500,623]},{"content":"The class whose members are inherited is called the <bpt id=\"p1\">*</bpt>base class<ept id=\"p1\">*</ept>, and the class that inherits those members is called the <bpt id=\"p2\">*</bpt>derived class<ept id=\"p2\">*</ept>.","pos":[624,762],"source":" The class whose members are inherited is called the *base class*, and the class that inherits those members is called the *derived class*."},{"content":"A derived class can have only one direct base class.","pos":[763,815]},{"content":"However, inheritance is transitive.","pos":[816,851]},{"content":"If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the members declared in ClassB and ClassA.","pos":[852,979]},{"pos":[987,1163],"content":"[!NOTE]\n Structs do not support inheritance, but they can implement interfaces. For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).","leadings":["","> "],"nodes":[{"content":"Structs do not support inheritance, but they can implement interfaces. For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).","pos":[9,174],"nodes":[{"content":"Structs do not support inheritance, but they can implement interfaces.","pos":[0,70]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Interfaces<ept id=\"p1\">](../../../csharp/programming-guide/interfaces/index.md)</ept>.","pos":[71,165],"source":" For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md)."}]}]},{"content":"Conceptually, a derived class is a specialization of the base class.","pos":[1170,1238]},{"content":"For example, if you have a base class <ph id=\"ph1\">`Animal`</ph>, you might have one derived class that is named <ph id=\"ph2\">`Mammal`</ph> and another derived class that is named <ph id=\"ph3\">`Reptile`</ph>.","pos":[1239,1393],"source":" For example, if you have a base class `Animal`, you might have one derived class that is named `Mammal` and another derived class that is named `Reptile`."},{"content":"A <ph id=\"ph1\">`Mammal`</ph> is an <ph id=\"ph2\">`Animal`</ph>, and a <ph id=\"ph3\">`Reptile`</ph> is an <ph id=\"ph4\">`Animal`</ph>, but each derived class represents different specializations of the base class.","pos":[1394,1531],"source":" A `Mammal` is an `Animal`, and a `Reptile` is an `Animal`, but each derived class represents different specializations of the base class."},{"content":"When you define a class to derive from another class, the derived class implicitly gains all the members of the base class, except for its constructors and finalizers.","pos":[1538,1705]},{"content":"The derived class can thereby reuse the code in the base class without having to re-implement it.","pos":[1706,1803]},{"content":"In the derived class, you can add more members.","pos":[1804,1851]},{"content":"In this manner, the derived class extends the functionality of the base class.","pos":[1852,1930]},{"content":"The following illustration shows a class <ph id=\"ph1\">`WorkItem`</ph> that represents an item of work in some business process.","pos":[1937,2046],"source":"The following illustration shows a class `WorkItem` that represents an item of work in some business process."},{"content":"Like all classes, it derives from <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> and inherits all its methods.","pos":[2047,2160],"source":" Like all classes, it derives from <xref:System.Object?displayProperty=nameWithType> and inherits all its methods."},{"content":"<ph id=\"ph1\">`WorkItem`</ph> adds five members of its own.","pos":[2161,2201],"source":"`WorkItem` adds five members of its own."},{"content":"These include a constructor, because constructors are not inherited.","pos":[2202,2270]},{"content":"Class <ph id=\"ph1\">`ChangeRequest`</ph> inherits from <ph id=\"ph2\">`WorkItem`</ph> and represents a particular kind of work item.","pos":[2271,2364],"source":" Class `ChangeRequest` inherits from `WorkItem` and represents a particular kind of work item."},{"content":"<ph id=\"ph1\">`ChangeRequest`</ph> adds two more members to the members that it inherits from <ph id=\"ph2\">`WorkItem`</ph> and from <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>.","pos":[2365,2481],"source":"`ChangeRequest` adds two more members to the members that it inherits from `WorkItem` and from <xref:System.Object>."},{"content":"It must add its own constructor, and it also adds <ph id=\"ph1\">`originalItemID`</ph>.","pos":[2482,2549],"source":" It must add its own constructor, and it also adds `originalItemID`."},{"content":"Property <ph id=\"ph1\">`originalItemID`</ph> enables the <ph id=\"ph2\">`ChangeRequest`</ph> instance to be associated with the original <ph id=\"ph3\">`WorkItem`</ph> to which the change request applies.","pos":[2550,2695],"source":" Property `originalItemID` enables the `ChangeRequest` instance to be associated with the original `WorkItem` to which the change request applies."},{"content":"Diagram that shows class inheritance","pos":[2704,2740]},{"content":"The following example shows how the class relationships demonstrated in the previous illustration are expressed in C#.","pos":[2799,2917]},{"content":"The example also shows how <ph id=\"ph1\">`WorkItem`</ph> overrides the virtual method <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>, and how the <ph id=\"ph3\">`ChangeRequest`</ph> class inherits the <ph id=\"ph4\">`WorkItem`</ph> implementation of the method.","pos":[2918,3135],"source":" The example also shows how `WorkItem` overrides the virtual method <xref:System.Object.ToString%2A?displayProperty=nameWithType>, and how the `ChangeRequest` class inherits the `WorkItem` implementation of the method."},{"pos":[3284,3312],"content":"Abstract and Virtual Methods","linkify":"Abstract and Virtual Methods","nodes":[{"content":"Abstract and Virtual Methods","pos":[0,28]}]},{"content":"When a base class declares a method as <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../../../csharp/language-reference/keywords/virtual.md)</ept>, a derived class can <bpt id=\"p2\">[</bpt>override<ept id=\"p2\">](../../../csharp/language-reference/keywords/override.md)</ept> the method with its own implementation.","pos":[3316,3549],"source":"When a base class declares a method as [virtual](../../../csharp/language-reference/keywords/virtual.md), a derived class can [override](../../../csharp/language-reference/keywords/override.md) the method with its own implementation."},{"content":"If a base class declares a member as <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../../../csharp/language-reference/keywords/abstract.md)</ept>, that method must be overridden in any non-abstract class that directly inherits from that class.","pos":[3550,3752],"source":" If a base class declares a member as [abstract](../../../csharp/language-reference/keywords/abstract.md), that method must be overridden in any non-abstract class that directly inherits from that class."},{"content":"If a derived class is itself abstract, it inherits abstract members without implementing them.","pos":[3753,3847]},{"content":"Abstract and virtual members are the basis for polymorphism, which is the second primary characteristic of object-oriented programming.","pos":[3848,3983]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Polymorphism<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/polymorphism.md)</ept>.","pos":[3984,4096],"source":" For more information, see [Polymorphism](../../../csharp/programming-guide/classes-and-structs/polymorphism.md)."},{"pos":[4105,4126],"content":"Abstract Base Classes","linkify":"Abstract Base Classes","nodes":[{"content":"Abstract Base Classes","pos":[0,21]}]},{"content":"You can declare a class as <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../../../csharp/language-reference/keywords/abstract.md)</ept> if you want to prevent direct instantiation by using the <bpt id=\"p2\">[</bpt>new<ept id=\"p2\">](../../../csharp/language-reference/keywords/new.md)</ept> keyword.","pos":[4130,4348],"source":"You can declare a class as [abstract](../../../csharp/language-reference/keywords/abstract.md) if you want to prevent direct instantiation by using the [new](../../../csharp/language-reference/keywords/new.md) keyword."},{"content":"If you do this, the class can be used only if a new class is derived from it.","pos":[4349,4426]},{"content":"An abstract class can contain one or more method signatures that themselves are declared as abstract.","pos":[4427,4528]},{"content":"These signatures specify the parameters and return value but have no implementation (method body).","pos":[4529,4627]},{"content":"An abstract class does not have to contain abstract members; however, if a class does contain an abstract member, the class itself must be declared as abstract.","pos":[4628,4788]},{"content":"Derived classes that are not abstract themselves must provide the implementation for any abstract methods from an abstract base class.","pos":[4789,4923]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Abstract and Sealed Classes and Class Members<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)</ept>.","pos":[4924,5102],"source":" For more information, see [Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)."},{"pos":[5111,5121],"content":"Interfaces","linkify":"Interfaces","nodes":[{"content":"Interfaces","pos":[0,10]}]},{"content":"An <bpt id=\"p1\">*</bpt>interface<ept id=\"p1\">*</ept> is a reference type that is somewhat similar to an abstract base class that consists of only abstract members.","pos":[5125,5250],"source":"An *interface* is a reference type that is somewhat similar to an abstract base class that consists of only abstract members."},{"content":"When a class implements an interface, it must provide an implementation for all the members of the interface.","pos":[5251,5360]},{"content":"A class can implement multiple interfaces even though it can derive from only a single direct base class.","pos":[5361,5466]},{"content":"Interfaces are used to define specific capabilities for classes that do not necessarily have an \"is a\" relationship.","pos":[5473,5589]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.IEquatable%601?displayProperty=nameWithType&gt;</ph> interface can be implemented by any class or struct that has to enable client code to determine whether two objects of the type are equivalent (however the type defines equivalence).","pos":[5590,5847],"source":" For example, the <xref:System.IEquatable%601?displayProperty=nameWithType> interface can be implemented by any class or struct that has to enable client code to determine whether two objects of the type are equivalent (however the type defines equivalence)."},{"content":"<ph id=\"ph1\">&lt;xref:System.IEquatable%601&gt;</ph> does not imply the same kind of \"is a\" relationship that exists between a base class and a derived class (for example, a <ph id=\"ph2\">`Mammal`</ph> is an <ph id=\"ph3\">`Animal`</ph>).","pos":[5848,6023],"source":"<xref:System.IEquatable%601> does not imply the same kind of \"is a\" relationship that exists between a base class and a derived class (for example, a `Mammal` is an `Animal`)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Interfaces<ept id=\"p1\">](../../../csharp/programming-guide/interfaces/index.md)</ept>.","pos":[6024,6118],"source":" For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md)."},{"pos":[6127,6156],"content":"Preventing Further Derivation","linkify":"Preventing Further Derivation","nodes":[{"content":"Preventing Further Derivation","pos":[0,29]}]},{"content":"A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as <bpt id=\"p1\">[</bpt>sealed<ept id=\"p1\">](../../../csharp/language-reference/keywords/sealed.md)</ept>.","pos":[6160,6348],"source":"A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as [sealed](../../../csharp/language-reference/keywords/sealed.md)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Abstract and Sealed Classes and Class Members<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)</ept>.","pos":[6349,6527],"source":" For more information, see [Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)."},{"pos":[6536,6578],"content":"Derived Class Hiding of Base Class Members","linkify":"Derived Class Hiding of Base Class Members","nodes":[{"content":"Derived Class Hiding of Base Class Members","pos":[0,42]}]},{"content":"A derived class can hide base class members by declaring members with the same name and signature.","pos":[6582,6680]},{"content":"The <bpt id=\"p1\">[</bpt>new<ept id=\"p1\">](../../../csharp/language-reference/keywords/new.md)</ept> modifier can be used to explicitly indicate that the member is not intended to be an override of the base member.","pos":[6681,6856],"source":" The [new](../../../csharp/language-reference/keywords/new.md) modifier can be used to explicitly indicate that the member is not intended to be an override of the base member."},{"content":"The use of <bpt id=\"p1\">[</bpt>new<ept id=\"p1\">](../../../csharp/language-reference/keywords/new.md)</ept> is not required, but a compiler warning will be generated if <bpt id=\"p2\">[</bpt>new<ept id=\"p2\">](../../../csharp/language-reference/keywords/new.md)</ept> is not used.","pos":[6857,7057],"source":" The use of [new](../../../csharp/language-reference/keywords/new.md) is not required, but a compiler warning will be generated if [new](../../../csharp/language-reference/keywords/new.md) is not used."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Versioning with the Override and New Keywords<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)</ept> and <bpt id=\"p2\">[</bpt>Knowing When to Use Override and New Keywords<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)</ept>.","pos":[7058,7392],"source":" For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md) and [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)."},{"pos":[7401,7409],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7413,7479],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[7482,7567],"content":"<bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/index.md)</ept>","source":"[Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)"},{"pos":[7570,7631],"content":"<bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../../../csharp/language-reference/keywords/class.md)</ept>","source":"[class](../../../csharp/language-reference/keywords/class.md)"},{"pos":[7634,7697],"content":"<bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](../../../csharp/language-reference/keywords/struct.md)</ept>","source":"[struct](../../../csharp/language-reference/keywords/struct.md)"}]}