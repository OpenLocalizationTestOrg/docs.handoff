<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="console-teleprompter.md" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3ac4312ba5d6088826fdf151609f6693a265e5a3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\tutorials\console-teleprompter.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_hi-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa0a6c42d3069a89b8404f3fe43c74dff261e4b8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d6c4f380c25f5b53bb45652e84a0c0f03a46936e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Console Application</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>This tutorial teaches you a number of features in .NET Core and the C# language.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Console Application</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This tutorial teaches you a number of features in .NET Core and the C# language.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You’ll learn:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The basics of the .NET Core Command Line Interface (CLI)</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The structure of a C# Console Application</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Console I/O</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The basics of File I/O APIs in .NET</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The basics of the Task-based Asynchronous Programming in .NET</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You’ll build an application that reads a text file, and echoes the contents of that text file to the console.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The output to the console is paced to match reading it aloud.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can speed up or slow down the pace by pressing the ‘&lt;’ (less than) or ‘&gt;’ (greater than) keys.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>There are a lot of features in this tutorial.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Let’s build them one by one.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You’ll need to setup your machine to run .NET Core.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can find the installation instructions on the <bpt id="p1">[</bpt>.NET Core<ept id="p1">](https://www.microsoft.com/net/core)</ept> page.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can run this application on Windows, Linux, macOS or in a Docker container.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You’ll need to install your favorite code editor.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Create the Application</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The first step is to create a new application.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Open a command prompt and create a new directory for your application.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Make that the current directory.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Type the command <ph id="ph1">`dotnet new console`</ph> at the command prompt.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This creates the starter files for a basic "Hello World" application.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Before you start making modifications, let’s go through the steps to run the simple Hello World application.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>After creating the application, type <ph id="ph1">`dotnet restore`</ph> at the command prompt.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command runs the NuGet package restore process.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>NuGet is a .NET package manager.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This command downloads any of the missing dependencies for your project.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>As this is a new project, none of the dependencies are in place, so the first run will download the .NET Core framework.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>After this initial step, you will only need to run <ph id="ph1">`dotnet restore`</ph> when you add new dependent packages, or update the versions of any of your dependencies.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>After restoring packages, you run <ph id="ph1">`dotnet build`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This executes the build engine and creates your application executable.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Finally, you execute <ph id="ph1">`dotnet run`</ph> to run your application.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The simple Hello World application code is all in Program.cs.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Open that file with your favorite text editor.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>We’re about to make our first changes.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>At the top of the file, see a using statement:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This statement tells the compiler that any types from the <ph id="ph1">`System`</ph> namespace are in scope.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Like other Object Oriented languages you may have used, C# uses namespaces to organize types.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This Hello World program is no different.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can see that the program is enclosed in the namespace with the name based on the name of the current directory.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For this tutorial, let's change the name of the namespace to <ph id="ph1">`TeleprompterConsole`</ph>:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Reading and Echoing the File</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The first feature to add is the ability to read a text file and display all that text to the console.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>First, let’s add a text file.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Copy the <bpt id="p1">[</bpt>sampleQuotes.txt<ept id="p1">](https://github.com/dotnet/samples/raw/master/csharp/getting-started/console-teleprompter/sampleQuotes.txt)</ept> file from the GitHub repository for this <bpt id="p2">[</bpt>sample<ept id="p2">](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-teleprompter)</ept> into your project directory.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This will serve as the script for your application.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If you would like information on how to download the sample app for this topic, see the instructions in the <bpt id="p1">[</bpt>Samples and Tutorials<ept id="p1">](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Next, add the following method in your <ph id="ph1">`Program`</ph> class (right below the <ph id="ph2">`Main`</ph> method):</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This method uses types from two new namespaces.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For this to compile you’ll need to add the following two lines to the top of the file:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface is defined in the <ph id="ph2">&lt;xref:System.Collections.Generic&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.IO.File&gt;</ph> class is defined in the <ph id="ph2">&lt;xref:System.IO&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This method is a special type of C# method called an <bpt id="p1">*</bpt>Iterator method<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Enumerator methods return sequences that are evaluated lazily.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>That means each item in the sequence is generated as it is requested by the code consuming the sequence.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Enumerator methods are methods that contain one or more <bpt id="p1">[</bpt><ph id="ph1">`yield return`</ph><ept id="p1">](../language-reference/keywords/yield.md)</ept> statements.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The object returned by the <ph id="ph1">`ReadFrom`</ph> method contains the code to generate each item in the sequence.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In this example, that involves reading the next line of text from the source file, and returning that string.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Each time the calling code requests the next item from the sequence, the code reads the next line of text from the file and returns it.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>When the file is completely read, the sequence indicates that there are no more items.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>There are two other C# syntax elements that may be new to you.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><ph id="ph1">`using`</ph><ept id="p1">](../language-reference/keywords/using-statement.md)</ept> statement in this method manages resource cleanup.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The variable that is initialized in the <ph id="ph1">`using`</ph> statement (<ph id="ph2">`reader`</ph>, in this example) must implement the <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>That interface defines a single method, <ph id="ph1">`Dispose`</ph>, that should be called when the resource should be released.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The compiler generates that call when execution reaches the closing brace of the <ph id="ph1">`using`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The compiler-generated code ensures that the resource is released even if an exception is thrown from the code in the block defined by the using statement.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`reader`</ph> variable is defined using the <ph id="ph2">`var`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`var`</ph><ept id="p1">](../language-reference/keywords/var.md)</ept> defines an <bpt id="p2">*</bpt>implicitly typed local variable<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>That means the type of the variable is determined by the compile-time type of the object assigned to the variable.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Here, that is the return value from the <ph id="ph1">&lt;xref:System.IO.File.OpenText(System.String)&gt;</ph> method, which is a <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Now, let’s fill in the code to read the file in the <ph id="ph1">`Main`</ph> method:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Run the program (using <ph id="ph1">`dotnet run`</ph>) and you can see every line printed out to the console.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Adding Delays and Formatting output</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>What you have is being displayed far too fast to read aloud.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Now you need to add the delays in the output.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As you start, you’ll be building some of the core code that enables asynchronous processing.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>However, these first steps will follow a few anti-patterns.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The anti-patterns are pointed out in comments as you add the code, and the code will be updated in later steps.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>There are two steps to this section.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>First, you’ll update the iterator method to return single words instead of entire lines.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>That’s done with these modifications.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Replace the <ph id="ph1">`yield return line;`</ph> statement with the following code:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Next, you need to modify how you consume the lines of the file, and add a delay after writing each word.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Replace the <ph id="ph1">`Console.WriteLine(line)`</ph> statement in the <ph id="ph2">`Main`</ph> method with the following block:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class is in the <ph id="ph2">&lt;xref:System.Threading.Tasks&gt;</ph> namespace, so you need to add that <ph id="ph3">`using`</ph> statement at the top of file:</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Run the sample, and check the output.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Now, each single word is printed, followed by a 200 ms delay.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>However, the displayed output shows some issues because the source text file has several lines that have more than 80 characters without a line break.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>That can be hard to read while it's scrolling by.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>That’s easy to fix.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You’ll just keep track of the length of each line, and generate a new line whenever the line length reaches a certain threshold.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Declare a local variable after the declaration of <ph id="ph1">`words`</ph> in the <ph id="ph2">`ReadFrom`</ph> method that holds the line length:</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Then, add the following code after the <ph id="ph1">`yield return word + " ";`</ph> statement (before the closing brace):</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Run the sample, and you’ll be able to read aloud at its pre-configured pace.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Async Tasks</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>In this final step, you’ll add the code to write the output asynchronously in one task, while also running another task to read input from the user if they want to speed up or slow down the text display, or stop the text display altogether.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This has a few steps in it and by the end, you’ll have all the updates that you need.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The first step is to create an asynchronous <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> returning method that represents the code you’ve created so far to read and display the file.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Add this method to your <ph id="ph1">`Program`</ph> class (it’s taken from the body of your <ph id="ph2">`Main`</ph> method):</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>You’ll notice two changes.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>First, in the body of the method, instead of calling <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> to synchronously wait for a task to finish, this version uses the <ph id="ph2">`await`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>In order to do that, you need to add the <ph id="ph1">`async`</ph> modifier to the method signature.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This method returns a <ph id="ph1">`Task`</ph>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Notice that there are no return statements that return a <ph id="ph1">`Task`</ph> object.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Instead, that <ph id="ph1">`Task`</ph> object is created by code the compiler generates when you use the <ph id="ph2">`await`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You can imagine that this method returns when it reaches an <ph id="ph1">`await`</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The returned <ph id="ph1">`Task`</ph> indicates that the work has not completed.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The method resumes when the awaited task completes.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>When it has executed to completion, the returned <ph id="ph1">`Task`</ph> indicates that it is complete.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Calling code can monitor that returned <ph id="ph1">`Task`</ph> to determine when it has completed.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can call this new method in your <ph id="ph1">`Main`</ph> method:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Here, in <ph id="ph1">`Main`</ph>, the code does synchronously wait.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You should use the <ph id="ph1">`await`</ph> operator instead of synchronously waiting whenever possible.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>But, in a console application’s <ph id="ph1">`Main`</ph> method, you cannot use the <ph id="ph2">`await`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>That would result in the application exiting before all tasks have completed.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>If you use C# 7.1 or later, you can create console applications with <bpt id="p1">[</bpt><ph id="ph1">`async`</ph> <ph id="ph2">`Main`</ph> method<ept id="p1">](../whats-new/csharp-7-1.md#async-main)</ept>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Next, you need to write the second asynchronous method to read from the Console and watch for the ‘&lt;’ (less than), ‘&gt;’ (greater than) and ‘X’ or ‘x’ keys.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Here’s the method you add for that task:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>This creates a lambda expression to represent an <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate that reads a key from the Console and modifies a local variable representing the delay when the user presses the ‘&lt;’ (less than) or ‘&gt;’ (greater than) keys.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The delegate method finishes when user presses the ‘X’ or ‘x’  keys, which allow the user to stop the text display at any time.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This method uses <ph id="ph1">&lt;xref:System.Console.ReadKey&gt;</ph> to block and wait for the user to press a key.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>To finish this feature, you need to create a new <ph id="ph1">`async Task`</ph> returning method that starts both of these tasks (<ph id="ph2">`GetInput`</ph> and <ph id="ph3">`ShowTeleprompter`</ph>), and also manages the shared data between these two tasks.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It’s time to create a class that can handle the shared data between these two tasks.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This class contains two public properties: the delay, and a flag <ph id="ph1">`Done`</ph> to indicate that the file has been completely read:</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Put that class in a new file, and enclose that class in the <ph id="ph1">`TeleprompterConsole`</ph> namespace as shown above.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You’ll also need to add a <ph id="ph1">`using static`</ph> statement so that you can reference the <ph id="ph2">`Min`</ph> and <ph id="ph3">`Max`</ph> methods without the enclosing class or namespace names.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt><ph id="ph1">`using static`</ph><ept id="p1">](../language-reference/keywords/using-static.md)</ept> statement imports the methods from one class.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This is in contrast with the <ph id="ph1">`using`</ph> statements used up to this point that have imported all classes from a namespace.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Next, you need to update the <ph id="ph1">`ShowTeleprompter`</ph> and <ph id="ph2">`GetInput`</ph> methods to use the new <ph id="ph3">`config`</ph> object.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Write one final <ph id="ph1">`Task`</ph> returning <ph id="ph2">`async`</ph> method to start both tasks and exit when the first task finishes:</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The one new method here is the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])&gt;</ph> call.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>That creates a <ph id="ph1">`Task`</ph> that finishes as soon as any of the tasks in its argument list completes.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Next, you need to update both the <ph id="ph1">`ShowTeleprompter`</ph> and <ph id="ph2">`GetInput`</ph> methods to use the <ph id="ph3">`config`</ph> object for the delay:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This new version of <ph id="ph1">`ShowTeleprompter`</ph> calls a new method in the <ph id="ph2">`TeleprompterConfig`</ph> class.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Now, you need to update <ph id="ph1">`Main`</ph> to call <ph id="ph2">`RunTeleprompter`</ph> instead of <ph id="ph3">`ShowTeleprompter`</ph>:</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This tutorial showed you a number of the features around the C# language and the .NET Core libraries related to working in Console applications.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>You can build on this knowledge to explore more about the language, and the classes introduced here.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>You’ve seen the basics of File and Console I/O, blocking and non-blocking use of the Task-based asynchronous programming, a tour of the C# language and how C# programs are organized and the .NET Core Command Line Interface and tools.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>For more information about File I/O, see the <bpt id="p1">[</bpt>File and Stream I/O<ept id="p1">](../../standard/io/index.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For more information about asynchronous programming model used in this tutorial, see the <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](../..//standard/parallel-programming/task-based-asynchronous-programming.md)</ept> topic and the <bpt id="p2">[</bpt>Asynchronous programming<ept id="p2">](../async.md)</ept> topic.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>