{"content":"---\ntitle: \"Event-based Asynchronous Pattern Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Event-based Asynchronous Pattern\"\n  - \"ProgressChangedEventArgs class\"\n  - \"BackgroundWorker component\"\n  - \"events [.NET Framework], asynchronous\"\n  - \"Asynchronous Pattern\"\n  - \"AsyncOperationManager class\"\n  - \"threading [.NET Framework], asynchronous features\"\n  - \"AsyncOperation class\"\n  - \"AsyncCompletedEventArgs class\"\nms.assetid: 792aa8da-918b-458e-b154-9836b97735f3\ncaps.latest.revision: 19\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Event-based Asynchronous Pattern Overview\nApplications that perform many tasks simultaneously, yet remain responsive to user interaction, often require a design that uses multiple threads. The <xref:System.Threading> namespace provides all the tools necessary to create high-performance multithreaded applications, but using these tools effectively requires significant experience with multithreaded software engineering. For relatively simple multithreaded applications, the <xref:System.ComponentModel.BackgroundWorker> component provides a straightforward solution. For more sophisticated asynchronous applications, consider implementing a class that adheres to the Event-based Asynchronous Pattern.  \n  \n The Event-based Asynchronous Pattern makes available the advantages of multithreaded applications while hiding many of the complex issues inherent in multithreaded design. Using a class that supports this pattern can allow you to:  \n  \n-   Perform time-consuming tasks, such as downloads and database operations, \"in the background,\" without interrupting your application.  \n  \n-   Execute multiple operations simultaneously, receiving notifications when each completes.  \n  \n-   Wait for resources to become available without stopping (\"hanging\") your application.  \n  \n-   Communicate with pending asynchronous operations using the familiar events-and-delegates model. For more information on using event handlers and delegates, see [Events](../../../docs/standard/events/index.md).  \n  \n A class that supports the Event-based Asynchronous Pattern will have one or more methods named *MethodName*`Async`. These methods may mirror synchronous versions, which perform the same operation on the current thread. The class may also have a *MethodName*`Completed` event and it may have a *MethodName*`AsyncCancel` (or simply `CancelAsync`) method.  \n  \n <xref:System.Windows.Forms.PictureBox> is a typical component that supports the Event-based Asynchronous Pattern. You can download an image synchronously by calling its <xref:System.Windows.Forms.PictureBox.Load%2A> method, but if the image is large, or if the network connection is slow, your application will stop (\"hang\") until the download operation is completed and the call to <xref:System.Windows.Forms.PictureBox.Load%2A> returns.  \n  \n If you want your application to keep running while the image is loading, you can call the <xref:System.Windows.Forms.PictureBox.LoadAsync%2A> method and handle the <xref:System.Windows.Forms.PictureBox.LoadCompleted> event, just as you would handle any other event. When you call the <xref:System.Windows.Forms.PictureBox.LoadAsync%2A> method, your application will continue to run while the download proceeds on a separate thread (\"in the background\"). Your event handler will be called when the image-loading operation is complete, and your event handler can examine the <xref:System.ComponentModel.AsyncCompletedEventArgs> parameter to determine if the download completed successfully.  \n  \n The Event-based Asynchronous Pattern requires that an asynchronous operation can be canceled, and the <xref:System.Windows.Forms.PictureBox> control supports this requirement with its <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> method. Calling <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> submits a request to stop the pending download, and when the task is canceled, the <xref:System.Windows.Forms.PictureBox.LoadCompleted> event is raised.  \n  \n> [!CAUTION]\n>  It is possible that the download will finish just as the <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> request is made, so <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> may not reflect the request to cancel. This is called a *race condition* and is a common issue in multithreaded programming. For more information on issues in multithreaded programming, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).  \n  \n## Characteristics of the Event-based Asynchronous Pattern  \n The Event-based Asynchronous Pattern may take several forms, depending on the complexity of the operations supported by a particular class. The simplest classes may have a single *MethodName*`Async` method and a corresponding *MethodName*`Completed` event. More complex classes may have several *MethodName*`Async` methods, each with a corresponding *MethodName*`Completed` event, as well as synchronous versions of these methods. Classes can optionally support cancellation, progress reporting, and incremental results for each asynchronous method.  \n  \n An asynchronous method may also support multiple pending calls (multiple concurrent invocations), allowing your code to call it any number of times before it completes other pending operations. Correctly handling this situation may require your application to track the completion of each operation.  \n  \n### Examples of the Event-based Asynchronous Pattern  \n The <xref:System.Media.SoundPlayer> and <xref:System.Windows.Forms.PictureBox> components represent simple implementations of the Event-based Asynchronous Pattern. The <xref:System.Net.WebClient> and <xref:System.ComponentModel.BackgroundWorker> components represent more complex implementations of the Event-based Asynchronous Pattern.  \n  \n Below is an example class declaration that conforms to the pattern:  \n  \n```vb  \nPublic Class AsyncExample  \n    ' Synchronous methods.  \n    Public Function Method1(ByVal param As String) As Integer   \n    Public Sub Method2(ByVal param As Double)   \n  \n    ' Asynchronous methods.  \n    Overloads Public Sub Method1Async(ByVal param As String)   \n    Overloads Public Sub Method1Async(ByVal param As String, ByVal userState As Object)   \n    Public Event Method1Completed As Method1CompletedEventHandler  \n  \n    Overloads Public Sub Method2Async(ByVal param As Double)   \n    Overloads Public Sub Method2Async(ByVal param As Double, ByVal userState As Object)   \n    Public Event Method2Completed As Method2CompletedEventHandler  \n  \n    Public Sub CancelAsync(ByVal userState As Object)   \n  \n    Public ReadOnly Property IsBusy () As Boolean  \n  \n    ' Class implementation not shown.  \nEnd Class  \n```  \n  \n```csharp  \npublic class AsyncExample  \n{  \n    // Synchronous methods.  \n    public int Method1(string param);  \n    public void Method2(double param);  \n  \n    // Asynchronous methods.  \n    public void Method1Async(string param);  \n    public void Method1Async(string param, object userState);  \n    public event Method1CompletedEventHandler Method1Completed;  \n  \n    public void Method2Async(double param);  \n    public void Method2Async(double param, object userState);  \n    public event Method2CompletedEventHandler Method2Completed;  \n  \n    public void CancelAsync(object userState);  \n  \n    public bool IsBusy { get; }  \n  \n    // Class implementation not shown.  \n}  \n```  \n  \n The fictitious `AsyncExample` class has two methods, both of which support synchronous and asynchronous invocations. The synchronous overloads behave like any method call and execute the operation on the calling thread; if the operation is time-consuming, there may be a noticeable delay before the call returns. The asynchronous overloads will start the operation on another thread and then return immediately, allowing the calling thread to continue while the operation executes \"in the background.\"  \n  \n### Asynchronous Method Overloads  \n There are potentially two overloads for the asynchronous operations: single-invocation and multiple-invocation. You can distinguish these two forms by their method signatures: the multiple-invocation form has an extra parameter called `userState`. This form makes it possible for your code to call `Method1Async(string param, object userState)` multiple times without waiting for any pending asynchronous operations to finish. If, on the other hand, you try to call `Method1Async(string param)` before a previous invocation has completed, the method raises an <xref:System.InvalidOperationException>.  \n  \n The `userState` parameter for the multiple-invocation overloads allows you to distinguish among asynchronous operations. You provide a unique value (for example, a GUID or hash code) for each call to `Method1Async(string param, object userState)`, and when each operation is completed, your event handler can determine which instance of the operation raised the completion event.  \n  \n### Tracking Pending Operations  \n If you use the multiple-invocation overloads, your code will need to keep track of the `userState` objects (task IDs) for pending tasks. For each call to `Method1Async(string param, object userState)`, you will typically generate a new, unique `userState` object and add it to a collection. When the task corresponding to this `userState` object raises the completion event, your completion method implementation will examine <xref:System.ComponentModel.AsyncCompletedEventArgs.UserState%2A?displayProperty=fullName> and remove it from your collection. Used this way, the `userState` parameter takes the role of a task ID.  \n  \n> [!NOTE]\n>  You must be careful to provide a unique value for `userState` in your calls to multiple-invocation overloads. Non-unique task IDs will cause the asynchronous class throw an <xref:System.ArgumentException>.  \n  \n### Canceling Pending Operations  \n It is important to be able to cancel asynchronous operations at any time before their completion. Classes that implement the Event-based Asynchronous Pattern will have a `CancelAsync` method (if there is only one asynchronous method) or a *MethodName*`AsyncCancel` method (if there are multiple asynchronous methods).  \n  \n Methods that allow multiple invocations take a `userState` parameter, which can be used to track the lifetime of each task. `CancelAsync` takes a `userState` parameter, which allows you to cancel particular pending tasks.  \n  \n Methods that support only a single pending operation at a time, like `Method1Async(string param)`, are not cancelable.  \n  \n### Receiving Progress Updates and Incremental Results  \n A class that adheres to the Event-based Asynchronous Pattern may optionally provide an event for tracking progress and incremental results. This will typically be named `ProgressChanged` or *MethodName*`ProgressChanged`, and its corresponding event handler will take a <xref:System.ComponentModel.ProgressChangedEventArgs> parameter.  \n  \n The event handler for the `ProgressChanged`event can examine the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A?displayProperty=fullName> property to determine what percentage of an asynchronous task has been completed. This property will range from 0 to 100, and it can be used to update the <xref:System.Windows.Forms.ProgressBar.Value%2A> property of a <xref:System.Windows.Forms.ProgressBar>. If multiple asynchronous operations are pending, you can use the <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A?displayProperty=fullName> property to distinguish which operation is reporting progress.  \n  \n Some classes may report incremental results as asynchronous operations proceed. These results will be stored in a class that derives from <xref:System.ComponentModel.ProgressChangedEventArgs> and they will appear as properties in the derived class. You can access these results in the event handler for the `ProgressChanged` event, just as you would access the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> property. If multiple asynchronous operations are pending, you can use the <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A> property to distinguish which operation is reporting incremental results.  \n  \n## See Also  \n <xref:System.ComponentModel.ProgressChangedEventArgs>   \n <xref:System.ComponentModel.BackgroundWorker>   \n <xref:System.ComponentModel.AsyncCompletedEventArgs>   \n [How to: Use Components That Support the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)   \n [How to: Run an Operation in the Background](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)   \n [How to: Implement a Form That Uses a Background Operation](../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md)   \n [Multithreaded Programming with the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/multithreaded-programming-with-the-event-based-asynchronous-pattern.md)   \n [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)   \n [Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)","nodes":[{"pos":[4,714],"embed":true,"restype":"x-metadata","content":"title: \"Event-based Asynchronous Pattern Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Event-based Asynchronous Pattern\"\n  - \"ProgressChangedEventArgs class\"\n  - \"BackgroundWorker component\"\n  - \"events [.NET Framework], asynchronous\"\n  - \"Asynchronous Pattern\"\n  - \"AsyncOperationManager class\"\n  - \"threading [.NET Framework], asynchronous features\"\n  - \"AsyncOperation class\"\n  - \"AsyncCompletedEventArgs class\"\nms.assetid: 792aa8da-918b-458e-b154-9836b97735f3\ncaps.latest.revision: 19\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","nodes":[{"content":"Event-based Asynchronous Pattern Overview | Microsoft Docs","nodes":[{"pos":[0,58],"content":"Event-based Asynchronous Pattern Overview | Microsoft Docs","nodes":[{"content":"Event-based Asynchronous Pattern Overview | Microsoft Docs","pos":[0,58]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[721,762],"content":"Event-based Asynchronous Pattern Overview","linkify":"Event-based Asynchronous Pattern Overview","nodes":[{"content":"Event-based Asynchronous Pattern Overview","pos":[0,41]}]},{"content":"Applications that perform many tasks simultaneously, yet remain responsive to user interaction, often require a design that uses multiple threads.","pos":[763,909]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading&gt;</ph> namespace provides all the tools necessary to create high-performance multithreaded applications, but using these tools effectively requires significant experience with multithreaded software engineering.","pos":[910,1142],"source":" The <xref:System.Threading> namespace provides all the tools necessary to create high-performance multithreaded applications, but using these tools effectively requires significant experience with multithreaded software engineering."},{"content":"For relatively simple multithreaded applications, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> component provides a straightforward solution.","pos":[1143,1289],"source":" For relatively simple multithreaded applications, the <xref:System.ComponentModel.BackgroundWorker> component provides a straightforward solution."},{"content":"For more sophisticated asynchronous applications, consider implementing a class that adheres to the Event-based Asynchronous Pattern.","pos":[1290,1423]},{"content":"The Event-based Asynchronous Pattern makes available the advantages of multithreaded applications while hiding many of the complex issues inherent in multithreaded design.","pos":[1430,1601]},{"content":"Using a class that supports this pattern can allow you to:","pos":[1602,1660]},{"content":"Perform time-consuming tasks, such as downloads and database operations, \"in the background,\" without interrupting your application.","pos":[1670,1802]},{"content":"Execute multiple operations simultaneously, receiving notifications when each completes.","pos":[1812,1900]},{"content":"Wait for resources to become available without stopping (\"hanging\") your application.","pos":[1910,1995]},{"content":"Communicate with pending asynchronous operations using the familiar events-and-delegates model.","pos":[2005,2100]},{"content":"For more information on using event handlers and delegates, see <bpt id=\"p1\">[</bpt>Events<ept id=\"p1\">](../../../docs/standard/events/index.md)</ept>.","pos":[2101,2214],"source":" For more information on using event handlers and delegates, see [Events](../../../docs/standard/events/index.md)."},{"content":"A class that supports the Event-based Asynchronous Pattern will have one or more methods named <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph>.","pos":[2221,2336],"source":"A class that supports the Event-based Asynchronous Pattern will have one or more methods named *MethodName*`Async`."},{"content":"These methods may mirror synchronous versions, which perform the same operation on the current thread.","pos":[2337,2439]},{"content":"The class may also have a <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Completed`</ph> event and it may have a <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`AsyncCancel`</ph> (or simply <ph id=\"ph3\">`CancelAsync`</ph>) method.","pos":[2440,2573],"source":" The class may also have a *MethodName*`Completed` event and it may have a *MethodName*`AsyncCancel` (or simply `CancelAsync`) method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Forms.PictureBox&gt;</ph> is a typical component that supports the Event-based Asynchronous Pattern.","pos":[2580,2693],"source":"<xref:System.Windows.Forms.PictureBox> is a typical component that supports the Event-based Asynchronous Pattern."},{"content":"You can download an image synchronously by calling its <ph id=\"ph1\">&lt;xref:System.Windows.Forms.PictureBox.Load%2A&gt;</ph> method, but if the image is large, or if the network connection is slow, your application will stop (\"hang\") until the download operation is completed and the call to <ph id=\"ph2\">&lt;xref:System.Windows.Forms.PictureBox.Load%2A&gt;</ph> returns.","pos":[2694,3018],"source":" You can download an image synchronously by calling its <xref:System.Windows.Forms.PictureBox.Load%2A> method, but if the image is large, or if the network connection is slow, your application will stop (\"hang\") until the download operation is completed and the call to <xref:System.Windows.Forms.PictureBox.Load%2A> returns."},{"content":"If you want your application to keep running while the image is loading, you can call the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.PictureBox.LoadAsync%2A&gt;</ph> method and handle the <ph id=\"ph2\">&lt;xref:System.Windows.Forms.PictureBox.LoadCompleted&gt;</ph> event, just as you would handle any other event.","pos":[3025,3290],"source":"If you want your application to keep running while the image is loading, you can call the <xref:System.Windows.Forms.PictureBox.LoadAsync%2A> method and handle the <xref:System.Windows.Forms.PictureBox.LoadCompleted> event, just as you would handle any other event."},{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.PictureBox.LoadAsync%2A&gt;</ph> method, your application will continue to run while the download proceeds on a separate thread (\"in the background\").","pos":[3291,3478],"source":" When you call the <xref:System.Windows.Forms.PictureBox.LoadAsync%2A> method, your application will continue to run while the download proceeds on a separate thread (\"in the background\")."},{"content":"Your event handler will be called when the image-loading operation is complete, and your event handler can examine the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> parameter to determine if the download completed successfully.","pos":[3479,3713],"source":" Your event handler will be called when the image-loading operation is complete, and your event handler can examine the <xref:System.ComponentModel.AsyncCompletedEventArgs> parameter to determine if the download completed successfully."},{"content":"The Event-based Asynchronous Pattern requires that an asynchronous operation can be canceled, and the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.PictureBox&gt;</ph> control supports this requirement with its <ph id=\"ph2\">&lt;xref:System.Windows.Forms.PictureBox.CancelAsync%2A&gt;</ph> method.","pos":[3720,3965],"source":"The Event-based Asynchronous Pattern requires that an asynchronous operation can be canceled, and the <xref:System.Windows.Forms.PictureBox> control supports this requirement with its <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> method."},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.Windows.Forms.PictureBox.CancelAsync%2A&gt;</ph> submits a request to stop the pending download, and when the task is canceled, the <ph id=\"ph2\">&lt;xref:System.Windows.Forms.PictureBox.LoadCompleted&gt;</ph> event is raised.","pos":[3966,4180],"source":" Calling <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> submits a request to stop the pending download, and when the task is canceled, the <xref:System.Windows.Forms.PictureBox.LoadCompleted> event is raised."},{"pos":[4188,4694],"content":"[!CAUTION]\n It is possible that the download will finish just as the <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> request is made, so <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> may not reflect the request to cancel. This is called a *race condition* and is a common issue in multithreaded programming. For more information on issues in multithreaded programming, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).","leadings":["","> "],"nodes":[{"content":"It is possible that the download will finish just as the <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> request is made, so <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> may not reflect the request to cancel. This is called a *race condition* and is a common issue in multithreaded programming. For more information on issues in multithreaded programming, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).","pos":[12,504],"nodes":[{"content":"It is possible that the download will finish just as the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.PictureBox.CancelAsync%2A&gt;</ph> request is made, so <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A&gt;</ph> may not reflect the request to cancel.","pos":[0,235],"source":"It is possible that the download will finish just as the <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> request is made, so <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> may not reflect the request to cancel."},{"content":"This is called a <bpt id=\"p1\">*</bpt>race condition<ept id=\"p1\">*</ept> and is a common issue in multithreaded programming.","pos":[236,321],"source":" This is called a *race condition* and is a common issue in multithreaded programming."},{"content":"For more information on issues in multithreaded programming, see <bpt id=\"p1\">[</bpt>Managed Threading Best Practices<ept id=\"p1\">](../../../docs/standard/threading/managed-threading-best-practices.md)</ept>.","pos":[322,492],"source":" For more information on issues in multithreaded programming, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md)."}]}]},{"pos":[4703,4758],"content":"Characteristics of the Event-based Asynchronous Pattern","linkify":"Characteristics of the Event-based Asynchronous Pattern","nodes":[{"content":"Characteristics of the Event-based Asynchronous Pattern","pos":[0,55]}]},{"content":"The Event-based Asynchronous Pattern may take several forms, depending on the complexity of the operations supported by a particular class.","pos":[4762,4901]},{"content":"The simplest classes may have a single <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph> method and a corresponding <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Completed`</ph> event.","pos":[4902,5018],"source":" The simplest classes may have a single *MethodName*`Async` method and a corresponding *MethodName*`Completed` event."},{"content":"More complex classes may have several <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph> methods, each with a corresponding <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Completed`</ph> event, as well as synchronous versions of these methods.","pos":[5019,5192],"source":" More complex classes may have several *MethodName*`Async` methods, each with a corresponding *MethodName*`Completed` event, as well as synchronous versions of these methods."},{"content":"Classes can optionally support cancellation, progress reporting, and incremental results for each asynchronous method.","pos":[5193,5311]},{"content":"An asynchronous method may also support multiple pending calls (multiple concurrent invocations), allowing your code to call it any number of times before it completes other pending operations.","pos":[5318,5511]},{"content":"Correctly handling this situation may require your application to track the completion of each operation.","pos":[5512,5617]},{"pos":[5627,5675],"content":"Examples of the Event-based Asynchronous Pattern","linkify":"Examples of the Event-based Asynchronous Pattern","nodes":[{"content":"Examples of the Event-based Asynchronous Pattern","pos":[0,48]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Media.SoundPlayer&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Forms.PictureBox&gt;</ph> components represent simple implementations of the Event-based Asynchronous Pattern.","pos":[5679,5842],"source":"The <xref:System.Media.SoundPlayer> and <xref:System.Windows.Forms.PictureBox> components represent simple implementations of the Event-based Asynchronous Pattern."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.WebClient&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> components represent more complex implementations of the Event-based Asynchronous Pattern.","pos":[5843,6015],"source":" The <xref:System.Net.WebClient> and <xref:System.ComponentModel.BackgroundWorker> components represent more complex implementations of the Event-based Asynchronous Pattern."},{"content":"Below is an example class declaration that conforms to the pattern:","pos":[6022,6089]},{"content":"The fictitious <ph id=\"ph1\">`AsyncExample`</ph> class has two methods, both of which support synchronous and asynchronous invocations.","pos":[7626,7742],"source":"The fictitious `AsyncExample` class has two methods, both of which support synchronous and asynchronous invocations."},{"content":"The synchronous overloads behave like any method call and execute the operation on the calling thread; if the operation is time-consuming, there may be a noticeable delay before the call returns.","pos":[7743,7938]},{"content":"The asynchronous overloads will start the operation on another thread and then return immediately, allowing the calling thread to continue while the operation executes \"in the background.\"","pos":[7939,8127]},{"pos":[8137,8166],"content":"Asynchronous Method Overloads","linkify":"Asynchronous Method Overloads","nodes":[{"content":"Asynchronous Method Overloads","pos":[0,29]}]},{"content":"There are potentially two overloads for the asynchronous operations: single-invocation and multiple-invocation.","pos":[8170,8281]},{"content":"You can distinguish these two forms by their method signatures: the multiple-invocation form has an extra parameter called <ph id=\"ph1\">`userState`</ph>.","pos":[8282,8417],"source":" You can distinguish these two forms by their method signatures: the multiple-invocation form has an extra parameter called `userState`."},{"content":"This form makes it possible for your code to call <ph id=\"ph1\">`Method1Async(string param, object userState)`</ph> multiple times without waiting for any pending asynchronous operations to finish.","pos":[8418,8596],"source":" This form makes it possible for your code to call `Method1Async(string param, object userState)` multiple times without waiting for any pending asynchronous operations to finish."},{"content":"If, on the other hand, you try to call <ph id=\"ph1\">`Method1Async(string param)`</ph> before a previous invocation has completed, the method raises an <ph id=\"ph2\">&lt;xref:System.InvalidOperationException&gt;</ph>.","pos":[8597,8770],"source":" If, on the other hand, you try to call `Method1Async(string param)` before a previous invocation has completed, the method raises an <xref:System.InvalidOperationException>."},{"content":"The <ph id=\"ph1\">`userState`</ph> parameter for the multiple-invocation overloads allows you to distinguish among asynchronous operations.","pos":[8777,8897],"source":"The `userState` parameter for the multiple-invocation overloads allows you to distinguish among asynchronous operations."},{"content":"You provide a unique value (for example, a GUID or hash code) for each call to <ph id=\"ph1\">`Method1Async(string param, object userState)`</ph>, and when each operation is completed, your event handler can determine which instance of the operation raised the completion event.","pos":[8898,9156],"source":" You provide a unique value (for example, a GUID or hash code) for each call to `Method1Async(string param, object userState)`, and when each operation is completed, your event handler can determine which instance of the operation raised the completion event."},{"pos":[9166,9193],"content":"Tracking Pending Operations","linkify":"Tracking Pending Operations","nodes":[{"content":"Tracking Pending Operations","pos":[0,27]}]},{"content":"If you use the multiple-invocation overloads, your code will need to keep track of the <ph id=\"ph1\">`userState`</ph> objects (task IDs) for pending tasks.","pos":[9197,9333],"source":"If you use the multiple-invocation overloads, your code will need to keep track of the `userState` objects (task IDs) for pending tasks."},{"content":"For each call to <ph id=\"ph1\">`Method1Async(string param, object userState)`</ph>, you will typically generate a new, unique <ph id=\"ph2\">`userState`</ph> object and add it to a collection.","pos":[9334,9487],"source":" For each call to `Method1Async(string param, object userState)`, you will typically generate a new, unique `userState` object and add it to a collection."},{"content":"When the task corresponding to this <ph id=\"ph1\">`userState`</ph> object raises the completion event, your completion method implementation will examine <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.UserState%2A?displayProperty=fullName&gt;</ph> and remove it from your collection.","pos":[9488,9749],"source":" When the task corresponding to this `userState` object raises the completion event, your completion method implementation will examine <xref:System.ComponentModel.AsyncCompletedEventArgs.UserState%2A?displayProperty=fullName> and remove it from your collection."},{"content":"Used this way, the <ph id=\"ph1\">`userState`</ph> parameter takes the role of a task ID.","pos":[9750,9819],"source":" Used this way, the `userState` parameter takes the role of a task ID."},{"pos":[9827,10043],"content":"[!NOTE]\n You must be careful to provide a unique value for `userState` in your calls to multiple-invocation overloads. Non-unique task IDs will cause the asynchronous class throw an <xref:System.ArgumentException>.","leadings":["","> "],"nodes":[{"content":"You must be careful to provide a unique value for `userState` in your calls to multiple-invocation overloads. Non-unique task IDs will cause the asynchronous class throw an <xref:System.ArgumentException>.","pos":[9,214],"nodes":[{"content":"You must be careful to provide a unique value for <ph id=\"ph1\">`userState`</ph> in your calls to multiple-invocation overloads.","pos":[0,109],"source":"You must be careful to provide a unique value for `userState` in your calls to multiple-invocation overloads."},{"content":"Non-unique task IDs will cause the asynchronous class throw an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[110,205],"source":" Non-unique task IDs will cause the asynchronous class throw an <xref:System.ArgumentException>."}]}]},{"pos":[10053,10081],"content":"Canceling Pending Operations","linkify":"Canceling Pending Operations","nodes":[{"content":"Canceling Pending Operations","pos":[0,28]}]},{"content":"It is important to be able to cancel asynchronous operations at any time before their completion.","pos":[10085,10182]},{"content":"Classes that implement the Event-based Asynchronous Pattern will have a <ph id=\"ph1\">`CancelAsync`</ph> method (if there is only one asynchronous method) or a <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph2\">`AsyncCancel`</ph> method (if there are multiple asynchronous methods).","pos":[10183,10402],"source":" Classes that implement the Event-based Asynchronous Pattern will have a `CancelAsync` method (if there is only one asynchronous method) or a *MethodName*`AsyncCancel` method (if there are multiple asynchronous methods)."},{"content":"Methods that allow multiple invocations take a <ph id=\"ph1\">`userState`</ph> parameter, which can be used to track the lifetime of each task.","pos":[10409,10532],"source":"Methods that allow multiple invocations take a `userState` parameter, which can be used to track the lifetime of each task."},{"content":"<ph id=\"ph1\">`CancelAsync`</ph> takes a <ph id=\"ph2\">`userState`</ph> parameter, which allows you to cancel particular pending tasks.","pos":[10533,10630],"source":"`CancelAsync` takes a `userState` parameter, which allows you to cancel particular pending tasks."},{"pos":[10637,10755],"content":"Methods that support only a single pending operation at a time, like <ph id=\"ph1\">`Method1Async(string param)`</ph>, are not cancelable.","source":"Methods that support only a single pending operation at a time, like `Method1Async(string param)`, are not cancelable."},{"pos":[10765,10815],"content":"Receiving Progress Updates and Incremental Results","linkify":"Receiving Progress Updates and Incremental Results","nodes":[{"content":"Receiving Progress Updates and Incremental Results","pos":[0,50]}]},{"content":"A class that adheres to the Event-based Asynchronous Pattern may optionally provide an event for tracking progress and incremental results.","pos":[10819,10958]},{"content":"This will typically be named <ph id=\"ph1\">`ProgressChanged`</ph> or <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph2\">`ProgressChanged`</ph>, and its corresponding event handler will take a <ph id=\"ph3\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph> parameter.","pos":[10959,11152],"source":" This will typically be named `ProgressChanged` or *MethodName*`ProgressChanged`, and its corresponding event handler will take a <xref:System.ComponentModel.ProgressChangedEventArgs> parameter."},{"content":"The event handler for the <ph id=\"ph1\">`ProgressChanged`</ph>event can examine the <ph id=\"ph2\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A?displayProperty=fullName&gt;</ph> property to determine what percentage of an asynchronous task has been completed.","pos":[11159,11406],"source":"The event handler for the `ProgressChanged`event can examine the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A?displayProperty=fullName> property to determine what percentage of an asynchronous task has been completed."},{"content":"This property will range from 0 to 100, and it can be used to update the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.ProgressBar.Value%2A&gt;</ph> property of a <ph id=\"ph2\">&lt;xref:System.Windows.Forms.ProgressBar&gt;</ph>.","pos":[11407,11583],"source":" This property will range from 0 to 100, and it can be used to update the <xref:System.Windows.Forms.ProgressBar.Value%2A> property of a <xref:System.Windows.Forms.ProgressBar>."},{"content":"If multiple asynchronous operations are pending, you can use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A?displayProperty=fullName&gt;</ph> property to distinguish which operation is reporting progress.","pos":[11584,11803],"source":" If multiple asynchronous operations are pending, you can use the <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A?displayProperty=fullName> property to distinguish which operation is reporting progress."},{"content":"Some classes may report incremental results as asynchronous operations proceed.","pos":[11810,11889]},{"content":"These results will be stored in a class that derives from <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph> and they will appear as properties in the derived class.","pos":[11890,12058],"source":" These results will be stored in a class that derives from <xref:System.ComponentModel.ProgressChangedEventArgs> and they will appear as properties in the derived class."},{"content":"You can access these results in the event handler for the <ph id=\"ph1\">`ProgressChanged`</ph> event, just as you would access the <ph id=\"ph2\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A&gt;</ph> property.","pos":[12059,12256],"source":" You can access these results in the event handler for the `ProgressChanged` event, just as you would access the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> property."},{"content":"If multiple asynchronous operations are pending, you can use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A&gt;</ph> property to distinguish which operation is reporting incremental results.","pos":[12257,12462],"source":" If multiple asynchronous operations are pending, you can use the <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A> property to distinguish which operation is reporting incremental results."},{"pos":[12471,12479],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>How to: Use Components That Support the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)</ept><ph id=\"ph1\"> </ph>","pos":[12648,12856],"source":"[How to: Use Components That Support the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Run an Operation in the Background<ept id=\"p1\">](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)</ept><ph id=\"ph1\"> </ph>","pos":[12860,12993],"source":"[How to: Run an Operation in the Background](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Implement a Form That Uses a Background Operation<ept id=\"p1\">](../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md)</ept><ph id=\"ph1\"> </ph>","pos":[12997,13160],"source":"[How to: Implement a Form That Uses a Background Operation](../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md) "},{"content":"<bpt id=\"p1\">[</bpt>Multithreaded Programming with the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/multithreaded-programming-with-the-event-based-asynchronous-pattern.md)</ept><ph id=\"ph1\"> </ph>","pos":[13164,13363],"source":"[Multithreaded Programming with the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/multithreaded-programming-with-the-event-based-asynchronous-pattern.md) "},{"content":"<bpt id=\"p1\">[</bpt>Best Practices for Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)</ept><ph id=\"ph1\"> </ph>","pos":[13367,13568],"source":"[Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md) "},{"content":"<bpt id=\"p1\">[</bpt>Deciding When to Implement the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)</ept>","pos":[13572,13762],"source":"[Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)"}]}