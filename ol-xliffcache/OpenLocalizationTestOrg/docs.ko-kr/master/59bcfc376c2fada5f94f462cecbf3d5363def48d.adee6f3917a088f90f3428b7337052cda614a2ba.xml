{"content":"---\ntitle: \"Transport: UDP\"\nms.date: \"03/30/2017\"\nms.assetid: 738705de-ad3e-40e0-b363-90305bddb140\n---\n# Transport: UDP\nThe UDP Transport sample demonstrates how to implement UDP unicast and multicast as a custom Windows Communication Foundation (WCF) transport. The sample describes the recommended procedure for creating a custom transport in WCF, by using the channel framework and following WCF best practices. The steps to create a custom transport are as follows:  \n  \n1.  Decide which of the channel [Message Exchange Patterns](#MessageExchangePatterns) (IOutputChannel, IInputChannel, IDuplexChannel, IRequestChannel, or IReplyChannel) your ChannelFactory and ChannelListener will support. Then decide whether you will support the sessionful variations of these interfaces.  \n  \n2.  Create a channel factory and listener that support your Message Exchange Pattern.  \n  \n3.  Ensure that any network-specific exceptions are normalized to the appropriate derived class of <xref:System.ServiceModel.CommunicationException>.  \n  \n4.  Add a [\\<binding>](../../../../docs/framework/misc/binding.md) element that adds the custom transport to a channel stack. For more information, see [Adding a Binding Element](#AddingABindingElement).  \n  \n5.  Add a binding element extension section to expose the new binding element to the configuration system.  \n  \n6.  Add metadata extensions to communicate capabilities to other endpoints.  \n  \n7.  Add a binding that pre-configures a stack of binding elements according to a well-defined profile. For more information, see [Adding a Standard Binding](#AddingAStandardBinding).  \n  \n8.  Add a binding section and binding configuration element to expose the binding to the configuration system. For more information, see [Adding Configuration Support](#AddingConfigurationSupport).  \n  \n<a name=\"MessageExchangePatterns\"></a>   \n## Message Exchange Patterns  \n The first step in writing a custom transport is to decide which Message Exchange Patterns (MEPs) are required for the transport. There are three MEPs to choose from:  \n  \n-   Datagram (IInputChannel/IOutputChannel)  \n  \n     When using a datagram MEP, a client sends a message using a \"fire and forget\" exchange. A fire and forget exchange is one that requires out-of-band confirmation of successful delivery. The message might be lost in transit and never reach the service. If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message. The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols. Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.  \n  \n-   Request-Response (IRequestChannel/IReplyChannel)  \n  \n     In this MEP, a message is sent, and a reply is received. The pattern consists of request-response pairs. Examples of request-response calls are remote procedure calls (RPC) and browser GETs. This pattern is also known as Half-Duplex. In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.  \n  \n-   Duplex (IDuplexChannel)  \n  \n     The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order. The duplex MEP is like a phone conversation, where each word being spoken is a message. Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.  \n  \n Each of these MEPs can also support sessions. The added functionality provided by a session-aware channel is that it correlates all messages sent and received on a channel. The Request-Response pattern is a stand-alone two-message session, as the request and reply are correlated. In contrast, the Request-Response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other. This gives you a total of six MEPs—Datagram, Request-Response, Duplex, Datagram with sessions, Request-Response with sessions, and Duplex with sessions—to choose from.  \n  \n> [!NOTE]\n>  For the UDP transport, the only MEP that is supported is Datagram, because UDP is inherently a \"fire and forget\" protocol.  \n  \n### The ICommunicationObject and the WCF object lifecycle  \n WCF has a common state machine that is used for managing the lifecycle of objects like <xref:System.ServiceModel.Channels.IChannel>, <xref:System.ServiceModel.Channels.IChannelFactory>, and <xref:System.ServiceModel.Channels.IChannelListener> that are used for communication. There are five states in which these communication objects can exist. These states are represented by the <xref:System.ServiceModel.CommunicationState> enumeration, and are as follows:  \n  \n-   Created: This is the state of a <xref:System.ServiceModel.ICommunicationObject> when it is first instantiated. No input/output (I/O) occurs in this state.  \n  \n-   Opening: Objects transition to this state when <xref:System.ServiceModel.ICommunicationObject.Open%2A> is called. At this point properties are made immutable, and input/output can begin. This transition is valid only from the Created state.  \n  \n-   Opened: Objects transition to this state when the open process completes. This transition is valid only from the Opening state. At this point, the object is fully usable for transfer.  \n  \n-   Closing: Objects transition to this state when <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called for a graceful shutdown. This transition is valid only from the Opened state.  \n  \n-   Closed: In the Closed state objects are no longer usable. In general, most configuration is still accessible for inspection, but no communication can occur. This state is equivalent to being disposed.  \n  \n-   Faulted: In the Faulted state, objects are accessible to inspection but no longer usable. When a non-recoverable error occurs, the object transitions into this state. The only valid transition from this state is into the `Closed` state.  \n  \n There are events that fire for each state transition. The <xref:System.ServiceModel.ICommunicationObject.Abort%2A> method can be called at any time, and causes the object to transition immediately from its current state into the Closed state. Calling <xref:System.ServiceModel.ICommunicationObject.Abort%2A> terminates any unfinished work.  \n  \n<a name=\"ChannelAndChannelListener\"></a>   \n## Channel Factory and Channel Listener  \n The next step in writing a custom transport is to create an implementation of <xref:System.ServiceModel.Channels.IChannelFactory> for client channels and of <xref:System.ServiceModel.Channels.IChannelListener> for service channels. The channel layer uses a factory pattern for constructing channels. WCF provides base class helpers for this process.  \n  \n-   The <xref:System.ServiceModel.Channels.CommunicationObject> class implements <xref:System.ServiceModel.ICommunicationObject> and enforces the state machine previously described in Step 2. \n\n-   The <xref:System.ServiceModel.Channels.ChannelManagerBase> class implements <xref:System.ServiceModel.Channels.CommunicationObject> and provides a unified base class for <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase>. The <xref:System.ServiceModel.Channels.ChannelManagerBase> class works in conjunction with <xref:System.ServiceModel.Channels.ChannelBase>, which is a base class that implements <xref:System.ServiceModel.Channels.IChannel>.  \n  \n-   The <xref:System.ServiceModel.Channels.ChannelFactoryBase> class implements <xref:System.ServiceModel.Channels.ChannelManagerBase> and <xref:System.ServiceModel.Channels.IChannelFactory> and consolidates the `CreateChannel` overloads into one `OnCreateChannel` abstract method.  \n  \n-   The <xref:System.ServiceModel.Channels.ChannelListenerBase> class implements <xref:System.ServiceModel.Channels.IChannelListener>. It takes care of basic state management.  \n  \n In this sample, the factory implementation is contained in UdpChannelFactory.cs and the listener implementation is contained in UdpChannelListener.cs. The <xref:System.ServiceModel.Channels.IChannel> implementations are in UdpOutputChannel.cs and UdpInputChannel.cs.  \n  \n### The UDP Channel Factory  \n The `UdpChannelFactory` derives from <xref:System.ServiceModel.Channels.ChannelFactoryBase>. The sample overrides <xref:System.ServiceModel.Channels.ChannelFactoryBase.GetProperty%2A> to provide access to the message version of the message encoder. The sample also overrides <xref:System.ServiceModel.Channels.ChannelFactoryBase.OnClose%2A> so that we can tear down our instance of <xref:System.ServiceModel.Channels.BufferManager> when the state machine transitions.  \n  \n#### The UDP Output Channel  \n The `UdpOutputChannel` implements <xref:System.ServiceModel.Channels.IOutputChannel>. The constructor validates the arguments and constructs a destination <xref:System.Net.EndPoint> object based on the <xref:System.ServiceModel.EndpointAddress> that is passed in.  \n  \n```csharp\nthis.socket = new Socket(this.remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);  \n```  \n  \n The channel can be closed gracefully or ungracefully. If the channel is closed gracefully the socket is closed and a call is made to the base class `OnClose` method. If this throws an exception, the infrastructure calls `Abort` to ensure the channel is cleaned up.  \n  \n```csharp\nthis.socket.Close(0);  \n```  \n  \n We then implement `Send()` and `BeginSend()`/`EndSend()`. This breaks down into two main sections. First we serialize the message into a byte array.  \n  \n```csharp\nArraySegment<byte> messageBuffer = EncodeMessage(message);  \n```  \n  \n Then we send the resulting data on the wire.  \n  \n```csharp\nthis.socket.SendTo(messageBuffer.Array, messageBuffer.Offset, messageBuffer.Count, SocketFlags.None, this.remoteEndPoint);  \n```  \n  \n### The UdpChannelListener  \n The `UdpChannelListener` that the sample implements derives from the <xref:System.ServiceModel.Channels.ChannelListenerBase> class. It uses a single UDP socket to receive datagrams. The `OnOpen` method receives data using the UDP socket in an asynchronous loop. The data are then converted into messages using the Message Encoding Framework.  \n  \n```csharp\nmessage = MessageEncoderFactory.Encoder.ReadMessage(new ArraySegment<byte>(buffer, 0, count), bufferManager);  \n```  \n  \n Because the same datagram channel represents messages that arrive from a number of sources, the `UdpChannelListener` is a singleton listener. There is, at most, one active <xref:System.ServiceModel.Channels.IChannel> associated with this listener at a time. The sample generates another one only if a channel that is returned by the `AcceptChannel` method is subsequently disposed. When a message is received, it is enqueued into this singleton channel.  \n  \n#### UdpInputChannel  \n The `UdpInputChannel` class implements `IInputChannel`. It consists of a queue of incoming messages that is populated by the `UdpChannelListener`'s socket. These messages are dequeued by the `IInputChannel.Receive` method.  \n  \n<a name=\"AddingABindingElement\"></a>   \n## Adding a Binding Element  \n Now that the factories and channels are built, we must expose them to the ServiceModel runtime through a binding. A binding is a collection of binding elements that represents the communication stack associated with a service address. Each element in the stack is represented by a [\\<binding>](../../../../docs/framework/misc/binding.md) element.  \n  \n In the sample, the binding element is `UdpTransportBindingElement`, which derives from <xref:System.ServiceModel.Channels.TransportBindingElement>. It overrides the following methods to build the factories associated with our binding.  \n  \n```csharp\npublic IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context)  \n{  \n    return (IChannelFactory<TChannel>)(object)new UdpChannelFactory(this, context);  \n}  \n  \npublic IChannelListener<TChannel> BuildChannelListener<TChannel>(BindingContext context)  \n{  \n    return (IChannelListener<TChannel>)(object)new UdpChannelListener(this, context);  \n}  \n```  \n  \n It also contains members for cloning the `BindingElement` and returning our scheme (soap.udp).  \n  \n## Adding Metadata Support for a Transport Binding Element  \n To integrate our transport into the metadata system, we must support both the import and export of policy. This allows us to generate clients of our binding through the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).  \n  \n### Adding WSDL Support  \n The transport binding element in a binding is responsible for exporting and importing addressing information in metadata. When using a SOAP binding, the transport binding element should also export a correct transport URI in metadata.  \n  \n#### WSDL Export  \n To export addressing information the `UdpTransportBindingElement` implements the `IWsdlExportExtension` interface. The `ExportEndpoint` method adds the correct addressing information to the WSDL port.  \n  \n```csharp\nif (context.WsdlPort != null)  \n{  \n    AddAddressToWsdlPort(context.WsdlPort, context.Endpoint.Address, encodingBindingElement.MessageVersion.Addressing);  \n}  \n```  \n  \n The `UdpTransportBindingElement` implementation of the `ExportEndpoint` method also exports a transport URI when the endpoint uses a SOAP binding.  \n  \n```csharp\nWsdlNS.SoapBinding soapBinding = GetSoapBinding(context, exporter);  \nif (soapBinding != null)  \n{  \n    soapBinding.Transport = UdpPolicyStrings.UdpNamespace;  \n}  \n```  \n  \n#### WSDL Import  \n To extend the WSDL import system to handle importing the addresses, we must add the following configuration to the configuration file for Svcutil.exe as shown in the Svcutil.exe.config file.  \n  \n```xml\n<configuration>  \n  <system.serviceModel>  \n    <client>  \n      <metadata>  \n        <wsdlImporters>  \n          <extension type=\" Microsoft.ServiceModel.Samples.UdpBindingElementImporter, UdpTransport\" />  \n        </policyImporters>  \n      </metadata>  \n    </client>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n When running Svcutil.exe, there are two options for getting Svcutil.exe to load the WSDL import extensions:  \n  \n1.  Point Svcutil.exe to our configuration file using the /SvcutilConfig:\\<file>.  \n  \n2.  Add the configuration section to Svcutil.exe.config in the same directory as Svcutil.exe.  \n  \n The `UdpBindingElementImporter` type implements the `IWsdlImportExtension` interface. The `ImportEndpoint` method imports the address from the WSDL port.  \n  \n```csharp\nBindingElementCollection bindingElements = context.Endpoint.Binding.CreateBindingElements();  \nTransportBindingElement transportBindingElement = bindingElements.Find<TransportBindingElement>();  \nif (transportBindingElement is UdpTransportBindingElement)  \n{  \n    ImportAddress(context);  \n}  \n```  \n  \n### Adding Policy Support  \n The custom binding element can export policy assertions in the WSDL binding for a service endpoint to express the capabilities of that binding element.  \n  \n#### Policy Export  \n The `UdpTransportBindingElement` type implements `IPolicyExportExtension` to add support for exporting policy. As a result, `System.ServiceModel.MetadataExporter` includes `UdpTransportBindingElement` in the generation of policy for any binding that includes it.  \n  \n In `IPolicyExportExtension.ExportPolicy`, we add an assertion for UDP and another assertion if we are in multicast mode. This is because multicast mode affects how the communication stack is constructed, and thus must be coordinated between both sides.  \n  \n```csharp\nICollection<XmlElement> bindingAssertions = context.GetBindingAssertions();  \nXmlDocument xmlDocument = new XmlDocument();  \nbindingAssertions.Add(xmlDocument.CreateElement(  \nUdpPolicyStrings.Prefix, UdpPolicyStrings.TransportAssertion, UdpPolicyStrings.UdpNamespace));  \nif (Multicast)  \n{  \n    bindingAssertions.Add(xmlDocument.CreateElement(\n        UdpPolicyStrings.Prefix, \n        UdpPolicyStrings.MulticastAssertion, \n        UdpPolicyStrings.UdpNamespace));  \n}  \n```  \n  \n Because custom transport binding elements are responsible for handling addressing, the `IPolicyExportExtension` implementation on the `UdpTransportBindingElement` must also handle exporting the appropriate WS-Addressing policy assertions to indicate the version of WS-Addressing being used.  \n  \n```csharp\nAddWSAddressingAssertion(context, encodingBindingElement.MessageVersion.Addressing);  \n```  \n  \n#### Policy Import  \n To extend the Policy Import system, we must add the following configuration to the configuration file for Svcutil.exe as shown in the Svcutil.exe.config file.  \n  \n```xml\n<configuration>  \n  <system.serviceModel>  \n    <client>  \n      <metadata>  \n        <policyImporters>  \n          <extension type=\" Microsoft.ServiceModel.Samples.UdpBindingElementImporter, UdpTransport\" />  \n        </policyImporters>  \n      </metadata>  \n    </client>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n Then we implement `IPolicyImporterExtension` from our registered class (`UdpBindingElementImporter`). In `ImportPolicy()`, we look through the assertions in our namespace, and process the ones for generating the transport and check whether it is multicast. We also must remove the assertions we handle from the list of binding assertions. Again, when running Svcutil.exe, there are two options for integration:  \n  \n1.  Point Svcutil.exe to our configuration file using the /SvcutilConfig:\\<file>.  \n  \n2.  Add the configuration section to Svcutil.exe.config in the same directory as Svcutil.exe.  \n  \n<a name=\"AddingAStandardBinding\"></a>   \n## Adding a Standard Binding  \n Our binding element can be used in the following two ways:  \n  \n-   Through a custom binding: A custom binding allows the user to create their own binding based on an arbitrary set of binding elements.  \n  \n-   By using a system-provided binding that includes our binding element. WCF provides a number of these system-defined bindings, such as `BasicHttpBinding`, `NetTcpBinding`, and `WsHttpBinding`. Each of these bindings is associated with a well-defined profile.  \n  \n The sample implements profile binding in `SampleProfileUdpBinding`, which derives from <xref:System.ServiceModel.Channels.Binding>. The `SampleProfileUdpBinding` contains up to four binding elements within it: `UdpTransportBindingElement`, `TextMessageEncodingBindingElement CompositeDuplexBindingElement`, and `ReliableSessionBindingElement`.  \n  \n```csharp\npublic override BindingElementCollection CreateBindingElements()  \n{     \n    BindingElementCollection bindingElements = new BindingElementCollection();  \n    if (ReliableSessionEnabled)  \n    {  \n        bindingElements.Add(session);  \n        bindingElements.Add(compositeDuplex);  \n    }  \n    bindingElements.Add(encoding);  \n    bindingElements.Add(transport);  \n    return bindingElements.Clone();  \n}  \n```  \n  \n### Adding a Custom Standard Binding Importer  \n Svcutil.exe and the `WsdlImporter` type, by default, recognizes and imports system-defined bindings. Otherwise, the binding gets imported as a `CustomBinding` instance. To enable Svcutil.exe and the `WsdlImporter` to import the `SampleProfileUdpBinding` the `UdpBindingElementImporter` also acts as a custom standard binding importer.  \n  \n A custom standard binding importer implements the `ImportEndpoint` method on the `IWsdlImportExtension` interface to examine the `CustomBinding` instance imported from metadata to see whether it could have been generated by a specific standard binding.  \n  \n```csharp\nif (context.Endpoint.Binding is CustomBinding)  \n{  \n    Binding binding;  \n    if (transportBindingElement is UdpTransportBindingElement)  \n    {  \n        //if TryCreate is true, the CustomBinding will be replace by a SampleProfileUdpBinding in the  \n        //generated config file for better typed generation.  \n        if (SampleProfileUdpBinding.TryCreate(bindingElements, out binding))  \n        {  \n            binding.Name = context.Endpoint.Binding.Name;  \n            binding.Namespace = context.Endpoint.Binding.Namespace;  \n            context.Endpoint.Binding = binding;  \n        }  \n    }  \n}  \n```  \n  \n Generally, implementing a custom standard binding importer involves checking the properties of the imported binding elements to verify that only properties that could have been set by the standard binding have changed and all other properties are their defaults. A basic strategy for implementing a standard binding importer is to create an instance of the standard binding, propagate the properties from the binding elements to the standard binding instance that the standard binding supports, and the compare the binding elements from the standard binding with the imported binding elements.  \n  \n<a name=\"AddingConfigurationSupport\"></a>   \n## Adding Configuration Support  \n To expose our transport through configuration, we must implement two configuration sections. The first is a `BindingElementExtensionElement` for `UdpTransportBindingElement`. This is so that `CustomBinding` implementations can reference our binding element. The second is a `Configuration` for our `SampleProfileUdpBinding`.  \n  \n### Binding Element Extension Element  \n The section `UdpTransportElement` is a `BindingElementExtensionElement` that exposes `UdpTransportBindingElement` to the configuration system. With a few basic overrides, we define our configuration section name, the type of our binding element and how to create our binding element. We can then register our extension section in a configuration file as shown in the following code.  \n  \n```xml\n<configuration>  \n  <system.serviceModel>  \n    <extensions>  \n      <bindingElementExtensions>  \n        <add name=\"udpTransport\" type=\"Microsoft.ServiceModel.Samples.UdpTransportElement, UdpTransport />  \n      </bindingElementExtensions>  \n    </extensions>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n The extension can be referenced from custom bindings to use UDP as the transport.  \n  \n```xml\n<configuration>  \n  <system.serviceModel>  \n    <bindings>  \n      <customBinding>  \n       <binding configurationName=\"UdpCustomBinding\">  \n         <udpTransport/>  \n       </binding>  \n      </customBinding>  \n    </bindings>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n### Binding Section  \n The section `SampleProfileUdpBindingCollectionElement` is a `StandardBindingCollectionElement` that exposes `SampleProfileUdpBinding` to the configuration system. The bulk of the implementation is delegated to the `SampleProfileUdpBindingConfigurationElement`, which derives from `StandardBindingElement`. The `SampleProfileUdpBindingConfigurationElement` has properties that correspond to the properties on `SampleProfileUdpBinding`, and functions to map from the `ConfigurationElement` binding. Finally, override the `OnApplyConfiguration` method in our `SampleProfileUdpBinding`, as shown in the following sample code.  \n  \n```csharp\nprotected override void OnApplyConfiguration(string configurationName)  \n{  \n    if (binding == null)\n        throw new ArgumentNullException(\"binding\");\n\n    if (binding.GetType() != typeof(SampleProfileUdpBinding))\n    {\n        throw new ArgumentException(string.Format(CultureInfo.CurrentCulture,\n            \"Invalid type for binding. Expected type: {0}. Type passed in: {1}.\",\n            typeof(SampleProfileUdpBinding).AssemblyQualifiedName,\n            binding.GetType().AssemblyQualifiedName));\n    }\n    SampleProfileUdpBinding udpBinding = (SampleProfileUdpBinding)binding;\n\n    udpBinding.OrderedSession = this.OrderedSession;\n    udpBinding.ReliableSessionEnabled = this.ReliableSessionEnabled;\n    udpBinding.SessionInactivityTimeout = this.SessionInactivityTimeout;\n    if (this.ClientBaseAddress != null)\n        udpBinding.ClientBaseAddress = ClientBaseAddress;\n}\n```  \n  \n To register this handler with the configuration system, we add the following section to the relevant configuration file.  \n  \n```xml\n<configuration>  \n  <configSections>  \n     <sectionGroup name=\"system.serviceModel\">  \n        <sectionGroup name=\"bindings\">  \n          <section name=\"sampleProfileUdpBinding\" type=\"Microsoft.ServiceModel.Samples.SampleProfileUdpBindingCollectionElement, UdpTransport />  \n        </sectionGroup>  \n     </sectionGroup>  \n  </configSections>  \n</configuration>  \n```  \n  \n It can then be referenced from the serviceModel configuration section.  \n  \n```xml\n<configuration>  \n  <system.serviceModel>  \n    <client>  \n      <endpoint configurationName=\"calculator\"  \n                address=\"soap.udp://localhost:8001/\"   \n                bindingConfiguration=\"CalculatorServer\"  \n                binding=\"sampleProfileUdpBinding\"   \n                contract= \"Microsoft.ServiceModel.Samples.ICalculatorContract\">  \n      </endpoint>  \n    </client>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n## The UDP Test Service and Client  \n Test code for using this sample transport is available in the UdpTestService and UdpTestClient directories. The service code consists of two tests—one test sets up bindings and endpoints from code and the other does it through configuration. Both tests use two endpoints. One endpoint uses the `SampleUdpProfileBinding` with [\\<reliableSession>](https://docs.microsoft.com/previous-versions/ms731375(v=vs.90)) set to `true`. The other endpoint uses a custom binding with `UdpTransportBindingElement`. This is equivalent to using `SampleUdpProfileBinding` with [\\<reliableSession>](https://docs.microsoft.com/previous-versions/ms731375(v=vs.90)) set to `false`. Both tests create a service, add an endpoint for each binding, open the service and then wait for the user to hit ENTER before closing the service.  \n  \n When you start the service test application you should see the following output.  \n  \n```console\nTesting Udp From Code.  \nService is started from code...  \nPress <ENTER> to terminate the service and start service from config...  \n```  \n  \n You can then run the test client application against the published endpoints. The client test application creates a client for each endpoint and sends five messages to each endpoint. The following output is on the client.  \n  \n```console\nTesting Udp From Imported Files Generated By SvcUtil.  \n0  \n3  \n6  \n9  \n12  \nPress <ENTER> to complete test.  \n```  \n  \n The following is the full output on the service.  \n  \n```console\nService is started from code...  \nPress <ENTER> to terminate the service and start service from config...  \nHello, world!  \nHello, world!  \nHello, world!  \nHello, world!  \nHello, world!  \n   adding 0 + 0  \n   adding 1 + 2  \n   adding 2 + 4  \n   adding 3 + 6  \n   adding 4 + 8  \n```  \n  \n To run the client application against endpoints published using configuration, hit ENTER on the service and then run the test client again. You should see the following output on the service.  \n  \n```console\nTesting Udp From Config.  \nService is started from config...  \nPress <ENTER> to terminate the service and exit...  \n```  \n  \n Running the client again yields the same as the preceding results.  \n  \n To regenerate the client code and configuration using Svcutil.exe, start the service application and then run the following Svcutil.exe from the root directory of the sample.  \n  \n```console\nsvcutil http://localhost:8000/udpsample/ /reference:UdpTranport\\bin\\UdpTransport.dll /svcutilConfig:svcutil.exe.config  \n```  \n  \n Note that Svcutil.exe does not generate the binding extension configuration for the `SampleProfileUdpBinding`, so you must add it manually.  \n  \n```xml\n<configuration>  \n  <system.serviceModel>      \n    <extensions>  \n      <!-- This was added manually because svcutil.exe does not add this extension to the file -->  \n      <bindingExtensions>  \n        <add name=\"sampleProfileUdpBinding\" type=\"Microsoft.ServiceModel.Samples.SampleProfileUdpBindingCollectionElement, UdpTransport\" />  \n      </bindingExtensions>  \n    </extensions>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n#### To set up, build, and run the sample  \n  \n1.  To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n2.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n3.  Refer to the preceding \"The UDP Test Service and Client\" section.  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Transport\\Udp`\n","nodes":[{"pos":[4,98],"embed":true,"restype":"x-metadata","content":"title: \"Transport: UDP\"\nms.date: \"03/30/2017\"\nms.assetid: 738705de-ad3e-40e0-b363-90305bddb140","nodes":[{"content":"Transport: UDP","nodes":[{"pos":[0,14],"content":"Transport: UDP","nodes":[{"content":"Transport: UDP","pos":[0,14]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[105,119],"content":"Transport: UDP","linkify":"Transport: UDP","nodes":[{"content":"Transport: UDP","pos":[0,14]}]},{"content":"The UDP Transport sample demonstrates how to implement UDP unicast and multicast as a custom Windows Communication Foundation (WCF) transport.","pos":[120,262]},{"content":"The sample describes the recommended procedure for creating a custom transport in WCF, by using the channel framework and following WCF best practices.","pos":[263,414]},{"content":"The steps to create a custom transport are as follows:","pos":[415,469]},{"content":"Decide which of the channel <bpt id=\"p1\">[</bpt>Message Exchange Patterns<ept id=\"p1\">](#MessageExchangePatterns)</ept> (IOutputChannel, IInputChannel, IDuplexChannel, IRequestChannel, or IReplyChannel) your ChannelFactory and ChannelListener will support.","pos":[479,697],"source":"Decide which of the channel [Message Exchange Patterns](#MessageExchangePatterns) (IOutputChannel, IInputChannel, IDuplexChannel, IRequestChannel, or IReplyChannel) your ChannelFactory and ChannelListener will support."},{"content":"Then decide whether you will support the sessionful variations of these interfaces.","pos":[698,781]},{"content":"Create a channel factory and listener that support your Message Exchange Pattern.","pos":[791,872]},{"pos":[882,1027],"content":"Ensure that any network-specific exceptions are normalized to the appropriate derived class of <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph>.","source":"Ensure that any network-specific exceptions are normalized to the appropriate derived class of <xref:System.ServiceModel.CommunicationException>."},{"content":"Add a <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>binding&gt;<ept id=\"p1\">](../../../../docs/framework/misc/binding.md)</ept> element that adds the custom transport to a channel stack.","pos":[1037,1158],"source":"Add a [\\<binding>](../../../../docs/framework/misc/binding.md) element that adds the custom transport to a channel stack."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Adding a Binding Element<ept id=\"p1\">](#AddingABindingElement)</ept>.","pos":[1159,1236],"source":" For more information, see [Adding a Binding Element](#AddingABindingElement)."},{"content":"Add a binding element extension section to expose the new binding element to the configuration system.","pos":[1246,1348]},{"content":"Add metadata extensions to communicate capabilities to other endpoints.","pos":[1358,1429]},{"content":"Add a binding that pre-configures a stack of binding elements according to a well-defined profile.","pos":[1439,1537]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Adding a Standard Binding<ept id=\"p1\">](#AddingAStandardBinding)</ept>.","pos":[1538,1617],"source":" For more information, see [Adding a Standard Binding](#AddingAStandardBinding)."},{"content":"Add a binding section and binding configuration element to expose the binding to the configuration system.","pos":[1627,1733]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Adding Configuration Support<ept id=\"p1\">](#AddingConfigurationSupport)</ept>.","pos":[1734,1820],"source":" For more information, see [Adding Configuration Support](#AddingConfigurationSupport)."},{"pos":[1871,1896],"content":"Message Exchange Patterns","linkify":"Message Exchange Patterns","nodes":[{"content":"Message Exchange Patterns","pos":[0,25]}]},{"content":"The first step in writing a custom transport is to decide which Message Exchange Patterns (MEPs) are required for the transport.","pos":[1900,2028]},{"content":"There are three MEPs to choose from:","pos":[2029,2065]},{"content":"Datagram (IInputChannel/IOutputChannel)","pos":[2075,2114]},{"content":"When using a datagram MEP, a client sends a message using a \"fire and forget\" exchange.","pos":[2125,2212]},{"content":"A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.","pos":[2213,2309]},{"content":"The message might be lost in transit and never reach the service.","pos":[2310,2375]},{"content":"If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.","pos":[2376,2512]},{"content":"The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.","pos":[2513,2672]},{"content":"Client datagram channels implement the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IOutputChannel&gt;</ph> interface and service datagram channels implement the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> interface.","pos":[2673,2877],"source":" Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface."},{"content":"Request-Response (IRequestChannel/IReplyChannel)","pos":[2887,2935]},{"content":"In this MEP, a message is sent, and a reply is received.","pos":[2946,3002]},{"content":"The pattern consists of request-response pairs.","pos":[3003,3050]},{"content":"Examples of request-response calls are remote procedure calls (RPC) and browser GETs.","pos":[3051,3136]},{"content":"This pattern is also known as Half-Duplex.","pos":[3137,3179]},{"content":"In this MEP, client channels implement <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IRequestChannel&gt;</ph> and service channels implement <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph>.","pos":[3180,3352],"source":" In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>."},{"content":"Duplex (IDuplexChannel)","pos":[3362,3385]},{"content":"The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.","pos":[3396,3499]},{"content":"The duplex MEP is like a phone conversation, where each word being spoken is a message.","pos":[3500,3587]},{"content":"Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexChannel&gt;</ph>.","pos":[3588,3756],"source":" Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>."},{"content":"Each of these MEPs can also support sessions.","pos":[3763,3808]},{"content":"The added functionality provided by a session-aware channel is that it correlates all messages sent and received on a channel.","pos":[3809,3935]},{"content":"The Request-Response pattern is a stand-alone two-message session, as the request and reply are correlated.","pos":[3936,4043]},{"content":"In contrast, the Request-Response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.","pos":[4044,4196]},{"content":"This gives you a total of six MEPs—Datagram, Request-Response, Duplex, Datagram with sessions, Request-Response with sessions, and Duplex with sessions—to choose from.","pos":[4197,4364]},{"pos":[4372,4505],"content":"[!NOTE]\n For the UDP transport, the only MEP that is supported is Datagram, because UDP is inherently a \"fire and forget\" protocol.","leadings":["","> "],"nodes":[{"content":"For the UDP transport, the only MEP that is supported is Datagram, because UDP is inherently a \"fire and forget\" protocol.","pos":[9,131]}]},{"pos":[4515,4568],"content":"The ICommunicationObject and the WCF object lifecycle","linkify":"The ICommunicationObject and the WCF object lifecycle","nodes":[{"content":"The ICommunicationObject and the WCF object lifecycle","pos":[0,53]}]},{"content":"WCF has a common state machine that is used for managing the lifecycle of objects like <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannel&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IChannelFactory&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IChannelListener&gt;</ph> that are used for communication.","pos":[4572,4847],"source":"WCF has a common state machine that is used for managing the lifecycle of objects like <xref:System.ServiceModel.Channels.IChannel>, <xref:System.ServiceModel.Channels.IChannelFactory>, and <xref:System.ServiceModel.Channels.IChannelListener> that are used for communication."},{"content":"There are five states in which these communication objects can exist.","pos":[4848,4917]},{"content":"These states are represented by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationState&gt;</ph> enumeration, and are as follows:","pos":[4918,5032],"source":" These states are represented by the <xref:System.ServiceModel.CommunicationState> enumeration, and are as follows:"},{"content":"Created: This is the state of a <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> when it is first instantiated.","pos":[5042,5152],"source":"Created: This is the state of a <xref:System.ServiceModel.ICommunicationObject> when it is first instantiated."},{"content":"No input/output (I/O) occurs in this state.","pos":[5153,5196]},{"content":"Opening: Objects transition to this state when <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Open%2A&gt;</ph> is called.","pos":[5206,5319],"source":"Opening: Objects transition to this state when <xref:System.ServiceModel.ICommunicationObject.Open%2A> is called."},{"content":"At this point properties are made immutable, and input/output can begin.","pos":[5320,5392]},{"content":"This transition is valid only from the Created state.","pos":[5393,5446]},{"content":"Opened: Objects transition to this state when the open process completes.","pos":[5456,5529]},{"content":"This transition is valid only from the Opening state.","pos":[5530,5583]},{"content":"At this point, the object is fully usable for transfer.","pos":[5584,5639]},{"content":"Closing: Objects transition to this state when <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Close%2A&gt;</ph> is called for a graceful shutdown.","pos":[5649,5787],"source":"Closing: Objects transition to this state when <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called for a graceful shutdown."},{"content":"This transition is valid only from the Opened state.","pos":[5788,5840]},{"content":"Closed: In the Closed state objects are no longer usable.","pos":[5850,5907]},{"content":"In general, most configuration is still accessible for inspection, but no communication can occur.","pos":[5908,6006]},{"content":"This state is equivalent to being disposed.","pos":[6007,6050]},{"content":"Faulted: In the Faulted state, objects are accessible to inspection but no longer usable.","pos":[6060,6149]},{"content":"When a non-recoverable error occurs, the object transitions into this state.","pos":[6150,6226]},{"content":"The only valid transition from this state is into the <ph id=\"ph1\">`Closed`</ph> state.","pos":[6227,6296],"source":" The only valid transition from this state is into the `Closed` state."},{"content":"There are events that fire for each state transition.","pos":[6303,6356]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A&gt;</ph> method can be called at any time, and causes the object to transition immediately from its current state into the Closed state.","pos":[6357,6545],"source":" The <xref:System.ServiceModel.ICommunicationObject.Abort%2A> method can be called at any time, and causes the object to transition immediately from its current state into the Closed state."},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A&gt;</ph> terminates any unfinished work.","pos":[6546,6642],"source":" Calling <xref:System.ServiceModel.ICommunicationObject.Abort%2A> terminates any unfinished work."},{"pos":[6695,6731],"content":"Channel Factory and Channel Listener","linkify":"Channel Factory and Channel Listener","nodes":[{"content":"Channel Factory and Channel Listener","pos":[0,36]}]},{"content":"The next step in writing a custom transport is to create an implementation of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelFactory&gt;</ph> for client channels and of <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IChannelListener&gt;</ph> for service channels.","pos":[6735,6966],"source":"The next step in writing a custom transport is to create an implementation of <xref:System.ServiceModel.Channels.IChannelFactory> for client channels and of <xref:System.ServiceModel.Channels.IChannelListener> for service channels."},{"content":"The channel layer uses a factory pattern for constructing channels.","pos":[6967,7034]},{"content":"WCF provides base class helpers for this process.","pos":[7035,7084]},{"pos":[7094,7281],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CommunicationObject&gt;</ph> class implements <ph id=\"ph2\">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> and enforces the state machine previously described in Step 2.","source":"The <xref:System.ServiceModel.Channels.CommunicationObject> class implements <xref:System.ServiceModel.ICommunicationObject> and enforces the state machine previously described in Step 2."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ChannelManagerBase&gt;</ph> class implements <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.CommunicationObject&gt;</ph> and provides a unified base class for <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.ChannelFactoryBase&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.ServiceModel.Channels.ChannelListenerBase&gt;</ph>.","pos":[7288,7573],"source":"The <xref:System.ServiceModel.Channels.ChannelManagerBase> class implements <xref:System.ServiceModel.Channels.CommunicationObject> and provides a unified base class for <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ChannelManagerBase&gt;</ph> class works in conjunction with <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ChannelBase&gt;</ph>, which is a base class that implements <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IChannel&gt;</ph>.","pos":[7574,7797],"source":" The <xref:System.ServiceModel.Channels.ChannelManagerBase> class works in conjunction with <xref:System.ServiceModel.Channels.ChannelBase>, which is a base class that implements <xref:System.ServiceModel.Channels.IChannel>."},{"pos":[7807,8084],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ChannelFactoryBase&gt;</ph> class implements <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ChannelManagerBase&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IChannelFactory&gt;</ph> and consolidates the <ph id=\"ph4\">`CreateChannel`</ph> overloads into one <ph id=\"ph5\">`OnCreateChannel`</ph> abstract method.","source":"The <xref:System.ServiceModel.Channels.ChannelFactoryBase> class implements <xref:System.ServiceModel.Channels.ChannelManagerBase> and <xref:System.ServiceModel.Channels.IChannelFactory> and consolidates the `CreateChannel` overloads into one `OnCreateChannel` abstract method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ChannelListenerBase&gt;</ph> class implements <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IChannelListener&gt;</ph>.","pos":[8094,8224],"source":"The <xref:System.ServiceModel.Channels.ChannelListenerBase> class implements <xref:System.ServiceModel.Channels.IChannelListener>."},{"content":"It takes care of basic state management.","pos":[8225,8265]},{"content":"In this sample, the factory implementation is contained in UdpChannelFactory.cs and the listener implementation is contained in UdpChannelListener.cs.","pos":[8272,8422]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannel&gt;</ph> implementations are in UdpOutputChannel.cs and UdpInputChannel.cs.","pos":[8423,8538],"source":" The <xref:System.ServiceModel.Channels.IChannel> implementations are in UdpOutputChannel.cs and UdpInputChannel.cs."},{"pos":[8548,8571],"content":"The UDP Channel Factory","linkify":"The UDP Channel Factory","nodes":[{"content":"The UDP Channel Factory","pos":[0,23]}]},{"content":"The <ph id=\"ph1\">`UdpChannelFactory`</ph> derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ChannelFactoryBase&gt;</ph>.","pos":[8575,8667],"source":"The `UdpChannelFactory` derives from <xref:System.ServiceModel.Channels.ChannelFactoryBase>."},{"content":"The sample overrides <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ChannelFactoryBase.GetProperty%2A&gt;</ph> to provide access to the message version of the message encoder.","pos":[8668,8823],"source":" The sample overrides <xref:System.ServiceModel.Channels.ChannelFactoryBase.GetProperty%2A> to provide access to the message version of the message encoder."},{"content":"The sample also overrides <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ChannelFactoryBase.OnClose%2A&gt;</ph> so that we can tear down our instance of <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.BufferManager&gt;</ph> when the state machine transitions.","pos":[8824,9042],"source":" The sample also overrides <xref:System.ServiceModel.Channels.ChannelFactoryBase.OnClose%2A> so that we can tear down our instance of <xref:System.ServiceModel.Channels.BufferManager> when the state machine transitions."},{"pos":[9053,9075],"content":"The UDP Output Channel","linkify":"The UDP Output Channel","nodes":[{"content":"The UDP Output Channel","pos":[0,22]}]},{"content":"The <ph id=\"ph1\">`UdpOutputChannel`</ph> implements <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IOutputChannel&gt;</ph>.","pos":[9079,9164],"source":"The `UdpOutputChannel` implements <xref:System.ServiceModel.Channels.IOutputChannel>."},{"content":"The constructor validates the arguments and constructs a destination <ph id=\"ph1\">&lt;xref:System.Net.EndPoint&gt;</ph> object based on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.EndpointAddress&gt;</ph> that is passed in.","pos":[9165,9342],"source":" The constructor validates the arguments and constructs a destination <xref:System.Net.EndPoint> object based on the <xref:System.ServiceModel.EndpointAddress> that is passed in."},{"content":"The channel can be closed gracefully or ungracefully.","pos":[9467,9520]},{"content":"If the channel is closed gracefully the socket is closed and a call is made to the base class <ph id=\"ph1\">`OnClose`</ph> method.","pos":[9521,9632],"source":" If the channel is closed gracefully the socket is closed and a call is made to the base class `OnClose` method."},{"content":"If this throws an exception, the infrastructure calls <ph id=\"ph1\">`Abort`</ph> to ensure the channel is cleaned up.","pos":[9633,9731],"source":" If this throws an exception, the infrastructure calls `Abort` to ensure the channel is cleaned up."},{"content":"We then implement <ph id=\"ph1\">`Send()`</ph> and <ph id=\"ph2\">`BeginSend()`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`EndSend()`</ph>.","pos":[9781,9838],"source":"We then implement `Send()` and `BeginSend()`/`EndSend()`."},{"content":"This breaks down into two main sections.","pos":[9839,9879]},{"content":"First we serialize the message into a byte array.","pos":[9880,9929]},{"content":"Then we send the resulting data on the wire.","pos":[10016,10060]},{"pos":[10214,10236],"content":"The UdpChannelListener","linkify":"The UdpChannelListener","nodes":[{"content":"The UdpChannelListener","pos":[0,22]}]},{"content":"The <ph id=\"ph1\">`UdpChannelListener`</ph> that the sample implements derives from the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ChannelListenerBase&gt;</ph> class.","pos":[10240,10371],"source":"The `UdpChannelListener` that the sample implements derives from the <xref:System.ServiceModel.Channels.ChannelListenerBase> class."},{"content":"It uses a single UDP socket to receive datagrams.","pos":[10372,10421]},{"content":"The <ph id=\"ph1\">`OnOpen`</ph> method receives data using the UDP socket in an asynchronous loop.","pos":[10422,10501],"source":" The `OnOpen` method receives data using the UDP socket in an asynchronous loop."},{"content":"The data are then converted into messages using the Message Encoding Framework.","pos":[10502,10581]},{"content":"Because the same datagram channel represents messages that arrive from a number of sources, the <ph id=\"ph1\">`UdpChannelListener`</ph> is a singleton listener.","pos":[10719,10860],"source":"Because the same datagram channel represents messages that arrive from a number of sources, the `UdpChannelListener` is a singleton listener."},{"content":"There is, at most, one active <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannel&gt;</ph> associated with this listener at a time.","pos":[10861,10976],"source":" There is, at most, one active <xref:System.ServiceModel.Channels.IChannel> associated with this listener at a time."},{"content":"The sample generates another one only if a channel that is returned by the <ph id=\"ph1\">`AcceptChannel`</ph> method is subsequently disposed.","pos":[10977,11100],"source":" The sample generates another one only if a channel that is returned by the `AcceptChannel` method is subsequently disposed."},{"content":"When a message is received, it is enqueued into this singleton channel.","pos":[11101,11172]},{"pos":[11183,11198],"content":"UdpInputChannel","linkify":"UdpInputChannel","nodes":[{"content":"UdpInputChannel","pos":[0,15]}]},{"content":"The <ph id=\"ph1\">`UdpInputChannel`</ph> class implements <ph id=\"ph2\">`IInputChannel`</ph>.","pos":[11202,11257],"source":"The `UdpInputChannel` class implements `IInputChannel`."},{"content":"It consists of a queue of incoming messages that is populated by the <ph id=\"ph1\">`UdpChannelListener`</ph>'s socket.","pos":[11258,11357],"source":" It consists of a queue of incoming messages that is populated by the `UdpChannelListener`'s socket."},{"content":"These messages are dequeued by the <ph id=\"ph1\">`IInputChannel.Receive`</ph> method.","pos":[11358,11424],"source":" These messages are dequeued by the `IInputChannel.Receive` method."},{"pos":[11473,11497],"content":"Adding a Binding Element","linkify":"Adding a Binding Element","nodes":[{"content":"Adding a Binding Element","pos":[0,24]}]},{"content":"Now that the factories and channels are built, we must expose them to the ServiceModel runtime through a binding.","pos":[11501,11614]},{"content":"A binding is a collection of binding elements that represents the communication stack associated with a service address.","pos":[11615,11735]},{"content":"Each element in the stack is represented by a <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>binding&gt;<ept id=\"p1\">](../../../../docs/framework/misc/binding.md)</ept> element.","pos":[11736,11847],"source":" Each element in the stack is represented by a [\\<binding>](../../../../docs/framework/misc/binding.md) element."},{"content":"In the sample, the binding element is <ph id=\"ph1\">`UdpTransportBindingElement`</ph>, which derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement&gt;</ph>.","pos":[11854,12001],"source":"In the sample, the binding element is `UdpTransportBindingElement`, which derives from <xref:System.ServiceModel.Channels.TransportBindingElement>."},{"content":"It overrides the following methods to build the factories associated with our binding.","pos":[12002,12088]},{"pos":[12487,12581],"content":"It also contains members for cloning the <ph id=\"ph1\">`BindingElement`</ph> and returning our scheme (soap.udp).","source":"It also contains members for cloning the `BindingElement` and returning our scheme (soap.udp)."},{"pos":[12590,12645],"content":"Adding Metadata Support for a Transport Binding Element","linkify":"Adding Metadata Support for a Transport Binding Element","nodes":[{"content":"Adding Metadata Support for a Transport Binding Element","pos":[0,55]}]},{"content":"To integrate our transport into the metadata system, we must support both the import and export of policy.","pos":[12649,12755]},{"content":"This allows us to generate clients of our binding through the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.","pos":[12756,12951],"source":" This allows us to generate clients of our binding through the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)."},{"pos":[12961,12980],"content":"Adding WSDL Support","linkify":"Adding WSDL Support","nodes":[{"content":"Adding WSDL Support","pos":[0,19]}]},{"content":"The transport binding element in a binding is responsible for exporting and importing addressing information in metadata.","pos":[12984,13105]},{"content":"When using a SOAP binding, the transport binding element should also export a correct transport URI in metadata.","pos":[13106,13218]},{"pos":[13229,13240],"content":"WSDL Export","linkify":"WSDL Export","nodes":[{"content":"WSDL Export","pos":[0,11]}]},{"content":"To export addressing information the <ph id=\"ph1\">`UdpTransportBindingElement`</ph> implements the <ph id=\"ph2\">`IWsdlExportExtension`</ph> interface.","pos":[13244,13358],"source":"To export addressing information the `UdpTransportBindingElement` implements the `IWsdlExportExtension` interface."},{"content":"The <ph id=\"ph1\">`ExportEndpoint`</ph> method adds the correct addressing information to the WSDL port.","pos":[13359,13444],"source":" The `ExportEndpoint` method adds the correct addressing information to the WSDL port."},{"pos":[13632,13778],"content":"The <ph id=\"ph1\">`UdpTransportBindingElement`</ph> implementation of the <ph id=\"ph2\">`ExportEndpoint`</ph> method also exports a transport URI when the endpoint uses a SOAP binding.","source":"The `UdpTransportBindingElement` implementation of the `ExportEndpoint` method also exports a transport URI when the endpoint uses a SOAP binding."},{"pos":[13974,13985],"content":"WSDL Import","linkify":"WSDL Import","nodes":[{"content":"WSDL Import","pos":[0,11]}]},{"content":"To extend the WSDL import system to handle importing the addresses, we must add the following configuration to the configuration file for Svcutil.exe as shown in the Svcutil.exe.config file.","pos":[13989,14179]},{"content":"When running Svcutil.exe, there are two options for getting Svcutil.exe to load the WSDL import extensions:","pos":[14522,14629]},{"content":"Point Svcutil.exe to our configuration file using the /SvcutilConfig:<ph id=\"ph1\">\\&lt;</ph>file&gt;.","pos":[14639,14716],"source":"Point Svcutil.exe to our configuration file using the /SvcutilConfig:\\<file>."},{"content":"Add the configuration section to Svcutil.exe.config in the same directory as Svcutil.exe.","pos":[14726,14815]},{"content":"The <ph id=\"ph1\">`UdpBindingElementImporter`</ph> type implements the <ph id=\"ph2\">`IWsdlImportExtension`</ph> interface.","pos":[14822,14907],"source":"The `UdpBindingElementImporter` type implements the `IWsdlImportExtension` interface."},{"content":"The <ph id=\"ph1\">`ImportEndpoint`</ph> method imports the address from the WSDL port.","pos":[14908,14975],"source":" The `ImportEndpoint` method imports the address from the WSDL port."},{"pos":[15299,15320],"content":"Adding Policy Support","linkify":"Adding Policy Support","nodes":[{"content":"Adding Policy Support","pos":[0,21]}]},{"content":"The custom binding element can export policy assertions in the WSDL binding for a service endpoint to express the capabilities of that binding element.","pos":[15324,15475]},{"pos":[15486,15499],"content":"Policy Export","linkify":"Policy Export","nodes":[{"content":"Policy Export","pos":[0,13]}]},{"content":"The <ph id=\"ph1\">`UdpTransportBindingElement`</ph> type implements <ph id=\"ph2\">`IPolicyExportExtension`</ph> to add support for exporting policy.","pos":[15503,15613],"source":"The `UdpTransportBindingElement` type implements `IPolicyExportExtension` to add support for exporting policy."},{"content":"As a result, <ph id=\"ph1\">`System.ServiceModel.MetadataExporter`</ph> includes <ph id=\"ph2\">`UdpTransportBindingElement`</ph> in the generation of policy for any binding that includes it.","pos":[15614,15765],"source":" As a result, `System.ServiceModel.MetadataExporter` includes `UdpTransportBindingElement` in the generation of policy for any binding that includes it."},{"content":"In <ph id=\"ph1\">`IPolicyExportExtension.ExportPolicy`</ph>, we add an assertion for UDP and another assertion if we are in multicast mode.","pos":[15772,15892],"source":"In `IPolicyExportExtension.ExportPolicy`, we add an assertion for UDP and another assertion if we are in multicast mode."},{"content":"This is because multicast mode affects how the communication stack is constructed, and thus must be coordinated between both sides.","pos":[15893,16024]},{"pos":[16524,16814],"content":"Because custom transport binding elements are responsible for handling addressing, the <ph id=\"ph1\">`IPolicyExportExtension`</ph> implementation on the <ph id=\"ph2\">`UdpTransportBindingElement`</ph> must also handle exporting the appropriate WS-Addressing policy assertions to indicate the version of WS-Addressing being used.","source":"Because custom transport binding elements are responsible for handling addressing, the `IPolicyExportExtension` implementation on the `UdpTransportBindingElement` must also handle exporting the appropriate WS-Addressing policy assertions to indicate the version of WS-Addressing being used."},{"pos":[16931,16944],"content":"Policy Import","linkify":"Policy Import","nodes":[{"content":"Policy Import","pos":[0,13]}]},{"content":"To extend the Policy Import system, we must add the following configuration to the configuration file for Svcutil.exe as shown in the Svcutil.exe.config file.","pos":[16948,17106]},{"content":"Then we implement <ph id=\"ph1\">`IPolicyImporterExtension`</ph> from our registered class (<ph id=\"ph2\">`UdpBindingElementImporter`</ph>).","pos":[17451,17552],"source":"Then we implement `IPolicyImporterExtension` from our registered class (`UdpBindingElementImporter`)."},{"content":"In <ph id=\"ph1\">`ImportPolicy()`</ph>, we look through the assertions in our namespace, and process the ones for generating the transport and check whether it is multicast.","pos":[17553,17707],"source":" In `ImportPolicy()`, we look through the assertions in our namespace, and process the ones for generating the transport and check whether it is multicast."},{"content":"We also must remove the assertions we handle from the list of binding assertions.","pos":[17708,17789]},{"content":"Again, when running Svcutil.exe, there are two options for integration:","pos":[17790,17861]},{"content":"Point Svcutil.exe to our configuration file using the /SvcutilConfig:<ph id=\"ph1\">\\&lt;</ph>file&gt;.","pos":[17871,17948],"source":"Point Svcutil.exe to our configuration file using the /SvcutilConfig:\\<file>."},{"content":"Add the configuration section to Svcutil.exe.config in the same directory as Svcutil.exe.","pos":[17958,18047]},{"pos":[18097,18122],"content":"Adding a Standard Binding","linkify":"Adding a Standard Binding","nodes":[{"content":"Adding a Standard Binding","pos":[0,25]}]},{"content":"Our binding element can be used in the following two ways:","pos":[18126,18184]},{"content":"Through a custom binding: A custom binding allows the user to create their own binding based on an arbitrary set of binding elements.","pos":[18194,18327]},{"content":"By using a system-provided binding that includes our binding element.","pos":[18337,18406]},{"content":"WCF provides a number of these system-defined bindings, such as <ph id=\"ph1\">`BasicHttpBinding`</ph>, <ph id=\"ph2\">`NetTcpBinding`</ph>, and <ph id=\"ph3\">`WsHttpBinding`</ph>.","pos":[18407,18528],"source":" WCF provides a number of these system-defined bindings, such as `BasicHttpBinding`, `NetTcpBinding`, and `WsHttpBinding`."},{"content":"Each of these bindings is associated with a well-defined profile.","pos":[18529,18594]},{"content":"The sample implements profile binding in <ph id=\"ph1\">`SampleProfileUdpBinding`</ph>, which derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Binding&gt;</ph>.","pos":[18601,18732],"source":"The sample implements profile binding in `SampleProfileUdpBinding`, which derives from <xref:System.ServiceModel.Channels.Binding>."},{"content":"The <ph id=\"ph1\">`SampleProfileUdpBinding`</ph> contains up to four binding elements within it: <ph id=\"ph2\">`UdpTransportBindingElement`</ph>, <ph id=\"ph3\">`TextMessageEncodingBindingElement CompositeDuplexBindingElement`</ph>, and <ph id=\"ph4\">`ReliableSessionBindingElement`</ph>.","pos":[18733,18944],"source":" The `SampleProfileUdpBinding` contains up to four binding elements within it: `UdpTransportBindingElement`, `TextMessageEncodingBindingElement CompositeDuplexBindingElement`, and `ReliableSessionBindingElement`."},{"pos":[19383,19424],"content":"Adding a Custom Standard Binding Importer","linkify":"Adding a Custom Standard Binding Importer","nodes":[{"content":"Adding a Custom Standard Binding Importer","pos":[0,41]}]},{"content":"Svcutil.exe and the <ph id=\"ph1\">`WsdlImporter`</ph> type, by default, recognizes and imports system-defined bindings.","pos":[19428,19528],"source":"Svcutil.exe and the `WsdlImporter` type, by default, recognizes and imports system-defined bindings."},{"content":"Otherwise, the binding gets imported as a <ph id=\"ph1\">`CustomBinding`</ph> instance.","pos":[19529,19596],"source":" Otherwise, the binding gets imported as a `CustomBinding` instance."},{"content":"To enable Svcutil.exe and the <ph id=\"ph1\">`WsdlImporter`</ph> to import the <ph id=\"ph2\">`SampleProfileUdpBinding`</ph> the <ph id=\"ph3\">`UdpBindingElementImporter`</ph> also acts as a custom standard binding importer.","pos":[19597,19762],"source":" To enable Svcutil.exe and the `WsdlImporter` to import the `SampleProfileUdpBinding` the `UdpBindingElementImporter` also acts as a custom standard binding importer."},{"pos":[19769,20021],"content":"A custom standard binding importer implements the <ph id=\"ph1\">`ImportEndpoint`</ph> method on the <ph id=\"ph2\">`IWsdlImportExtension`</ph> interface to examine the <ph id=\"ph3\">`CustomBinding`</ph> instance imported from metadata to see whether it could have been generated by a specific standard binding.","source":"A custom standard binding importer implements the `ImportEndpoint` method on the `IWsdlImportExtension` interface to examine the `CustomBinding` instance imported from metadata to see whether it could have been generated by a specific standard binding."},{"content":"Generally, implementing a custom standard binding importer involves checking the properties of the imported binding elements to verify that only properties that could have been set by the standard binding have changed and all other properties are their defaults.","pos":[20658,20920]},{"content":"A basic strategy for implementing a standard binding importer is to create an instance of the standard binding, propagate the properties from the binding elements to the standard binding instance that the standard binding supports, and the compare the binding elements from the standard binding with the imported binding elements.","pos":[20921,21251]},{"pos":[21305,21333],"content":"Adding Configuration Support","linkify":"Adding Configuration Support","nodes":[{"content":"Adding Configuration Support","pos":[0,28]}]},{"content":"To expose our transport through configuration, we must implement two configuration sections.","pos":[21337,21429]},{"content":"The first is a <ph id=\"ph1\">`BindingElementExtensionElement`</ph> for <ph id=\"ph2\">`UdpTransportBindingElement`</ph>.","pos":[21430,21511],"source":" The first is a `BindingElementExtensionElement` for `UdpTransportBindingElement`."},{"content":"This is so that <ph id=\"ph1\">`CustomBinding`</ph> implementations can reference our binding element.","pos":[21512,21594],"source":" This is so that `CustomBinding` implementations can reference our binding element."},{"content":"The second is a <ph id=\"ph1\">`Configuration`</ph> for our <ph id=\"ph2\">`SampleProfileUdpBinding`</ph>.","pos":[21595,21661],"source":" The second is a `Configuration` for our `SampleProfileUdpBinding`."},{"pos":[21671,21704],"content":"Binding Element Extension Element","linkify":"Binding Element Extension Element","nodes":[{"content":"Binding Element Extension Element","pos":[0,33]}]},{"content":"The section <ph id=\"ph1\">`UdpTransportElement`</ph> is a <ph id=\"ph2\">`BindingElementExtensionElement`</ph> that exposes <ph id=\"ph3\">`UdpTransportBindingElement`</ph> to the configuration system.","pos":[21708,21850],"source":"The section `UdpTransportElement` is a `BindingElementExtensionElement` that exposes `UdpTransportBindingElement` to the configuration system."},{"content":"With a few basic overrides, we define our configuration section name, the type of our binding element and how to create our binding element.","pos":[21851,21991]},{"content":"We can then register our extension section in a configuration file as shown in the following code.","pos":[21992,22090]},{"content":"The extension can be referenced from custom bindings to use UDP as the transport.","pos":[22422,22503]},{"pos":[22806,22821],"content":"Binding Section","linkify":"Binding Section","nodes":[{"content":"Binding Section","pos":[0,15]}]},{"content":"The section <ph id=\"ph1\">`SampleProfileUdpBindingCollectionElement`</ph> is a <ph id=\"ph2\">`StandardBindingCollectionElement`</ph> that exposes <ph id=\"ph3\">`SampleProfileUdpBinding`</ph> to the configuration system.","pos":[22825,22987],"source":"The section `SampleProfileUdpBindingCollectionElement` is a `StandardBindingCollectionElement` that exposes `SampleProfileUdpBinding` to the configuration system."},{"content":"The bulk of the implementation is delegated to the <ph id=\"ph1\">`SampleProfileUdpBindingConfigurationElement`</ph>, which derives from <ph id=\"ph2\">`StandardBindingElement`</ph>.","pos":[22988,23130],"source":" The bulk of the implementation is delegated to the `SampleProfileUdpBindingConfigurationElement`, which derives from `StandardBindingElement`."},{"content":"The <ph id=\"ph1\">`SampleProfileUdpBindingConfigurationElement`</ph> has properties that correspond to the properties on <ph id=\"ph2\">`SampleProfileUdpBinding`</ph>, and functions to map from the <ph id=\"ph3\">`ConfigurationElement`</ph> binding.","pos":[23131,23321],"source":" The `SampleProfileUdpBindingConfigurationElement` has properties that correspond to the properties on `SampleProfileUdpBinding`, and functions to map from the `ConfigurationElement` binding."},{"content":"Finally, override the <ph id=\"ph1\">`OnApplyConfiguration`</ph> method in our <ph id=\"ph2\">`SampleProfileUdpBinding`</ph>, as shown in the following sample code.","pos":[23322,23446],"source":" Finally, override the `OnApplyConfiguration` method in our `SampleProfileUdpBinding`, as shown in the following sample code."},{"content":"To register this handler with the configuration system, we add the following section to the relevant configuration file.","pos":[24354,24474]},{"content":"It can then be referenced from the serviceModel configuration section.","pos":[24863,24933]},{"pos":[25397,25428],"content":"The UDP Test Service and Client","linkify":"The UDP Test Service and Client","nodes":[{"content":"The UDP Test Service and Client","pos":[0,31]}]},{"content":"Test code for using this sample transport is available in the UdpTestService and UdpTestClient directories.","pos":[25432,25539]},{"content":"The service code consists of two tests—one test sets up bindings and endpoints from code and the other does it through configuration.","pos":[25540,25673]},{"content":"Both tests use two endpoints.","pos":[25674,25703]},{"content":"One endpoint uses the <ph id=\"ph1\">`SampleUdpProfileBinding`</ph> with <bpt id=\"p1\">[</bpt><ph id=\"ph2\">\\&lt;</ph>reliableSession&gt;<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/ms731375(v=vs.90))</ept> set to <ph id=\"ph3\">`true`</ph>.","pos":[25704,25856],"source":" One endpoint uses the `SampleUdpProfileBinding` with [\\<reliableSession>](https://docs.microsoft.com/previous-versions/ms731375(v=vs.90)) set to `true`."},{"content":"The other endpoint uses a custom binding with <ph id=\"ph1\">`UdpTransportBindingElement`</ph>.","pos":[25857,25932],"source":" The other endpoint uses a custom binding with `UdpTransportBindingElement`."},{"content":"This is equivalent to using <ph id=\"ph1\">`SampleUdpProfileBinding`</ph> with <bpt id=\"p1\">[</bpt><ph id=\"ph2\">\\&lt;</ph>reliableSession&gt;<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/ms731375(v=vs.90))</ept> set to <ph id=\"ph3\">`false`</ph>.","pos":[25933,26092],"source":" This is equivalent to using `SampleUdpProfileBinding` with [\\<reliableSession>](https://docs.microsoft.com/previous-versions/ms731375(v=vs.90)) set to `false`."},{"content":"Both tests create a service, add an endpoint for each binding, open the service and then wait for the user to hit ENTER before closing the service.","pos":[26093,26240]},{"content":"When you start the service test application you should see the following output.","pos":[26247,26327]},{"content":"You can then run the test client application against the published endpoints.","pos":[26487,26564]},{"content":"The client test application creates a client for each endpoint and sends five messages to each endpoint.","pos":[26565,26669]},{"content":"The following output is on the client.","pos":[26670,26708]},{"content":"The following is the full output on the service.","pos":[26846,26894]},{"content":"To run the client application against endpoints published using configuration, hit ENTER on the service and then run the test client again.","pos":[27199,27338]},{"content":"You should see the following output on the service.","pos":[27339,27390]},{"content":"Running the client again yields the same as the preceding results.","pos":[27533,27599]},{"content":"To regenerate the client code and configuration using Svcutil.exe, start the service application and then run the following Svcutil.exe from the root directory of the sample.","pos":[27606,27780]},{"pos":[27928,28067],"content":"Note that Svcutil.exe does not generate the binding extension configuration for the <ph id=\"ph1\">`SampleProfileUdpBinding`</ph>, so you must add it manually.","source":"Note that Svcutil.exe does not generate the binding extension configuration for the `SampleProfileUdpBinding`, so you must add it manually."},{"pos":[28527,28563],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[28573,28743],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[28753,28961],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"content":"Refer to the preceding \"The UDP Test Service and Client\" section.","pos":[28971,29036]},{"pos":[29044,29176],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[14,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[0,53]},{"content":"Check for the following (default) directory before continuing.","pos":[54,116]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[29230,29540],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[29541,29591]}]}