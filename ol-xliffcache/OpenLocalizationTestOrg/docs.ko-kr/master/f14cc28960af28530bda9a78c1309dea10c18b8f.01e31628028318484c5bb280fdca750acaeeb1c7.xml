{"content":"---\ntitle: \"Considerations in Overloading Procedures (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"signatures [Visual Basic], ParamArray arguments\"\n  - \"ParamArray keyword [Visual Basic], parameter arrays\"\n  - \"ParamArray keyword [Visual Basic], arguments and signatures\"\n  - \"function overloading [Visual Basic], implicit overloads for ParamArray\"\n  - \"ParamArray keyword [Visual Basic], signatures\"\n  - \"Visual Basic code, procedures\"\n  - \"arguments [Visual Basic], parameter arrays\"\n  - \"procedures [Visual Basic], overloading\"\n  - \"parameters [Visual Basic], lists\"\n  - \"function overloading [Visual Basic], typeless programming\"\n  - \"typeless programming\"\n  - \"function overloading [Visual Basic], restrictions\"\n  - \"arguments [Visual Basic], optional\"\n  - \"optional arguments [Visual Basic], overloading\"\n  - \"signatures [Visual Basic], procedure\"\n  - \"parameter lists [Visual Basic]\"\n  - \"parameter arrays [Visual Basic], overloading arguments\"\n  - \"Visual Basic code, parameter lists\"\n  - \"procedure overloading [Visual Basic], considerations\"\n  - \"Option Explicit statement [Visual Basic]\"\n  - \"restrictions [Visual Basic], overloading procedures\"\n  - \"procedures [Visual Basic], parameter lists\"\nms.assetid: a2001248-10d0-42c5-b0ce-eeedc987319f\n---\n# Considerations in Overloading Procedures (Visual Basic)\nWhen you overload a procedure, you must use a different *signature* for each overloaded version. This usually means each version must specify a different parameter list. For more information, see \"Different Signature\" in [Procedure Overloading](./procedure-overloading.md).  \n  \n You can overload a `Function` procedure with a `Sub` procedure, and vice versa, provided they have different signatures. Two overloads cannot differ only in that one has a return value and the other does not.  \n  \n You can overload a property the same way you overload a procedure, and with the same restrictions. However, you cannot overload a procedure with a property, or vice versa.  \n  \n## Alternatives to Overloaded Versions  \n You sometimes have alternatives to overloaded versions, particularly when the presence of arguments is optional or their number is variable.  \n  \n Keep in mind that optional arguments are not necessarily supported by all languages, and parameter arrays are limited to Visual Basic. If you are writing a procedure that is likely to be called from code written in any of several different languages, overloaded versions offer the greatest flexibility.  \n  \n### Overloads and Optional Arguments  \n When the calling code can optionally supply or omit one or more arguments, you can define multiple overloaded versions or use optional parameters.  \n  \n#### When to Use Overloaded Versions  \n You can consider defining a series of overloaded versions in the following cases:  \n  \n-   The logic in the procedure code is significantly different depending on whether the calling code supplies an optional argument or not.  \n  \n-   The procedure code cannot reliably test whether the calling code has supplied an optional argument. This is the case, for example, if there is no possible candidate for a default value that the calling code could not be expected to supply.  \n  \n#### When to Use Optional Parameters  \n You might prefer one or more optional parameters in the following cases:  \n  \n-   The only required action when the calling code does not supply an optional argument is to set the parameter to a default value. In such a case, the procedure code can be less complicated if you define a single version with one or more `Optional` parameters.  \n  \n For more information, see [Optional Parameters](./optional-parameters.md).  \n  \n### Overloads and ParamArrays  \n When the calling code can pass a variable number of arguments, you can define multiple overloaded versions or use a parameter array.  \n  \n#### When to Use Overloaded Versions  \n You can consider defining a series of overloaded versions in the following cases:  \n  \n-   You know that the calling code never passes more than a small number of values to the parameter array.  \n  \n-   The logic in the procedure code is significantly different depending on how many values the calling code passes.  \n  \n-   The calling code can pass values of different data types.  \n  \n#### When to Use a Parameter Array  \n You are better served by a `ParamArray` parameter in the following cases:  \n  \n-   You are not able to predict how many values the calling code can pass to the parameter array, and it could be a large number.  \n  \n-   The procedure logic lends itself to iterating through all the values the calling code passes, performing essentially the same operations on every value.  \n  \n For more information, see [Parameter Arrays](./parameter-arrays.md).  \n  \n## Implicit Overloads for Optional Parameters  \n A procedure with an [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) parameter is equivalent to two overloaded procedures, one with the optional parameter and one without it. You cannot overload such a procedure with a parameter list corresponding to either of these. The following declarations illustrate this.  \n  \n [!code-vb[VbVbcnProcedures#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#58)]  \n  \n [!code-vb[VbVbcnProcedures#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#60)]  \n  \n [!code-vb[VbVbcnProcedures#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#61)]  \n  \n For a procedure with more than one optional parameter, there is a set of implicit overloads, arrived at by logic similar to that in the preceding example.  \n  \n## Implicit Overloads for a ParamArray Parameter  \n The compiler considers a procedure with a [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) parameter to have an infinite number of overloads, differing from each other in what the calling code passes to the parameter array, as follows:  \n  \n-   One overload for when the calling code does not supply an argument to the `ParamArray`  \n  \n-   One overload for when the calling code supplies a one-dimensional array of the `ParamArray` element type  \n  \n-   For every positive integer, one overload for when the calling code supplies that number of arguments, each of the `ParamArray` element type  \n  \n The following declarations illustrate these implicit overloads.  \n  \n [!code-vb[VbVbcnProcedures#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#68)]  \n  \n [!code-vb[VbVbcnProcedures#70](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#70)]  \n  \n You cannot overload such a procedure with a parameter list that takes a one-dimensional array for the parameter array. However, you can use the signatures of the other implicit overloads. The following declarations illustrate this.  \n  \n [!code-vb[VbVbcnProcedures#71](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#71)]  \n  \n## Typeless Programming as an Alternative to Overloading  \n If you want to allow the calling code to pass different data types to a parameter, an alternative approach is typeless programming. You can set the type checking switch to `Off` with either the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) or the [/optionstrict](../../../../visual-basic/reference/command-line-compiler/optionstrict.md) compiler option. Then you do not have to declare the parameter's data type. However, this approach has the following disadvantages compared to overloading:  \n  \n-   Typeless programming produces less efficient execution code.  \n  \n-   The procedure must test for every data type it anticipates being passed.  \n  \n-   The compiler cannot signal an error if the calling code passes a data type that the procedure does not support.  \n  \n## See also\n\n- [Procedures](./index.md)\n- [Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md)\n- [Troubleshooting Procedures](./troubleshooting-procedures.md)\n- [How to: Define Multiple Versions of a Procedure](./how-to-define-multiple-versions-of-a-procedure.md)\n- [How to: Call an Overloaded Procedure](./how-to-call-an-overloaded-procedure.md)\n- [How to: Overload a Procedure that Takes Optional Parameters](./how-to-overload-a-procedure-that-takes-optional-parameters.md)\n- [How to: Overload a Procedure that Takes an Indefinite Number of Parameters](./how-to-overload-a-procedure-that-takes-an-indefinite-number-of-parameters.md)\n- [Overload Resolution](./overload-resolution.md)\n- [Overloads](../../../../visual-basic/language-reference/modifiers/overloads.md)\n","nodes":[{"pos":[4,1271],"embed":true,"restype":"x-metadata","content":"title: \"Considerations in Overloading Procedures (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"signatures [Visual Basic], ParamArray arguments\"\n  - \"ParamArray keyword [Visual Basic], parameter arrays\"\n  - \"ParamArray keyword [Visual Basic], arguments and signatures\"\n  - \"function overloading [Visual Basic], implicit overloads for ParamArray\"\n  - \"ParamArray keyword [Visual Basic], signatures\"\n  - \"Visual Basic code, procedures\"\n  - \"arguments [Visual Basic], parameter arrays\"\n  - \"procedures [Visual Basic], overloading\"\n  - \"parameters [Visual Basic], lists\"\n  - \"function overloading [Visual Basic], typeless programming\"\n  - \"typeless programming\"\n  - \"function overloading [Visual Basic], restrictions\"\n  - \"arguments [Visual Basic], optional\"\n  - \"optional arguments [Visual Basic], overloading\"\n  - \"signatures [Visual Basic], procedure\"\n  - \"parameter lists [Visual Basic]\"\n  - \"parameter arrays [Visual Basic], overloading arguments\"\n  - \"Visual Basic code, parameter lists\"\n  - \"procedure overloading [Visual Basic], considerations\"\n  - \"Option Explicit statement [Visual Basic]\"\n  - \"restrictions [Visual Basic], overloading procedures\"\n  - \"procedures [Visual Basic], parameter lists\"\nms.assetid: a2001248-10d0-42c5-b0ce-eeedc987319f","nodes":[{"content":"Considerations in Overloading Procedures (Visual Basic)","nodes":[{"pos":[0,55],"content":"Considerations in Overloading Procedures (Visual Basic)","nodes":[{"content":"Considerations in Overloading Procedures (Visual Basic)","pos":[0,55]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[1278,1333],"content":"Considerations in Overloading Procedures (Visual Basic)","linkify":"Considerations in Overloading Procedures (Visual Basic)","nodes":[{"content":"Considerations in Overloading Procedures (Visual Basic)","pos":[0,55]}]},{"content":"When you overload a procedure, you must use a different <bpt id=\"p1\">*</bpt>signature<ept id=\"p1\">*</ept> for each overloaded version.","pos":[1334,1430],"source":"When you overload a procedure, you must use a different *signature* for each overloaded version."},{"content":"This usually means each version must specify a different parameter list.","pos":[1431,1503]},{"content":"For more information, see \"Different Signature\" in <bpt id=\"p1\">[</bpt>Procedure Overloading<ept id=\"p1\">](./procedure-overloading.md)</ept>.","pos":[1504,1607],"source":" For more information, see \"Different Signature\" in [Procedure Overloading](./procedure-overloading.md)."},{"content":"You can overload a <ph id=\"ph1\">`Function`</ph> procedure with a <ph id=\"ph2\">`Sub`</ph> procedure, and vice versa, provided they have different signatures.","pos":[1614,1734],"source":"You can overload a `Function` procedure with a `Sub` procedure, and vice versa, provided they have different signatures."},{"content":"Two overloads cannot differ only in that one has a return value and the other does not.","pos":[1735,1822]},{"content":"You can overload a property the same way you overload a procedure, and with the same restrictions.","pos":[1829,1927]},{"content":"However, you cannot overload a procedure with a property, or vice versa.","pos":[1928,2000]},{"pos":[2009,2044],"content":"Alternatives to Overloaded Versions","linkify":"Alternatives to Overloaded Versions","nodes":[{"content":"Alternatives to Overloaded Versions","pos":[0,35]}]},{"content":"You sometimes have alternatives to overloaded versions, particularly when the presence of arguments is optional or their number is variable.","pos":[2048,2188]},{"content":"Keep in mind that optional arguments are not necessarily supported by all languages, and parameter arrays are limited to Visual Basic.","pos":[2195,2329]},{"content":"If you are writing a procedure that is likely to be called from code written in any of several different languages, overloaded versions offer the greatest flexibility.","pos":[2330,2497]},{"pos":[2507,2539],"content":"Overloads and Optional Arguments","linkify":"Overloads and Optional Arguments","nodes":[{"content":"Overloads and Optional Arguments","pos":[0,32]}]},{"content":"When the calling code can optionally supply or omit one or more arguments, you can define multiple overloaded versions or use optional parameters.","pos":[2543,2689]},{"pos":[2700,2731],"content":"When to Use Overloaded Versions","linkify":"When to Use Overloaded Versions","nodes":[{"content":"When to Use Overloaded Versions","pos":[0,31]}]},{"content":"You can consider defining a series of overloaded versions in the following cases:","pos":[2735,2816]},{"content":"The logic in the procedure code is significantly different depending on whether the calling code supplies an optional argument or not.","pos":[2826,2960]},{"content":"The procedure code cannot reliably test whether the calling code has supplied an optional argument.","pos":[2970,3069]},{"content":"This is the case, for example, if there is no possible candidate for a default value that the calling code could not be expected to supply.","pos":[3070,3209]},{"pos":[3220,3251],"content":"When to Use Optional Parameters","linkify":"When to Use Optional Parameters","nodes":[{"content":"When to Use Optional Parameters","pos":[0,31]}]},{"content":"You might prefer one or more optional parameters in the following cases:","pos":[3255,3327]},{"content":"The only required action when the calling code does not supply an optional argument is to set the parameter to a default value.","pos":[3337,3464]},{"content":"In such a case, the procedure code can be less complicated if you define a single version with one or more <ph id=\"ph1\">`Optional`</ph> parameters.","pos":[3465,3594],"source":" In such a case, the procedure code can be less complicated if you define a single version with one or more `Optional` parameters."},{"pos":[3601,3675],"content":"For more information, see <bpt id=\"p1\">[</bpt>Optional Parameters<ept id=\"p1\">](./optional-parameters.md)</ept>.","source":"For more information, see [Optional Parameters](./optional-parameters.md)."},{"pos":[3685,3710],"content":"Overloads and ParamArrays","linkify":"Overloads and ParamArrays","nodes":[{"content":"Overloads and ParamArrays","pos":[0,25]}]},{"content":"When the calling code can pass a variable number of arguments, you can define multiple overloaded versions or use a parameter array.","pos":[3714,3846]},{"pos":[3857,3888],"content":"When to Use Overloaded Versions","linkify":"When to Use Overloaded Versions","nodes":[{"content":"When to Use Overloaded Versions","pos":[0,31]}]},{"content":"You can consider defining a series of overloaded versions in the following cases:","pos":[3892,3973]},{"content":"You know that the calling code never passes more than a small number of values to the parameter array.","pos":[3983,4085]},{"content":"The logic in the procedure code is significantly different depending on how many values the calling code passes.","pos":[4095,4207]},{"content":"The calling code can pass values of different data types.","pos":[4217,4274]},{"pos":[4285,4314],"content":"When to Use a Parameter Array","linkify":"When to Use a Parameter Array","nodes":[{"content":"When to Use a Parameter Array","pos":[0,29]}]},{"pos":[4318,4391],"content":"You are better served by a <ph id=\"ph1\">`ParamArray`</ph> parameter in the following cases:","source":"You are better served by a `ParamArray` parameter in the following cases:"},{"content":"You are not able to predict how many values the calling code can pass to the parameter array, and it could be a large number.","pos":[4401,4526]},{"content":"The procedure logic lends itself to iterating through all the values the calling code passes, performing essentially the same operations on every value.","pos":[4536,4688]},{"pos":[4695,4763],"content":"For more information, see <bpt id=\"p1\">[</bpt>Parameter Arrays<ept id=\"p1\">](./parameter-arrays.md)</ept>.","source":"For more information, see [Parameter Arrays](./parameter-arrays.md)."},{"pos":[4772,4814],"content":"Implicit Overloads for Optional Parameters","linkify":"Implicit Overloads for Optional Parameters","nodes":[{"content":"Implicit Overloads for Optional Parameters","pos":[0,42]}]},{"content":"A procedure with an <bpt id=\"p1\">[</bpt>Optional<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/optional.md)</ept> parameter is equivalent to two overloaded procedures, one with the optional parameter and one without it.","pos":[4818,5021],"source":"A procedure with an [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) parameter is equivalent to two overloaded procedures, one with the optional parameter and one without it."},{"content":"You cannot overload such a procedure with a parameter list corresponding to either of these.","pos":[5022,5114]},{"content":"The following declarations illustrate this.","pos":[5115,5158]},{"content":"For a procedure with more than one optional parameter, there is a set of implicit overloads, arrived at by logic similar to that in the preceding example.","pos":[5537,5691]},{"pos":[5700,5745],"content":"Implicit Overloads for a ParamArray Parameter","linkify":"Implicit Overloads for a ParamArray Parameter","nodes":[{"content":"Implicit Overloads for a ParamArray Parameter","pos":[0,45]}]},{"pos":[5749,6017],"content":"The compiler considers a procedure with a <bpt id=\"p1\">[</bpt>ParamArray<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/paramarray.md)</ept> parameter to have an infinite number of overloads, differing from each other in what the calling code passes to the parameter array, as follows:","source":"The compiler considers a procedure with a [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) parameter to have an infinite number of overloads, differing from each other in what the calling code passes to the parameter array, as follows:"},{"pos":[6027,6113],"content":"One overload for when the calling code does not supply an argument to the <ph id=\"ph1\">`ParamArray`</ph>","source":"One overload for when the calling code does not supply an argument to the `ParamArray`"},{"pos":[6123,6227],"content":"One overload for when the calling code supplies a one-dimensional array of the <ph id=\"ph1\">`ParamArray`</ph> element type","source":"One overload for when the calling code supplies a one-dimensional array of the `ParamArray` element type"},{"pos":[6237,6376],"content":"For every positive integer, one overload for when the calling code supplies that number of arguments, each of the <ph id=\"ph1\">`ParamArray`</ph> element type","source":"For every positive integer, one overload for when the calling code supplies that number of arguments, each of the `ParamArray` element type"},{"content":"The following declarations illustrate these implicit overloads.","pos":[6383,6446]},{"content":"You cannot overload such a procedure with a parameter list that takes a one-dimensional array for the parameter array.","pos":[6701,6819]},{"content":"However, you can use the signatures of the other implicit overloads.","pos":[6820,6888]},{"content":"The following declarations illustrate this.","pos":[6889,6932]},{"pos":[7065,7118],"content":"Typeless Programming as an Alternative to Overloading","linkify":"Typeless Programming as an Alternative to Overloading","nodes":[{"content":"Typeless Programming as an Alternative to Overloading","pos":[0,53]}]},{"content":"If you want to allow the calling code to pass different data types to a parameter, an alternative approach is typeless programming.","pos":[7122,7253]},{"content":"You can set the type checking switch to <ph id=\"ph1\">`Off`</ph> with either the <bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept> or the <bpt id=\"p2\">[</bpt>/optionstrict<ept id=\"p2\">](../../../../visual-basic/reference/command-line-compiler/optionstrict.md)</ept> compiler option.","pos":[7254,7538],"source":" You can set the type checking switch to `Off` with either the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) or the [/optionstrict](../../../../visual-basic/reference/command-line-compiler/optionstrict.md) compiler option."},{"content":"Then you do not have to declare the parameter's data type.","pos":[7539,7597]},{"content":"However, this approach has the following disadvantages compared to overloading:","pos":[7598,7677]},{"content":"Typeless programming produces less efficient execution code.","pos":[7687,7747]},{"content":"The procedure must test for every data type it anticipates being passed.","pos":[7757,7829]},{"content":"The compiler cannot signal an error if the calling code passes a data type that the procedure does not support.","pos":[7839,7950]},{"pos":[7959,7967],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7971,7995],"content":"<bpt id=\"p1\">[</bpt>Procedures<ept id=\"p1\">](./index.md)</ept>","source":"[Procedures](./index.md)"},{"pos":[7998,8075],"content":"<bpt id=\"p1\">[</bpt>Procedure Parameters and Arguments<ept id=\"p1\">](./procedure-parameters-and-arguments.md)</ept>","source":"[Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md)"},{"pos":[8078,8139],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Procedures<ept id=\"p1\">](./troubleshooting-procedures.md)</ept>","source":"[Troubleshooting Procedures](./troubleshooting-procedures.md)"},{"pos":[8142,8244],"content":"<bpt id=\"p1\">[</bpt>How to: Define Multiple Versions of a Procedure<ept id=\"p1\">](./how-to-define-multiple-versions-of-a-procedure.md)</ept>","source":"[How to: Define Multiple Versions of a Procedure](./how-to-define-multiple-versions-of-a-procedure.md)"},{"pos":[8247,8327],"content":"<bpt id=\"p1\">[</bpt>How to: Call an Overloaded Procedure<ept id=\"p1\">](./how-to-call-an-overloaded-procedure.md)</ept>","source":"[How to: Call an Overloaded Procedure](./how-to-call-an-overloaded-procedure.md)"},{"pos":[8330,8456],"content":"<bpt id=\"p1\">[</bpt>How to: Overload a Procedure that Takes Optional Parameters<ept id=\"p1\">](./how-to-overload-a-procedure-that-takes-optional-parameters.md)</ept>","source":"[How to: Overload a Procedure that Takes Optional Parameters](./how-to-overload-a-procedure-that-takes-optional-parameters.md)"},{"pos":[8459,8615],"content":"<bpt id=\"p1\">[</bpt>How to: Overload a Procedure that Takes an Indefinite Number of Parameters<ept id=\"p1\">](./how-to-overload-a-procedure-that-takes-an-indefinite-number-of-parameters.md)</ept>","source":"[How to: Overload a Procedure that Takes an Indefinite Number of Parameters](./how-to-overload-a-procedure-that-takes-an-indefinite-number-of-parameters.md)"},{"pos":[8618,8665],"content":"<bpt id=\"p1\">[</bpt>Overload Resolution<ept id=\"p1\">](./overload-resolution.md)</ept>","source":"[Overload Resolution](./overload-resolution.md)"},{"pos":[8668,8747],"content":"<bpt id=\"p1\">[</bpt>Overloads<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/overloads.md)</ept>","source":"[Overloads](../../../../visual-basic/language-reference/modifiers/overloads.md)"}]}