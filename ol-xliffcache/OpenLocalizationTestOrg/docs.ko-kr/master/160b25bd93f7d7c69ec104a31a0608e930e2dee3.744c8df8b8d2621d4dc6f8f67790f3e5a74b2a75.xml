{"content":"---\ntitle: \"group clause - C# Reference\"\nms.custom: seodec18\n\nms.date: 07/20/2015\nf1_keywords: \n  - \"group\"\n  - \"group_CSharpKeyword\"\nhelpviewer_keywords: \n  - \"group keyword [C#]\"\n  - \"group clause [C#]\"\nms.assetid: c817242e-b12c-4baa-a57e-73ee138f34d1\n---\n# group clause (C# Reference)\n\nThe `group` clause returns a sequence of <xref:System.Linq.IGrouping%602> objects that contain zero or more items that match the key value for the group. For example, you can group a sequence of strings according to the first letter in each string. In this case, the first letter is the key and has a type [char](char.md), and is stored in the `Key` property of each <xref:System.Linq.IGrouping%602> object. The compiler infers the type of the key.\n\nYou can end a query expression with a `group` clause, as shown in the following example:\n\n[!code-csharp[cscsrefQueryKeywords#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#10)]\n\nIf you want to perform additional query operations on each group, you can specify a temporary identifier by using the [into](into.md) contextual keyword. When you use `into`, you must continue with the query, and eventually end it with either a `select` statement or another `group` clause, as shown in the following excerpt:\n\n[!code-csharp[cscsrefQueryKeywords#11](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#11)]\n\nMore complete examples of the use of `group` with and without `into` are provided in the Example section of this article.\n\n## Enumerating the results of a group query\n\nBecause the <xref:System.Linq.IGrouping%602> objects produced by a `group` query are essentially a list of lists, you must use a nested [foreach](foreach-in.md) loop to access the items in each group. The outer loop iterates over the group keys, and the inner loop iterates over each item in the group itself. A group may have a key but no elements. The following is the `foreach` loop that executes the query in the previous code examples:\n\n[!code-csharp[cscsrefQueryKeywords#12](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#12)]\n\n## Key types\n\nGroup keys can be any type, such as a string, a built-in numeric type, or a user-defined named type or anonymous type.\n\n### Grouping by string\n\nThe previous code examples used a `char`. A string key could easily have been specified instead, for example the complete last name:\n\n[!code-csharp[cscsrefQueryKeywords#13](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#13)]\n\n### Grouping by bool\n\nThe following example shows the use of a bool value for a key to divide the results into two groups. Note that the value is produced by a sub-expression in the `group` clause.\n\n[!code-csharp[cscsrefQueryKeywords#14](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#14)]\n\n### Grouping by numeric range\n\nThe next example uses an expression to create numeric group keys that represent a percentile range. Note the use of [let](let-clause.md) as a convenient location to store a method call result, so that you don't have to call the method two times in the `group` clause. For more information about how to safely use methods in query expressions, see [How to: Handle Exceptions in Query Expressions](../../programming-guide/linq-query-expressions/how-to-handle-exceptions-in-query-expressions.md).\n\n[!code-csharp[cscsrefQueryKeywords#15](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#15)]\n\n### Grouping by composite keys\n\nUse a composite key when you want to group elements according to more than one key. You create a composite key by using an anonymous type or a named type to hold the key element. In the following example, assume that a class `Person` has been declared with members named `surname` and `city`. The `group` clause causes a separate group to be created for each set of persons with the same last name and the same city.\n\n```csharp\ngroup person by new {name = person.surname, city = person.city};\n```\n\nUse a named type if you must pass the query variable to another method. Create a special class using auto-implemented properties for the keys, and then override the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods. You can also use a struct, in which case you do not strictly have to override those methods. For more information see [How to: Implement a Lightweight Class with Auto-Implemented Properties](../../programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties.md) and [How to: Query for Duplicate Files in a Directory Tree](../../programming-guide/concepts/linq/how-to-query-for-duplicate-files-in-a-directory-tree-linq.md). The latter article has a code example that demonstrates how to use a composite key with a named type.\n\n## Example\n\nThe following example shows the standard pattern for ordering source data into groups when no additional query logic is applied to the groups. This is called a grouping without a continuation. The elements in an array of strings are grouped according to their first letter. The result of the query is an <xref:System.Linq.IGrouping%602> type that contains a public `Key` property of type `char` and an <xref:System.Collections.Generic.IEnumerable%601> collection that contains each item in the grouping.\n\nThe result of a `group` clause is a sequence of sequences. Therefore, to access the individual elements within each returned group, use a nested `foreach` loop inside the loop that iterates the group keys, as shown in the following example.\n\n[!code-csharp[cscsrefQueryKeywords#16](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#16)]\n\n## Example\n\nThis example shows how to perform additional logic on the groups after you have created them, by using a *continuation* with `into`. For more information, see [into](into.md). The following example queries each group to select only those whose key value is a vowel.\n\n[!code-csharp[cscsrefQueryKeywords#17](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Group.cs#17)]\n\n## Remarks\n\nAt compile time, `group` clauses are translated into calls to the <xref:System.Linq.Enumerable.GroupBy%2A> method.\n\n## See also\n\n- <xref:System.Linq.IGrouping%602>\n- <xref:System.Linq.Enumerable.GroupBy%2A>\n- <xref:System.Linq.Enumerable.ThenBy%2A>\n- <xref:System.Linq.Enumerable.ThenByDescending%2A>\n- [Query Keywords](query-keywords.md)\n- [Language Integrated Query (LINQ)](../../linq/index.md)\n- [Create a nested group](../../linq/create-a-nested-group.md)\n- [Group query results](../../linq/group-query-results.md)\n- [Perform a subquery on a grouping operation](../../linq/perform-a-subquery-on-a-grouping-operation.md)\n","nodes":[{"pos":[4,253],"embed":true,"restype":"x-metadata","content":"title: \"group clause - C# Reference\"\nms.custom: seodec18\n\nms.date: 07/20/2015\nf1_keywords: \n  - \"group\"\n  - \"group_CSharpKeyword\"\nhelpviewer_keywords: \n  - \"group keyword [C#]\"\n  - \"group clause [C#]\"\nms.assetid: c817242e-b12c-4baa-a57e-73ee138f34d1","nodes":[{"content":"group clause - C# Reference","nodes":[{"pos":[0,27],"content":"group clause - C# Reference","nodes":[{"content":"group clause - C# Reference","pos":[0,27]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[260,287],"content":"group clause (C# Reference)","linkify":"group clause (C# Reference)","nodes":[{"content":"group clause (C# Reference)","pos":[0,27]}]},{"content":"The <ph id=\"ph1\">`group`</ph> clause returns a sequence of <ph id=\"ph2\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> objects that contain zero or more items that match the key value for the group.","pos":[289,442],"source":"The `group` clause returns a sequence of <xref:System.Linq.IGrouping%602> objects that contain zero or more items that match the key value for the group."},{"content":"For example, you can group a sequence of strings according to the first letter in each string.","pos":[443,537]},{"content":"In this case, the first letter is the key and has a type <bpt id=\"p1\">[</bpt>char<ept id=\"p1\">](char.md)</ept>, and is stored in the <ph id=\"ph1\">`Key`</ph> property of each <ph id=\"ph2\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> object.","pos":[538,696],"source":" In this case, the first letter is the key and has a type [char](char.md), and is stored in the `Key` property of each <xref:System.Linq.IGrouping%602> object."},{"content":"The compiler infers the type of the key.","pos":[697,737]},{"pos":[739,827],"content":"You can end a query expression with a <ph id=\"ph1\">`group`</ph> clause, as shown in the following example:","source":"You can end a query expression with a `group` clause, as shown in the following example:"},{"content":"If you want to perform additional query operations on each group, you can specify a temporary identifier by using the <bpt id=\"p1\">[</bpt>into<ept id=\"p1\">](into.md)</ept> contextual keyword.","pos":[954,1107],"source":"If you want to perform additional query operations on each group, you can specify a temporary identifier by using the [into](into.md) contextual keyword."},{"content":"When you use <ph id=\"ph1\">`into`</ph>, you must continue with the query, and eventually end it with either a <ph id=\"ph2\">`select`</ph> statement or another <ph id=\"ph3\">`group`</ph> clause, as shown in the following excerpt:","pos":[1108,1279],"source":" When you use `into`, you must continue with the query, and eventually end it with either a `select` statement or another `group` clause, as shown in the following excerpt:"},{"pos":[1406,1527],"content":"More complete examples of the use of <ph id=\"ph1\">`group`</ph> with and without <ph id=\"ph2\">`into`</ph> are provided in the Example section of this article.","source":"More complete examples of the use of `group` with and without `into` are provided in the Example section of this article."},{"pos":[1532,1572],"content":"Enumerating the results of a group query","linkify":"Enumerating the results of a group query","nodes":[{"content":"Enumerating the results of a group query","pos":[0,40]}]},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> objects produced by a <ph id=\"ph2\">`group`</ph> query are essentially a list of lists, you must use a nested <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](foreach-in.md)</ept> loop to access the items in each group.","pos":[1574,1774],"source":"Because the <xref:System.Linq.IGrouping%602> objects produced by a `group` query are essentially a list of lists, you must use a nested [foreach](foreach-in.md) loop to access the items in each group."},{"content":"The outer loop iterates over the group keys, and the inner loop iterates over each item in the group itself.","pos":[1775,1883]},{"content":"A group may have a key but no elements.","pos":[1884,1923]},{"content":"The following is the <ph id=\"ph1\">`foreach`</ph> loop that executes the query in the previous code examples:","pos":[1924,2014],"source":" The following is the `foreach` loop that executes the query in the previous code examples:"},{"pos":[2144,2153],"content":"Key types","linkify":"Key types","nodes":[{"content":"Key types","pos":[0,9]}]},{"content":"Group keys can be any type, such as a string, a built-in numeric type, or a user-defined named type or anonymous type.","pos":[2155,2273]},{"pos":[2279,2297],"content":"Grouping by string","linkify":"Grouping by string","nodes":[{"content":"Grouping by string","pos":[0,18]}]},{"content":"The previous code examples used a <ph id=\"ph1\">`char`</ph>.","pos":[2299,2340],"source":"The previous code examples used a `char`."},{"content":"A string key could easily have been specified instead, for example the complete last name:","pos":[2341,2431]},{"pos":[2562,2578],"content":"Grouping by bool","linkify":"Grouping by bool","nodes":[{"content":"Grouping by bool","pos":[0,16]}]},{"content":"The following example shows the use of a bool value for a key to divide the results into two groups.","pos":[2580,2680]},{"content":"Note that the value is produced by a sub-expression in the <ph id=\"ph1\">`group`</ph> clause.","pos":[2681,2755],"source":" Note that the value is produced by a sub-expression in the `group` clause."},{"pos":[2886,2911],"content":"Grouping by numeric range","linkify":"Grouping by numeric range","nodes":[{"content":"Grouping by numeric range","pos":[0,25]}]},{"content":"The next example uses an expression to create numeric group keys that represent a percentile range.","pos":[2913,3012]},{"content":"Note the use of <bpt id=\"p1\">[</bpt>let<ept id=\"p1\">](let-clause.md)</ept> as a convenient location to store a method call result, so that you don't have to call the method two times in the <ph id=\"ph1\">`group`</ph> clause.","pos":[3013,3180],"source":" Note the use of [let](let-clause.md) as a convenient location to store a method call result, so that you don't have to call the method two times in the `group` clause."},{"content":"For more information about how to safely use methods in query expressions, see <bpt id=\"p1\">[</bpt>How to: Handle Exceptions in Query Expressions<ept id=\"p1\">](../../programming-guide/linq-query-expressions/how-to-handle-exceptions-in-query-expressions.md)</ept>.","pos":[3181,3406],"source":" For more information about how to safely use methods in query expressions, see [How to: Handle Exceptions in Query Expressions](../../programming-guide/linq-query-expressions/how-to-handle-exceptions-in-query-expressions.md)."},{"pos":[3537,3563],"content":"Grouping by composite keys","linkify":"Grouping by composite keys","nodes":[{"content":"Grouping by composite keys","pos":[0,26]}]},{"content":"Use a composite key when you want to group elements according to more than one key.","pos":[3565,3648]},{"content":"You create a composite key by using an anonymous type or a named type to hold the key element.","pos":[3649,3743]},{"content":"In the following example, assume that a class <ph id=\"ph1\">`Person`</ph> has been declared with members named <ph id=\"ph2\">`surname`</ph> and <ph id=\"ph3\">`city`</ph>.","pos":[3744,3857],"source":" In the following example, assume that a class `Person` has been declared with members named `surname` and `city`."},{"content":"The <ph id=\"ph1\">`group`</ph> clause causes a separate group to be created for each set of persons with the same last name and the same city.","pos":[3858,3981],"source":" The `group` clause causes a separate group to be created for each set of persons with the same last name and the same city."},{"content":"Use a named type if you must pass the query variable to another method.","pos":[4063,4134]},{"content":"Create a special class using auto-implemented properties for the keys, and then override the <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods.","pos":[4135,4307],"source":" Create a special class using auto-implemented properties for the keys, and then override the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods."},{"content":"You can also use a struct, in which case you do not strictly have to override those methods.","pos":[4308,4400]},{"content":"For more information see <bpt id=\"p1\">[</bpt>How to: Implement a Lightweight Class with Auto-Implemented Properties<ept id=\"p1\">](../../programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Query for Duplicate Files in a Directory Tree<ept id=\"p2\">](../../programming-guide/concepts/linq/how-to-query-for-duplicate-files-in-a-directory-tree-linq.md)</ept>.","pos":[4401,4777],"source":" For more information see [How to: Implement a Lightweight Class with Auto-Implemented Properties](../../programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties.md) and [How to: Query for Duplicate Files in a Directory Tree](../../programming-guide/concepts/linq/how-to-query-for-duplicate-files-in-a-directory-tree-linq.md)."},{"content":"The latter article has a code example that demonstrates how to use a composite key with a named type.","pos":[4778,4879]},{"pos":[4884,4891],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows the standard pattern for ordering source data into groups when no additional query logic is applied to the groups.","pos":[4893,5035]},{"content":"This is called a grouping without a continuation.","pos":[5036,5085]},{"content":"The elements in an array of strings are grouped according to their first letter.","pos":[5086,5166]},{"content":"The result of the query is an <ph id=\"ph1\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> type that contains a public <ph id=\"ph2\">`Key`</ph> property of type <ph id=\"ph3\">`char`</ph> and an <ph id=\"ph4\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection that contains each item in the grouping.","pos":[5167,5396],"source":" The result of the query is an <xref:System.Linq.IGrouping%602> type that contains a public `Key` property of type `char` and an <xref:System.Collections.Generic.IEnumerable%601> collection that contains each item in the grouping."},{"content":"The result of a <ph id=\"ph1\">`group`</ph> clause is a sequence of sequences.","pos":[5398,5456],"source":"The result of a `group` clause is a sequence of sequences."},{"content":"Therefore, to access the individual elements within each returned group, use a nested <ph id=\"ph1\">`foreach`</ph> loop inside the loop that iterates the group keys, as shown in the following example.","pos":[5457,5638],"source":" Therefore, to access the individual elements within each returned group, use a nested `foreach` loop inside the loop that iterates the group keys, as shown in the following example."},{"pos":[5768,5775],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example shows how to perform additional logic on the groups after you have created them, by using a <bpt id=\"p1\">*</bpt>continuation<ept id=\"p1\">*</ept> with <ph id=\"ph1\">`into`</ph>.","pos":[5777,5909],"source":"This example shows how to perform additional logic on the groups after you have created them, by using a *continuation* with `into`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>into<ept id=\"p1\">](into.md)</ept>.","pos":[5910,5952],"source":" For more information, see [into](into.md)."},{"content":"The following example queries each group to select only those whose key value is a vowel.","pos":[5953,6042]},{"pos":[6172,6179],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6181,6295],"content":"At compile time, <ph id=\"ph1\">`group`</ph> clauses are translated into calls to the <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.GroupBy%2A&gt;</ph> method.","source":"At compile time, `group` clauses are translated into calls to the <xref:System.Linq.Enumerable.GroupBy%2A> method."},{"pos":[6300,6308],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6484,6519],"content":"<bpt id=\"p1\">[</bpt>Query Keywords<ept id=\"p1\">](query-keywords.md)</ept>","source":"[Query Keywords](query-keywords.md)"},{"pos":[6522,6577],"content":"<bpt id=\"p1\">[</bpt>Language Integrated Query (LINQ)<ept id=\"p1\">](../../linq/index.md)</ept>","source":"[Language Integrated Query (LINQ)](../../linq/index.md)"},{"pos":[6580,6640],"content":"<bpt id=\"p1\">[</bpt>Create a nested group<ept id=\"p1\">](../../linq/create-a-nested-group.md)</ept>","source":"[Create a nested group](../../linq/create-a-nested-group.md)"},{"pos":[6643,6699],"content":"<bpt id=\"p1\">[</bpt>Group query results<ept id=\"p1\">](../../linq/group-query-results.md)</ept>","source":"[Group query results](../../linq/group-query-results.md)"},{"pos":[6702,6804],"content":"<bpt id=\"p1\">[</bpt>Perform a subquery on a grouping operation<ept id=\"p1\">](../../linq/perform-a-subquery-on-a-grouping-operation.md)</ept>","source":"[Perform a subquery on a grouping operation](../../linq/perform-a-subquery-on-a-grouping-operation.md)"}]}