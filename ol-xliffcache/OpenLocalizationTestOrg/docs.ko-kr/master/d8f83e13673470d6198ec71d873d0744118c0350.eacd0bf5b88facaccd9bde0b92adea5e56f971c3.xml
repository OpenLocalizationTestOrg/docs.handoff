{"content":"---\ntitle: \"How to: Retrieve the Value of an Element (LINQ to XML) (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 4228c007-07c9-4cf2-a45b-e7074c109581\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\n---\n# How to: Retrieve the Value of an Element (LINQ to XML) (C#)\nThis topic shows how to get the value of elements. There are two main ways to do this. One way is to cast an <xref:System.Xml.Linq.XElement> or an <xref:System.Xml.Linq.XAttribute> to the desired type. The explicit conversion operator then converts the contents of the element or attribute to the specified type and assigns it to your variable. Alternatively, you can use the <xref:System.Xml.Linq.XElement.Value%2A?displayProperty=fullName> property or the <xref:System.Xml.Linq.XAttribute.Value%2A?displayProperty=fullName> property.  \n  \n With C#, however, casting is generally the better approach. If you cast the element or attribute to a nullable type, the code is simpler to write when retrieving the value of an element (or attribute) that might or might not exist. The last example in this topic demonstrates this. However, you cannot set the contents of an element through casting, as you can through <xref:System.Xml.Linq.XElement.Value%2A?displayProperty=fullName> property.  \n  \n## Example  \n To retrieve the value of an element, you just cast the <xref:System.Xml.Linq.XElement> object to your desired type. You can always cast an element to a string, as follows:  \n  \n```csharp  \nXElement e = new XElement(\"StringElement\", \"abcde\");  \nConsole.WriteLine(e);  \nConsole.WriteLine(\"Value of e:\" + (string)e);  \n```  \n  \n This example produces the following output:  \n  \n```  \n<StringElement>abcde</StringElement>  \nValue of e:abcde  \n```  \n  \n## Example  \n You can also cast elements to types other than string. For example, if you have an element that contains an integer, you can cast it to `int`, as shown in the following code:  \n  \n```csharp  \nXElement e = new XElement(\"Age\", \"44\");  \nConsole.WriteLine(e);  \nConsole.WriteLine(\"Value of e:\" + (int)e);  \n```  \n  \n This example produces the following output:  \n  \n```  \n<Age>44</Age>  \nValue of e:44  \n```  \n  \n [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] provides explicit cast operators for the following data types: `string`, `bool`, `bool?`, `int`, `int?`, `uint`, `uint?`, `long`, `long?`, `ulong`, `ulong?`, `float`, `float?`, `double`, `double?`, `decimal`, `decimal?`, `DateTime`, `DateTime?`, `TimeSpan`, `TimeSpan?`, `GUID`, and `GUID?`.  \n  \n [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] provides the same cast operators for <xref:System.Xml.Linq.XAttribute> objects.  \n  \n## Example  \n You can use the <xref:System.Xml.Linq.XElement.Value%2A> property to retrieve the contents of an element:  \n  \n```csharp  \nXElement e = new XElement(\"StringElement\", \"abcde\");   \nConsole.WriteLine(e);  \nConsole.WriteLine(\"Value of e:\" + e.Value);  \n```  \n  \n This example produces the following output:  \n  \n```  \n<StringElement>abcde</StringElement>  \nValue of e:abcde  \n```  \n  \n## Example  \n Sometimes you try to retrieve the value of an element even though you are not sure it exists. In this case, when you assign the casted element to a nullable type (either `string` or one of the nullable types in the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]), if the element does not exist the assigned variable is just set to `null`. The following code shows that when the element might or might not exist, it is easier to use casting than to use the <xref:System.Xml.Linq.XElement.Value%2A> property.  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"Child1\", \"child 1 content\"),  \n    new XElement(\"Child2\", \"2\")  \n);  \n  \n// The following assignments show why it is easier to use  \n// casting when the element might or might not exist.  \n  \nstring c1 = (string)root.Element(\"Child1\");  \nConsole.WriteLine(\"c1:{0}\", c1 == null ? \"element does not exist\" : c1);  \n  \nint? c2 = (int?)root.Element(\"Child2\");  \nConsole.WriteLine(\"c2:{0}\", c2 == null ? \"element does not exist\" : c2.ToString());  \n  \nstring c3 = (string)root.Element(\"Child3\");  \nConsole.WriteLine(\"c3:{0}\", c3 == null ? \"element does not exist\" : c3);  \n  \nint? c4 = (int?)root.Element(\"Child4\");  \nConsole.WriteLine(\"c4:{0}\", c4 == null ? \"element does not exist\" : c4.ToString());  \n  \nConsole.WriteLine();  \n  \n// The following assignments show the required code when using  \n// the Value property when the element might or might not exist.  \n// Notice that this is more difficult than the casting approach.  \n  \nXElement e1 = root.Element(\"Child1\");  \nstring v1;  \nif (e1 == null)  \n    v1 = null;  \nelse  \n    v1 = e1.Value;  \nConsole.WriteLine(\"v1:{0}\", v1 == null ? \"element does not exist\" : v1);  \n  \nXElement e2 = root.Element(\"Child2\");  \nint? v2;  \nif (e2 == null)  \n    v2 = null;  \nelse  \n    v2 = Int32.Parse(e2.Value);  \nConsole.WriteLine(\"v2:{0}\", v2 == null ? \"element does not exist\" : v2.ToString());  \n  \nXElement e3 = root.Element(\"Child3\");  \nstring v3;  \nif (e3 == null)  \n    v3 = null;  \nelse  \n    v3 = e3.Value;  \nConsole.WriteLine(\"v3:{0}\", v3 == null ? \"element does not exist\" : v3);  \n  \nXElement e4 = root.Element(\"Child4\");  \nint? v4;  \nif (e4 == null)  \n    v4 = null;  \nelse  \n    v4 = Int32.Parse(e4.Value);  \nConsole.WriteLine(\"v4:{0}\", v4 == null ? \"element does not exist\" : v4.ToString());  \n```  \n  \n This code produces the following output:  \n  \n```  \nc1:child 1 content  \nc2:2  \nc3:element does not exist  \nc4:element does not exist  \n  \nv1:child 1 content  \nv2:2  \nv3:element does not exist  \nv4:element does not exist  \n```  \n  \n In general, you can write simpler code when using casting to retrieve the contents of elements and attributes.  \n  \n## See Also  \n [LINQ to XML Axes (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-xml-axes.md)","nodes":[{"pos":[4,366],"embed":true,"restype":"x-metadata","content":"title: \"How to: Retrieve the Value of an Element (LINQ to XML) (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 4228c007-07c9-4cf2-a45b-e7074c109581\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n","nodes":[{"content":"How to: Retrieve the Value of an Element (LINQ to XML) (C#) | Microsoft Docs","nodes":[{"pos":[0,76],"content":"How to: Retrieve the Value of an Element (LINQ to XML) (C#) | Microsoft Docs","nodes":[{"content":"How to: Retrieve the Value of an Element (LINQ to XML) (C#) | Microsoft Docs","pos":[0,76]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[373,432],"content":"How to: Retrieve the Value of an Element (LINQ to XML) (C#)","linkify":"How to: Retrieve the Value of an Element (LINQ to XML) (C#)","nodes":[{"content":"How to: Retrieve the Value of an Element (LINQ to XML) (C#)","pos":[0,59]}]},{"content":"This topic shows how to get the value of elements.","pos":[433,483]},{"content":"There are two main ways to do this.","pos":[484,519]},{"content":"One way is to cast an <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement&gt;</ph> or an <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> to the desired type.","pos":[520,634],"source":" One way is to cast an <xref:System.Xml.Linq.XElement> or an <xref:System.Xml.Linq.XAttribute> to the desired type."},{"content":"The explicit conversion operator then converts the contents of the element or attribute to the specified type and assigns it to your variable.","pos":[635,777]},{"content":"Alternatively, you can use the <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement.Value%2A?displayProperty=fullName&gt;</ph> property or the <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XAttribute.Value%2A?displayProperty=fullName&gt;</ph> property.","pos":[778,968],"source":" Alternatively, you can use the <xref:System.Xml.Linq.XElement.Value%2A?displayProperty=fullName> property or the <xref:System.Xml.Linq.XAttribute.Value%2A?displayProperty=fullName> property."},{"content":"With C#, however, casting is generally the better approach.","pos":[975,1034]},{"content":"If you cast the element or attribute to a nullable type, the code is simpler to write when retrieving the value of an element (or attribute) that might or might not exist.","pos":[1035,1206]},{"content":"The last example in this topic demonstrates this.","pos":[1207,1256]},{"content":"However, you cannot set the contents of an element through casting, as you can through <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement.Value%2A?displayProperty=fullName&gt;</ph> property.","pos":[1257,1419],"source":" However, you cannot set the contents of an element through casting, as you can through <xref:System.Xml.Linq.XElement.Value%2A?displayProperty=fullName> property."},{"pos":[1428,1435],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"To retrieve the value of an element, you just cast the <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement&gt;</ph> object to your desired type.","pos":[1439,1554],"source":"To retrieve the value of an element, you just cast the <xref:System.Xml.Linq.XElement> object to your desired type."},{"content":"You can always cast an element to a string, as follows:","pos":[1555,1610]},{"content":"This example produces the following output:","pos":[1765,1808]},{"pos":[1890,1897],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"You can also cast elements to types other than string.","pos":[1901,1955]},{"content":"For example, if you have an element that contains an integer, you can cast it to <ph id=\"ph1\">`int`</ph>, as shown in the following code:","pos":[1956,2075],"source":" For example, if you have an element that contains an integer, you can cast it to `int`, as shown in the following code:"},{"content":"This example produces the following output:","pos":[2214,2257]},{"pos":[2311,2705],"content":"<ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> provides explicit cast operators for the following data types: <ph id=\"ph2\">`string`</ph>, <ph id=\"ph3\">`bool`</ph>, <ph id=\"ph4\">`bool?`</ph>, <ph id=\"ph5\">`int`</ph>, <ph id=\"ph6\">`int?`</ph>, <ph id=\"ph7\">`uint`</ph>, <ph id=\"ph8\">`uint?`</ph>, <ph id=\"ph9\">`long`</ph>, <ph id=\"ph10\">`long?`</ph>, <ph id=\"ph11\">`ulong`</ph>, <ph id=\"ph12\">`ulong?`</ph>, <ph id=\"ph13\">`float`</ph>, <ph id=\"ph14\">`float?`</ph>, <ph id=\"ph15\">`double`</ph>, <ph id=\"ph16\">`double?`</ph>, <ph id=\"ph17\">`decimal`</ph>, <ph id=\"ph18\">`decimal?`</ph>, <ph id=\"ph19\">`DateTime`</ph>, <ph id=\"ph20\">`DateTime?`</ph>, <ph id=\"ph21\">`TimeSpan`</ph>, <ph id=\"ph22\">`TimeSpan?`</ph>, <ph id=\"ph23\">`GUID`</ph>, and <ph id=\"ph24\">`GUID?`</ph>.","source":"[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] provides explicit cast operators for the following data types: `string`, `bool`, `bool?`, `int`, `int?`, `uint`, `uint?`, `long`, `long?`, `ulong`, `ulong?`, `float`, `float?`, `double`, `double?`, `decimal`, `decimal?`, `DateTime`, `DateTime?`, `TimeSpan`, `TimeSpan?`, `GUID`, and `GUID?`."},{"pos":[2712,2894],"content":"<ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> provides the same cast operators for <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> objects.","source":"[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] provides the same cast operators for <xref:System.Xml.Linq.XAttribute> objects."},{"pos":[2903,2910],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement.Value%2A&gt;</ph> property to retrieve the contents of an element:","pos":[2914,3019],"source":"You can use the <xref:System.Xml.Linq.XElement.Value%2A> property to retrieve the contents of an element:"},{"content":"This example produces the following output:","pos":[3173,3216]},{"pos":[3298,3305],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Sometimes you try to retrieve the value of an element even though you are not sure it exists.","pos":[3309,3402]},{"content":"In this case, when you assign the casted element to a nullable type (either <ph id=\"ph1\">`string`</ph> or one of the nullable types in the <ph id=\"ph2\">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>), if the element does not exist the assigned variable is just set to <ph id=\"ph3\">`null`</ph>.","pos":[3403,3687],"source":" In this case, when you assign the casted element to a nullable type (either `string` or one of the nullable types in the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]), if the element does not exist the assigned variable is just set to `null`."},{"content":"The following code shows that when the element might or might not exist, it is easier to use casting than to use the <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement.Value%2A&gt;</ph> property.","pos":[3688,3855],"source":" The following code shows that when the element might or might not exist, it is easier to use casting than to use the <xref:System.Xml.Linq.XElement.Value%2A> property."},{"content":"This code produces the following output:","pos":[5687,5727]},{"content":"In general, you can write simpler code when using casting to retrieve the contents of elements and attributes.","pos":[5920,6030]},{"pos":[6039,6047],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[6051,6146],"content":"<bpt id=\"p1\">[</bpt>LINQ to XML Axes (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/linq-to-xml-axes.md)</ept>","source":"[LINQ to XML Axes (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-xml-axes.md)"}]}