{"content":"---\ntitle: \"Managed and Unmanaged Threading in Windows\"\nms.date: \"10/24/2018\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"threading [.NET Framework], unmanaged\"\n  - \"threading [.NET Framework], managed\"\n  - \"threading [.NET], managed\"\n  - \"threads and fibers [.NET]\"\n  - \"managed threading\"\nms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Managed and unmanaged threading in Windows\n\nManagement of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code. The runtime monitors all the threads in its process that have ever executed code within the managed execution environment. It does not track any other threads. Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.  \n  \n When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object. If one is found, the runtime is already aware of this thread. If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.  \n  \n In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification. For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.  \n  \n> [!NOTE]\n>  An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads. Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.  \n  \n## Mapping from Win32 threading to managed threading\n\n The following table maps Win32 threading elements to their approximate runtime equivalent. Note that this mapping does not represent identical functionality. For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented. However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>. Be sure to read the documentation closely before making assumptions about functionality.  \n  \n|In Win32|In the common language runtime|  \n|--------------|------------------------------------|  \n|**CreateThread**|Combination of **Thread** and <xref:System.Threading.ThreadStart>|  \n|**TerminateThread**|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  \n|**SuspendThread**|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  \n|**ResumeThread**|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  \n|**Sleep**|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  \n|**WaitForSingleObject** on the thread handle|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  \n|**ExitThread**|No equivalent|  \n|**GetCurrentThread**|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  \n|**SetThreadPriority**|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  \n|No equivalent|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  \n|No equivalent|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  \n|Close to **CoInitializeEx** (OLE32.DLL)|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  \n  \n## Managed threads and COM apartments\n\nA managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment. (For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread. If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.  \n  \n The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.  \n  \n If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA). The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.  \n  \n> [!IMPORTANT]\n>  For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure. In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code. This is not permitted in the .NET Framework 2.0.  \n  \n Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler. In other words, they can be called from any COM apartment in a free-threaded manner. The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.  \n  \n In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances. If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).  \n  \n When managed code calls out to COM objects, it always follows COM rules. In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.  \n  \n## Blocking issues  \n\nIf a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>. In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code. It is preferable for you to use managed blocking rather than unmanaged blocking. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>. Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.  \n\n## Threads and fibers\n\nThe .NET threading model does not support [fibers](/windows/desktop/procthread/fibers). You should not call into any unmanaged function that is implemented by using fibers. Such calls may result in a crash of the .NET runtime.\n\n## See also\n\n- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>\n- <xref:System.Threading.ThreadState>\n- <xref:System.EnterpriseServices.ServicedComponent>\n- <xref:System.Threading.Thread>\n- <xref:System.Threading.Monitor>\n","nodes":[{"pos":[4,393],"embed":true,"restype":"x-metadata","content":"title: \"Managed and Unmanaged Threading in Windows\"\nms.date: \"10/24/2018\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"threading [.NET Framework], unmanaged\"\n  - \"threading [.NET Framework], managed\"\n  - \"threading [.NET], managed\"\n  - \"threads and fibers [.NET]\"\n  - \"managed threading\"\nms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Managed and Unmanaged Threading in Windows","nodes":[{"pos":[0,42],"content":"Managed and Unmanaged Threading in Windows","nodes":[{"content":"Managed and Unmanaged Threading in Windows","pos":[0,42]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[400,442],"content":"Managed and unmanaged threading in Windows","linkify":"Managed and unmanaged threading in Windows","nodes":[{"content":"Managed and unmanaged threading in Windows","pos":[0,42]}]},{"content":"Management of all threads is done through the <ph id=\"ph1\">&lt;xref:System.Threading.Thread&gt;</ph> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.","pos":[444,674],"source":"Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code."},{"content":"The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.","pos":[675,797]},{"content":"It does not track any other threads.","pos":[798,834]},{"content":"Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM <bpt id=\"p1\">[</bpt>DllGetClassObject<ept id=\"p1\">](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject)</ept> function, and platform invoke.","pos":[835,1115],"source":" Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke."},{"content":"When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <ph id=\"ph1\">&lt;xref:System.Threading.Thread&gt;</ph> object.","pos":[1122,1338],"source":"When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object."},{"content":"If one is found, the runtime is already aware of this thread.","pos":[1339,1400]},{"content":"If it cannot find one, however, the runtime builds a new <ph id=\"ph1\">&lt;xref:System.Threading.Thread&gt;</ph> object and installs it in the thread-local store of that thread.","pos":[1401,1553],"source":" If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread."},{"content":"In managed threading, <ph id=\"ph1\">&lt;xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> is the stable managed thread identification.","pos":[1560,1701],"source":"In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification."},{"content":"For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.","pos":[1702,1863]},{"pos":[1871,2257],"content":"[!NOTE]\n An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads. Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.","leadings":["","> "],"nodes":[{"content":"An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads. Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.","pos":[9,384],"nodes":[{"content":"An operating-system <bpt id=\"p1\">**</bpt>ThreadId<ept id=\"p1\">**</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.","pos":[0,173],"source":"An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads."},{"content":"Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.","pos":[174,375]}]}]},{"pos":[2266,2315],"content":"Mapping from Win32 threading to managed threading","linkify":"Mapping from Win32 threading to managed threading","nodes":[{"content":"Mapping from Win32 threading to managed threading","pos":[0,49]}]},{"content":"The following table maps Win32 threading elements to their approximate runtime equivalent.","pos":[2318,2408]},{"content":"Note that this mapping does not represent identical functionality.","pos":[2409,2475]},{"content":"For example, <bpt id=\"p1\">**</bpt>TerminateThread<ept id=\"p1\">**</ept> does not execute <bpt id=\"p2\">**</bpt>finally<ept id=\"p2\">**</ept> clauses or free up resources, and cannot be prevented.","pos":[2476,2592],"source":" For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented."},{"content":"However, <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph> executes all your rollback code, reclaims all the resources, and can be denied using <ph id=\"ph2\">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph>.","pos":[2593,2801],"source":" However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>."},{"content":"Be sure to read the documentation closely before making assumptions about functionality.","pos":[2802,2890]},{"content":"In Win32","pos":[2897,2905]},{"content":"In the common language runtime","pos":[2906,2936]},{"pos":[2997,3013],"content":"<bpt id=\"p1\">**</bpt>CreateThread<ept id=\"p1\">**</ept>","source":"**CreateThread**"},{"pos":[3014,3079],"content":"Combination of <bpt id=\"p1\">**</bpt>Thread<ept id=\"p1\">**</ept> and <ph id=\"ph1\">&lt;xref:System.Threading.ThreadStart&gt;</ph>","source":"Combination of **Thread** and <xref:System.Threading.ThreadStart>"},{"pos":[3084,3103],"content":"<bpt id=\"p1\">**</bpt>TerminateThread<ept id=\"p1\">**</ept>","source":"**TerminateThread**"},{"pos":[3177,3194],"content":"<bpt id=\"p1\">**</bpt>SuspendThread<ept id=\"p1\">**</ept>","source":"**SuspendThread**"},{"pos":[3270,3286],"content":"<bpt id=\"p1\">**</bpt>ResumeThread<ept id=\"p1\">**</ept>","source":"**ResumeThread**"},{"pos":[3361,3370],"content":"<bpt id=\"p1\">**</bpt>Sleep<ept id=\"p1\">**</ept>","source":"**Sleep**"},{"pos":[3444,3488],"content":"<bpt id=\"p1\">**</bpt>WaitForSingleObject<ept id=\"p1\">**</ept> on the thread handle","source":"**WaitForSingleObject** on the thread handle"},{"pos":[3561,3575],"content":"<bpt id=\"p1\">**</bpt>ExitThread<ept id=\"p1\">**</ept>","source":"**ExitThread**"},{"content":"No equivalent","pos":[3576,3589]},{"pos":[3594,3614],"content":"<bpt id=\"p1\">**</bpt>GetCurrentThread<ept id=\"p1\">**</ept>","source":"**GetCurrentThread**"},{"pos":[3696,3717],"content":"<bpt id=\"p1\">**</bpt>SetThreadPriority<ept id=\"p1\">**</ept>","source":"**SetThreadPriority**"},{"content":"No equivalent","pos":[3794,3807]},{"content":"No equivalent","pos":[3880,3893]},{"pos":[3974,4013],"content":"Close to <bpt id=\"p1\">**</bpt>CoInitializeEx<ept id=\"p1\">**</ept> (OLE32.DLL)","source":"Close to **CoInitializeEx** (OLE32.DLL)"},{"pos":[4101,4135],"content":"Managed threads and COM apartments","linkify":"Managed threads and COM apartments","nodes":[{"content":"Managed threads and COM apartments","pos":[0,34]}]},{"content":"A managed thread can be marked to indicate that it will host a <bpt id=\"p1\">[</bpt>single-threaded<ept id=\"p1\">](/windows/desktop/com/single-threaded-apartments)</ept> or <bpt id=\"p2\">[</bpt>multithreaded<ept id=\"p2\">](/windows/desktop/com/multithreaded-apartments)</ept> apartment.","pos":[4137,4343],"source":"A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment."},{"content":"(For more information on the COM threading architecture, see <bpt id=\"p1\">[</bpt>Processes, Threads, and Apartments<ept id=\"p1\">](/windows/desktop/com/processes--threads--and-apartments)</ept>.) The <ph id=\"ph1\">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods of the <ph id=\"ph4\">&lt;xref:System.Threading.Thread&gt;</ph> class return and assign the apartment state of a thread.","pos":[4344,4772],"source":" (For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread."},{"content":"If the state has not been set, <ph id=\"ph1\">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> returns <ph id=\"ph2\">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph>.","pos":[4773,4940],"source":" If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>."},{"pos":[4947,5121],"content":"The property can be set only when the thread is in the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state; it can be set only once for a thread.","source":"The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread."},{"content":"If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).","pos":[5128,5253]},{"content":"The finalizer thread and all threads controlled by <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph> are MTA.","pos":[5254,5348],"source":" The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA."},{"pos":[5356,5744],"content":"[!IMPORTANT]\n For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure. In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code. This is not permitted in the .NET Framework 2.0.","leadings":["","> "],"nodes":[{"content":"For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure. In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code. This is not permitted in the .NET Framework 2.0.","pos":[14,386],"nodes":[{"content":"For application startup code, the only way to control apartment state is to apply the <ph id=\"ph1\">&lt;xref:System.MTAThreadAttribute&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.STAThreadAttribute&gt;</ph> to the entry point procedure.","pos":[0,188],"source":"For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure."},{"content":"In the .NET Framework 1.0 and 1.1, the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property can be set as the first line of code.","pos":[189,323],"source":" In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code."},{"content":"This is not permitted in the .NET Framework 2.0.","pos":[324,372]}]}]},{"content":"Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.","pos":[5751,5852]},{"content":"In other words, they can be called from any COM apartment in a free-threaded manner.","pos":[5853,5937]},{"content":"The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <ph id=\"ph1\">&lt;xref:System.EnterpriseServices.ServicedComponent&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.StandardOleMarshalObject&gt;</ph>.","pos":[5938,6163],"source":" The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>."},{"content":"In the managed world, there is no support for the <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> unless you use contexts and context-bound managed instances.","pos":[6170,6345],"source":"In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances."},{"content":"If you are using Enterprise Services, then your object must derive from <ph id=\"ph1\">&lt;xref:System.EnterpriseServices.ServicedComponent&gt;</ph> (which is itself derived from <ph id=\"ph2\">&lt;xref:System.ContextBoundObject&gt;</ph>).","pos":[6346,6533],"source":" If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>)."},{"content":"When managed code calls out to COM objects, it always follows COM rules.","pos":[6540,6612]},{"content":"In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.","pos":[6613,6719]},{"pos":[6728,6743],"content":"Blocking issues","linkify":"Blocking issues","nodes":[{"content":"Blocking issues","pos":[0,15]}]},{"content":"If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph>.","pos":[6747,7045],"source":"If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>."},{"content":"In the case of <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph>, the runtime marks the thread for <bpt id=\"p1\">**</bpt>Abort<ept id=\"p1\">**</ept> and takes control of it when it re-enters managed code.","pos":[7046,7229],"source":" In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code."},{"content":"It is preferable for you to use managed blocking rather than unmanaged blocking.","pos":[7230,7310]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>,<ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph7\">&lt;xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType&gt;</ph>, and so on are all responsive to <ph id=\"ph8\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> and to <ph id=\"ph9\">&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType&gt;</ph>.","pos":[7311,8008],"source":"<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>."},{"content":"Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.","pos":[8009,8179]},{"pos":[8186,8204],"content":"Threads and fibers","linkify":"Threads and fibers","nodes":[{"content":"Threads and fibers","pos":[0,18]}]},{"content":"The .NET threading model does not support <bpt id=\"p1\">[</bpt>fibers<ept id=\"p1\">](/windows/desktop/procthread/fibers)</ept>.","pos":[8206,8293],"source":"The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers)."},{"content":"You should not call into any unmanaged function that is implemented by using fibers.","pos":[8294,8378]},{"content":"Such calls may result in a crash of the .NET runtime.","pos":[8379,8432]},{"pos":[8437,8445],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]}]}