{"content":"---\ntitle: \"Control Authoring Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"controls, authoring overview\"\n  - \"authoring overview for controls\"\nms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f\ncaps.latest.revision: 32\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Control Authoring Overview\nThe extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control. However, in certain cases you may still need to create a custom control. This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]. This topic also demonstrates how to create a new control.  \n  \n \n  \n<a name=\"when_to_write_a_new_control\"></a>   \n## Alternatives to Writing a New Control  \n Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size. If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.  Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers. The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.  \n  \n-   **Rich Content.** Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content. For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.  To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property. Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization. For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](../../../../docs/framework/wpf/controls/wpf-content-model.md).  \n  \n-   **Styles.** A <xref:System.Windows.Style> is a collection of values that represent properties for a control. By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control. For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14. You can create a style as a resource and set the appropriate properties accordingly. Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.  \n  \n-   **Data Templates.** A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control. For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.  For an example of this, see [Data Templating Overview](../../../../docs/framework/wpf/data/data-templating-overview.md).  In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.  For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.  \n  \n-   **Control Templates.** Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control. You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.  For example, suppose you want a control that looks like a stoplight. This control has a simple user interface and functionality.  The control is three circles, only one of which can be lit up at a time. After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.  Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.  \n  \n    > [!NOTE]\n    >  Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.  The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control. In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.  In the example of the stoplight, the radio button needs just be a circle that can \"light up.\" Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.  In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.  \n  \n-   **Triggers.** A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control. For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected. Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item. A trigger enables you to change property values or take actions based on the value of a property. An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.  \n  \n For more information about styles, templates, and triggers, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).  \n  \n In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.  \n  \n<a name=\"models_for_control_authoring\"></a>   \n## Models for Control Authoring  \n The rich content model, styles, templates, and triggers minimize the need for you to create a new control. However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides three general models for creating a control, each of which provides a different set of features and level of flexibility. The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.  \n  \n### Deriving from UserControl  \n The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>. When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]. You can then reference the named elements and define the event handlers in code. This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  \n  \n If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers. However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.  It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.  \n  \n#### Benefits of Deriving from UserControl  \n Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:  \n  \n-   You want to build your control similarly to how you build an application.  \n  \n-   Your control consists only of existing components.  \n  \n-   You don't need to support complex customization.  \n  \n### Deriving from Control  \n Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls. When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates. By doing so, you separate the operational logic from the visual representation. You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.  If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance. Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.  \n  \n#### Benefits of Deriving from Control  \n Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:  \n  \n-   You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.  \n  \n-   You want your control to support different themes.  \n  \n### Deriving from FrameworkElement  \n Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements. For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>. However, there are times when a control's appearance requires more than the functionality of simple element composition. For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.  \n  \n There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition. Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals. This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>. Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component. For an example, see [Using DrawingVisual Objects](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md). <xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition. It is also possible to mix direct rendering and custom element composition in the same control.  \n  \n#### Benefits of Deriving from FrameworkElement  \n Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:  \n  \n-   You want to have precise control over the appearance of your control beyond what is provided by simple element composition.  \n  \n-   You want to define the appearance of your control by defining your own render logic.  \n  \n-   You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.  \n  \n<a name=\"control_authoring_basics\"></a>   \n## Control Authoring Basics  \n As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control. The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system. The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  \n  \n### Use Dependency Properties  \n When a property is a dependency property, it is possible to do the following:  \n  \n-   Set the property in a style.  \n  \n-   Bind the property to a data source.  \n  \n-   Use a dynamic resource as the property's value.  \n  \n-   Animate the property.  \n  \n If you want a property of your control to support any of this functionality, you should implement it as a dependency property. The following example defines a dependency property named `Value` by doing the following:  \n  \n-   Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.  \n  \n-   Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=fullName>, to specify the following:  \n  \n    -   The name of the property.  \n  \n    -   The type of the property.  \n  \n    -   The type that owns the property.  \n  \n    -   The metadata for the property. The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.  \n  \n-   Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors. Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively. It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly. For example, when a property is bound to a data source, the property's `set` accessor is not called.  Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.  For more information on these callbacks, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  \n  \n-   Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`. `CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.  \n  \n-   Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`. `OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event. Routed events are discussed in the next section.  \n  \n [!code-csharp[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]\n [!code-vb[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]  \n  \n For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  \n  \n### Use Routed Events  \n Just as dependency properties extend the notion of [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties with additional functionality, routed events extend the notion of standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events. When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:  \n  \n-   Events can be handled on a parent of multiple controls. If an event is a bubbling event, a single parent in the element tree can subscribe to the event. Then application authors can use one handler to respond to the event of multiple controls. For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>. Whenever the event occurs on any of the controls, the event handler is called.  \n  \n-   Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.  \n  \n-   Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]. For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).  \n  \n The following example defines a routed event by doing the following:  \n  \n-   Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.  \n  \n-   Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=fullName> method. The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:  \n  \n    -   The name of the event is `ValueChanged`.  \n  \n    -   The routing strategy is <xref:System.Windows.RoutingStrategy>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.  \n  \n    -   The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.  \n  \n    -   The owning type of the event is `NumericUpDown`.  \n  \n-   Declare a public event named `ValueChanged` and includes event-accessor declarations. The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.  \n  \n-   Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.  \n  \n [!code-csharp[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]\n [!code-vb[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]  \n  \n For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md) and [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  \n  \n### Use Binding  \n To decouple the UI of your control from its logic, consider using data binding. This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>. When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code. It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.  \n  \n The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.  \n  \n [!code-xml[UserControlNumericUpDownSimple#UIRefMarkup](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]  \n  \n [!code-csharp[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]\n [!code-vb[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]  \n  \n The following example uses binding to accomplish the same thing.  \n  \n [!code-xml[UserControlNumericUpDown#Binding](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]  \n  \n For more information about data binding, see [Data Binding Overview](../../../../docs/framework/wpf/data/data-binding-overview.md).  \n  \n### Design for Designers  \n To receive support for custom WPF controls in the [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] (for example, property editing with the Properties window), follow these guidelines.  For more information on developing for the [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)], see [WPF Designer](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26).  \n  \n#### Dependency Properties  \n Be sure to implement [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `get` and `set` accessors as described earlier, in \"Use Dependency Properties.\" Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.  \n  \n#### Attached Properties  \n You should implement attached properties on custom controls using the following guidelines:  \n  \n-   Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method. The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.  \n  \n-   Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*. Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument. The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property. The `Get`*PropertyName* method should return a value of the same type. If the `Set`*PropertyName* method is missing, the property is marked read-only.  \n  \n-   `Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively. Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.  \n  \n For more information on attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).  \n  \n### Define and Use Shared Resources  \n You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications. For the most part, the information discussed in this topic applies regardless of the method you use.  There is one difference worth noting, however.  When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file. But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.  \n  \n When an application looks for a resource, it looks at three levels in the following order:  \n  \n1.  The element level.  \n  \n     The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.  \n  \n2.  The application level.  \n  \n     Resources defined by the <xref:System.Windows.Application> object.  \n  \n3.  The theme level.  \n  \n     Theme-level dictionaries are stored in a subfolder named Themes.  The files in the Themes folder correspond to themes.  For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.  You can also have a file named generic.xaml.  When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.  \n  \n When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level. Both methods have their advantages.  \n  \n#### Defining Resources at the Element Level  \n You can define shared resources at the element level by creating a custom resource dictionary and merging it with your controlâ€™s resource dictionary.  When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls. Resources at the element level can also use simple strings as keys. The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.  \n  \n [!code-xml[SharedResources#1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]  \n  \n Once you have defined your dictionary, you need to merge it with your control's resource dictionary.  You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.  \n  \n The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].  \n  \n [!code-xml[SharedResources#2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]  \n  \n The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.  For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.  You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.  \n  \n The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.  \n  \n [!code-csharp[SharedResources#3](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]  \n  \n The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitilizeComponent`.  Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once. Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.  \n  \n [!code-csharp[SharedResources#4](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]  \n  \n#### Defining Resources at the Theme Level  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables you to create resources for different Windows themes.  As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use. For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.  \n  \n Resources that are specific to a theme are kept in a resource dictionary with a specific file name. These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control. The following table lists the resource dictionary files and the theme that is associated with each file:  \n  \n|Resource dictionary file name|Windows theme|  \n|-----------------------------------|-------------------|  \n|`Classic.xaml`|Classic Windows 9x/2000 look on Windows XP|  \n|`Luna.NormalColor.xaml`|Default blue theme on Windows XP|  \n|`Luna.Homestead.xaml`|Olive theme on Windows XP|  \n|`Luna.Metallic.xaml`|Silver theme on Windows XP|  \n|`Royale.NormalColor.xaml`|Default theme on Windows XP Media Center Edition|  \n|`Aero.NormalColor.xaml`|Default theme on Windows Vista|  \n  \n You do not need to define a resource for every theme. If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource. If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.  The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files. Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.  \n  \n [NumericUpDown Custom Control with Theme and UI Automation Support Sample](http://go.microsoft.com/fwlink/?LinkID=160025) contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml and one is in Luna.NormalColor.xaml.  You can run the application and switch between the Silver theme in Windows XP and another theme to see the difference between the two control templates. (If you are running Windows Vista, you can rename Luna.NormalColor.xaml to Aero.NormalColor.xaml and switch between two themes, such as Windows Classic and the default theme for Windows Vista.)  \n  \n When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.  \n  \n [!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]\n [!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]  \n  \n##### Defining and Referencing Keys for Theme Resources  \n When you define a resource at the element level, you can assign a string as its key and access the resource via the string. When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.  The following example defines a resource in generic.xaml.  \n  \n [!code-xml[ThemeResourcesControlLibrary#5](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]  \n  \n The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.  \n  \n [!code-xml[ThemeResourcesControlLibrary#6](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]  \n  \n##### Specifying the Location of Theme Resources  \n To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources. You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control. The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.  \n  \n The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation>, to specify that the generic and theme-specific resources are in the same assembly as the control.  \n  \n [!code-csharp[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]\n [!code-vb[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]  \n  \n## See Also  \n [WPF Designer](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26)   \n [Pack URIs in WPF](../../../../docs/framework/wpf/app-development/pack-uris-in-wpf.md)   \n [Control Customization](../../../../docs/framework/wpf/controls/control-customization.md)","nodes":[{"pos":[4,451],"nodes":[{"content":"Control Authoring Overview | Microsoft Docs","nodes":[{"pos":[0,43],"content":"Control Authoring Overview | Microsoft Docs","nodes":[{"content":"Control Authoring Overview | Microsoft Docs","pos":[0,43]}]}],"pos":[6,52],"yaml":true}],"content":"title: \"Control Authoring Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"controls, authoring overview\"\n  - \"authoring overview for controls\"\nms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f\ncaps.latest.revision: 32\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","yamlblock":true},{"pos":[458,484],"content":"Control Authoring Overview","linkify":"Control Authoring Overview","nodes":[{"content":"Control Authoring Overview","pos":[0,26]}]},{"content":"The extensibility of the <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> control model greatly reduces the need to create a new control.","pos":[485,653],"source":"The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control."},{"content":"However, in certain cases you may still need to create a custom control.","pos":[654,726]},{"content":"This topic discusses the features that minimize your need to create a custom control and the different control authoring models in <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph>.","pos":[727,938],"source":" This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]."},{"content":"This topic also demonstrates how to create a new control.","pos":[939,996]},{"pos":[1056,1093],"content":"Alternatives to Writing a New Control","linkify":"Alternatives to Writing a New Control","nodes":[{"content":"Alternatives to Writing a New Control","pos":[0,37]}]},{"content":"Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.","pos":[1097,1305]},{"content":"If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.","pos":[1306,1555]},{"content":"Although that is still an option, <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> enables to you customize existing controls by using its rich content model, styles, templates, and triggers.","pos":[1557,1781],"source":"  Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers."},{"content":"The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.","pos":[1782,1933]},{"content":"<bpt id=\"p1\">**</bpt>Rich Content.<ept id=\"p1\">**</ept>","pos":[1943,1960],"source":"**Rich Content.**"},{"content":"Many of the standard <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> controls support rich content.","pos":[1961,2094],"source":" Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content."},{"content":"For example, the content property of a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> is of type <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, so theoretically anything can be displayed on a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Button&gt;</ph>.","pos":[2095,2291],"source":" For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>."},{"content":"To have a button display an image and text, you can add an image and a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> to a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> and assign the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> to the <ph id=\"ph4\">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property.","pos":[2293,2582],"source":"  To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property."},{"content":"Because the controls can display <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.","pos":[2583,2845],"source":" Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization."},{"content":"For more information about the content model for <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> and other content models in <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>WPF Content Model<ept id=\"p1\">](../../../../docs/framework/wpf/controls/wpf-content-model.md)</ept>.","pos":[2846,3130],"source":" For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](../../../../docs/framework/wpf/controls/wpf-content-model.md)."},{"content":"<bpt id=\"p1\">**</bpt>Styles.<ept id=\"p1\">**</ept>","pos":[3140,3151],"source":"**Styles.**"},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Style&gt;</ph> is a collection of values that represent properties for a control.","pos":[3152,3248],"source":" A <xref:System.Windows.Style> is a collection of values that represent properties for a control."},{"content":"By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.","pos":[3249,3382]},{"content":"For example, assume that you want all of your <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> controls to have red, Arial font with a font size of 14.","pos":[3383,3526],"source":" For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14."},{"content":"You can create a style as a resource and set the appropriate properties accordingly.","pos":[3527,3611]},{"content":"Then every <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> that you add to your application will have the same appearance.","pos":[3612,3727],"source":" Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance."},{"content":"<bpt id=\"p1\">**</bpt>Data Templates.<ept id=\"p1\">**</ept>","pos":[3737,3756],"source":"**Data Templates.**"},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.DataTemplate&gt;</ph> enables you to customize how data is displayed on a control.","pos":[3757,3854],"source":" A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control."},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Windows.DataTemplate&gt;</ph> can be used to specify how data is displayed in a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>.","pos":[3855,3994],"source":" For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>."},{"content":"For an example of this, see <bpt id=\"p1\">[</bpt>Data Templating Overview<ept id=\"p1\">](../../../../docs/framework/wpf/data/data-templating-overview.md)</ept>.","pos":[3996,4116],"source":"  For an example of this, see [Data Templating Overview](../../../../docs/framework/wpf/data/data-templating-overview.md)."},{"content":"In addition to customizing the appearance of data, a <ph id=\"ph1\">&lt;xref:System.Windows.DataTemplate&gt;</ph> can include UI elements, which gives you a lot of flexibility in custom UIs.","pos":[4118,4282],"source":"  In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs."},{"content":"For example, by using a <ph id=\"ph1\">&lt;xref:System.Windows.DataTemplate&gt;</ph>, you can create a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ComboBox&gt;</ph> in which each item contains a check box.","pos":[4284,4441],"source":"  For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box."},{"content":"<bpt id=\"p1\">**</bpt>Control Templates.<ept id=\"p1\">**</ept>","pos":[4451,4473],"source":"**Control Templates.**"},{"content":"Many controls in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> use a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.","pos":[4474,4758],"source":" Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control."},{"content":"You can drastically change the appearance of a control by redefining its <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.","pos":[4759,4879],"source":" You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>."},{"content":"For example, suppose you want a control that looks like a stoplight.","pos":[4881,4949]},{"content":"This control has a simple user interface and functionality.","pos":[4950,5009]},{"content":"The control is three circles, only one of which can be lit up at a time.","pos":[5011,5083]},{"content":"After some reflection, you might realize that a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> offers the functionality of only one being selected at a time, but the default appearance of the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> looks nothing like the lights on a stoplight.","pos":[5084,5360],"source":" After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight."},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> uses a control template to define its appearance, it is easy to redefine the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to fit the requirements of the control, and use radio buttons to make your stoplight.","pos":[5362,5626],"source":"  Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight."},{"pos":[5638,6651],"content":"[!NOTE]\nAlthough a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.  The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control. In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.  In the example of the stoplight, the radio button needs just be a circle that can \"light up.\" Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.  In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.","leadings":["","    >  "],"nodes":[{"content":"Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.  The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control. In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.  In the example of the stoplight, the radio button needs just be a circle that can \"light up.\" Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.  In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.","pos":[8,1006],"nodes":[{"content":"Although a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> can use a <ph id=\"ph2\">&lt;xref:System.Windows.DataTemplate&gt;</ph>, a <ph id=\"ph3\">&lt;xref:System.Windows.DataTemplate&gt;</ph> is not sufficient in this example.","pos":[0,171],"source":"Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.DataTemplate&gt;</ph> defines the appearance of the content of a control.","pos":[173,263],"source":"  The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control."},{"content":"In the case of a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph>, the content is whatever appears to the right of the circle that indicates whether the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> is selected.","pos":[264,466],"source":" In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected."},{"content":"In the example of the stoplight, the radio button needs just be a circle that can \"light up.\"","pos":[468,561]},{"content":"Because the appearance requirement for the stoplight is so different than the default appearance of the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph>, it is necessary to redefine the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.","pos":[562,789],"source":" Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>."},{"content":"In general a <ph id=\"ph1\">&lt;xref:System.Windows.DataTemplate&gt;</ph> is used for defining the content (or data) of a control, and a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is used for defining how a control is structured.","pos":[791,998],"source":"  In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured."}]}]},{"content":"<bpt id=\"p1\">**</bpt>Triggers.<ept id=\"p1\">**</ept>","pos":[6661,6674],"source":"**Triggers.**"},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Trigger&gt;</ph> allows you to dynamically change the appearance and behavior of a control without creating a new control.","pos":[6675,6812],"source":" A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control."},{"content":"For example, suppose you have multiple <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> controls in your application and want the items in each <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> to be bold and red when they are selected.","pos":[6813,7028],"source":" For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected."},{"content":"Your first instinct might be to create a class that inherits from <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> and override the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A&gt;</ph> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ListBoxItem&gt;</ph> that changes the appearance of the selected item.","pos":[7029,7428],"source":" Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item."},{"content":"A trigger enables you to change property values or take actions based on the value of a property.","pos":[7429,7526]},{"content":"An <ph id=\"ph1\">&lt;xref:System.Windows.EventTrigger&gt;</ph> enables you to take actions when an event occurs.","pos":[7527,7614],"source":" An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs."},{"pos":[7621,7777],"content":"For more information about styles, templates, and triggers, see <bpt id=\"p1\">[</bpt>Styling and Templating<ept id=\"p1\">](../../../../docs/framework/wpf/controls/styling-and-templating.md)</ept>.","source":"For more information about styles, templates, and triggers, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md)."},{"content":"In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.","pos":[7784,8041]},{"pos":[8097,8125],"content":"Models for Control Authoring","linkify":"Models for Control Authoring","nodes":[{"content":"Models for Control Authoring","pos":[0,28]}]},{"content":"The rich content model, styles, templates, and triggers minimize the need for you to create a new control.","pos":[8129,8235]},{"content":"However, if you do need to create a new control, it is important to understand the different control authoring models in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.","pos":[8236,8439],"source":" However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> provides three general models for creating a control, each of which provides a different set of features and level of flexibility.","pos":[8440,8652],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides three general models for creating a control, each of which provides a different set of features and level of flexibility."},{"content":"The base classes for the three models are <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.","pos":[8653,8822],"source":" The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>."},{"pos":[8832,8857],"content":"Deriving from UserControl","linkify":"Deriving from UserControl","nodes":[{"content":"Deriving from UserControl","pos":[0,25]}]},{"content":"The simplest way to create a control in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is to derive from <ph id=\"ph2\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>.","pos":[8861,9044],"source":"The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>."},{"content":"When you build a control that inherits from <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, you add existing components to the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, name the components, and reference event handlers in <ph id=\"ph3\">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph>.","pos":[9045,9335],"source":" When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]."},{"content":"You can then reference the named elements and define the event handlers in code.","pos":[9336,9416]},{"content":"This development model is very similar to the model used for application development in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.","pos":[9417,9587],"source":" This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]."},{"content":"If built correctly, a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> can take advantage of the benefits of rich content, styles, and triggers.","pos":[9594,9732],"source":"If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers."},{"content":"However, if your control inherits from <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, people who use your control will not be able to use a <ph id=\"ph2\">&lt;xref:System.Windows.DataTemplate&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to customize its appearance.","pos":[9733,9983],"source":" However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance."},{"content":"It is necessary to derive from the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control&gt;</ph> class or one of its derived classes (other than <ph id=\"ph2\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>) to create a custom control that supports templates.","pos":[9985,10202],"source":"  It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates."},{"pos":[10213,10250],"content":"Benefits of Deriving from UserControl","linkify":"Benefits of Deriving from UserControl","nodes":[{"content":"Benefits of Deriving from UserControl","pos":[0,37]}]},{"content":"Consider deriving from <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> if all of the following apply:","pos":[10254,10350],"source":"Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:"},{"content":"You want to build your control similarly to how you build an application.","pos":[10360,10433]},{"content":"Your control consists only of existing components.","pos":[10443,10493]},{"content":"You don't need to support complex customization.","pos":[10503,10551]},{"pos":[10561,10582],"content":"Deriving from Control","linkify":"Deriving from Control","nodes":[{"content":"Deriving from Control","pos":[0,21]}]},{"content":"Deriving from the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control&gt;</ph> class is the model used by most of the existing <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> controls.","pos":[10586,10782],"source":"Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls."},{"content":"When you create a control that inherits from the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control&gt;</ph> class, you define its appearance by using templates.","pos":[10783,10923],"source":" When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates."},{"content":"By doing so, you separate the operational logic from the visual representation.","pos":[10924,11003]},{"content":"You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> whenever possible.","pos":[11004,11214],"source":" You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible."},{"content":"If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to customize its appearance.","pos":[11216,11401],"source":"  If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance."},{"content":"Although building a custom <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control&gt;</ph> is not as simple as building a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, a custom <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Control&gt;</ph> provides the most flexibility.","pos":[11402,11621],"source":" Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility."},{"pos":[11632,11665],"content":"Benefits of Deriving from Control","linkify":"Benefits of Deriving from Control","nodes":[{"content":"Benefits of Deriving from Control","pos":[0,33]}]},{"content":"Consider deriving from <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control&gt;</ph> instead of using the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> class if any of the following apply:","pos":[11669,11831],"source":"Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:"},{"content":"You want the appearance of your control to be customizable via the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.","pos":[11841,11955],"source":"You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>."},{"content":"You want your control to support different themes.","pos":[11965,12015]},{"pos":[12025,12055],"content":"Deriving from FrameworkElement","linkify":"Deriving from FrameworkElement","nodes":[{"content":"Deriving from FrameworkElement","pos":[0,30]}]},{"content":"Controls that derive from <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control&gt;</ph> rely upon composing existing elements.","pos":[12059,12208],"source":"Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements."},{"content":"For many scenarios, this is an acceptable solution, because any object that inherits from <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> can be in a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.","pos":[12209,12397],"source":" For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>."},{"content":"However, there are times when a control's appearance requires more than the functionality of simple element composition.","pos":[12398,12518]},{"content":"For these scenarios, basing a component on <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is the right choice.","pos":[12519,12621],"source":" For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice."},{"content":"There are two standard methods for building <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>-based components: direct rendering and custom element composition.","pos":[12628,12777],"source":"There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition."},{"content":"Direct rendering involves overriding the <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> method of <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and providing <ph id=\"ph3\">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> operations that explicitly define the component visuals.","pos":[12778,13025],"source":" Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals."},{"content":"This is the method used by <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Image&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Border&gt;</ph>.","pos":[13026,13132],"source":" This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>."},{"content":"Custom element composition involves using objects of type <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> to compose the appearance of your component.","pos":[13133,13270],"source":" Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component."},{"content":"For an example, see <bpt id=\"p1\">[</bpt>Using DrawingVisual Objects<ept id=\"p1\">](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)</ept>.","pos":[13271,13404],"source":" For an example, see [Using DrawingVisual Objects](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Track&gt;</ph> is an example of a control in <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> that uses custom element composition.","pos":[13405,13602],"source":" <xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition."},{"content":"It is also possible to mix direct rendering and custom element composition in the same control.","pos":[13603,13698]},{"pos":[13709,13751],"content":"Benefits of Deriving from FrameworkElement","linkify":"Benefits of Deriving from FrameworkElement","nodes":[{"content":"Benefits of Deriving from FrameworkElement","pos":[0,42]}]},{"content":"Consider deriving from <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> if any of the following apply:","pos":[13755,13847],"source":"Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:"},{"content":"You want to have precise control over the appearance of your control beyond what is provided by simple element composition.","pos":[13857,13980]},{"content":"You want to define the appearance of your control by defining your own render logic.","pos":[13990,14074]},{"content":"You want to compose existing elements in novel ways that go beyond what is possible with <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control&gt;</ph>.","pos":[14084,14259],"source":"You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>."},{"pos":[14311,14335],"content":"Control Authoring Basics","linkify":"Control Authoring Basics","nodes":[{"content":"Control Authoring Basics","pos":[0,24]}]},{"content":"As discussed earlier, one of the most powerful features of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.","pos":[14339,14634],"source":"As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control."},{"content":"The styling, data binding, and trigger features are made possible by the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> property system and the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> event system.","pos":[14635,14909],"source":" The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system."},{"content":"The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.","pos":[14910,15240],"source":" The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]."},{"pos":[15250,15275],"content":"Use Dependency Properties","linkify":"Use Dependency Properties","nodes":[{"content":"Use Dependency Properties","pos":[0,25]}]},{"content":"When a property is a dependency property, it is possible to do the following:","pos":[15279,15356]},{"content":"Set the property in a style.","pos":[15366,15394]},{"content":"Bind the property to a data source.","pos":[15404,15439]},{"content":"Use a dynamic resource as the property's value.","pos":[15449,15496]},{"content":"Animate the property.","pos":[15506,15527]},{"content":"If you want a property of your control to support any of this functionality, you should implement it as a dependency property.","pos":[15534,15660]},{"content":"The following example defines a dependency property named <ph id=\"ph1\">`Value`</ph> by doing the following:","pos":[15661,15750],"source":" The following example defines a dependency property named `Value` by doing the following:"},{"pos":[15760,15883],"content":"Define a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier named <ph id=\"ph2\">`ValueProperty`</ph> as a <ph id=\"ph3\">`public`</ph> <ph id=\"ph4\">`static`</ph> <ph id=\"ph5\">`readonly`</ph> field.","source":"Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field."},{"content":"Register the property name with the property system, by calling <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A?displayProperty=fullName&gt;</ph>, to specify the following:","pos":[15893,16061],"source":"Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=fullName>, to specify the following:"},{"content":"The name of the property.","pos":[16075,16100]},{"content":"The type of the property.","pos":[16114,16139]},{"content":"The type that owns the property.","pos":[16153,16185]},{"content":"The metadata for the property.","pos":[16199,16229]},{"content":"The metadata contains the property's default value, a <ph id=\"ph1\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> and a <ph id=\"ph2\">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>.","pos":[16230,16378],"source":" The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>."},{"content":"Define a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> wrapper property named <ph id=\"ph2\">`Value`</ph>, which is the same name that is used to register the dependency property, by implementing the property's <ph id=\"ph3\">`get`</ph> and <ph id=\"ph4\">`set`</ph> accessors.","pos":[16388,16629],"source":"Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors."},{"content":"Note that the <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessors only call <ph id=\"ph3\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> respectively.","pos":[16630,16799],"source":" Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively."},{"content":"It is recommended that the accessors of dependency properties not contain additional logic because clients and <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> can bypass the accessors and call <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> directly.","pos":[16800,17142],"source":" It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly."},{"content":"For example, when a property is bound to a data source, the property's <ph id=\"ph1\">`set`</ph> accessor is not called.","pos":[17143,17243],"source":" For example, when a property is bound to a data source, the property's `set` accessor is not called."},{"content":"Instead of adding additional logic to the get and set accessors, use the <ph id=\"ph1\">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> delegates to respond to or check the value when it changes.","pos":[17245,17515],"source":"  Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes."},{"content":"For more information on these callbacks, see <bpt id=\"p1\">[</bpt>Dependency Property Callbacks and Validation<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.","pos":[17517,17698],"source":"  For more information on these callbacks, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)."},{"content":"Define a method for the <ph id=\"ph1\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> named <ph id=\"ph2\">`CoerceValue`</ph>.","pos":[17708,17794],"source":"Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`."},{"content":"<ph id=\"ph1\">`CoerceValue`</ph> ensures that <ph id=\"ph2\">`Value`</ph> is greater or equal to <ph id=\"ph3\">`MinValue`</ph> and less than or equal to <ph id=\"ph4\">`MaxValue`</ph>.","pos":[17795,17901],"source":"`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`."},{"content":"Define a method for the <ph id=\"ph1\">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, named <ph id=\"ph2\">`OnValueChanged`</ph>.","pos":[17911,18005],"source":"Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`."},{"content":"<ph id=\"ph1\">`OnValueChanged`</ph> creates a <ph id=\"ph2\">&lt;xref:System.Windows.RoutedPropertyChangedEventArgs%601&gt;</ph> object and prepares to raise the <ph id=\"ph3\">`ValueChanged`</ph> routed event.","pos":[18006,18151],"source":"`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event."},{"content":"Routed events are discussed in the next section.","pos":[18152,18200]},{"pos":[18207,18585],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UserControlNumericUpDown#DependencyProperty<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>UserControlNumericUpDown#DependencyProperty<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]\n[!code-vb[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]"},{"pos":[18592,18722],"content":"For more information, see <bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.","source":"For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)."},{"pos":[18732,18749],"content":"Use Routed Events","linkify":"Use Routed Events","nodes":[{"content":"Use Routed Events","pos":[0,17]}]},{"content":"Just as dependency properties extend the notion of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> properties with additional functionality, routed events extend the notion of standard <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> events.","pos":[18753,19037],"source":"Just as dependency properties extend the notion of [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties with additional functionality, routed events extend the notion of standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events."},{"content":"When you create a new <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:","pos":[19038,19273],"source":" When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:"},{"content":"Events can be handled on a parent of multiple controls.","pos":[19283,19338]},{"content":"If an event is a bubbling event, a single parent in the element tree can subscribe to the event.","pos":[19339,19435]},{"content":"Then application authors can use one handler to respond to the event of multiple controls.","pos":[19436,19526]},{"content":"For example, if your control is a part of each item in a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> (because it is included in a <ph id=\"ph2\">&lt;xref:System.Windows.DataTemplate&gt;</ph>), the application developer can define the event handler for your control's event on the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>.","pos":[19527,19815],"source":" For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>."},{"content":"Whenever the event occurs on any of the controls, the event handler is called.","pos":[19816,19894]},{"content":"Routed events can be used in an <ph id=\"ph1\">&lt;xref:System.Windows.EventSetter&gt;</ph>, which enables application developers to specify the handler of an event within a style.","pos":[19904,20058],"source":"Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style."},{"content":"Routed events can be used in an <ph id=\"ph1\">&lt;xref:System.Windows.EventTrigger&gt;</ph>, which is useful for animating properties by using <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>.","pos":[20068,20258],"source":"Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Animation Overview<ept id=\"p1\">](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.","pos":[20259,20380],"source":" For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)."},{"content":"The following example defines a routed event by doing the following:","pos":[20387,20455]},{"pos":[20465,20585],"content":"Define a <ph id=\"ph1\">&lt;xref:System.Windows.RoutedEvent&gt;</ph> identifier named <ph id=\"ph2\">`ValueChangedEvent`</ph> as a <ph id=\"ph3\">`public`</ph> <ph id=\"ph4\">`static`</ph> <ph id=\"ph5\">`readonly`</ph> field.","source":"Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field."},{"content":"Register the routed event by calling the <ph id=\"ph1\">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=fullName&gt;</ph> method.","pos":[20595,20726],"source":"Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=fullName> method."},{"content":"The example specifies the following information when it calls <ph id=\"ph1\">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>:","pos":[20727,20847],"source":" The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:"},{"pos":[20861,20901],"content":"The name of the event is <ph id=\"ph1\">`ValueChanged`</ph>.","source":"The name of the event is `ValueChanged`."},{"content":"The routing strategy is <ph id=\"ph1\">&lt;xref:System.Windows.RoutingStrategy&gt;</ph>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.","pos":[20915,21222],"source":"The routing strategy is <xref:System.Windows.RoutingStrategy>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element."},{"content":"The type of the event handler is <ph id=\"ph1\">&lt;xref:System.Windows.RoutedPropertyChangedEventHandler%601&gt;</ph>, constructed with a <ph id=\"ph2\">&lt;xref:System.Decimal&gt;</ph> type.","pos":[21236,21376],"source":"The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type."},{"pos":[21390,21438],"content":"The owning type of the event is <ph id=\"ph1\">`NumericUpDown`</ph>.","source":"The owning type of the event is `NumericUpDown`."},{"content":"Declare a public event named <ph id=\"ph1\">`ValueChanged`</ph> and includes event-accessor declarations.","pos":[21448,21533],"source":"Declare a public event named `ValueChanged` and includes event-accessor declarations."},{"content":"The example calls <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph> in the <ph id=\"ph2\">`add`</ph> accessor declaration and <ph id=\"ph3\">&lt;xref:System.Windows.UIElement.RemoveHandler%2A&gt;</ph> in the <ph id=\"ph4\">`remove`</ph> accessor declaration to use the <ph id=\"ph5\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> event services.","pos":[21534,21830],"source":" The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services."},{"pos":[21840,21935],"content":"Create a protected, virtual method named <ph id=\"ph1\">`OnValueChanged`</ph> that raises the <ph id=\"ph2\">`ValueChanged`</ph> event.","source":"Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event."},{"pos":[21942,22292],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UserControlNumericUpDown#RoutedEvent<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>UserControlNumericUpDown#RoutedEvent<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]\n[!code-vb[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]"},{"pos":[22299,22532],"content":"For more information, see <bpt id=\"p1\">[</bpt>Routed Events Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept> and <bpt id=\"p2\">[</bpt>Create a Custom Routed Event<ept id=\"p2\">](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)</ept>.","source":"For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md) and [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)."},{"pos":[22542,22553],"content":"Use Binding","linkify":"Use Binding","nodes":[{"content":"Use Binding","pos":[0,11]}]},{"content":"To decouple the UI of your control from its logic, consider using data binding.","pos":[22557,22636]},{"content":"This is particularly important if you define the appearance of your control by using a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.","pos":[22637,22771],"source":" This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>."},{"content":"When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.","pos":[22772,22891]},{"content":"It's a good idea to avoid referencing elements that are in the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> because when the code references elements that are in the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> and the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is changed, the referenced element needs to be included in the new <ph id=\"ph4\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.","pos":[22892,23276],"source":" It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>."},{"pos":[23283,23457],"content":"The following example updates the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> of the <ph id=\"ph2\">`NumericUpDown`</ph> control, assigning a name to it and referencing the textbox by name in code.","source":"The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code."},{"pos":[23464,23641],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>UserControlNumericUpDownSimple#UIRefMarkup<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[UserControlNumericUpDownSimple#UIRefMarkup](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]"},{"pos":[23648,24014],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UserControlNumericUpDownSimple#UIRefCode<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>UserControlNumericUpDownSimple#UIRefCode<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]\n [!code-vb[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]"},{"content":"The following example uses binding to accomplish the same thing.","pos":[24021,24085]},{"pos":[24092,24249],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>UserControlNumericUpDown#Binding<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[UserControlNumericUpDown#Binding](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]"},{"pos":[24256,24387],"content":"For more information about data binding, see <bpt id=\"p1\">[</bpt>Data Binding Overview<ept id=\"p1\">](../../../../docs/framework/wpf/data/data-binding-overview.md)</ept>.","source":"For more information about data binding, see [Data Binding Overview](../../../../docs/framework/wpf/data/data-binding-overview.md)."},{"pos":[24397,24417],"content":"Design for Designers","linkify":"Design for Designers","nodes":[{"content":"Design for Designers","pos":[0,20]}]},{"content":"To receive support for custom WPF controls in the <ph id=\"ph1\">[!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)]</ph> (for example, property editing with the Properties window), follow these guidelines.","pos":[24421,24645],"source":"To receive support for custom WPF controls in the [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] (for example, property editing with the Properties window), follow these guidelines."},{"content":"For more information on developing for the <ph id=\"ph1\">[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>WPF Designer<ept id=\"p1\">](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26)</ept>.","pos":[24647,24872],"source":"  For more information on developing for the [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)], see [WPF Designer](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26)."},{"pos":[24883,24904],"content":"Dependency Properties","linkify":"Dependency Properties","nodes":[{"content":"Dependency Properties","pos":[0,21]}]},{"content":"Be sure to implement <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> <ph id=\"ph2\">`get`</ph> and <ph id=\"ph3\">`set`</ph> accessors as described earlier, in \"Use Dependency Properties.\"","pos":[24908,25078],"source":"Be sure to implement [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `get` and `set` accessors as described earlier, in \"Use Dependency Properties.\""},{"content":"Designers may use the wrapper to detect the presence of a dependency property, but they, like <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> and clients of the control, are not required to call the accessors when getting or setting the property.","pos":[25079,25359],"source":" Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property."},{"pos":[25370,25389],"content":"Attached Properties","linkify":"Attached Properties","nodes":[{"content":"Attached Properties","pos":[0,19]}]},{"content":"You should implement attached properties on custom controls using the following guidelines:","pos":[25393,25484]},{"content":"Have a <ph id=\"ph1\">`public`</ph> <ph id=\"ph2\">`static`</ph> <ph id=\"ph3\">`readonly`</ph> <ph id=\"ph4\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> of the form <bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept><ph id=\"ph5\">`Property`</ph> that was creating using the <ph id=\"ph6\">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method.","pos":[25494,25704],"source":"Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method."},{"content":"The property name that is passed to <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> must match <bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept>.","pos":[25705,25828],"source":" The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*."},{"content":"Implement a pair of <ph id=\"ph1\">`public`</ph> <ph id=\"ph2\">`static`</ph> CLR methods named <ph id=\"ph3\">`Set`</ph><bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> and <ph id=\"ph4\">`Get`</ph><bpt id=\"p2\">*</bpt>PropertyName<ept id=\"p2\">*</ept>.","pos":[25838,25938],"source":"Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*."},{"content":"Both methods should accept a class derived from <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as their first argument.","pos":[25939,26052],"source":" Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument."},{"content":"The <ph id=\"ph1\">`Set`</ph><bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> method also accepts an argument whose type matches the registered data type for the property.","pos":[26053,26170],"source":" The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property."},{"content":"The <ph id=\"ph1\">`Get`</ph><bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> method should return a value of the same type.","pos":[26171,26241],"source":" The `Get`*PropertyName* method should return a value of the same type."},{"content":"If the <ph id=\"ph1\">`Set`</ph><bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> method is missing, the property is marked read-only.","pos":[26242,26321],"source":" If the `Set`*PropertyName* method is missing, the property is marked read-only."},{"content":"<ph id=\"ph1\">`Set`</ph> <bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> and <ph id=\"ph2\">`Get`</ph><bpt id=\"p2\">*</bpt>PropertyName<ept id=\"p2\">*</ept> must route directly to the <ph id=\"ph3\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> methods on the target dependency object, respectively.","pos":[26331,26563],"source":"`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively."},{"content":"Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.","pos":[26564,26701]},{"pos":[26708,26861],"content":"For more information on attached properties, see <bpt id=\"p1\">[</bpt>Attached Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.","source":"For more information on attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)."},{"pos":[26871,26902],"content":"Define and Use Shared Resources","linkify":"Define and Use Shared Resources","nodes":[{"content":"Define and Use Shared Resources","pos":[0,31]}]},{"content":"You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.","pos":[26906,27074]},{"content":"For the most part, the information discussed in this topic applies regardless of the method you use.","pos":[27075,27175]},{"content":"There is one difference worth noting, however.","pos":[27177,27223]},{"content":"When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.","pos":[27225,27346]},{"content":"But an assembly that contains only controls does not have an <ph id=\"ph1\">&lt;xref:System.Windows.Application&gt;</ph> object associated with it, so an App.xaml file is not available.","pos":[27347,27506],"source":" But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available."},{"content":"When an application looks for a resource, it looks at three levels in the following order:","pos":[27513,27603]},{"content":"The element level.","pos":[27613,27631]},{"content":"The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.","pos":[27642,27803]},{"content":"The application level.","pos":[27813,27835]},{"content":"Resources defined by the <ph id=\"ph1\">&lt;xref:System.Windows.Application&gt;</ph> object.","pos":[27846,27912],"source":"Resources defined by the <xref:System.Windows.Application> object."},{"content":"The theme level.","pos":[27922,27938]},{"content":"Theme-level dictionaries are stored in a subfolder named Themes.","pos":[27949,28013]},{"content":"The files in the Themes folder correspond to themes.","pos":[28015,28067]},{"content":"For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.","pos":[28069,28178]},{"content":"You can also have a file named generic.xaml.","pos":[28180,28224]},{"content":"When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.","pos":[28226,28371]},{"content":"When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.","pos":[28378,28531]},{"content":"Both methods have their advantages.","pos":[28532,28567]},{"pos":[28578,28617],"content":"Defining Resources at the Element Level","linkify":"Defining Resources at the Element Level","nodes":[{"content":"Defining Resources at the Element Level","pos":[0,39]}]},{"content":"You can define shared resources at the element level by creating a custom resource dictionary and merging it with your controlâ€™s resource dictionary.","pos":[28621,28770]},{"content":"When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.","pos":[28772,28899]},{"content":"Resources at the element level can also use simple strings as keys.","pos":[28900,28967]},{"content":"The following example creates a <ph id=\"ph1\">&lt;xref:System.Windows.Media.LinearGradientBrush&gt;</ph> resource file named Dictionary1.xaml.","pos":[28968,29085],"source":" The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml."},{"pos":[29092,29213],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>SharedResources#1<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[SharedResources#1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]"},{"content":"Once you have defined your dictionary, you need to merge it with your control's resource dictionary.","pos":[29220,29320]},{"content":"You can do this by using <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> or code.","pos":[29322,29427],"source":"  You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code."},{"pos":[29434,29566],"content":"The following example merges a resource dictionary by using <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>.","source":"The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]."},{"pos":[29573,29695],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>SharedResources#2<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[SharedResources#2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]"},{"content":"The disadvantage to this approach is that a <ph id=\"ph1\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> object is created each time you reference it.","pos":[29702,29832],"source":"The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it."},{"content":"For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <ph id=\"ph1\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> objects.","pos":[29834,30042],"source":"  For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects."},{"content":"You can avoid this by creating a static class that merges the resources in code and returns the resulting <ph id=\"ph1\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.","pos":[30044,30191],"source":"  You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>."},{"content":"The following example creates a class that returns a shared <ph id=\"ph1\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.","pos":[30198,30299],"source":"The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>."},{"pos":[30306,30440],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SharedResources#3<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SharedResources#3](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]"},{"content":"The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls <ph id=\"ph1\">`InitilizeComponent`</ph>.","pos":[30447,30601],"source":"The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitilizeComponent`."},{"content":"Because the <ph id=\"ph1\">`SharedDictionaryManager.SharedDictionary`</ph> is a static property, the <ph id=\"ph2\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is created only once.","pos":[30603,30746],"source":"  Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once."},{"content":"Because the resource dictionary was merged before <ph id=\"ph1\">`InitializeComponent`</ph> was called, the resources are available to the control in its <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> file.","pos":[30747,30958],"source":" Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file."},{"pos":[30965,31093],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SharedResources#4<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SharedResources#4](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]"},{"pos":[31104,31141],"content":"Defining Resources at the Theme Level","linkify":"Defining Resources at the Theme Level","nodes":[{"content":"Defining Resources at the Theme Level","pos":[0,37]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> enables you to create resources for different Windows themes.","pos":[31145,31288],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables you to create resources for different Windows themes."},{"content":"As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.","pos":[31290,31428]},{"content":"For example, the appearance of a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> in the Windows Classic theme (the default theme for Windows 2000) differs from a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph> in the Windows Luna theme (the default theme for Windows XP) because the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Button&gt;</ph> uses a different <ph id=\"ph4\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> for each theme.","pos":[31429,31809],"source":" For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme."},{"content":"Resources that are specific to a theme are kept in a resource dictionary with a specific file name.","pos":[31816,31915]},{"content":"These files must be in a folder named <ph id=\"ph1\">`Themes`</ph> that is a subfolder of the folder that contains the control.","pos":[31916,32023],"source":" These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control."},{"content":"The following table lists the resource dictionary files and the theme that is associated with each file:","pos":[32024,32128]},{"content":"Resource dictionary file name","pos":[32135,32164]},{"content":"Windows theme","pos":[32165,32178]},{"content":"Classic Windows 9x/2000 look on Windows XP","pos":[32258,32300]},{"content":"Default blue theme on Windows XP","pos":[32329,32361]},{"content":"Olive theme on Windows XP","pos":[32388,32413]},{"content":"Silver theme on Windows XP","pos":[32439,32465]},{"content":"Default theme on Windows XP Media Center Edition","pos":[32496,32544]},{"content":"Default theme on Windows Vista","pos":[32573,32603]},{"content":"You do not need to define a resource for every theme.","pos":[32611,32664]},{"content":"If a resource is not defined for a specific theme, then the control checks <ph id=\"ph1\">`Classic.xaml`</ph> for the resource.","pos":[32665,32772],"source":" If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource."},{"content":"If the resource is not defined in the file that corresponds to the current theme or in <ph id=\"ph1\">`Classic.xaml`</ph>, the control uses the generic resource, which is in a resource dictionary file named <ph id=\"ph2\">`generic.xaml`</ph>.","pos":[32773,32975],"source":" If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`."},{"content":"The <ph id=\"ph1\">`generic.xaml`</ph> file is located in the same folder as the theme-specific resource dictionary files.","pos":[32977,33079],"source":"  The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files."},{"content":"Although <ph id=\"ph1\">`generic.xaml`</ph> does not correspond to a specific Windows theme, it is still a theme-level dictionary.","pos":[33080,33190],"source":" Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary."},{"content":"<bpt id=\"p1\">[</bpt>NumericUpDown Custom Control with Theme and UI Automation Support Sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=160025)</ept> contains two resource dictionaries for the <ph id=\"ph1\">`NumericUpDown`</ph> control: one is in generic.xaml and one is in Luna.NormalColor.xaml.","pos":[33197,33446],"source":"[NumericUpDown Custom Control with Theme and UI Automation Support Sample](http://go.microsoft.com/fwlink/?LinkID=160025) contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml and one is in Luna.NormalColor.xaml."},{"content":"You can run the application and switch between the Silver theme in Windows XP and another theme to see the difference between the two control templates.","pos":[33448,33600]},{"content":"(If you are running Windows Vista, you can rename Luna.NormalColor.xaml to Aero.NormalColor.xaml and switch between two themes, such as Windows Classic and the default theme for Windows Vista.)","pos":[33601,33794]},{"content":"When you put a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> method on the <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph>, as shown in the following example.","pos":[33801,34202],"source":"When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example."},{"pos":[34209,34621],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CustomControlNumericUpDownOneProject#StaticConstructor<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>CustomControlNumericUpDownOneProject#StaticConstructor<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]\n [!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]"},{"pos":[34633,34682],"content":"Defining and Referencing Keys for Theme Resources","linkify":"Defining and Referencing Keys for Theme Resources","nodes":[{"content":"Defining and Referencing Keys for Theme Resources","pos":[0,49]}]},{"content":"When you define a resource at the element level, you can assign a string as its key and access the resource via the string.","pos":[34686,34809]},{"content":"When you define a resource at the theme level, you must use a <ph id=\"ph1\">&lt;xref:System.Windows.ComponentResourceKey&gt;</ph> as the key.","pos":[34810,34926],"source":" When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key."},{"content":"The following example defines a resource in generic.xaml.","pos":[34928,34985]},{"pos":[34992,35142],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>ThemeResourcesControlLibrary#5<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[ThemeResourcesControlLibrary#5](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]"},{"content":"The following example references the resource by specifying the <ph id=\"ph1\">&lt;xref:System.Windows.ComponentResourceKey&gt;</ph> as the key.","pos":[35149,35267],"source":"The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key."},{"pos":[35274,35423],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>ThemeResourcesControlLibrary#6<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[ThemeResourcesControlLibrary#6](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]"},{"pos":[35435,35477],"content":"Specifying the Location of Theme Resources","linkify":"Specifying the Location of Theme Resources","nodes":[{"content":"Specifying the Location of Theme Resources","pos":[0,42]}]},{"content":"To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.","pos":[35481,35610]},{"content":"You can accomplish that by adding the <ph id=\"ph1\">&lt;xref:System.Windows.ThemeInfoAttribute&gt;</ph> to the assembly that contains the control.","pos":[35611,35732],"source":" You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.ThemeInfoAttribute&gt;</ph> has a <ph id=\"ph2\">&lt;xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A&gt;</ph> property that specifies the location of generic resources, and a <ph id=\"ph3\">&lt;xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A&gt;</ph> property that specifies the location of the theme-specific resources.","pos":[35733,36056],"source":" The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources."},{"content":"The following example sets the <ph id=\"ph1\">&lt;xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A&gt;</ph> properties to <ph id=\"ph3\">&lt;xref:System.Windows.ResourceDictionaryLocation&gt;</ph>, to specify that the generic and theme-specific resources are in the same assembly as the control.","pos":[36063,36397],"source":"The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation>, to specify that the generic and theme-specific resources are in the same assembly as the control."},{"pos":[36404,36822],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CustomControlNumericUpDown#ThemesSection<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>CustomControlNumericUpDown#ThemesSection<ept id=\"p4\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]\n [!code-vb[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]"},{"pos":[36831,36839],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>WPF Designer<ept id=\"p1\">](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26)</ept><ph id=\"ph1\"> </ph>","pos":[36843,36928],"source":"[WPF Designer](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26) "},{"content":"<bpt id=\"p1\">[</bpt>Pack URIs in WPF<ept id=\"p1\">](../../../../docs/framework/wpf/app-development/pack-uris-in-wpf.md)</ept><ph id=\"ph1\"> </ph>","pos":[36932,37019],"source":"[Pack URIs in WPF](../../../../docs/framework/wpf/app-development/pack-uris-in-wpf.md) "},{"content":"<bpt id=\"p1\">[</bpt>Control Customization<ept id=\"p1\">](../../../../docs/framework/wpf/controls/control-customization.md)</ept>","pos":[37023,37112],"source":"[Control Customization](../../../../docs/framework/wpf/controls/control-customization.md)"}]}