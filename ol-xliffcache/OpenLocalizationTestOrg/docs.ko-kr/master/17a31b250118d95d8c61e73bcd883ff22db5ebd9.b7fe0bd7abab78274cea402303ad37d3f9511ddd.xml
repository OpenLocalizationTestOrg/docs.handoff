{"content":"---\ntitle: \"Making an Image Easier to Debug | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"images [.NET Framework], debugging\"\n  - \"executable image for debugging\"\n  - \"debugging [.NET Framework], executable images for\"\nms.assetid: 7d90ea7a-150f-4f97-98a7-f9c26541b9a3\ncaps.latest.revision: 13\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# Making an Image Easier to Debug\nWhen compiling unmanaged code, you can configure an executable image for debugging by setting IDE switches or command-line options. For example, you can use the /**Zi** command-line option in Visual C++ to ask it to emit debug symbol files (file extension .pdb). Similarly, the /**Od** command-line option tells the compiler to disable optimization. The resulting code runs more slowly, but is easier to debug, should this be necessary.  \n  \n When compiling .NET Framework managed code, compilers such as Visual C++, Visual Basic, and C# compile their source program into Microsoft Intermediate Language (MSIL). MSIL is subsequently JIT-compiled, just before execution, into native machine code. As with unmanaged code, you can configure an executable image for debugging by setting IDE switches or command-line options. In addition, you can configure the JIT compilation for debugging in much the same way.  \n  \n This JIT configuration has two aspects:  \n  \n-   You can request the JIT-compiler to generate tracking information. This makes it possible for the debugger to match up a chain of MSIL with its machine code counterpart, and to track where local variables and function arguments are stored.  In the .NET Framework version 2.0, the JIT compiler will always generate tracking information, so there is no need to request it.  \n  \n-   You can request the JIT-compiler to not optimize the resulting machine code.  \n  \n Normally, the compiler that generates the MSIL sets these JIT-compiler options appropriately, based upon the IDE switches or command-line options you specify, for example, /**Od**.  \n  \n In some cases, you might want to change the behavior of the JIT compiler so that the machine code it generates is easier to debug. For example, you might want to generate JIT tracking information for a retail build or control optimization. You can do so with an initialization (.ini) file.  \n  \n For example, if the assembly you want to debug is called MyApp.exe, then you can create a text file named MyApp.ini, in the same folder as MyApp.exe, which contains these three lines:  \n  \n```  \n[.NET Framework Debugging Control]  \nGenerateTrackingInfo=1  \nAllowOptimize=0  \n```  \n  \n You can set the value of each option to 0 or 1, and any absent option defaults to 0. Setting `GenerateTrackingInfo` to 1 and `AllowOptimize` to 0 provides the easiest debugging.  \n  \n> [!NOTE]\n>  In the .NET Framework version 2.0, the JIT compiler always generates tracking information regardless of the value for `GenerateTrackingInfo`; however, the `AllowOptimize` value still has an effect. When using the [Ngen.exe (Native Image Generator)](../../../docs/framework/tools/ngen-exe-native-image-generator.md) to precompile the native image without optimization, the .ini file must be present in the target folder with `AllowOptimize=0` when Ngen.exe executes. If you have precompiled an assembly without optimization, you must remove the precompiled code using the NGen.exe **/uninstall** option before rerunning Ngen.exe to precompile the code as optimized. If the .ini file is not present in the folder, by default Ngen.exe precompiles the code as optimized.  \n  \n> [!NOTE]\n>  The <xref:System.Diagnostics.DebuggableAttribute?displayProperty=fullName> controls the settings for an assembly. **DebuggableAttribute** includes two fields that record the settings for whether the JIT compiler should optimize, and/or generate tracking information. In the .NET Framework version 2.0, the JIT compiler will always generate tracking information.  \n  \n> [!NOTE]\n>  For a retail build, compilers do not set any **DebuggableAttribute**. The JIT-compiler default behavior is to generate the highest performance, hardest to debug machine code. Enabling JIT tracking lowers performance a little, and disabling optimization lowers performance a lot.  \n  \n> [!NOTE]\n>  The **DebuggableAttribute** applies to a whole assembly at a time, not to individual modules within the assembly. Development tools must therefore attach custom attributes to the assembly metadata token, if an assembly has already been created, or to the class called **System.Runtime.CompilerServices.AssemblyAttributesGoHere**. The ALink tool will then promote these **DebuggableAttribute** attributes from each module to the assembly they become a part of. If there is a conflict, the ALink operation will fail.  \n  \n> [!NOTE]\n>  In version 1.0 of the .NET Framework, the Microsoft Visual C++ compiler adds the **DebuggableAttribute** when the **/clr** and **/Zi** compiler options are specified. In version 1.1 of the .NET Framework, you must either add the **DebugabbleAttribute** manually in your code or use the **/ASSEMBLYDEBUG** linker option.  \n  \n## See Also  \n [Debugging, Tracing, and Profiling](../../../docs/framework/debug-trace-profile/index.md)   \n [Enabling JIT-Attach Debugging](../../../docs/framework/debug-trace-profile/enabling-jit-attach-debugging.md)   \n [Enabling Profiling](http://msdn.microsoft.com/en-us/3b669676-f0e0-4ebf-8674-68986dd2020d)","nodes":[{"pos":[4,567],"nodes":[{"content":"Making an Image Easier to Debug | Microsoft Docs","nodes":[{"pos":[0,48],"content":"Making an Image Easier to Debug | Microsoft Docs","nodes":[{"content":"Making an Image Easier to Debug | Microsoft Docs","pos":[0,48]}]}],"pos":[6,57],"yaml":true}],"content":"title: \"Making an Image Easier to Debug | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"images [.NET Framework], debugging\"\n  - \"executable image for debugging\"\n  - \"debugging [.NET Framework], executable images for\"\nms.assetid: 7d90ea7a-150f-4f97-98a7-f9c26541b9a3\ncaps.latest.revision: 13\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","yamlblock":true},{"pos":[574,605],"content":"Making an Image Easier to Debug","linkify":"Making an Image Easier to Debug","nodes":[{"content":"Making an Image Easier to Debug","pos":[0,31]}]},{"content":"When compiling unmanaged code, you can configure an executable image for debugging by setting IDE switches or command-line options.","pos":[606,737]},{"content":"For example, you can use the /<bpt id=\"p1\">**</bpt>Zi<ept id=\"p1\">**</ept> command-line option in Visual C++ to ask it to emit debug symbol files (file extension .pdb).","pos":[738,868],"source":" For example, you can use the /**Zi** command-line option in Visual C++ to ask it to emit debug symbol files (file extension .pdb)."},{"content":"Similarly, the /<bpt id=\"p1\">**</bpt>Od<ept id=\"p1\">**</ept> command-line option tells the compiler to disable optimization.","pos":[869,955],"source":" Similarly, the /**Od** command-line option tells the compiler to disable optimization."},{"content":"The resulting code runs more slowly, but is easier to debug, should this be necessary.","pos":[956,1042]},{"content":"When compiling .NET Framework managed code, compilers such as Visual C++, Visual Basic, and C# compile their source program into Microsoft Intermediate Language (MSIL).","pos":[1049,1217]},{"content":"MSIL is subsequently JIT-compiled, just before execution, into native machine code.","pos":[1218,1301]},{"content":"As with unmanaged code, you can configure an executable image for debugging by setting IDE switches or command-line options.","pos":[1302,1426]},{"content":"In addition, you can configure the JIT compilation for debugging in much the same way.","pos":[1427,1513]},{"content":"This JIT configuration has two aspects:","pos":[1520,1559]},{"content":"You can request the JIT-compiler to generate tracking information.","pos":[1569,1635]},{"content":"This makes it possible for the debugger to match up a chain of MSIL with its machine code counterpart, and to track where local variables and function arguments are stored.","pos":[1636,1808]},{"content":"In the .NET Framework version 2.0, the JIT compiler will always generate tracking information, so there is no need to request it.","pos":[1810,1939]},{"content":"You can request the JIT-compiler to not optimize the resulting machine code.","pos":[1949,2025]},{"pos":[2032,2212],"content":"Normally, the compiler that generates the MSIL sets these JIT-compiler options appropriately, based upon the IDE switches or command-line options you specify, for example, /<bpt id=\"p1\">**</bpt>Od<ept id=\"p1\">**</ept>.","source":"Normally, the compiler that generates the MSIL sets these JIT-compiler options appropriately, based upon the IDE switches or command-line options you specify, for example, /**Od**."},{"content":"In some cases, you might want to change the behavior of the JIT compiler so that the machine code it generates is easier to debug.","pos":[2219,2349]},{"content":"For example, you might want to generate JIT tracking information for a retail build or control optimization.","pos":[2350,2458]},{"content":"You can do so with an initialization (.ini) file.","pos":[2459,2508]},{"content":"For example, if the assembly you want to debug is called MyApp.exe, then you can create a text file named MyApp.ini, in the same folder as MyApp.exe, which contains these three lines:","pos":[2515,2698]},{"content":"You can set the value of each option to 0 or 1, and any absent option defaults to 0.","pos":[2800,2884]},{"content":"Setting <ph id=\"ph1\">`GenerateTrackingInfo`</ph> to 1 and <ph id=\"ph2\">`AllowOptimize`</ph> to 0 provides the easiest debugging.","pos":[2885,2977],"source":" Setting `GenerateTrackingInfo` to 1 and `AllowOptimize` to 0 provides the easiest debugging."},{"pos":[2985,3762],"content":"[!NOTE]\n In the .NET Framework version 2.0, the JIT compiler always generates tracking information regardless of the value for `GenerateTrackingInfo`; however, the `AllowOptimize` value still has an effect. When using the [Ngen.exe (Native Image Generator)](../../../docs/framework/tools/ngen-exe-native-image-generator.md) to precompile the native image without optimization, the .ini file must be present in the target folder with `AllowOptimize=0` when Ngen.exe executes. If you have precompiled an assembly without optimization, you must remove the precompiled code using the NGen.exe **/uninstall** option before rerunning Ngen.exe to precompile the code as optimized. If the .ini file is not present in the folder, by default Ngen.exe precompiles the code as optimized.","leadings":["","> "],"nodes":[{"content":"In the .NET Framework version 2.0, the JIT compiler always generates tracking information regardless of the value for `GenerateTrackingInfo`; however, the `AllowOptimize` value still has an effect. When using the [Ngen.exe (Native Image Generator)](../../../docs/framework/tools/ngen-exe-native-image-generator.md) to precompile the native image without optimization, the .ini file must be present in the target folder with `AllowOptimize=0` when Ngen.exe executes. If you have precompiled an assembly without optimization, you must remove the precompiled code using the NGen.exe **/uninstall** option before rerunning Ngen.exe to precompile the code as optimized. If the .ini file is not present in the folder, by default Ngen.exe precompiles the code as optimized.","pos":[9,775],"nodes":[{"content":"In the .NET Framework version 2.0, the JIT compiler always generates tracking information regardless of the value for <ph id=\"ph1\">`GenerateTrackingInfo`</ph>; however, the <ph id=\"ph2\">`AllowOptimize`</ph> value still has an effect.","pos":[0,197],"source":"In the .NET Framework version 2.0, the JIT compiler always generates tracking information regardless of the value for `GenerateTrackingInfo`; however, the `AllowOptimize` value still has an effect."},{"content":"When using the <bpt id=\"p1\">[</bpt>Ngen.exe (Native Image Generator)<ept id=\"p1\">](../../../docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to precompile the native image without optimization, the .ini file must be present in the target folder with <ph id=\"ph1\">`AllowOptimize=0`</ph> when Ngen.exe executes.","pos":[198,465],"source":" When using the [Ngen.exe (Native Image Generator)](../../../docs/framework/tools/ngen-exe-native-image-generator.md) to precompile the native image without optimization, the .ini file must be present in the target folder with `AllowOptimize=0` when Ngen.exe executes."},{"content":"If you have precompiled an assembly without optimization, you must remove the precompiled code using the NGen.exe <bpt id=\"p1\">**</bpt>/uninstall<ept id=\"p1\">**</ept> option before rerunning Ngen.exe to precompile the code as optimized.","pos":[466,664],"source":" If you have precompiled an assembly without optimization, you must remove the precompiled code using the NGen.exe **/uninstall** option before rerunning Ngen.exe to precompile the code as optimized."},{"content":"If the .ini file is not present in the folder, by default Ngen.exe precompiles the code as optimized.","pos":[665,766]}]}]},{"pos":[3770,4142],"content":"[!NOTE]\n The <xref:System.Diagnostics.DebuggableAttribute?displayProperty=fullName> controls the settings for an assembly. **DebuggableAttribute** includes two fields that record the settings for whether the JIT compiler should optimize, and/or generate tracking information. In the .NET Framework version 2.0, the JIT compiler will always generate tracking information.","leadings":["","> "],"nodes":[{"content":"The <xref:System.Diagnostics.DebuggableAttribute?displayProperty=fullName> controls the settings for an assembly. **DebuggableAttribute** includes two fields that record the settings for whether the JIT compiler should optimize, and/or generate tracking information. In the .NET Framework version 2.0, the JIT compiler will always generate tracking information.","pos":[9,370],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Diagnostics.DebuggableAttribute?displayProperty=fullName&gt;</ph> controls the settings for an assembly.","pos":[0,113],"source":"The <xref:System.Diagnostics.DebuggableAttribute?displayProperty=fullName> controls the settings for an assembly."},{"content":"<bpt id=\"p1\">**</bpt>DebuggableAttribute<ept id=\"p1\">**</ept> includes two fields that record the settings for whether the JIT compiler should optimize, and/or generate tracking information.","pos":[114,266],"source":"**DebuggableAttribute** includes two fields that record the settings for whether the JIT compiler should optimize, and/or generate tracking information."},{"content":"In the .NET Framework version 2.0, the JIT compiler will always generate tracking information.","pos":[267,361]}]}]},{"pos":[4150,4439],"content":"[!NOTE]\n For a retail build, compilers do not set any **DebuggableAttribute**. The JIT-compiler default behavior is to generate the highest performance, hardest to debug machine code. Enabling JIT tracking lowers performance a little, and disabling optimization lowers performance a lot.","leadings":["","> "],"nodes":[{"content":"For a retail build, compilers do not set any **DebuggableAttribute**. The JIT-compiler default behavior is to generate the highest performance, hardest to debug machine code. Enabling JIT tracking lowers performance a little, and disabling optimization lowers performance a lot.","pos":[9,287],"nodes":[{"content":"For a retail build, compilers do not set any <bpt id=\"p1\">**</bpt>DebuggableAttribute<ept id=\"p1\">**</ept>.","pos":[0,69],"source":"For a retail build, compilers do not set any **DebuggableAttribute**."},{"content":"The JIT-compiler default behavior is to generate the highest performance, hardest to debug machine code.","pos":[70,174]},{"content":"Enabling JIT tracking lowers performance a little, and disabling optimization lowers performance a lot.","pos":[175,278]}]}]},{"pos":[4447,4972],"content":"[!NOTE]\n The **DebuggableAttribute** applies to a whole assembly at a time, not to individual modules within the assembly. Development tools must therefore attach custom attributes to the assembly metadata token, if an assembly has already been created, or to the class called **System.Runtime.CompilerServices.AssemblyAttributesGoHere**. The ALink tool will then promote these **DebuggableAttribute** attributes from each module to the assembly they become a part of. If there is a conflict, the ALink operation will fail.","leadings":["","> "],"nodes":[{"content":"The **DebuggableAttribute** applies to a whole assembly at a time, not to individual modules within the assembly. Development tools must therefore attach custom attributes to the assembly metadata token, if an assembly has already been created, or to the class called **System.Runtime.CompilerServices.AssemblyAttributesGoHere**. The ALink tool will then promote these **DebuggableAttribute** attributes from each module to the assembly they become a part of. If there is a conflict, the ALink operation will fail.","pos":[9,523],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>DebuggableAttribute<ept id=\"p1\">**</ept> applies to a whole assembly at a time, not to individual modules within the assembly.","pos":[0,113],"source":"The **DebuggableAttribute** applies to a whole assembly at a time, not to individual modules within the assembly."},{"content":"Development tools must therefore attach custom attributes to the assembly metadata token, if an assembly has already been created, or to the class called <bpt id=\"p1\">**</bpt>System.Runtime.CompilerServices.AssemblyAttributesGoHere<ept id=\"p1\">**</ept>.","pos":[114,329],"source":" Development tools must therefore attach custom attributes to the assembly metadata token, if an assembly has already been created, or to the class called **System.Runtime.CompilerServices.AssemblyAttributesGoHere**."},{"content":"The ALink tool will then promote these <bpt id=\"p1\">**</bpt>DebuggableAttribute<ept id=\"p1\">**</ept> attributes from each module to the assembly they become a part of.","pos":[330,459],"source":" The ALink tool will then promote these **DebuggableAttribute** attributes from each module to the assembly they become a part of."},{"content":"If there is a conflict, the ALink operation will fail.","pos":[460,514]}]}]},{"pos":[4980,5310],"content":"[!NOTE]\n In version 1.0 of the .NET Framework, the Microsoft Visual C++ compiler adds the **DebuggableAttribute** when the **/clr** and **/Zi** compiler options are specified. In version 1.1 of the .NET Framework, you must either add the **DebugabbleAttribute** manually in your code or use the **/ASSEMBLYDEBUG** linker option.","leadings":["","> "],"nodes":[{"content":"In version 1.0 of the .NET Framework, the Microsoft Visual C++ compiler adds the **DebuggableAttribute** when the **/clr** and **/Zi** compiler options are specified. In version 1.1 of the .NET Framework, you must either add the **DebugabbleAttribute** manually in your code or use the **/ASSEMBLYDEBUG** linker option.","pos":[9,328],"nodes":[{"content":"In version 1.0 of the .NET Framework, the Microsoft Visual C++ compiler adds the <bpt id=\"p1\">**</bpt>DebuggableAttribute<ept id=\"p1\">**</ept> when the <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>/Zi<ept id=\"p3\">**</ept> compiler options are specified.","pos":[0,166],"source":"In version 1.0 of the .NET Framework, the Microsoft Visual C++ compiler adds the **DebuggableAttribute** when the **/clr** and **/Zi** compiler options are specified."},{"content":"In version 1.1 of the .NET Framework, you must either add the <bpt id=\"p1\">**</bpt>DebugabbleAttribute<ept id=\"p1\">**</ept> manually in your code or use the <bpt id=\"p2\">**</bpt>/ASSEMBLYDEBUG<ept id=\"p2\">**</ept> linker option.","pos":[167,319],"source":" In version 1.1 of the .NET Framework, you must either add the **DebugabbleAttribute** manually in your code or use the **/ASSEMBLYDEBUG** linker option."}]}]},{"pos":[5319,5327],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Debugging, Tracing, and Profiling<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5331,5421],"source":"[Debugging, Tracing, and Profiling](../../../docs/framework/debug-trace-profile/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Enabling JIT-Attach Debugging<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/enabling-jit-attach-debugging.md)</ept><ph id=\"ph1\"> </ph>","pos":[5425,5535],"source":"[Enabling JIT-Attach Debugging](../../../docs/framework/debug-trace-profile/enabling-jit-attach-debugging.md) "},{"content":"<bpt id=\"p1\">[</bpt>Enabling Profiling<ept id=\"p1\">](http://msdn.microsoft.com/en-us/3b669676-f0e0-4ebf-8674-68986dd2020d)</ept>","pos":[5539,5629],"source":"[Enabling Profiling](http://msdn.microsoft.com/en-us/3b669676-f0e0-4ebf-8674-68986dd2020d)"}]}