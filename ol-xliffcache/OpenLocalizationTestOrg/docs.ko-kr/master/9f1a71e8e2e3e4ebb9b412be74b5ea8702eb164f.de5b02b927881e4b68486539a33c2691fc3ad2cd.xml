{"content":"---\ntitle: \"Widening and Narrowing Conversions (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"widening conversions [Visual Basic]\"\n  - \"narrowing conversions [Visual Basic]\"\n  - \"conversions [Visual Basic], type\"\n  - \"data types [Visual Basic], changing\"\n  - \"variables [Visual Basic], changing data type\"\n  - \"conversions [Visual Basic], exceptions during conversion\"\n  - \"type conversion [Visual Basic], exceptions during conversion\"\n  - \"conversions [Visual Basic], data type\"\n  - \"conversions [Visual Basic], narrowing\"\n  - \"type conversion [Visual Basic], narrowing\"\n  - \"data type conversion [Visual Basic], widening\"\n  - \"data type conversion [Visual Basic], narrowing\"\n  - \"changing data types [Visual Basic]\"\n  - \"type conversion [Visual Basic], widening\"\n  - \"data type conversion [Visual Basic], exceptions during conversion\"\n  - \"conversions [Visual Basic], widening\"\nms.assetid: 058c3152-6c28-4268-af44-2209e774f0bd\n---\n# Widening and Narrowing Conversions (Visual Basic)\nAn important consideration with a type conversion is whether the result of the conversion is within the range of the destination data type.  \n  \n A *widening conversion* changes a value to a data type that can allow for any possible value of the original data.  Widening conversions preserve the source value but can change its representation. This occurs if you convert from an integral type to `Decimal`, or from `Char` to `String`.  \n  \n A *narrowing conversion* changes a value to a data type that might not be able to hold some of the possible values. For example, a fractional value is rounded when it is converted to an integral type, and a numeric type being converted to `Boolean` is reduced to either `True` or `False`.  \n  \n## Widening Conversions  \n The following table shows the standard widening conversions.  \n  \n|Data type|Widens to data types <sup>1</sup>|  \n|---|---|  \n|[SByte](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md)|`SByte`, `Short`, `Integer`, `Long`, `Decimal`, `Single`, `Double`|  \n|[Byte](../../../../visual-basic/language-reference/data-types/byte-data-type.md)|`Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, `ULong`, `Decimal`, `Single`, `Double`|  \n|[Short](../../../../visual-basic/language-reference/data-types/short-data-type.md)|`Short`, `Integer`, `Long`, `Decimal`, `Single`, `Double`|  \n|[UShort](../../../../visual-basic/language-reference/data-types/ushort-data-type.md)|`UShort`, `Integer`, `UInteger`, `Long`, `ULong`, `Decimal`, `Single`, `Double`|  \n|[Integer](../../../../visual-basic/language-reference/data-types/integer-data-type.md)|`Integer`, `Long`, `Decimal`, `Single`, `Double`<sup>2</sup>|  \n|[UInteger](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md)|`UInteger`, `Long`, `ULong`, `Decimal`, `Single`, `Double`<sup>2</sup>|  \n|[Long](../../../../visual-basic/language-reference/data-types/long-data-type.md)|`Long`, `Decimal`, `Single`, `Double`<sup>2</sup>|  \n|[ULong](../../../../visual-basic/language-reference/data-types/ulong-data-type.md)|`ULong`, `Decimal`, `Single`, `Double`<sup>2</sup>|  \n|[Decimal](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)|`Decimal`, `Single`, `Double`<sup>2</sup>|  \n|[Single](../../../../visual-basic/language-reference/data-types/single-data-type.md)|`Single`, `Double`|  \n|[Double](../../../../visual-basic/language-reference/data-types/double-data-type.md)|`Double`|  \n|Any enumerated type ([Enum](../../../../visual-basic/language-reference/statements/enum-statement.md))|Its underlying integral type and any type to which the underlying type widens.|  \n|[Char](../../../../visual-basic/language-reference/data-types/char-data-type.md)|`Char`, `String`|  \n|`Char` array|`Char` array, `String`|  \n|Any type|[Object](../../../../visual-basic/language-reference/data-types/object-data-type.md)|  \n|Any derived type|Any base type from which it is derived <sup>3</sup>.|  \n|Any type|Any interface it implements.|  \n|[Nothing](../../../../visual-basic/language-reference/nothing.md)|Any data type or object type.|  \n  \n <sup>1</sup> By definition, every data type widens to itself.  \n  \n <sup>2</sup> Conversions from `Integer`, `UInteger`, `Long`, `ULong`, or `Decimal` to `Single` or `Double` might result in loss of precision, but never in loss of magnitude. In this sense they do not incur information loss.  \n  \n <sup>3</sup> It might seem surprising that a conversion from a derived type to one of its base types is widening. The justification is that the derived type contains all the members of the base type, so it qualifies as an instance of the base type. In the opposite direction, the base type does not contain any new members defined by the derived type.  \n  \n Widening conversions always succeed at run time and never incur data loss. You can always perform them implicitly, whether the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) sets the type checking switch to `On` or to `Off`.  \n  \n## Narrowing Conversions  \n The standard narrowing conversions include the following:  \n  \n-   The reverse directions of the widening conversions in the preceding table (except that every type widens to itself)  \n  \n-   Conversions in either direction between [Boolean](../../../../visual-basic/language-reference/data-types/boolean-data-type.md) and any numeric type  \n  \n-   Conversions from any numeric type to any enumerated type (`Enum`)  \n  \n-   Conversions in either direction between [String](../../../../visual-basic/language-reference/data-types/string-data-type.md) and any numeric type, `Boolean`, or [Date](../../../../visual-basic/language-reference/data-types/date-data-type.md)  \n  \n-   Conversions from a data type or object type to a type derived from it  \n  \n Narrowing conversions do not always succeed at run time, and can fail or incur data loss. An error occurs if the destination data type cannot receive the value being converted. For example, a numeric conversion can result in an overflow. The compiler does not allow you to perform narrowing conversions implicitly unless the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) sets the type checking switch to `Off`.  \n  \n> [!NOTE]\n>  The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).  \n  \n### When to Use Narrowing Conversions  \n You use a narrowing conversion when you know the source value can be converted to the destination data type without error or data loss. For example, if you have a `String` that you know contains either \"True\" or \"False,\" you can use the `CBool` keyword to convert it to `Boolean`.  \n  \n## Exceptions During Conversion  \n Because widening conversions always succeed, they do not throw exceptions. Narrowing conversions, when they fail, most commonly throw the following exceptions:  \n  \n-   <xref:System.InvalidCastException> — if no conversion is defined between the two types  \n  \n-   <xref:System.OverflowException> — (integral types only) if the converted value is too large for the target type  \n  \n If a class or structure defines a [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md) to serve as a conversion operator to or from that class or structure, that `CType` can throw any exception it deems appropriate. In addition, that `CType` might call Visual Basic functions or [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] methods, which in turn could throw a variety of exceptions.  \n  \n## Changes During Reference Type Conversions  \n A conversion from a *reference type* copies only the pointer to the value. The value itself is neither copied nor changed in any way. The only thing that can change is the data type of the variable holding the pointer. In the following example, the data type is converted from the derived class to its base class, but the object that both variables now point to is unchanged.  \n  \n```  \n' Assume class cSquare inherits from class cShape.  \nDim shape As cShape  \nDim square As cSquare = New cSquare  \n' The following statement performs a widening  \n' conversion from a derived class to its base class.  \nshape = square  \n```  \n  \n## See also\n\n- [Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md)\n- [Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)\n- [Implicit and Explicit Conversions](../../../../visual-basic/programming-guide/language-features/data-types/implicit-and-explicit-conversions.md)\n- [Conversions Between Strings and Other Types](../../../../visual-basic/programming-guide/language-features/data-types/conversions-between-strings-and-other-types.md)\n- [How to: Convert an Object to Another Type in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/how-to-convert-an-object-to-another-type.md)\n- [Array Conversions](../../../../visual-basic/programming-guide/language-features/data-types/array-conversions.md)\n- [Data Types](../../../../visual-basic/language-reference/data-types/index.md)\n- [Type Conversion Functions](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)\n","nodes":[{"pos":[4,944],"embed":true,"restype":"x-metadata","content":"title: \"Widening and Narrowing Conversions (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"widening conversions [Visual Basic]\"\n  - \"narrowing conversions [Visual Basic]\"\n  - \"conversions [Visual Basic], type\"\n  - \"data types [Visual Basic], changing\"\n  - \"variables [Visual Basic], changing data type\"\n  - \"conversions [Visual Basic], exceptions during conversion\"\n  - \"type conversion [Visual Basic], exceptions during conversion\"\n  - \"conversions [Visual Basic], data type\"\n  - \"conversions [Visual Basic], narrowing\"\n  - \"type conversion [Visual Basic], narrowing\"\n  - \"data type conversion [Visual Basic], widening\"\n  - \"data type conversion [Visual Basic], narrowing\"\n  - \"changing data types [Visual Basic]\"\n  - \"type conversion [Visual Basic], widening\"\n  - \"data type conversion [Visual Basic], exceptions during conversion\"\n  - \"conversions [Visual Basic], widening\"\nms.assetid: 058c3152-6c28-4268-af44-2209e774f0bd","nodes":[{"content":"Widening and Narrowing Conversions (Visual Basic)","nodes":[{"pos":[0,49],"content":"Widening and Narrowing Conversions (Visual Basic)","nodes":[{"content":"Widening and Narrowing Conversions (Visual Basic)","pos":[0,49]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[951,1000],"content":"Widening and Narrowing Conversions (Visual Basic)","linkify":"Widening and Narrowing Conversions (Visual Basic)","nodes":[{"content":"Widening and Narrowing Conversions (Visual Basic)","pos":[0,49]}]},{"content":"An important consideration with a type conversion is whether the result of the conversion is within the range of the destination data type.","pos":[1001,1140]},{"content":"A <bpt id=\"p1\">*</bpt>widening conversion<ept id=\"p1\">*</ept> changes a value to a data type that can allow for any possible value of the original data.","pos":[1147,1261],"source":"A *widening conversion* changes a value to a data type that can allow for any possible value of the original data."},{"content":"Widening conversions preserve the source value but can change its representation.","pos":[1263,1344]},{"content":"This occurs if you convert from an integral type to <ph id=\"ph1\">`Decimal`</ph>, or from <ph id=\"ph2\">`Char`</ph> to <ph id=\"ph3\">`String`</ph>.","pos":[1345,1435],"source":" This occurs if you convert from an integral type to `Decimal`, or from `Char` to `String`."},{"content":"A <bpt id=\"p1\">*</bpt>narrowing conversion<ept id=\"p1\">*</ept> changes a value to a data type that might not be able to hold some of the possible values.","pos":[1442,1557],"source":"A *narrowing conversion* changes a value to a data type that might not be able to hold some of the possible values."},{"content":"For example, a fractional value is rounded when it is converted to an integral type, and a numeric type being converted to <ph id=\"ph1\">`Boolean`</ph> is reduced to either <ph id=\"ph2\">`True`</ph> or <ph id=\"ph3\">`False`</ph>.","pos":[1558,1730],"source":" For example, a fractional value is rounded when it is converted to an integral type, and a numeric type being converted to `Boolean` is reduced to either `True` or `False`."},{"pos":[1739,1759],"content":"Widening Conversions","linkify":"Widening Conversions","nodes":[{"content":"Widening Conversions","pos":[0,20]}]},{"content":"The following table shows the standard widening conversions.","pos":[1763,1823]},{"content":"Data type","pos":[1830,1839]},{"pos":[1840,1873],"content":"Widens to data types <bpt id=\"p1\">&lt;sup&gt;</bpt>1<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"Widens to data types <sup>1</sup>"},{"pos":[1890,1972],"content":"<bpt id=\"p1\">[</bpt>SByte<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md)</ept>","source":"[SByte](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md)"},{"pos":[1973,2039],"content":"<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Short`</ph>, <ph id=\"ph3\">`Integer`</ph>, <ph id=\"ph4\">`Long`</ph>, <ph id=\"ph5\">`Decimal`</ph>, <ph id=\"ph6\">`Single`</ph>, <ph id=\"ph7\">`Double`</ph>","source":"`SByte`, `Short`, `Integer`, `Long`, `Decimal`, `Single`, `Double`"},{"pos":[2044,2124],"content":"<bpt id=\"p1\">[</bpt>Byte<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/byte-data-type.md)</ept>","source":"[Byte](../../../../visual-basic/language-reference/data-types/byte-data-type.md)"},{"pos":[2125,2221],"content":"<ph id=\"ph1\">`Byte`</ph>, <ph id=\"ph2\">`Short`</ph>, <ph id=\"ph3\">`UShort`</ph>, <ph id=\"ph4\">`Integer`</ph>, <ph id=\"ph5\">`UInteger`</ph>, <ph id=\"ph6\">`Long`</ph>, <ph id=\"ph7\">`ULong`</ph>, <ph id=\"ph8\">`Decimal`</ph>, <ph id=\"ph9\">`Single`</ph>, <ph id=\"ph10\">`Double`</ph>","source":"`Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, `ULong`, `Decimal`, `Single`, `Double`"},{"pos":[2226,2308],"content":"<bpt id=\"p1\">[</bpt>Short<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/short-data-type.md)</ept>","source":"[Short](../../../../visual-basic/language-reference/data-types/short-data-type.md)"},{"pos":[2309,2366],"content":"<ph id=\"ph1\">`Short`</ph>, <ph id=\"ph2\">`Integer`</ph>, <ph id=\"ph3\">`Long`</ph>, <ph id=\"ph4\">`Decimal`</ph>, <ph id=\"ph5\">`Single`</ph>, <ph id=\"ph6\">`Double`</ph>","source":"`Short`, `Integer`, `Long`, `Decimal`, `Single`, `Double`"},{"pos":[2371,2455],"content":"<bpt id=\"p1\">[</bpt>UShort<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/ushort-data-type.md)</ept>","source":"[UShort](../../../../visual-basic/language-reference/data-types/ushort-data-type.md)"},{"pos":[2456,2535],"content":"<ph id=\"ph1\">`UShort`</ph>, <ph id=\"ph2\">`Integer`</ph>, <ph id=\"ph3\">`UInteger`</ph>, <ph id=\"ph4\">`Long`</ph>, <ph id=\"ph5\">`ULong`</ph>, <ph id=\"ph6\">`Decimal`</ph>, <ph id=\"ph7\">`Single`</ph>, <ph id=\"ph8\">`Double`</ph>","source":"`UShort`, `Integer`, `UInteger`, `Long`, `ULong`, `Decimal`, `Single`, `Double`"},{"pos":[2540,2626],"content":"<bpt id=\"p1\">[</bpt>Integer<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/integer-data-type.md)</ept>","source":"[Integer](../../../../visual-basic/language-reference/data-types/integer-data-type.md)"},{"pos":[2627,2687],"content":"<ph id=\"ph1\">`Integer`</ph>, <ph id=\"ph2\">`Long`</ph>, <ph id=\"ph3\">`Decimal`</ph>, <ph id=\"ph4\">`Single`</ph>, <ph id=\"ph5\">`Double`</ph><bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"`Integer`, `Long`, `Decimal`, `Single`, `Double`<sup>2</sup>"},{"pos":[2692,2780],"content":"<bpt id=\"p1\">[</bpt>UInteger<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md)</ept>","source":"[UInteger](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md)"},{"pos":[2781,2851],"content":"<ph id=\"ph1\">`UInteger`</ph>, <ph id=\"ph2\">`Long`</ph>, <ph id=\"ph3\">`ULong`</ph>, <ph id=\"ph4\">`Decimal`</ph>, <ph id=\"ph5\">`Single`</ph>, <ph id=\"ph6\">`Double`</ph><bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"`UInteger`, `Long`, `ULong`, `Decimal`, `Single`, `Double`<sup>2</sup>"},{"pos":[2856,2936],"content":"<bpt id=\"p1\">[</bpt>Long<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/long-data-type.md)</ept>","source":"[Long](../../../../visual-basic/language-reference/data-types/long-data-type.md)"},{"pos":[2937,2986],"content":"<ph id=\"ph1\">`Long`</ph>, <ph id=\"ph2\">`Decimal`</ph>, <ph id=\"ph3\">`Single`</ph>, <ph id=\"ph4\">`Double`</ph><bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"`Long`, `Decimal`, `Single`, `Double`<sup>2</sup>"},{"pos":[2991,3073],"content":"<bpt id=\"p1\">[</bpt>ULong<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/ulong-data-type.md)</ept>","source":"[ULong](../../../../visual-basic/language-reference/data-types/ulong-data-type.md)"},{"pos":[3074,3124],"content":"<ph id=\"ph1\">`ULong`</ph>, <ph id=\"ph2\">`Decimal`</ph>, <ph id=\"ph3\">`Single`</ph>, <ph id=\"ph4\">`Double`</ph><bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"`ULong`, `Decimal`, `Single`, `Double`<sup>2</sup>"},{"pos":[3129,3215],"content":"<bpt id=\"p1\">[</bpt>Decimal<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)</ept>","source":"[Decimal](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)"},{"pos":[3216,3257],"content":"<ph id=\"ph1\">`Decimal`</ph>, <ph id=\"ph2\">`Single`</ph>, <ph id=\"ph3\">`Double`</ph><bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"`Decimal`, `Single`, `Double`<sup>2</sup>"},{"pos":[3262,3346],"content":"<bpt id=\"p1\">[</bpt>Single<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/single-data-type.md)</ept>","source":"[Single](../../../../visual-basic/language-reference/data-types/single-data-type.md)"},{"pos":[3347,3365],"content":"<ph id=\"ph1\">`Single`</ph>, <ph id=\"ph2\">`Double`</ph>","source":"`Single`, `Double`"},{"pos":[3370,3454],"content":"<bpt id=\"p1\">[</bpt>Double<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/double-data-type.md)</ept>","source":"[Double](../../../../visual-basic/language-reference/data-types/double-data-type.md)"},{"pos":[3468,3570],"content":"Any enumerated type (<bpt id=\"p1\">[</bpt>Enum<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/enum-statement.md)</ept>)","source":"Any enumerated type ([Enum](../../../../visual-basic/language-reference/statements/enum-statement.md))"},{"content":"Its underlying integral type and any type to which the underlying type widens.","pos":[3571,3649]},{"pos":[3654,3734],"content":"<bpt id=\"p1\">[</bpt>Char<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/char-data-type.md)</ept>","source":"[Char](../../../../visual-basic/language-reference/data-types/char-data-type.md)"},{"pos":[3735,3751],"content":"<ph id=\"ph1\">`Char`</ph>, <ph id=\"ph2\">`String`</ph>","source":"`Char`, `String`"},{"pos":[3756,3768],"content":"<ph id=\"ph1\">`Char`</ph> array","source":"`Char` array"},{"pos":[3769,3791],"content":"<ph id=\"ph1\">`Char`</ph> array, <ph id=\"ph2\">`String`</ph>","source":"`Char` array, `String`"},{"content":"Any type","pos":[3796,3804]},{"pos":[3805,3889],"content":"<bpt id=\"p1\">[</bpt>Object<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/object-data-type.md)</ept>","source":"[Object](../../../../visual-basic/language-reference/data-types/object-data-type.md)"},{"content":"Any derived type","pos":[3894,3910]},{"pos":[3911,3963],"content":"Any base type from which it is derived <bpt id=\"p1\">&lt;sup&gt;</bpt>3<ept id=\"p1\">&lt;/sup&gt;</ept>.","source":"Any base type from which it is derived <sup>3</sup>."},{"content":"Any type","pos":[3968,3976]},{"content":"Any interface it implements.","pos":[3977,4005]},{"pos":[4010,4075],"content":"<bpt id=\"p1\">[</bpt>Nothing<ept id=\"p1\">](../../../../visual-basic/language-reference/nothing.md)</ept>","source":"[Nothing](../../../../visual-basic/language-reference/nothing.md)"},{"content":"Any data type or object type.","pos":[4076,4105]},{"pos":[4113,4174],"content":"<bpt id=\"p1\">&lt;sup&gt;</bpt>1<ept id=\"p1\">&lt;/sup&gt;</ept> By definition, every data type widens to itself.","source":"<sup>1</sup> By definition, every data type widens to itself."},{"content":"<bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept> Conversions from <ph id=\"ph1\">`Integer`</ph>, <ph id=\"ph2\">`UInteger`</ph>, <ph id=\"ph3\">`Long`</ph>, <ph id=\"ph4\">`ULong`</ph>, or <ph id=\"ph5\">`Decimal`</ph> to <ph id=\"ph6\">`Single`</ph> or <ph id=\"ph7\">`Double`</ph> might result in loss of precision, but never in loss of magnitude.","pos":[4181,4354],"source":"<sup>2</sup> Conversions from `Integer`, `UInteger`, `Long`, `ULong`, or `Decimal` to `Single` or `Double` might result in loss of precision, but never in loss of magnitude."},{"content":"In this sense they do not incur information loss.","pos":[4355,4404]},{"content":"<bpt id=\"p1\">&lt;sup&gt;</bpt>3<ept id=\"p1\">&lt;/sup&gt;</ept> It might seem surprising that a conversion from a derived type to one of its base types is widening.","pos":[4411,4524],"source":"<sup>3</sup> It might seem surprising that a conversion from a derived type to one of its base types is widening."},{"content":"The justification is that the derived type contains all the members of the base type, so it qualifies as an instance of the base type.","pos":[4525,4659]},{"content":"In the opposite direction, the base type does not contain any new members defined by the derived type.","pos":[4660,4762]},{"content":"Widening conversions always succeed at run time and never incur data loss.","pos":[4769,4843]},{"content":"You can always perform them implicitly, whether the <bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept> sets the type checking switch to <ph id=\"ph1\">`On`</ph> or to <ph id=\"ph2\">`Off`</ph>.","pos":[4844,5055],"source":" You can always perform them implicitly, whether the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) sets the type checking switch to `On` or to `Off`."},{"pos":[5064,5085],"content":"Narrowing Conversions","linkify":"Narrowing Conversions","nodes":[{"content":"Narrowing Conversions","pos":[0,21]}]},{"content":"The standard narrowing conversions include the following:","pos":[5089,5146]},{"content":"The reverse directions of the widening conversions in the preceding table (except that every type widens to itself)","pos":[5156,5271]},{"pos":[5281,5428],"content":"Conversions in either direction between <bpt id=\"p1\">[</bpt>Boolean<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/boolean-data-type.md)</ept> and any numeric type","source":"Conversions in either direction between [Boolean](../../../../visual-basic/language-reference/data-types/boolean-data-type.md) and any numeric type"},{"pos":[5438,5503],"content":"Conversions from any numeric type to any enumerated type (<ph id=\"ph1\">`Enum`</ph>)","source":"Conversions from any numeric type to any enumerated type (`Enum`)"},{"pos":[5513,5754],"content":"Conversions in either direction between <bpt id=\"p1\">[</bpt>String<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/string-data-type.md)</ept> and any numeric type, <ph id=\"ph1\">`Boolean`</ph>, or <bpt id=\"p2\">[</bpt>Date<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/date-data-type.md)</ept>","source":"Conversions in either direction between [String](../../../../visual-basic/language-reference/data-types/string-data-type.md) and any numeric type, `Boolean`, or [Date](../../../../visual-basic/language-reference/data-types/date-data-type.md)"},{"content":"Conversions from a data type or object type to a type derived from it","pos":[5764,5833]},{"content":"Narrowing conversions do not always succeed at run time, and can fail or incur data loss.","pos":[5840,5929]},{"content":"An error occurs if the destination data type cannot receive the value being converted.","pos":[5930,6016]},{"content":"For example, a numeric conversion can result in an overflow.","pos":[6017,6077]},{"content":"The compiler does not allow you to perform narrowing conversions implicitly unless the <bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept> sets the type checking switch to <ph id=\"ph1\">`Off`</ph>.","pos":[6078,6313],"source":" The compiler does not allow you to perform narrowing conversions implicitly unless the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) sets the type checking switch to `Off`."},{"pos":[6321,6662],"content":"[!NOTE]\n The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).","leadings":["","> "],"nodes":[{"content":"The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).","pos":[9,339],"nodes":[{"content":"The narrowing-conversion error is suppressed for conversions from the elements in a <ph id=\"ph1\">`For Each…Next`</ph> collection to the loop control variable.","pos":[0,140],"source":"The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable."},{"content":"For more information and examples, see the \"Narrowing Conversions\" section in <bpt id=\"p1\">[</bpt>For Each...Next Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)</ept>.","pos":[141,330],"source":" For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)."}]}]},{"pos":[6672,6705],"content":"When to Use Narrowing Conversions","linkify":"When to Use Narrowing Conversions","nodes":[{"content":"When to Use Narrowing Conversions","pos":[0,33]}]},{"content":"You use a narrowing conversion when you know the source value can be converted to the destination data type without error or data loss.","pos":[6709,6844]},{"content":"For example, if you have a <ph id=\"ph1\">`String`</ph> that you know contains either \"True\" or \"False,\" you can use the <ph id=\"ph2\">`CBool`</ph> keyword to convert it to <ph id=\"ph3\">`Boolean`</ph>.","pos":[6845,6989],"source":" For example, if you have a `String` that you know contains either \"True\" or \"False,\" you can use the `CBool` keyword to convert it to `Boolean`."},{"pos":[6998,7026],"content":"Exceptions During Conversion","linkify":"Exceptions During Conversion","nodes":[{"content":"Exceptions During Conversion","pos":[0,28]}]},{"content":"Because widening conversions always succeed, they do not throw exceptions.","pos":[7030,7104]},{"content":"Narrowing conversions, when they fail, most commonly throw the following exceptions:","pos":[7105,7189]},{"pos":[7199,7285],"content":"<ph id=\"ph1\">&lt;xref:System.InvalidCastException&gt;</ph> — if no conversion is defined between the two types","source":"<xref:System.InvalidCastException> — if no conversion is defined between the two types"},{"pos":[7295,7406],"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> — (integral types only) if the converted value is too large for the target type","source":"<xref:System.OverflowException> — (integral types only) if the converted value is too large for the target type"},{"content":"If a class or structure defines a <bpt id=\"p1\">[</bpt>CType Function<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept> to serve as a conversion operator to or from that class or structure, that <ph id=\"ph1\">`CType`</ph> can throw any exception it deems appropriate.","pos":[7413,7665],"source":"If a class or structure defines a [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md) to serve as a conversion operator to or from that class or structure, that `CType` can throw any exception it deems appropriate."},{"content":"In addition, that <ph id=\"ph1\">`CType`</ph> might call Visual Basic functions or <ph id=\"ph2\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> methods, which in turn could throw a variety of exceptions.","pos":[7666,7842],"source":" In addition, that `CType` might call Visual Basic functions or [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] methods, which in turn could throw a variety of exceptions."},{"pos":[7851,7892],"content":"Changes During Reference Type Conversions","linkify":"Changes During Reference Type Conversions","nodes":[{"content":"Changes During Reference Type Conversions","pos":[0,41]}]},{"content":"A conversion from a <bpt id=\"p1\">*</bpt>reference type<ept id=\"p1\">*</ept> copies only the pointer to the value.","pos":[7896,7970],"source":"A conversion from a *reference type* copies only the pointer to the value."},{"content":"The value itself is neither copied nor changed in any way.","pos":[7971,8029]},{"content":"The only thing that can change is the data type of the variable holding the pointer.","pos":[8030,8114]},{"content":"In the following example, the data type is converted from the derived class to its base class, but the object that both variables now point to is unchanged.","pos":[8115,8271]},{"pos":[8528,8536],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8540,8634],"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/index.md)</ept>","source":"[Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md)"},{"pos":[8637,8764],"content":"<bpt id=\"p1\">[</bpt>Type Conversions in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept>","source":"[Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)"},{"pos":[8767,8912],"content":"<bpt id=\"p1\">[</bpt>Implicit and Explicit Conversions<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/implicit-and-explicit-conversions.md)</ept>","source":"[Implicit and Explicit Conversions](../../../../visual-basic/programming-guide/language-features/data-types/implicit-and-explicit-conversions.md)"},{"pos":[8915,9080],"content":"<bpt id=\"p1\">[</bpt>Conversions Between Strings and Other Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/conversions-between-strings-and-other-types.md)</ept>","source":"[Conversions Between Strings and Other Types](../../../../visual-basic/programming-guide/language-features/data-types/conversions-between-strings-and-other-types.md)"},{"pos":[9083,9259],"content":"<bpt id=\"p1\">[</bpt>How to: Convert an Object to Another Type in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-convert-an-object-to-another-type.md)</ept>","source":"[How to: Convert an Object to Another Type in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/how-to-convert-an-object-to-another-type.md)"},{"pos":[9262,9375],"content":"<bpt id=\"p1\">[</bpt>Array Conversions<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/array-conversions.md)</ept>","source":"[Array Conversions](../../../../visual-basic/programming-guide/language-features/data-types/array-conversions.md)"},{"pos":[9378,9455],"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/index.md)</ept>","source":"[Data Types](../../../../visual-basic/language-reference/data-types/index.md)"},{"pos":[9458,9569],"content":"<bpt id=\"p1\">[</bpt>Type Conversion Functions<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)</ept>","source":"[Type Conversion Functions](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)"}]}