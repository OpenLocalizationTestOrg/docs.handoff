{"content":"---\ntitle: \"Internet Information Services Hosting Best Practices\"\nms.date: \"03/30/2017\"\nms.assetid: 0834768e-9665-46bf-86eb-d4b09ab91af5\n---\n# Internet Information Services Hosting Best Practices\nThis topic outlines some best practices for hosting Windows Communication Foundation (WCF) services.  \n  \n## Implementing WCF Services as DLLs  \n Implementing a WCF service as a DLL that is deployed to the \\bin directory of a Web application allows you reuse the service outside of the Web application model, for example, in a test environment that may not have Internet Information Services (IIS) deployed.  \n  \n## Service Hosts in IIS-Hosted Applications  \n Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, [!INCLUDE[iis601](../../../../includes/iis601-md.md)] to host TCP services, because TCP communication is not natively supported on [!INCLUDE[iis601](../../../../includes/iis601-md.md)]). This approach is not recommended. Service hosts created imperatively are not known within the IIS hosting environment. The critical point is that processing done by imperatively created services is not accounted for by IIS when it determines whether the hosting application pool is idle. The result is that applications that have such imperatively created service hosts have an IIS hosting environment that aggressively disposes of IIS host processes.  \n  \n## URIs and IIS-Hosted Endpoints  \n Endpoints for an IIS-hosted service should be configured using relative Uniform Resource Identifiers (URIs), not absolute addresses. This guarantees that the endpoint address falls within the set of URI addresses that belong to the hosting application and ensures that message-based activation happens as expected.  \n  \n## State Management and Process Recycling  \n The IIS hosting environment is optimized for services that do not maintain local state in memory. IIS recycles the host process in response to a variety of external and internal events, causing any volatile state stored exclusively in memory to be lost. Services hosted in IIS should store their state external to the process (for example, in a database) or in an in-memory cache that can easily be re-created if an application recycle event occurs.  \n  \n> [!NOTE]\n>  The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state. WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles. IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.  \n  \n## Optimizing Performance in Middle-Tier Scenarios  \n For optimal performance in a *middle-tier scenario*—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests. Instantiating WCF service clients is an expensive operation relative to making a service call on a pre-existing client instance, and middle-tier scenarios produce distinct performance gains by caching remote clients across requests. WCF service clients are thread-safe, so it is not necessary to synchronize access to a client across multiple threads.  \n  \n Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the `svcutil /a` option. The `/a` option causes the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate `BeginXXX/EndXXX` methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads.  \n  \n## WCF in Multi-Homed or Multi-named scenarios  \n You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as `http://www.contoso.com`) but are individually addressed by different hostnames (for example, `http://www.contoso.com` might direct traffic to two different machines named `http://machine1.internal.contoso.com` and `http://machine2.internal.contoso.com`). This deployment scenario is fully supported by WCF, but requires special configuration of the IIS Web site hosting WCF services to display the correct (external) hostname in the service's metadata (Web Services Description Language).  \n  \n To ensure that the correct hostname appears in the service metadata WCF generates, configure the default identity for the IIS Web site that hosts WCF services to use an explicit hostname. For example, computers that reside inside of the `www.contoso.com` farm should use an IIS site binding of *:80:www.contoso.com for HTTP and \\*:443:www.contoso.com for HTTPS.  \n  \n You can configure IIS Web site bindings by using the IIS Microsoft Management Console (MMC) snap-in.  \n  \n## Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder  \n To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] files folder, use different identities and temporary folders for different applications. For example, if you have two virtual applications /Application1 and / Application2, you can create two Application pools, A and B, with two different identities. Application pool A can run under one user identity (user1) while application pool B can run under another user identity (user2), and configure /Application1 to use A and /Application2 to use B.  \n  \n In Web.config, you can configure the temporary folder using \\<system.web/compilation/@tempFolder>. For /Application1, it can be \"c:\\tempForUser1\" and for application2 it can be \"c:\\tempForUser2\". Grant corresponding write permission to these folders for the two identities.  \n  \n Then user2 cannot change the code-generation folder for /application2 (under c:\\tempForUser1).  \n  \n## Enabling asynchronous processing  \n By default messages sent to a WCF service hosted under IIS 6.0 and earlier are processed in a synchronous manner. ASP.NET calls into WCF on its own thread (the ASP.NET worker thread) and WCF uses another thread to process the request. WCF holds onto the ASP.NET worker thread until it completes its processing. This leads to synchronous processing of requests. Processing requests asynchronously enables greater scalability because it reduces the number of threads required to process a request –WCF does not hold on to the ASP.NET thread while processing the request. Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to *Denial Of Service* (DOS) attacks. Starting with IIS 7.0, a concurrent request throttle has been introduced: `[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ASP.NET\\2.0.50727.0]\"MaxConcurrentRequestsPerCpu`. With this new throttle it is safe to use the asynchronous processing.  By default in IIS 7.0, the asynchronous handler and module are registered. If this has been turned off, you can manually enable asynchronous processing of requests in your application's Web.config file. The settings you use depend on your `aspNetCompatibilityEnabled` setting. If you have `aspNetCompatibilityEnabled` set to `false`, configure the `System.ServiceModel.Activation.ServiceHttpModule` as shown in the following configuration snippet.  \n  \n```xml  \n<system.serviceModel>  \n    <serviceHostingEnvironment aspNetCompatibilityEnabled=\"false\" />      \n  </system.serviceModel>  \n  <system.webServer>  \n    <modules>  \n      <remove name=\"ServiceModel\"/>  \n      <add name=\"ServiceModel\"   \n           preCondition=\"integratedMode,runtimeVersionv2.0\"   \n           type=\"System.ServiceModel.Activation.ServiceHttpModule, System.ServiceModel,Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\"/>  \n    </modules>  \n    </system.webServer>  \n```  \n  \n If you have `aspNetCompatibilityEnabled` set to `true`, configure the `System.ServiceModel.Activation.ServiceHttpHandlerFactory` as shown in the following config snippet.  \n  \n```xml  \n<system.serviceModel>  \n    <serviceHostingEnvironment aspNetCompatibilityEnabled=\"true\" />      \n  </system.serviceModel>  \n  <system.webServer>  \n    <handlers>  \n          <clear/>  \n          <add name=\"TestAsyncHttpHandler\"   \n               path=\"*.svc\"   \n               verb=\"*\"   \n               type=\"System.ServiceModel.Activation.ServiceHttpHandlerFactory, System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\"           \n               />  \n    </handlers>      \n  </system.webServer>  \n```  \n  \n## See also\n\n- [Service Hosting Samples](../samples/hosting.md)\n- [Windows Server App Fabric Hosting Features](https://go.microsoft.com/fwlink/?LinkId=201276)\n","nodes":[{"pos":[4,136],"embed":true,"restype":"x-metadata","content":"title: \"Internet Information Services Hosting Best Practices\"\nms.date: \"03/30/2017\"\nms.assetid: 0834768e-9665-46bf-86eb-d4b09ab91af5","nodes":[{"content":"Internet Information Services Hosting Best Practices","nodes":[{"pos":[0,52],"content":"Internet Information Services Hosting Best Practices","nodes":[{"content":"Internet Information Services Hosting Best Practices","pos":[0,52]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[143,195],"content":"Internet Information Services Hosting Best Practices","linkify":"Internet Information Services Hosting Best Practices","nodes":[{"content":"Internet Information Services Hosting Best Practices","pos":[0,52]}]},{"content":"This topic outlines some best practices for hosting Windows Communication Foundation (WCF) services.","pos":[196,296]},{"pos":[305,338],"content":"Implementing WCF Services as DLLs","linkify":"Implementing WCF Services as DLLs","nodes":[{"content":"Implementing WCF Services as DLLs","pos":[0,33]}]},{"content":"Implementing a WCF service as a DLL that is deployed to the \\bin directory of a Web application allows you reuse the service outside of the Web application model, for example, in a test environment that may not have Internet Information Services (IIS) deployed.","pos":[342,603]},{"pos":[612,652],"content":"Service Hosts in IIS-Hosted Applications","linkify":"Service Hosts in IIS-Hosted Applications","nodes":[{"content":"Service Hosts in IIS-Hosted Applications","pos":[0,40]}]},{"content":"Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, <ph id=\"ph1\">[!INCLUDE[iis601](../../../../includes/iis601-md.md)]</ph> to host TCP services, because TCP communication is not natively supported on <ph id=\"ph2\">[!INCLUDE[iis601](../../../../includes/iis601-md.md)]</ph>).","pos":[656,1013],"source":"Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, [!INCLUDE[iis601](../../../../includes/iis601-md.md)] to host TCP services, because TCP communication is not natively supported on [!INCLUDE[iis601](../../../../includes/iis601-md.md)])."},{"content":"This approach is not recommended.","pos":[1014,1047]},{"content":"Service hosts created imperatively are not known within the IIS hosting environment.","pos":[1048,1132]},{"content":"The critical point is that processing done by imperatively created services is not accounted for by IIS when it determines whether the hosting application pool is idle.","pos":[1133,1301]},{"content":"The result is that applications that have such imperatively created service hosts have an IIS hosting environment that aggressively disposes of IIS host processes.","pos":[1302,1465]},{"pos":[1474,1503],"content":"URIs and IIS-Hosted Endpoints","linkify":"URIs and IIS-Hosted Endpoints","nodes":[{"content":"URIs and IIS-Hosted Endpoints","pos":[0,29]}]},{"content":"Endpoints for an IIS-hosted service should be configured using relative Uniform Resource Identifiers (URIs), not absolute addresses.","pos":[1507,1639]},{"content":"This guarantees that the endpoint address falls within the set of URI addresses that belong to the hosting application and ensures that message-based activation happens as expected.","pos":[1640,1821]},{"pos":[1830,1868],"content":"State Management and Process Recycling","linkify":"State Management and Process Recycling","nodes":[{"content":"State Management and Process Recycling","pos":[0,38]}]},{"content":"The IIS hosting environment is optimized for services that do not maintain local state in memory.","pos":[1872,1969]},{"content":"IIS recycles the host process in response to a variety of external and internal events, causing any volatile state stored exclusively in memory to be lost.","pos":[1970,2125]},{"content":"Services hosted in IIS should store their state external to the process (for example, in a database) or in an in-memory cache that can easily be re-created if an application recycle event occurs.","pos":[2126,2321]},{"pos":[2329,2854],"content":"[!NOTE]\n The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state. WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles. IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.","leadings":["","> "],"nodes":[{"content":"The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state. WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles. IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.","pos":[9,523],"nodes":[{"content":"The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state.","pos":[0,107]},{"content":"WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles.","pos":[108,207]},{"content":"IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.","pos":[208,514]}]}]},{"pos":[2863,2910],"content":"Optimizing Performance in Middle-Tier Scenarios","linkify":"Optimizing Performance in Middle-Tier Scenarios","nodes":[{"content":"Optimizing Performance in Middle-Tier Scenarios","pos":[0,47]}]},{"content":"For optimal performance in a <bpt id=\"p1\">*</bpt>middle-tier scenario<ept id=\"p1\">*</ept>—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests.","pos":[2914,3151],"source":"For optimal performance in a *middle-tier scenario*—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests."},{"content":"Instantiating WCF service clients is an expensive operation relative to making a service call on a pre-existing client instance, and middle-tier scenarios produce distinct performance gains by caching remote clients across requests.","pos":[3152,3384]},{"content":"WCF service clients are thread-safe, so it is not necessary to synchronize access to a client across multiple threads.","pos":[3385,3503]},{"content":"Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the <ph id=\"ph1\">`svcutil /a`</ph> option.","pos":[3510,3631],"source":"Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the `svcutil /a` option."},{"content":"The <ph id=\"ph1\">`/a`</ph> option causes the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept> to generate <ph id=\"ph2\">`BeginXXX/EndXXX`</ph> methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads.","pos":[3632,3954],"source":" The `/a` option causes the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate `BeginXXX/EndXXX` methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads."},{"pos":[3963,4006],"content":"WCF in Multi-Homed or Multi-named scenarios","linkify":"WCF in Multi-Homed or Multi-named scenarios","nodes":[{"content":"WCF in Multi-Homed or Multi-named scenarios","pos":[0,43]}]},{"content":"You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as <ph id=\"ph1\">`http://www.contoso.com`</ph>) but are individually addressed by different hostnames (for example, <ph id=\"ph2\">`http://www.contoso.com`</ph> might direct traffic to two different machines named <ph id=\"ph3\">`http://machine1.internal.contoso.com`</ph> and <ph id=\"ph4\">`http://machine2.internal.contoso.com`</ph>).","pos":[4010,4383],"source":"You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as `http://www.contoso.com`) but are individually addressed by different hostnames (for example, `http://www.contoso.com` might direct traffic to two different machines named `http://machine1.internal.contoso.com` and `http://machine2.internal.contoso.com`)."},{"content":"This deployment scenario is fully supported by WCF, but requires special configuration of the IIS Web site hosting WCF services to display the correct (external) hostname in the service's metadata (Web Services Description Language).","pos":[4384,4617]},{"content":"To ensure that the correct hostname appears in the service metadata WCF generates, configure the default identity for the IIS Web site that hosts WCF services to use an explicit hostname.","pos":[4624,4811]},{"content":"For example, computers that reside inside of the <ph id=\"ph1\">`www.contoso.com`</ph> farm should use an IIS site binding of *:80:www.contoso.com for HTTP and <ph id=\"ph2\">\\*</ph>:443:www.contoso.com for HTTPS.","pos":[4812,4985],"source":" For example, computers that reside inside of the `www.contoso.com` farm should use an IIS site binding of *:80:www.contoso.com for HTTP and \\*:443:www.contoso.com for HTTPS."},{"content":"You can configure IIS Web site bindings by using the IIS Microsoft Management Console (MMC) snap-in.","pos":[4992,5092]},{"pos":[5101,5218],"content":"Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder","linkify":"Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder","nodes":[{"content":"Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder","pos":[0,117]}]},{"content":"To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> files folder, use different identities and temporary folders for different applications.","pos":[5222,5501],"source":"To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] files folder, use different identities and temporary folders for different applications."},{"content":"For example, if you have two virtual applications /Application1 and / Application2, you can create two Application pools, A and B, with two different identities.","pos":[5502,5663]},{"content":"Application pool A can run under one user identity (user1) while application pool B can run under another user identity (user2), and configure /Application1 to use A and /Application2 to use B.","pos":[5664,5857]},{"content":"In Web.config, you can configure the temporary folder using <ph id=\"ph1\">\\&lt;</ph><ph id=\"ph2\">system.web/compilation/@tempFolder</ph>&gt;.","pos":[5864,5962],"source":"In Web.config, you can configure the temporary folder using \\<system.web/compilation/@tempFolder>."},{"content":"For /Application1, it can be \"c:\\tempForUser1\" and for application2 it can be \"c:\\tempForUser2\".","pos":[5963,6059]},{"content":"Grant corresponding write permission to these folders for the two identities.","pos":[6060,6137]},{"content":"Then user2 cannot change the code-generation folder for /application2 (under c:\\tempForUser1).","pos":[6144,6238]},{"pos":[6247,6279],"content":"Enabling asynchronous processing","linkify":"Enabling asynchronous processing","nodes":[{"content":"Enabling asynchronous processing","pos":[0,32]}]},{"content":"By default messages sent to a WCF service hosted under IIS 6.0 and earlier are processed in a synchronous manner.","pos":[6283,6396]},{"content":"ASP.NET calls into WCF on its own thread (the ASP.NET worker thread) and WCF uses another thread to process the request.","pos":[6397,6517]},{"content":"WCF holds onto the ASP.NET worker thread until it completes its processing.","pos":[6518,6593]},{"content":"This leads to synchronous processing of requests.","pos":[6594,6643]},{"content":"Processing requests asynchronously enables greater scalability because it reduces the number of threads required to process a request –WCF does not hold on to the ASP.NET thread while processing the request.","pos":[6644,6851]},{"content":"Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to <bpt id=\"p1\">*</bpt>Denial Of Service<ept id=\"p1\">*</ept> (DOS) attacks.","pos":[6852,7044],"source":" Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to *Denial Of Service* (DOS) attacks."},{"content":"Starting with IIS 7.0, a concurrent request throttle has been introduced: <ph id=\"ph1\">`[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ASP.NET\\2.0.50727.0]\"MaxConcurrentRequestsPerCpu`</ph>.","pos":[7045,7209],"source":" Starting with IIS 7.0, a concurrent request throttle has been introduced: `[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ASP.NET\\2.0.50727.0]\"MaxConcurrentRequestsPerCpu`."},{"content":"With this new throttle it is safe to use the asynchronous processing.","pos":[7210,7279]},{"content":"By default in IIS 7.0, the asynchronous handler and module are registered.","pos":[7281,7355]},{"content":"If this has been turned off, you can manually enable asynchronous processing of requests in your application's Web.config file.","pos":[7356,7483]},{"content":"The settings you use depend on your <ph id=\"ph1\">`aspNetCompatibilityEnabled`</ph> setting.","pos":[7484,7557],"source":" The settings you use depend on your `aspNetCompatibilityEnabled` setting."},{"content":"If you have <ph id=\"ph1\">`aspNetCompatibilityEnabled`</ph> set to <ph id=\"ph2\">`false`</ph>, configure the <ph id=\"ph3\">`System.ServiceModel.Activation.ServiceHttpModule`</ph> as shown in the following configuration snippet.","pos":[7558,7728],"source":" If you have `aspNetCompatibilityEnabled` set to `false`, configure the `System.ServiceModel.Activation.ServiceHttpModule` as shown in the following configuration snippet."},{"pos":[8254,8424],"content":"If you have <ph id=\"ph1\">`aspNetCompatibilityEnabled`</ph> set to <ph id=\"ph2\">`true`</ph>, configure the <ph id=\"ph3\">`System.ServiceModel.Activation.ServiceHttpHandlerFactory`</ph> as shown in the following config snippet.","source":"If you have `aspNetCompatibilityEnabled` set to `true`, configure the `System.ServiceModel.Activation.ServiceHttpHandlerFactory` as shown in the following config snippet."},{"pos":[8985,8993],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8997,9045],"content":"<bpt id=\"p1\">[</bpt>Service Hosting Samples<ept id=\"p1\">](../samples/hosting.md)</ept>","source":"[Service Hosting Samples](../samples/hosting.md)"},{"pos":[9048,9140],"content":"<bpt id=\"p1\">[</bpt>Windows Server App Fabric Hosting Features<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=201276)</ept>","source":"[Windows Server App Fabric Hosting Features](https://go.microsoft.com/fwlink/?LinkId=201276)"}]}