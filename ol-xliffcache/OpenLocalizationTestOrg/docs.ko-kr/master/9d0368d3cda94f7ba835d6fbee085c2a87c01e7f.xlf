<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="tuples.md" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9d0368d3cda94f7ba835d6fbee085c2a87c01e7f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\data-types\tuples.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ea4706c4f853ac3df45bfc26ad04d5d0253ad5b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">88991babf0b26d9e71951abeea4c95a0b31854de</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Tuples in Visual Basic | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Tuples (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Starting with Visual Basic 2017, the Visual Basic language offers built-in support for tuples that makes creating tuples and accessing the elements of tuples easier.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A tuple is a light-weight data structure that has a specific number and sequence of values.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When you instantiate the tuple, you define the number and the data type of each value (or element).</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, a 2-tuple (or pair) has two elements.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The first might be a <ph id="ph1">`Boolean`</ph> value, while the second is a <ph id="ph2">`String`</ph>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Because tuples make it easy to store multiple values in a single object, they are often used as a lightweight way to return multiple values from a method.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Tuple support requires the <ph id="ph1">&lt;xref:System.ValueTuple&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>If the .NET Framework 4.7 is not installed, you must add the NuGet package <ph id="ph1">`System.ValueTuple`</ph>, which is available on the NuGet Gallery.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Without this package, you may get a compilation error similar to, "Predefined type 'ValueTuple(Of,,,)' is not defined or imported."</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Instantiating and using a tuple</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You instantiate a tuple by enclosing its comma-delimited values im parentheses.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Each of those values then becomes a field of the tuple.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the following code defines a triple (or 3-tuple) with a <ph id="ph1">`Date`</ph> as its first value, a <ph id="ph2">`String`</ph> as its second, and a <ph id="ph3">`Boolean`</ph> as its third.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By default, the name of each field in a tuple consists of the string <ph id="ph1">`Item`</ph> along with the field's one-based position in the tuple.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For this 3-tuple, the <ph id="ph1">`Date`</ph> field is <ph id="ph2">`Item1`</ph>, the <ph id="ph3">`String`</ph> field is <ph id="ph4">`Item2`</ph>, and the <ph id="ph5">`Boolean`</ph> field is <ph id="ph6">`Item3`</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following example displays the values of fields of the tuple instantiated in the previous line of code</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The fields of a Visual Basic tuple are read-write; after you've instantiated a tuple, you can modify its values.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following example modifies two of the three fields of the tuple created in the previous example and displays the result.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Instantiating and using a named tuple</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Rather than using default names for a tuple's fields, you can instantiate a <bpt id="p1">*</bpt>named tuple<ept id="p1">*</ept> by assigning your own names to the tuple's elements.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The tuple's fields can then be accessed by their assigned names <bpt id="p1">*</bpt>or<ept id="p1">*</ept> by their default names.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example instantiates the same 3-tuple as previously, except that it explicitly names the first field <ph id="ph1">`EventDate`</ph>, the second <ph id="ph2">`Name`</ph>, and the third <ph id="ph3">`IsHoliday`</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It then displays the field values, modifies them, and displays the field values again.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Tuples versus structures</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A Visual Basic tuple is a value type that is an instance of one of the a <bpt id="p1">**</bpt>System.ValueTuple<ept id="p1">**</ept> generic types.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`holiday`</ph> tuple defined in the previous example is an instance of the <ph id="ph2">&lt;xref:System.ValueTuple%603&gt;</ph> structure.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It is designed to be a lightweight container for data.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Since the tuple aims to make it easy to create an object with multiple data items, it lacks some of the features that a custom structure might have.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>These include:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Customer members.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You cannot define your own properties, methods, or events for a tuple.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Validation.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You cannot validate the data assigned to fields.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Immutability.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Visual Basic tuples are mutable.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In contrast, a custom structure allows you to control whether an instance is mutable or immutable.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If custom members, property and field validation, or immutability are important, you should use the Visual Basic <bpt id="p1">[</bpt>Structure<ept id="p1">](../../../language-reference/statements/structure-statement.md)</ept> statement to define a custom value type.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A Visual Basic tuple does inherit the members of its <bpt id="p1">**</bpt>ValueTuple<ept id="p1">**</ept> type.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In addition to its fields, these include the following methods:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Member</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>CompareTo</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Compares the current tuple to another tuple with the same number of elements.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Equals</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Determines whether the current tuple is equal to another tuple or object.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>GetHashCode</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Calculates the hash code for the current instance.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>ToString</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Returns the string representation of this tuple, which takes the form <ph id="ph1">`(Item1, Item2...)`</ph>, where <ph id="ph2">`Item1`</ph> and <ph id="ph3">`Item2`</ph> represent the values of the tuple's fields.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">**</bpt>ValueTuple<ept id="p1">**</ept> types implement <ph id="ph1">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interfaces, which allow you to define customer comparers.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Assignment and tuples</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Visual Basic supports assignment between tuple types that have the same number of fields.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The field types can be converted if one of the following is true:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The source and target field are of the same type.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A widening (or implicit) conversion of the source type to the target type is defined.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Option Strict`</ph> is <ph id="ph2">`On`</ph>, and a narrowing (or explicit) conversion of the source type to the target type is defined.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This conversion can throw an exception if the source value is outside the range of the target type.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Other conversions are not considered for assignments.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Let's look at the kinds of assignments that are allowed between tuple types.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Consider these variables used in the following examples:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The first two variables, <ph id="ph1">`unnamed`</ph> and <ph id="ph2">`anonymous`</ph>, do not have semantic names provided for the fields.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Their field names are the default <ph id="ph1">`Item1`</ph> and <ph id="ph2">`Item2`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The last two variables, <ph id="ph1">`named`</ph> and <ph id="ph2">`differentName`</ph> have semantic field names.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Note that these two tuples have different names for the fields.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>All four of these tuples have the same number of fields (referred to as 'arity'), and the types of those fields are identical.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Therefore, all of these assignments work:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Notice that the names of the tuples are not assigned.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The values of the fields are assigned following the order of the fields in the tuple.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Finally, notice that we can assign the <ph id="ph1">`named`</ph> tuple to the <ph id="ph2">`conversion`</ph> tuple, even though the first field of <ph id="ph3">`named`</ph> is an <ph id="ph4">`Integer`</ph>, and the first field of <ph id="ph5">`conversion`</ph> is a <ph id="ph6">`Long`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This assignment succeeds because converting an <ph id="ph1">`Integer`</ph> to a <ph id="ph2">`Long`</ph> is a widening conversion.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Tuples with different numbers of fields are not assignable:</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Tuples as method return values</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A method can return only a single value.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Frequently, though, you'd like a method call to return multiple values.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>There are several ways to work around this limitation:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can create a custom class or structure whose properties or fields represent values returned by the method.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Thus is a heavyweight solution; it requires that you define a custom type whose only purpose is to retrieve values from a method call.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can return a single value from the method, and return the remaining values by passing them by reference to the method.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This involves the overhead of instantiating a variable and risks inadvertently overwriting the value of the variable that you pass by reference.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You can use a tuple, which provides a lightweight solution to retrieving multiple return values.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>TryParse<ept id="p1">**</ept> methods in .NET return a <ph id="ph1">`Boolean`</ph> value that indicates whether the parsing operation succeeded.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The result of the parsing operation is returned in a variable passed by reference to the method.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Normally, a call to the a parsing method such as <ph id="ph1">&lt;xref:System.Int32.TryParse%2A?displayProperty=fullName&gt;</ph> looks like the following:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>We can return a tuple from the parsing operation if we wrap the call to the <ph id="ph1">&lt;xref:System.Int32.TryParse%2A?displayProperty=fullName&gt;</ph> method in our own method.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`NumericLibrary.ParseInteger`</ph> calls the <ph id="ph2">&lt;xref:System.Int32.TryParse%2A?displayProperty=fullName&gt;</ph> method and returns a named tuple with two elements.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You can then call the method with code like the following:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Visual Basic tuples and tuples in the .NET Framework</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A Visual Basic tuple is an instance of one of the <bpt id="p1">**</bpt>System.ValueTuple<ept id="p1">**</ept> generic types, which were introduced in the .NET Framework 4.7.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The .NET Framework also includes a set of generic <bpt id="p1">**</bpt>System.Tuple<ept id="p1">**</ept> classes.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>These classes, however, differ from Visual Basic tuples and the <bpt id="p1">**</bpt>System.ValueTuple<ept id="p1">**</ept> generic types in a number of ways:</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The elements of the <bpt id="p1">**</bpt>Tuple<ept id="p1">**</ept> classes are properties named <ph id="ph1">`Item1`</ph>, <ph id="ph2">`Item2`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In Visual Basic tuples and the <bpt id="p1">**</bpt>ValueTuple<ept id="p1">**</ept> types, tuple elements are fields.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You cannot assign meaningful names to the elements of a <bpt id="p1">**</bpt>Tuple<ept id="p1">**</ept> instance or of a <bpt id="p2">**</bpt>ValueTuple<ept id="p2">**</ept> instance.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Visual Basic allows you to assign names that communicate the meaning of the fields.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The properties of a <bpt id="p1">**</bpt>Tuple<ept id="p1">**</ept> instance are read-only; the tuples are immutable.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>In Visual Basic tuples and the <bpt id="p1">**</bpt>ValueTuple<ept id="p1">**</ept> types, tuple fields are read-write; the tuples are mutable.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The generic <bpt id="p1">**</bpt>Tuple<ept id="p1">**</ept> types are reference types.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Using these <bpt id="p1">**</bpt>Tuple<ept id="p1">**</ept> types means allocating objects.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>On hot paths, this can have a measurable impact on your application's performance.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Visual Basic tuples and the <bpt id="p1">**</bpt>ValueTuple<ept id="p1">**</ept> types are value types.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Extension methods in the <ph id="ph1">&lt;xref:System.TupleExtensions&gt;</ph> class make it easy to convert between Visual Basic tuples and .NET <bpt id="p1">**</bpt>Tuple<ept id="p1">**</ept> objects.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ToTuple<ept id="p1">**</ept> method converts a Visual Basic tuple to a .NET <bpt id="p2">**</bpt>Tuple<ept id="p2">**</ept> object, and the <bpt id="p3">**</bpt>ToValueTuple<ept id="p3">**</ept> method converts a .NET <bpt id="p4">**</bpt>Tuple<ept id="p4">**</ept> object to a Visual Basic tuple.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The following example creates a tuple, converts it to a .NET <bpt id="p1">**</bpt>Tuple<ept id="p1">**</ept> object, and converts it back to a Visual Basic tuple.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The example then compares this tuple with the original one to ensure that they are equal.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Visual Basic Language Reference<ept id="p1">](index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>