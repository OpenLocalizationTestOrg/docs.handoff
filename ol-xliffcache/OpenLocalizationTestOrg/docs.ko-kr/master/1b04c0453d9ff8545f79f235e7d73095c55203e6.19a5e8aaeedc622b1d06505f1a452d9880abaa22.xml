{"content":"---\ntitle: \"ICorProfilerInfo3::RequestProfilerDetach Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorProfilerInfo3.RequestProfilerDetach Method\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerInfo3::RequestProfilerDetach\"\nhelpviewer_keywords: \n  - \"RequestProfilerDetach method [.NET Framework profiling]\"\n  - \"ICorProfilerInfo3::RequestProfilerDetach method [.NET Framework profiling]\"\nms.assetid: ea102e62-0454-4477-bcf3-126773acd184\ntopic_type: \n  - \"apiref\"\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# ICorProfilerInfo3::RequestProfilerDetach Method\nInstructs the runtime to detach the profiler.  \n  \n## Syntax  \n  \n```  \nHRESULT RequestProfilerDetach(  \n   [in] DWORD    dwExpectedCompletionMilliseconds);  \n```  \n  \n## Parameters  \n `dwExpectedCompletionMilliseconds`  \n [in] The length of time, in milliseconds, the common language runtime (CLR) should wait before checking to see whether it is safe to unload the profiler.  \n  \n## Return Value  \n This method returns the following specific HRESULTs as well as HRESULT errors that indicate method failure.  \n  \n|HRESULT|Description|  \n|-------------|-----------------|  \n|S_OK|The detach request is valid, and the detach procedure is now continuing on another thread. When the detach is fully complete, a `ProfilerDetachSucceeded` event is issued.|  \n|E_ CORPROF_E_CALLBACK3_REQUIRED|The profiler failed an [IUnknown::QueryInterface](https://go.microsoft.com/fwlink/?LinkID=144867) attempt for the [ICorProfilerCallback3](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback3-interface.md) interface, which it must implement to support the detach operation. Detach was not attempted.|  \n|CORPROF_E_IMMUTABLE_FLAGS_SET|Detachment is impossible because the profiler set immutable flags at startup. Detachment was not attempted; the profiler is still fully attached.|  \n|CORPROF_E_IRREVERSIBLE_INSTRUMENTATION_PRESENT|Detachment is impossible because the profiler used instrumented Microsoft intermediate language (MSIL) code, or inserted `enter`/`leave` hooks. Detachment was not attempted; the profiler is still fully attached.<br /><br /> **Note** Instrumented MSIL is code is code that is provided by the profiler using the [SetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-setilfunctionbody-method.md) method.|  \n|CORPROF_E_RUNTIME_UNINITIALIZED|The runtime has not been initialized yet in the managed application. (That is, the runtime has not been fully loaded.) This error code may be returned when detachment is requested inside the profiler callback's [ICorProfilerCallback::Initialize](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-initialize-method.md) method.|  \n|CORPROF_E_UNSUPPORTED_CALL_SEQUENCE|`RequestProfilerDetach` was called at an unsupported time. This occurs if the method is called on a managed thread but not from within an [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) method or from within an [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) method that cannot tolerate a garbage collection. For more information, see [CORPROF_E_UNSUPPORTED_CALL_SEQUENCE HRESULT](../../../../docs/framework/unmanaged-api/profiling/corprof-e-unsupported-call-sequence-hresult.md).|  \n  \n## Remarks  \n During the detach procedure, the detach thread (the thread created specifically for detaching the profiler) occasionally checks whether all threads have exited the profilerâ€™s code. The profiler should provide an estimate of how long this should take through the `dwExpectedCompletionMilliseconds` parameter. A good value to use is the typical amount of time the profiler spends inside any given `ICorProfilerCallback*` method; this value should not be less than half of the maximum amount of time the profiler expects to spend.  \n  \n The detach thread uses `dwExpectedCompletionMilliseconds` to decide how long to sleep before checking whether profiler callback code has been popped off all stacks. Although the details of the following algorithm may change in future releases of the CLR, it illustrates one way `dwExpectedCompletionMilliseconds` can be used when determining when it is safe to unload the profiler. The detach thread first sleeps for `dwExpectedCompletionMilliseconds` milliseconds. If, after awakening from the sleep, the CLR finds that profiler callback code is still present, the detach thread sleeps again, this time for two times `dwExpectedCompletionMilliseconds` milliseconds. If, after awakening from this second sleep, the detach thread finds that profiler callback code is still present, it sleeps for 10 minutes before checking again. The detach thread continues to recheck every 10 minutes.  \n  \n If the profiler specifies `dwExpectedCompletionMilliseconds` as 0 (zero), the CLR uses a default value of 5000, which means that it will perform a check after 5 seconds, again after 10 seconds, and then every 10 minutes thereafter.  \n  \n## Requirements  \n **Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).  \n  \n **Header:** CorProf.idl, CorProf.h  \n  \n **Library:** CorGuids.lib  \n  \n **.NET Framework Versions:** [!INCLUDE[net_current_v40plus](../../../../includes/net-current-v40plus-md.md)]  \n  \n## See also\n\n- [ICorProfilerInfo3 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo3-interface.md)\n- [Profiling Interfaces](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)\n- [Profiling](../../../../docs/framework/unmanaged-api/profiling/index.md)\n","nodes":[{"pos":[4,539],"embed":true,"restype":"x-metadata","content":"title: \"ICorProfilerInfo3::RequestProfilerDetach Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorProfilerInfo3.RequestProfilerDetach Method\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerInfo3::RequestProfilerDetach\"\nhelpviewer_keywords: \n  - \"RequestProfilerDetach method [.NET Framework profiling]\"\n  - \"ICorProfilerInfo3::RequestProfilerDetach method [.NET Framework profiling]\"\nms.assetid: ea102e62-0454-4477-bcf3-126773acd184\ntopic_type: \n  - \"apiref\"\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"ICorProfilerInfo3::RequestProfilerDetach Method","nodes":[{"pos":[0,47],"content":"ICorProfilerInfo3::RequestProfilerDetach Method","nodes":[{"content":"ICorProfilerInfo3::RequestProfilerDetach Method","pos":[0,47]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[546,593],"content":"ICorProfilerInfo3::RequestProfilerDetach Method","linkify":"ICorProfilerInfo3::RequestProfilerDetach Method","nodes":[{"content":"ICorProfilerInfo3::RequestProfilerDetach Method","pos":[0,47]}]},{"content":"Instructs the runtime to detach the profiler.","pos":[594,639]},{"pos":[648,654],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[765,775],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] The length of time, in milliseconds, the common language runtime (CLR) should wait before checking to see whether it is safe to unload the profiler.","pos":[817,970]},{"pos":[979,991],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"This method returns the following specific HRESULTs as well as HRESULT errors that indicate method failure.","pos":[995,1102]},{"content":"HRESULT","pos":[1109,1116]},{"content":"Description","pos":[1117,1128]},{"content":"S_OK","pos":[1169,1173]},{"content":"The detach request is valid, and the detach procedure is now continuing on another thread.","pos":[1174,1264]},{"content":"When the detach is fully complete, a <ph id=\"ph1\">`ProfilerDetachSucceeded`</ph> event is issued.","pos":[1265,1344],"source":" When the detach is fully complete, a `ProfilerDetachSucceeded` event is issued."},{"content":"E_ CORPROF_E_CALLBACK3_REQUIRED","pos":[1349,1380]},{"content":"The profiler failed an <bpt id=\"p1\">[</bpt>IUnknown::QueryInterface<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkID=144867)</ept> attempt for the <bpt id=\"p2\">[</bpt>ICorProfilerCallback3<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback3-interface.md)</ept> interface, which it must implement to support the detach operation.","pos":[1381,1673],"source":"The profiler failed an [IUnknown::QueryInterface](https://go.microsoft.com/fwlink/?LinkID=144867) attempt for the [ICorProfilerCallback3](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback3-interface.md) interface, which it must implement to support the detach operation."},{"content":"Detach was not attempted.","pos":[1674,1699]},{"content":"CORPROF_E_IMMUTABLE_FLAGS_SET","pos":[1704,1733]},{"content":"Detachment is impossible because the profiler set immutable flags at startup.","pos":[1734,1811]},{"content":"Detachment was not attempted; the profiler is still fully attached.","pos":[1812,1879]},{"content":"CORPROF_E_IRREVERSIBLE_INSTRUMENTATION_PRESENT","pos":[1884,1930]},{"content":"Detachment is impossible because the profiler used instrumented Microsoft intermediate language (MSIL) code, or inserted <ph id=\"ph1\">`enter`</ph><ph id=\"ph2\">/</ph><ph id=\"ph3\">`leave`</ph> hooks.","pos":[1931,2074],"source":"Detachment is impossible because the profiler used instrumented Microsoft intermediate language (MSIL) code, or inserted `enter`/`leave` hooks."},{"content":"Detachment was not attempted; the profiler is still fully attached.","pos":[2075,2142]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> Instrumented MSIL is code is code that is provided by the profiler using the <bpt id=\"p2\">[</bpt>SetILFunctionBody<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-setilfunctionbody-method.md)</ept> method.","pos":[2155,2365],"source":"**Note** Instrumented MSIL is code is code that is provided by the profiler using the [SetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-setilfunctionbody-method.md) method."},{"content":"CORPROF_E_RUNTIME_UNINITIALIZED","pos":[2370,2401]},{"content":"The runtime has not been initialized yet in the managed application.","pos":[2402,2470]},{"content":"(That is, the runtime has not been fully loaded.) This error code may be returned when detachment is requested inside the profiler callback's <bpt id=\"p1\">[</bpt>ICorProfilerCallback::Initialize<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-initialize-method.md)</ept> method.","pos":[2471,2749],"source":" (That is, the runtime has not been fully loaded.) This error code may be returned when detachment is requested inside the profiler callback's [ICorProfilerCallback::Initialize](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-initialize-method.md) method."},{"content":"CORPROF_E_UNSUPPORTED_CALL_SEQUENCE","pos":[2754,2789]},{"content":"<ph id=\"ph1\">`RequestProfilerDetach`</ph> was called at an unsupported time.","pos":[2790,2848],"source":"`RequestProfilerDetach` was called at an unsupported time."},{"content":"This occurs if the method is called on a managed thread but not from within an <bpt id=\"p1\">[</bpt>ICorProfilerCallback<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept> method or from within an <bpt id=\"p2\">[</bpt>ICorProfilerCallback<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept> method that cannot tolerate a garbage collection.","pos":[2849,3220],"source":" This occurs if the method is called on a managed thread but not from within an [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) method or from within an [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) method that cannot tolerate a garbage collection."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>CORPROF_E_UNSUPPORTED_CALL_SEQUENCE HRESULT<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/corprof-e-unsupported-call-sequence-hresult.md)</ept>.","pos":[3221,3392],"source":" For more information, see [CORPROF_E_UNSUPPORTED_CALL_SEQUENCE HRESULT](../../../../docs/framework/unmanaged-api/profiling/corprof-e-unsupported-call-sequence-hresult.md)."},{"pos":[3402,3409],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"During the detach procedure, the detach thread (the thread created specifically for detaching the profiler) occasionally checks whether all threads have exited the profilerâ€™s code.","pos":[3413,3593]},{"content":"The profiler should provide an estimate of how long this should take through the <ph id=\"ph1\">`dwExpectedCompletionMilliseconds`</ph> parameter.","pos":[3594,3720],"source":" The profiler should provide an estimate of how long this should take through the `dwExpectedCompletionMilliseconds` parameter."},{"content":"A good value to use is the typical amount of time the profiler spends inside any given <ph id=\"ph1\">`ICorProfilerCallback*`</ph> method; this value should not be less than half of the maximum amount of time the profiler expects to spend.","pos":[3721,3940],"source":" A good value to use is the typical amount of time the profiler spends inside any given `ICorProfilerCallback*` method; this value should not be less than half of the maximum amount of time the profiler expects to spend."},{"content":"The detach thread uses <ph id=\"ph1\">`dwExpectedCompletionMilliseconds`</ph> to decide how long to sleep before checking whether profiler callback code has been popped off all stacks.","pos":[3947,4111],"source":"The detach thread uses `dwExpectedCompletionMilliseconds` to decide how long to sleep before checking whether profiler callback code has been popped off all stacks."},{"content":"Although the details of the following algorithm may change in future releases of the CLR, it illustrates one way <ph id=\"ph1\">`dwExpectedCompletionMilliseconds`</ph> can be used when determining when it is safe to unload the profiler.","pos":[4112,4328],"source":" Although the details of the following algorithm may change in future releases of the CLR, it illustrates one way `dwExpectedCompletionMilliseconds` can be used when determining when it is safe to unload the profiler."},{"content":"The detach thread first sleeps for <ph id=\"ph1\">`dwExpectedCompletionMilliseconds`</ph> milliseconds.","pos":[4329,4412],"source":" The detach thread first sleeps for `dwExpectedCompletionMilliseconds` milliseconds."},{"content":"If, after awakening from the sleep, the CLR finds that profiler callback code is still present, the detach thread sleeps again, this time for two times <ph id=\"ph1\">`dwExpectedCompletionMilliseconds`</ph> milliseconds.","pos":[4413,4613],"source":" If, after awakening from the sleep, the CLR finds that profiler callback code is still present, the detach thread sleeps again, this time for two times `dwExpectedCompletionMilliseconds` milliseconds."},{"content":"If, after awakening from this second sleep, the detach thread finds that profiler callback code is still present, it sleeps for 10 minutes before checking again.","pos":[4614,4775]},{"content":"The detach thread continues to recheck every 10 minutes.","pos":[4776,4832]},{"pos":[4839,5070],"content":"If the profiler specifies <ph id=\"ph1\">`dwExpectedCompletionMilliseconds`</ph> as 0 (zero), the CLR uses a default value of 5000, which means that it will perform a check after 5 seconds, again after 10 seconds, and then every 10 minutes thereafter.","source":"If the profiler specifies `dwExpectedCompletionMilliseconds` as 0 (zero), the CLR uses a default value of 5000, which means that it will perform a check after 5 seconds, again after 10 seconds, and then every 10 minutes thereafter."},{"pos":[5079,5091],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[5095,5199],"content":"<bpt id=\"p1\">**</bpt>Platforms:<ept id=\"p1\">**</ept> See <bpt id=\"p2\">[</bpt>System Requirements<ept id=\"p2\">](../../../../docs/framework/get-started/system-requirements.md)</ept>.","source":"**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md)."},{"pos":[5206,5240],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> CorProf.idl, CorProf.h","source":"**Header:** CorProf.idl, CorProf.h"},{"pos":[5247,5272],"content":"<bpt id=\"p1\">**</bpt>Library:<ept id=\"p1\">**</ept> CorGuids.lib","source":"**Library:** CorGuids.lib"},{"pos":[5279,5387],"content":"<bpt id=\"p1\">**</bpt>.NET Framework Versions:<ept id=\"p1\">**</ept> <ph id=\"ph1\">[!INCLUDE[net_current_v40plus](../../../../includes/net-current-v40plus-md.md)]</ph>","source":"**.NET Framework Versions:** [!INCLUDE[net_current_v40plus](../../../../includes/net-current-v40plus-md.md)]"},{"pos":[5396,5404],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5408,5520],"content":"<bpt id=\"p1\">[</bpt>ICorProfilerInfo3 Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo3-interface.md)</ept>","source":"[ICorProfilerInfo3 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo3-interface.md)"},{"pos":[5523,5621],"content":"<bpt id=\"p1\">[</bpt>Profiling Interfaces<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)</ept>","source":"[Profiling Interfaces](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)"},{"pos":[5624,5696],"content":"<bpt id=\"p1\">[</bpt>Profiling<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/index.md)</ept>","source":"[Profiling](../../../../docs/framework/unmanaged-api/profiling/index.md)"}]}