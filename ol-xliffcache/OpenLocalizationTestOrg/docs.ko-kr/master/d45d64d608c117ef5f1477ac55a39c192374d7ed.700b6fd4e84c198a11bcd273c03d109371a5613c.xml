{"content":"---\ntitle: \"Generics in the Run Time - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generics [C#], at run time\"\nms.assetid: 119df7e6-9ceb-49df-af36-24f8f8c0747f\n---\n# Generics in the Run Time (C# Programming Guide)\nWhen a generic type or method is compiled into Microsoft intermediate language (MSIL), it contains metadata that identifies it as having type parameters. How the MSIL for a generic type is used differs based on whether the supplied type parameter is a value type or reference type.  \n  \n When a generic type is first constructed with a value type as a parameter, the runtime creates a specialized generic type with the supplied parameter or parameters substituted in the appropriate locations in the MSIL. Specialized generic types are created one time for each unique value type that is used as a parameter.  \n  \n For example, suppose your program code declared a stack that is constructed of integers:  \n  \n [!code-csharp[csProgGuideGenerics#42](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#42)]  \n  \n At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that has the integer substituted appropriately for its parameter. Now, whenever your program code uses a stack of integers, the runtime reuses the generated specialized <xref:System.Collections.Generic.Stack%601> class. In the following example, two instances of a stack of integers are created, and they share a single instance of the `Stack<int>` code:  \n  \n [!code-csharp[csProgGuideGenerics#43](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#43)]  \n  \n However, suppose that another <xref:System.Collections.Generic.Stack%601> class with a different value type such as a `long` or a user-defined structure as its parameter is created at another point in your code. As a result, the runtime generates another version of the generic type and substitutes a `long` in the appropriate locations in MSIL. Conversions are no longer necessary because each specialized generic class natively contains the value type.  \n  \n Generics work somewhat differently for reference types. The first time a generic type is constructed with any reference type, the runtime creates a specialized generic type with object references substituted for the parameters in the MSIL. Then, every time that a constructed type is instantiated with a reference type as its parameter, regardless of what type it is, the runtime reuses the previously created specialized version of the generic type. This is possible because all references are the same size.  \n  \n For example, suppose you had two reference types, a `Customer` class and an `Order` class, and also suppose that you created a stack of `Customer` types:  \n  \n [!code-csharp[csProgGuideGenerics#47](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#47)]  \n  \n [!code-csharp[csProgGuideGenerics#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#44)]  \n  \n At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that stores object references that will be filled in later instead of storing data. Suppose the next line of code creates a stack of another reference type, which is named `Order`:  \n  \n [!code-csharp[csProgGuideGenerics#45](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#45)]  \n  \n Unlike with value types, another specialized version of the <xref:System.Collections.Generic.Stack%601> class is not created for the `Order` type. Instead, an instance of the specialized version of the <xref:System.Collections.Generic.Stack%601> class is created and the `orders` variable is set to reference it. Suppose that you then encountered a line of code to create a stack of a `Customer` type:  \n  \n [!code-csharp[csProgGuideGenerics#46](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#46)]  \n  \n As with the previous use of the <xref:System.Collections.Generic.Stack%601> class created by using the `Order` type, another instance of the specialized <xref:System.Collections.Generic.Stack%601> class is created. The pointers that are contained therein are set to reference an area of memory the size of a `Customer` type. Because the number of reference types can vary wildly from program to program, the C# implementation of generics greatly reduces the amount of code by reducing to one the number of specialized classes created by the compiler for generic classes of reference types.  \n  \n Moreover, when a generic C# class is instantiated by using a value type or reference type parameter, reflection can query it at runtime and both its actual type and its type parameter can be ascertained.  \n  \n## See also\n\n- <xref:System.Collections.Generic>\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)\n- [Generics](~/docs/standard/generics/index.md)\n","nodes":[{"pos":[4,204],"embed":true,"restype":"x-metadata","content":"title: \"Generics in the Run Time - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generics [C#], at run time\"\nms.assetid: 119df7e6-9ceb-49df-af36-24f8f8c0747f","nodes":[{"content":"Generics in the Run Time - C# Programming Guide","nodes":[{"pos":[0,47],"content":"Generics in the Run Time - C# Programming Guide","nodes":[{"content":"Generics in the Run Time - C# Programming Guide","pos":[0,47]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[211,258],"content":"Generics in the Run Time (C# Programming Guide)","linkify":"Generics in the Run Time (C# Programming Guide)","nodes":[{"content":"Generics in the Run Time (C# Programming Guide)","pos":[0,47]}]},{"content":"When a generic type or method is compiled into Microsoft intermediate language (MSIL), it contains metadata that identifies it as having type parameters.","pos":[259,412]},{"content":"How the MSIL for a generic type is used differs based on whether the supplied type parameter is a value type or reference type.","pos":[413,540]},{"content":"When a generic type is first constructed with a value type as a parameter, the runtime creates a specialized generic type with the supplied parameter or parameters substituted in the appropriate locations in the MSIL.","pos":[547,764]},{"content":"Specialized generic types are created one time for each unique value type that is used as a parameter.","pos":[765,867]},{"content":"For example, suppose your program code declared a stack that is constructed of integers:","pos":[874,962]},{"content":"At this point, the runtime generates a specialized version of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class that has the integer substituted appropriately for its parameter.","pos":[1100,1281],"source":"At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that has the integer substituted appropriately for its parameter."},{"content":"Now, whenever your program code uses a stack of integers, the runtime reuses the generated specialized <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class.","pos":[1282,1435],"source":" Now, whenever your program code uses a stack of integers, the runtime reuses the generated specialized <xref:System.Collections.Generic.Stack%601> class."},{"content":"In the following example, two instances of a stack of integers are created, and they share a single instance of the <ph id=\"ph1\">`Stack&lt;int&gt;`</ph> code:","pos":[1436,1570],"source":" In the following example, two instances of a stack of integers are created, and they share a single instance of the `Stack<int>` code:"},{"content":"However, suppose that another <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class with a different value type such as a <ph id=\"ph2\">`long`</ph> or a user-defined structure as its parameter is created at another point in your code.","pos":[1708,1919],"source":"However, suppose that another <xref:System.Collections.Generic.Stack%601> class with a different value type such as a `long` or a user-defined structure as its parameter is created at another point in your code."},{"content":"As a result, the runtime generates another version of the generic type and substitutes a <ph id=\"ph1\">`long`</ph> in the appropriate locations in MSIL.","pos":[1920,2053],"source":" As a result, the runtime generates another version of the generic type and substitutes a `long` in the appropriate locations in MSIL."},{"content":"Conversions are no longer necessary because each specialized generic class natively contains the value type.","pos":[2054,2162]},{"content":"Generics work somewhat differently for reference types.","pos":[2169,2224]},{"content":"The first time a generic type is constructed with any reference type, the runtime creates a specialized generic type with object references substituted for the parameters in the MSIL.","pos":[2225,2408]},{"content":"Then, every time that a constructed type is instantiated with a reference type as its parameter, regardless of what type it is, the runtime reuses the previously created specialized version of the generic type.","pos":[2409,2619]},{"content":"This is possible because all references are the same size.","pos":[2620,2678]},{"pos":[2685,2838],"content":"For example, suppose you had two reference types, a <ph id=\"ph1\">`Customer`</ph> class and an <ph id=\"ph2\">`Order`</ph> class, and also suppose that you created a stack of <ph id=\"ph3\">`Customer`</ph> types:","source":"For example, suppose you had two reference types, a `Customer` class and an `Order` class, and also suppose that you created a stack of `Customer` types:"},{"content":"At this point, the runtime generates a specialized version of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class that stores object references that will be filled in later instead of storing data.","pos":[3107,3306],"source":"At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that stores object references that will be filled in later instead of storing data."},{"content":"Suppose the next line of code creates a stack of another reference type, which is named <ph id=\"ph1\">`Order`</ph>:","pos":[3307,3403],"source":" Suppose the next line of code creates a stack of another reference type, which is named `Order`:"},{"content":"Unlike with value types, another specialized version of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class is not created for the <ph id=\"ph2\">`Order`</ph> type.","pos":[3541,3687],"source":"Unlike with value types, another specialized version of the <xref:System.Collections.Generic.Stack%601> class is not created for the `Order` type."},{"content":"Instead, an instance of the specialized version of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class is created and the <ph id=\"ph2\">`orders`</ph> variable is set to reference it.","pos":[3688,3853],"source":" Instead, an instance of the specialized version of the <xref:System.Collections.Generic.Stack%601> class is created and the `orders` variable is set to reference it."},{"content":"Suppose that you then encountered a line of code to create a stack of a <ph id=\"ph1\">`Customer`</ph> type:","pos":[3854,3942],"source":" Suppose that you then encountered a line of code to create a stack of a `Customer` type:"},{"content":"As with the previous use of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class created by using the <ph id=\"ph2\">`Order`</ph> type, another instance of the specialized <ph id=\"ph3\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> class is created.","pos":[4080,4294],"source":"As with the previous use of the <xref:System.Collections.Generic.Stack%601> class created by using the `Order` type, another instance of the specialized <xref:System.Collections.Generic.Stack%601> class is created."},{"content":"The pointers that are contained therein are set to reference an area of memory the size of a <ph id=\"ph1\">`Customer`</ph> type.","pos":[4295,4404],"source":" The pointers that are contained therein are set to reference an area of memory the size of a `Customer` type."},{"content":"Because the number of reference types can vary wildly from program to program, the C# implementation of generics greatly reduces the amount of code by reducing to one the number of specialized classes created by the compiler for generic classes of reference types.","pos":[4405,4669]},{"content":"Moreover, when a generic C# class is instantiated by using a value type or reference type parameter, reflection can query it at runtime and both its actual type and its type parameter can be ascertained.","pos":[4676,4879]},{"pos":[4888,4896],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4936,5002],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[5005,5103],"content":"<bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept>","source":"[Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)"},{"pos":[5106,5151],"content":"<bpt id=\"p1\">[</bpt>Generics<ept id=\"p1\">](~/docs/standard/generics/index.md)</ept>","source":"[Generics](~/docs/standard/generics/index.md)"}]}