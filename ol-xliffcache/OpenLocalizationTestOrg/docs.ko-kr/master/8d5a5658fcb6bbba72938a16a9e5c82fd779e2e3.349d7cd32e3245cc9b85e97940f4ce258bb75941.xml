{"content":"---\ntitle: \"Code Access Security Basics\"\nms.date: \"03/30/2017\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"security [.NET Framework], code access security\"\nms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n\n# Code Access Security Basics\n\n[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]\n\nEvery application that targets the common language runtime (that is, every managed application) must interact with the runtime's security system. When a managed application is loaded, its host automatically grants it a set of permissions. These permissions are determined by the host's local security settings or by the sandbox the application is in. Depending on these permissions, the application either runs properly or generates a security exception.\n\nThe default host for desktop applications allows code to run in full trust. Therefore, if your application targets the desktop, it has an unrestricted permission set. Other hosts or sandboxes provide a limited permission set for applications. Because the permission set can change from host to host, you must design your application to use only the permissions that your target host allows.\n\nYou must be familiar with the following code access security concepts in order to write effective applications that target the common language runtime:\n\n- **Type-safe code**: Type-safe code is code that accesses types only in well-defined, allowable ways. For example, given a valid object reference, type-safe code can access memory at fixed offsets that correspond to actual field members. If the code accesses memory at arbitrary offsets outside the range of memory that belongs to that object's publicly exposed fields, it is not type-safe. To enable code to benefit from code access security, you must use a compiler that generates verifiably type-safe code. For more information, see the [Writing Verifiably Type-Safe Code](#typesafe_code) section later in this topic.\n\n- **Imperative and declarative syntax**: Code that targets the common language runtime can interact with the security system by requesting permissions, demanding that callers have specified permissions, and overriding certain security settings (given enough privileges). You use two forms of syntax to programmatically interact with the .NET Framework security system: declarative syntax and imperative syntax. Declarative calls are performed using attributes; imperative calls are performed using new instances of classes within your code. Some calls can be performed only imperatively, others can be performed only declaratively, and some calls can be performed in either manner.\n\n- **Secure class libraries**: A secure class library uses security demands to ensure that the library's callers have permission to access the resources that the library exposes. For example, a secure class library might have a method for creating files that would demand that its callers have permissions to create files. The .NET Framework consists of secure class libraries. You should be aware of the permissions required to access any library that your code uses. For more information, see the [Using Secure Class Libraries](#secure_library) section later in this topic.\n\n- **Transparent code**: Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], in addition to identifying specific permissions, you must also determine whether your code should run as security-transparent. Security-transparent code cannot call types or members that are identified as security-critical. This rule applies to full-trust applications as well as partially trusted applications. For more information, see [Security-Transparent Code](../../../docs/framework/misc/security-transparent-code.md).\n\n<a name=\"typesafe_code\"></a>\n\n## Writing Verifiably Type-Safe Code\n\nJust-in-time (JIT) compilation performs a verification process that examines code and tries to determine whether the code is type-safe. Code that is proven during verification to be type-safe is called *verifiably type-safe code*. Code can be type-safe, yet might not be verifiably type-safe because of the limitations of the verification process or of the compiler. Not all languages are type-safe, and some language compilers, such as Microsoft Visual C++, cannot generate verifiably type-safe managed code. To determine whether the language compiler you use generates verifiably type-safe code, consult the compiler's documentation. If you use a language compiler that generates verifiably type-safe code only when you avoid certain language constructs, you might want to use the [PEVerify tool](../../../docs/framework/tools/peverify-exe-peverify-tool.md) to determine whether your code is verifiably type-safe.\n\nCode that is not verifiably type-safe can attempt to execute if security policy allows the code to bypass verification. However, because type safety is an essential part of the runtime's mechanism for isolating assemblies, security cannot be reliably enforced if code violates the rules of type safety. By default, code that is not type-safe is allowed to run only if it originates from the local computer. Therefore, mobile code should be type-safe.\n\n<a name=\"secure_library\"></a>\n\n## Using Secure Class Libraries\n\nIf your code requests and is granted the permissions required by the class library, it will be allowed to access the library and the resources that the library exposes will be protected from unauthorized access. If your code does not have the appropriate permissions, it will not be allowed to access the class library, and malicious code will not be able to use your code to indirectly access protected resources. Other code that calls your code must also have permission to access the library. If it does not, your code will be restricted from running as well.\n\nCode access security does not eliminate the possibility of human error in writing code. However, if your application uses secure class libraries to access protected resources, the security risk for application code is decreased, because class libraries are closely scrutinized for potential security problems.\n\n## Declarative Security\n\nDeclarative security syntax uses [attributes](../../../docs/standard/attributes/index.md) to place security information into the [metadata](../../../docs/standard/metadata-and-self-describing-components.md) of your code. Attributes can be placed at the assembly, class, or member level, to indicate the type of request, demand, or override you want to use. Requests are used in applications that target the common language runtime to inform the runtime security system about the permissions that your application needs or does not want. Demands and overrides are used in libraries to help protect resources from callers or to override default security behavior.\n\n> [!NOTE]\n> In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], there have been important changes to the .NET Framework security model and terminology. For more information about these changes, see [Security Changes](../../../docs/framework/security/security-changes.md).\n\nIn order to use declarative security calls, you must initialize the state data of the permission object so that it represents the particular form of permission you need. Every built-in permission has an attribute that is passed a <xref:System.Security.Permissions.SecurityAction> enumeration to describe the type of security operation you want to perform. However, permissions also accept their own parameters that are exclusive to them.\n\nThe following code fragment shows declarative syntax for requesting that your code's callers have a custom permission called `MyPermission`. This permission is a hypothetical custom permission and does not exist in the .NET Framework. In this example, the declarative call is placed directly before the class definition, specifying that this permission be applied to the class level. The attribute is passed a **SecurityAction.Demand** structure to specify that callers must have this permission in order to run.\n\n```vb\n<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1\n\n   Public Sub New()\n      'The constructor is protected by the security call.\n   End Sub\n\n   Public Sub MyMethod()\n      'This method is protected by the security call.\n   End Sub\n\n   Public Sub YourMethod()\n      'This method is protected by the security call.\n   End Sub\nEnd Class\n```\n\n```csharp\n[MyPermission(SecurityAction.Demand, Unrestricted = true)]\npublic class MyClass\n{\n   public MyClass()\n   {\n      //The constructor is protected by the security call.\n   }\n\n   public void MyMethod()\n   {\n      //This method is protected by the security call.\n   }\n\n   public void YourMethod()\n   {\n      //This method is protected by the security call.\n   }\n}\n```\n\n## Imperative Security\n\nImperative security syntax issues a security call by creating a new instance of the permission object you want to invoke. You can use imperative syntax to perform demands and overrides, but not requests.\n\nBefore you make the security call, you must initialize the state data of the permission object so that it represents the particular form of the permission you need. For example, when creating a <xref:System.Security.Permissions.FileIOPermission> object, you can use the constructor to initialize the **FileIOPermission** object so that it represents either unrestricted access to all files or no access to files. Or, you can use a different **FileIOPermission** object, passing parameters that indicate the type of access you want the object to represent (that is, read, append, or write) and what files you want the object to protect.\n\nIn addition to using imperative security syntax to invoke a single security object, you can use it to initialize a group of permissions in a permission set. For example, this technique is the only way to reliably perform [assert](../../../docs/framework/misc/using-the-assert-method.md) calls on multiple permissions in one method. Use the <xref:System.Security.PermissionSet> and <xref:System.Security.NamedPermissionSet> classes to create a group of permissions and then call the appropriate method to invoke the desired security call.\n\nYou can use imperative syntax to perform demands and overrides, but not requests. You might use imperative syntax for demands and overrides instead of declarative syntax when information that you need in order to initialize the permission state becomes known only at run time. For example, if you want to ensure that callers have permission to read a certain file, but you do not know the name of that file until run time, use an imperative demand. You might also choose to use imperative checks instead of declarative checks when you need to determine at run time whether a condition holds and, based on the result of the test, make a security demand (or not).\n\nThe following code fragment shows imperative syntax for requesting that your code's callers have a custom permission called `MyPermission`. This permission is a hypothetical custom permission and does not exist in the .NET Framework. A new instance of `MyPermission` is created in `MyMethod`, guarding only this method with the security call.\n\n```vb\nPublic Class MyClass1\n\n   Public Sub New()\n\n   End Sub\n\n   Public Sub MyMethod()\n      'MyPermission is demanded using imperative syntax.\n      Dim Perm As New MyPermission()\n      Perm.Demand()\n      'This method is protected by the security call.\n   End Sub\n\n   Public Sub YourMethod()\n      'YourMethod 'This method is not protected by the security call.\n   End Sub\nEnd Class\n```\n\n```csharp\npublic class MyClass {\n   public MyClass(){\n\n   }\n\n   public void MyMethod() {\n       //MyPermission is demanded using imperative syntax.\n       MyPermission Perm = new MyPermission();\n       Perm.Demand();\n       //This method is protected by the security call.\n   }\n\n   public void YourMethod() {\n       //This method is not protected by the security call.\n   }\n}\n```\n\n## Using Managed Wrapper Classes\n\nMost applications and components (except secure libraries) should not directly call unmanaged code. There are several reasons for this. If code calls unmanaged code directly, it will not be allowed to run in many circumstances because code must be granted a high level of trust to call native code. If policy is modified to allow such an application to run, it can significantly weaken the security of the system, leaving the application free to perform almost any operation.\n\nAdditionally, code that has permission to access unmanaged code can probably perform almost any operation by calling into an unmanaged API. For example, code that has permission to call unmanaged code does not need <xref:System.Security.Permissions.FileIOPermission> to access a file; it can just call an unmanaged (Win32) file API directly, bypassing the managed file API that requires **FileIOPermission**. If managed code has permission to call into unmanaged code and does call directly into unmanaged code, the security system will be unable to reliably enforce security restrictions, since the runtime cannot enforce such restrictions on unmanaged code.\n\nIf you want your application to perform an operation that requires accessing unmanaged code, it should do so through a trusted managed class that wraps the required functionality (if such a class exists). Do not create a wrapper class yourself if one already exists in a secure class library. The wrapper class, which must be granted a high degree of trust to be allowed to make the call into unmanaged code, is responsible for demanding that its callers have the appropriate permissions. If you use the wrapper class, your code only needs to request and be granted the permissions that the wrapper class demands.\n\n## See also\n\n- <xref:System.Security.PermissionSet>\n- <xref:System.Security.Permissions.FileIOPermission>\n- <xref:System.Security.NamedPermissionSet>\n- <xref:System.Security.Permissions.SecurityAction>\n- [Assert](../../../docs/framework/misc/using-the-assert-method.md)\n- [Code Access Security](../../../docs/framework/misc/code-access-security.md)\n- [Code Access Security Basics](../../../docs/framework/misc/code-access-security-basics.md)\n- [Attributes](../../../docs/standard/attributes/index.md)\n- [Metadata and Self-Describing Components](../../../docs/standard/metadata-and-self-describing-components.md)\n","nodes":[{"pos":[4,256],"embed":true,"restype":"x-metadata","content":"title: \"Code Access Security Basics\"\nms.date: \"03/30/2017\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"security [.NET Framework], code access security\"\nms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Code Access Security Basics","nodes":[{"pos":[0,27],"content":"Code Access Security Basics","nodes":[{"content":"Code Access Security Basics","pos":[0,27]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[264,291],"content":"Code Access Security Basics","linkify":"Code Access Security Basics","nodes":[{"content":"Code Access Security Basics","pos":[0,27]}]},{"content":"Every application that targets the common language runtime (that is, every managed application) must interact with the runtime's security system.","pos":[367,512]},{"content":"When a managed application is loaded, its host automatically grants it a set of permissions.","pos":[513,605]},{"content":"These permissions are determined by the host's local security settings or by the sandbox the application is in.","pos":[606,717]},{"content":"Depending on these permissions, the application either runs properly or generates a security exception.","pos":[718,821]},{"content":"The default host for desktop applications allows code to run in full trust.","pos":[823,898]},{"content":"Therefore, if your application targets the desktop, it has an unrestricted permission set.","pos":[899,989]},{"content":"Other hosts or sandboxes provide a limited permission set for applications.","pos":[990,1065]},{"content":"Because the permission set can change from host to host, you must design your application to use only the permissions that your target host allows.","pos":[1066,1213]},{"content":"You must be familiar with the following code access security concepts in order to write effective applications that target the common language runtime:","pos":[1215,1366]},{"content":"<bpt id=\"p1\">**</bpt>Type-safe code<ept id=\"p1\">**</ept>: Type-safe code is code that accesses types only in well-defined, allowable ways.","pos":[1370,1470],"source":"**Type-safe code**: Type-safe code is code that accesses types only in well-defined, allowable ways."},{"content":"For example, given a valid object reference, type-safe code can access memory at fixed offsets that correspond to actual field members.","pos":[1471,1606]},{"content":"If the code accesses memory at arbitrary offsets outside the range of memory that belongs to that object's publicly exposed fields, it is not type-safe.","pos":[1607,1759]},{"content":"To enable code to benefit from code access security, you must use a compiler that generates verifiably type-safe code.","pos":[1760,1878]},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Writing Verifiably Type-Safe Code<ept id=\"p1\">](#typesafe_code)</ept> section later in this topic.","pos":[1879,1989],"source":" For more information, see the [Writing Verifiably Type-Safe Code](#typesafe_code) section later in this topic."},{"content":"<bpt id=\"p1\">**</bpt>Imperative and declarative syntax<ept id=\"p1\">**</ept>: Code that targets the common language runtime can interact with the security system by requesting permissions, demanding that callers have specified permissions, and overriding certain security settings (given enough privileges).","pos":[1993,2261],"source":"**Imperative and declarative syntax**: Code that targets the common language runtime can interact with the security system by requesting permissions, demanding that callers have specified permissions, and overriding certain security settings (given enough privileges)."},{"content":"You use two forms of syntax to programmatically interact with the .NET Framework security system: declarative syntax and imperative syntax.","pos":[2262,2401]},{"content":"Declarative calls are performed using attributes; imperative calls are performed using new instances of classes within your code.","pos":[2402,2531]},{"content":"Some calls can be performed only imperatively, others can be performed only declaratively, and some calls can be performed in either manner.","pos":[2532,2672]},{"content":"<bpt id=\"p1\">**</bpt>Secure class libraries<ept id=\"p1\">**</ept>: A secure class library uses security demands to ensure that the library's callers have permission to access the resources that the library exposes.","pos":[2676,2851],"source":"**Secure class libraries**: A secure class library uses security demands to ensure that the library's callers have permission to access the resources that the library exposes."},{"content":"For example, a secure class library might have a method for creating files that would demand that its callers have permissions to create files.","pos":[2852,2995]},{"content":"The .NET Framework consists of secure class libraries.","pos":[2996,3050]},{"content":"You should be aware of the permissions required to access any library that your code uses.","pos":[3051,3141]},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Using Secure Class Libraries<ept id=\"p1\">](#secure_library)</ept> section later in this topic.","pos":[3142,3248],"source":" For more information, see the [Using Secure Class Libraries](#secure_library) section later in this topic."},{"content":"<bpt id=\"p1\">**</bpt>Transparent code<ept id=\"p1\">**</ept>: Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, in addition to identifying specific permissions, you must also determine whether your code should run as security-transparent.","pos":[3252,3482],"source":"**Transparent code**: Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], in addition to identifying specific permissions, you must also determine whether your code should run as security-transparent."},{"content":"Security-transparent code cannot call types or members that are identified as security-critical.","pos":[3483,3579]},{"content":"This rule applies to full-trust applications as well as partially trusted applications.","pos":[3580,3667]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Security-Transparent Code<ept id=\"p1\">](../../../docs/framework/misc/security-transparent-code.md)</ept>.","pos":[3668,3781],"source":" For more information, see [Security-Transparent Code](../../../docs/framework/misc/security-transparent-code.md)."},{"pos":[3816,3849],"content":"Writing Verifiably Type-Safe Code","linkify":"Writing Verifiably Type-Safe Code","nodes":[{"content":"Writing Verifiably Type-Safe Code","pos":[0,33]}]},{"content":"Just-in-time (JIT) compilation performs a verification process that examines code and tries to determine whether the code is type-safe.","pos":[3851,3986]},{"content":"Code that is proven during verification to be type-safe is called <bpt id=\"p1\">*</bpt>verifiably type-safe code<ept id=\"p1\">*</ept>.","pos":[3987,4081],"source":" Code that is proven during verification to be type-safe is called *verifiably type-safe code*."},{"content":"Code can be type-safe, yet might not be verifiably type-safe because of the limitations of the verification process or of the compiler.","pos":[4082,4217]},{"content":"Not all languages are type-safe, and some language compilers, such as Microsoft Visual C++, cannot generate verifiably type-safe managed code.","pos":[4218,4360]},{"content":"To determine whether the language compiler you use generates verifiably type-safe code, consult the compiler's documentation.","pos":[4361,4486]},{"content":"If you use a language compiler that generates verifiably type-safe code only when you avoid certain language constructs, you might want to use the <bpt id=\"p1\">[</bpt>PEVerify tool<ept id=\"p1\">](../../../docs/framework/tools/peverify-exe-peverify-tool.md)</ept> to determine whether your code is verifiably type-safe.","pos":[4487,4766],"source":" If you use a language compiler that generates verifiably type-safe code only when you avoid certain language constructs, you might want to use the [PEVerify tool](../../../docs/framework/tools/peverify-exe-peverify-tool.md) to determine whether your code is verifiably type-safe."},{"content":"Code that is not verifiably type-safe can attempt to execute if security policy allows the code to bypass verification.","pos":[4768,4887]},{"content":"However, because type safety is an essential part of the runtime's mechanism for isolating assemblies, security cannot be reliably enforced if code violates the rules of type safety.","pos":[4888,5070]},{"content":"By default, code that is not type-safe is allowed to run only if it originates from the local computer.","pos":[5071,5174]},{"content":"Therefore, mobile code should be type-safe.","pos":[5175,5218]},{"pos":[5254,5282],"content":"Using Secure Class Libraries","linkify":"Using Secure Class Libraries","nodes":[{"content":"Using Secure Class Libraries","pos":[0,28]}]},{"content":"If your code requests and is granted the permissions required by the class library, it will be allowed to access the library and the resources that the library exposes will be protected from unauthorized access.","pos":[5284,5495]},{"content":"If your code does not have the appropriate permissions, it will not be allowed to access the class library, and malicious code will not be able to use your code to indirectly access protected resources.","pos":[5496,5698]},{"content":"Other code that calls your code must also have permission to access the library.","pos":[5699,5779]},{"content":"If it does not, your code will be restricted from running as well.","pos":[5780,5846]},{"content":"Code access security does not eliminate the possibility of human error in writing code.","pos":[5848,5935]},{"content":"However, if your application uses secure class libraries to access protected resources, the security risk for application code is decreased, because class libraries are closely scrutinized for potential security problems.","pos":[5936,6157]},{"pos":[6162,6182],"content":"Declarative Security","linkify":"Declarative Security","nodes":[{"content":"Declarative Security","pos":[0,20]}]},{"content":"Declarative security syntax uses <bpt id=\"p1\">[</bpt>attributes<ept id=\"p1\">](../../../docs/standard/attributes/index.md)</ept> to place security information into the <bpt id=\"p2\">[</bpt>metadata<ept id=\"p2\">](../../../docs/standard/metadata-and-self-describing-components.md)</ept> of your code.","pos":[6184,6404],"source":"Declarative security syntax uses [attributes](../../../docs/standard/attributes/index.md) to place security information into the [metadata](../../../docs/standard/metadata-and-self-describing-components.md) of your code."},{"content":"Attributes can be placed at the assembly, class, or member level, to indicate the type of request, demand, or override you want to use.","pos":[6405,6540]},{"content":"Requests are used in applications that target the common language runtime to inform the runtime security system about the permissions that your application needs or does not want.","pos":[6541,6720]},{"content":"Demands and overrides are used in libraries to help protect resources from callers or to override default security behavior.","pos":[6721,6845]},{"pos":[6849,7137],"content":"[!NOTE]\nIn the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], there have been important changes to the .NET Framework security model and terminology. For more information about these changes, see [Security Changes](../../../docs/framework/security/security-changes.md).","leadings":["","> "],"nodes":[{"content":"In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], there have been important changes to the .NET Framework security model and terminology. For more information about these changes, see [Security Changes](../../../docs/framework/security/security-changes.md).","pos":[8,286],"nodes":[{"content":"In the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, there have been important changes to the .NET Framework security model and terminology.","pos":[0,158],"source":"In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], there have been important changes to the .NET Framework security model and terminology."},{"content":"For more information about these changes, see <bpt id=\"p1\">[</bpt>Security Changes<ept id=\"p1\">](../../../docs/framework/security/security-changes.md)</ept>.","pos":[159,278],"source":" For more information about these changes, see [Security Changes](../../../docs/framework/security/security-changes.md)."}]}]},{"content":"In order to use declarative security calls, you must initialize the state data of the permission object so that it represents the particular form of permission you need.","pos":[7139,7308]},{"content":"Every built-in permission has an attribute that is passed a <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityAction&gt;</ph> enumeration to describe the type of security operation you want to perform.","pos":[7309,7494],"source":" Every built-in permission has an attribute that is passed a <xref:System.Security.Permissions.SecurityAction> enumeration to describe the type of security operation you want to perform."},{"content":"However, permissions also accept their own parameters that are exclusive to them.","pos":[7495,7576]},{"content":"The following code fragment shows declarative syntax for requesting that your code's callers have a custom permission called <ph id=\"ph1\">`MyPermission`</ph>.","pos":[7578,7718],"source":"The following code fragment shows declarative syntax for requesting that your code's callers have a custom permission called `MyPermission`."},{"content":"This permission is a hypothetical custom permission and does not exist in the .NET Framework.","pos":[7719,7812]},{"content":"In this example, the declarative call is placed directly before the class definition, specifying that this permission be applied to the class level.","pos":[7813,7961]},{"content":"The attribute is passed a <bpt id=\"p1\">**</bpt>SecurityAction.Demand<ept id=\"p1\">**</ept> structure to specify that callers must have this permission in order to run.","pos":[7962,8090],"source":" The attribute is passed a **SecurityAction.Demand** structure to specify that callers must have this permission in order to run."},{"pos":[8845,8864],"content":"Imperative Security","linkify":"Imperative Security","nodes":[{"content":"Imperative Security","pos":[0,19]}]},{"content":"Imperative security syntax issues a security call by creating a new instance of the permission object you want to invoke.","pos":[8866,8987]},{"content":"You can use imperative syntax to perform demands and overrides, but not requests.","pos":[8988,9069]},{"content":"Before you make the security call, you must initialize the state data of the permission object so that it represents the particular form of the permission you need.","pos":[9071,9235]},{"content":"For example, when creating a <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> object, you can use the constructor to initialize the <bpt id=\"p1\">**</bpt>FileIOPermission<ept id=\"p1\">**</ept> object so that it represents either unrestricted access to all files or no access to files.","pos":[9236,9483],"source":" For example, when creating a <xref:System.Security.Permissions.FileIOPermission> object, you can use the constructor to initialize the **FileIOPermission** object so that it represents either unrestricted access to all files or no access to files."},{"content":"Or, you can use a different <bpt id=\"p1\">**</bpt>FileIOPermission<ept id=\"p1\">**</ept> object, passing parameters that indicate the type of access you want the object to represent (that is, read, append, or write) and what files you want the object to protect.","pos":[9484,9706],"source":" Or, you can use a different **FileIOPermission** object, passing parameters that indicate the type of access you want the object to represent (that is, read, append, or write) and what files you want the object to protect."},{"content":"In addition to using imperative security syntax to invoke a single security object, you can use it to initialize a group of permissions in a permission set.","pos":[9708,9864]},{"content":"For example, this technique is the only way to reliably perform <bpt id=\"p1\">[</bpt>assert<ept id=\"p1\">](../../../docs/framework/misc/using-the-assert-method.md)</ept> calls on multiple permissions in one method.","pos":[9865,10039],"source":" For example, this technique is the only way to reliably perform [assert](../../../docs/framework/misc/using-the-assert-method.md) calls on multiple permissions in one method."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Security.PermissionSet&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Security.NamedPermissionSet&gt;</ph> classes to create a group of permissions and then call the appropriate method to invoke the desired security call.","pos":[10040,10245],"source":" Use the <xref:System.Security.PermissionSet> and <xref:System.Security.NamedPermissionSet> classes to create a group of permissions and then call the appropriate method to invoke the desired security call."},{"content":"You can use imperative syntax to perform demands and overrides, but not requests.","pos":[10247,10328]},{"content":"You might use imperative syntax for demands and overrides instead of declarative syntax when information that you need in order to initialize the permission state becomes known only at run time.","pos":[10329,10523]},{"content":"For example, if you want to ensure that callers have permission to read a certain file, but you do not know the name of that file until run time, use an imperative demand.","pos":[10524,10695]},{"content":"You might also choose to use imperative checks instead of declarative checks when you need to determine at run time whether a condition holds and, based on the result of the test, make a security demand (or not).","pos":[10696,10908]},{"content":"The following code fragment shows imperative syntax for requesting that your code's callers have a custom permission called <ph id=\"ph1\">`MyPermission`</ph>.","pos":[10910,11049],"source":"The following code fragment shows imperative syntax for requesting that your code's callers have a custom permission called `MyPermission`."},{"content":"This permission is a hypothetical custom permission and does not exist in the .NET Framework.","pos":[11050,11143]},{"content":"A new instance of <ph id=\"ph1\">`MyPermission`</ph> is created in <ph id=\"ph2\">`MyMethod`</ph>, guarding only this method with the security call.","pos":[11144,11252],"source":" A new instance of `MyPermission` is created in `MyMethod`, guarding only this method with the security call."},{"pos":[12028,12057],"content":"Using Managed Wrapper Classes","linkify":"Using Managed Wrapper Classes","nodes":[{"content":"Using Managed Wrapper Classes","pos":[0,29]}]},{"content":"Most applications and components (except secure libraries) should not directly call unmanaged code.","pos":[12059,12158]},{"content":"There are several reasons for this.","pos":[12159,12194]},{"content":"If code calls unmanaged code directly, it will not be allowed to run in many circumstances because code must be granted a high level of trust to call native code.","pos":[12195,12357]},{"content":"If policy is modified to allow such an application to run, it can significantly weaken the security of the system, leaving the application free to perform almost any operation.","pos":[12358,12534]},{"content":"Additionally, code that has permission to access unmanaged code can probably perform almost any operation by calling into an unmanaged API.","pos":[12536,12675]},{"content":"For example, code that has permission to call unmanaged code does not need <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> to access a file; it can just call an unmanaged (Win32) file API directly, bypassing the managed file API that requires <bpt id=\"p1\">**</bpt>FileIOPermission<ept id=\"p1\">**</ept>.","pos":[12676,12944],"source":" For example, code that has permission to call unmanaged code does not need <xref:System.Security.Permissions.FileIOPermission> to access a file; it can just call an unmanaged (Win32) file API directly, bypassing the managed file API that requires **FileIOPermission**."},{"content":"If managed code has permission to call into unmanaged code and does call directly into unmanaged code, the security system will be unable to reliably enforce security restrictions, since the runtime cannot enforce such restrictions on unmanaged code.","pos":[12945,13195]},{"content":"If you want your application to perform an operation that requires accessing unmanaged code, it should do so through a trusted managed class that wraps the required functionality (if such a class exists).","pos":[13197,13401]},{"content":"Do not create a wrapper class yourself if one already exists in a secure class library.","pos":[13402,13489]},{"content":"The wrapper class, which must be granted a high degree of trust to be allowed to make the call into unmanaged code, is responsible for demanding that its callers have the appropriate permissions.","pos":[13490,13685]},{"content":"If you use the wrapper class, your code only needs to request and be granted the permissions that the wrapper class demands.","pos":[13686,13810]},{"pos":[13815,13823],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[14016,14081],"content":"<bpt id=\"p1\">[</bpt>Assert<ept id=\"p1\">](../../../docs/framework/misc/using-the-assert-method.md)</ept>","source":"[Assert](../../../docs/framework/misc/using-the-assert-method.md)"},{"pos":[14084,14160],"content":"<bpt id=\"p1\">[</bpt>Code Access Security<ept id=\"p1\">](../../../docs/framework/misc/code-access-security.md)</ept>","source":"[Code Access Security](../../../docs/framework/misc/code-access-security.md)"},{"pos":[14163,14253],"content":"<bpt id=\"p1\">[</bpt>Code Access Security Basics<ept id=\"p1\">](../../../docs/framework/misc/code-access-security-basics.md)</ept>","source":"[Code Access Security Basics](../../../docs/framework/misc/code-access-security-basics.md)"},{"pos":[14256,14312],"content":"<bpt id=\"p1\">[</bpt>Attributes<ept id=\"p1\">](../../../docs/standard/attributes/index.md)</ept>","source":"[Attributes](../../../docs/standard/attributes/index.md)"},{"pos":[14315,14423],"content":"<bpt id=\"p1\">[</bpt>Metadata and Self-Describing Components<ept id=\"p1\">](../../../docs/standard/metadata-and-self-describing-components.md)</ept>","source":"[Metadata and Self-Describing Components](../../../docs/standard/metadata-and-self-describing-components.md)"}]}