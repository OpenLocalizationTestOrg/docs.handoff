{"content":"---\ntitle: \"releaseHandleFailed MDA\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"managed debugging assistants (MDAs), handles\"\n  - \"release handle failed\"\n  - \"CriticalHandle class, run-time errors\"\n  - \"releaseHandleFailed MDA\"\n  - \"ReleaseHandle method\"\n  - \"SafeHandle class, run-time errors\"\n  - \"MDAs (managed debugging assistants), handles\"\nms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# releaseHandleFailed MDA\nThe `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.  \n  \n## Symptoms  \n Resource or memory leaks.  If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.  \n  \n## Cause  \n Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource. However, the requirements are as follows:  \n  \n-   <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources. A memory leak would make the process unusable over time.  \n  \n-   The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function. Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it. Therefore, failure implies resource leaks.  \n  \n-   Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself. It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.  \n  \n## Resolution  \n The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere. This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime. If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.  \n  \n There are a number of ways in which incorrect handle duplication can occur:  \n  \n-   Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method. Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods. These latter methods specify the region of code in which the raw handle value may be safely used. Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread. Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.  \n  \n-   Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle. If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.  \n  \n-   When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable. In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually. This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle. Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point. The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail. The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy. If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.  \n  \n-   It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function. This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with. It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.  The handle value can be compared with the value reported by this MDA.  \n  \n-   Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace. An erroneous release of one handle type can cause problems with another. For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely. This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type. If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.  \n  \n## Effect on the Runtime  \n This MDA has no effect on the CLR.  \n  \n## Output  \n A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle. For example:  \n  \n```  \n\"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'   \nfailed to properly release the handle with value 0x0000BEEF. This   \nusually indicates that the handle was released incorrectly via   \nanother means (such as extracting the handle using DangerousGetHandle   \nand closing it directly or building another SafeHandle around it.\"  \n```  \n  \n## Configuration  \n  \n```xml  \n<mdaConfig>  \n  <assistants>  \n    <releaseHandleFailed/>  \n  </assistants>  \n</mdaConfig>  \n```  \n  \n## Example  \n The following is a code example that can activate the `releaseHandleFailed` MDA.  \n  \n```csharp\nbool ReleaseHandle()  \n{  \n    // Calling the Win32 CloseHandle function to release the   \n    // native handle wrapped by this SafeHandle. This method returns   \n    // false on failure, but should only fail if the input is invalid   \n    // (which should not happen here). The method specifically must not   \n    // fail simply because of lack of resources or other transient   \n    // failures beyond the userâ€™s control. That would make it unacceptable   \n    // to call CloseHandle as part of the implementation of this method.  \n    return CloseHandle(handle);  \n}  \n```  \n  \n## See also\n\n- <xref:System.Runtime.InteropServices.MarshalAsAttribute>\n- [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)\n- [Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)\n","nodes":[{"pos":[4,437],"embed":true,"restype":"x-metadata","content":"title: \"releaseHandleFailed MDA\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"managed debugging assistants (MDAs), handles\"\n  - \"release handle failed\"\n  - \"CriticalHandle class, run-time errors\"\n  - \"releaseHandleFailed MDA\"\n  - \"ReleaseHandle method\"\n  - \"SafeHandle class, run-time errors\"\n  - \"MDAs (managed debugging assistants), handles\"\nms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"releaseHandleFailed MDA","nodes":[{"pos":[0,23],"content":"releaseHandleFailed MDA","nodes":[{"content":"releaseHandleFailed MDA","pos":[0,23]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[444,467],"content":"releaseHandleFailed MDA","linkify":"releaseHandleFailed MDA","nodes":[{"content":"releaseHandleFailed MDA","pos":[0,23]}]},{"pos":[468,792],"content":"The <ph id=\"ph1\">`releaseHandleFailed`</ph> managed debugging assistant (MDA) is activated is to notify developers when the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method of a class derived from <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> returns <ph id=\"ph5\">`false`</ph>.","source":"The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`."},{"pos":[801,809],"content":"Symptoms","linkify":"Symptoms","nodes":[{"content":"Symptoms","pos":[0,8]}]},{"content":"Resource or memory leaks.","pos":[813,838]},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method of the class deriving from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> fails, then the resource encapsulated by the class might not have been released or cleaned up.","pos":[840,1146],"source":"  If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up."},{"pos":[1155,1160],"content":"Cause","linkify":"Cause","nodes":[{"content":"Cause","pos":[0,5]}]},{"content":"Users must provide the implementation of the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method if they create classes that derive from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>; thus, the circumstances are specific to the individual resource.","pos":[1164,1492],"source":"Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource."},{"content":"However, the requirements are as follows:","pos":[1493,1534]},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> types represent wrappers around vital process resources.","pos":[1544,1706],"source":"<xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources."},{"content":"A memory leak would make the process unusable over time.","pos":[1707,1763]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method must not fail to perform its function.","pos":[1773,1888],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function."},{"content":"Once the process acquires such a resource, <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> is the only way to release it.","pos":[1889,2028],"source":" Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it."},{"content":"Therefore, failure implies resource leaks.","pos":[2029,2071]},{"content":"Any failure that does occur during the execution of <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph>, impeding the release of the resource, is a bug in the implementation of the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method itself.","pos":[2081,2356],"source":"Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself."},{"content":"It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.","pos":[2357,2520]},{"pos":[2529,2539],"content":"Resolution","linkify":"Resolution","nodes":[{"content":"Resolution","pos":[0,10]}]},{"content":"The code that uses the specific <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> (or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> and copied elsewhere.","pos":[2543,2878],"source":"The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere."},{"content":"This is the usual cause of failures within <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.","pos":[2879,3127],"source":" This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime."},{"content":"If the raw handle copy is subsequently closed, it can cause a later <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> call to fail because the close is attempted on the same handle, which is now invalid.","pos":[3128,3347],"source":" If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid."},{"content":"There are a number of ways in which incorrect handle duplication can occur:","pos":[3354,3429]},{"content":"Look for calls to the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> method.","pos":[3439,3539],"source":"Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method."},{"content":"Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> methods.","pos":[3540,3797],"source":" Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods."},{"content":"These latter methods specify the region of code in which the raw handle value may be safely used.","pos":[3798,3895]},{"content":"Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> on another thread.","pos":[3896,4184],"source":" Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread."},{"content":"Once all uses of <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call <ph id=\"ph2\">`CloseHandle`</ph> or another low-level native method that will release the handle.","pos":[4185,4498],"source":" Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle."},{"content":"Ensure that the code that is used to initialize the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> with a valid raw handle value owns the handle.","pos":[4508,4655],"source":"Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle."},{"content":"If you form a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> around a handle your code does not own without setting the <ph id=\"ph2\">`ownsHandle`</ph> parameter to <ph id=\"ph3\">`false`</ph> in the base constructor, then both the <ph id=\"ph4\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> and the real handle owner can try to close the handle, leading to an error in <ph id=\"ph5\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> if the <ph id=\"ph6\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> loses the race.","pos":[4656,5115],"source":" If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race."},{"content":"When a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> is marshaled between application domains, confirm the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> derivation being used has been marked as serializable.","pos":[5125,5338],"source":"When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable."},{"content":"In the rare cases where a class derived from <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> has been made serializable, it should implement the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface or use one of the other techniques for controlling the serialization and deserialization process manually.","pos":[5339,5651],"source":" In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually."},{"content":"This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> instances thinking they own the same handle.","pos":[5652,5883],"source":" This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle."},{"content":"Both will try to call <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> on the same handle at some point.","pos":[5884,6005],"source":" Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point."},{"content":"The second <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to do this will fail.","pos":[6006,6087],"source":" The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail."},{"content":"The correct course of action when serializing a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> is to call the <ph id=\"ph2\">`DuplicateHandle`</ph> function or a similar function for your native handle type to make a distinct legal handle copy.","pos":[6088,6314],"source":" The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy."},{"content":"If your handle type does not support this then the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> type wrapping it cannot be made serializable.","pos":[6315,6460],"source":" If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable."},{"content":"It may be possible to track where a handle is being closed early, leading to a failure when the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the <ph id=\"ph2\">`CloseHandle`</ph> function.","pos":[6470,6780],"source":"It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function."},{"content":"This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.","pos":[6781,6920]},{"content":"It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.","pos":[6921,7117]},{"content":"The handle value can be compared with the value reported by this MDA.","pos":[7119,7188]},{"content":"Note that some native handle types, such as all the Win32 handles that can be released via the <ph id=\"ph1\">`CloseHandle`</ph> function, share the same handle namespace.","pos":[7198,7349],"source":"Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace."},{"content":"An erroneous release of one handle type can cause problems with another.","pos":[7350,7422]},{"content":"For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.","pos":[7423,7560]},{"content":"This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.","pos":[7561,7704]},{"content":"If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.","pos":[7705,7824]},{"pos":[7833,7854],"content":"Effect on the Runtime","linkify":"Effect on the Runtime","nodes":[{"content":"Effect on the Runtime","pos":[0,21]}]},{"content":"This MDA has no effect on the CLR.","pos":[7858,7892]},{"pos":[7901,7907],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"A message indicating that a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> or a <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> failed to properly release the handle.","pos":[7911,8084],"source":"A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle."},{"content":"For example:","pos":[8085,8097]},{"pos":[8462,8475],"content":"Configuration","linkify":"Configuration","nodes":[{"content":"Configuration","pos":[0,13]}]},{"pos":[8595,8602],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8606,8686],"content":"The following is a code example that can activate the <ph id=\"ph1\">`releaseHandleFailed`</ph> MDA.","source":"The following is a code example that can activate the `releaseHandleFailed` MDA."},{"pos":[9286,9294],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9357,9510],"content":"<bpt id=\"p1\">[</bpt>Diagnosing Errors with Managed Debugging Assistants<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)</ept>","source":"[Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)"},{"pos":[9513,9588],"content":"<bpt id=\"p1\">[</bpt>Interop Marshaling<ept id=\"p1\">](../../../docs/framework/interop/interop-marshaling.md)</ept>","source":"[Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)"}]}