{"content":"---\ntitle: Tour of .NET\ndescription: A guided tour through some of the prominent features of the .NET platform.\nkeywords: .NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async\nauthor: cartermp\nms.author: wiwagn\nms.date: 02/09/2016\nms.topic: article\nms.prod: .net\nms.technology: dotnet-standard\nms.devlang: dotnet\nms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93\n---\n\n# Tour of .NET\n\n.NET is a general purpose development platform.  It has several key features, such as multiple programming languages, asynchronous and concurrent programming models, and native interoperability which enable a wide range of scenarios across multiple platforms.\n\nThis article offers a guided tour through some of the key features of the .NET platform.\n\nSee the [.NET Architectural Components](components.md) to learn about each of the architectural \"pieces\" of .NET and what they're used for.\n\n## How to run the code samples\n\nTo learn how to set up a development environment to run the code samples, check out [Getting Started](get-started.md).  You can copy and paste code samples from this page into your environment to execute them. \n\n> [!NOTE]\nIn the future, this documentation site will have the ability to run these code samples in your browser.\n\n## Programming languages\n\n.NET supports multiple programming languages.  .NET runtimes implement the [Common Language Infrastructure (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), which (among other things) specifies a language-independent runtime and language interoperability.  This means that you can choose any .NET language to build apps and services on .NET.\n\nMicrosoft actively develops and supports three .NET languages: C#, F#, and Visual Basic .NET. \n\n* C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages. Anyone familiar with C and similar languages will find few problems in adapting to C#.  Check out the [C# Guide](../csharp/index.md) to learn more about C#.\n\n* F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.  Check out the [F# Guide](../fsharp/index.md) to learn more about F#.\n\n* Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.\n\n## Automatic memory management\n\n.NET uses [garbage collection](garbagecollection/index.md) to provide automatic memory management for programs.  The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.  To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md).\n\nThe following two lines both allocate memory:\n\n[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]\n\nThere is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.\n\nThe garbage collector is just one of the services that help ensure *memory safety*.  The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).  For instance, the runtime ensures that programs do not index off the end of an array or access a phantom field off the end of an object.\n\nIn the following example, the runtime will throw an `InvalidIndexException` exception, to enforce memory safety.\n\n[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]\n\n## Working with unmanaged resources\n\nSome objects reference *unmanaged resources*. Unmanaged resources are resources that are not automatically maintained by the .NET runtime.  For example, a file handle is an unmanaged resource.  A @System.IO.FileStream object is a managed object, but it references a file handle, which is unmanaged.  When you are done using the FileStream, you need to release the file handle.\n\nIn .NET, objects that reference unmanaged resources implement the @System.IDisposable interface.  When you are done using the object, you call the object's @System.IDisposable.Dispose method, which is responsible for releasing any unmanaged resources.  .NET languages provide a convenient `using` syntax for such objects, as in the following example:\n\n[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]\n\nOnce the `using` block completes, the .NET runtime will automatically call the `stream` object's @System.IDisposable.Dispose method, which releases the file handle.  The runtime will also do this if an exception causes control to leave the block.\n\nFor more details, check out the following pages:\n\n* For C#, [using Statement](../csharp/language-reference/keywords/using-statement.md)\n* For F#, [Resource Management: The `use` Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md)\n* For Visual Basic, [Using Statement](../visual-basic/language-reference/statements/using-statement.md)\n\n## Type safety\n\nObjects are allocated in terms of types. The only operations allowed for a given object, and the memory it consumes, are those of its type. A `Dog` type may have `Jump` and `WagTail` methods, but not likely a `SumTotal` method. A program can only call the declared methods of a given type. All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or `object`).\n\n.NET languages are object-oriented, with hierarchies of base and derived classes. The .NET runtime will only allow object casts and calls that align with the object hierarchy. Remember that every type defined in any .NET language derives from the base `object` type.\n\n[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)]\n\nType safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords. Accessor keywords are artifacts which control access to members of a given type by other code. These are usually used for various kinds of data within a type that are used to manage its behavior.\n\n[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]\n\nC#, Visual Basic, and F# support local **type inference**. Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side. This doesn't mean that the type safety is broken or avoided. The resulting type **has** a strong type with everything that implies. Let's rewrite the first two lines of the previous example to introduce type inference. Note that the rest of the example is completely the same.\n\n[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]\n\nF# has even further type inference capabilities than method-local type inference found in C# and Visual Basic.  To learn more, check out [Type Inference](../fsharp/language-reference/type-inference.md).\n\n## Delegates and lambdas\n\nDelegates are like C++ function pointers, with a big difference that they are type safe. They are a kind of disconnected method within the CLR type system. Regular methods are attached to a class and only directly callable through static or instance calling conventions.\n\nDelegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.\n\nRead more about it in the [Delegates and lambdas](delegates-lambdas.md) document.\n\n## Generics\n\nGenerics are a feature that was added in .NET Framework 2.0. In short, generics allow the programmer to introduce a \"type parameter\" when designing their classes, that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.\n\nGenerics were added to help programmers implement generic data structures. Before their arrival, in order for a, say, `List` type to be generic, it would have to work with elements that were of type `object`. This would have various performance as well as semantic problems, not to mention possible subtle runtime errors. The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an `InvalidCastException` is thrown on working with the list's members.\n\nThe following sample shows a basic program running using an instance of @System.Collections.Generic.List%601 types.\n\n[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]\n\nFor more information, see the [Generic types (Generics) overview](generics.md) article.\n\n## Async programming\n\nAsync programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs. Internally, they are based off of objects (such as `Task`) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.\n\nTo learn more about async programming in .NET, start with the [Async overview](async.md).\n\n## Language Integrated Query (LINQ)\n\nLINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data. The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!\n\nTo learn more and see some samples, check out [LINQ (Language Integrated Query)](using-linq.md).\n\n## Native interoperability\n\nEvery operating system in current use provides a lot of platform support for various programming tasks. .NET provides several ways to tap into those APIs. Collectively, this support is called \"native interoperability\" and in this section we will take a look at how to access native APIs from managed, .NET code.\n\nThe main way to do native interoperability is via \"platform invoke\" or P/Invoke for short. This support in .NET Core is available across Linux and Windows platforms. Another, Windows-only way of doing native interoperability is known as \"COM interop\" which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code. It is built on top of P/Invoke infrastructure, but it works in subtly different ways.\n\nMost of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.\n\nRead more about it in the [Native interoperability](native-interop.md) document.\n\n## Unsafe code\n\nThe CLR enables the ability to access native memory and do pointer arithmetic via `unsafe` code. These operations are needed for certain algorithms and system interoperability. Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm. Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety. It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.\n\nThe following example is a modified version of the `ToString()` method from the `StringBuilder` class.  It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:\n\n[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]\n\n## Next Steps\n\nIf you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).\n\nIf you're interested in a tour of F# features, check out [Tour of F#](../fsharp/tour.md).\n\nIf you want to get started with writing code of your own, check out [Getting Started](get-started.md).\n\nTo learn about important components of .NET, check out [.NET Architectural Components](components.md).\n","nodes":[{"pos":[11,23],"content":"Tour of .NET","needQuote":true,"needEscape":true,"nodes":[{"content":"Tour of .NET","pos":[0,12]}]},{"pos":[37,111],"content":"A guided tour through some of the prominent features of the .NET platform.","needQuote":true,"needEscape":true,"nodes":[{"content":"A guided tour through some of the prominent features of the .NET platform.","pos":[0,74]}]},{"pos":[122,213],"content":".NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async","pos":[0,91]}]},{"pos":[407,419],"content":"Tour of .NET","linkify":"Tour of .NET","nodes":[{"content":"Tour of .NET","pos":[0,12]}]},{"content":".NET is a general purpose development platform.","pos":[421,468]},{"content":"It has several key features, such as multiple programming languages, asynchronous and concurrent programming models, and native interoperability which enable a wide range of scenarios across multiple platforms.","pos":[470,680]},{"content":"This article offers a guided tour through some of the key features of the .NET platform.","pos":[682,770]},{"pos":[772,911],"content":"See the <bpt id=\"p1\">[</bpt>.NET Architectural Components<ept id=\"p1\">](components.md)</ept> to learn about each of the architectural \"pieces\" of .NET and what they're used for.","source":"See the [.NET Architectural Components](components.md) to learn about each of the architectural \"pieces\" of .NET and what they're used for."},{"pos":[916,943],"content":"How to run the code samples","linkify":"How to run the code samples","nodes":[{"content":"How to run the code samples","pos":[0,27]}]},{"content":"To learn how to set up a development environment to run the code samples, check out <bpt id=\"p1\">[</bpt>Getting Started<ept id=\"p1\">](get-started.md)</ept>.","pos":[945,1063],"source":"To learn how to set up a development environment to run the code samples, check out [Getting Started](get-started.md)."},{"content":"You can copy and paste code samples from this page into your environment to execute them.","pos":[1065,1154]},{"content":"In the future, this documentation site will have the ability to run these code samples in your browser.","pos":[1167,1270]},{"pos":[1275,1296],"content":"Programming languages","linkify":"Programming languages","nodes":[{"content":"Programming languages","pos":[0,21]}]},{"content":".NET supports multiple programming languages.","pos":[1298,1343]},{"content":".NET runtimes implement the <bpt id=\"p1\">[</bpt>Common Language Infrastructure (CLI)<ept id=\"p1\">](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/)</ept>, which (among other things) specifies a language-independent runtime and language interoperability.","pos":[1345,1604],"source":"  .NET runtimes implement the [Common Language Infrastructure (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), which (among other things) specifies a language-independent runtime and language interoperability."},{"content":"This means that you can choose any .NET language to build apps and services on .NET.","pos":[1606,1690]},{"content":"Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic .NET.","pos":[1692,1785]},{"content":"C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.","pos":[1790,1914]},{"content":"Anyone familiar with C and similar languages will find few problems in adapting to C#.","pos":[1915,2001]},{"content":"Check out the <bpt id=\"p1\">[</bpt>C# Guide<ept id=\"p1\">](../csharp/index.md)</ept> to learn more about C#.","pos":[2003,2071],"source":"  Check out the [C# Guide](../csharp/index.md) to learn more about C#."},{"content":"F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.","pos":[2075,2211]},{"content":"Check out the <bpt id=\"p1\">[</bpt>F# Guide<ept id=\"p1\">](../fsharp/index.md)</ept> to learn more about F#.","pos":[2213,2281],"source":"  Check out the [F# Guide](../fsharp/index.md) to learn more about F#."},{"content":"Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.","pos":[2285,2396]},{"pos":[2401,2428],"content":"Automatic memory management","linkify":"Automatic memory management","nodes":[{"content":"Automatic memory management","pos":[0,27]}]},{"content":".NET uses <bpt id=\"p1\">[</bpt>garbage collection<ept id=\"p1\">](garbagecollection/index.md)</ept> to provide automatic memory management for programs.","pos":[2430,2541],"source":".NET uses [garbage collection](garbagecollection/index.md) to provide automatic memory management for programs."},{"content":"The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.","pos":[2543,2672]},{"content":"To learn more about the .NET GC, check out <bpt id=\"p1\">[</bpt>Fundamentals of garbage collection (GC)<ept id=\"p1\">](garbagecollection/fundamentals.md)</ept>.","pos":[2674,2794],"source":"  To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md)."},{"content":"The following two lines both allocate memory:","pos":[2796,2841]},{"pos":[2843,2938],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>MemoryManagement<ept id=\"p2\">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]"},{"content":"There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.","pos":[2940,3105]},{"content":"The garbage collector is just one of the services that help ensure <bpt id=\"p1\">*</bpt>memory safety<ept id=\"p1\">*</ept>.","pos":[3107,3190],"source":"The garbage collector is just one of the services that help ensure *memory safety*."},{"content":"The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).","pos":[3192,3331]},{"content":"For instance, the runtime ensures that programs do not index off the end of an array or access a phantom field off the end of an object.","pos":[3333,3469]},{"pos":[3471,3583],"content":"In the following example, the runtime will throw an <ph id=\"ph1\">`InvalidIndexException`</ph> exception, to enforce memory safety.","source":"In the following example, the runtime will throw an `InvalidIndexException` exception, to enforce memory safety."},{"pos":[3585,3680],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>MemoryManagement<ept id=\"p2\">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]"},{"pos":[3685,3717],"content":"Working with unmanaged resources","linkify":"Working with unmanaged resources","nodes":[{"content":"Working with unmanaged resources","pos":[0,32]}]},{"content":"Some objects reference <bpt id=\"p1\">*</bpt>unmanaged resources<ept id=\"p1\">*</ept>.","pos":[3719,3764],"source":"Some objects reference *unmanaged resources*."},{"content":"Unmanaged resources are resources that are not automatically maintained by the .NET runtime.","pos":[3765,3857]},{"content":"For example, a file handle is an unmanaged resource.","pos":[3859,3911]},{"content":"A <ph id=\"ph1\">@System.IO.FileStream</ph> object is a managed object, but it references a file handle, which is unmanaged.","pos":[3913,4017],"source":"  A @System.IO.FileStream object is a managed object, but it references a file handle, which is unmanaged."},{"content":"When you are done using the FileStream, you need to release the file handle.","pos":[4019,4095]},{"content":"In .NET, objects that reference unmanaged resources implement the <ph id=\"ph1\">@System.IDisposable</ph> interface.","pos":[4097,4193],"source":"In .NET, objects that reference unmanaged resources implement the @System.IDisposable interface."},{"content":"When you are done using the object, you call the object's <ph id=\"ph1\">@System.IDisposable.Dispose</ph> method, which is responsible for releasing any unmanaged resources.","pos":[4195,4348],"source":"  When you are done using the object, you call the object's @System.IDisposable.Dispose method, which is responsible for releasing any unmanaged resources."},{"content":".NET languages provide a convenient <ph id=\"ph1\">`using`</ph> syntax for such objects, as in the following example:","pos":[4350,4447],"source":"  .NET languages provide a convenient `using` syntax for such objects, as in the following example:"},{"pos":[4449,4548],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UnmanagedResources<ept id=\"p2\">](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]"},{"content":"Once the <ph id=\"ph1\">`using`</ph> block completes, the .NET runtime will automatically call the <ph id=\"ph2\">`stream`</ph> object's <ph id=\"ph3\">@System.IDisposable.Dispose</ph> method, which releases the file handle.","pos":[4550,4714],"source":"Once the `using` block completes, the .NET runtime will automatically call the `stream` object's @System.IDisposable.Dispose method, which releases the file handle."},{"content":"The runtime will also do this if an exception causes control to leave the block.","pos":[4716,4796]},{"content":"For more details, check out the following pages:","pos":[4798,4846]},{"pos":[4850,4933],"content":"For C#, <bpt id=\"p1\">[</bpt>using Statement<ept id=\"p1\">](../csharp/language-reference/keywords/using-statement.md)</ept>","source":"For C#, [using Statement](../csharp/language-reference/keywords/using-statement.md)"},{"pos":[4936,5053],"content":"For F#, <bpt id=\"p1\">[</bpt>Resource Management: The <ph id=\"ph1\">`use`</ph> Keyword<ept id=\"p1\">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept>","source":"For F#, [Resource Management: The `use` Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md)"},{"pos":[5056,5157],"content":"For Visual Basic, <bpt id=\"p1\">[</bpt>Using Statement<ept id=\"p1\">](../visual-basic/language-reference/statements/using-statement.md)</ept>","source":"For Visual Basic, [Using Statement](../visual-basic/language-reference/statements/using-statement.md)"},{"pos":[5162,5173],"content":"Type safety","linkify":"Type safety","nodes":[{"content":"Type safety","pos":[0,11]}]},{"content":"Objects are allocated in terms of types.","pos":[5175,5215]},{"content":"The only operations allowed for a given object, and the memory it consumes, are those of its type.","pos":[5216,5314]},{"content":"A <ph id=\"ph1\">`Dog`</ph> type may have <ph id=\"ph2\">`Jump`</ph> and <ph id=\"ph3\">`WagTail`</ph> methods, but not likely a <ph id=\"ph4\">`SumTotal`</ph> method.","pos":[5315,5402],"source":" A `Dog` type may have `Jump` and `WagTail` methods, but not likely a `SumTotal` method."},{"content":"A program can only call the declared methods of a given type.","pos":[5403,5464]},{"content":"All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id=\"ph1\">`object`</ph>).","pos":[5465,5596],"source":" All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or `object`)."},{"content":".NET languages are object-oriented, with hierarchies of base and derived classes.","pos":[5598,5679]},{"content":"The .NET runtime will only allow object casts and calls that align with the object hierarchy.","pos":[5680,5773]},{"content":"Remember that every type defined in any .NET language derives from the base <ph id=\"ph1\">`object`</ph> type.","pos":[5774,5864],"source":" Remember that every type defined in any .NET language derives from the base `object` type."},{"pos":[5866,5951],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TypeSafety<ept id=\"p2\">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)]"},{"content":"Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.","pos":[5953,6062]},{"content":"Accessor keywords are artifacts which control access to members of a given type by other code.","pos":[6063,6157]},{"content":"These are usually used for various kinds of data within a type that are used to manage its behavior.","pos":[6158,6258]},{"pos":[6260,6343],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TypeSafety<ept id=\"p2\">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]"},{"content":"C#, Visual Basic, and F# support local <bpt id=\"p1\">**</bpt>type inference<ept id=\"p1\">**</ept>.","pos":[6345,6403],"source":"C#, Visual Basic, and F# support local **type inference**."},{"content":"Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.","pos":[6404,6547]},{"content":"This doesn't mean that the type safety is broken or avoided.","pos":[6548,6608]},{"content":"The resulting type <bpt id=\"p1\">**</bpt>has<ept id=\"p1\">**</ept> a strong type with everything that implies.","pos":[6609,6679],"source":" The resulting type **has** a strong type with everything that implies."},{"content":"Let's rewrite the first two lines of the previous example to introduce type inference.","pos":[6680,6766]},{"content":"Note that the rest of the example is completely the same.","pos":[6767,6824]},{"pos":[6826,6911],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TypeSafety<ept id=\"p2\">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]"},{"content":"F# has even further type inference capabilities than method-local type inference found in C# and Visual Basic.","pos":[6913,7023]},{"content":"To learn more, check out <bpt id=\"p1\">[</bpt>Type Inference<ept id=\"p1\">](../fsharp/language-reference/type-inference.md)</ept>.","pos":[7025,7115],"source":"  To learn more, check out [Type Inference](../fsharp/language-reference/type-inference.md)."},{"pos":[7120,7141],"content":"Delegates and lambdas","linkify":"Delegates and lambdas","nodes":[{"content":"Delegates and lambdas","pos":[0,21]}]},{"content":"Delegates are like C++ function pointers, with a big difference that they are type safe.","pos":[7143,7231]},{"content":"They are a kind of disconnected method within the CLR type system.","pos":[7232,7298]},{"content":"Regular methods are attached to a class and only directly callable through static or instance calling conventions.","pos":[7299,7413]},{"content":"Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.","pos":[7415,7551]},{"pos":[7553,7634],"content":"Read more about it in the <bpt id=\"p1\">[</bpt>Delegates and lambdas<ept id=\"p1\">](delegates-lambdas.md)</ept> document.","source":"Read more about it in the [Delegates and lambdas](delegates-lambdas.md) document."},{"pos":[7639,7647],"content":"Generics","linkify":"Generics","nodes":[{"content":"Generics","pos":[0,8]}]},{"content":"Generics are a feature that was added in .NET Framework 2.0.","pos":[7649,7709]},{"content":"In short, generics allow the programmer to introduce a \"type parameter\" when designing their classes, that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.","pos":[7710,7928]},{"content":"Generics were added to help programmers implement generic data structures.","pos":[7930,8004]},{"content":"Before their arrival, in order for a, say, <ph id=\"ph1\">`List`</ph> type to be generic, it would have to work with elements that were of type <ph id=\"ph2\">`object`</ph>.","pos":[8005,8138],"source":" Before their arrival, in order for a, say, `List` type to be generic, it would have to work with elements that were of type `object`."},{"content":"This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.","pos":[8139,8251]},{"content":"The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <ph id=\"ph1\">`InvalidCastException`</ph> is thrown on working with the list's members.","pos":[8252,8436],"source":" The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an `InvalidCastException` is thrown on working with the list's members."},{"content":"The following sample shows a basic program running using an instance of <ph id=\"ph1\">@System.Collections.Generic.List</ph>%601 types.","pos":[8438,8553],"source":"The following sample shows a basic program running using an instance of @System.Collections.Generic.List%601 types."},{"pos":[8555,8638],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>GenericsShort<ept id=\"p2\">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]"},{"pos":[8640,8727],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Generic types (Generics) overview<ept id=\"p1\">](generics.md)</ept> article.","source":"For more information, see the [Generic types (Generics) overview](generics.md) article."},{"pos":[8732,8749],"content":"Async programming","linkify":"Async programming","nodes":[{"content":"Async programming","pos":[0,17]}]},{"content":"Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.","pos":[8751,8896]},{"content":"Internally, they are based off of objects (such as <ph id=\"ph1\">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.","pos":[8897,9054],"source":" Internally, they are based off of objects (such as `Task`) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible."},{"pos":[9056,9145],"content":"To learn more about async programming in .NET, start with the <bpt id=\"p1\">[</bpt>Async overview<ept id=\"p1\">](async.md)</ept>.","source":"To learn more about async programming in .NET, start with the [Async overview](async.md)."},{"pos":[9150,9182],"content":"Language Integrated Query (LINQ)","linkify":"Language Integrated Query (LINQ)","nodes":[{"content":"Language Integrated Query (LINQ)","pos":[0,32]}]},{"content":"LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.","pos":[9184,9304]},{"content":"The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!","pos":[9305,9483]},{"pos":[9485,9581],"content":"To learn more and see some samples, check out <bpt id=\"p1\">[</bpt>LINQ (Language Integrated Query)<ept id=\"p1\">](using-linq.md)</ept>.","source":"To learn more and see some samples, check out [LINQ (Language Integrated Query)](using-linq.md)."},{"pos":[9586,9609],"content":"Native interoperability","linkify":"Native interoperability","nodes":[{"content":"Native interoperability","pos":[0,23]}]},{"content":"Every operating system in current use provides a lot of platform support for various programming tasks.","pos":[9611,9714]},{"content":".NET provides several ways to tap into those APIs.","pos":[9715,9765]},{"content":"Collectively, this support is called \"native interoperability\" and in this section we will take a look at how to access native APIs from managed, .NET code.","pos":[9766,9922]},{"content":"The main way to do native interoperability is via \"platform invoke\" or P/Invoke for short.","pos":[9924,10014]},{"content":"This support in .NET Core is available across Linux and Windows platforms.","pos":[10015,10089]},{"content":"Another, Windows-only way of doing native interoperability is known as \"COM interop\" which is used to work with <bpt id=\"p1\">[</bpt>COM components<ept id=\"p1\">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.","pos":[10090,10285],"source":" Another, Windows-only way of doing native interoperability is known as \"COM interop\" which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code."},{"content":"It is built on top of P/Invoke infrastructure, but it works in subtly different ways.","pos":[10286,10371]},{"content":"Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.","pos":[10373,10518]},{"pos":[10520,10600],"content":"Read more about it in the <bpt id=\"p1\">[</bpt>Native interoperability<ept id=\"p1\">](native-interop.md)</ept> document.","source":"Read more about it in the [Native interoperability](native-interop.md) document."},{"pos":[10605,10616],"content":"Unsafe code","linkify":"Unsafe code","nodes":[{"content":"Unsafe code","pos":[0,11]}]},{"content":"The CLR enables the ability to access native memory and do pointer arithmetic via <ph id=\"ph1\">`unsafe`</ph> code.","pos":[10618,10714],"source":"The CLR enables the ability to access native memory and do pointer arithmetic via `unsafe` code."},{"content":"These operations are needed for certain algorithms and system interoperability.","pos":[10715,10794]},{"content":"Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.","pos":[10795,10941]},{"content":"Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.","pos":[10942,11077]},{"content":"It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.","pos":[11078,11184]},{"content":"The following example is a modified version of the <ph id=\"ph1\">`ToString()`</ph> method from the <ph id=\"ph2\">`StringBuilder`</ph> class.","pos":[11186,11288],"source":"The following example is a modified version of the `ToString()` method from the `StringBuilder` class."},{"content":"It illustrates how using <ph id=\"ph1\">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:","pos":[11290,11411],"source":"  It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:"},{"pos":[11413,11482],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Unsafe<ept id=\"p2\">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]"},{"pos":[11487,11497],"content":"Next Steps","linkify":"Next Steps","nodes":[{"content":"Next Steps","pos":[0,10]}]},{"pos":[11499,11604],"content":"If you're interested in a tour of C# features, check out <bpt id=\"p1\">[</bpt>Tour of C#<ept id=\"p1\">](../csharp/tour-of-csharp/index.md)</ept>.","source":"If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md)."},{"pos":[11606,11695],"content":"If you're interested in a tour of F# features, check out <bpt id=\"p1\">[</bpt>Tour of F#<ept id=\"p1\">](../fsharp/tour.md)</ept>.","source":"If you're interested in a tour of F# features, check out [Tour of F#](../fsharp/tour.md)."},{"pos":[11697,11799],"content":"If you want to get started with writing code of your own, check out <bpt id=\"p1\">[</bpt>Getting Started<ept id=\"p1\">](get-started.md)</ept>.","source":"If you want to get started with writing code of your own, check out [Getting Started](get-started.md)."},{"pos":[11801,11903],"content":"To learn about important components of .NET, check out <bpt id=\"p1\">[</bpt>.NET Architectural Components<ept id=\"p1\">](components.md)</ept>.","source":"To learn about important components of .NET, check out [.NET Architectural Components](components.md)."}]}