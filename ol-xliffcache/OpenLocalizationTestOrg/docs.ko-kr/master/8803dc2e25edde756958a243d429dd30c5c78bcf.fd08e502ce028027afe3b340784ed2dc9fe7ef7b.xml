{"content":"---\ntitle: \">> Operator (Visual Basic)\"\nms.date: 07/20/2015\nf1_keywords: \n  - \"vb.>>\"\nhelpviewer_keywords: \n  - \"operator>>\"\n  - \">> operator [Visual Basic]\"\n  - \"bit shift operators [Visual Basic]\"\n  - \"operator >>\"\n  - \"right shift operators [Visual Basic]\"\nms.assetid: 054dc6a6-47d9-47ef-82da-cfa2b59fbf8f\n---\n# >> Operator (Visual Basic)\nPerforms an arithmetic right shift on a bit pattern.  \n  \n## Syntax  \n  \n```  \nresult = pattern >> amount  \n```  \n  \n## Parts  \n `result`  \n Required. Integral numeric value. The result of shifting the bit pattern. The data type is the same as that of `pattern`.  \n  \n `pattern`  \n Required. Integral numeric expression. The bit pattern to be shifted. The data type must be an integral type (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, or `ULong`).  \n  \n `amount`  \n Required. Numeric expression. The number of bits to shift the bit pattern. The data type must be `Integer` or widen to `Integer`.  \n  \n## Remarks  \n Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end. In an arithmetic right shift, the bits shifted beyond the rightmost bit position are discarded, and the leftmost (sign) bit is propagated into the bit positions vacated at the left. This means that if `pattern` has a negative value, the vacated positions are set to one; otherwise they are set to zero.  \n  \n Note that the data types `Byte`, `UShort`, `UInteger`, and `ULong` are unsigned, so there is no sign bit to propagate. If `pattern` is of any unsigned type, the vacated positions are always set to zero.  \n  \n To prevent shifting by more bits than the result can hold, Visual Basic masks the value of `amount` with a size mask corresponding to the data type of `pattern`. The binary AND of these values is used for the shift amount. The size masks are as follows:  \n  \n|Data type of `pattern`|Size mask (decimal)|Size mask (hexadecimal)|  \n|----------------------------|---------------------------|-------------------------------|  \n|`SByte`, `Byte`|7|&H00000007|  \n|`Short`, `UShort`|15|&H0000000F|  \n|`Integer`, `UInteger`|31|&H0000001F|  \n|`Long`, `ULong`|63|&H0000003F|  \n  \n If `amount` is zero, the value of `result` is identical to the value of `pattern`. If `amount` is negative, it is taken as an unsigned value and masked with the appropriate size mask.  \n  \n Arithmetic shifts never generate overflow exceptions.  \n  \n## Overloading  \n The `>>` operator can be *overloaded*, which means that a class or structure can redefine its behavior when an operand has the type of that class or structure. If your code uses this operator on such a class or structure, be sure you understand its redefined behavior. For more information, see [Operator Procedures](../../../visual-basic/programming-guide/language-features/procedures/operator-procedures.md).  \n  \n## Example  \n The following example uses the `>>` operator to perform arithmetic right shifts on integral values. The result always has the same data type as that of the expression being shifted.  \n  \n [!code-vb[VbVbalrOperators#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#14)]  \n  \n The results of the preceding example are as follows:  \n  \n-   `result1` is 2560 (0000 1010 0000 0000).  \n  \n-   `result2` is 160 (0000 0000 1010 0000).  \n  \n-   `result3` is 2 (0000 0000 0000 0010).  \n  \n-   `result4` is 640 (0000 0010 1000 0000).  \n  \n-   `result5` is 0 (shifted 15 places to the right).  \n  \n The shift amount for `result4` is calculated as 18 AND 15, which equals 2.  \n  \n The following example shows arithmetic shifts on a negative value.  \n  \n [!code-vb[VbVbalrOperators#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#55)]  \n  \n The results of the preceding example are as follows:  \n  \n-   `negresult1` is -512 (1111 1110 0000 0000).  \n  \n-   `negresult2` is -1 (the sign bit is propagated).  \n  \n## See also\n\n- [Bit Shift Operators](../../../visual-basic/language-reference/operators/bit-shift-operators.md)\n- [Assignment Operators](../../../visual-basic/language-reference/operators/assignment-operators.md)\n- [>>= Operator](../../../visual-basic/language-reference/operators/right-shift-assignment-operator.md)\n- [Operator Precedence in Visual Basic](../../../visual-basic/language-reference/operators/operator-precedence.md)\n- [Operators Listed by Functionality](../../../visual-basic/language-reference/operators/operators-listed-by-functionality.md)\n- [Arithmetic Operators in Visual Basic](../../../visual-basic/programming-guide/language-features/operators-and-expressions/arithmetic-operators.md)\n","nodes":[{"pos":[4,308],"embed":true,"restype":"x-metadata","content":"title: \">> Operator (Visual Basic)\"\nms.date: 07/20/2015\nf1_keywords: \n  - \"vb.>>\"\nhelpviewer_keywords: \n  - \"operator>>\"\n  - \">> operator [Visual Basic]\"\n  - \"bit shift operators [Visual Basic]\"\n  - \"operator >>\"\n  - \"right shift operators [Visual Basic]\"\nms.assetid: 054dc6a6-47d9-47ef-82da-cfa2b59fbf8f","nodes":[{"content":">> Operator (Visual Basic)","nodes":[{"pos":[3,26],"content":"Operator (Visual Basic)","nodes":[{"content":"Operator (Visual Basic)","pos":[0,23]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[315,341],"content":">> Operator (Visual Basic)","linkify":">> Operator (Visual Basic)","nodes":[{"content":"&gt;&gt; Operator (Visual Basic)","pos":[0,26],"source":">> Operator (Visual Basic)"}]},{"content":"Performs an arithmetic right shift on a bit pattern.","pos":[342,394]},{"pos":[403,409],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[462,467],"content":"Parts","linkify":"Parts","nodes":[{"content":"Parts","pos":[0,5]}]},{"content":"Required.","pos":[483,492]},{"content":"Integral numeric value.","pos":[493,516]},{"content":"The result of shifting the bit pattern.","pos":[517,556]},{"content":"The data type is the same as that of <ph id=\"ph1\">`pattern`</ph>.","pos":[557,604],"source":" The data type is the same as that of `pattern`."},{"content":"Required.","pos":[624,633]},{"content":"Integral numeric expression.","pos":[634,662]},{"content":"The bit pattern to be shifted.","pos":[663,693]},{"content":"The data type must be an integral type (<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Byte`</ph>, <ph id=\"ph3\">`Short`</ph>, <ph id=\"ph4\">`UShort`</ph>, <ph id=\"ph5\">`Integer`</ph>, <ph id=\"ph6\">`UInteger`</ph>, <ph id=\"ph7\">`Long`</ph>, or <ph id=\"ph8\">`ULong`</ph>).","pos":[694,813],"source":" The data type must be an integral type (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, or `ULong`)."},{"content":"Required.","pos":[832,841]},{"content":"Numeric expression.","pos":[842,861]},{"content":"The number of bits to shift the bit pattern.","pos":[862,906]},{"content":"The data type must be <ph id=\"ph1\">`Integer`</ph> or widen to <ph id=\"ph2\">`Integer`</ph>.","pos":[907,961],"source":" The data type must be `Integer` or widen to `Integer`."},{"pos":[970,977],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end.","pos":[981,1110]},{"content":"In an arithmetic right shift, the bits shifted beyond the rightmost bit position are discarded, and the leftmost (sign) bit is propagated into the bit positions vacated at the left.","pos":[1111,1292]},{"content":"This means that if <ph id=\"ph1\">`pattern`</ph> has a negative value, the vacated positions are set to one; otherwise they are set to zero.","pos":[1293,1413],"source":" This means that if `pattern` has a negative value, the vacated positions are set to one; otherwise they are set to zero."},{"content":"Note that the data types <ph id=\"ph1\">`Byte`</ph>, <ph id=\"ph2\">`UShort`</ph>, <ph id=\"ph3\">`UInteger`</ph>, and <ph id=\"ph4\">`ULong`</ph> are unsigned, so there is no sign bit to propagate.","pos":[1420,1538],"source":"Note that the data types `Byte`, `UShort`, `UInteger`, and `ULong` are unsigned, so there is no sign bit to propagate."},{"content":"If <ph id=\"ph1\">`pattern`</ph> is of any unsigned type, the vacated positions are always set to zero.","pos":[1539,1622],"source":" If `pattern` is of any unsigned type, the vacated positions are always set to zero."},{"content":"To prevent shifting by more bits than the result can hold, Visual Basic masks the value of <ph id=\"ph1\">`amount`</ph> with a size mask corresponding to the data type of <ph id=\"ph2\">`pattern`</ph>.","pos":[1629,1790],"source":"To prevent shifting by more bits than the result can hold, Visual Basic masks the value of `amount` with a size mask corresponding to the data type of `pattern`."},{"content":"The binary AND of these values is used for the shift amount.","pos":[1791,1851]},{"content":"The size masks are as follows:","pos":[1852,1882]},{"pos":[1889,1911],"content":"Data type of <ph id=\"ph1\">`pattern`</ph>","source":"Data type of `pattern`"},{"content":"Size mask (decimal)","pos":[1912,1931]},{"content":"Size mask (hexadecimal)","pos":[1932,1955]},{"pos":[2053,2068],"content":"<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Byte`</ph>","source":"`SByte`, `Byte`"},{"content":"7","pos":[2069,2070]},{"content":"&amp;H00000007","pos":[2071,2081],"source":"&H00000007"},{"pos":[2086,2103],"content":"<ph id=\"ph1\">`Short`</ph>, <ph id=\"ph2\">`UShort`</ph>","source":"`Short`, `UShort`"},{"content":"15","pos":[2104,2106]},{"content":"&amp;H0000000F","pos":[2107,2117],"source":"&H0000000F"},{"pos":[2122,2143],"content":"<ph id=\"ph1\">`Integer`</ph>, <ph id=\"ph2\">`UInteger`</ph>","source":"`Integer`, `UInteger`"},{"content":"31","pos":[2144,2146]},{"content":"&amp;H0000001F","pos":[2147,2157],"source":"&H0000001F"},{"pos":[2162,2177],"content":"<ph id=\"ph1\">`Long`</ph>, <ph id=\"ph2\">`ULong`</ph>","source":"`Long`, `ULong`"},{"content":"63","pos":[2178,2180]},{"content":"&amp;H0000003F","pos":[2181,2191],"source":"&H0000003F"},{"content":"If <ph id=\"ph1\">`amount`</ph> is zero, the value of <ph id=\"ph2\">`result`</ph> is identical to the value of <ph id=\"ph3\">`pattern`</ph>.","pos":[2199,2281],"source":"If `amount` is zero, the value of `result` is identical to the value of `pattern`."},{"content":"If <ph id=\"ph1\">`amount`</ph> is negative, it is taken as an unsigned value and masked with the appropriate size mask.","pos":[2282,2382],"source":" If `amount` is negative, it is taken as an unsigned value and masked with the appropriate size mask."},{"content":"Arithmetic shifts never generate overflow exceptions.","pos":[2389,2442]},{"pos":[2451,2462],"content":"Overloading","linkify":"Overloading","nodes":[{"content":"Overloading","pos":[0,11]}]},{"content":"The <ph id=\"ph1\">`&gt;&gt;`</ph> operator can be <bpt id=\"p1\">*</bpt>overloaded<ept id=\"p1\">*</ept>, which means that a class or structure can redefine its behavior when an operand has the type of that class or structure.","pos":[2466,2625],"source":"The `>>` operator can be *overloaded*, which means that a class or structure can redefine its behavior when an operand has the type of that class or structure."},{"content":"If your code uses this operator on such a class or structure, be sure you understand its redefined behavior.","pos":[2626,2734]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Operator Procedures<ept id=\"p1\">](../../../visual-basic/programming-guide/language-features/procedures/operator-procedures.md)</ept>.","pos":[2735,2876],"source":" For more information, see [Operator Procedures](../../../visual-basic/programming-guide/language-features/procedures/operator-procedures.md)."},{"pos":[2885,2892],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example uses the <ph id=\"ph1\">`&gt;&gt;`</ph> operator to perform arithmetic right shifts on integral values.","pos":[2896,2995],"source":"The following example uses the `>>` operator to perform arithmetic right shifts on integral values."},{"content":"The result always has the same data type as that of the expression being shifted.","pos":[2996,3077]},{"content":"The results of the preceding example are as follows:","pos":[3208,3260]},{"pos":[3270,3310],"content":"<ph id=\"ph1\">`result1`</ph> is 2560 (0000 1010 0000 0000).","source":"`result1` is 2560 (0000 1010 0000 0000)."},{"pos":[3320,3359],"content":"<ph id=\"ph1\">`result2`</ph> is 160 (0000 0000 1010 0000).","source":"`result2` is 160 (0000 0000 1010 0000)."},{"pos":[3369,3406],"content":"<ph id=\"ph1\">`result3`</ph> is 2 (0000 0000 0000 0010).","source":"`result3` is 2 (0000 0000 0000 0010)."},{"pos":[3416,3455],"content":"<ph id=\"ph1\">`result4`</ph> is 640 (0000 0010 1000 0000).","source":"`result4` is 640 (0000 0010 1000 0000)."},{"pos":[3465,3513],"content":"<ph id=\"ph1\">`result5`</ph> is 0 (shifted 15 places to the right).","source":"`result5` is 0 (shifted 15 places to the right)."},{"pos":[3520,3594],"content":"The shift amount for <ph id=\"ph1\">`result4`</ph> is calculated as 18 AND 15, which equals 2.","source":"The shift amount for `result4` is calculated as 18 AND 15, which equals 2."},{"content":"The following example shows arithmetic shifts on a negative value.","pos":[3601,3667]},{"content":"The results of the preceding example are as follows:","pos":[3798,3850]},{"pos":[3860,3903],"content":"<ph id=\"ph1\">`negresult1`</ph> is -512 (1111 1110 0000 0000).","source":"`negresult1` is -512 (1111 1110 0000 0000)."},{"pos":[3913,3961],"content":"<ph id=\"ph1\">`negresult2`</ph> is -1 (the sign bit is propagated).","source":"`negresult2` is -1 (the sign bit is propagated)."},{"pos":[3970,3978],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3982,4078],"content":"<bpt id=\"p1\">[</bpt>Bit Shift Operators<ept id=\"p1\">](../../../visual-basic/language-reference/operators/bit-shift-operators.md)</ept>","source":"[Bit Shift Operators](../../../visual-basic/language-reference/operators/bit-shift-operators.md)"},{"pos":[4081,4179],"content":"<bpt id=\"p1\">[</bpt>Assignment Operators<ept id=\"p1\">](../../../visual-basic/language-reference/operators/assignment-operators.md)</ept>","source":"[Assignment Operators](../../../visual-basic/language-reference/operators/assignment-operators.md)"},{"pos":[4182,4283],"content":"<bpt id=\"p1\">[</bpt>&gt;&gt;= Operator<ept id=\"p1\">](../../../visual-basic/language-reference/operators/right-shift-assignment-operator.md)</ept>","source":"[>>= Operator](../../../visual-basic/language-reference/operators/right-shift-assignment-operator.md)"},{"pos":[4286,4398],"content":"<bpt id=\"p1\">[</bpt>Operator Precedence in Visual Basic<ept id=\"p1\">](../../../visual-basic/language-reference/operators/operator-precedence.md)</ept>","source":"[Operator Precedence in Visual Basic](../../../visual-basic/language-reference/operators/operator-precedence.md)"},{"pos":[4401,4525],"content":"<bpt id=\"p1\">[</bpt>Operators Listed by Functionality<ept id=\"p1\">](../../../visual-basic/language-reference/operators/operators-listed-by-functionality.md)</ept>","source":"[Operators Listed by Functionality](../../../visual-basic/language-reference/operators/operators-listed-by-functionality.md)"},{"pos":[4528,4675],"content":"<bpt id=\"p1\">[</bpt>Arithmetic Operators in Visual Basic<ept id=\"p1\">](../../../visual-basic/programming-guide/language-features/operators-and-expressions/arithmetic-operators.md)</ept>","source":"[Arithmetic Operators in Visual Basic](../../../visual-basic/programming-guide/language-features/operators-and-expressions/arithmetic-operators.md)"}]}