{"content":"---\ntitle: \"Methods - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"methods [C#]\"\n  - \"C# language, methods\"\nms.assetid: cc738f07-e8cd-4683-9585-9f40c0667c37\n---\n# Methods (C# Programming Guide)\nA method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method. The Main method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.  \n  \n> [!NOTE]\n>  This topic discusses named methods. For information about anonymous functions, see [Anonymous Functions](../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md).  \n  \n## Method Signatures  \n Methods are declared in a [class](../../../csharp/language-reference/keywords/class.md) or [struct](../../../csharp/language-reference/keywords/struct.md) by specifying the access level such as `public` or `private`, optional modifiers such as `abstract` or `sealed`, the return value, the name of the method, and any method parameters. These parts together are the signature of the method.  \n  \n> [!NOTE]\n>  A return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.  \n  \n Method parameters are enclosed in parentheses and are separated by commas. Empty parentheses indicate that the method requires no parameters. This class contains four methods:  \n  \n [!code-csharp[csProgGuideObjects#40](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#40)]  \n  \n## Method Access  \n Calling a method on an object is like accessing a field. After the object name, add a period, the name of the method, and parentheses. Arguments are listed within the parentheses, and are separated by commas. The methods of the `Motorcycle` class can therefore be called as in the following example:  \n  \n [!code-csharp[csProgGuideObjects#41](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#41)]  \n  \n## Method Parameters vs. Arguments  \n The method definition specifies the names and types of any parameters that are required. When calling code calls the method, it provides concrete values called arguments for each parameter. The arguments must be compatible with the parameter type but the argument name (if any) used in the calling code does not have to be the same as the parameter named defined in the method. For example:  \n  \n [!code-csharp[csProgGuideObjects#74](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#74)]  \n  \n## Passing by Reference vs. Passing by Value  \n By default, when a value type is passed to a method, a copy is passed instead of the object itself. Therefore, changes to the argument have no effect on the original copy in the calling method. You can pass a value-type by reference by using the ref keyword. For more information, see [Passing Value-Type Parameters](../../../csharp/programming-guide/classes-and-structs/passing-value-type-parameters.md). For a list of built-in value types, see [Value Types Table](../../../csharp/language-reference/keywords/value-types-table.md).  \n  \n When an object of a reference type is passed to a method, a reference to the object is passed. That is, the method receives not the object itself but an argument that indicates the location of the object. If you change a member of the object by using this reference, the change is reflected in the argument in the calling method, even if you pass the object by value.  \n  \n You create a reference type by using the `class` keyword, as the following example shows.  \n  \n [!code-csharp[csProgGuideObjects#42](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#42)]  \n  \n Now, if you pass an object that is based on this type to a method, a reference to the object is passed. The following example passes an object of type `SampleRefType` to method `ModifyObject`.  \n  \n [!code-csharp[csProgGuideObjects#75](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#75)]  \n  \n The example does essentially the same thing as the previous example in that it passes an argument by value to a method. But, because a reference type is used, the result is different. The modification that is made in `ModifyObject` to the `value` field of the parameter, `obj`, also changes the `value` field of the argument, `rt`, in the `TestRefType` method. The `TestRefType` method displays 33 as the output.  \n  \n For more information about how to pass reference types by reference and by value, see [Passing Reference-Type Parameters](../../../csharp/programming-guide/classes-and-structs/passing-reference-type-parameters.md) and [Reference Types](../../../csharp/language-reference/keywords/reference-types.md).  \n  \n## Return Values  \nMethods can return a value to the caller. If the return type, the type listed before the method name, is not `void`, the method can return the value by using the `return` keyword. A statement with the `return` keyword followed by a value that matches the return type will return that value to the method caller. \n\nThe value can be returned to the caller by value or, starting with C# 7.0, [by reference](ref-returns.md). Values are returned to the caller by reference if the `ref` keyword is used in the method signature and it follows each `return` keyword. For example, the following method signature and return statement indicate that the method returns a variable names `estDistance` by reference to the caller.\n\n```csharp\npublic ref double GetEstimatedDistance()\n{\n   return ref estDistance;\n}\n```\n\nThe `return` keyword also stops the execution of the method. If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method. Without the `return` keyword, the method will stop executing when it reaches the end of the code block. Methods with a non-void return type are required to use the `return` keyword to return a value. For example, these two methods use the `return` keyword to return integers:  \n  \n [!code-csharp[csProgGuideObjects#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#44)]  \n  \n To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient. You can also assign the return value to a variable. For example, the following two code examples accomplish the same goal:  \n  \n [!code-csharp[csProgGuideObjects#45](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#45)]  \n  \n [!code-csharp[csProgGuideObjects#46](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#46)]  \n  \n Using a local variable, in this case, `result`, to store a value is optional. It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.  \n\nTo use a value returned by reference from a method, you must declare a [ref local](ref-returns.md#ref-locals) variable if you intend to modify its value. For example, if the `Planet.GetEstimatedDistance` method returns a <xref:System.Double> value by reference, you can define it as a ref local variable with code like the following:\n\n```csharp\nref int distance = plant \n```\n\nReturning a multi-dimensional array from a method, `M`, that modifies the array's contents is not necessary if the calling function passed the array into `M`.  You may return the resulting array from `M` for good style or functional flow of values, but it is not necessary because C# passes all reference types by value, and the value of an array reference is the pointer to the array. In the method `M`, any changes to the array's contents are observable by any code that has a reference to the array, as shown in the following example.  \n  \n```csharp  \nstatic void Main(string[] args)\n{\n    int[,] matrix = new int[2, 2];\n    FillMatrix(matrix);\n    // matrix is now full of -1\n}\n\npublic static void FillMatrix(int[,] matrix)\n{\n    for (int i = 0; i < matrix.GetLength(0); i++)\n    {\n        for (int j = 0; j < matrix.GetLength(1); j++)\n        {\n            matrix[i, j] = -1;\n        }\n    }\n}\n```  \n  \n For more information, see [return](../../../csharp/language-reference/keywords/return.md).  \n  \n## Async Methods  \n By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions. \n  \n If you mark a method with the [async](../../../csharp/language-reference/keywords/async.md) modifier, you can use the [await](../../../csharp/language-reference/keywords/await.md) operator in the method. When control reaches an await expression in the async method, control returns to the caller, and progress in the method is suspended until the awaited task completes. When the task is complete, execution can resume in the method.  \n  \n> [!NOTE]\n>  An async method returns to the caller when either it encounters the first awaited object thatâ€™s not yet complete or it gets to the end of the async method, whichever occurs first.  \n  \n An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or void. The void return type is used primarily to define event handlers, where a void return type is required. An async method that returns void can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.  \n  \n In the following example, `DelayAsync` is an async method that has a return type of <xref:System.Threading.Tasks.Task%601>. `DelayAsync` has a `return` statement that returns an integer. Therefore the method declaration of `DelayAsync` must have a return type of `Task<int>`. Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer as the following statement demonstrates: `int result = await delayTask`.  \n  \n The `startButton_Click` method is an example of an async method that has a return type of void. Because `DoSomethingAsync` is an async method, the task for the call to `DoSomethingAsync` must be awaited, as the following statement shows: `await DoSomethingAsync();`. The `startButton_Click` method must be defined with the `async` modifier because the method has an `await` expression.  \n  \n [!code-csharp[csAsyncMethod#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csasyncmethod/cs/mainwindow.xaml.cs#2)]  \n  \n An async method can't declare any [ref](../../../csharp/language-reference/keywords/ref.md) or [out](../../../csharp/language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.  \n  \n For more information about async methods, see [Asynchronous Programming with async and await](../../../csharp/programming-guide/concepts/async/index.md), [Control Flow in Async Programs](../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md), and [Async Return Types](../../../csharp/programming-guide/concepts/async/async-return-types.md).  \n  \n## Expression Body Definitions  \n It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.  There is a syntax shortcut for defining such methods using `=>`:  \n  \n```csharp  \npublic Point Move(int dx, int dy) => new Point(x + dx, y + dy);   \npublic void Print() => Console.WriteLine(First + \" \" + Last);  \n// Works with operators, properties, and indexers too.  \npublic static Complex operator +(Complex a, Complex b) => a.Add(b);  \npublic string Name => First + \" \" + Last;   \npublic Customer this[long id] => store.LookupCustomer(id);  \n```  \n  \n If the method returns `void` or is an async method, then the body of the method must be a statement expression (same as with lambdas).  For properties and indexers, they must be read only, and you don't use the `get` accessor keyword.  \n  \n## Iterators  \n An iterator performs a custom iteration over a collection, such as a list or an array. An iterator uses the [yield return](../../../csharp/language-reference/keywords/yield.md) statement to return each element one at a time. When a [yield return](../../../csharp/language-reference/keywords/yield.md) statement is reached, the current location in code is remembered. Execution is restarted from that location when the iterator is called the next time.  \n  \n You call an iterator from client code by using a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statement.  \n  \n The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.  \n  \n For more information, see [Iterators](../../../csharp/programming-guide/concepts/iterators.md).  \n  \n## C# Language Specification  \n [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  \n  \n## See also\n\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Classes and Structs](index.md)\n- [Access Modifiers](access-modifiers.md)\n- [Static Classes and Static Class Members](static-classes-and-static-class-members.md)\n- [Inheritance](inheritance.md)\n- [Abstract and Sealed Classes and Class Members](abstract-and-sealed-classes-and-class-members.md)\n- [params](../../../csharp/language-reference/keywords/params.md)\n- [return](../../../csharp/language-reference/keywords/return.md)\n- [out](../../../csharp/language-reference/keywords/out.md)\n- [ref](../../../csharp/language-reference/keywords/ref.md)\n- [Passing Parameters](passing-parameters.md)\n","nodes":[{"pos":[4,200],"embed":true,"restype":"x-metadata","content":"title: \"Methods - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"methods [C#]\"\n  - \"C# language, methods\"\nms.assetid: cc738f07-e8cd-4683-9585-9f40c0667c37","nodes":[{"content":"Methods - C# Programming Guide","nodes":[{"pos":[0,30],"content":"Methods - C# Programming Guide","nodes":[{"content":"Methods - C# Programming Guide","pos":[0,30]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[207,237],"content":"Methods (C# Programming Guide)","linkify":"Methods (C# Programming Guide)","nodes":[{"content":"Methods (C# Programming Guide)","pos":[0,30]}]},{"content":"A method is a code block that contains a series of statements.","pos":[238,300]},{"content":"A program causes the statements to be executed by calling the method and specifying any required method arguments.","pos":[301,415]},{"content":"In C#, every executed instruction is performed in the context of a method.","pos":[416,490]},{"content":"The Main method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.","pos":[491,633]},{"pos":[641,848],"content":"[!NOTE]\n This topic discusses named methods. For information about anonymous functions, see [Anonymous Functions](../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md).","leadings":["","> "],"nodes":[{"content":"This topic discusses named methods. For information about anonymous functions, see [Anonymous Functions](../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md).","pos":[9,205],"nodes":[{"content":"This topic discusses named methods.","pos":[0,35]},{"content":"For information about anonymous functions, see <bpt id=\"p1\">[</bpt>Anonymous Functions<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)</ept>.","pos":[36,196],"source":" For information about anonymous functions, see [Anonymous Functions](../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)."}]}]},{"pos":[857,874],"content":"Method Signatures","linkify":"Method Signatures","nodes":[{"content":"Method Signatures","pos":[0,17]}]},{"content":"Methods are declared in a <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../../../csharp/language-reference/keywords/class.md)</ept> or <bpt id=\"p2\">[</bpt>struct<ept id=\"p2\">](../../../csharp/language-reference/keywords/struct.md)</ept> by specifying the access level such as <ph id=\"ph1\">`public`</ph> or <ph id=\"ph2\">`private`</ph>, optional modifiers such as <ph id=\"ph3\">`abstract`</ph> or <ph id=\"ph4\">`sealed`</ph>, the return value, the name of the method, and any method parameters.","pos":[878,1214],"source":"Methods are declared in a [class](../../../csharp/language-reference/keywords/class.md) or [struct](../../../csharp/language-reference/keywords/struct.md) by specifying the access level such as `public` or `private`, optional modifiers such as `abstract` or `sealed`, the return value, the name of the method, and any method parameters."},{"content":"These parts together are the signature of the method.","pos":[1215,1268]},{"pos":[1276,1534],"content":"[!NOTE]\n A return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.","leadings":["","> "],"nodes":[{"content":"A return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.","pos":[9,256],"nodes":[{"content":"A return type of a method is not part of the signature of the method for the purposes of method overloading.","pos":[0,108]},{"content":"However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.","pos":[109,247]}]}]},{"content":"Method parameters are enclosed in parentheses and are separated by commas.","pos":[1541,1615]},{"content":"Empty parentheses indicate that the method requires no parameters.","pos":[1616,1682]},{"content":"This class contains four methods:","pos":[1683,1716]},{"pos":[1853,1866],"content":"Method Access","linkify":"Method Access","nodes":[{"content":"Method Access","pos":[0,13]}]},{"content":"Calling a method on an object is like accessing a field.","pos":[1870,1926]},{"content":"After the object name, add a period, the name of the method, and parentheses.","pos":[1927,2004]},{"content":"Arguments are listed within the parentheses, and are separated by commas.","pos":[2005,2078]},{"content":"The methods of the <ph id=\"ph1\">`Motorcycle`</ph> class can therefore be called as in the following example:","pos":[2079,2169],"source":" The methods of the `Motorcycle` class can therefore be called as in the following example:"},{"pos":[2306,2337],"content":"Method Parameters vs. Arguments","linkify":"Method Parameters vs. Arguments","nodes":[{"content":"Method Parameters vs. Arguments","pos":[0,31]}]},{"content":"The method definition specifies the names and types of any parameters that are required.","pos":[2341,2429]},{"content":"When calling code calls the method, it provides concrete values called arguments for each parameter.","pos":[2430,2530]},{"content":"The arguments must be compatible with the parameter type but the argument name (if any) used in the calling code does not have to be the same as the parameter named defined in the method.","pos":[2531,2718]},{"content":"For example:","pos":[2719,2731]},{"pos":[2868,2909],"content":"Passing by Reference vs. Passing by Value","linkify":"Passing by Reference vs. Passing by Value","nodes":[{"content":"Passing by Reference vs. Passing by Value","pos":[0,41]}]},{"content":"By default, when a value type is passed to a method, a copy is passed instead of the object itself.","pos":[2913,3012]},{"content":"Therefore, changes to the argument have no effect on the original copy in the calling method.","pos":[3013,3106]},{"content":"You can pass a value-type by reference by using the ref keyword.","pos":[3107,3171]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Passing Value-Type Parameters<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/passing-value-type-parameters.md)</ept>.","pos":[3172,3318],"source":" For more information, see [Passing Value-Type Parameters](../../../csharp/programming-guide/classes-and-structs/passing-value-type-parameters.md)."},{"content":"For a list of built-in value types, see <bpt id=\"p1\">[</bpt>Value Types Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/value-types-table.md)</ept>.","pos":[3319,3445],"source":" For a list of built-in value types, see [Value Types Table](../../../csharp/language-reference/keywords/value-types-table.md)."},{"content":"When an object of a reference type is passed to a method, a reference to the object is passed.","pos":[3452,3546]},{"content":"That is, the method receives not the object itself but an argument that indicates the location of the object.","pos":[3547,3656]},{"content":"If you change a member of the object by using this reference, the change is reflected in the argument in the calling method, even if you pass the object by value.","pos":[3657,3819]},{"pos":[3826,3915],"content":"You create a reference type by using the <ph id=\"ph1\">`class`</ph> keyword, as the following example shows.","source":"You create a reference type by using the `class` keyword, as the following example shows."},{"content":"Now, if you pass an object that is based on this type to a method, a reference to the object is passed.","pos":[4050,4153]},{"content":"The following example passes an object of type <ph id=\"ph1\">`SampleRefType`</ph> to method <ph id=\"ph2\">`ModifyObject`</ph>.","pos":[4154,4242],"source":" The following example passes an object of type `SampleRefType` to method `ModifyObject`."},{"content":"The example does essentially the same thing as the previous example in that it passes an argument by value to a method.","pos":[4377,4496]},{"content":"But, because a reference type is used, the result is different.","pos":[4497,4560]},{"content":"The modification that is made in <ph id=\"ph1\">`ModifyObject`</ph> to the <ph id=\"ph2\">`value`</ph> field of the parameter, <ph id=\"ph3\">`obj`</ph>, also changes the <ph id=\"ph4\">`value`</ph> field of the argument, <ph id=\"ph5\">`rt`</ph>, in the <ph id=\"ph6\">`TestRefType`</ph> method.","pos":[4561,4737],"source":" The modification that is made in `ModifyObject` to the `value` field of the parameter, `obj`, also changes the `value` field of the argument, `rt`, in the `TestRefType` method."},{"content":"The <ph id=\"ph1\">`TestRefType`</ph> method displays 33 as the output.","pos":[4738,4789],"source":" The `TestRefType` method displays 33 as the output."},{"pos":[4796,5096],"content":"For more information about how to pass reference types by reference and by value, see <bpt id=\"p1\">[</bpt>Passing Reference-Type Parameters<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/passing-reference-type-parameters.md)</ept> and <bpt id=\"p2\">[</bpt>Reference Types<ept id=\"p2\">](../../../csharp/language-reference/keywords/reference-types.md)</ept>.","source":"For more information about how to pass reference types by reference and by value, see [Passing Reference-Type Parameters](../../../csharp/programming-guide/classes-and-structs/passing-reference-type-parameters.md) and [Reference Types](../../../csharp/language-reference/keywords/reference-types.md)."},{"pos":[5105,5118],"content":"Return Values","linkify":"Return Values","nodes":[{"content":"Return Values","pos":[0,13]}]},{"content":"Methods can return a value to the caller.","pos":[5121,5162]},{"content":"If the return type, the type listed before the method name, is not <ph id=\"ph1\">`void`</ph>, the method can return the value by using the <ph id=\"ph2\">`return`</ph> keyword.","pos":[5163,5300],"source":" If the return type, the type listed before the method name, is not `void`, the method can return the value by using the `return` keyword."},{"content":"A statement with the <ph id=\"ph1\">`return`</ph> keyword followed by a value that matches the return type will return that value to the method caller.","pos":[5301,5432],"source":" A statement with the `return` keyword followed by a value that matches the return type will return that value to the method caller."},{"content":"The value can be returned to the caller by value or, starting with C# 7.0, <bpt id=\"p1\">[</bpt>by reference<ept id=\"p1\">](ref-returns.md)</ept>.","pos":[5435,5541],"source":"The value can be returned to the caller by value or, starting with C# 7.0, [by reference](ref-returns.md)."},{"content":"Values are returned to the caller by reference if the <ph id=\"ph1\">`ref`</ph> keyword is used in the method signature and it follows each <ph id=\"ph2\">`return`</ph> keyword.","pos":[5542,5679],"source":" Values are returned to the caller by reference if the `ref` keyword is used in the method signature and it follows each `return` keyword."},{"content":"For example, the following method signature and return statement indicate that the method returns a variable names <ph id=\"ph1\">`estDistance`</ph> by reference to the caller.","pos":[5680,5836],"source":" For example, the following method signature and return statement indicate that the method returns a variable names `estDistance` by reference to the caller."},{"content":"The <ph id=\"ph1\">`return`</ph> keyword also stops the execution of the method.","pos":[5925,5985],"source":"The `return` keyword also stops the execution of the method."},{"content":"If the return type is <ph id=\"ph1\">`void`</ph>, a <ph id=\"ph2\">`return`</ph> statement without a value is still useful to stop the execution of the method.","pos":[5986,6105],"source":" If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method."},{"content":"Without the <ph id=\"ph1\">`return`</ph> keyword, the method will stop executing when it reaches the end of the code block.","pos":[6106,6209],"source":" Without the `return` keyword, the method will stop executing when it reaches the end of the code block."},{"content":"Methods with a non-void return type are required to use the <ph id=\"ph1\">`return`</ph> keyword to return a value.","pos":[6210,6305],"source":" Methods with a non-void return type are required to use the `return` keyword to return a value."},{"content":"For example, these two methods use the <ph id=\"ph1\">`return`</ph> keyword to return integers:","pos":[6306,6381],"source":" For example, these two methods use the `return` keyword to return integers:"},{"content":"To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.","pos":[6516,6659]},{"content":"You can also assign the return value to a variable.","pos":[6660,6711]},{"content":"For example, the following two code examples accomplish the same goal:","pos":[6712,6782]},{"content":"Using a local variable, in this case, <ph id=\"ph1\">`result`</ph>, to store a value is optional.","pos":[7045,7122],"source":"Using a local variable, in this case, `result`, to store a value is optional."},{"content":"It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.","pos":[7123,7278]},{"content":"To use a value returned by reference from a method, you must declare a <bpt id=\"p1\">[</bpt>ref local<ept id=\"p1\">](ref-returns.md#ref-locals)</ept> variable if you intend to modify its value.","pos":[7282,7435],"source":"To use a value returned by reference from a method, you must declare a [ref local](ref-returns.md#ref-locals) variable if you intend to modify its value."},{"content":"For example, if the <ph id=\"ph1\">`Planet.GetEstimatedDistance`</ph> method returns a <ph id=\"ph2\">&lt;xref:System.Double&gt;</ph> value by reference, you can define it as a ref local variable with code like the following:","pos":[7436,7615],"source":" For example, if the `Planet.GetEstimatedDistance` method returns a <xref:System.Double> value by reference, you can define it as a ref local variable with code like the following:"},{"content":"Returning a multi-dimensional array from a method, <ph id=\"ph1\">`M`</ph>, that modifies the array's contents is not necessary if the calling function passed the array into <ph id=\"ph2\">`M`</ph>.","pos":[7658,7816],"source":"Returning a multi-dimensional array from a method, `M`, that modifies the array's contents is not necessary if the calling function passed the array into `M`."},{"content":"You may return the resulting array from <ph id=\"ph1\">`M`</ph> for good style or functional flow of values, but it is not necessary because C# passes all reference types by value, and the value of an array reference is the pointer to the array.","pos":[7818,8043],"source":"  You may return the resulting array from `M` for good style or functional flow of values, but it is not necessary because C# passes all reference types by value, and the value of an array reference is the pointer to the array."},{"content":"In the method <ph id=\"ph1\">`M`</ph>, any changes to the array's contents are observable by any code that has a reference to the array, as shown in the following example.","pos":[8044,8195],"source":" In the method `M`, any changes to the array's contents are observable by any code that has a reference to the array, as shown in the following example."},{"pos":[8567,8657],"content":"For more information, see <bpt id=\"p1\">[</bpt>return<ept id=\"p1\">](../../../csharp/language-reference/keywords/return.md)</ept>.","source":"For more information, see [return](../../../csharp/language-reference/keywords/return.md)."},{"pos":[8666,8679],"content":"Async Methods","linkify":"Async Methods","nodes":[{"content":"Async Methods","pos":[0,13]}]},{"content":"By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.","pos":[8683,8858]},{"content":"If you mark a method with the <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](../../../csharp/language-reference/keywords/async.md)</ept> modifier, you can use the <bpt id=\"p2\">[</bpt>await<ept id=\"p2\">](../../../csharp/language-reference/keywords/await.md)</ept> operator in the method.","pos":[8864,9067],"source":"If you mark a method with the [async](../../../csharp/language-reference/keywords/async.md) modifier, you can use the [await](../../../csharp/language-reference/keywords/await.md) operator in the method."},{"content":"When control reaches an await expression in the async method, control returns to the caller, and progress in the method is suspended until the awaited task completes.","pos":[9068,9234]},{"content":"When the task is complete, execution can resume in the method.","pos":[9235,9297]},{"pos":[9305,9495],"content":"[!NOTE]\n An async method returns to the caller when either it encounters the first awaited object thatâ€™s not yet complete or it gets to the end of the async method, whichever occurs first.","leadings":["","> "],"nodes":[{"content":"An async method returns to the caller when either it encounters the first awaited object thatâ€™s not yet complete or it gets to the end of the async method, whichever occurs first.","pos":[9,188]}]},{"content":"An async method can have a return type of <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, or void.","pos":[9502,9628],"source":"An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or void."},{"content":"The void return type is used primarily to define event handlers, where a void return type is required.","pos":[9629,9731]},{"content":"An async method that returns void can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.","pos":[9732,9872]},{"content":"In the following example, <ph id=\"ph1\">`DelayAsync`</ph> is an async method that has a return type of <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>.","pos":[9879,10002],"source":"In the following example, `DelayAsync` is an async method that has a return type of <xref:System.Threading.Tasks.Task%601>."},{"content":"<ph id=\"ph1\">`DelayAsync`</ph> has a <ph id=\"ph2\">`return`</ph> statement that returns an integer.","pos":[10003,10065],"source":"`DelayAsync` has a `return` statement that returns an integer."},{"content":"Therefore the method declaration of <ph id=\"ph1\">`DelayAsync`</ph> must have a return type of <ph id=\"ph2\">`Task&lt;int&gt;`</ph>.","pos":[10066,10154],"source":" Therefore the method declaration of `DelayAsync` must have a return type of `Task<int>`."},{"content":"Because the return type is <ph id=\"ph1\">`Task&lt;int&gt;`</ph>, the evaluation of the <ph id=\"ph2\">`await`</ph> expression in <ph id=\"ph3\">`DoSomethingAsync`</ph> produces an integer as the following statement demonstrates: <ph id=\"ph4\">`int result = await delayTask`</ph>.","pos":[10155,10350],"source":" Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer as the following statement demonstrates: `int result = await delayTask`."},{"content":"The <ph id=\"ph1\">`startButton_Click`</ph> method is an example of an async method that has a return type of void.","pos":[10357,10452],"source":"The `startButton_Click` method is an example of an async method that has a return type of void."},{"content":"Because <ph id=\"ph1\">`DoSomethingAsync`</ph> is an async method, the task for the call to <ph id=\"ph2\">`DoSomethingAsync`</ph> must be awaited, as the following statement shows: <ph id=\"ph3\">`await DoSomethingAsync();`</ph>.","pos":[10453,10623],"source":" Because `DoSomethingAsync` is an async method, the task for the call to `DoSomethingAsync` must be awaited, as the following statement shows: `await DoSomethingAsync();`."},{"content":"The <ph id=\"ph1\">`startButton_Click`</ph> method must be defined with the <ph id=\"ph2\">`async`</ph> modifier because the method has an <ph id=\"ph3\">`await`</ph> expression.","pos":[10624,10742],"source":" The `startButton_Click` method must be defined with the `async` modifier because the method has an `await` expression."},{"pos":[10873,11107],"content":"An async method can't declare any <bpt id=\"p1\">[</bpt>ref<ept id=\"p1\">](../../../csharp/language-reference/keywords/ref.md)</ept> or <bpt id=\"p2\">[</bpt>out<ept id=\"p2\">](../../../csharp/language-reference/keywords/out-parameter-modifier.md)</ept> parameters, but it can call methods that have such parameters.","source":"An async method can't declare any [ref](../../../csharp/language-reference/keywords/ref.md) or [out](../../../csharp/language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters."},{"pos":[11114,11483],"content":"For more information about async methods, see <bpt id=\"p1\">[</bpt>Asynchronous Programming with async and await<ept id=\"p1\">](../../../csharp/programming-guide/concepts/async/index.md)</ept>, <bpt id=\"p2\">[</bpt>Control Flow in Async Programs<ept id=\"p2\">](../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)</ept>, and <bpt id=\"p3\">[</bpt>Async Return Types<ept id=\"p3\">](../../../csharp/programming-guide/concepts/async/async-return-types.md)</ept>.","source":"For more information about async methods, see [Asynchronous Programming with async and await](../../../csharp/programming-guide/concepts/async/index.md), [Control Flow in Async Programs](../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md), and [Async Return Types](../../../csharp/programming-guide/concepts/async/async-return-types.md)."},{"pos":[11492,11519],"content":"Expression Body Definitions","linkify":"Expression Body Definitions","nodes":[{"content":"Expression Body Definitions","pos":[0,27]}]},{"content":"It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.","pos":[11523,11686]},{"content":"There is a syntax shortcut for defining such methods using <ph id=\"ph1\">`=&gt;`</ph>:","pos":[11688,11752],"source":"  There is a syntax shortcut for defining such methods using `=>`:"},{"content":"If the method returns <ph id=\"ph1\">`void`</ph> or is an async method, then the body of the method must be a statement expression (same as with lambdas).","pos":[12144,12278],"source":"If the method returns `void` or is an async method, then the body of the method must be a statement expression (same as with lambdas)."},{"content":"For properties and indexers, they must be read only, and you don't use the <ph id=\"ph1\">`get`</ph> accessor keyword.","pos":[12280,12378],"source":"  For properties and indexers, they must be read only, and you don't use the `get` accessor keyword."},{"pos":[12387,12396],"content":"Iterators","linkify":"Iterators","nodes":[{"content":"Iterators","pos":[0,9]}]},{"content":"An iterator performs a custom iteration over a collection, such as a list or an array.","pos":[12400,12486]},{"content":"An iterator uses the <bpt id=\"p1\">[</bpt>yield return<ept id=\"p1\">](../../../csharp/language-reference/keywords/yield.md)</ept> statement to return each element one at a time.","pos":[12487,12624],"source":" An iterator uses the [yield return](../../../csharp/language-reference/keywords/yield.md) statement to return each element one at a time."},{"content":"When a <bpt id=\"p1\">[</bpt>yield return<ept id=\"p1\">](../../../csharp/language-reference/keywords/yield.md)</ept> statement is reached, the current location in code is remembered.","pos":[12625,12766],"source":" When a [yield return](../../../csharp/language-reference/keywords/yield.md) statement is reached, the current location in code is remembered."},{"content":"Execution is restarted from that location when the iterator is called the next time.","pos":[12767,12851]},{"pos":[12858,12986],"content":"You call an iterator from client code by using a <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](../../../csharp/language-reference/keywords/foreach-in.md)</ept> statement.","source":"You call an iterator from client code by using a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statement."},{"pos":[12993,13213],"content":"The return type of an iterator can be <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Collections.IEnumerator&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph>.","source":"The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>."},{"pos":[13220,13315],"content":"For more information, see <bpt id=\"p1\">[</bpt>Iterators<ept id=\"p1\">](../../../csharp/programming-guide/concepts/iterators.md)</ept>.","source":"For more information, see [Iterators](../../../csharp/programming-guide/concepts/iterators.md)."},{"pos":[13324,13349],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[13421,13429],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[13433,13499],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[13502,13533],"content":"<bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](index.md)</ept>","source":"[Classes and Structs](index.md)"},{"pos":[13536,13575],"content":"<bpt id=\"p1\">[</bpt>Access Modifiers<ept id=\"p1\">](access-modifiers.md)</ept>","source":"[Access Modifiers](access-modifiers.md)"},{"pos":[13578,13663],"content":"<bpt id=\"p1\">[</bpt>Static Classes and Static Class Members<ept id=\"p1\">](static-classes-and-static-class-members.md)</ept>","source":"[Static Classes and Static Class Members](static-classes-and-static-class-members.md)"},{"pos":[13666,13695],"content":"<bpt id=\"p1\">[</bpt>Inheritance<ept id=\"p1\">](inheritance.md)</ept>","source":"[Inheritance](inheritance.md)"},{"pos":[13698,13795],"content":"<bpt id=\"p1\">[</bpt>Abstract and Sealed Classes and Class Members<ept id=\"p1\">](abstract-and-sealed-classes-and-class-members.md)</ept>","source":"[Abstract and Sealed Classes and Class Members](abstract-and-sealed-classes-and-class-members.md)"},{"pos":[13798,13861],"content":"<bpt id=\"p1\">[</bpt>params<ept id=\"p1\">](../../../csharp/language-reference/keywords/params.md)</ept>","source":"[params](../../../csharp/language-reference/keywords/params.md)"},{"pos":[13864,13927],"content":"<bpt id=\"p1\">[</bpt>return<ept id=\"p1\">](../../../csharp/language-reference/keywords/return.md)</ept>","source":"[return](../../../csharp/language-reference/keywords/return.md)"},{"pos":[13930,13987],"content":"<bpt id=\"p1\">[</bpt>out<ept id=\"p1\">](../../../csharp/language-reference/keywords/out.md)</ept>","source":"[out](../../../csharp/language-reference/keywords/out.md)"},{"pos":[13990,14047],"content":"<bpt id=\"p1\">[</bpt>ref<ept id=\"p1\">](../../../csharp/language-reference/keywords/ref.md)</ept>","source":"[ref](../../../csharp/language-reference/keywords/ref.md)"},{"pos":[14050,14093],"content":"<bpt id=\"p1\">[</bpt>Passing Parameters<ept id=\"p1\">](passing-parameters.md)</ept>","source":"[Passing Parameters](passing-parameters.md)"}]}