{"content":"---\ntitle: Get started with semantic analysis\ndescription: This tutorial provides an overview of working with semantic analysis using the .NET Compiler SDK.\nms.date: 02/06/2018\nms.custom: mvc\n---\n\n# Get started with semantic analysis\n\nThis tutorial assumes you're familiar with the Syntax API. The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.\n\nIn this tutorial, you explore the **Symbol** and **Binding APIs**. These APIs provide information about the _semantic meaning_ of a program. They enable you to ask and answer questions about the types represented by any symbol in your program.\n\nYou'll need to install the **.NET Compiler Platform SDK**:\n\n[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]\n\n## Understanding Compilations and Symbols\n\nAs you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API. The **Syntax API** allows you to look at the _structure_ of a program. However, often you want richer information about the semantics or _meaning_ of a program. While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as \"what's the type of this variable\" in a vacuum. The meaning of a type name may be dependent on assembly references, namespace imports, or other code files. Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.\n\nAn instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program. The **compilation** includes the set of source files to be compiled, assembly references, and compiler options. You can reason about the meaning of the code using all the other information in this context. A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to. The process of associating names and expressions with **Symbols** is called **Binding**.\n\nLike <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives. When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.\n\n## Querying symbols\n\nIn this tutorial, you look at the \"Hello World\" program again. This time, you query the symbols in the program to understand what types those symbols represent. You query for the types in a namespace, and learn to find the methods available on a type.\n\nYou can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).\n\n> [!NOTE]\n> The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program. Using these APIs often means casting properties or collection members to specific derived types. In the following examples, the assignment and the casts are separate statements, using explicitly typed variables. You can read the code to see the return types of the API and the runtime type of the objects returned. In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.\n\nCreate a new C# **Stand-Alone Code Analysis Tool** project:\n\n* In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.\n* Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.\n* Name your project \"**SemanticQuickStart**\" and click OK.\n\nYou're going to analyze the basic \"Hello World!\" program shown earlier.\nAdd the text for the Hello World program as a constant in your `Program` class:\n\n[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 \"Declare a constant string for the program text to analyze\")]\n\nNext, add the following code to build the syntax tree for the code text in the `programText` constant.  Add the following line to your `Main` method:\n\n[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 \"Create the syntax tree\")]\n\nNext, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created. The \"Hello World\" sample relies on the <xref:System.String> and <xref:System.Console> types. You need to reference the assembly that declares those two types in your compilation. Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:\n\n[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 \"Create the compilation for the semantic model\")]\n\nThe <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation. The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference. \n\n## Querying the semantic model\n\nOnce you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>. You can think of the semantic model as the source for all the information you would normally get from intellisense. A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like \"What names are in scope at this location?\", \"What members are accessible from this method?\", \"What variables are used in this block of text?\", and \"What does this name/expression refer to?\" Add this statement to create the semantic model:\n\n[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 \"Create the semantic model\")]\n\n## Binding a name\n\nThe <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>. After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace. Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:\n\n[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 \"Find the namespace symbol for the first using\")]\n\nThe preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace. The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning. The **syntax model** finds the string `System` in the using statement. The **semantic model** has all the information about the types defined in the `System` namespace.\n\nFrom the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property. This property returns the symbol this expression refers to. For expressions that don't refer to anything (such as numeric literals) this property is `null`. When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol. In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>. Add the following code to your `Main` method. It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:\n\n[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 \"Display all the child namespaces from this compilation\")]\n\nRun the program and you should see the following output:\n\n```\nSystem.Collections\nSystem.Configuration\nSystem.Deployment\nSystem.Diagnostics\nSystem.Globalization\nSystem.IO\nSystem.Numerics\nSystem.Reflection\nSystem.Resources\nSystem.Runtime\nSystem.Security\nSystem.StubHelpers\nSystem.Text\nSystem.Threading\nPress any key to continue . . .\n```\n\n> [!NOTE]\n> The output does not include every namespace that is a child namespace of the `System` namespace. It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared. Any namespaces declared in other assemblies are not known to this compilation\n\n### Binding an expression\n\nThe preceding code shows how to find a symbol by binding to a name. There are other expressions in a C# program that can be bound that aren't names. To demonstrate this capability, let's access the binding to a simple string literal.\n\nThe \"Hello World\" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the \"Hello, World!\" string displayed to the console.\n\nYou find the \"Hello, World!\" string by locating the single string literal in the program. Then, once you've located the syntax node, get the type info for that node from the semantic model. Add the following code to your `Main` method:\n\n[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 \"Find the namespace symbol for the only using\")]\n\nThe <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal. In this example, that's the `string` type. Add a declaration that assigns this property to a local variable:\n\n[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 \"Use the string literal to access the semantic information in the string type.\")]\n\nTo finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`. This query gets complex, so let's build it line by line, then reconstruct it as a single query. The source for this query is the sequence of all members declared on the `string` type:\n\n[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 \"Access the sequence of members on the string type.\")]\n\nThat source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:\n\n[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 \"Find the subset of the collection that is the methods.\")]\n\nNext, add another filter to return only those methods that are public and return a `string`:\n\n[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 \"Find only the public methods that return a string.\")]\n\nSelect only the name property, and only distinct names by removing any overloads:\n\n[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 \"Use the string literal to access the semantic information in the string type.\")]\n\nYou can also build the full query using the LINQ query syntax, and then display all the method names in  the console:\n\n[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 \"Build and display the results of the query.\")]\n\nBuild and run the program. You should see the following output:\n\n```\nJoin\nSubstring\nTrim\nTrimStart\nTrimEnd\nNormalize\nPadLeft\nPadRight\nToLower\nToLowerInvariant\nToUpper\nToUpperInvariant\nToString\nInsert\nReplace\nRemove\nFormat\nCopy\nConcat\nIntern\nIsInterned\nPress any key to continue . . .\n```\nYou've used the Semantic API to find and display information about the symbols that are part of this program.\n","nodes":[{"pos":[4,191],"embed":true,"restype":"x-metadata","content":"title: Get started with semantic analysis\ndescription: This tutorial provides an overview of working with semantic analysis using the .NET Compiler SDK.\nms.date: 02/06/2018\nms.custom: mvc","nodes":[{"content":"Get started with semantic analysis","nodes":[{"pos":[0,34],"content":"Get started with semantic analysis","nodes":[{"content":"Get started with semantic analysis","pos":[0,34]}]}],"path":["title"],"nosxs":false},{"content":"This tutorial provides an overview of working with semantic analysis using the .NET Compiler SDK.","nodes":[{"pos":[0,97],"content":"This tutorial provides an overview of working with semantic analysis using the .NET Compiler SDK.","nodes":[{"content":"This tutorial provides an overview of working with semantic analysis using the .NET Compiler SDK.","pos":[0,97]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[199,233],"content":"Get started with semantic analysis","linkify":"Get started with semantic analysis","nodes":[{"content":"Get started with semantic analysis","pos":[0,34]}]},{"content":"This tutorial assumes you're familiar with the Syntax API.","pos":[235,293]},{"content":"The <bpt id=\"p1\">[</bpt>get started with syntax analysis<ept id=\"p1\">](syntax-analysis.md)</ept> article provides sufficient introduction.","pos":[294,394],"source":" The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction."},{"content":"In this tutorial, you explore the <bpt id=\"p1\">**</bpt>Symbol<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Binding APIs<ept id=\"p2\">**</ept>.","pos":[396,462],"source":"In this tutorial, you explore the **Symbol** and **Binding APIs**."},{"content":"These APIs provide information about the <bpt id=\"p1\">_</bpt>semantic meaning<ept id=\"p1\">_</ept> of a program.","pos":[463,536],"source":" These APIs provide information about the _semantic meaning_ of a program."},{"content":"They enable you to ask and answer questions about the types represented by any symbol in your program.","pos":[537,639]},{"pos":[641,699],"content":"You'll need to install the <bpt id=\"p1\">**</bpt>.NET Compiler Platform SDK<ept id=\"p1\">**</ept>:","source":"You'll need to install the **.NET Compiler Platform SDK**:"},{"pos":[769,807],"content":"Understanding Compilations and Symbols","linkify":"Understanding Compilations and Symbols","nodes":[{"content":"Understanding Compilations and Symbols","pos":[0,38]}]},{"content":"As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.","pos":[809,936]},{"content":"The <bpt id=\"p1\">**</bpt>Syntax API<ept id=\"p1\">**</ept> allows you to look at the <bpt id=\"p2\">_</bpt>structure<ept id=\"p2\">_</ept> of a program.","pos":[937,1007],"source":" The **Syntax API** allows you to look at the _structure_ of a program."},{"content":"However, often you want richer information about the semantics or <bpt id=\"p1\">_</bpt>meaning<ept id=\"p1\">_</ept> of a program.","pos":[1008,1097],"source":" However, often you want richer information about the semantics or _meaning_ of a program."},{"content":"While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as \"what's the type of this variable\" in a vacuum.","pos":[1098,1286]},{"content":"The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.","pos":[1287,1394]},{"content":"Those questions are answered using the <bpt id=\"p1\">**</bpt>Semantic API<ept id=\"p1\">**</ept>, specifically the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType&gt;</ph> class.","pos":[1395,1546],"source":" Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class."},{"content":"An instance of <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.","pos":[1548,1735],"source":"An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program."},{"content":"The <bpt id=\"p1\">**</bpt>compilation<ept id=\"p1\">**</ept> includes the set of source files to be compiled, assembly references, and compiler options.","pos":[1736,1847],"source":" The **compilation** includes the set of source files to be compiled, assembly references, and compiler options."},{"content":"You can reason about the meaning of the code using all the other information in this context.","pos":[1848,1941]},{"content":"A <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph> allows you to find <bpt id=\"p1\">**</bpt>Symbols<ept id=\"p1\">**</ept> - entities such as types, namespaces, members, and variables which names and other expressions refer to.","pos":[1942,2121],"source":" A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to."},{"content":"The process of associating names and expressions with <bpt id=\"p1\">**</bpt>Symbols<ept id=\"p1\">**</ept> is called <bpt id=\"p2\">**</bpt>Binding<ept id=\"p2\">**</ept>.","pos":[2122,2210],"source":" The process of associating names and expressions with **Symbols** is called **Binding**."},{"content":"Like <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph> is an abstract class with language-specific derivatives.","pos":[2212,2386],"source":"Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives."},{"content":"When creating an instance of Compilation, you must invoke a factory method on the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType&gt;</ph> (or <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType&gt;</ph>) class.","pos":[2387,2658],"source":" When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class."},{"pos":[2663,2679],"content":"Querying symbols","linkify":"Querying symbols","nodes":[{"content":"Querying symbols","pos":[0,16]}]},{"content":"In this tutorial, you look at the \"Hello World\" program again.","pos":[2681,2743]},{"content":"This time, you query the symbols in the program to understand what types those symbols represent.","pos":[2744,2841]},{"content":"You query for the types in a namespace, and learn to find the methods available on a type.","pos":[2842,2932]},{"pos":[2934,3091],"content":"You can see the finished code for this sample in <bpt id=\"p1\">[</bpt>our GitHub repository<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart)</ept>.","source":"You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart)."},{"pos":[3095,3687],"content":"[!NOTE]\nThe Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program. Using these APIs often means casting properties or collection members to specific derived types. In the following examples, the assignment and the casts are separate statements, using explicitly typed variables. You can read the code to see the return types of the API and the runtime type of the objects returned. In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.","leadings":["","> "],"nodes":[{"content":"The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program. Using these APIs often means casting properties or collection members to specific derived types. In the following examples, the assignment and the casts are separate statements, using explicitly typed variables. You can read the code to see the return types of the API and the runtime type of the objects returned. In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.","pos":[8,590],"nodes":[{"content":"The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.","pos":[0,133]},{"content":"Using these APIs often means casting properties or collection members to specific derived types.","pos":[134,230]},{"content":"In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.","pos":[231,345]},{"content":"You can read the code to see the return types of the API and the runtime type of the objects returned.","pos":[346,448]},{"content":"In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.","pos":[449,582]}]}]},{"pos":[3689,3748],"content":"Create a new C# <bpt id=\"p1\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p1\">**</ept> project:","source":"Create a new C# **Stand-Alone Code Analysis Tool** project:"},{"pos":[3752,3844],"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>File<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept><ph id=\"ph2\"> &gt; </ph><bpt id=\"p3\">**</bpt>Project<ept id=\"p3\">**</ept> to display the New Project dialog.","source":"In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog."},{"pos":[3847,3930],"content":"Under <bpt id=\"p1\">**</bpt>Visual C#<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Extensibility<ept id=\"p2\">**</ept>, choose <bpt id=\"p3\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p3\">**</ept>.","source":"Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**."},{"pos":[3933,3989],"content":"Name your project \"<bpt id=\"p1\">**</bpt>SemanticQuickStart<ept id=\"p1\">**</ept>\" and click OK.","source":"Name your project \"**SemanticQuickStart**\" and click OK."},{"content":"You're going to analyze the basic \"Hello World!\"","pos":[3991,4039]},{"content":"program shown earlier.","pos":[4040,4062]},{"content":"Add the text for the Hello World program as a constant in your <ph id=\"ph1\">`Program`</ph> class:","pos":[4063,4142],"source":"\nAdd the text for the Hello World program as a constant in your `Program` class:"},{"content":"Next, add the following code to build the syntax tree for the code text in the <ph id=\"ph1\">`programText`</ph> constant.","pos":[4317,4419],"source":"Next, add the following code to build the syntax tree for the code text in the `programText` constant."},{"content":"Add the following line to your <ph id=\"ph1\">`Main`</ph> method:","pos":[4421,4466],"source":"  Add the following line to your `Main` method:"},{"content":"Next, build a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation&gt;</ph> from the tree you already created.","pos":[4597,4700],"source":"Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created."},{"content":"The \"Hello World\" sample relies on the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Console&gt;</ph> types.","pos":[4701,4793],"source":" The \"Hello World\" sample relies on the <xref:System.String> and <xref:System.Console> types."},{"content":"You need to reference the assembly that declares those two types in your compilation.","pos":[4794,4879]},{"content":"Add the following line to your <ph id=\"ph1\">`Main`</ph> method to create a compilation of your syntax tree, including the reference to the appropriate assembly:","pos":[4880,5022],"source":" Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:"},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType&gt;</ph> method adds references to the compilation.","pos":[5183,5330],"source":"The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType&gt;</ph> method loads an assembly as a reference.","pos":[5331,5470],"source":" The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference."},{"pos":[5476,5503],"content":"Querying the semantic model","linkify":"Querying the semantic model","nodes":[{"content":"Querying the semantic model","pos":[0,27]}]},{"content":"Once you have a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph> you can ask it for a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> for any <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.SyntaxTree&gt;</ph> contained in that <ph id=\"ph4\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph>.","pos":[5505,5737],"source":"Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>."},{"content":"You can think of the semantic model as the source for all the information you would normally get from intellisense.","pos":[5738,5853]},{"content":"A <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> can answer questions like \"What names are in scope at this location?\", \"What members are accessible from this method?\", \"What variables are used in this block of text?\", and \"What does this name/expression refer to?\"","pos":[5854,6116],"source":" A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like \"What names are in scope at this location?\", \"What members are accessible from this method?\", \"What variables are used in this block of text?\", and \"What does this name/expression refer to?\""},{"content":"Add this statement to create the semantic model:","pos":[6117,6165]},{"pos":[6312,6326],"content":"Binding a name","linkify":"Binding a name","nodes":[{"content":"Binding a name","pos":[0,14]}]},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph> creates the  <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> from the <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.SyntaxTree&gt;</ph>.","pos":[6328,6481],"source":"The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>."},{"content":"After creating the model, you can query it to find the first <ph id=\"ph1\">`using`</ph> directive, and retrieve the symbol information for the <ph id=\"ph2\">`System`</ph> namespace.","pos":[6482,6625],"source":" After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace."},{"content":"Add these two lines to your <ph id=\"ph1\">`Main`</ph> method to create the semantic model and retrieve the symbol for the first using statement:","pos":[6626,6751],"source":" Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:"},{"content":"The preceding code shows how to bind the name in the first <ph id=\"ph1\">`using`</ph> directive to retrieve a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType&gt;</ph> for the <ph id=\"ph3\">`System`</ph> namespace.","pos":[6935,7123],"source":"The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace."},{"content":"The preceding code also illustrates that you use the <bpt id=\"p1\">**</bpt>syntax model<ept id=\"p1\">**</ept> to find the structure of the code; you use the <bpt id=\"p2\">**</bpt>semantic model<ept id=\"p2\">**</ept> to understand its meaning.","pos":[7124,7286],"source":" The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning."},{"content":"The <bpt id=\"p1\">**</bpt>syntax model<ept id=\"p1\">**</ept> finds the string <ph id=\"ph1\">`System`</ph> in the using statement.","pos":[7287,7357],"source":" The **syntax model** finds the string `System` in the using statement."},{"content":"The <bpt id=\"p1\">**</bpt>semantic model<ept id=\"p1\">**</ept> has all the information about the types defined in the <ph id=\"ph1\">`System`</ph> namespace.","pos":[7358,7455],"source":" The **semantic model** has all the information about the types defined in the `System` namespace."},{"content":"From the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SymbolInfo&gt;</ph> object you can obtain the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType&gt;</ph> using the <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType&gt;</ph> property.","pos":[7457,7696],"source":"From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property."},{"content":"This property returns the symbol this expression refers to.","pos":[7697,7756]},{"content":"For expressions that don't refer to anything (such as numeric literals) this property is <ph id=\"ph1\">`null`</ph>.","pos":[7757,7853],"source":" For expressions that don't refer to anything (such as numeric literals) this property is `null`."},{"content":"When the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType&gt;</ph> is not null, the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType&gt;</ph> denotes the type of the symbol.","pos":[7854,8060],"source":" When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol."},{"content":"In this example, the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType&gt;</ph> property is a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType&gt;</ph>.","pos":[8061,8248],"source":" In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>."},{"content":"Add the following code to your <ph id=\"ph1\">`Main`</ph> method.","pos":[8249,8294],"source":" Add the following code to your `Main` method."},{"content":"It retrieves the symbol for the <ph id=\"ph1\">`System`</ph> namespace and then displays all the child namespaces declared in the <ph id=\"ph2\">`System`</ph> namespace:","pos":[8295,8424],"source":" It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:"},{"content":"Run the program and you should see the following output:","pos":[8604,8660]},{"pos":[8943,9262],"content":"[!NOTE]\nThe output does not include every namespace that is a child namespace of the `System` namespace. It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared. Any namespaces declared in other assemblies are not known to this compilation","leadings":["","> "],"nodes":[{"content":"The output does not include every namespace that is a child namespace of the `System` namespace. It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared. Any namespaces declared in other assemblies are not known to this compilation","pos":[8,317],"nodes":[{"content":"The output does not include every namespace that is a child namespace of the <ph id=\"ph1\">`System`</ph> namespace.","pos":[0,96],"source":"The output does not include every namespace that is a child namespace of the `System` namespace."},{"content":"It displays every namespace that is present in this compilation, which only references the assembly where <ph id=\"ph1\">`System.String`</ph> is declared.","pos":[97,231],"source":" It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared."},{"content":"Any namespaces declared in other assemblies are not known to this compilation","pos":[232,309]}]}]},{"pos":[9268,9289],"content":"Binding an expression","linkify":"Binding an expression","nodes":[{"content":"Binding an expression","pos":[0,21]}]},{"content":"The preceding code shows how to find a symbol by binding to a name.","pos":[9291,9358]},{"content":"There are other expressions in a C# program that can be bound that aren't names.","pos":[9359,9439]},{"content":"To demonstrate this capability, let's access the binding to a simple string literal.","pos":[9440,9524]},{"content":"The \"Hello World\" program contains a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType&gt;</ph>, the \"Hello, World!\"","pos":[9526,9680],"source":"The \"Hello World\" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the \"Hello, World!\""},{"content":"string displayed to the console.","pos":[9681,9713]},{"content":"You find the \"Hello, World!\"","pos":[9715,9743]},{"content":"string by locating the single string literal in the program.","pos":[9744,9804]},{"content":"Then, once you've located the syntax node, get the type info for that node from the semantic model.","pos":[9805,9904]},{"content":"Add the following code to your <ph id=\"ph1\">`Main`</ph> method:","pos":[9905,9950],"source":" Add the following code to your `Main` method:"},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType&gt;</ph> struct includes a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType&gt;</ph> property that enables access to the semantic information about the type of the literal.","pos":[10132,10382],"source":"The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal."},{"content":"In this example, that's the <ph id=\"ph1\">`string`</ph> type.","pos":[10383,10425],"source":" In this example, that's the `string` type."},{"content":"Add a declaration that assigns this property to a local variable:","pos":[10426,10491]},{"content":"To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the <ph id=\"ph1\">`string`</ph> type that return a <ph id=\"ph2\">`string`</ph>.","pos":[10713,10866],"source":"To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`."},{"content":"This query gets complex, so let's build it line by line, then reconstruct it as a single query.","pos":[10867,10962]},{"content":"The source for this query is the sequence of all members declared on the <ph id=\"ph1\">`string`</ph> type:","pos":[10963,11050],"source":" The source for this query is the sequence of all members declared on the `string` type:"},{"pos":[11243,11550],"content":"That source sequence contains all members, including properties and fields, so filter it using the <ph id=\"ph1\">&lt;xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType&gt;</ph> method to find elements that are <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType&gt;</ph> objects:","source":"That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:"},{"pos":[11734,11826],"content":"Next, add another filter to return only those methods that are public and return a <ph id=\"ph1\">`string`</ph>:","source":"Next, add another filter to return only those methods that are public and return a `string`:"},{"content":"Select only the name property, and only distinct names by removing any overloads:","pos":[12010,12091]},{"content":"You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:","pos":[12287,12404]},{"content":"Build and run the program.","pos":[12586,12612]},{"content":"You should see the following output:","pos":[12613,12649]},{"content":"You've used the Semantic API to find and display information about the symbols that are part of this program.","pos":[12874,12983]}]}