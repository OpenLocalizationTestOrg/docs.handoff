{"content":"---\ntitle: \"Knowing When to Use Override and New Keywords (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"override keyword [C#]\"\n  - \"new keyword [C#]\"\n  - \"polymorphism [C#], using override and new [C#]\"\nms.assetid: 323db184-b136-46fc-8839-007886e7e8b0\ncaps.latest.revision: 16\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Knowing When to Use Override and New Keywords (C# Programming Guide)\nIn C#, a method in a derived class can have the same name as a method in the base class. You can specify how the methods interact by using the [new](../../../csharp/language-reference/keywords/new.md) and [override](../../../csharp/language-reference/keywords/override.md) keywords. The `override` modifier *extends* the base class method, and the `new` modifier *hides* it. The difference is illustrated in the examples in this topic.  \n  \n In a console application, declare the following two classes, `BaseClass` and `DerivedClass`. `DerivedClass` inherits from `BaseClass`.  \n  \n```csharp  \nclass BaseClass  \n{  \n    public void Method1()  \n    {  \n        Console.WriteLine(\"Base - Method1\");  \n    }  \n}  \n  \nclass DerivedClass : BaseClass  \n{  \n    public void Method2()  \n    {  \n        Console.WriteLine(\"Derived - Method2\");  \n    }  \n}  \n  \n```  \n  \n In the `Main` method, declare variables `bc`, `dc`, and `bcdc`.  \n  \n-   `bc` is of type `BaseClass`, and its value is of type `BaseClass`.  \n  \n-   `dc` is of type `DerivedClass`, and its value is of type `DerivedClass`.  \n  \n-   `bcdc` is of type `BaseClass`, and its value is of type `DerivedClass`. This is the variable to pay attention to.  \n  \n Because `bc` and `bcdc` have type `BaseClass`, they can only directly access `Method1`, unless you use casting. Variable `dc` can access both `Method1` and `Method2`. These relationships are shown in the following code.  \n  \n```csharp  \nclass Program  \n{  \n    static void Main(string[] args)  \n    {  \n        BaseClass bc = new BaseClass();  \n        DerivedClass dc = new DerivedClass();  \n        BaseClass bcdc = new DerivedClass();  \n  \n        bc.Method1();  \n        dc.Method1();  \n        dc.Method2();  \n        bcdc.Method1();  \n    }  \n    // Output:  \n    // Base - Method1  \n    // Base - Method1  \n    // Derived - Method2  \n    // Base - Method1  \n}  \n  \n```  \n  \n Next, add the following `Method2` method to `BaseClass`. The signature of this method matches the signature of the `Method2` method in `DerivedClass`.  \n  \n```csharp  \npublic void Method2()  \n{  \n    Console.WriteLine(\"Base - Method2\");  \n}  \n  \n```  \n  \n Because `BaseClass` now has a `Method2` method, a second calling statement can be added for `BaseClass` variables `bc` and `bcdc`, as shown in the following code.  \n  \n```csharp  \nbc.Method1();  \nbc.Method2();  \ndc.Method1();  \ndc.Method2();  \nbcdc.Method1();  \nbcdc.Method2();  \n  \n```  \n  \n When you build the project, you see that the addition of the `Method2` method in `BaseClass` causes a warning. The warning says that the `Method2` method in `DerivedClass` hides the `Method2` method in `BaseClass`. You are advised to use the `new` keyword in the `Method2` definition if you intend to cause that result. Alternatively, you could rename one of the `Method2` methods to resolve the warning, but that is not always practical.  \n  \n Before adding `new`, run the program to see the output produced by the additional calling statements. The following results are displayed.  \n  \n```csharp  \n// Output:  \n// Base - Method1  \n// Base - Method2  \n// Base - Method1  \n// Derived - Method2  \n// Base - Method1  \n// Base - Method2  \n  \n```  \n  \n The `new` keyword preserves the relationships that produce that output, but it suppresses the warning. The variables that have type `BaseClass` continue to access the members of `BaseClass`, and the variable that has type `DerivedClass` continues to access members in `DerivedClass` first, and then to consider members inherited from `BaseClass`.  \n  \n To suppress the warning, add the `new` modifier to the definition of `Method2` in `DerivedClass`, as shown in the following code. The modifier can be added before or after `public`.  \n  \n```csharp  \npublic new void Method2()  \n{  \n    Console.WriteLine(\"Derived - Method2\");  \n}  \n  \n```  \n  \n Run the program again to verify that the output has not changed. Also verify that the warning no longer appears. By using `new`, you are asserting that you are aware that the member that it modifies hides a member that is inherited from the base class. For more information about name hiding through inheritance, see [new Modifier](../../../csharp/language-reference/keywords/new-modifier.md).  \n  \n To contrast this behavior to the effects of using `override`, add the following method to `DerivedClass`. The `override` modifier can be added before or after `public`.  \n  \n```csharp  \npublic override void Method1()  \n{  \n    Console.WriteLine(\"Derived - Method1\");  \n}  \n  \n```  \n  \n Add the `virtual` modifier to the definition of `Method1` in `BaseClass`. The `virtual` modifier can be added before or after `public`.  \n  \n```csharp  \npublic virtual void Method1()  \n{  \n    Console.WriteLine(\"Base - Method1\");  \n}  \n  \n```  \n  \n Run the project again. Notice especially the last two lines of the following output.  \n  \n```csharp  \n// Output:  \n// Base - Method1  \n// Base - Method2  \n// Derived - Method1  \n// Derived - Method2  \n// Derived - Method1  \n// Base - Method2  \n  \n```  \n  \n The use of the `override` modifier enables `bcdc` to access the `Method1` method that is defined in `DerivedClass`. Typically, that is the desired behavior in inheritance hierarchies. You want objects that have values that are created from the derived class to use the methods that are defined in the derived class. You achieve that behavior by using `override` to extend the base class method.  \n  \n The following code contains the full example.  \n  \n```csharp  \nusing System;  \nusing System.Text;  \n  \nnamespace OverrideAndNew  \n{  \n    class Program  \n    {  \n        static void Main(string[] args)  \n        {  \n            BaseClass bc = new BaseClass();  \n            DerivedClass dc = new DerivedClass();  \n            BaseClass bcdc = new DerivedClass();  \n  \n            // The following two calls do what you would expect. They call  \n            // the methods that are defined in BaseClass.  \n            bc.Method1();  \n            bc.Method2();  \n            // Output:  \n            // Base - Method1  \n            // Base - Method2  \n  \n            // The following two calls do what you would expect. They call  \n            // the methods that are defined in DerivedClass.  \n            dc.Method1();  \n            dc.Method2();  \n            // Output:  \n            // Derived - Method1  \n            // Derived - Method2  \n  \n            // The following two calls produce different results, depending   \n            // on whether override (Method1) or new (Method2) is used.  \n            bcdc.Method1();  \n            bcdc.Method2();  \n            // Output:  \n            // Derived - Method1  \n            // Base - Method2  \n        }  \n    }  \n  \n    class BaseClass  \n    {  \n        public virtual void Method1()  \n        {  \n            Console.WriteLine(\"Base - Method1\");  \n        }  \n  \n        public virtual void Method2()  \n        {  \n            Console.WriteLine(\"Base - Method2\");  \n        }  \n    }  \n  \n    class DerivedClass : BaseClass  \n    {  \n        public override void Method1()  \n        {  \n            Console.WriteLine(\"Derived - Method1\");  \n        }  \n  \n        public new void Method2()  \n        {  \n            Console.WriteLine(\"Derived - Method2\");  \n        }  \n    }  \n}  \n  \n```  \n  \n The following example illustrates similar behavior in a different context. The example defines three classes: a base class named `Car` and two classes that are derived from it, `ConvertibleCar` and `Minivan`. The base class contains a `DescribeCar` method. The method displays a basic description of a car, and then calls `ShowDetails` to provide additional information. Each of the three classes defines a `ShowDetails` method. The `new` modifier is used to define `ShowDetails` in the `ConvertibleCar` class. The `override` modifier is used to define `ShowDetails` in the `Minivan` class.  \n  \n```csharp  \n// Define the base class, Car. The class defines two methods,  \n// DescribeCar and ShowDetails. DescribeCar calls ShowDetails, and each derived  \n// class also defines a ShowDetails method. The example tests which version of  \n// ShowDetails is selected, the base class method or the derived class method.  \nclass Car  \n{  \n    public void DescribeCar()  \n    {  \n        System.Console.WriteLine(\"Four wheels and an engine.\");  \n        ShowDetails();  \n    }  \n  \n    public virtual void ShowDetails()  \n    {  \n        System.Console.WriteLine(\"Standard transportation.\");  \n    }  \n}  \n  \n// Define the derived classes.  \n  \n// Class ConvertibleCar uses the new modifier to acknowledge that ShowDetails  \n// hides the base class method.  \nclass ConvertibleCar : Car  \n{  \n    public new void ShowDetails()  \n    {  \n        System.Console.WriteLine(\"A roof that opens up.\");  \n    }  \n}  \n  \n// Class Minivan uses the override modifier to specify that ShowDetails  \n// extends the base class method.  \nclass Minivan : Car  \n{  \n    public override void ShowDetails()  \n    {  \n        System.Console.WriteLine(\"Carries seven people.\");  \n    }  \n}  \n  \n```  \n  \n The example tests which version of `ShowDetails` is called. The following method, `TestCars1`, declares an instance of each class, and then calls `DescribeCar` on each instance.  \n  \n```csharp  \npublic static void TestCars1()  \n{  \n    System.Console.WriteLine(\"\\nTestCars1\");  \n    System.Console.WriteLine(\"----------\");  \n  \n    Car car1 = new Car();  \n    car1.DescribeCar();  \n    System.Console.WriteLine(\"----------\");  \n  \n    // Notice the output from this test case. The new modifier is  \n    // used in the definition of ShowDetails in the ConvertibleCar  \n    // class.    \n  \n    ConvertibleCar car2 = new ConvertibleCar();  \n    car2.DescribeCar();  \n    System.Console.WriteLine(\"----------\");  \n  \n    Minivan car3 = new Minivan();  \n    car3.DescribeCar();  \n    System.Console.WriteLine(\"----------\");  \n}  \n  \n```  \n  \n `TestCars1` produces the following output. Notice especially the results for `car2`, which probably are not what you expected. The type of the object is `ConvertibleCar`, but `DescribeCar` does not access the version of `ShowDetails` that is defined in the `ConvertibleCar` class because that method is declared with the `new` modifier, not the `override` modifier. As a result, a `ConvertibleCar` object displays the same description as a `Car` object. Contrast the results for `car3`, which is a `Minivan` object. In this case, the `ShowDetails` method that is declared in the `Minivan` class overrides the `ShowDetails` method that is declared in the `Car` class, and the description that is displayed describes a minivan.  \n  \n```csharp  \n  \n// TestCars1  \n// ----------  \n// Four wheels and an engine.  \n// Standard transportation.  \n// ----------  \n// Four wheels and an engine.  \n// Standard transportation.  \n// ----------  \n// Four wheels and an engine.  \n// Carries seven people.  \n// ----------  \n  \n```  \n  \n `TestCars2` creates a list of objects that have type `Car`. The values of the objects are instantiated from the `Car`, `ConvertibleCar`, and `Minivan` classes. `DescribeCar` is called on each element of the list. The following code shows the definition of `TestCars2`.  \n  \n```csharp  \npublic static void TestCars2()  \n{  \n    System.Console.WriteLine(\"\\nTestCars2\");  \n    System.Console.WriteLine(\"----------\");  \n  \n    var cars = new List<Car> { new Car(), new ConvertibleCar(),   \n        new Minivan() };  \n  \n    foreach (var car in cars)  \n    {  \n        car.DescribeCar();  \n        System.Console.WriteLine(\"----------\");  \n    }  \n}  \n  \n```  \n  \n The following output is displayed. Notice that it is the same as the output that is displayed by `TestCars1`. The `ShowDetails` method of the `ConvertibleCar` class is not called, regardless of whether the type of the object is `ConvertibleCar`, as in `TestCars1`, or `Car`, as in `TestCars2`. Conversely, `car3` calls the `ShowDetails` method from the `Minivan` class in both cases, whether it has type `Minivan` or type `Car`.  \n  \n```csharp  \n// TestCars2  \n// ----------  \n// Four wheels and an engine.  \n// Standard transportation.  \n// ----------  \n// Four wheels and an engine.  \n// Standard transportation.  \n// ----------  \n// Four wheels and an engine.  \n// Carries seven people.  \n// ----------  \n  \n```  \n  \n Methods `TestCars3` and `TestCars4` complete the example. These methods call `ShowDetails` directly, first from objects declared to have type `ConvertibleCar` and `Minivan` (`TestCars3`), then from objects declared to have type `Car` (`TestCars4`). The following code defines these two methods.  \n  \n```csharp  \n  \npublic static void TestCars3()  \n{  \n    System.Console.WriteLine(\"\\nTestCars3\");  \n    System.Console.WriteLine(\"----------\");  \n    ConvertibleCar car2 = new ConvertibleCar();  \n    Minivan car3 = new Minivan();  \n    car2.ShowDetails();  \n    car3.ShowDetails();  \n}  \n  \npublic static void TestCars4()  \n{  \n    System.Console.WriteLine(\"\\nTestCars4\");  \n    System.Console.WriteLine(\"----------\");  \n    Car car2 = new ConvertibleCar();  \n    Car car3 = new Minivan();  \n    car2.ShowDetails();  \n    car3.ShowDetails();  \n}  \n  \n```  \n  \n The methods produce the following output, which corresponds to the results from the first example in this topic.  \n  \n```csharp  \n// TestCars3  \n// ----------  \n// A roof that opens up.  \n// Carries seven people.  \n  \n// TestCars4  \n// ----------  \n// Standard transportation.  \n// Carries seven people.  \n  \n```  \n  \n The following code shows the complete project and its output.  \n  \n```csharp  \nusing System;  \nusing System.Collections.Generic;  \nusing System.Linq;  \nusing System.Text;  \n  \nnamespace OverrideAndNew2  \n{  \n    class Program  \n    {  \n        static void Main(string[] args)  \n        {  \n            // Declare objects of the derived classes and test which version  \n            // of ShowDetails is run, base or derived.  \n            TestCars1();  \n  \n            // Declare objects of the base class, instantiated with the  \n            // derived classes, and repeat the tests.  \n            TestCars2();  \n  \n            // Declare objects of the derived classes and call ShowDetails  \n            // directly.  \n            TestCars3();  \n  \n            // Declare objects of the base class, instantiated with the  \n            // derived classes, and repeat the tests.  \n            TestCars4();  \n        }  \n  \n        public static void TestCars1()  \n        {  \n            System.Console.WriteLine(\"\\nTestCars1\");  \n            System.Console.WriteLine(\"----------\");  \n  \n            Car car1 = new Car();  \n            car1.DescribeCar();  \n            System.Console.WriteLine(\"----------\");  \n  \n            // Notice the output from this test case. The new modifier is  \n            // used in the definition of ShowDetails in the ConvertibleCar  \n            // class.    \n            ConvertibleCar car2 = new ConvertibleCar();  \n            car2.DescribeCar();  \n            System.Console.WriteLine(\"----------\");  \n  \n            Minivan car3 = new Minivan();  \n            car3.DescribeCar();  \n            System.Console.WriteLine(\"----------\");  \n        }  \n        // Output:  \n        // TestCars1  \n        // ----------  \n        // Four wheels and an engine.  \n        // Standard transportation.  \n        // ----------  \n        // Four wheels and an engine.  \n        // Standard transportation.  \n        // ----------  \n        // Four wheels and an engine.  \n        // Carries seven people.  \n        // ----------  \n  \n        public static void TestCars2()  \n        {  \n            System.Console.WriteLine(\"\\nTestCars2\");  \n            System.Console.WriteLine(\"----------\");  \n  \n            var cars = new List<Car> { new Car(), new ConvertibleCar(),   \n                new Minivan() };  \n  \n            foreach (var car in cars)  \n            {  \n                car.DescribeCar();  \n                System.Console.WriteLine(\"----------\");  \n            }  \n        }  \n        // Output:  \n        // TestCars2  \n        // ----------  \n        // Four wheels and an engine.  \n        // Standard transportation.  \n        // ----------  \n        // Four wheels and an engine.  \n        // Standard transportation.  \n        // ----------  \n        // Four wheels and an engine.  \n        // Carries seven people.  \n        // ----------  \n  \n        public static void TestCars3()  \n        {  \n            System.Console.WriteLine(\"\\nTestCars3\");  \n            System.Console.WriteLine(\"----------\");  \n            ConvertibleCar car2 = new ConvertibleCar();  \n            Minivan car3 = new Minivan();  \n            car2.ShowDetails();  \n            car3.ShowDetails();  \n        }  \n        // Output:  \n        // TestCars3  \n        // ----------  \n        // A roof that opens up.  \n        // Carries seven people.  \n  \n        public static void TestCars4()  \n        {  \n            System.Console.WriteLine(\"\\nTestCars4\");  \n            System.Console.WriteLine(\"----------\");  \n            Car car2 = new ConvertibleCar();  \n            Car car3 = new Minivan();  \n            car2.ShowDetails();  \n            car3.ShowDetails();  \n        }  \n        // Output:  \n        // TestCars4  \n        // ----------  \n        // Standard transportation.  \n        // Carries seven people.  \n    }  \n  \n    // Define the base class, Car. The class defines two virtual methods,  \n    // DescribeCar and ShowDetails. DescribeCar calls ShowDetails, and each derived  \n    // class also defines a ShowDetails method. The example tests which version of  \n    // ShowDetails is used, the base class method or the derived class method.  \n    class Car  \n    {  \n        public virtual void DescribeCar()  \n        {  \n            System.Console.WriteLine(\"Four wheels and an engine.\");  \n            ShowDetails();  \n        }  \n  \n        public virtual void ShowDetails()  \n        {  \n            System.Console.WriteLine(\"Standard transportation.\");  \n        }  \n    }  \n  \n    // Define the derived classes.  \n  \n    // Class ConvertibleCar uses the new modifier to acknowledge that ShowDetails  \n    // hides the base class method.  \n    class ConvertibleCar : Car  \n    {  \n        public new void ShowDetails()  \n        {  \n            System.Console.WriteLine(\"A roof that opens up.\");  \n        }  \n    }  \n  \n    // Class Minivan uses the override modifier to specify that ShowDetails  \n    // extends the base class method.  \n    class Minivan : Car  \n    {  \n        public override void ShowDetails()  \n        {  \n            System.Console.WriteLine(\"Carries seven people.\");  \n        }  \n    }  \n  \n}  \n  \n```  \n  \n## See Also  \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)   \n [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)   \n [base](../../../csharp/language-reference/keywords/base.md)   \n [abstract](../../../csharp/language-reference/keywords/abstract.md)","nodes":[{"pos":[4,644],"nodes":[{"content":"Knowing When to Use Override and New Keywords (C# Programming Guide) | Microsoft Docs","nodes":[{"pos":[0,85],"content":"Knowing When to Use Override and New Keywords (C# Programming Guide) | Microsoft Docs","nodes":[{"content":"Knowing When to Use Override and New Keywords (C# Programming Guide) | Microsoft Docs","pos":[0,85]}]}],"pos":[6,94],"yaml":true}],"content":"title: \"Knowing When to Use Override and New Keywords (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"override keyword [C#]\"\n  - \"new keyword [C#]\"\n  - \"polymorphism [C#], using override and new [C#]\"\nms.assetid: 323db184-b136-46fc-8839-007886e7e8b0\ncaps.latest.revision: 16\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","yamlblock":true},{"pos":[651,719],"content":"Knowing When to Use Override and New Keywords (C# Programming Guide)","linkify":"Knowing When to Use Override and New Keywords (C# Programming Guide)","nodes":[{"content":"Knowing When to Use Override and New Keywords (C# Programming Guide)","pos":[0,68]}]},{"content":"In C#, a method in a derived class can have the same name as a method in the base class.","pos":[720,808]},{"content":"You can specify how the methods interact by using the <bpt id=\"p1\">[</bpt>new<ept id=\"p1\">](../../../csharp/language-reference/keywords/new.md)</ept> and <bpt id=\"p2\">[</bpt>override<ept id=\"p2\">](../../../csharp/language-reference/keywords/override.md)</ept> keywords.","pos":[809,1002],"source":" You can specify how the methods interact by using the [new](../../../csharp/language-reference/keywords/new.md) and [override](../../../csharp/language-reference/keywords/override.md) keywords."},{"content":"The <ph id=\"ph1\">`override`</ph> modifier <bpt id=\"p1\">*</bpt>extends<ept id=\"p1\">*</ept> the base class method, and the <ph id=\"ph2\">`new`</ph> modifier <bpt id=\"p2\">*</bpt>hides<ept id=\"p2\">*</ept> it.","pos":[1003,1094],"source":" The `override` modifier *extends* the base class method, and the `new` modifier *hides* it."},{"content":"The difference is illustrated in the examples in this topic.","pos":[1095,1155]},{"content":"In a console application, declare the following two classes, <ph id=\"ph1\">`BaseClass`</ph> and <ph id=\"ph2\">`DerivedClass`</ph>.","pos":[1162,1254],"source":"In a console application, declare the following two classes, `BaseClass` and `DerivedClass`."},{"content":"<ph id=\"ph1\">`DerivedClass`</ph> inherits from <ph id=\"ph2\">`BaseClass`</ph>.","pos":[1255,1296],"source":"`DerivedClass` inherits from `BaseClass`."},{"pos":[1582,1645],"content":"In the <ph id=\"ph1\">`Main`</ph> method, declare variables <ph id=\"ph2\">`bc`</ph>, <ph id=\"ph3\">`dc`</ph>, and <ph id=\"ph4\">`bcdc`</ph>.","source":"In the `Main` method, declare variables `bc`, `dc`, and `bcdc`."},{"pos":[1655,1721],"content":"<ph id=\"ph1\">`bc`</ph> is of type <ph id=\"ph2\">`BaseClass`</ph>, and its value is of type <ph id=\"ph3\">`BaseClass`</ph>.","source":"`bc` is of type `BaseClass`, and its value is of type `BaseClass`."},{"pos":[1731,1803],"content":"<ph id=\"ph1\">`dc`</ph> is of type <ph id=\"ph2\">`DerivedClass`</ph>, and its value is of type <ph id=\"ph3\">`DerivedClass`</ph>.","source":"`dc` is of type `DerivedClass`, and its value is of type `DerivedClass`."},{"content":"<ph id=\"ph1\">`bcdc`</ph> is of type <ph id=\"ph2\">`BaseClass`</ph>, and its value is of type <ph id=\"ph3\">`DerivedClass`</ph>.","pos":[1813,1884],"source":"`bcdc` is of type `BaseClass`, and its value is of type `DerivedClass`."},{"content":"This is the variable to pay attention to.","pos":[1885,1926]},{"content":"Because <ph id=\"ph1\">`bc`</ph> and <ph id=\"ph2\">`bcdc`</ph> have type <ph id=\"ph3\">`BaseClass`</ph>, they can only directly access <ph id=\"ph4\">`Method1`</ph>, unless you use casting.","pos":[1933,2044],"source":"Because `bc` and `bcdc` have type `BaseClass`, they can only directly access `Method1`, unless you use casting."},{"content":"Variable <ph id=\"ph1\">`dc`</ph> can access both <ph id=\"ph2\">`Method1`</ph> and <ph id=\"ph3\">`Method2`</ph>.","pos":[2045,2099],"source":" Variable `dc` can access both `Method1` and `Method2`."},{"content":"These relationships are shown in the following code.","pos":[2100,2152]},{"content":"Next, add the following <ph id=\"ph1\">`Method2`</ph> method to <ph id=\"ph2\">`BaseClass`</ph>.","pos":[2615,2671],"source":"Next, add the following `Method2` method to `BaseClass`."},{"content":"The signature of this method matches the signature of the <ph id=\"ph1\">`Method2`</ph> method in <ph id=\"ph2\">`DerivedClass`</ph>.","pos":[2672,2765],"source":" The signature of this method matches the signature of the `Method2` method in `DerivedClass`."},{"pos":[2871,3033],"content":"Because <ph id=\"ph1\">`BaseClass`</ph> now has a <ph id=\"ph2\">`Method2`</ph> method, a second calling statement can be added for <ph id=\"ph3\">`BaseClass`</ph> variables <ph id=\"ph4\">`bc`</ph> and <ph id=\"ph5\">`bcdc`</ph>, as shown in the following code.","source":"Because `BaseClass` now has a `Method2` method, a second calling statement can be added for `BaseClass` variables `bc` and `bcdc`, as shown in the following code."},{"content":"When you build the project, you see that the addition of the <ph id=\"ph1\">`Method2`</ph> method in <ph id=\"ph2\">`BaseClass`</ph> causes a warning.","pos":[3164,3274],"source":"When you build the project, you see that the addition of the `Method2` method in `BaseClass` causes a warning."},{"content":"The warning says that the <ph id=\"ph1\">`Method2`</ph> method in <ph id=\"ph2\">`DerivedClass`</ph> hides the <ph id=\"ph3\">`Method2`</ph> method in <ph id=\"ph4\">`BaseClass`</ph>.","pos":[3275,3378],"source":" The warning says that the `Method2` method in `DerivedClass` hides the `Method2` method in `BaseClass`."},{"content":"You are advised to use the <ph id=\"ph1\">`new`</ph> keyword in the <ph id=\"ph2\">`Method2`</ph> definition if you intend to cause that result.","pos":[3379,3483],"source":" You are advised to use the `new` keyword in the `Method2` definition if you intend to cause that result."},{"content":"Alternatively, you could rename one of the <ph id=\"ph1\">`Method2`</ph> methods to resolve the warning, but that is not always practical.","pos":[3484,3602],"source":" Alternatively, you could rename one of the `Method2` methods to resolve the warning, but that is not always practical."},{"content":"Before adding <ph id=\"ph1\">`new`</ph>, run the program to see the output produced by the additional calling statements.","pos":[3609,3710],"source":"Before adding `new`, run the program to see the output produced by the additional calling statements."},{"content":"The following results are displayed.","pos":[3711,3747]},{"content":"The <ph id=\"ph1\">`new`</ph> keyword preserves the relationships that produce that output, but it suppresses the warning.","pos":[3914,4016],"source":"The `new` keyword preserves the relationships that produce that output, but it suppresses the warning."},{"content":"The variables that have type <ph id=\"ph1\">`BaseClass`</ph> continue to access the members of <ph id=\"ph2\">`BaseClass`</ph>, and the variable that has type <ph id=\"ph3\">`DerivedClass`</ph> continues to access members in <ph id=\"ph4\">`DerivedClass`</ph> first, and then to consider members inherited from <ph id=\"ph5\">`BaseClass`</ph>.","pos":[4017,4260],"source":" The variables that have type `BaseClass` continue to access the members of `BaseClass`, and the variable that has type `DerivedClass` continues to access members in `DerivedClass` first, and then to consider members inherited from `BaseClass`."},{"content":"To suppress the warning, add the <ph id=\"ph1\">`new`</ph> modifier to the definition of <ph id=\"ph2\">`Method2`</ph> in <ph id=\"ph3\">`DerivedClass`</ph>, as shown in the following code.","pos":[4267,4396],"source":"To suppress the warning, add the `new` modifier to the definition of `Method2` in `DerivedClass`, as shown in the following code."},{"content":"The modifier can be added before or after <ph id=\"ph1\">`public`</ph>.","pos":[4397,4448],"source":" The modifier can be added before or after `public`."},{"content":"Run the program again to verify that the output has not changed.","pos":[4561,4625]},{"content":"Also verify that the warning no longer appears.","pos":[4626,4673]},{"content":"By using <ph id=\"ph1\">`new`</ph>, you are asserting that you are aware that the member that it modifies hides a member that is inherited from the base class.","pos":[4674,4813],"source":" By using `new`, you are asserting that you are aware that the member that it modifies hides a member that is inherited from the base class."},{"content":"For more information about name hiding through inheritance, see <bpt id=\"p1\">[</bpt>new Modifier<ept id=\"p1\">](../../../csharp/language-reference/keywords/new-modifier.md)</ept>.","pos":[4814,4954],"source":" For more information about name hiding through inheritance, see [new Modifier](../../../csharp/language-reference/keywords/new-modifier.md)."},{"content":"To contrast this behavior to the effects of using <ph id=\"ph1\">`override`</ph>, add the following method to <ph id=\"ph2\">`DerivedClass`</ph>.","pos":[4961,5066],"source":"To contrast this behavior to the effects of using `override`, add the following method to `DerivedClass`."},{"content":"The <ph id=\"ph1\">`override`</ph> modifier can be added before or after <ph id=\"ph2\">`public`</ph>.","pos":[5067,5129],"source":" The `override` modifier can be added before or after `public`."},{"content":"Add the <ph id=\"ph1\">`virtual`</ph> modifier to the definition of <ph id=\"ph2\">`Method1`</ph> in <ph id=\"ph3\">`BaseClass`</ph>.","pos":[5247,5320],"source":"Add the `virtual` modifier to the definition of `Method1` in `BaseClass`."},{"content":"The <ph id=\"ph1\">`virtual`</ph> modifier can be added before or after <ph id=\"ph2\">`public`</ph>.","pos":[5321,5382],"source":" The `virtual` modifier can be added before or after `public`."},{"content":"Run the project again.","pos":[5496,5518]},{"content":"Notice especially the last two lines of the following output.","pos":[5519,5580]},{"content":"The use of the <ph id=\"ph1\">`override`</ph> modifier enables <ph id=\"ph2\">`bcdc`</ph> to access the <ph id=\"ph3\">`Method1`</ph> method that is defined in <ph id=\"ph4\">`DerivedClass`</ph>.","pos":[5753,5868],"source":"The use of the `override` modifier enables `bcdc` to access the `Method1` method that is defined in `DerivedClass`."},{"content":"Typically, that is the desired behavior in inheritance hierarchies.","pos":[5869,5936]},{"content":"You want objects that have values that are created from the derived class to use the methods that are defined in the derived class.","pos":[5937,6068]},{"content":"You achieve that behavior by using <ph id=\"ph1\">`override`</ph> to extend the base class method.","pos":[6069,6147],"source":" You achieve that behavior by using `override` to extend the base class method."},{"content":"The following code contains the full example.","pos":[6154,6199]},{"content":"The following example illustrates similar behavior in a different context.","pos":[8008,8082]},{"content":"The example defines three classes: a base class named <ph id=\"ph1\">`Car`</ph> and two classes that are derived from it, <ph id=\"ph2\">`ConvertibleCar`</ph> and <ph id=\"ph3\">`Minivan`</ph>.","pos":[8083,8216],"source":" The example defines three classes: a base class named `Car` and two classes that are derived from it, `ConvertibleCar` and `Minivan`."},{"content":"The base class contains a <ph id=\"ph1\">`DescribeCar`</ph> method.","pos":[8217,8264],"source":" The base class contains a `DescribeCar` method."},{"content":"The method displays a basic description of a car, and then calls <ph id=\"ph1\">`ShowDetails`</ph> to provide additional information.","pos":[8265,8378],"source":" The method displays a basic description of a car, and then calls `ShowDetails` to provide additional information."},{"content":"Each of the three classes defines a <ph id=\"ph1\">`ShowDetails`</ph> method.","pos":[8379,8436],"source":" Each of the three classes defines a `ShowDetails` method."},{"content":"The <ph id=\"ph1\">`new`</ph> modifier is used to define <ph id=\"ph2\">`ShowDetails`</ph> in the <ph id=\"ph3\">`ConvertibleCar`</ph> class.","pos":[8437,8518],"source":" The `new` modifier is used to define `ShowDetails` in the `ConvertibleCar` class."},{"content":"The <ph id=\"ph1\">`override`</ph> modifier is used to define <ph id=\"ph2\">`ShowDetails`</ph> in the <ph id=\"ph3\">`Minivan`</ph> class.","pos":[8519,8598],"source":" The `override` modifier is used to define `ShowDetails` in the `Minivan` class."},{"content":"The example tests which version of <ph id=\"ph1\">`ShowDetails`</ph> is called.","pos":[9783,9842],"source":"The example tests which version of `ShowDetails` is called."},{"content":"The following method, <ph id=\"ph1\">`TestCars1`</ph>, declares an instance of each class, and then calls <ph id=\"ph2\">`DescribeCar`</ph> on each instance.","pos":[9843,9960],"source":" The following method, `TestCars1`, declares an instance of each class, and then calls `DescribeCar` on each instance."},{"content":"<ph id=\"ph1\">`TestCars1`</ph> produces the following output.","pos":[10622,10664],"source":"`TestCars1` produces the following output."},{"content":"Notice especially the results for <ph id=\"ph1\">`car2`</ph>, which probably are not what you expected.","pos":[10665,10748],"source":" Notice especially the results for `car2`, which probably are not what you expected."},{"content":"The type of the object is <ph id=\"ph1\">`ConvertibleCar`</ph>, but <ph id=\"ph2\">`DescribeCar`</ph> does not access the version of <ph id=\"ph3\">`ShowDetails`</ph> that is defined in the <ph id=\"ph4\">`ConvertibleCar`</ph> class because that method is declared with the <ph id=\"ph5\">`new`</ph> modifier, not the <ph id=\"ph6\">`override`</ph> modifier.","pos":[10749,10987],"source":" The type of the object is `ConvertibleCar`, but `DescribeCar` does not access the version of `ShowDetails` that is defined in the `ConvertibleCar` class because that method is declared with the `new` modifier, not the `override` modifier."},{"content":"As a result, a <ph id=\"ph1\">`ConvertibleCar`</ph> object displays the same description as a <ph id=\"ph2\">`Car`</ph> object.","pos":[10988,11075],"source":" As a result, a `ConvertibleCar` object displays the same description as a `Car` object."},{"content":"Contrast the results for <ph id=\"ph1\">`car3`</ph>, which is a <ph id=\"ph2\">`Minivan`</ph> object.","pos":[11076,11137],"source":" Contrast the results for `car3`, which is a `Minivan` object."},{"content":"In this case, the <ph id=\"ph1\">`ShowDetails`</ph> method that is declared in the <ph id=\"ph2\">`Minivan`</ph> class overrides the <ph id=\"ph3\">`ShowDetails`</ph> method that is declared in the <ph id=\"ph4\">`Car`</ph> class, and the description that is displayed describes a minivan.","pos":[11138,11347],"source":" In this case, the `ShowDetails` method that is declared in the `Minivan` class overrides the `ShowDetails` method that is declared in the `Car` class, and the description that is displayed describes a minivan."},{"content":"<ph id=\"ph1\">`TestCars2`</ph> creates a list of objects that have type <ph id=\"ph2\">`Car`</ph>.","pos":[11643,11702],"source":"`TestCars2` creates a list of objects that have type `Car`."},{"content":"The values of the objects are instantiated from the <ph id=\"ph1\">`Car`</ph>, <ph id=\"ph2\">`ConvertibleCar`</ph>, and <ph id=\"ph3\">`Minivan`</ph> classes.","pos":[11703,11802],"source":" The values of the objects are instantiated from the `Car`, `ConvertibleCar`, and `Minivan` classes."},{"content":"<ph id=\"ph1\">`DescribeCar`</ph> is called on each element of the list.","pos":[11803,11855],"source":"`DescribeCar` is called on each element of the list."},{"content":"The following code shows the definition of <ph id=\"ph1\">`TestCars2`</ph>.","pos":[11856,11911],"source":" The following code shows the definition of `TestCars2`."},{"content":"The following output is displayed.","pos":[12303,12337]},{"content":"Notice that it is the same as the output that is displayed by <ph id=\"ph1\">`TestCars1`</ph>.","pos":[12338,12412],"source":" Notice that it is the same as the output that is displayed by `TestCars1`."},{"content":"The <ph id=\"ph1\">`ShowDetails`</ph> method of the <ph id=\"ph2\">`ConvertibleCar`</ph> class is not called, regardless of whether the type of the object is <ph id=\"ph3\">`ConvertibleCar`</ph>, as in <ph id=\"ph4\">`TestCars1`</ph>, or <ph id=\"ph5\">`Car`</ph>, as in <ph id=\"ph6\">`TestCars2`</ph>.","pos":[12413,12596],"source":" The `ShowDetails` method of the `ConvertibleCar` class is not called, regardless of whether the type of the object is `ConvertibleCar`, as in `TestCars1`, or `Car`, as in `TestCars2`."},{"content":"Conversely, <ph id=\"ph1\">`car3`</ph> calls the <ph id=\"ph2\">`ShowDetails`</ph> method from the <ph id=\"ph3\">`Minivan`</ph> class in both cases, whether it has type <ph id=\"ph4\">`Minivan`</ph> or type <ph id=\"ph5\">`Car`</ph>.","pos":[12597,12731],"source":" Conversely, `car3` calls the `ShowDetails` method from the `Minivan` class in both cases, whether it has type `Minivan` or type `Car`."},{"content":"Methods <ph id=\"ph1\">`TestCars3`</ph> and <ph id=\"ph2\">`TestCars4`</ph> complete the example.","pos":[13024,13081],"source":"Methods `TestCars3` and `TestCars4` complete the example."},{"content":"These methods call <ph id=\"ph1\">`ShowDetails`</ph> directly, first from objects declared to have type <ph id=\"ph2\">`ConvertibleCar`</ph> and <ph id=\"ph3\">`Minivan`</ph> (<ph id=\"ph4\">`TestCars3`</ph>), then from objects declared to have type <ph id=\"ph5\">`Car`</ph> (<ph id=\"ph6\">`TestCars4`</ph>).","pos":[13082,13272],"source":" These methods call `ShowDetails` directly, first from objects declared to have type `ConvertibleCar` and `Minivan` (`TestCars3`), then from objects declared to have type `Car` (`TestCars4`)."},{"content":"The following code defines these two methods.","pos":[13273,13318]},{"content":"The methods produce the following output, which corresponds to the results from the first example in this topic.","pos":[13884,13996]},{"content":"The following code shows the complete project and its output.","pos":[14203,14264]},{"pos":[19388,19396],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[19400,19467],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[19471,19557],"source":"[Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Versioning with the Override and New Keywords<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)</ept><ph id=\"ph1\"> </ph>","pos":[19561,19713],"source":"[Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md) "},{"content":"<bpt id=\"p1\">[</bpt>base<ept id=\"p1\">](../../../csharp/language-reference/keywords/base.md)</ept><ph id=\"ph1\"> </ph>","pos":[19717,19777],"source":"[base](../../../csharp/language-reference/keywords/base.md) "},{"content":"<bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../../../csharp/language-reference/keywords/abstract.md)</ept>","pos":[19781,19848],"source":"[abstract](../../../csharp/language-reference/keywords/abstract.md)"}]}