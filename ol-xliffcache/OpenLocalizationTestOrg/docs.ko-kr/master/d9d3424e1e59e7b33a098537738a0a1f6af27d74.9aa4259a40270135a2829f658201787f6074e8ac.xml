{"content":"---\ntitle: Tuple types - C# Guide\ndescription: Learn about unnamed and named tuple types in C#\nms.date: 05/15/2018\nms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa\n---\n# C# tuple types\n\nC# tuples are types that you define using a lightweight syntax. The advantages\ninclude a simpler syntax, rules for conversions based on number (referred to as cardinality)\nand types of elements, and\nconsistent rules for copies, equality tests, and assignments. As a tradeoff, tuples do not\nsupport some of the object-oriented idioms associated with inheritance. You\ncan get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.\n\nIn this article, you'll learn the language rules governing tuples in C# 7.0 and later versions,\ndifferent ways to use them, and initial guidance on working with tuples.\n\n> [!NOTE]\n> The new tuples features require the <xref:System.ValueTuple> types.\n> You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it\n> on platforms that do not include the types.\n>\n> This is similar to other language features that rely on types\n> delivered in the framework. Examples include `async` and `await`\n> relying on the `INotifyCompletion` interface, and LINQ relying\n> on `IEnumerable<T>`. However, the delivery mechanism is changing\n> as .NET is becoming more platform independent. The .NET Framework\n> may not always ship on the same cadence as the language compiler. When new language\n> features rely on new types, those types will be available as NuGet packages when\n> the language features ship. As these new types get added to the .NET Standard\n> API and delivered as part of the framework, the NuGet package requirement will\n> be removed.\n\nLet's start with the reasons for adding new tuple support. Methods return\na single object. Tuples enable you to package multiple values in that single\nobject more easily.\n\nThe .NET Framework already has generic `Tuple` classes. These classes,\nhowever, had two major limitations. For one, the `Tuple` classes named\ntheir properties `Item1`, `Item2`, and so on. Those names carry no semantic\ninformation. Using these `Tuple` types does not enable communicating the\nmeaning of each of the properties. The new language features enable you to declare\nand use semantically meaningful names for the elements in a tuple.\n\nThe `Tuple` classes cause more performance concerns because they are\nreference types. Using one of the `Tuple` types means allocating objects. On hot\npaths, allocating many small objects can have a measurable impact on your application's performance. Therefore,\nthe language support for tuples leverages the new `ValueTuple` structs.\n\nTo avoid those deficiencies, you could create a `class` or a `struct`\nto carry multiple elements. Unfortunately, that's more work for you,\nand it obscures your design intent. Making a `struct` or `class` implies\nthat you are defining a type with both data and behavior. Many times, you\nsimply want to store multiple values in a single object.\n\nThe language features and the `ValueTuple` generic structs enforce the rule that\nyou cannot add any behavior (methods) to these tuple types.\nAll the `ValueTuple` types are *mutable structs*. Each member field is a\npublic field. That makes them very lightweight. However, that means tuples\nshould not be used where immutability is important.\n\nTuples are both simpler and more flexible data containers than `class` and\n`struct` types. Let's explore those differences.\n\n## Named and unnamed tuples\n\nThe `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on,\nsimilar to the properties defined in the existing `Tuple` types.\nThese names are the only names you can use for *unnamed tuples*. When you\ndo not provide any alternative field names to a tuple, you've created an\nunnamed tuple:\n\n[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple \"Unnamed tuple\")]\n\nThe tuple in the previous example was initialized using literal constants and\nwon't have element names created using *tuple field name projections* in C# 7.1.\n\nHowever, when you initialize a tuple, you can use new language features\nthat give better names to each field. Doing so creates a *named tuple*.\nNamed tuples still have elements named `Item1`, `Item2`, `Item3` and so on.\nBut they also have synonyms for any of those elements that you have named.\nYou create a named tuple by specifying the names for each element. One way\nis to specify the names as part of the tuple initialization:\n\n[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple \"Named tuple\")]\n\nThese synonyms are handled by the compiler and the language so that you\ncan use named tuples effectively. IDEs and editors can read these semantic names\nusing the Roslyn APIs. You can reference the elements of a named\ntuple by those semantic names anywhere in the same assembly. The compiler\nreplaces the names you've defined with `Item*` equivalents when generating\nthe compiled output. The compiled Microsoft Intermediate Language (MSIL)\ndoes not include the names you've given these elements.\n\nBeginning with C# 7.1, the field names for a tuple may be provided from the\nvariables used to initialize the tuple. This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**. The following code creates a tuple named\n`accumulation` with elements `count` (an integer), and `sum` (a double).\n\n[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectedTupleNames \"Named tuple\")]\n\nThe compiler must communicate those names you created for tuples that\nare returned from public methods or properties. In those cases, the compiler\nadds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method. This attribute contains\na <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of\nthe elements in the tuple.\n\n> [!NOTE]\n> Development Tools, such as Visual Studio, also read that metadata,\n> and provide IntelliSense and other features using the metadata\n> field names.\n\nIt is important to understand these underlying fundamentals of\nthe new tuples and the `ValueTuple` type in order to understand\nthe rules for assigning named tuples to each other.\n\n## Tuple projection initializers\n\nIn general, tuple projection initializers work by using the variable or\nfield names from the right-hand side of a tuple initialization statement.\nIf an explicit name is given, that takes precedence over any projected\nname. For example, in the following initializer, the elements are `explicitFieldOne`\nand `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:\n\n[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionExample_Explicit \"Explicitly named tuple\")]\n\nFor any field where an explicit name is not provided, an applicable implicit\nname is projected. There is no requirement to provide semantic names,\neither explicitly or implicitly. The following initializer has     field\nnames `Item1`, whose value is `42` and `stringContent`, whose value is \"The answer to everything\":\n\n[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#MixedTuple \"mixed tuple\")]\n\nThere are two conditions where candidate field names are not projected onto the tuple field:\n\n1. When the candidate name is a reserved tuple name. Examples include `Item3`, `ToString`. or `Rest`.\n1. When the candidate name is a duplicate of another tuple field name, either explicit or implicit.\n\nThese conditions avoid ambiguity. These names would cause an ambiguity\nif they were used as the field names for a field in a tuple. Neither of these\nconditions cause compile-time errors. Instead, the elements without projected names\ndo not have semantic names projected for them.  The following examples\ndemonstrate these conditions:\n\n[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionAmbiguities \"tuples where projections are not performed\")]\n\nThese situations do not cause compiler errors because that would be a breaking change for\ncode written with C# 7.0, when tuple field name projections were not available.\n\n## Equality and tuples\n\nBeginning with C# 7.3, tuple types support the `==` and `!=` operators. These operators work by comparing each member of the left argument to each member of the right argument in order. These comparisons short-circuit. They will stop evaluating members as soon as one pair is not equal. The following code examples use `==`, but the comparison rules all apply to `!=`. The following code example shows an equality comparison for two pairs of integers:\n\n[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#Equality \"Testing tuples for equality\")]\n\nThere are several rules that make tuple equality tests more convenient. Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:\n\n[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#NullableEquality \"Comparing Tuples and nullable tuples\")]\n\nTuple equality also performs implicit conversions on each member of both tuples. These include lifted conversions, widening conversions, or other implicit conversions. The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:\n\n[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberConversions \"converting tuples for equality tests\")]\n\nThe names of the tuple members do not participate in tests for equality. However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.\nIn the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:\n\n[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberNames \"Tuple member names do not participate in equality tests\")]\n\nFinally, tuples may contain nested tuples. Tuple equality compares the \"shape\" of each operand through nested tuples as shown in the following example:\n\n[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetNestedTuples \"Tuples may contain nested tuples that participate in tuple equality.\")]\n\nIt's a compile time error to compare two tuples for equality (or inequality) when they have different shapes. The compiler won' attempt any deconstruction of nested tuples in order to compare them.\n\n## Assignment and tuples\n\nThe language supports assignment between tuple types that have\nthe same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element. Other\nconversions aren't considered for assignments. It's a compile time error to assign one tuple to another when they have different shapes. The compiler won't attempt any deconstruction of nested tuples in order to assign them.\nLet's look at the kinds\nof assignments that are allowed between tuple types.\n\nConsider these variables used in the following examples:\n\n[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation \"Variable creation\")]\n\nThe first two variables, `unnamed` and `anonymous` do not have semantic\nnames provided for the elements. The field names are `Item1` and `Item2`.\nThe last two variables, `named` and `differentName` have semantic names\ngiven for the elements. These two tuples have different names\nfor the elements.\n\nAll four of these tuples have the same number of elements (referred to as 'cardinality')\nand the types of those elements are identical. Therefore, all of these\nassignments work:\n\n[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment \"Variable assignment\")]\n\nNotice that the names of the tuples are not assigned. The values of the\nelements are assigned following the order of the elements in the tuple.\n\nTuples of different types or numbers of elements are not assignable:\n\n```csharp\n// Does not compile.\n// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)\nvar differentShape = (1, 2, 3);\nnamed = differentShape;\n```\n\n## Tuples as method return values\n\nOne of the most common uses for tuples is as a method return\nvalue. Let's walk through one example. Consider this method\nthat computes the standard deviation for a sequence of numbers:\n\n[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation \"Compute Standard Deviation\")]\n\n> [!NOTE]\n> These examples compute the uncorrected sample standard deviation.\n> The corrected sample standard deviation formula would divide\n> the sum of the squared differences from the mean by (N-1) instead\n> of N, as the `Average` extension method does. Consult a statistics\n> text for more details on the differences between these formulas\n> for standard deviation.\n\nThe preceding code follows the textbook formula for the standard deviation. It produces\nthe correct answer, but it's an inefficient implementation. This\nmethod enumerates the sequence twice: Once to produce the average, and\nonce to produce the average of the square of the difference of the average.\n(Remember that LINQ queries are evaluated lazily, so the computation of\nthe differences from the mean and the average of those differences makes\nonly one enumeration.)\n\nThere is an alternative formula that computes standard deviation using\nonly one enumeration of the sequence.  This computation produces two\nvalues as it enumerates the sequence: the sum of all items in the sequence,\nand the sum of the each value squared:\n\n[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula \"Compute Standard Deviation using the sum of squares\")]\n\nThis version enumerates the sequence exactly once. But it's not reusable code. As you keep working, you'll find that many different\nstatistical computations use the number of items in the sequence,\nthe sum of the sequence, and the sum\nof the squares of the sequence. Let's refactor this method and write\na utility method that produces all three of those values. All three values can be returned as a tuple.\n\nLet's update this method so the three values computed during the enumeration\nare stored in a tuple. That creates this version:\n\n[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion \"Refactor to use tuples\")]\n\nVisual Studio's Refactoring support makes it easy to extract the functionality\nfor the core statistics into a private method. That gives you a `private static`\nmethod that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:\n\n[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion \"After extracting utility method\")]\n \nThe language enables a couple more options that you can use, if you want\nto make a few quick edits by hand. First, you can use the `var`\ndeclaration to initialize the tuple result from the `ComputeSumAndSumOfSquares`\nmethod call. You can also create three discrete variables inside the\n`ComputeSumAndSumOfSquares` method. The final version is shown in the following code:\n\n[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion \"After final cleanup\")]\n\nThis final version can be used for any method that needs those three\nvalues, or any subset of them.\n\nThe language supports other options in managing the names of the elements\nin these tuple-returning methods.\n\nYou can remove the field names from the return value declaration and\nreturn an unnamed tuple:\n\n```csharp\nprivate static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)\n{\n    double sum = 0;\n    double sumOfSquares = 0;\n    int count = 0;\n\n    foreach (var item in sequence)\n    {\n        count++;\n        sum += item;\n        sumOfSquares += item * item;\n    }\n\n    return (sum, sumOfSquares, count);\n}\n```\n\nThe fields of this tuple are named `Item1`, `Item2`, and `Item3`.\nIt's recommended that you provide semantic names to the elements of tuples\nreturned from methods.\n\nAnother idiom where tuples can be useful is when you are authoring\nLINQ queries. The final projected result often contains some, but not\nall, of the properties of the objects being selected.\n\nYou would traditionally project the results of the query into a sequence\nof objects that were an anonymous type. That presented many limitations,\nprimarily because anonymous types could not conveniently be named in the\nreturn type for a method. Alternatives using `object` or `dynamic` as the\ntype of the result came with significant performance costs.\n\nReturning a sequence of a tuple type is easy, and the names and types\nof the elements are available at compile time and through IDE tools.\nFor example, consider a ToDo application. You might define a\nclass similar to the following to represent a single entry in the ToDo list:\n\n[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem \"To Do Item\")]\n\nYour mobile applications may support a compact form of the current ToDo items\nthat only displays the title. That LINQ query would make a projection that\nincludes only the ID and the title. A method that returns a sequence of tuples\nexpresses that design well:\n\n[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple \"Query returning a tuple\")]\n\n> [!NOTE]\n> In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types. In the above code,\n> the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.\n\nThe named tuple can be part of the signature. It lets the compiler and IDE\ntools provide static checking that you are using the result correctly. The\nnamed tuple also carries the static type information so there is no need\nto use expensive run time features like reflection or dynamic binding to\nwork with the results.\n\n## Deconstruction\n\nYou can unpackage all the items in a tuple by *deconstructing* the tuple\nreturned by a method. There are three different approaches to deconstructing\ntuples.  First, you can explicitly declare the type of each field inside\nparentheses to create discrete variables for each of the elements in the tuple:\n\n[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct \"Deconstruct\")]\n\nYou can also declare implicitly typed variables for each field in a tuple\nby using the `var` keyword outside the parentheses:\n\n[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar \"Deconstruct to Var\")]\n\nIt is also legal to use the `var` keyword with any, or all of the variable\ndeclarations inside the parentheses. \n\n```csharp\n(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);\n```\n\nYou cannot use a specific\ntype outside the parentheses, even if every field in the tuple has the\nsame type.\n\nYou can deconstruct tuples with existing declarations as well:\n\n```csharp\npublic class Point\n{\n    public int X { get; set; }\n    public int Y { get; set; }\n\n    public Point(int x, int y) => (X, Y) = (x, y);\n}\n```\n\n> [!WARNING]\n>  You cannot mix existing declarations with declarations inside the parentheses. For instance, the following is not allowed: `(var x, y) = MyMethod();`. This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.\n\n### Deconstructing user-defined types\n\nAny tuple type can be deconstructed as shown above. It's also easy\nto enable deconstruction on any user-defined type (classes, structs, or \neven interfaces).\n\nThe type author can define one or more `Deconstruct` methods that\nassign values to any number of `out` variables representing the\ndata elements that make up the type. For example, the following\n`Person` type defines a `Deconstruct` method that deconstructs\na person object into the elements representing the first name\nand last name:\n\n[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod \"Type with a deconstruct method\")]\n\nThe deconstruct method enables assignment from a `Person` to two strings, \nrepresenting the `FirstName` and `LastName` properties:\n\n[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType \"Deconstruct a class type\")]\n\nYou can enable deconstruction even for types you did not author.\nThe `Deconstruct` method can be an extension method that unpackages\nthe accessible data members of an object. The example below shows\na `Student` type, derived from the `Person` type, and an extension\nmethod that deconstructs a `Student` into three variables, representing\nthe `FirstName`, the `LastName`, and the `GPA`:\n\n[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod \"Type with a deconstruct extension method\")]\n\nA `Student` object now has two accessible `Deconstruct` methods: the extension method\ndeclared for `Student` types, and the member of the `Person` type. Both are in scope,\nand that enables a `Student` to be deconstructed into either two variables or three.\nIf you assign a student to three variables, the first name, last name, and GPA are\nall returned. If you assign a student to two variables, only the first name and \nthe last name are returned.\n\n[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension \"Deconstruct a class type using an extension method\")]\n\nYou should be careful defining multiple `Deconstruct` methods in a \nclass or a class hierarchy. Multiple `Deconstruct` methods that have the\nsame number of `out` parameters can quickly cause ambiguities. Callers may\nnot be able to easily call the desired `Deconstruct` method.\n\nIn this example, there is minimal chance for an ambiguous call because the\n`Deconstruct` method for `Person` has two output parameters, and the `Deconstruct`\nmethod for `Student` has three.\n\nDeconstruction operators do not participate in testing equality. The following example generates compiler error CS0019:\n\n```csharp\nPerson p = new Person(\"Althea\", \"Goodwin\");\nif ((\"Althea\", \"Goodwin\") == p)\n    Console.WriteLine(p);\n```\n\nThe `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.\n\n## Conclusion \n\nThe new language and library support for named tuples makes it much easier\nto work with designs that use data structures that store multiple elements\nbut do not define behavior, as classes and structs do. It's\neasy and concise to use tuples for those types. You get all the benefits of\nstatic type checking, without needing to author types using the more\nverbose `class` or `struct` syntax. Even so, they are most useful for utility methods\nthat are `private`, or `internal`. Create user-defined types, either\n`class` or `struct` types when your public methods return a value\nthat has multiple elements.\n","nodes":[{"pos":[4,163],"embed":true,"restype":"x-metadata","content":"title: Tuple types - C# Guide\ndescription: Learn about unnamed and named tuple types in C#\nms.date: 05/15/2018\nms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa","nodes":[{"content":"Tuple types - C# Guide","nodes":[{"pos":[0,22],"content":"Tuple types - C# Guide","nodes":[{"content":"Tuple types - C# Guide","pos":[0,22]}]}],"path":["title"],"nosxs":false},{"content":"Learn about unnamed and named tuple types in C#","nodes":[{"pos":[0,47],"content":"Learn about unnamed and named tuple types in C#","nodes":[{"content":"Learn about unnamed and named tuple types in C#","pos":[0,47]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[170,184],"content":"C# tuple types","linkify":"C# tuple types","nodes":[{"content":"C# tuple types","pos":[0,14]}]},{"content":"C# tuples are types that you define using a lightweight syntax.","pos":[186,249]},{"content":"The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.","pos":[250,446],"source":" The advantages\ninclude a simpler syntax, rules for conversions based on number (referred to as cardinality)\nand types of elements, and\nconsistent rules for copies, equality tests, and assignments."},{"content":"As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.","pos":[447,547],"source":" As a tradeoff, tuples do not\nsupport some of the object-oriented idioms associated with inheritance."},{"content":"You can get an overview in the section on <bpt id=\"p1\">[</bpt>tuples in the What's new in C# 7.0<ept id=\"p1\">](whats-new/csharp-7.md#tuples)</ept> article.","pos":[548,665],"source":" You\ncan get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article."},{"pos":[667,835],"content":"In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.","source":"In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions,\ndifferent ways to use them, and initial guidance on working with tuples."},{"pos":[839,1087],"content":"[!NOTE]\nThe new tuples features require the <xref:System.ValueTuple> types.\nYou must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it\non platforms that do not include the types.","leadings":["","> ","> ","> "],"nodes":[{"content":"The new tuples features require the <xref:System.ValueTuple> types.\nYou must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it\non platforms that do not include the types.","pos":[8,242],"nodes":[{"content":"The new tuples features require the <ph id=\"ph1\">&lt;xref:System.ValueTuple&gt;</ph> types.","pos":[0,67],"source":"The new tuples features require the <xref:System.ValueTuple> types."},{"content":"You must add the NuGet package <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`System.ValueTuple`</ph><ept id=\"p1\">](https://www.nuget.org/packages/System.ValueTuple/)</ept> in order to use it on platforms that do not include the types.","pos":[68,234],"source":"\nYou must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it\non platforms that do not include the types."}]}]},{"pos":[1092,1764],"content":"This is similar to other language features that rely on types\ndelivered in the framework. Examples include `async` and `await`\nrelying on the `INotifyCompletion` interface, and LINQ relying\non `IEnumerable<T>`. However, the delivery mechanism is changing\nas .NET is becoming more platform independent. The .NET Framework\nmay not always ship on the same cadence as the language compiler. When new language\nfeatures rely on new types, those types will be available as NuGet packages when\nthe language features ship. As these new types get added to the .NET Standard\nAPI and delivered as part of the framework, the NuGet package requirement will\nbe removed.","leadings":["","> ","> ","> ","> ","> ","> ","> ","> ","> "],"nodes":[{"content":"This is similar to other language features that rely on types delivered in the framework.","pos":[0,89],"source":"This is similar to other language features that rely on types\ndelivered in the framework."},{"content":"Examples include <ph id=\"ph1\">`async`</ph> and <ph id=\"ph2\">`await`</ph> relying on the <ph id=\"ph3\">`INotifyCompletion`</ph> interface, and LINQ relying on <ph id=\"ph4\">`IEnumerable&lt;T&gt;`</ph>.","pos":[90,210],"source":" Examples include `async` and `await`\nrelying on the `INotifyCompletion` interface, and LINQ relying\non `IEnumerable<T>`."},{"content":"However, the delivery mechanism is changing as .NET is becoming more platform independent.","pos":[211,301],"source":" However, the delivery mechanism is changing\nas .NET is becoming more platform independent."},{"content":"The .NET Framework may not always ship on the same cadence as the language compiler.","pos":[302,386],"source":" The .NET Framework\nmay not always ship on the same cadence as the language compiler."},{"content":"When new language features rely on new types, those types will be available as NuGet packages when the language features ship.","pos":[387,513],"source":" When new language\nfeatures rely on new types, those types will be available as NuGet packages when\nthe language features ship."},{"content":"As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.","pos":[514,654],"source":" As these new types get added to the .NET Standard\nAPI and delivered as part of the framework, the NuGet package requirement will\nbe removed."}]},{"content":"Let's start with the reasons for adding new tuple support.","pos":[1766,1824]},{"content":"Methods return a single object.","pos":[1825,1856],"source":" Methods return\na single object."},{"content":"Tuples enable you to package multiple values in that single object more easily.","pos":[1857,1936],"source":" Tuples enable you to package multiple values in that single\nobject more easily."},{"content":"The .NET Framework already has generic <ph id=\"ph1\">`Tuple`</ph> classes.","pos":[1938,1993],"source":"The .NET Framework already has generic `Tuple` classes."},{"content":"These classes, however, had two major limitations.","pos":[1994,2044],"source":" These classes,\nhowever, had two major limitations."},{"content":"For one, the <ph id=\"ph1\">`Tuple`</ph> classes named their properties <ph id=\"ph2\">`Item1`</ph>, <ph id=\"ph3\">`Item2`</ph>, and so on.","pos":[2045,2125],"source":" For one, the `Tuple` classes named\ntheir properties `Item1`, `Item2`, and so on."},{"content":"Those names carry no semantic information.","pos":[2126,2168],"source":" Those names carry no semantic\ninformation."},{"content":"Using these <ph id=\"ph1\">`Tuple`</ph> types does not enable communicating the meaning of each of the properties.","pos":[2169,2263],"source":" Using these `Tuple` types does not enable communicating the\nmeaning of each of the properties."},{"content":"The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.","pos":[2264,2378],"source":" The new language features enable you to declare\nand use semantically meaningful names for the elements in a tuple."},{"content":"The <ph id=\"ph1\">`Tuple`</ph> classes cause more performance concerns because they are reference types.","pos":[2380,2465],"source":"The `Tuple` classes cause more performance concerns because they are\nreference types."},{"content":"Using one of the <ph id=\"ph1\">`Tuple`</ph> types means allocating objects.","pos":[2466,2522],"source":" Using one of the `Tuple` types means allocating objects."},{"content":"On hot paths, allocating many small objects can have a measurable impact on your application's performance.","pos":[2523,2630],"source":" On hot\npaths, allocating many small objects can have a measurable impact on your application's performance."},{"content":"Therefore, the language support for tuples leverages the new <ph id=\"ph1\">`ValueTuple`</ph> structs.","pos":[2631,2713],"source":" Therefore,\nthe language support for tuples leverages the new `ValueTuple` structs."},{"content":"To avoid those deficiencies, you could create a <ph id=\"ph1\">`class`</ph> or a <ph id=\"ph2\">`struct`</ph> to carry multiple elements.","pos":[2715,2812],"source":"To avoid those deficiencies, you could create a `class` or a `struct`\nto carry multiple elements."},{"content":"Unfortunately, that's more work for you, and it obscures your design intent.","pos":[2813,2889],"source":" Unfortunately, that's more work for you,\nand it obscures your design intent."},{"content":"Making a <ph id=\"ph1\">`struct`</ph> or <ph id=\"ph2\">`class`</ph> implies that you are defining a type with both data and behavior.","pos":[2890,2984],"source":" Making a `struct` or `class` implies\nthat you are defining a type with both data and behavior."},{"content":"Many times, you simply want to store multiple values in a single object.","pos":[2985,3057],"source":" Many times, you\nsimply want to store multiple values in a single object."},{"content":"The language features and the <ph id=\"ph1\">`ValueTuple`</ph> generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.","pos":[3059,3199],"source":"The language features and the `ValueTuple` generic structs enforce the rule that\nyou cannot add any behavior (methods) to these tuple types."},{"content":"All the <ph id=\"ph1\">`ValueTuple`</ph> types are <bpt id=\"p1\">*</bpt>mutable structs<ept id=\"p1\">*</ept>.","pos":[3200,3249],"source":"\nAll the `ValueTuple` types are *mutable structs*."},{"content":"Each member field is a public field.","pos":[3250,3286],"source":" Each member field is a\npublic field."},{"content":"That makes them very lightweight.","pos":[3287,3320]},{"content":"However, that means tuples should not be used where immutability is important.","pos":[3321,3399],"source":" However, that means tuples\nshould not be used where immutability is important."},{"content":"Tuples are both simpler and more flexible data containers than <ph id=\"ph1\">`class`</ph> and <ph id=\"ph2\">`struct`</ph> types.","pos":[3401,3491],"source":"Tuples are both simpler and more flexible data containers than `class` and\n`struct` types."},{"content":"Let's explore those differences.","pos":[3492,3524]},{"pos":[3529,3553],"content":"Named and unnamed tuples","linkify":"Named and unnamed tuples","nodes":[{"content":"Named and unnamed tuples","pos":[0,24]}]},{"content":"The <ph id=\"ph1\">`ValueTuple`</ph> struct has fields named <ph id=\"ph2\">`Item1`</ph>, <ph id=\"ph3\">`Item2`</ph>, <ph id=\"ph4\">`Item3`</ph>, and so on, similar to the properties defined in the existing <ph id=\"ph5\">`Tuple`</ph> types.","pos":[3555,3698],"source":"The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on,\nsimilar to the properties defined in the existing `Tuple` types."},{"content":"These names are the only names you can use for <bpt id=\"p1\">*</bpt>unnamed tuples<ept id=\"p1\">*</ept>.","pos":[3699,3763],"source":"\nThese names are the only names you can use for *unnamed tuples*."},{"content":"When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:","pos":[3764,3860],"source":" When you\ndo not provide any alternative field names to a tuple, you've created an\nunnamed tuple:"},{"pos":[3980,4138],"content":"The tuple in the previous example was initialized using literal constants and won't have element names created using <bpt id=\"p1\">*</bpt>tuple field name projections<ept id=\"p1\">*</ept> in C# 7.1.","source":"The tuple in the previous example was initialized using literal constants and\nwon't have element names created using *tuple field name projections* in C# 7.1."},{"content":"However, when you initialize a tuple, you can use new language features that give better names to each field.","pos":[4140,4249],"source":"However, when you initialize a tuple, you can use new language features\nthat give better names to each field."},{"content":"Doing so creates a <bpt id=\"p1\">*</bpt>named tuple<ept id=\"p1\">*</ept>.","pos":[4250,4283],"source":" Doing so creates a *named tuple*."},{"content":"Named tuples still have elements named <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph>, <ph id=\"ph3\">`Item3`</ph> and so on.","pos":[4284,4359],"source":"\nNamed tuples still have elements named `Item1`, `Item2`, `Item3` and so on."},{"content":"But they also have synonyms for any of those elements that you have named.","pos":[4360,4434],"source":"\nBut they also have synonyms for any of those elements that you have named."},{"content":"You create a named tuple by specifying the names for each element.","pos":[4435,4501],"source":"\nYou create a named tuple by specifying the names for each element."},{"content":"One way is to specify the names as part of the tuple initialization:","pos":[4502,4570],"source":" One way\nis to specify the names as part of the tuple initialization:"},{"content":"These synonyms are handled by the compiler and the language so that you can use named tuples effectively.","pos":[4684,4789],"source":"These synonyms are handled by the compiler and the language so that you\ncan use named tuples effectively."},{"content":"IDEs and editors can read these semantic names using the Roslyn APIs.","pos":[4790,4859],"source":" IDEs and editors can read these semantic names\nusing the Roslyn APIs."},{"content":"You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.","pos":[4860,4962],"source":" You can reference the elements of a named\ntuple by those semantic names anywhere in the same assembly."},{"content":"The compiler replaces the names you've defined with <ph id=\"ph1\">`Item*`</ph> equivalents when generating the compiled output.","pos":[4963,5071],"source":" The compiler\nreplaces the names you've defined with `Item*` equivalents when generating\nthe compiled output."},{"content":"The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.","pos":[5072,5179],"source":" The compiled Microsoft Intermediate Language (MSIL)\ndoes not include the names you've given these elements."},{"content":"Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.","pos":[5181,5296],"source":"Beginning with C# 7.1, the field names for a tuple may be provided from the\nvariables used to initialize the tuple."},{"content":"This is referred to as <bpt id=\"p1\">**</bpt><bpt id=\"p2\">[</bpt>tuple projection initializers<ept id=\"p2\">](#tuple-projection-initializers)</ept><ept id=\"p1\">**</ept>.","pos":[5297,5388],"source":" This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**."},{"content":"The following code creates a tuple named <ph id=\"ph1\">`accumulation`</ph> with elements <ph id=\"ph2\">`count`</ph> (an integer), and <ph id=\"ph3\">`sum`</ph> (a double).","pos":[5389,5502],"source":" The following code creates a tuple named\n`accumulation` with elements `count` (an integer), and `sum` (a double)."},{"content":"The compiler must communicate those names you created for tuples that are returned from public methods or properties.","pos":[5626,5743],"source":"The compiler must communicate those names you created for tuples that\nare returned from public methods or properties."},{"content":"In those cases, the compiler adds a <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.TupleElementNamesAttribute&gt;</ph> attribute on the method.","pos":[5744,5870],"source":" In those cases, the compiler\nadds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method."},{"content":"This attribute contains a <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames&gt;</ph> list property that contains the names given to each of the elements in the tuple.","pos":[5871,6059],"source":" This attribute contains\na <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of\nthe elements in the tuple."},{"pos":[6063,6219],"content":"[!NOTE]\nDevelopment Tools, such as Visual Studio, also read that metadata,\nand provide IntelliSense and other features using the metadata\nfield names.","leadings":["","> ","> ","> "],"nodes":[{"content":"Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.","pos":[8,150],"source":"Development Tools, such as Visual Studio, also read that metadata,\nand provide IntelliSense and other features using the metadata\nfield names."}]},{"pos":[6221,6399],"content":"It is important to understand these underlying fundamentals of the new tuples and the <ph id=\"ph1\">`ValueTuple`</ph> type in order to understand the rules for assigning named tuples to each other.","source":"It is important to understand these underlying fundamentals of\nthe new tuples and the `ValueTuple` type in order to understand\nthe rules for assigning named tuples to each other."},{"pos":[6404,6433],"content":"Tuple projection initializers","linkify":"Tuple projection initializers","nodes":[{"content":"Tuple projection initializers","pos":[0,29]}]},{"content":"In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.","pos":[6435,6580],"source":"In general, tuple projection initializers work by using the variable or\nfield names from the right-hand side of a tuple initialization statement."},{"content":"If an explicit name is given, that takes precedence over any projected name.","pos":[6581,6657],"source":"\nIf an explicit name is given, that takes precedence over any projected\nname."},{"content":"For example, in the following initializer, the elements are <ph id=\"ph1\">`explicitFieldOne`</ph> and <ph id=\"ph2\">`explicitFieldTwo`</ph>, not <ph id=\"ph3\">`localVariableOne`</ph> and <ph id=\"ph4\">`localVariableTwo`</ph>:","pos":[6658,6807],"source":" For example, in the following initializer, the elements are `explicitFieldOne`\nand `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:"},{"content":"For any field where an explicit name is not provided, an applicable implicit name is projected.","pos":[6953,7048],"source":"For any field where an explicit name is not provided, an applicable implicit\nname is projected."},{"content":"There is no requirement to provide semantic names, either explicitly or implicitly.","pos":[7049,7132],"source":" There is no requirement to provide semantic names,\neither explicitly or implicitly."},{"content":"The following initializer has     field names <ph id=\"ph1\">`Item1`</ph>, whose value is <ph id=\"ph2\">`42`</ph> and <ph id=\"ph3\">`stringContent`</ph>, whose value is \"The answer to everything\":","pos":[7133,7271],"source":" The following initializer has     field\nnames `Item1`, whose value is `42` and `stringContent`, whose value is \"The answer to everything\":"},{"content":"There are two conditions where candidate field names are not projected onto the tuple field:","pos":[7382,7474]},{"content":"When the candidate name is a reserved tuple name.","pos":[7479,7528]},{"content":"Examples include <ph id=\"ph1\">`Item3`</ph>, <ph id=\"ph2\">`ToString`</ph>.","pos":[7529,7566],"source":" Examples include `Item3`, `ToString`."},{"content":"or <ph id=\"ph1\">`Rest`</ph>.","pos":[7567,7577],"source":" or `Rest`."},{"content":"When the candidate name is a duplicate of another tuple field name, either explicit or implicit.","pos":[7581,7677]},{"content":"These conditions avoid ambiguity.","pos":[7679,7712]},{"content":"These names would cause an ambiguity if they were used as the field names for a field in a tuple.","pos":[7713,7810],"source":" These names would cause an ambiguity\nif they were used as the field names for a field in a tuple."},{"content":"Neither of these conditions cause compile-time errors.","pos":[7811,7865],"source":" Neither of these\nconditions cause compile-time errors."},{"content":"Instead, the elements without projected names do not have semantic names projected for them.","pos":[7866,7958],"source":" Instead, the elements without projected names\ndo not have semantic names projected for them."},{"content":"The following examples demonstrate these conditions:","pos":[7960,8012],"source":"  The following examples\ndemonstrate these conditions:"},{"pos":[8176,8345],"content":"These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.","source":"These situations do not cause compiler errors because that would be a breaking change for\ncode written with C# 7.0, when tuple field name projections were not available."},{"pos":[8350,8369],"content":"Equality and tuples","linkify":"Equality and tuples","nodes":[{"content":"Equality and tuples","pos":[0,19]}]},{"content":"Beginning with C# 7.3, tuple types support the <ph id=\"ph1\">`==`</ph> and <ph id=\"ph2\">`!=`</ph> operators.","pos":[8371,8442],"source":"Beginning with C# 7.3, tuple types support the `==` and `!=` operators."},{"content":"These operators work by comparing each member of the left argument to each member of the right argument in order.","pos":[8443,8556]},{"content":"These comparisons short-circuit.","pos":[8557,8589]},{"content":"They will stop evaluating members as soon as one pair is not equal.","pos":[8590,8657]},{"content":"The following code examples use <ph id=\"ph1\">`==`</ph>, but the comparison rules all apply to <ph id=\"ph2\">`!=`</ph>.","pos":[8658,8739],"source":" The following code examples use `==`, but the comparison rules all apply to `!=`."},{"content":"The following code example shows an equality comparison for two pairs of integers:","pos":[8740,8822]},{"content":"There are several rules that make tuple equality tests more convenient.","pos":[8962,9033]},{"content":"Tuple equality performs <bpt id=\"p1\">[</bpt>lifted conversions<ept id=\"p1\">](~/_csharplang/spec/conversions.md#lifted-conversion-operators)</ept> if one of the tuples is a nullable tuple, as shown in the following code:","pos":[9034,9215],"source":" Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:"},{"content":"Tuple equality also performs implicit conversions on each member of both tuples.","pos":[9380,9460]},{"content":"These include lifted conversions, widening conversions, or other implicit conversions.","pos":[9461,9547]},{"content":"The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:","pos":[9548,9690]},{"content":"The names of the tuple members do not participate in tests for equality.","pos":[9866,9938]},{"content":"However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.","pos":[9939,10108]},{"content":"In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:","pos":[10109,10231],"source":"\nIn the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:"},{"content":"Finally, tuples may contain nested tuples.","pos":[10407,10449]},{"content":"Tuple equality compares the \"shape\" of each operand through nested tuples as shown in the following example:","pos":[10450,10558]},{"content":"It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.","pos":[10749,10858]},{"content":"The compiler won' attempt any deconstruction of nested tuples in order to compare them.","pos":[10859,10946]},{"pos":[10951,10972],"content":"Assignment and tuples","linkify":"Assignment and tuples","nodes":[{"content":"Assignment and tuples","pos":[0,21]}]},{"content":"The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.","pos":[10974,11173],"source":"The language supports assignment between tuple types that have\nthe same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element."},{"content":"Other conversions aren't considered for assignments.","pos":[11174,11226],"source":" Other\nconversions aren't considered for assignments."},{"content":"It's a compile time error to assign one tuple to another when they have different shapes.","pos":[11227,11316]},{"content":"The compiler won't attempt any deconstruction of nested tuples in order to assign them.","pos":[11317,11404]},{"content":"Let's look at the kinds of assignments that are allowed between tuple types.","pos":[11405,11481],"source":"\nLet's look at the kinds\nof assignments that are allowed between tuple types."},{"content":"Consider these variables used in the following examples:","pos":[11483,11539]},{"content":"The first two variables, <ph id=\"ph1\">`unnamed`</ph> and <ph id=\"ph2\">`anonymous`</ph> do not have semantic names provided for the elements.","pos":[11671,11775],"source":"The first two variables, `unnamed` and `anonymous` do not have semantic\nnames provided for the elements."},{"content":"The field names are <ph id=\"ph1\">`Item1`</ph> and <ph id=\"ph2\">`Item2`</ph>.","pos":[11776,11816],"source":" The field names are `Item1` and `Item2`."},{"content":"The last two variables, <ph id=\"ph1\">`named`</ph> and <ph id=\"ph2\">`differentName`</ph> have semantic names given for the elements.","pos":[11817,11912],"source":"\nThe last two variables, `named` and `differentName` have semantic names\ngiven for the elements."},{"content":"These two tuples have different names for the elements.","pos":[11913,11968],"source":" These two tuples have different names\nfor the elements."},{"content":"All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.","pos":[11970,12105],"source":"All four of these tuples have the same number of elements (referred to as 'cardinality')\nand the types of those elements are identical."},{"content":"Therefore, all of these assignments work:","pos":[12106,12147],"source":" Therefore, all of these\nassignments work:"},{"content":"Notice that the names of the tuples are not assigned.","pos":[12285,12338]},{"content":"The values of the elements are assigned following the order of the elements in the tuple.","pos":[12339,12428],"source":" The values of the\nelements are assigned following the order of the elements in the tuple."},{"content":"Tuples of different types or numbers of elements are not assignable:","pos":[12430,12498]},{"pos":[12661,12691],"content":"Tuples as method return values","linkify":"Tuples as method return values","nodes":[{"content":"Tuples as method return values","pos":[0,30]}]},{"content":"One of the most common uses for tuples is as a method return value.","pos":[12693,12760],"source":"One of the most common uses for tuples is as a method return\nvalue."},{"content":"Let's walk through one example.","pos":[12761,12792]},{"content":"Consider this method that computes the standard deviation for a sequence of numbers:","pos":[12793,12877],"source":" Consider this method\nthat computes the standard deviation for a sequence of numbers:"},{"pos":[13025,13392],"content":"[!NOTE]\nThese examples compute the uncorrected sample standard deviation.\nThe corrected sample standard deviation formula would divide\nthe sum of the squared differences from the mean by (N-1) instead\nof N, as the `Average` extension method does. Consult a statistics\ntext for more details on the differences between these formulas\nfor standard deviation.","leadings":["","> ","> ","> ","> ","> ","> "],"nodes":[{"content":"These examples compute the uncorrected sample standard deviation.\nThe corrected sample standard deviation formula would divide\nthe sum of the squared differences from the mean by (N-1) instead\nof N, as the `Average` extension method does. Consult a statistics\ntext for more details on the differences between these formulas\nfor standard deviation.","pos":[8,355],"nodes":[{"content":"These examples compute the uncorrected sample standard deviation.","pos":[0,65]},{"content":"The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the <ph id=\"ph1\">`Average`</ph> extension method does.","pos":[66,238],"source":"\nThe corrected sample standard deviation formula would divide\nthe sum of the squared differences from the mean by (N-1) instead\nof N, as the `Average` extension method does."},{"content":"Consult a statistics text for more details on the differences between these formulas for standard deviation.","pos":[239,347],"source":" Consult a statistics\ntext for more details on the differences between these formulas\nfor standard deviation."}]}]},{"content":"The preceding code follows the textbook formula for the standard deviation.","pos":[13394,13469]},{"content":"It produces the correct answer, but it's an inefficient implementation.","pos":[13470,13541],"source":" It produces\nthe correct answer, but it's an inefficient implementation."},{"content":"This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.","pos":[13542,13693],"source":" This\nmethod enumerates the sequence twice: Once to produce the average, and\nonce to produce the average of the square of the difference of the average."},{"content":"(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)","pos":[13694,13861],"source":"\n(Remember that LINQ queries are evaluated lazily, so the computation of\nthe differences from the mean and the average of those differences makes\nonly one enumeration.)"},{"content":"There is an alternative formula that computes standard deviation using only one enumeration of the sequence.","pos":[13863,13971],"source":"There is an alternative formula that computes standard deviation using\nonly one enumeration of the sequence."},{"content":"This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:","pos":[13973,14117],"source":"  This computation produces two\nvalues as it enumerates the sequence: the sum of all items in the sequence,\nand the sum of the each value squared:"},{"content":"This version enumerates the sequence exactly once.","pos":[14292,14342]},{"content":"But it's not reusable code.","pos":[14343,14370]},{"content":"As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.","pos":[14371,14558],"source":" As you keep working, you'll find that many different\nstatistical computations use the number of items in the sequence,\nthe sum of the sequence, and the sum\nof the squares of the sequence."},{"content":"Let's refactor this method and write a utility method that produces all three of those values.","pos":[14559,14653],"source":" Let's refactor this method and write\na utility method that produces all three of those values."},{"content":"All three values can be returned as a tuple.","pos":[14654,14698]},{"content":"Let's update this method so the three values computed during the enumeration are stored in a tuple.","pos":[14700,14799],"source":"Let's update this method so the three values computed during the enumeration\nare stored in a tuple."},{"content":"That creates this version:","pos":[14800,14826]},{"content":"Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.","pos":[14958,15083],"source":"Visual Studio's Refactoring support makes it easy to extract the functionality\nfor the core statistics into a private method."},{"content":"That gives you a <ph id=\"ph1\">`private static`</ph> method that returns the tuple type with the three values of <ph id=\"ph2\">`Sum`</ph>, <ph id=\"ph3\">`SumOfSquares`</ph>, and <ph id=\"ph4\">`Count`</ph>:","pos":[15084,15213],"source":" That gives you a `private static`\nmethod that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:"},{"content":"The language enables a couple more options that you can use, if you want to make a few quick edits by hand.","pos":[15367,15474],"source":"The language enables a couple more options that you can use, if you want\nto make a few quick edits by hand."},{"content":"First, you can use the <ph id=\"ph1\">`var`</ph> declaration to initialize the tuple result from the <ph id=\"ph2\">`ComputeSumAndSumOfSquares`</ph> method call.","pos":[15475,15596],"source":" First, you can use the `var`\ndeclaration to initialize the tuple result from the `ComputeSumAndSumOfSquares`\nmethod call."},{"content":"You can also create three discrete variables inside the <ph id=\"ph1\">`ComputeSumAndSumOfSquares`</ph> method.","pos":[15597,15688],"source":" You can also create three discrete variables inside the\n`ComputeSumAndSumOfSquares` method."},{"content":"The final version is shown in the following code:","pos":[15689,15738]},{"pos":[15881,15980],"content":"This final version can be used for any method that needs those three values, or any subset of them.","source":"This final version can be used for any method that needs those three\nvalues, or any subset of them."},{"pos":[15982,16089],"content":"The language supports other options in managing the names of the elements in these tuple-returning methods.","source":"The language supports other options in managing the names of the elements\nin these tuple-returning methods."},{"pos":[16091,16184],"content":"You can remove the field names from the return value declaration and return an unnamed tuple:","source":"You can remove the field names from the return value declaration and\nreturn an unnamed tuple:"},{"content":"The fields of this tuple are named <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph>, and <ph id=\"ph3\">`Item3`</ph>.","pos":[16529,16594],"source":"The fields of this tuple are named `Item1`, `Item2`, and `Item3`."},{"content":"It's recommended that you provide semantic names to the elements of tuples returned from methods.","pos":[16595,16692],"source":"\nIt's recommended that you provide semantic names to the elements of tuples\nreturned from methods."},{"content":"Another idiom where tuples can be useful is when you are authoring LINQ queries.","pos":[16694,16774],"source":"Another idiom where tuples can be useful is when you are authoring\nLINQ queries."},{"content":"The final projected result often contains some, but not all, of the properties of the objects being selected.","pos":[16775,16884],"source":" The final projected result often contains some, but not\nall, of the properties of the objects being selected."},{"content":"You would traditionally project the results of the query into a sequence of objects that were an anonymous type.","pos":[16886,16998],"source":"You would traditionally project the results of the query into a sequence\nof objects that were an anonymous type."},{"content":"That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.","pos":[16999,17130],"source":" That presented many limitations,\nprimarily because anonymous types could not conveniently be named in the\nreturn type for a method."},{"content":"Alternatives using <ph id=\"ph1\">`object`</ph> or <ph id=\"ph2\">`dynamic`</ph> as the type of the result came with significant performance costs.","pos":[17131,17238],"source":" Alternatives using `object` or `dynamic` as the\ntype of the result came with significant performance costs."},{"content":"Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.","pos":[17240,17378],"source":"Returning a sequence of a tuple type is easy, and the names and types\nof the elements are available at compile time and through IDE tools."},{"content":"For example, consider a ToDo application.","pos":[17379,17420],"source":"\nFor example, consider a ToDo application."},{"content":"You might define a class similar to the following to represent a single entry in the ToDo list:","pos":[17421,17516],"source":" You might define a\nclass similar to the following to represent a single entry in the ToDo list:"},{"content":"Your mobile applications may support a compact form of the current ToDo items that only displays the title.","pos":[17634,17741],"source":"Your mobile applications may support a compact form of the current ToDo items\nthat only displays the title."},{"content":"That LINQ query would make a projection that includes only the ID and the title.","pos":[17742,17822],"source":" That LINQ query would make a projection that\nincludes only the ID and the title."},{"content":"A method that returns a sequence of tuples expresses that design well:","pos":[17823,17893],"source":" A method that returns a sequence of tuples\nexpresses that design well:"},{"pos":[18048,18319],"content":"[!NOTE]\nIn C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types. In the above code,\nthe `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.","leadings":["","> ","> "],"nodes":[{"content":"In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types. In the above code,\nthe `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.","pos":[8,267],"nodes":[{"content":"In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.","pos":[0,141]},{"content":"In the above code, the <ph id=\"ph1\">`select`</ph> statement in the query projection creates a tuple that has elements <ph id=\"ph2\">`ID`</ph> and <ph id=\"ph3\">`Title`</ph>.","pos":[142,259],"source":" In the above code,\nthe `select` statement in the query projection creates a tuple that has elements `ID` and `Title`."}]}]},{"content":"The named tuple can be part of the signature.","pos":[18321,18366]},{"content":"It lets the compiler and IDE tools provide static checking that you are using the result correctly.","pos":[18367,18466],"source":" It lets the compiler and IDE\ntools provide static checking that you are using the result correctly."},{"content":"The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.","pos":[18467,18639],"source":" The\nnamed tuple also carries the static type information so there is no need\nto use expensive run time features like reflection or dynamic binding to\nwork with the results."},{"pos":[18644,18658],"content":"Deconstruction","linkify":"Deconstruction","nodes":[{"content":"Deconstruction","pos":[0,14]}]},{"content":"You can unpackage all the items in a tuple by <bpt id=\"p1\">*</bpt>deconstructing<ept id=\"p1\">*</ept> the tuple returned by a method.","pos":[18660,18754],"source":"You can unpackage all the items in a tuple by *deconstructing* the tuple\nreturned by a method."},{"content":"There are three different approaches to deconstructing tuples.","pos":[18755,18817],"source":" There are three different approaches to deconstructing\ntuples."},{"content":"First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:","pos":[18819,18962],"source":"  First, you can explicitly declare the type of each field inside\nparentheses to create discrete variables for each of the elements in the tuple:"},{"pos":[19081,19206],"content":"You can also declare implicitly typed variables for each field in a tuple by using the <ph id=\"ph1\">`var`</ph> keyword outside the parentheses:","source":"You can also declare implicitly typed variables for each field in a tuple\nby using the `var` keyword outside the parentheses:"},{"pos":[19342,19453],"content":"It is also legal to use the <ph id=\"ph1\">`var`</ph> keyword with any, or all of the variable declarations inside the parentheses.","source":"It is also legal to use the `var` keyword with any, or all of the variable\ndeclarations inside the parentheses."},{"pos":[19552,19659],"content":"You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.","source":"You cannot use a specific\ntype outside the parentheses, even if every field in the tuple has the\nsame type."},{"content":"You can deconstruct tuples with existing declarations as well:","pos":[19661,19723]},{"pos":[19879,20159],"content":"[!WARNING]\n You cannot mix existing declarations with declarations inside the parentheses. For instance, the following is not allowed: `(var x, y) = MyMethod();`. This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.","leadings":["","> "],"nodes":[{"content":"You cannot mix existing declarations with declarations inside the parentheses. For instance, the following is not allowed: `(var x, y) = MyMethod();`. This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.","pos":[12,278],"nodes":[{"content":"You cannot mix existing declarations with declarations inside the parentheses.","pos":[0,78]},{"content":"For instance, the following is not allowed: <ph id=\"ph1\">`(var x, y) = MyMethod();`</ph>.","pos":[79,150],"source":" For instance, the following is not allowed: `(var x, y) = MyMethod();`."},{"content":"This produces error CS8184 because <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> is declared inside the parentheses and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> is previously declared elsewhere.","pos":[151,266],"source":" This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere."}]}]},{"pos":[20165,20198],"content":"Deconstructing user-defined types","linkify":"Deconstructing user-defined types","nodes":[{"content":"Deconstructing user-defined types","pos":[0,33]}]},{"content":"Any tuple type can be deconstructed as shown above.","pos":[20200,20251]},{"content":"It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).","pos":[20252,20357],"source":" It's also easy\nto enable deconstruction on any user-defined type (classes, structs, or \neven interfaces)."},{"content":"The type author can define one or more <ph id=\"ph1\">`Deconstruct`</ph> methods that assign values to any number of <ph id=\"ph2\">`out`</ph> variables representing the data elements that make up the type.","pos":[20359,20525],"source":"The type author can define one or more `Deconstruct` methods that\nassign values to any number of `out` variables representing the\ndata elements that make up the type."},{"content":"For example, the following <ph id=\"ph1\">`Person`</ph> type defines a <ph id=\"ph2\">`Deconstruct`</ph> method that deconstructs a person object into the elements representing the first name and last name:","pos":[20526,20692],"source":" For example, the following\n`Person` type defines a `Deconstruct` method that deconstructs\na person object into the elements representing the first name\nand last name:"},{"pos":[20854,20984],"content":"The deconstruct method enables assignment from a <ph id=\"ph1\">`Person`</ph> to two strings, representing the <ph id=\"ph2\">`FirstName`</ph> and <ph id=\"ph3\">`LastName`</ph> properties:","source":"The deconstruct method enables assignment from a `Person` to two strings, \nrepresenting the `FirstName` and `LastName` properties:"},{"content":"You can enable deconstruction even for types you did not author.","pos":[21123,21187]},{"content":"The <ph id=\"ph1\">`Deconstruct`</ph> method can be an extension method that unpackages the accessible data members of an object.","pos":[21188,21297],"source":"\nThe `Deconstruct` method can be an extension method that unpackages\nthe accessible data members of an object."},{"content":"The example below shows a <ph id=\"ph1\">`Student`</ph> type, derived from the <ph id=\"ph2\">`Person`</ph> type, and an extension method that deconstructs a <ph id=\"ph3\">`Student`</ph> into three variables, representing the <ph id=\"ph4\">`FirstName`</ph>, the <ph id=\"ph5\">`LastName`</ph>, and the <ph id=\"ph6\">`GPA`</ph>:","pos":[21298,21508],"source":" The example below shows\na `Student` type, derived from the `Person` type, and an extension\nmethod that deconstructs a `Student` into three variables, representing\nthe `FirstName`, the `LastName`, and the `GPA`:"},{"content":"A <ph id=\"ph1\">`Student`</ph> object now has two accessible <ph id=\"ph2\">`Deconstruct`</ph> methods: the extension method declared for <ph id=\"ph3\">`Student`</ph> types, and the member of the <ph id=\"ph4\">`Person`</ph> type.","pos":[21682,21834],"source":"A `Student` object now has two accessible `Deconstruct` methods: the extension method\ndeclared for `Student` types, and the member of the `Person` type."},{"content":"Both are in scope, and that enables a <ph id=\"ph1\">`Student`</ph> to be deconstructed into either two variables or three.","pos":[21835,21938],"source":" Both are in scope,\nand that enables a `Student` to be deconstructed into either two variables or three."},{"content":"If you assign a student to three variables, the first name, last name, and GPA are all returned.","pos":[21939,22035],"source":"\nIf you assign a student to three variables, the first name, last name, and GPA are\nall returned."},{"content":"If you assign a student to two variables, only the first name and the last name are returned.","pos":[22036,22130],"source":" If you assign a student to two variables, only the first name and \nthe last name are returned."},{"content":"You should be careful defining multiple <ph id=\"ph1\">`Deconstruct`</ph> methods in a class or a class hierarchy.","pos":[22312,22407],"source":"You should be careful defining multiple `Deconstruct` methods in a \nclass or a class hierarchy."},{"content":"Multiple <ph id=\"ph1\">`Deconstruct`</ph> methods that have the same number of <ph id=\"ph2\">`out`</ph> parameters can quickly cause ambiguities.","pos":[22408,22515],"source":" Multiple `Deconstruct` methods that have the\nsame number of `out` parameters can quickly cause ambiguities."},{"content":"Callers may not be able to easily call the desired <ph id=\"ph1\">`Deconstruct`</ph> method.","pos":[22516,22588],"source":" Callers may\nnot be able to easily call the desired `Deconstruct` method."},{"pos":[22590,22779],"content":"In this example, there is minimal chance for an ambiguous call because the <ph id=\"ph1\">`Deconstruct`</ph> method for <ph id=\"ph2\">`Person`</ph> has two output parameters, and the <ph id=\"ph3\">`Deconstruct`</ph> method for <ph id=\"ph4\">`Student`</ph> has three.","source":"In this example, there is minimal chance for an ambiguous call because the\n`Deconstruct` method for `Person` has two output parameters, and the `Deconstruct`\nmethod for `Student` has three."},{"content":"Deconstruction operators do not participate in testing equality.","pos":[22781,22845]},{"content":"The following example generates compiler error CS0019:","pos":[22846,22900]},{"pos":[23019,23175],"content":"The <ph id=\"ph1\">`Deconstruct`</ph> method could convert the <ph id=\"ph2\">`Person`</ph> object <ph id=\"ph3\">`p`</ph> to a tuple containing two strings, but it is not applicable in the context of equality tests.","source":"The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests."},{"pos":[23180,23190],"content":"Conclusion","linkify":"Conclusion","nodes":[{"content":"Conclusion","pos":[0,10]}]},{"content":"The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.","pos":[23193,23397],"source":"The new language and library support for named tuples makes it much easier\nto work with designs that use data structures that store multiple elements\nbut do not define behavior, as classes and structs do."},{"content":"It's easy and concise to use tuples for those types.","pos":[23398,23450],"source":" It's\neasy and concise to use tuples for those types."},{"content":"You get all the benefits of static type checking, without needing to author types using the more verbose <ph id=\"ph1\">`class`</ph> or <ph id=\"ph2\">`struct`</ph> syntax.","pos":[23451,23583],"source":" You get all the benefits of\nstatic type checking, without needing to author types using the more\nverbose `class` or `struct` syntax."},{"content":"Even so, they are most useful for utility methods that are <ph id=\"ph1\">`private`</ph>, or <ph id=\"ph2\">`internal`</ph>.","pos":[23584,23668],"source":" Even so, they are most useful for utility methods\nthat are `private`, or `internal`."},{"content":"Create user-defined types, either <ph id=\"ph1\">`class`</ph> or <ph id=\"ph2\">`struct`</ph> types when your public methods return a value that has multiple elements.","pos":[23669,23796],"source":" Create user-defined types, either\n`class` or `struct` types when your public methods return a value\nthat has multiple elements."}]}