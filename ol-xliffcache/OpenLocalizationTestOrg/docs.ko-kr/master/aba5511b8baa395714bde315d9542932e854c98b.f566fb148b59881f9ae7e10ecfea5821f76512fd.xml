{"content":"---\ntitle: \"The Shape of the Command Trees\"\nms.date: \"03/30/2017\"\nms.assetid: 2215585e-ca47-45f8-98d4-8cb982f8c1d3\n---\n\n# The Shape of the Command Trees\n\nThe SQL generation module is responsible for generating a backend specific SQL query based on a given input query command tree expression. This section discusses the characteristics, properties, and structure of the query command trees.\n\n## Query Command Trees Overview\n\nA query command tree is an object model representation of a query. Query command trees serve two purposes:\n\n- To express an input query that is specified against the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].\n\n- To express an output query that is given to a provider and describes a query against the backend.\n\nQuery command trees support richer semantics than SQL:1999 compliant queries, including support for working with nested collections and type operations, like checking whether an entity is of a particular type, or filtering sets based on a type.\n\nThe DBQueryCommandTree.Query property is the root of the expression tree that describes the query logic. The DBQueryCommandTree.Parameters property contains a list of parameters that are used in the query. The expression tree is composed of DbExpression objects.\n\nA DbExpression object represents some computation. Several kinds of expressions are provided by the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] for composing query expressions, including constants, variables, functions, constructors, and standard relational operators like filter and join. Every DbExpression object has a ResultType property that represents the type of the result produced by that expression. This type is expressed as a TypeUsage.\n\n## Shapes of the Output Query Command Tree\n\nOutput query command trees closely represent relational (SQL) queries and adhere to much stricter rules than those that apply to query command trees. They typically contain constructs that are easily translated to SQL.\n\nInput command trees are expressed against the conceptual model, which supports navigation properties, associations among entities, and inheritance. Output command trees are expressed against the storage model. Input command trees allow you to project nested collections, but output command trees do not.\n\nOutput query command trees are built using a subset of the available DbExpression objects and even some expressions in that subset have restricted usage.\n\nType operations, like checking whether a given expression is of a particular type or filtering sets based on a type, are not present in output command trees.\n\nIn output command trees, only expressions that return Boolean values are used for projections and only for predicates in expressions requiring a predicate, like a filter or a case statement.\n\nThe root of an output query command trees is a DbProjectExpression object.\n\n### Expression Types Not Present in Output Query Command Trees\n\nThe following expression types are not valid in an output query command tree and do not need to be handled by providers:\n\n- DbDerefExpression\n\n- DbEntityRefExpression\n\n- DbRefKeyExpression\n\n- DbIsOfExpression\n\n- DbOfTypeExpression\n\n- DbRefExpression\n\n- DbRelationshipNavigationExpression\n\n- DbTreatExpression\n\n### Expression Restrictions and Notes\n\nMany expressions can only be used in a restricted manner in output query command trees:\n\n#### DbFunctionExpression\n\nThe following function types can be passed:\n\n- Canonical functions that are recognized by the Edm namespace.\n\n- Built-in (store) functions that are recognized by the BuiltInAttribute.\n\n- User-defined functions.\n\nCanonical functions (see [Canonical Functions](../../../../../docs/framework/data/adonet/ef/language-reference/canonical-functions.md) for more information) are specified as part of the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], and providers should supply implementations for canonical functions based on those specifications. Store functions are based on the specifications in the corresponding provider manifest. User defined functions are based on specifications in the SSDL.\n\nAlso, functions having the NiladicFunction attribute have no arguments and should be translated without the parenthesis at the end.  That is, to *\\<functionName>* instead of *\\<functionName>()*.\n\n#### DbNewInstanceExpression\n\nDbNewInstanceExpression can only occur in the following two cases:\n\n- As the Projection property of DbProjectExpression.  When used as such the following restrictions apply:\n\n    - The result type must be a row type.\n\n    - Each of its arguments is an expression that produces a result with a primitive type. Typically, each argument is a scalar expression, like a PropertyExpression over a DbVariableReferenceExpression, a function invocation, or an arithmetic computation of the DbPropertyExpression over a DbVariableReferenceExpression or a function invocation. However, an expression representing a scalar subquery can also occur in the list of arguments for a DbNewInstanceExpression. An expression that represents a scalar subquery is an expression tree that represents a subquery that returns exactly one row and one column of a primitive type with a DbElementExpression object root\n\n- With a collection return type, in which case it defines a new collection of the expressions provided as arguments.\n\n#### DbVariableReferenceExpression\n\nA DbVariableReferenceExpression has to be a child of DbPropertyExpression node.\n\n#### DbGroupByExpression\n\nThe Aggregates property of a DbGroupByExpression can only have elements of type DbFunctionAggregate. There are no other aggregate types.\n\n#### DbLimitExpression\n\nThe property Limit can only be a DbConstantExpression or a DbParameterReferenceExpression. Also property WithTies is always false as of version 3.5 of the .NET Framework.\n\n#### DbScanExpression\n\nWhen used in output command trees, the DbScanExpression effectively represents a scan over a table, a view, or a store query, represented by EntitySetBase::Target.\n\nIf the metadata property \"Defining Query\" of the target is non-null, then it represents a query, the query text for which is provided in that metadata property in the provider’s specific language (or dialect) as specified in the store schema definition.\n\nOtherwise, the target represents a table or a view. Its schema prefix is either in the \"Schema\" metadata property, if not null, otherwise is the entity container name.  The table or view name is either the \"Table\" metadata property, if not null, otherwise the Name property of the entity set base.\n\nAll these properties originate from the definition of the corresponding EntitySet in the store schema definition file (the SSDL).\n\n### Using Primitive Types\n\nWhen primitive types are referenced in output command trees, they are typically referenced in the conceptual model's primitive types. However, for certain expressions, providers need the corresponding store primitive type. Examples of such expressions include DbCastExpression and possibly DbNullExpression, if the provider needs to cast the null to the corresponding type. In these cases, providers should do the mapping to the provider type based on the primitive type kind and its facets.\n\n## See also\n\n- [SQL Generation](../../../../../docs/framework/data/adonet/ef/sql-generation.md)\n","nodes":[{"pos":[4,114],"embed":true,"restype":"x-metadata","content":"title: \"The Shape of the Command Trees\"\nms.date: \"03/30/2017\"\nms.assetid: 2215585e-ca47-45f8-98d4-8cb982f8c1d3","nodes":[{"content":"The Shape of the Command Trees","nodes":[{"pos":[0,30],"content":"The Shape of the Command Trees","nodes":[{"content":"The Shape of the Command Trees","pos":[0,30]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[122,152],"content":"The Shape of the Command Trees","linkify":"The Shape of the Command Trees","nodes":[{"content":"The Shape of the Command Trees","pos":[0,30]}]},{"content":"The SQL generation module is responsible for generating a backend specific SQL query based on a given input query command tree expression.","pos":[154,292]},{"content":"This section discusses the characteristics, properties, and structure of the query command trees.","pos":[293,390]},{"pos":[395,423],"content":"Query Command Trees Overview","linkify":"Query Command Trees Overview","nodes":[{"content":"Query Command Trees Overview","pos":[0,28]}]},{"content":"A query command tree is an object model representation of a query.","pos":[425,491]},{"content":"Query command trees serve two purposes:","pos":[492,531]},{"pos":[535,654],"content":"To express an input query that is specified against the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph>.","source":"To express an input query that is specified against the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]."},{"content":"To express an output query that is given to a provider and describes a query against the backend.","pos":[658,755]},{"content":"Query command trees support richer semantics than SQL:1999 compliant queries, including support for working with nested collections and type operations, like checking whether an entity is of a particular type, or filtering sets based on a type.","pos":[757,1001]},{"content":"The DBQueryCommandTree.Query property is the root of the expression tree that describes the query logic.","pos":[1003,1107]},{"content":"The DBQueryCommandTree.Parameters property contains a list of parameters that are used in the query.","pos":[1108,1208]},{"content":"The expression tree is composed of DbExpression objects.","pos":[1209,1265]},{"content":"A DbExpression object represents some computation.","pos":[1267,1317]},{"content":"Several kinds of expressions are provided by the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> for composing query expressions, including constants, variables, functions, constructors, and standard relational operators like filter and join.","pos":[1318,1575],"source":" Several kinds of expressions are provided by the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] for composing query expressions, including constants, variables, functions, constructors, and standard relational operators like filter and join."},{"content":"Every DbExpression object has a ResultType property that represents the type of the result produced by that expression.","pos":[1576,1695]},{"content":"This type is expressed as a TypeUsage.","pos":[1696,1734]},{"pos":[1739,1778],"content":"Shapes of the Output Query Command Tree","linkify":"Shapes of the Output Query Command Tree","nodes":[{"content":"Shapes of the Output Query Command Tree","pos":[0,39]}]},{"content":"Output query command trees closely represent relational (SQL) queries and adhere to much stricter rules than those that apply to query command trees.","pos":[1780,1929]},{"content":"They typically contain constructs that are easily translated to SQL.","pos":[1930,1998]},{"content":"Input command trees are expressed against the conceptual model, which supports navigation properties, associations among entities, and inheritance.","pos":[2000,2147]},{"content":"Output command trees are expressed against the storage model.","pos":[2148,2209]},{"content":"Input command trees allow you to project nested collections, but output command trees do not.","pos":[2210,2303]},{"content":"Output query command trees are built using a subset of the available DbExpression objects and even some expressions in that subset have restricted usage.","pos":[2305,2458]},{"content":"Type operations, like checking whether a given expression is of a particular type or filtering sets based on a type, are not present in output command trees.","pos":[2460,2617]},{"content":"In output command trees, only expressions that return Boolean values are used for projections and only for predicates in expressions requiring a predicate, like a filter or a case statement.","pos":[2619,2809]},{"content":"The root of an output query command trees is a DbProjectExpression object.","pos":[2811,2885]},{"pos":[2891,2949],"content":"Expression Types Not Present in Output Query Command Trees","linkify":"Expression Types Not Present in Output Query Command Trees","nodes":[{"content":"Expression Types Not Present in Output Query Command Trees","pos":[0,58]}]},{"content":"The following expression types are not valid in an output query command tree and do not need to be handled by providers:","pos":[2951,3071]},{"content":"DbDerefExpression","pos":[3075,3092]},{"content":"DbEntityRefExpression","pos":[3096,3117]},{"content":"DbRefKeyExpression","pos":[3121,3139]},{"content":"DbIsOfExpression","pos":[3143,3159]},{"content":"DbOfTypeExpression","pos":[3163,3181]},{"content":"DbRefExpression","pos":[3185,3200]},{"content":"DbRelationshipNavigationExpression","pos":[3204,3238]},{"content":"DbTreatExpression","pos":[3242,3259]},{"pos":[3265,3298],"content":"Expression Restrictions and Notes","linkify":"Expression Restrictions and Notes","nodes":[{"content":"Expression Restrictions and Notes","pos":[0,33]}]},{"content":"Many expressions can only be used in a restricted manner in output query command trees:","pos":[3300,3387]},{"pos":[3394,3414],"content":"DbFunctionExpression","linkify":"DbFunctionExpression","nodes":[{"content":"DbFunctionExpression","pos":[0,20]}]},{"content":"The following function types can be passed:","pos":[3416,3459]},{"content":"Canonical functions that are recognized by the Edm namespace.","pos":[3463,3524]},{"content":"Built-in (store) functions that are recognized by the BuiltInAttribute.","pos":[3528,3599]},{"content":"User-defined functions.","pos":[3603,3626]},{"content":"Canonical functions (see <bpt id=\"p1\">[</bpt>Canonical Functions<ept id=\"p1\">](../../../../../docs/framework/data/adonet/ef/language-reference/canonical-functions.md)</ept> for more information) are specified as part of the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph>, and providers should supply implementations for canonical functions based on those specifications.","pos":[3628,3976],"source":"Canonical functions (see [Canonical Functions](../../../../../docs/framework/data/adonet/ef/language-reference/canonical-functions.md) for more information) are specified as part of the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], and providers should supply implementations for canonical functions based on those specifications."},{"content":"Store functions are based on the specifications in the corresponding provider manifest.","pos":[3977,4064]},{"content":"User defined functions are based on specifications in the SSDL.","pos":[4065,4128]},{"content":"Also, functions having the NiladicFunction attribute have no arguments and should be translated without the parenthesis at the end.","pos":[4130,4261]},{"content":"That is, to <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\&lt;</ph>functionName&gt;<ept id=\"p1\">*</ept> instead of <bpt id=\"p2\">*</bpt><ph id=\"ph2\">\\&lt;</ph>functionName&gt;()<ept id=\"p2\">*</ept>.","pos":[4263,4324],"source":"  That is, to *\\<functionName>* instead of *\\<functionName>()*."},{"pos":[4331,4354],"content":"DbNewInstanceExpression","linkify":"DbNewInstanceExpression","nodes":[{"content":"DbNewInstanceExpression","pos":[0,23]}]},{"content":"DbNewInstanceExpression can only occur in the following two cases:","pos":[4356,4422]},{"content":"As the Projection property of DbProjectExpression.","pos":[4426,4476]},{"content":"When used as such the following restrictions apply:","pos":[4478,4529]},{"content":"The result type must be a row type.","pos":[4537,4572]},{"content":"Each of its arguments is an expression that produces a result with a primitive type.","pos":[4580,4664]},{"content":"Typically, each argument is a scalar expression, like a PropertyExpression over a DbVariableReferenceExpression, a function invocation, or an arithmetic computation of the DbPropertyExpression over a DbVariableReferenceExpression or a function invocation.","pos":[4665,4920]},{"content":"However, an expression representing a scalar subquery can also occur in the list of arguments for a DbNewInstanceExpression.","pos":[4921,5045]},{"content":"An expression that represents a scalar subquery is an expression tree that represents a subquery that returns exactly one row and one column of a primitive type with a DbElementExpression object root","pos":[5046,5245]},{"content":"With a collection return type, in which case it defines a new collection of the expressions provided as arguments.","pos":[5249,5363]},{"pos":[5370,5399],"content":"DbVariableReferenceExpression","linkify":"DbVariableReferenceExpression","nodes":[{"content":"DbVariableReferenceExpression","pos":[0,29]}]},{"content":"A DbVariableReferenceExpression has to be a child of DbPropertyExpression node.","pos":[5401,5480]},{"pos":[5487,5506],"content":"DbGroupByExpression","linkify":"DbGroupByExpression","nodes":[{"content":"DbGroupByExpression","pos":[0,19]}]},{"content":"The Aggregates property of a DbGroupByExpression can only have elements of type DbFunctionAggregate.","pos":[5508,5608]},{"content":"There are no other aggregate types.","pos":[5609,5644]},{"pos":[5651,5668],"content":"DbLimitExpression","linkify":"DbLimitExpression","nodes":[{"content":"DbLimitExpression","pos":[0,17]}]},{"content":"The property Limit can only be a DbConstantExpression or a DbParameterReferenceExpression.","pos":[5670,5760]},{"content":"Also property WithTies is always false as of version 3.5 of the .NET Framework.","pos":[5761,5840]},{"pos":[5847,5863],"content":"DbScanExpression","linkify":"DbScanExpression","nodes":[{"content":"DbScanExpression","pos":[0,16]}]},{"content":"When used in output command trees, the DbScanExpression effectively represents a scan over a table, a view, or a store query, represented by EntitySetBase::Target.","pos":[5865,6028]},{"content":"If the metadata property \"Defining Query\" of the target is non-null, then it represents a query, the query text for which is provided in that metadata property in the provider’s specific language (or dialect) as specified in the store schema definition.","pos":[6030,6283]},{"content":"Otherwise, the target represents a table or a view.","pos":[6285,6336]},{"content":"Its schema prefix is either in the \"Schema\" metadata property, if not null, otherwise is the entity container name.","pos":[6337,6452]},{"content":"The table or view name is either the \"Table\" metadata property, if not null, otherwise the Name property of the entity set base.","pos":[6454,6582]},{"content":"All these properties originate from the definition of the corresponding EntitySet in the store schema definition file (the SSDL).","pos":[6584,6713]},{"pos":[6719,6740],"content":"Using Primitive Types","linkify":"Using Primitive Types","nodes":[{"content":"Using Primitive Types","pos":[0,21]}]},{"content":"When primitive types are referenced in output command trees, they are typically referenced in the conceptual model's primitive types.","pos":[6742,6875]},{"content":"However, for certain expressions, providers need the corresponding store primitive type.","pos":[6876,6964]},{"content":"Examples of such expressions include DbCastExpression and possibly DbNullExpression, if the provider needs to cast the null to the corresponding type.","pos":[6965,7115]},{"content":"In these cases, providers should do the mapping to the provider type based on the primitive type kind and its facets.","pos":[7116,7233]},{"pos":[7238,7246],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7250,7330],"content":"<bpt id=\"p1\">[</bpt>SQL Generation<ept id=\"p1\">](../../../../../docs/framework/data/adonet/ef/sql-generation.md)</ept>","source":"[SQL Generation](../../../../../docs/framework/data/adonet/ef/sql-generation.md)"}]}