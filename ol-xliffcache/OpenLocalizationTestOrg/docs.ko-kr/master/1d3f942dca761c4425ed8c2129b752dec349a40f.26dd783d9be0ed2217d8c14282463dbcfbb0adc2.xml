{"content":"---\ntitle: \"Overloadable Operators (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"C# language, operator overloading\"\n  - \"operator overloading [C#]\"\nms.assetid: 390d9d01-79fc-40ab-9ed3-0bf448da1b6a\ncaps.latest.revision: 18\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Overloadable Operators (C# Programming Guide)\nC# allows user-defined types to overload operators by defining static member functions using the [operator](../../../csharp/language-reference/keywords/operator.md) keyword. Not all operators can be overloaded, however, and others have restrictions, as listed in this table:  \n  \n|Operators|Overloadability|  \n|---------------|---------------------|  \n|[+](../../../csharp/language-reference/operators/addition-operator.md), [-](../../../csharp/language-reference/operators/subtraction-operator.md), [!](../../../csharp/language-reference/operators/logical-negation-operator.md), [~](../../../csharp/language-reference/operators/bitwise-complement-operator.md), [++](../../../csharp/language-reference/operators/increment-operator.md), [--](../../../csharp/language-reference/operators/decrement-operator.md), [true](../../../csharp/language-reference/keywords/true.md), [false](../../../csharp/language-reference/keywords/false.md)|These unary operators can be overloaded.|  \n|[+](../../../csharp/language-reference/operators/addition-operator.md), [-](../../../csharp/language-reference/operators/subtraction-operator.md), [*](../../../csharp/language-reference/operators/multiplication-operator.md), [/](../../../csharp/language-reference/operators/division-operator.md), [%](../../../csharp/language-reference/operators/modulus-operator.md), [&](../../../csharp/language-reference/operators/and-operator.md), [&#124;](../../../csharp/language-reference/operators/or-operator.md), [^](../../../csharp/language-reference/operators/xor-operator.md), [<\\<](../../../csharp/language-reference/operators/left-shift-operator.md), [>>](../../../csharp/language-reference/operators/right-shift-operator.md)|These binary operators can be overloaded.|  \n|[==](../../../csharp/language-reference/operators/equality-comparison-operator.md), [!=](../../../csharp/language-reference/operators/not-equal-operator.md), [\\<](../../../csharp/language-reference/operators/less-than-operator.md), [>](../../../csharp/language-reference/operators/greater-than-operator.md), [\\<=](../../../csharp/language-reference/operators/less-than-equal-operator.md), [>=](../../../csharp/language-reference/operators/greater-than-equal-operator.md)|The comparison operators can be overloaded (but see the note that follows this table).|  \n|[&&](../../../csharp/language-reference/operators/conditional-and-operator.md), [&#124;&#124;](../../../csharp/language-reference/operators/conditional-or-operator.md)|The conditional logical operators cannot be overloaded, but they are evaluated using `&` and `&#124;`, which can be overloaded.|  \n|[&#91;&#93;](../../../csharp/language-reference/operators/index-operator.md)|The array indexing operator cannot be overloaded, but you can define indexers.|  \n|[(T)x](../../../csharp/language-reference/operators/invocation-operator.md)|The cast operator cannot be overloaded, but you can define new conversion operators (see [explicit](../../../csharp/language-reference/keywords/explicit.md) and [implicit](../../../csharp/language-reference/keywords/implicit.md)).|  \n|[+=](../../../csharp/language-reference/operators/addition-assignment-operator.md), [-=](../../../csharp/language-reference/operators/subtraction-assignment-operator.md), [*=](../../../csharp/language-reference/operators/multiplication-assignment-operator.md), [/=](../../../csharp/language-reference/operators/division-assignment-operator.md), [%=](../../../csharp/language-reference/operators/modulus-assignment-operator.md), [&=](../../../csharp/language-reference/operators/and-assignment-operator.md), [&#124;=](../../../csharp/language-reference/operators/or-assignment-operator.md), [^=](../../../csharp/language-reference/operators/xor-assignment-operator.md), [<\\<=](../../../csharp/language-reference/operators/left-shift-assignment-operator.md), [>>=](../../../csharp/language-reference/operators/right-shift-assignment-operator.md)|Assignment operators cannot be overloaded, but `+=`, for example, is evaluated using `+`, which can be overloaded.|  \n|[=](../../../csharp/language-reference/operators/assignment-operator.md), [.](../../../csharp/language-reference/operators/member-access-operator.md), [?:](../../../csharp/language-reference/operators/conditional-operator.md), [??](../../../csharp/language-reference/operators/null-conditional-operator.md), [->](../../../csharp/language-reference/operators/dereference-operator.md), [=>](../../../csharp/language-reference/operators/lambda-operator.md), [f(x)](../../../csharp/language-reference/operators/invocation-operator.md), [as](../../../csharp/language-reference/keywords/as.md), [checked](../../../csharp/language-reference/keywords/checked.md), [unchecked](../../../csharp/language-reference/keywords/unchecked.md), [default](../../../csharp/programming-guide/generics/default-keyword-in-generic-code.md), [delegate](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md), [is](../../../csharp/language-reference/keywords/is.md), [new](../../../csharp/language-reference/keywords/new.md), [sizeof](../../../csharp/language-reference/keywords/sizeof.md), [typeof](../../../csharp/language-reference/keywords/typeof.md)|These operators cannot be overloaded.|  \n  \n> [!NOTE]\n>  The comparison operators, if overloaded, must be overloaded in pairs; that is, if `==` is overloaded, `!=` must also be overloaded. The reverse is also true, and similar for `<` and `>`, and for `<=` and `>=`.  \n  \n To overload an operator on a custom class requires creating a method on the class with the correct signature. The method must be named \"operator X\" where X is the name or symbol of the operator being overloaded. Unary operators have one parameter, and binary operators have two parameters. In each case, one parameter must be the same type as the class or struct that declares the operator.  \n  \n```csharp  \npublic static Complex operator +(Complex c1, Complex c2)  \n    {  \n        Return new Complex(c1.real + c2.real, c1.imaginary + c2.imaginary);  \n    }  \n  \n```  \n  \n It is common to have definitions that simply return immediately with the result of an expression.  There is a syntax shortcut using `=>` for these situations.  \n  \n```csharp  \npublic static Complex operator +(Complex c1, Complex c2) =>  \n        new Complex(c1.real + c2.real, c1.imaginary + c2.imaginary);  \n  \n    // Override ToString() to display a complex number   \n    // in the traditional format:  \n    public override string ToString() => $\"{this.real} + {this.imaginary}\";  \n  \n```  \n  \n For more information, see [How to: Use Operator Overloading to Create a Complex Number Class](../../../csharp/programming-guide/statements-expressions-operators/how-to-use-operator-overloading-to-create-a-complex-number-class.md).  \n  \n## See Also  \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Statements, Expressions, and Operators](../../../csharp/programming-guide/statements-expressions-operators/index.md)   \n [Operators](../../../csharp/programming-guide/statements-expressions-operators/operators.md)   \n [C# Operators](../../../csharp/language-reference/operators/index.md)   \n [Why are overloaded operators always static in C#?](http://go.microsoft.com/fwlink/?LinkId=112383)\n","nodes":[{"pos":[12,74],"content":"Overloadable Operators (C# Programming Guide) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overloadable Operators (C# Programming Guide) | Microsoft Docs","pos":[0,62]}]},{"pos":[596,641],"content":"Overloadable Operators (C# Programming Guide)","linkify":"Overloadable Operators (C# Programming Guide)","nodes":[{"content":"Overloadable Operators (C# Programming Guide)","pos":[0,45]}]},{"content":"C# allows user-defined types to overload operators by defining static member functions using the <bpt id=\"p1\">[</bpt>operator<ept id=\"p1\">](../../../csharp/language-reference/keywords/operator.md)</ept> keyword.","pos":[642,815],"source":"C# allows user-defined types to overload operators by defining static member functions using the [operator](../../../csharp/language-reference/keywords/operator.md) keyword."},{"content":"Not all operators can be overloaded, however, and others have restrictions, as listed in this table:","pos":[816,916]},{"content":"Operators","pos":[923,932]},{"content":"Overloadability","pos":[933,948]},{"pos":[995,1574],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">+</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/addition-operator.md)</ept>, <bpt id=\"p2\">[</bpt><ph id=\"ph2\">-</ph><ept id=\"p2\">](../../../csharp/language-reference/operators/subtraction-operator.md)</ept>, <bpt id=\"p3\">[</bpt>!<ept id=\"p3\">](../../../csharp/language-reference/operators/logical-negation-operator.md)</ept>, <bpt id=\"p4\">[</bpt><ph id=\"ph3\">~</ph><ept id=\"p4\">](../../../csharp/language-reference/operators/bitwise-complement-operator.md)</ept>, <bpt id=\"p5\">[</bpt><ph id=\"ph4\">++</ph><ept id=\"p5\">](../../../csharp/language-reference/operators/increment-operator.md)</ept>, <bpt id=\"p6\">[</bpt><ph id=\"ph5\">--</ph><ept id=\"p6\">](../../../csharp/language-reference/operators/decrement-operator.md)</ept>, <bpt id=\"p7\">[</bpt>true<ept id=\"p7\">](../../../csharp/language-reference/keywords/true.md)</ept>, <bpt id=\"p8\">[</bpt>false<ept id=\"p8\">](../../../csharp/language-reference/keywords/false.md)</ept>","source":"[+](../../../csharp/language-reference/operators/addition-operator.md), [-](../../../csharp/language-reference/operators/subtraction-operator.md), [!](../../../csharp/language-reference/operators/logical-negation-operator.md), [~](../../../csharp/language-reference/operators/bitwise-complement-operator.md), [++](../../../csharp/language-reference/operators/increment-operator.md), [--](../../../csharp/language-reference/operators/decrement-operator.md), [true](../../../csharp/language-reference/keywords/true.md), [false](../../../csharp/language-reference/keywords/false.md)"},{"content":"These unary operators can be overloaded.","pos":[1575,1615]},{"pos":[1620,2343],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">+</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/addition-operator.md)</ept>, <bpt id=\"p2\">[</bpt><ph id=\"ph2\">-</ph><ept id=\"p2\">](../../../csharp/language-reference/operators/subtraction-operator.md)</ept>, <bpt id=\"p3\">[</bpt><ph id=\"ph3\">*</ph><ept id=\"p3\">](../../../csharp/language-reference/operators/multiplication-operator.md)</ept>, <bpt id=\"p4\">[</bpt><ph id=\"ph4\">/</ph><ept id=\"p4\">](../../../csharp/language-reference/operators/division-operator.md)</ept>, <bpt id=\"p5\">[</bpt><ph id=\"ph5\">%</ph><ept id=\"p5\">](../../../csharp/language-reference/operators/modulus-operator.md)</ept>, <bpt id=\"p6\">[</bpt><ph id=\"ph6\">&amp;</ph><ept id=\"p6\">](../../../csharp/language-reference/operators/and-operator.md)</ept>, <bpt id=\"p7\">[</bpt>&amp;#124;<ept id=\"p7\">](../../../csharp/language-reference/operators/or-operator.md)</ept>, <bpt id=\"p8\">[</bpt><ph id=\"ph7\">^</ph><ept id=\"p8\">](../../../csharp/language-reference/operators/xor-operator.md)</ept>, <bpt id=\"p9\">[</bpt><ph id=\"ph8\">&lt;</ph><ph id=\"ph9\">\\&lt;</ph><ept id=\"p9\">](../../../csharp/language-reference/operators/left-shift-operator.md)</ept>, <bpt id=\"p10\">[</bpt><ph id=\"ph10\">&gt;&gt;</ph><ept id=\"p10\">](../../../csharp/language-reference/operators/right-shift-operator.md)</ept>","source":"[+](../../../csharp/language-reference/operators/addition-operator.md), [-](../../../csharp/language-reference/operators/subtraction-operator.md), [*](../../../csharp/language-reference/operators/multiplication-operator.md), [/](../../../csharp/language-reference/operators/division-operator.md), [%](../../../csharp/language-reference/operators/modulus-operator.md), [&](../../../csharp/language-reference/operators/and-operator.md), [&#124;](../../../csharp/language-reference/operators/or-operator.md), [^](../../../csharp/language-reference/operators/xor-operator.md), [<\\<](../../../csharp/language-reference/operators/left-shift-operator.md), [>>](../../../csharp/language-reference/operators/right-shift-operator.md)"},{"content":"These binary operators can be overloaded.","pos":[2344,2385]},{"pos":[2390,2860],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">==</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/equality-comparison-operator.md)</ept>, <bpt id=\"p2\">[</bpt>!=<ept id=\"p2\">](../../../csharp/language-reference/operators/not-equal-operator.md)</ept>, <bpt id=\"p3\">[</bpt><ph id=\"ph2\">\\&lt;</ph><ept id=\"p3\">](../../../csharp/language-reference/operators/less-than-operator.md)</ept>, <bpt id=\"p4\">[</bpt><ph id=\"ph3\">&gt;</ph><ept id=\"p4\">](../../../csharp/language-reference/operators/greater-than-operator.md)</ept>, <bpt id=\"p5\">[</bpt><ph id=\"ph4\">\\&lt;</ph><ph id=\"ph5\">=</ph><ept id=\"p5\">](../../../csharp/language-reference/operators/less-than-equal-operator.md)</ept>, <bpt id=\"p6\">[</bpt><ph id=\"ph6\">&gt;=</ph><ept id=\"p6\">](../../../csharp/language-reference/operators/greater-than-equal-operator.md)</ept>","source":"[==](../../../csharp/language-reference/operators/equality-comparison-operator.md), [!=](../../../csharp/language-reference/operators/not-equal-operator.md), [\\<](../../../csharp/language-reference/operators/less-than-operator.md), [>](../../../csharp/language-reference/operators/greater-than-operator.md), [\\<=](../../../csharp/language-reference/operators/less-than-equal-operator.md), [>=](../../../csharp/language-reference/operators/greater-than-equal-operator.md)"},{"content":"The comparison operators can be overloaded (but see the note that follows this table).","pos":[2861,2947]},{"pos":[2952,3119],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">&amp;&amp;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/conditional-and-operator.md)</ept>, <bpt id=\"p2\">[</bpt>&amp;#124;&amp;#124;<ept id=\"p2\">](../../../csharp/language-reference/operators/conditional-or-operator.md)</ept>","source":"[&&](../../../csharp/language-reference/operators/conditional-and-operator.md), [&#124;&#124;](../../../csharp/language-reference/operators/conditional-or-operator.md)"},{"pos":[3120,3247],"content":"The conditional logical operators cannot be overloaded, but they are evaluated using <ph id=\"ph1\">`&amp;`</ph> and <ph id=\"ph2\">`&amp;#124;`</ph>, which can be overloaded.","source":"The conditional logical operators cannot be overloaded, but they are evaluated using `&` and `&#124;`, which can be overloaded."},{"pos":[3252,3328],"content":"<bpt id=\"p1\">[</bpt>&amp;#91;&amp;#93;<ept id=\"p1\">](../../../csharp/language-reference/operators/index-operator.md)</ept>","source":"[&#91;&#93;](../../../csharp/language-reference/operators/index-operator.md)"},{"content":"The array indexing operator cannot be overloaded, but you can define indexers.","pos":[3329,3407]},{"pos":[3412,3487],"content":"<bpt id=\"p1\">[</bpt>(T)x<ept id=\"p1\">](../../../csharp/language-reference/operators/invocation-operator.md)</ept>","source":"[(T)x](../../../csharp/language-reference/operators/invocation-operator.md)"},{"pos":[3488,3718],"content":"The cast operator cannot be overloaded, but you can define new conversion operators (see <bpt id=\"p1\">[</bpt>explicit<ept id=\"p1\">](../../../csharp/language-reference/keywords/explicit.md)</ept> and <bpt id=\"p2\">[</bpt>implicit<ept id=\"p2\">](../../../csharp/language-reference/keywords/implicit.md)</ept>).","source":"The cast operator cannot be overloaded, but you can define new conversion operators (see [explicit](../../../csharp/language-reference/keywords/explicit.md) and [implicit](../../../csharp/language-reference/keywords/implicit.md))."},{"pos":[3723,4566],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">+=</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/addition-assignment-operator.md)</ept>, <bpt id=\"p2\">[</bpt><ph id=\"ph2\">-=</ph><ept id=\"p2\">](../../../csharp/language-reference/operators/subtraction-assignment-operator.md)</ept>, <bpt id=\"p3\">[</bpt><ph id=\"ph3\">*=</ph><ept id=\"p3\">](../../../csharp/language-reference/operators/multiplication-assignment-operator.md)</ept>, <bpt id=\"p4\">[</bpt><ph id=\"ph4\">/=</ph><ept id=\"p4\">](../../../csharp/language-reference/operators/division-assignment-operator.md)</ept>, <bpt id=\"p5\">[</bpt><ph id=\"ph5\">%=</ph><ept id=\"p5\">](../../../csharp/language-reference/operators/modulus-assignment-operator.md)</ept>, <bpt id=\"p6\">[</bpt><ph id=\"ph6\">&amp;=</ph><ept id=\"p6\">](../../../csharp/language-reference/operators/and-assignment-operator.md)</ept>, <bpt id=\"p7\">[</bpt>&amp;#124;=<ept id=\"p7\">](../../../csharp/language-reference/operators/or-assignment-operator.md)</ept>, <bpt id=\"p8\">[</bpt><ph id=\"ph7\">^=</ph><ept id=\"p8\">](../../../csharp/language-reference/operators/xor-assignment-operator.md)</ept>, <bpt id=\"p9\">[</bpt><ph id=\"ph8\">&lt;</ph><ph id=\"ph9\">\\&lt;</ph><ph id=\"ph10\">=</ph><ept id=\"p9\">](../../../csharp/language-reference/operators/left-shift-assignment-operator.md)</ept>, <bpt id=\"p10\">[</bpt><ph id=\"ph11\">&gt;&gt;=</ph><ept id=\"p10\">](../../../csharp/language-reference/operators/right-shift-assignment-operator.md)</ept>","source":"[+=](../../../csharp/language-reference/operators/addition-assignment-operator.md), [-=](../../../csharp/language-reference/operators/subtraction-assignment-operator.md), [*=](../../../csharp/language-reference/operators/multiplication-assignment-operator.md), [/=](../../../csharp/language-reference/operators/division-assignment-operator.md), [%=](../../../csharp/language-reference/operators/modulus-assignment-operator.md), [&=](../../../csharp/language-reference/operators/and-assignment-operator.md), [&#124;=](../../../csharp/language-reference/operators/or-assignment-operator.md), [^=](../../../csharp/language-reference/operators/xor-assignment-operator.md), [<\\<=](../../../csharp/language-reference/operators/left-shift-assignment-operator.md), [>>=](../../../csharp/language-reference/operators/right-shift-assignment-operator.md)"},{"pos":[4567,4681],"content":"Assignment operators cannot be overloaded, but <ph id=\"ph1\">`+=`</ph>, for example, is evaluated using <ph id=\"ph2\">`+`</ph>, which can be overloaded.","source":"Assignment operators cannot be overloaded, but `+=`, for example, is evaluated using `+`, which can be overloaded."},{"pos":[4686,5848],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">=</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/assignment-operator.md)</ept>, <bpt id=\"p2\">[</bpt>.<ept id=\"p2\">](../../../csharp/language-reference/operators/member-access-operator.md)</ept>, <bpt id=\"p3\">[</bpt>?:<ept id=\"p3\">](../../../csharp/language-reference/operators/conditional-operator.md)</ept>, <bpt id=\"p4\">[</bpt>??<ept id=\"p4\">](../../../csharp/language-reference/operators/null-conditional-operator.md)</ept>, <bpt id=\"p5\">[</bpt><ph id=\"ph2\">-&gt;</ph><ept id=\"p5\">](../../../csharp/language-reference/operators/dereference-operator.md)</ept>, <bpt id=\"p6\">[</bpt><ph id=\"ph3\">=&gt;</ph><ept id=\"p6\">](../../../csharp/language-reference/operators/lambda-operator.md)</ept>, <bpt id=\"p7\">[</bpt>f(x)<ept id=\"p7\">](../../../csharp/language-reference/operators/invocation-operator.md)</ept>, <bpt id=\"p8\">[</bpt>as<ept id=\"p8\">](../../../csharp/language-reference/keywords/as.md)</ept>, <bpt id=\"p9\">[</bpt>checked<ept id=\"p9\">](../../../csharp/language-reference/keywords/checked.md)</ept>, <bpt id=\"p10\">[</bpt>unchecked<ept id=\"p10\">](../../../csharp/language-reference/keywords/unchecked.md)</ept>, <bpt id=\"p11\">[</bpt>default<ept id=\"p11\">](../../../csharp/programming-guide/generics/default-keyword-in-generic-code.md)</ept>, <bpt id=\"p12\">[</bpt>delegate<ept id=\"p12\">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>, <bpt id=\"p13\">[</bpt>is<ept id=\"p13\">](../../../csharp/language-reference/keywords/is.md)</ept>, <bpt id=\"p14\">[</bpt>new<ept id=\"p14\">](../../../csharp/language-reference/keywords/new.md)</ept>, <bpt id=\"p15\">[</bpt>sizeof<ept id=\"p15\">](../../../csharp/language-reference/keywords/sizeof.md)</ept>, <bpt id=\"p16\">[</bpt>typeof<ept id=\"p16\">](../../../csharp/language-reference/keywords/typeof.md)</ept>","source":"[=](../../../csharp/language-reference/operators/assignment-operator.md), [.](../../../csharp/language-reference/operators/member-access-operator.md), [?:](../../../csharp/language-reference/operators/conditional-operator.md), [??](../../../csharp/language-reference/operators/null-conditional-operator.md), [->](../../../csharp/language-reference/operators/dereference-operator.md), [=>](../../../csharp/language-reference/operators/lambda-operator.md), [f(x)](../../../csharp/language-reference/operators/invocation-operator.md), [as](../../../csharp/language-reference/keywords/as.md), [checked](../../../csharp/language-reference/keywords/checked.md), [unchecked](../../../csharp/language-reference/keywords/unchecked.md), [default](../../../csharp/programming-guide/generics/default-keyword-in-generic-code.md), [delegate](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md), [is](../../../csharp/language-reference/keywords/is.md), [new](../../../csharp/language-reference/keywords/new.md), [sizeof](../../../csharp/language-reference/keywords/sizeof.md), [typeof](../../../csharp/language-reference/keywords/typeof.md)"},{"content":"These operators cannot be overloaded.","pos":[5849,5886]},{"pos":[5895,6115],"content":"[!NOTE]\n The comparison operators, if overloaded, must be overloaded in pairs; that is, if `==` is overloaded, `!=` must also be overloaded. The reverse is also true, and similar for `<` and `>`, and for `<=` and `>=`.","leadings":["","> "],"nodes":[{"content":" The comparison operators, if overloaded, must be overloaded in pairs; that is, if `==` is overloaded, `!=` must also be overloaded. The reverse is also true, and similar for `<` and `>`, and for `<=` and `>=`.","pos":[8,218],"nodes":[{"content":"The comparison operators, if overloaded, must be overloaded in pairs; that is, if <ph id=\"ph1\">`==`</ph> is overloaded, <ph id=\"ph2\">`!=`</ph> must also be overloaded.","pos":[1,132],"source":" The comparison operators, if overloaded, must be overloaded in pairs; that is, if `==` is overloaded, `!=` must also be overloaded."},{"content":"The reverse is also true, and similar for <ph id=\"ph1\">`&lt;`</ph> and <ph id=\"ph2\">`&gt;`</ph>, and for <ph id=\"ph3\">`&lt;=`</ph> and <ph id=\"ph4\">`&gt;=`</ph>.","pos":[133,210],"source":" The reverse is also true, and similar for `<` and `>`, and for `<=` and `>=`."}]}]},{"content":"To overload an operator on a custom class requires creating a method on the class with the correct signature.","pos":[6122,6231]},{"content":"The method must be named \"operator X\" where X is the name or symbol of the operator being overloaded.","pos":[6232,6333]},{"content":"Unary operators have one parameter, and binary operators have two parameters.","pos":[6334,6411]},{"content":"In each case, one parameter must be the same type as the class or struct that declares the operator.","pos":[6412,6512]},{"content":"It is common to have definitions that simply return immediately with the result of an expression.","pos":[6696,6793]},{"content":"There is a syntax shortcut using <ph id=\"ph1\">`=&gt;`</ph> for these situations.","pos":[6795,6854],"source":"  There is a syntax shortcut using `=>` for these situations."},{"pos":[7193,7423],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Use Operator Overloading to Create a Complex Number Class<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/how-to-use-operator-overloading-to-create-a-complex-number-class.md)</ept>.","source":"For more information, see [How to: Use Operator Overloading to Create a Complex Number Class](../../../csharp/programming-guide/statements-expressions-operators/how-to-use-operator-overloading-to-create-a-complex-number-class.md)."},{"pos":[7432,7440],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[7444,7511],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Statements, Expressions, and Operators<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[7514,7633],"source":" [Statements, Expressions, and Operators](../../../csharp/programming-guide/statements-expressions-operators/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Operators<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/operators.md)</ept><ph id=\"ph1\"> </ph>","pos":[7636,7730],"source":" [Operators](../../../csharp/programming-guide/statements-expressions-operators/operators.md) "},{"content":"<bpt id=\"p1\"> [</bpt>C# Operators<ept id=\"p1\">](../../../csharp/language-reference/operators/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[7733,7804],"source":" [C# Operators](../../../csharp/language-reference/operators/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Why are overloaded operators always static in C#?<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=112383)</ept>","pos":[7807,7906],"source":" [Why are overloaded operators always static in C#?](http://go.microsoft.com/fwlink/?LinkId=112383)"}]}