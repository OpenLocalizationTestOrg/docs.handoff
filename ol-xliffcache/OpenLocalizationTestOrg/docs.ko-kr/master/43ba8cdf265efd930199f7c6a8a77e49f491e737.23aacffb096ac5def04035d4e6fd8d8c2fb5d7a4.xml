{"content":"---\ntitle: \"Lambda Expressions (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2017-03-03\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"lambda expressions [C#]\"\n  - \"outer variables [C#]\"\n  - \"statement lambda [C#]\"\n  - \"expression lambda [C#]\"\n  - \"expressions [C#], lambda\"\nms.assetid: 57e3ba27-9a82-4067-aca7-5ca446b7bf93\ncaps.latest.revision: 64\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Lambda Expressions (C# Programming Guide)\nA lambda expression is an [anonymous function](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md) that you can use to create [delegates](../../../csharp/programming-guide/delegates/using-delegates.md) or [expression tree](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b) types. By using lambda expressions, you can write local functions that can be passed as arguments or returned as the value of function calls. Lambda expressions are particularly helpful for writing LINQ query expressions.  \n  \n To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator [=>](../../../csharp/language-reference/operators/lambda-operator.md), and you put the expression or statement block on the other side. For example, the lambda expression `x => x * x` specifies a parameter that’s named `x` and returns the value of `x` squared. You can assign this expression to a delegate type, as the following example shows:  \n  \n```csharp  \ndelegate int del(int i);  \nstatic void Main(string[] args)  \n{  \n    del myDelegate = x => x * x;  \n    int j = myDelegate(5); //j = 25  \n}  \n```  \n  \n To create an expression tree type:  \n  \n```csharp  \nusing System.Linq.Expressions;  \n  \nnamespace ConsoleApplication1  \n{  \n    class Program  \n    {  \n        static void Main(string[] args)  \n        {  \n            Expression<del> myET = x => x * x;  \n        }  \n    }  \n}  \n```  \n  \n The `=>` operator has the same precedence as assignment (`=`) and is [right associative](../../../csharp/programming-guide/statements-expressions-operators/operators.md) (see \"Associativity\" section of the Operators article).  \n  \n Lambdas are used in method-based [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)] queries as arguments to standard query operator methods such as <xref:System.Linq.Enumerable.Where%2A>.  \n  \n When you use method-based syntax to call the <xref:System.Linq.Enumerable.Where%2A> method in the <xref:System.Linq.Enumerable> class (as you do in [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)] to Objects and [!INCLUDE[sqltecxlinq](../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]) the parameter is a delegate type <xref:System.Func%602?displayProperty=fullName>. A lambda expression is the most convenient way to create that delegate. When you call the same method in, for example, the <xref:System.Linq.Queryable?displayProperty=fullName> class (as you do in [!INCLUDE[vbtecdlinq](../../../csharp/includes/vbtecdlinq_md.md)]) then the parameter type is an <xref:System.Linq.Expressions.Expression?displayProperty=fullName><Func\\> where Func is any of the Func delegates with up to sixteen input parameters. Again, a lambda expression is just a very concise way to construct that expression tree. The lambdas allow the `Where` calls to look similar although in fact the type of object created from the lambda is different.  \n  \n In the previous example, notice that the delegate signature has one implicitly-typed input parameter of type `int`, and returns an `int`. The lambda expression can be converted to a delegate of that type because it also has one input parameter (`x`) and a return value that the compiler can implicitly convert to type `int`. (Type inference is discussed in more detail in the following sections.) When the delegate is invoked by using an input parameter of 5, it returns a result of 25.  \n  \n Lambdas are not allowed on the left side of the [is](../../../csharp/language-reference/keywords/is.md) or [as](../../../csharp/language-reference/keywords/as.md) operator.  \n  \n All restrictions that apply to anonymous methods also apply to lambda expressions. For more information, see [Anonymous Methods](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md).  \n  \n## Expression Lambdas  \n A lambda expression with an expression on the right side of the => operator is called an *expression lambda*. Expression lambdas are used extensively in the construction of [Expression Trees](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b). An expression lambda returns the result of the expression and takes the following basic form:  \n  \n```csharp\n(input-parameters) => expression\n```\n\n The parentheses are optional only if the lambda has one input parameter; otherwise they are required. Two or more input parameters are separated by commas enclosed in parentheses:  \n  \n```csharp\n(x, y) => x == y\n```\n\n Sometimes it is difficult or impossible for the compiler to infer the input types. When this occurs, you can specify the types explicitly as shown in the following example:  \n  \n```csharp\n(int x, string s) => s.Length > x\n```\n\n Specify zero input parameters with empty parentheses:  \n  \n```csharp\n() => SomeMethod()\n```\n\n Note in the previous example that the body of an expression lambda can consist of a method call. However, if you are creating expression trees that are evaluated outside of the .NET Framework, such as in SQL Server, you should not use method calls in lambda expressions. The methods will have no meaning outside the context of the .NET common language runtime.  \n  \n## Statement Lambdas  \n A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:  \n  \n(input-parameters) => { statement; }\n\n The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.  \n  \n[!code-csharp[StatementLamba#1](../../../../samples\\snippets\\csharp\\programming-guide\\lambda-expressions/statements.cs#1)]\n\n[!code-csharp[StatementLamba#2](../../../../samples\\snippets\\csharp\\programming-guide\\lambda-expressions/statements.cs#2)]\n\n Statement lambdas, like anonymous methods, cannot be used to create expression trees.  \n  \n## Async Lambdas  \n You can easily create lambda expressions and statements that incorporate asynchronous processing by using the [async](../../../csharp/language-reference/keywords/async.md) and [await](../../../csharp/language-reference/keywords/await.md) keywords. For example, the following Windows Forms example contains an event handler that calls and awaits an async method, `ExampleMethodAsync`.  \n  \n```csharp\npublic partial class Form1 : Form  \n{  \n    public Form1()  \n    {  \n        InitializeComponent();  \n    }  \n  \n    private async void button1_Click(object sender, EventArgs e)  \n    {  \n        // ExampleMethodAsync returns a Task.  \n        await ExampleMethodAsync();  \n        textBox1.Text += \"\\r\\nControl returned to Click event handler.\\n\";  \n    }  \n  \n    async Task ExampleMethodAsync()  \n    {  \n        // The following line simulates a task-returning asynchronous process.  \n        await Task.Delay(1000);  \n    }  \n}  \n```\n\n You can add the same event handler by using an async lambda. To add this handler, add an `async` modifier before the lambda parameter list, as the following example shows.  \n  \n```csharp  \npublic partial class Form1 : Form  \n{  \n    public Form1()  \n    {  \n        InitializeComponent();  \n        button1.Click += async (sender, e) =>  \n        {  \n            // ExampleMethodAsync returns a Task.  \n            await ExampleMethodAsync();  \n            textBox1.Text += \"\\nControl returned to Click event handler.\\n\";  \n        };  \n    }  \n  \n    async Task ExampleMethodAsync()  \n    {  \n        // The following line simulates a task-returning asynchronous process.  \n        await Task.Delay(1000);  \n    }  \n}  \n```  \n\n For more information about how to create and use async methods, see [Asynchronous Programming with async and await](../../../csharp/programming-guide/concepts/async/index.md).  \n  \n## Lambdas with the Standard Query Operators  \n Many Standard query operators have an input parameter whose type is one of the <xref:System.Func%602> family of generic delegates. These delegates use type parameters to define the number and types of input parameters, and the return type of the delegate. `Func` delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data. For example, consider the following delegate type:  \n  \n```csharp  \npublic delegate TResult Func<TArg0, TResult>(TArg0 arg0)  \n```  \n  \n The delegate can be instantiated as `Func<int,bool> myFunc` where `int` is an input parameter and `bool` is the return value. The return value is always specified in the last type parameter. `Func<int, string, bool>` defines a delegate with two input parameters, `int` and `string`, and a return type of `bool`. The following `Func` delegate, when it is invoked, will return true or false to indicate whether the input parameter is equal to 5:  \n  \n```csharp  \nFunc<int, bool> myFunc = x => x == 5;  \nbool result = myFunc(4); // returns false of course  \n```  \n  \n You can also supply a lambda expression when the argument type is an `Expression<Func>`, for example in the standard query operators that are defined in System.Linq.Queryable. When you specify an `Expression<Func>` argument, the lambda will be compiled to an expression tree.  \n  \n A standard query operator, the <xref:System.Linq.Enumerable.Count%2A> method, is shown here:  \n  \n```csharp  \nint[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };  \nint oddNumbers = numbers.Count(n => n % 2 == 1);  \n```  \n  \n The compiler can infer the type of the input parameter, or you can also specify it explicitly. This particular lambda expression counts those integers (`n`) which when divided by two have a remainder of 1.  \n  \n The following line of code produces a sequence that contains all elements in the `numbers` array that are to the left side of the 9 because that's the first number in the sequence that doesn't meet the condition:  \n  \n```csharp  \nvar firstNumbersLessThan6 = numbers.TakeWhile(n => n < 6);  \n```  \n  \n This example shows how to specify multiple input parameters by enclosing them in parentheses. The method returns all the elements in the numbers array until a number is encountered whose value is less than its position. Do not confuse the lambda operator (`=>`) with the greater than or equal operator (`>=`).  \n  \n```csharp  \nvar firstSmallNumbers = numbers.TakeWhile((n, index) => n >= index);  \n```  \n  \n## Type Inference in Lambdas  \n When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter’s delegate type, and other factors as described in the C# Language Specification. For most of the standard query operators, the first input is the type of the elements in the source sequence. So if you are querying an `IEnumerable<Customer>`, then the input variable is inferred to be a `Customer` object, which means you have access to its methods and properties:  \n  \n```csharp  \ncustomers.Where(c => c.City == \"London\");  \n```  \n  \n The general rules for lambdas are as follows:  \n  \n-   The lambda must contain the same number of parameters as the delegate type.  \n  \n-   Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.  \n  \n-   The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.  \n  \n Note that lambda expressions in themselves do not have a type because the common type system has no intrinsic concept of \"lambda expression.\" However, it is sometimes convenient to speak informally of the \"type\" of a lambda expression. In these cases the type refers to the delegate type or <xref:System.Linq.Expressions.Expression> type to which the lambda expression is converted.  \n  \n## Variable Scope in Lambda Expressions  \n Lambdas can refer to *outer variables* (see [Anonymous Methods](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression. Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected. An outer variable must be definitely assigned before it can be consumed in a lambda expression. The following example demonstrates these rules:  \n  \n```csharp  \ndelegate bool D();  \ndelegate bool D2(int i);  \n  \nclass Test  \n{  \n    D del;  \n    D2 del2;  \n    public void TestMethod(int input)  \n    {  \n        int j = 0;  \n        // Initialize the delegates with lambda expressions.  \n        // Note access to 2 outer variables.  \n        // del will be invoked within this method.  \n        del = () => { j = 10;  return j > input; };  \n  \n        // del2 will be invoked after TestMethod goes out of scope.  \n        del2 = (x) => {return x == j; };  \n  \n        // Demonstrate value of j:  \n        // Output: j = 0   \n        // The delegate has not been invoked yet.  \n        Console.WriteLine(\"j = {0}\", j);        // Invoke the delegate.  \n        bool boolResult = del();  \n  \n        // Output: j = 10 b = True  \n        Console.WriteLine(\"j = {0}. b = {1}\", j, boolResult);  \n    }  \n  \n    static void Main()  \n    {  \n        Test test = new Test();  \n        test.TestMethod(5);  \n  \n        // Prove that del2 still has a copy of  \n        // local variable j from TestMethod.  \n        bool result = test.del2(10);  \n  \n        // Output: True  \n        Console.WriteLine(result);  \n  \n        Console.ReadKey();  \n    }  \n}  \n  \n```  \n  \n The following rules apply to variable scope in lambda expressions:  \n  \n-   A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.  \n  \n-   Variables introduced within a lambda expression are not visible in the outer method.  \n  \n-   A lambda expression cannot directly capture a `ref` or `out` parameter from an enclosing method.  \n  \n-   A return statement in a lambda expression does not cause the enclosing method to return.  \n  \n-   A lambda expression cannot contain a `goto` statement, `break` statement, or `continue` statement that is inside the lambda function if the jump statement’s target is outside the block. It is also an error to have a jump statement outside the lambda function block if the target is inside the block.  \n  \n## C# Language Specification  \n [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n## Featured Book Chapter  \n [Delegates, Events, and Lambda Expressions](http://go.microsoft.com/fwlink/?LinkId=195395) in [C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers](http://go.microsoft.com/fwlink/?LinkId=195369)  \n  \n## See Also  \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [LINQ (Language-Integrated Query)](http://msdn.microsoft.com/library/a73c4aec-5d15-4e98-b962-1274021ea93d)   \n [Anonymous Methods](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)   \n [is](../../../csharp/language-reference/keywords/is.md)   \n [Expression Trees](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)   \n [Visual Studio 2008 C# Samples (see LINQ Sample Queries files and XQuery program)](http://code.msdn.microsoft.com/Visual-Studio-2008-C-d295cdba)   \n [Recursive lambda expressions](http://go.microsoft.com/fwlink/?LinkId=112395)","nodes":[{"pos":[12,70],"content":"Lambda Expressions (C# Programming Guide) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Lambda Expressions (C# Programming Guide) | Microsoft Docs","pos":[0,58]}]},{"pos":[691,732],"content":"Lambda Expressions (C# Programming Guide)","linkify":"Lambda Expressions (C# Programming Guide)","nodes":[{"content":"Lambda Expressions (C# Programming Guide)","pos":[0,41]}]},{"content":"A lambda expression is an <bpt id=\"p1\">[</bpt>anonymous function<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept> that you can use to create <bpt id=\"p2\">[</bpt>delegates<ept id=\"p2\">](../../../csharp/programming-guide/delegates/using-delegates.md)</ept> or <bpt id=\"p3\">[</bpt>expression tree<ept id=\"p3\">](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)</ept> types.","pos":[733,1071],"source":"A lambda expression is an [anonymous function](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md) that you can use to create [delegates](../../../csharp/programming-guide/delegates/using-delegates.md) or [expression tree](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b) types."},{"content":"By using lambda expressions, you can write local functions that can be passed as arguments or returned as the value of function calls.","pos":[1072,1206]},{"content":"Lambda expressions are particularly helpful for writing LINQ query expressions.","pos":[1207,1286]},{"content":"To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator <bpt id=\"p1\">[</bpt><ph id=\"ph1\">=&gt;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/lambda-operator.md)</ept>, and you put the expression or statement block on the other side.","pos":[1293,1537],"source":"To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator [=>](../../../csharp/language-reference/operators/lambda-operator.md), and you put the expression or statement block on the other side."},{"content":"For example, the lambda expression <ph id=\"ph1\">`x =&gt; x * x`</ph> specifies a parameter that’s named <ph id=\"ph2\">`x`</ph> and returns the value of <ph id=\"ph3\">`x`</ph> squared.","pos":[1538,1662],"source":" For example, the lambda expression `x => x * x` specifies a parameter that’s named `x` and returns the value of `x` squared."},{"content":"You can assign this expression to a delegate type, as the following example shows:","pos":[1663,1745]},{"content":"To create an expression tree type:","pos":[1915,1949]},{"pos":[2204,2429],"content":"The <ph id=\"ph1\">`=&gt;`</ph> operator has the same precedence as assignment (<ph id=\"ph2\">`=`</ph>) and is <bpt id=\"p1\">[</bpt>right associative<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/operators.md)</ept> (see \"Associativity\" section of the Operators article).","source":"The `=>` operator has the same precedence as assignment (`=`) and is [right associative](../../../csharp/programming-guide/statements-expressions-operators/operators.md) (see \"Associativity\" section of the Operators article)."},{"pos":[2436,2636],"content":"Lambdas are used in method-based <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)]</ph> queries as arguments to standard query operator methods such as <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph>.","source":"Lambdas are used in method-based [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)] queries as arguments to standard query operator methods such as <xref:System.Linq.Enumerable.Where%2A>."},{"content":"When you use method-based syntax to call the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method in the <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable&gt;</ph> class (as you do in <ph id=\"ph3\">[!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)]</ph> to Objects and <ph id=\"ph4\">[!INCLUDE[sqltecxlinq](../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>) the parameter is a delegate type <ph id=\"ph5\">&lt;xref:System.Func%602?displayProperty=fullName&gt;</ph>.","pos":[2643,3052],"source":"When you use method-based syntax to call the <xref:System.Linq.Enumerable.Where%2A> method in the <xref:System.Linq.Enumerable> class (as you do in [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)] to Objects and [!INCLUDE[sqltecxlinq](../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]) the parameter is a delegate type <xref:System.Func%602?displayProperty=fullName>."},{"content":"A lambda expression is the most convenient way to create that delegate.","pos":[3053,3124]},{"content":"When you call the same method in, for example, the <ph id=\"ph1\">&lt;xref:System.Linq.Queryable?displayProperty=fullName&gt;</ph> class (as you do in <ph id=\"ph2\">[!INCLUDE[vbtecdlinq](../../../csharp/includes/vbtecdlinq_md.md)]</ph>) then the parameter type is an <ph id=\"ph3\">&lt;xref:System.Linq.Expressions.Expression?displayProperty=fullName&gt;</ph>&lt;Func<ph id=\"ph4\">\\&gt;</ph> where Func is any of the Func delegates with up to sixteen input parameters.","pos":[3125,3497],"source":" When you call the same method in, for example, the <xref:System.Linq.Queryable?displayProperty=fullName> class (as you do in [!INCLUDE[vbtecdlinq](../../../csharp/includes/vbtecdlinq_md.md)]) then the parameter type is an <xref:System.Linq.Expressions.Expression?displayProperty=fullName><Func\\> where Func is any of the Func delegates with up to sixteen input parameters."},{"content":"Again, a lambda expression is just a very concise way to construct that expression tree.","pos":[3498,3586]},{"content":"The lambdas allow the <ph id=\"ph1\">`Where`</ph> calls to look similar although in fact the type of object created from the lambda is different.","pos":[3587,3712],"source":" The lambdas allow the `Where` calls to look similar although in fact the type of object created from the lambda is different."},{"content":"In the previous example, notice that the delegate signature has one implicitly-typed input parameter of type <ph id=\"ph1\">`int`</ph>, and returns an <ph id=\"ph2\">`int`</ph>.","pos":[3719,3856],"source":"In the previous example, notice that the delegate signature has one implicitly-typed input parameter of type `int`, and returns an `int`."},{"content":"The lambda expression can be converted to a delegate of that type because it also has one input parameter (<ph id=\"ph1\">`x`</ph>) and a return value that the compiler can implicitly convert to type <ph id=\"ph2\">`int`</ph>.","pos":[3857,4043],"source":" The lambda expression can be converted to a delegate of that type because it also has one input parameter (`x`) and a return value that the compiler can implicitly convert to type `int`."},{"content":"(Type inference is discussed in more detail in the following sections.) When the delegate is invoked by using an input parameter of 5, it returns a result of 25.","pos":[4044,4205]},{"pos":[4212,4384],"content":"Lambdas are not allowed on the left side of the <bpt id=\"p1\">[</bpt>is<ept id=\"p1\">](../../../csharp/language-reference/keywords/is.md)</ept> or <bpt id=\"p2\">[</bpt>as<ept id=\"p2\">](../../../csharp/language-reference/keywords/as.md)</ept> operator.","source":"Lambdas are not allowed on the left side of the [is](../../../csharp/language-reference/keywords/is.md) or [as](../../../csharp/language-reference/keywords/as.md) operator."},{"content":"All restrictions that apply to anonymous methods also apply to lambda expressions.","pos":[4391,4473]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Anonymous Methods<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>.","pos":[4474,4609],"source":" For more information, see [Anonymous Methods](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)."},{"pos":[4618,4636],"content":"Expression Lambdas","linkify":"Expression Lambdas","nodes":[{"content":"Expression Lambdas","pos":[0,18]}]},{"content":"A lambda expression with an expression on the right side of the =&gt; operator is called an <bpt id=\"p1\">*</bpt>expression lambda<ept id=\"p1\">*</ept>.","pos":[4640,4749],"source":"A lambda expression with an expression on the right side of the => operator is called an *expression lambda*."},{"content":"Expression lambdas are used extensively in the construction of <bpt id=\"p1\">[</bpt>Expression Trees<ept id=\"p1\">](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)</ept>.","pos":[4750,4904],"source":" Expression lambdas are used extensively in the construction of [Expression Trees](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)."},{"content":"An expression lambda returns the result of the expression and takes the following basic form:","pos":[4905,4998]},{"content":"The parentheses are optional only if the lambda has one input parameter; otherwise they are required.","pos":[5053,5154]},{"content":"Two or more input parameters are separated by commas enclosed in parentheses:","pos":[5155,5232]},{"content":"Sometimes it is difficult or impossible for the compiler to infer the input types.","pos":[5271,5353]},{"content":"When this occurs, you can specify the types explicitly as shown in the following example:","pos":[5354,5443]},{"content":"Specify zero input parameters with empty parentheses:","pos":[5499,5552]},{"content":"Note in the previous example that the body of an expression lambda can consist of a method call.","pos":[5593,5689]},{"content":"However, if you are creating expression trees that are evaluated outside of the .NET Framework, such as in SQL Server, you should not use method calls in lambda expressions.","pos":[5690,5863]},{"content":"The methods will have no meaning outside the context of the .NET common language runtime.","pos":[5864,5953]},{"pos":[5962,5979],"content":"Statement Lambdas","linkify":"Statement Lambdas","nodes":[{"content":"Statement Lambdas","pos":[0,17]}]},{"content":"A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:","pos":[5983,6084]},{"content":"(input-parameters) =&gt; { statement; }","pos":[6090,6126],"source":"(input-parameters) => { statement; }"},{"content":"The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.","pos":[6129,6268]},{"pos":[6274,6396],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>StatementLamba#1<ept id=\"p2\">](../../../../samples\\snippets\\csharp\\programming-guide\\lambda-expressions/statements.cs#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[StatementLamba#1](../../../../samples\\snippets\\csharp\\programming-guide\\lambda-expressions/statements.cs#1)]"},{"pos":[6398,6520],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>StatementLamba#2<ept id=\"p2\">](../../../../samples\\snippets\\csharp\\programming-guide\\lambda-expressions/statements.cs#2)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[StatementLamba#2](../../../../samples\\snippets\\csharp\\programming-guide\\lambda-expressions/statements.cs#2)]"},{"content":"Statement lambdas, like anonymous methods, cannot be used to create expression trees.","pos":[6523,6608]},{"pos":[6617,6630],"content":"Async Lambdas","linkify":"Async Lambdas","nodes":[{"content":"Async Lambdas","pos":[0,13]}]},{"content":"You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](../../../csharp/language-reference/keywords/async.md)</ept> and <bpt id=\"p2\">[</bpt>await<ept id=\"p2\">](../../../csharp/language-reference/keywords/await.md)</ept> keywords.","pos":[6634,6881],"source":"You can easily create lambda expressions and statements that incorporate asynchronous processing by using the [async](../../../csharp/language-reference/keywords/async.md) and [await](../../../csharp/language-reference/keywords/await.md) keywords."},{"content":"For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <ph id=\"ph1\">`ExampleMethodAsync`</ph>.","pos":[6882,7017],"source":" For example, the following Windows Forms example contains an event handler that calls and awaits an async method, `ExampleMethodAsync`."},{"content":"You can add the same event handler by using an async lambda.","pos":[7574,7634]},{"content":"To add this handler, add an <ph id=\"ph1\">`async`</ph> modifier before the lambda parameter list, as the following example shows.","pos":[7635,7745],"source":" To add this handler, add an `async` modifier before the lambda parameter list, as the following example shows."},{"pos":[8303,8478],"content":"For more information about how to create and use async methods, see <bpt id=\"p1\">[</bpt>Asynchronous Programming with async and await<ept id=\"p1\">](../../../csharp/programming-guide/concepts/async/index.md)</ept>.","source":"For more information about how to create and use async methods, see [Asynchronous Programming with async and await](../../../csharp/programming-guide/concepts/async/index.md)."},{"pos":[8487,8528],"content":"Lambdas with the Standard Query Operators","linkify":"Lambdas with the Standard Query Operators","nodes":[{"content":"Lambdas with the Standard Query Operators","pos":[0,41]}]},{"content":"Many Standard query operators have an input parameter whose type is one of the <ph id=\"ph1\">&lt;xref:System.Func%602&gt;</ph> family of generic delegates.","pos":[8532,8662],"source":"Many Standard query operators have an input parameter whose type is one of the <xref:System.Func%602> family of generic delegates."},{"content":"These delegates use type parameters to define the number and types of input parameters, and the return type of the delegate.","pos":[8663,8787]},{"content":"<ph id=\"ph1\">`Func`</ph> delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data.","pos":[8788,8921],"source":"`Func` delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data."},{"content":"For example, consider the following delegate type:","pos":[8922,8972]},{"content":"The delegate can be instantiated as <ph id=\"ph1\">`Func&lt;int,bool&gt; myFunc`</ph> where <ph id=\"ph2\">`int`</ph> is an input parameter and <ph id=\"ph3\">`bool`</ph> is the return value.","pos":[9059,9184],"source":"The delegate can be instantiated as `Func<int,bool> myFunc` where `int` is an input parameter and `bool` is the return value."},{"content":"The return value is always specified in the last type parameter.","pos":[9185,9249]},{"content":"<ph id=\"ph1\">`Func&lt;int, string, bool&gt;`</ph> defines a delegate with two input parameters, <ph id=\"ph2\">`int`</ph> and <ph id=\"ph3\">`string`</ph>, and a return type of <ph id=\"ph4\">`bool`</ph>.","pos":[9250,9370],"source":"`Func<int, string, bool>` defines a delegate with two input parameters, `int` and `string`, and a return type of `bool`."},{"content":"The following <ph id=\"ph1\">`Func`</ph> delegate, when it is invoked, will return true or false to indicate whether the input parameter is equal to 5:","pos":[9371,9502],"source":" The following `Func` delegate, when it is invoked, will return true or false to indicate whether the input parameter is equal to 5:"},{"content":"You can also supply a lambda expression when the argument type is an <ph id=\"ph1\">`Expression&lt;Func&gt;`</ph>, for example in the standard query operators that are defined in System.Linq.Queryable.","pos":[9624,9799],"source":"You can also supply a lambda expression when the argument type is an `Expression<Func>`, for example in the standard query operators that are defined in System.Linq.Queryable."},{"content":"When you specify an <ph id=\"ph1\">`Expression&lt;Func&gt;`</ph> argument, the lambda will be compiled to an expression tree.","pos":[9800,9899],"source":" When you specify an `Expression<Func>` argument, the lambda will be compiled to an expression tree."},{"content":"A standard query operator, the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Count%2A&gt;</ph> method, is shown here:","pos":[9906,9998],"source":"A standard query operator, the <xref:System.Linq.Enumerable.Count%2A> method, is shown here:"},{"content":"The compiler can infer the type of the input parameter, or you can also specify it explicitly.","pos":[10129,10223]},{"content":"This particular lambda expression counts those integers (<ph id=\"ph1\">`n`</ph>) which when divided by two have a remainder of 1.","pos":[10224,10334],"source":" This particular lambda expression counts those integers (`n`) which when divided by two have a remainder of 1."},{"pos":[10341,10553],"content":"The following line of code produces a sequence that contains all elements in the <ph id=\"ph1\">`numbers`</ph> array that are to the left side of the 9 because that's the first number in the sequence that doesn't meet the condition:","source":"The following line of code produces a sequence that contains all elements in the `numbers` array that are to the left side of the 9 because that's the first number in the sequence that doesn't meet the condition:"},{"content":"This example shows how to specify multiple input parameters by enclosing them in parentheses.","pos":[10642,10735]},{"content":"The method returns all the elements in the numbers array until a number is encountered whose value is less than its position.","pos":[10736,10861]},{"content":"Do not confuse the lambda operator (<ph id=\"ph1\">`=&gt;`</ph>) with the greater than or equal operator (<ph id=\"ph2\">`&gt;=`</ph>).","pos":[10862,10951],"source":" Do not confuse the lambda operator (`=>`) with the greater than or equal operator (`>=`)."},{"pos":[11052,11077],"content":"Type Inference in Lambdas","linkify":"Type Inference in Lambdas","nodes":[{"content":"Type Inference in Lambdas","pos":[0,25]}]},{"content":"When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter’s delegate type, and other factors as described in the C# Language Specification.","pos":[11081,11329]},{"content":"For most of the standard query operators, the first input is the type of the elements in the source sequence.","pos":[11330,11439]},{"content":"So if you are querying an <ph id=\"ph1\">`IEnumerable&lt;Customer&gt;`</ph>, then the input variable is inferred to be a <ph id=\"ph2\">`Customer`</ph> object, which means you have access to its methods and properties:","pos":[11440,11612],"source":" So if you are querying an `IEnumerable<Customer>`, then the input variable is inferred to be a `Customer` object, which means you have access to its methods and properties:"},{"content":"The general rules for lambdas are as follows:","pos":[11684,11729]},{"content":"The lambda must contain the same number of parameters as the delegate type.","pos":[11739,11814]},{"content":"Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.","pos":[11824,11930]},{"content":"The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.","pos":[11940,12041]},{"content":"Note that lambda expressions in themselves do not have a type because the common type system has no intrinsic concept of \"lambda expression.\"","pos":[12048,12189]},{"content":"However, it is sometimes convenient to speak informally of the \"type\" of a lambda expression.","pos":[12190,12283]},{"content":"In these cases the type refers to the delegate type or <ph id=\"ph1\">&lt;xref:System.Linq.Expressions.Expression&gt;</ph> type to which the lambda expression is converted.","pos":[12284,12430],"source":" In these cases the type refers to the delegate type or <xref:System.Linq.Expressions.Expression> type to which the lambda expression is converted."},{"pos":[12439,12475],"content":"Variable Scope in Lambda Expressions","linkify":"Variable Scope in Lambda Expressions","nodes":[{"content":"Variable Scope in Lambda Expressions","pos":[0,36]}]},{"content":"Lambdas can refer to <bpt id=\"p1\">*</bpt>outer variables<ept id=\"p1\">*</ept> (see <bpt id=\"p2\">[</bpt>Anonymous Methods<ept id=\"p2\">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression.","pos":[12479,12759],"source":"Lambdas can refer to *outer variables* (see [Anonymous Methods](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression."},{"content":"Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected.","pos":[12760,12926]},{"content":"An outer variable must be definitely assigned before it can be consumed in a lambda expression.","pos":[12927,13022]},{"content":"The following example demonstrates these rules:","pos":[13023,13070]},{"content":"The following rules apply to variable scope in lambda expressions:","pos":[14288,14354]},{"content":"A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.","pos":[14364,14500]},{"content":"Variables introduced within a lambda expression are not visible in the outer method.","pos":[14510,14594]},{"pos":[14604,14700],"content":"A lambda expression cannot directly capture a <ph id=\"ph1\">`ref`</ph> or <ph id=\"ph2\">`out`</ph> parameter from an enclosing method.","source":"A lambda expression cannot directly capture a `ref` or `out` parameter from an enclosing method."},{"content":"A return statement in a lambda expression does not cause the enclosing method to return.","pos":[14710,14798]},{"content":"A lambda expression cannot contain a <ph id=\"ph1\">`goto`</ph> statement, <ph id=\"ph2\">`break`</ph> statement, or <ph id=\"ph3\">`continue`</ph> statement that is inside the lambda function if the jump statement’s target is outside the block.","pos":[14808,14993],"source":"A lambda expression cannot contain a `goto` statement, `break` statement, or `continue` statement that is inside the lambda function if the jump statement’s target is outside the block."},{"content":"It is also an error to have a jump statement outside the lambda function block if the target is inside the block.","pos":[14994,15107]},{"pos":[15116,15141],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[15255,15276],"content":"Featured Book Chapter","linkify":"Featured Book Chapter","nodes":[{"content":"Featured Book Chapter","pos":[0,21]}]},{"pos":[15280,15501],"content":"<bpt id=\"p1\">[</bpt>Delegates, Events, and Lambda Expressions<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=195395)</ept> in <bpt id=\"p2\">[</bpt>C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkId=195369)</ept>","source":"[Delegates, Events, and Lambda Expressions](http://go.microsoft.com/fwlink/?LinkId=195395) in [C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers](http://go.microsoft.com/fwlink/?LinkId=195369)"},{"pos":[15510,15518],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[15522,15589],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>LINQ (Language-Integrated Query)<ept id=\"p1\">](http://msdn.microsoft.com/library/a73c4aec-5d15-4e98-b962-1274021ea93d)</ept><ph id=\"ph1\"> </ph>","pos":[15592,15700],"source":" [LINQ (Language-Integrated Query)](http://msdn.microsoft.com/library/a73c4aec-5d15-4e98-b962-1274021ea93d) "},{"content":"<bpt id=\"p1\"> [</bpt>Anonymous Methods<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept><ph id=\"ph1\"> </ph>","pos":[15703,15813],"source":" [Anonymous Methods](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md) "},{"content":"<bpt id=\"p1\"> [</bpt>is<ept id=\"p1\">](../../../csharp/language-reference/keywords/is.md)</ept><ph id=\"ph1\"> </ph>","pos":[15816,15873],"source":" [is](../../../csharp/language-reference/keywords/is.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Expression Trees<ept id=\"p1\">](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)</ept><ph id=\"ph1\"> </ph>","pos":[15876,15968],"source":" [Expression Trees](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b) "},{"content":"<bpt id=\"p1\"> [</bpt>Visual Studio 2008 C# Samples (see LINQ Sample Queries files and XQuery program)<ept id=\"p1\">](http://code.msdn.microsoft.com/Visual-Studio-2008-C-d295cdba)</ept><ph id=\"ph1\"> </ph>","pos":[15971,16117],"source":" [Visual Studio 2008 C# Samples (see LINQ Sample Queries files and XQuery program)](http://code.msdn.microsoft.com/Visual-Studio-2008-C-d295cdba) "},{"content":"<bpt id=\"p1\"> [</bpt>Recursive lambda expressions<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=112395)</ept>","pos":[16120,16198],"source":" [Recursive lambda expressions](http://go.microsoft.com/fwlink/?LinkId=112395)"}]}