{"content":"---\ntitle: \"Property Design\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"member design guidelines, properties\"\n  - \"properties [.NET Framework], design guidelines\"\nms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163\nauthor: \"KrzysztofCwalina\"\n---\n# Property Design\nAlthough properties are technically very similar to methods, they are quite different in terms of their usage scenarios. They should be seen as smart fields. They have the calling syntax of fields, and the flexibility of methods.  \n  \n **✓ DO** create get-only properties if the caller should not be able to change the value of the property.  \n  \n Keep in mind that if the type of the property is a mutable reference type, the property value can be changed even if the property is get-only.  \n  \n **X DO NOT** provide set-only properties or properties with the setter having broader accessibility than the getter.  \n  \n For example, do not use properties with a public setter and a protected getter.  \n  \n If the property getter cannot be provided, implement the functionality as a method instead. Consider starting the method name with `Set` and follow with what you would have named the property. For example, <xref:System.AppDomain> has a method called `SetCachePath` instead of having a set-only property called `CachePath`.  \n  \n **✓ DO** provide sensible default values for all properties, ensuring that the defaults do not result in a security hole or terribly inefficient code.  \n  \n **✓ DO** allow properties to be set in any order even if this results in a temporary invalid state of the object.  \n  \n It is common for two or more properties to be interrelated to a point where some values of one property might be invalid given the values of other properties on the same object. In such cases, exceptions resulting from the invalid state should be postponed until the interrelated properties are actually used together by the object.  \n  \n **✓ DO** preserve the previous value if a property setter throws an exception.  \n  \n **X AVOID** throwing exceptions from property getters.  \n  \n Property getters should be simple operations and should not have any preconditions. If a getter can throw an exception, it should probably be redesigned to be a method. Notice that this rule does not apply to indexers, where we do expect exceptions as a result of validating the arguments.  \n  \n### Indexed Property Design  \n An indexed property is a special property that can have parameters and can be called with special syntax similar to array indexing.  \n  \n Indexed properties are commonly referred to as indexers. Indexers should be used only in APIs that provide access to items in a logical collection. For example, a string is a collection of characters, and the indexer on <xref:System.String?displayProperty=nameWithType> was added to access its characters.  \n  \n **✓ CONSIDER** using indexers to provide access to data stored in an internal array.  \n  \n **✓ CONSIDER** providing indexers on types representing collections of items.  \n  \n **X AVOID** using indexed properties with more than one parameter.  \n  \n If the design requires multiple parameters, reconsider whether the property really represents an accessor to a logical collection. If it does not, use methods instead. Consider starting the method name with `Get` or `Set`.  \n  \n **X AVOID** indexers with parameter types other than <xref:System.Int32?displayProperty=nameWithType>, <xref:System.Int64?displayProperty=nameWithType>, <xref:System.String?displayProperty=nameWithType>, <xref:System.Object?displayProperty=nameWithType>, or an enum.  \n  \n If the design requires other types of parameters, strongly reevaluate whether the API really represents an accessor to a logical collection. If it does not, use a method. Consider starting the method name with `Get` or `Set`.  \n  \n **✓ DO** use the name `Item` for indexed properties unless there is an obviously better name (e.g., see the <xref:System.String.Chars%2A> property on `System.String`).  \n  \n In C#, indexers are by default named Item. The <xref:System.Runtime.CompilerServices.IndexerNameAttribute> can be used to customize this name.  \n  \n **X DO NOT** provide both an indexer and methods that are semantically equivalent.  \n  \n **X DO NOT** provide more than one family of overloaded indexers in one type.  \n  \n This is enforced by the C# compiler.  \n  \n **X DO NOT** use nondefault indexed properties.  \n  \n This is enforced by the C# compiler.  \n  \n### Property Change Notification Events  \n Sometimes it is useful to provide an event notifying the user of changes in a property value. For example, `System.Windows.Forms.Control` raises a `TextChanged` event after the value of its `Text` property has changed.  \n  \n **✓ CONSIDER** raising change notification events when property values in high-level APIs (usually designer components) are modified.  \n  \n If there is a good scenario for a user to know when a property of an object is changing, the object should raise a change notification event for the property.  \n  \n However, it is unlikely to be worth the overhead to raise such events for low-level APIs such as base types or collections. For example, <xref:System.Collections.Generic.List%601> would not raise such events when a new item is added to the list and the `Count` property changes.  \n  \n **✓ CONSIDER** raising change notification events when the value of a property changes via external forces.  \n  \n If a property value changes via some external force (in a way other than by calling methods on the object), raise events indicate to the developer that the value is changing and has changed. A good example is the `Text` property of a text box control. When the user types text in a `TextBox`, the property value automatically changes.  \n  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See also\n\n- [Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)\n- [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)\n","nodes":[{"pos":[4,275],"embed":true,"restype":"x-metadata","content":"title: \"Property Design\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"member design guidelines, properties\"\n  - \"properties [.NET Framework], design guidelines\"\nms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163\nauthor: \"KrzysztofCwalina\"","nodes":[{"content":"Property Design","nodes":[{"pos":[0,15],"content":"Property Design","nodes":[{"content":"Property Design","pos":[0,15]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[282,297],"content":"Property Design","linkify":"Property Design","nodes":[{"content":"Property Design","pos":[0,15]}]},{"content":"Although properties are technically very similar to methods, they are quite different in terms of their usage scenarios.","pos":[298,418]},{"content":"They should be seen as smart fields.","pos":[419,455]},{"content":"They have the calling syntax of fields, and the flexibility of methods.","pos":[456,527]},{"pos":[534,639],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> create get-only properties if the caller should not be able to change the value of the property.","source":"**✓ DO** create get-only properties if the caller should not be able to change the value of the property."},{"content":"Keep in mind that if the type of the property is a mutable reference type, the property value can be changed even if the property is get-only.","pos":[646,788]},{"pos":[795,911],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> provide set-only properties or properties with the setter having broader accessibility than the getter.","source":"**X DO NOT** provide set-only properties or properties with the setter having broader accessibility than the getter."},{"content":"For example, do not use properties with a public setter and a protected getter.","pos":[918,997]},{"content":"If the property getter cannot be provided, implement the functionality as a method instead.","pos":[1004,1095]},{"content":"Consider starting the method name with <ph id=\"ph1\">`Set`</ph> and follow with what you would have named the property.","pos":[1096,1196],"source":" Consider starting the method name with `Set` and follow with what you would have named the property."},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> has a method called <ph id=\"ph2\">`SetCachePath`</ph> instead of having a set-only property called <ph id=\"ph3\">`CachePath`</ph>.","pos":[1197,1326],"source":" For example, <xref:System.AppDomain> has a method called `SetCachePath` instead of having a set-only property called `CachePath`."},{"pos":[1333,1483],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> provide sensible default values for all properties, ensuring that the defaults do not result in a security hole or terribly inefficient code.","source":"**✓ DO** provide sensible default values for all properties, ensuring that the defaults do not result in a security hole or terribly inefficient code."},{"pos":[1490,1603],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> allow properties to be set in any order even if this results in a temporary invalid state of the object.","source":"**✓ DO** allow properties to be set in any order even if this results in a temporary invalid state of the object."},{"content":"It is common for two or more properties to be interrelated to a point where some values of one property might be invalid given the values of other properties on the same object.","pos":[1610,1787]},{"content":"In such cases, exceptions resulting from the invalid state should be postponed until the interrelated properties are actually used together by the object.","pos":[1788,1942]},{"pos":[1949,2027],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> preserve the previous value if a property setter throws an exception.","source":"**✓ DO** preserve the previous value if a property setter throws an exception."},{"pos":[2034,2088],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> throwing exceptions from property getters.","source":"**X AVOID** throwing exceptions from property getters."},{"content":"Property getters should be simple operations and should not have any preconditions.","pos":[2095,2178]},{"content":"If a getter can throw an exception, it should probably be redesigned to be a method.","pos":[2179,2263]},{"content":"Notice that this rule does not apply to indexers, where we do expect exceptions as a result of validating the arguments.","pos":[2264,2384]},{"pos":[2394,2417],"content":"Indexed Property Design","linkify":"Indexed Property Design","nodes":[{"content":"Indexed Property Design","pos":[0,23]}]},{"content":"An indexed property is a special property that can have parameters and can be called with special syntax similar to array indexing.","pos":[2421,2552]},{"content":"Indexed properties are commonly referred to as indexers.","pos":[2559,2615]},{"content":"Indexers should be used only in APIs that provide access to items in a logical collection.","pos":[2616,2706]},{"content":"For example, a string is a collection of characters, and the indexer on <ph id=\"ph1\">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> was added to access its characters.","pos":[2707,2864],"source":" For example, a string is a collection of characters, and the indexer on <xref:System.String?displayProperty=nameWithType> was added to access its characters."},{"pos":[2871,2955],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using indexers to provide access to data stored in an internal array.","source":"**✓ CONSIDER** using indexers to provide access to data stored in an internal array."},{"pos":[2962,3039],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> providing indexers on types representing collections of items.","source":"**✓ CONSIDER** providing indexers on types representing collections of items."},{"pos":[3046,3112],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> using indexed properties with more than one parameter.","source":"**X AVOID** using indexed properties with more than one parameter."},{"content":"If the design requires multiple parameters, reconsider whether the property really represents an accessor to a logical collection.","pos":[3119,3249]},{"content":"If it does not, use methods instead.","pos":[3250,3286]},{"content":"Consider starting the method name with <ph id=\"ph1\">`Get`</ph> or <ph id=\"ph2\">`Set`</ph>.","pos":[3287,3341],"source":" Consider starting the method name with `Get` or `Set`."},{"pos":[3348,3614],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> indexers with parameter types other than <ph id=\"ph1\">&lt;xref:System.Int32?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Int64?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>, or an enum.","source":"**X AVOID** indexers with parameter types other than <xref:System.Int32?displayProperty=nameWithType>, <xref:System.Int64?displayProperty=nameWithType>, <xref:System.String?displayProperty=nameWithType>, <xref:System.Object?displayProperty=nameWithType>, or an enum."},{"content":"If the design requires other types of parameters, strongly reevaluate whether the API really represents an accessor to a logical collection.","pos":[3621,3761]},{"content":"If it does not, use a method.","pos":[3762,3791]},{"content":"Consider starting the method name with <ph id=\"ph1\">`Get`</ph> or <ph id=\"ph2\">`Set`</ph>.","pos":[3792,3846],"source":" Consider starting the method name with `Get` or `Set`."},{"pos":[3853,4020],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use the name <ph id=\"ph1\">`Item`</ph> for indexed properties unless there is an obviously better name (e.g., see the <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph> property on <ph id=\"ph3\">`System.String`</ph>).","source":"**✓ DO** use the name `Item` for indexed properties unless there is an obviously better name (e.g., see the <xref:System.String.Chars%2A> property on `System.String`)."},{"content":"In C#, indexers are by default named Item.","pos":[4027,4069]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> can be used to customize this name.","pos":[4070,4169],"source":" The <xref:System.Runtime.CompilerServices.IndexerNameAttribute> can be used to customize this name."},{"pos":[4176,4258],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> provide both an indexer and methods that are semantically equivalent.","source":"**X DO NOT** provide both an indexer and methods that are semantically equivalent."},{"pos":[4265,4342],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> provide more than one family of overloaded indexers in one type.","source":"**X DO NOT** provide more than one family of overloaded indexers in one type."},{"content":"This is enforced by the C# compiler.","pos":[4349,4385]},{"pos":[4392,4439],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use nondefault indexed properties.","source":"**X DO NOT** use nondefault indexed properties."},{"content":"This is enforced by the C# compiler.","pos":[4446,4482]},{"pos":[4492,4527],"content":"Property Change Notification Events","linkify":"Property Change Notification Events","nodes":[{"content":"Property Change Notification Events","pos":[0,35]}]},{"content":"Sometimes it is useful to provide an event notifying the user of changes in a property value.","pos":[4531,4624]},{"content":"For example, <ph id=\"ph1\">`System.Windows.Forms.Control`</ph> raises a <ph id=\"ph2\">`TextChanged`</ph> event after the value of its <ph id=\"ph3\">`Text`</ph> property has changed.","pos":[4625,4749],"source":" For example, `System.Windows.Forms.Control` raises a `TextChanged` event after the value of its `Text` property has changed."},{"pos":[4756,4889],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> raising change notification events when property values in high-level APIs (usually designer components) are modified.","source":"**✓ CONSIDER** raising change notification events when property values in high-level APIs (usually designer components) are modified."},{"content":"If there is a good scenario for a user to know when a property of an object is changing, the object should raise a change notification event for the property.","pos":[4896,5054]},{"content":"However, it is unlikely to be worth the overhead to raise such events for low-level APIs such as base types or collections.","pos":[5061,5184]},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> would not raise such events when a new item is added to the list and the <ph id=\"ph2\">`Count`</ph> property changes.","pos":[5185,5339],"source":" For example, <xref:System.Collections.Generic.List%601> would not raise such events when a new item is added to the list and the `Count` property changes."},{"pos":[5346,5453],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> raising change notification events when the value of a property changes via external forces.","source":"**✓ CONSIDER** raising change notification events when the value of a property changes via external forces."},{"content":"If a property value changes via some external force (in a way other than by calling methods on the object), raise events indicate to the developer that the value is changing and has changed.","pos":[5460,5650]},{"content":"A good example is the <ph id=\"ph1\">`Text`</ph> property of a text box control.","pos":[5651,5711],"source":" A good example is the `Text` property of a text box control."},{"content":"When the user types text in a <ph id=\"ph1\">`TextBox`</ph>, the property value automatically changes.","pos":[5712,5794],"source":" When the user types text in a `TextBox`, the property value automatically changes."},{"pos":[5801,5868],"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[5875,6280],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[6289,6297],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6301,6379],"content":"<bpt id=\"p1\">[</bpt>Member Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/member.md)</ept>","source":"[Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)"},{"pos":[6382,6462],"content":"<bpt id=\"p1\">[</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept>","source":"[Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)"}]}