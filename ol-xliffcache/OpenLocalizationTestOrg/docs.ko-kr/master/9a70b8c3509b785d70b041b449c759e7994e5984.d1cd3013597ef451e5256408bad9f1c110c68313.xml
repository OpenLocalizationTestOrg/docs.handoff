{"content":"---\ntitle: \"loaderLock MDA\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"deadlocks [.NET Framework]\"\n  - \"LoaderLock MDA\"\n  - \"MDAs (managed debugging assistants), loader locks\"\n  - \"managed debugging assistants (MDAs), loader locks\"\n  - \"operating system loader locks\"\n  - \"loader locks\"\n  - \"locks, threads\"\nms.assetid: 8c10fa02-1b9c-4be5-ab03-451d943ac1ee\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# loaderLock MDA\nThe `loaderLock` managed debugging assistant (MDA) detects attempts to execute managed code on a thread that holds the Microsoft Windows operating system loader lock.  Any such execution is illegal because it can lead to deadlocks and to use of DLLs before they have been initialized by the operating system's loader.  \n  \n## Symptoms  \n The most common failure when executing code inside the operating system's loader lock is that threads will deadlock when attempting to call other Win32 functions that also require the loader lock.  Examples of such functions are `LoadLibrary`, `GetProcAddress`, `FreeLibrary`, and `GetModuleHandle`.  The application might not directly call these functions; the common language runtime (CLR) might call these functions as the result of a higher level call like <xref:System.Reflection.Assembly.Load%2A> or the first call to a platform invoke method.  \n  \n Deadlocks can also occur if a thread is waiting for another thread to start or finish.  When a thread starts or finishes executing, it must acquire the operating system's loader lock to deliver events to affected DLLs.  \n  \n Finally, there are cases where calls into DLLs can occur before those DLLs have been properly initialized by the operating system's loader.  Unlike the deadlock failures, which can be diagnosed by examining the stacks of all the threads involved in the deadlock, it is very difficult to diagnose the use of uninitialized DLLs without using this MDA.  \n  \n## Cause  \n Mixed managed/unmanaged C++ assemblies built for .NET Framework versions 1.0 or 1.1 generally attempt to execute managed code inside the loader lock unless special care has been taken, for example, linking with **/NOENTRY**.\n  \n Mixed managed/unmanaged C++ assemblies built for .NET Framework version 2.0 are less susceptible to these problems, having the same reduced risk as applications using unmanaged DLLs that violate the operating system's rules.  For example, if an unmanaged DLL's `DllMain` entry point calls `CoCreateInstance` to obtain a managed object that has been exposed to COM, the result is an attempt to execute managed code inside the loader lock. For more information about loader lock issues in the .NET Framework version 2.0 and later, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies).  \n  \n## Resolution  \n In Visual C++ .NET 2002 and Visual C++ .NET 2003, DLLs compiled with the `/clr` compiler option could non-deterministically deadlock when loaded; this issue was called the mixed DLL loading or loader lock issue. In Visual C++ 2005 and later, almost all non-determinism has been removed from the mixed DLL loading process. However, there are a few remaining scenarios for which loader lock can (deterministically) occur. For a detailed account of the causes and resolutions for the remaining loader lock issues, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies). If that topic does not identify your loader lock problem, you have to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem. Look at the stack trace for the thread that has activated this MDA.  The thread is attempting to illegally call into managed code while holding the operating system's loader lock.  You will probably see a DLL's `DllMain` or equivalent entry point on the stack.  The operating system's rules for what you can legally do from inside such an entry point are quite limited.  These rules preclude any managed execution.  \n  \n## Effect on the Runtime  \n Typically, several threads inside the process will deadlock.  One of those threads is likely to be a thread responsible for performing a garbage collection, so this deadlock can have a major impact on the entire process.  Furthermore, it will prevent any additional operations that require the operating system's loader lock, like loading and unloading assemblies or DLLs and starting or stopping threads.  \n  \n In some unusual cases, it is also possible for access violations or similar problems to be triggered in DLLs which are called before they have been initialized.  \n  \n## Output  \n This MDA reports that an illegal managed execution is being attempted.  You need to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.  \n  \n## Configuration  \n  \n```xml  \n<mdaConfig>  \n  <assistants>  \n    <loaderLock/>  \n  </assistants>  \n</mdaConfig>  \n```  \n  \n## See also\n\n- [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)\n","nodes":[{"pos":[4,399],"embed":true,"restype":"x-metadata","content":"title: \"loaderLock MDA\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"deadlocks [.NET Framework]\"\n  - \"LoaderLock MDA\"\n  - \"MDAs (managed debugging assistants), loader locks\"\n  - \"managed debugging assistants (MDAs), loader locks\"\n  - \"operating system loader locks\"\n  - \"loader locks\"\n  - \"locks, threads\"\nms.assetid: 8c10fa02-1b9c-4be5-ab03-451d943ac1ee\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"loaderLock MDA","nodes":[{"pos":[0,14],"content":"loaderLock MDA","nodes":[{"content":"loaderLock MDA","pos":[0,14]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[406,420],"content":"loaderLock MDA","linkify":"loaderLock MDA","nodes":[{"content":"loaderLock MDA","pos":[0,14]}]},{"content":"The <ph id=\"ph1\">`loaderLock`</ph> managed debugging assistant (MDA) detects attempts to execute managed code on a thread that holds the Microsoft Windows operating system loader lock.","pos":[421,587],"source":"The `loaderLock` managed debugging assistant (MDA) detects attempts to execute managed code on a thread that holds the Microsoft Windows operating system loader lock."},{"content":"Any such execution is illegal because it can lead to deadlocks and to use of DLLs before they have been initialized by the operating system's loader.","pos":[589,738]},{"pos":[747,755],"content":"Symptoms","linkify":"Symptoms","nodes":[{"content":"Symptoms","pos":[0,8]}]},{"content":"The most common failure when executing code inside the operating system's loader lock is that threads will deadlock when attempting to call other Win32 functions that also require the loader lock.","pos":[759,955]},{"content":"Examples of such functions are <ph id=\"ph1\">`LoadLibrary`</ph>, <ph id=\"ph2\">`GetProcAddress`</ph>, <ph id=\"ph3\">`FreeLibrary`</ph>, and <ph id=\"ph4\">`GetModuleHandle`</ph>.","pos":[957,1058],"source":"  Examples of such functions are `LoadLibrary`, `GetProcAddress`, `FreeLibrary`, and `GetModuleHandle`."},{"content":"The application might not directly call these functions; the common language runtime (CLR) might call these functions as the result of a higher level call like <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> or the first call to a platform invoke method.","pos":[1060,1308],"source":"  The application might not directly call these functions; the common language runtime (CLR) might call these functions as the result of a higher level call like <xref:System.Reflection.Assembly.Load%2A> or the first call to a platform invoke method."},{"content":"Deadlocks can also occur if a thread is waiting for another thread to start or finish.","pos":[1315,1401]},{"content":"When a thread starts or finishes executing, it must acquire the operating system's loader lock to deliver events to affected DLLs.","pos":[1403,1533]},{"content":"Finally, there are cases where calls into DLLs can occur before those DLLs have been properly initialized by the operating system's loader.","pos":[1540,1679]},{"content":"Unlike the deadlock failures, which can be diagnosed by examining the stacks of all the threads involved in the deadlock, it is very difficult to diagnose the use of uninitialized DLLs without using this MDA.","pos":[1681,1889]},{"pos":[1898,1903],"content":"Cause","linkify":"Cause","nodes":[{"content":"Cause","pos":[0,5]}]},{"pos":[1907,2131],"content":"Mixed managed/unmanaged C++ assemblies built for .NET Framework versions 1.0 or 1.1 generally attempt to execute managed code inside the loader lock unless special care has been taken, for example, linking with <bpt id=\"p1\">**</bpt>/NOENTRY<ept id=\"p1\">**</ept>.","source":"Mixed managed/unmanaged C++ assemblies built for .NET Framework versions 1.0 or 1.1 generally attempt to execute managed code inside the loader lock unless special care has been taken, for example, linking with **/NOENTRY**."},{"content":"Mixed managed/unmanaged C++ assemblies built for .NET Framework version 2.0 are less susceptible to these problems, having the same reduced risk as applications using unmanaged DLLs that violate the operating system's rules.","pos":[2136,2360]},{"content":"For example, if an unmanaged DLL's <ph id=\"ph1\">`DllMain`</ph> entry point calls <ph id=\"ph2\">`CoCreateInstance`</ph> to obtain a managed object that has been exposed to COM, the result is an attempt to execute managed code inside the loader lock.","pos":[2362,2573],"source":"  For example, if an unmanaged DLL's `DllMain` entry point calls `CoCreateInstance` to obtain a managed object that has been exposed to COM, the result is an attempt to execute managed code inside the loader lock."},{"content":"For more information about loader lock issues in the .NET Framework version 2.0 and later, see <bpt id=\"p1\">[</bpt>Initialization of Mixed Assemblies<ept id=\"p1\">](/cpp/dotnet/initialization-of-mixed-assemblies)</ept>.","pos":[2574,2754],"source":" For more information about loader lock issues in the .NET Framework version 2.0 and later, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies)."},{"pos":[2763,2773],"content":"Resolution","linkify":"Resolution","nodes":[{"content":"Resolution","pos":[0,10]}]},{"content":"In Visual C++ .NET 2002 and Visual C++ .NET 2003, DLLs compiled with the <ph id=\"ph1\">`/clr`</ph> compiler option could non-deterministically deadlock when loaded; this issue was called the mixed DLL loading or loader lock issue.","pos":[2777,2988],"source":"In Visual C++ .NET 2002 and Visual C++ .NET 2003, DLLs compiled with the `/clr` compiler option could non-deterministically deadlock when loaded; this issue was called the mixed DLL loading or loader lock issue."},{"content":"In Visual C++ 2005 and later, almost all non-determinism has been removed from the mixed DLL loading process.","pos":[2989,3098]},{"content":"However, there are a few remaining scenarios for which loader lock can (deterministically) occur.","pos":[3099,3196]},{"content":"For a detailed account of the causes and resolutions for the remaining loader lock issues, see <bpt id=\"p1\">[</bpt>Initialization of Mixed Assemblies<ept id=\"p1\">](/cpp/dotnet/initialization-of-mixed-assemblies)</ept>.","pos":[3197,3377],"source":" For a detailed account of the causes and resolutions for the remaining loader lock issues, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies)."},{"content":"If that topic does not identify your loader lock problem, you have to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.","pos":[3378,3552]},{"content":"Look at the stack trace for the thread that has activated this MDA.","pos":[3553,3620]},{"content":"The thread is attempting to illegally call into managed code while holding the operating system's loader lock.","pos":[3622,3732]},{"content":"You will probably see a DLL's <ph id=\"ph1\">`DllMain`</ph> or equivalent entry point on the stack.","pos":[3734,3813],"source":"  You will probably see a DLL's `DllMain` or equivalent entry point on the stack."},{"content":"The operating system's rules for what you can legally do from inside such an entry point are quite limited.","pos":[3815,3922]},{"content":"These rules preclude any managed execution.","pos":[3924,3967]},{"pos":[3976,3997],"content":"Effect on the Runtime","linkify":"Effect on the Runtime","nodes":[{"content":"Effect on the Runtime","pos":[0,21]}]},{"content":"Typically, several threads inside the process will deadlock.","pos":[4001,4061]},{"content":"One of those threads is likely to be a thread responsible for performing a garbage collection, so this deadlock can have a major impact on the entire process.","pos":[4063,4221]},{"content":"Furthermore, it will prevent any additional operations that require the operating system's loader lock, like loading and unloading assemblies or DLLs and starting or stopping threads.","pos":[4223,4406]},{"content":"In some unusual cases, it is also possible for access violations or similar problems to be triggered in DLLs which are called before they have been initialized.","pos":[4413,4573]},{"pos":[4582,4588],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"This MDA reports that an illegal managed execution is being attempted.","pos":[4592,4662]},{"content":"You need to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.","pos":[4664,4780]},{"pos":[4789,4802],"content":"Configuration","linkify":"Configuration","nodes":[{"content":"Configuration","pos":[0,13]}]},{"pos":[4913,4921],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4925,5078],"content":"<bpt id=\"p1\">[</bpt>Diagnosing Errors with Managed Debugging Assistants<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)</ept>","source":"[Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)"}]}