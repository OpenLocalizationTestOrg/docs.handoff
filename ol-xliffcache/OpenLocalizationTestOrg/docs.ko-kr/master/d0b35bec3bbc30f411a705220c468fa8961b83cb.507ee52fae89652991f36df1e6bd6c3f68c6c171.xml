{"content":"---\ntitle: \"C# Features That Support LINQ\"\nms.date: 07/20/2015\nhelpviewer_keywords:\n  - \"LINQ [C#], features supporting LINQ\"\nms.assetid: 524b0078-ebfd-45a7-b390-f2ceb9d84797\n---\n# C# Features That Support LINQ\n\nThe following section introduces new language constructs introduced in C# 3.0. Although these new features are all used to a degree with [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] queries, they are not limited to [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] and can be used in any context where you find them useful.\n\n## Query Expressions\n\nQuery expressions use a declarative syntax similar to SQL or XQuery to query over IEnumerable collections. At compile time query syntax is converted to method calls to a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] provider's implementation of the standard query operator extension methods. Applications control the standard query operators that are in scope by specifying the appropriate namespace with a `using` directive. The following query expression takes an array of strings, groups them according to the first character in the string, and orders the groups.\n\n```csharp\nvar query = from str in stringArray\n            group str by str[0] into stringGroup\n            orderby stringGroup.Key\n            select stringGroup;\n```\n\nFor more information, see [LINQ Query Expressions](../../../../csharp/programming-guide/linq-query-expressions/index.md).\n\n## Implicitly Typed Variables (var)\n\nInstead of explicitly specifying a type when you declare and initialize a variable, you can use the [var](../../../../csharp/language-reference/keywords/var.md) modifier to instruct the compiler to infer and assign the type, as shown here:\n\n```csharp\nvar number = 5;\nvar name = \"Virginia\";\nvar query = from str in stringArray\n            where str[0] == 'm'\n            select str;\n```\n\nVariables declared as `var` are just as strongly-typed as variables whose type you specify explicitly. The use of `var` makes it possible to create anonymous types, but it can be used only for local variables. Arrays can also be declared with implicit typing.\n\nFor more information, see [Implicitly Typed Local Variables](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).\n\n## Object and Collection Initializers\n\nObject and collection initializers make it possible to initialize objects without explicitly calling a constructor for the object. Initializers are typically used in query expressions when they project the source data into a new data type. Assuming a class named `Customer` with public `Name` and `Phone` properties, the object initializer can be used as in the following code:\n\n```csharp\nCustomer cust = new Customer { Name = \"Mike\", Phone = \"555-1212\" };\n```\n\nContinuing with our `Customer` class, assume that there is a data source called `IncomingOrders`, and that for each order with a large `OrderSize`, we would like to create a new `Customer` based off of that order. A LINQ query can be executed on this data source and use object initialization to fill a collection:\n\n```csharp\nvar newLargeOrderCustomers = from o in IncomingOrders\n                            where o.OrderSize > 5\n                            select new Customer { Name = o.Name, Phone = o.Phone };\n```\n\nThe data source may have more properties lying under the hood than the `Customer` class such as `OrderSize`, but with object initialization, the data returned from the query is molded into the desired data type; we choose the data that is relevant to our class. As a result, we now have an `IEnumerable` filled with the new `Customer`s we wanted. The above can also be written in LINQ's method syntax:\n\n```csharp\nvar newLargeOrderCustomers = IncomingOrders.Where(x => x.OrderSize > 5).Select(y => new Customer { Name = y.Name, Phone = y.Phone });\n```\n\nFor more information, see:\n\n- [Object and Collection Initializers](../../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)\n\n- [Query Expression Syntax for Standard Query Operators](../../../../csharp/programming-guide/concepts/linq/query-expression-syntax-for-standard-query-operators.md)\n\n## Anonymous Types\n\nAn anonymous type is constructed by the compiler and the type name is only available to the compiler. Anonymous types provide a convenient way to group a set of properties temporarily in a query result without having to define a separate named type. Anonymous types are initialized with a new expression and an object initializer, as shown here:\n\n```csharp\nselect new {name = cust.Name, phone = cust.Phone};\n```\n\nFor more information, see [Anonymous Types](../../../../csharp/programming-guide/classes-and-structs/anonymous-types.md).\n\n## Extension Methods\n\nAn extension method is a static method that can be associated with a type, so that it can be called as if it were an instance method on the type. This feature enables you to, in effect, \"add\" new methods to existing types without actually modifying them. The standard query operators are a set of extension methods that provide [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query functionality for any type that implements <xref:System.Collections.Generic.IEnumerable%601>.\n\nFor more information, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md).\n\n## Lambda Expressions\n\nA lambda expression is an inline function that uses the => operator to separate input parameters from the function body and can be converted at compile time to a delegate or an expression tree. In [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] programming, you will encounter lambda expressions when you make direct method calls to the standard query operators.\n\nFor more information, see:\n\n- [Anonymous Functions](../../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)\n\n- [Lambda Expressions](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)\n\n- [Expression Trees (C#)](../../../../csharp/programming-guide/concepts/expression-trees/index.md)\n\n## See also\n\n- [Language-Integrated Query (LINQ) (C#)](../../../../csharp/programming-guide/concepts/linq/index.md)\n","nodes":[{"pos":[4,174],"embed":true,"restype":"x-metadata","content":"title: \"C# Features That Support LINQ\"\nms.date: 07/20/2015\nhelpviewer_keywords:\n  - \"LINQ [C#], features supporting LINQ\"\nms.assetid: 524b0078-ebfd-45a7-b390-f2ceb9d84797","nodes":[{"content":"C# Features That Support LINQ","nodes":[{"pos":[0,29],"content":"C# Features That Support LINQ","nodes":[{"content":"C# Features That Support LINQ","pos":[0,29]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[181,210],"content":"C# Features That Support LINQ","linkify":"C# Features That Support LINQ","nodes":[{"content":"C# Features That Support LINQ","pos":[0,29]}]},{"content":"The following section introduces new language constructs introduced in C# 3.0.","pos":[212,290]},{"content":"Although these new features are all used to a degree with <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> queries, they are not limited to <ph id=\"ph2\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> and can be used in any context where you find them useful.","pos":[291,540],"source":" Although these new features are all used to a degree with [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] queries, they are not limited to [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] and can be used in any context where you find them useful."},{"pos":[545,562],"content":"Query Expressions","linkify":"Query Expressions","nodes":[{"content":"Query Expressions","pos":[0,17]}]},{"content":"Query expressions use a declarative syntax similar to SQL or XQuery to query over IEnumerable collections.","pos":[564,670]},{"content":"At compile time query syntax is converted to method calls to a <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> provider's implementation of the standard query operator extension methods.","pos":[671,859],"source":" At compile time query syntax is converted to method calls to a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] provider's implementation of the standard query operator extension methods."},{"content":"Applications control the standard query operators that are in scope by specifying the appropriate namespace with a <ph id=\"ph1\">`using`</ph> directive.","pos":[860,993],"source":" Applications control the standard query operators that are in scope by specifying the appropriate namespace with a `using` directive."},{"content":"The following query expression takes an array of strings, groups them according to the first character in the string, and orders the groups.","pos":[994,1134]},{"pos":[1304,1425],"content":"For more information, see <bpt id=\"p1\">[</bpt>LINQ Query Expressions<ept id=\"p1\">](../../../../csharp/programming-guide/linq-query-expressions/index.md)</ept>.","source":"For more information, see [LINQ Query Expressions](../../../../csharp/programming-guide/linq-query-expressions/index.md)."},{"pos":[1430,1462],"content":"Implicitly Typed Variables (var)","linkify":"Implicitly Typed Variables (var)","nodes":[{"content":"Implicitly Typed Variables (var)","pos":[0,32]}]},{"pos":[1464,1703],"content":"Instead of explicitly specifying a type when you declare and initialize a variable, you can use the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](../../../../csharp/language-reference/keywords/var.md)</ept> modifier to instruct the compiler to infer and assign the type, as shown here:","source":"Instead of explicitly specifying a type when you declare and initialize a variable, you can use the [var](../../../../csharp/language-reference/keywords/var.md) modifier to instruct the compiler to infer and assign the type, as shown here:"},{"content":"Variables declared as <ph id=\"ph1\">`var`</ph> are just as strongly-typed as variables whose type you specify explicitly.","pos":[1851,1953],"source":"Variables declared as `var` are just as strongly-typed as variables whose type you specify explicitly."},{"content":"The use of <ph id=\"ph1\">`var`</ph> makes it possible to create anonymous types, but it can be used only for local variables.","pos":[1954,2060],"source":" The use of `var` makes it possible to create anonymous types, but it can be used only for local variables."},{"content":"Arrays can also be declared with implicit typing.","pos":[2061,2110]},{"pos":[2112,2267],"content":"For more information, see <bpt id=\"p1\">[</bpt>Implicitly Typed Local Variables<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)</ept>.","source":"For more information, see [Implicitly Typed Local Variables](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)."},{"pos":[2272,2306],"content":"Object and Collection Initializers","linkify":"Object and Collection Initializers","nodes":[{"content":"Object and Collection Initializers","pos":[0,34]}]},{"content":"Object and collection initializers make it possible to initialize objects without explicitly calling a constructor for the object.","pos":[2308,2438]},{"content":"Initializers are typically used in query expressions when they project the source data into a new data type.","pos":[2439,2547]},{"content":"Assuming a class named <ph id=\"ph1\">`Customer`</ph> with public <ph id=\"ph2\">`Name`</ph> and <ph id=\"ph3\">`Phone`</ph> properties, the object initializer can be used as in the following code:","pos":[2548,2685],"source":" Assuming a class named `Customer` with public `Name` and `Phone` properties, the object initializer can be used as in the following code:"},{"content":"Continuing with our <ph id=\"ph1\">`Customer`</ph> class, assume that there is a data source called <ph id=\"ph2\">`IncomingOrders`</ph>, and that for each order with a large <ph id=\"ph3\">`OrderSize`</ph>, we would like to create a new <ph id=\"ph4\">`Customer`</ph> based off of that order.","pos":[2770,2983],"source":"Continuing with our `Customer` class, assume that there is a data source called `IncomingOrders`, and that for each order with a large `OrderSize`, we would like to create a new `Customer` based off of that order."},{"content":"A LINQ query can be executed on this data source and use object initialization to fill a collection:","pos":[2984,3084]},{"content":"The data source may have more properties lying under the hood than the <ph id=\"ph1\">`Customer`</ph> class such as <ph id=\"ph2\">`OrderSize`</ph>, but with object initialization, the data returned from the query is molded into the desired data type; we choose the data that is relevant to our class.","pos":[3289,3550],"source":"The data source may have more properties lying under the hood than the `Customer` class such as `OrderSize`, but with object initialization, the data returned from the query is molded into the desired data type; we choose the data that is relevant to our class."},{"content":"As a result, we now have an <ph id=\"ph1\">`IEnumerable`</ph> filled with the new <ph id=\"ph2\">`Customer`</ph>s we wanted.","pos":[3551,3635],"source":" As a result, we now have an `IEnumerable` filled with the new `Customer`s we wanted."},{"content":"The above can also be written in LINQ's method syntax:","pos":[3636,3690]},{"content":"For more information, see:","pos":[3841,3867]},{"pos":[3871,4003],"content":"<bpt id=\"p1\">[</bpt>Object and Collection Initializers<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)</ept>","source":"[Object and Collection Initializers](../../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)"},{"pos":[4007,4169],"content":"<bpt id=\"p1\">[</bpt>Query Expression Syntax for Standard Query Operators<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/query-expression-syntax-for-standard-query-operators.md)</ept>","source":"[Query Expression Syntax for Standard Query Operators](../../../../csharp/programming-guide/concepts/linq/query-expression-syntax-for-standard-query-operators.md)"},{"pos":[4174,4189],"content":"Anonymous Types","linkify":"Anonymous Types","nodes":[{"content":"Anonymous Types","pos":[0,15]}]},{"content":"An anonymous type is constructed by the compiler and the type name is only available to the compiler.","pos":[4191,4292]},{"content":"Anonymous types provide a convenient way to group a set of properties temporarily in a query result without having to define a separate named type.","pos":[4293,4440]},{"content":"Anonymous types are initialized with a new expression and an object initializer, as shown here:","pos":[4441,4536]},{"pos":[4604,4725],"content":"For more information, see <bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept>.","source":"For more information, see [Anonymous Types](../../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)."},{"pos":[4730,4747],"content":"Extension Methods","linkify":"Extension Methods","nodes":[{"content":"Extension Methods","pos":[0,17]}]},{"content":"An extension method is a static method that can be associated with a type, so that it can be called as if it were an instance method on the type.","pos":[4749,4894]},{"content":"This feature enables you to, in effect, \"add\" new methods to existing types without actually modifying them.","pos":[4895,5003]},{"content":"The standard query operators are a set of extension methods that provide <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query functionality for any type that implements <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[5004,5226],"source":" The standard query operators are a set of extension methods that provide [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query functionality for any type that implements <xref:System.Collections.Generic.IEnumerable%601>."},{"pos":[5228,5353],"content":"For more information, see <bpt id=\"p1\">[</bpt>Extension Methods<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept>.","source":"For more information, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)."},{"pos":[5358,5376],"content":"Lambda Expressions","linkify":"Lambda Expressions","nodes":[{"content":"Lambda Expressions","pos":[0,18]}]},{"content":"A lambda expression is an inline function that uses the =&gt; operator to separate input parameters from the function body and can be converted at compile time to a delegate or an expression tree.","pos":[5378,5571],"source":"A lambda expression is an inline function that uses the => operator to separate input parameters from the function body and can be converted at compile time to a delegate or an expression tree."},{"content":"In <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> programming, you will encounter lambda expressions when you make direct method calls to the standard query operators.","pos":[5572,5742],"source":" In [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] programming, you will encounter lambda expressions when you make direct method calls to the standard query operators."},{"content":"For more information, see:","pos":[5744,5770]},{"pos":[5774,5889],"content":"<bpt id=\"p1\">[</bpt>Anonymous Functions<ept id=\"p1\">](../../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)</ept>","source":"[Anonymous Functions](../../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)"},{"pos":[5893,6006],"content":"<bpt id=\"p1\">[</bpt>Lambda Expressions<ept id=\"p1\">](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)</ept>","source":"[Lambda Expressions](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)"},{"pos":[6010,6106],"content":"<bpt id=\"p1\">[</bpt>Expression Trees (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/expression-trees/index.md)</ept>","source":"[Expression Trees (C#)](../../../../csharp/programming-guide/concepts/expression-trees/index.md)"},{"pos":[6111,6119],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6123,6223],"content":"<bpt id=\"p1\">[</bpt>Language-Integrated Query (LINQ) (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/index.md)</ept>","source":"[Language-Integrated Query (LINQ) (C#)](../../../../csharp/programming-guide/concepts/linq/index.md)"}]}