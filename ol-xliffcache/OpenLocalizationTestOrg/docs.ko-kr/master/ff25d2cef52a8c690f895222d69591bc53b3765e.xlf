<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="large-object-heap.md" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff25d2cef52a8c690f895222d69591bc53b3765e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbage-collection\large-object-heap.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">594c2dd965fd332ca35d1920d6d4251f6764985b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bc82545d4d22a00a94e2d878dc20e52f45c55c48</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>The large object heap on Windows systems</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>The large object heap on Windows systems</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The .NET Garbage Collector (GC) divides objects up into small and large objects.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When an object is large, some of its attributes become more significant than if the object is small.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For instance, compacting it -- that is, copying it in memory elsewhere on the heap -- can be expensive.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Because of this, the .NET Garbage Collector places large objects on the large object heap (LOH).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In this topic, we'll look at the large object heap in depth.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>We'll discuss what qualifies an object as a large object, how these large objects are collected, and what kind of performance implications large objects impose.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic discusses the large object heap in the .NET Framework and .NET Core running on Windows systems only.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It does not cover the LOH running on .NET implementations on other platforms.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>How an object ends up on the large object heap and how GC handles them</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If an object is greater than or equal to 85,000 bytes, it’s considered a large object.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This number was determined by performance tuning.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When an object allocation request is for 85,000 or more bytes, the runtime allocates it on the large object heap.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>To understand what this means, it's useful to examine some fundamentals about the .NET GC.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The .NET Garbage Collector is a generational collector.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>It has three generations: generation 0, generation 1, and generation 2.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The reason for having 3 generations is that, in a well-tuned app, most objects die in gen0.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, in a server app, the allocations associated with each request should die after the request is finished.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The in-flight allocation requests will make it into gen1 and die there.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Essentially, gen1 acts as a buffer between young object areas and long-lived object areas.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Small objects are always allocated in generation 0 and, depending on their lifetime, may be promoted to generation 1 or generation2.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Large objects are always allocated in generation 2.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Large objects belong to generation 2 because they are collected only during a generation 2 collection.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When a generation is collected, all its younger generation(s) are also collected.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, when a generation 1 GC happens, both generation 1 and 0 are collected.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>And when a generation 2 GC happens, the whole heap is collected.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For this reason, a generation 2 GC is also called a <bpt id="p1">*</bpt>full GC<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This article refers to generation 2 GC instead of full GC, but the terms are interchangeable.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Generations provide a logical view of the GC heap.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Physically, objects live in managed heap segments.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>managed heap segment<ept id="p1">*</ept> is a chunk of memory that the GC reserves from the OS by calling the <bpt id="p2">[</bpt>VirtualAlloc function<ept id="p2">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept> on behalf of managed code.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>When the CLR is loaded, the GC allocates two initial heap segments: one for small objects (the Small Object Heap, or SOH), and one for large objects (the Large Object Heap).</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The allocation requests are then satisfied by putting managed objects on these managed heap segments.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If the object is less than 85,000 bytes, it is put on the segment for the SOH; otherwise, it is put on an LOH segment.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Segments are committed (in smaller chunks) as more and more objects are allocated onto them.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For the SOH, objects that survive a GC are promoted to the next generation.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Objects that survive a generation 0 collection are now considered generation 1 objects, and so on.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, objects that survive the oldest generation are still considered to be in the oldest generation.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In other words, survivors from generation 2 are generation 2 objects; and survivors from the LOH are LOH objects (which are collected with gen2).</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>User code can only allocate in generation 0 (small objects) or the LOH (large objects).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Only the GC can “allocate” objects in generation 1 (by promoting survivors from generation 0) and generation 2 (by promoting survivors from generations 1 and 2).</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When a garbage collection is triggered, the GC traces through the live objects and compacts them.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>But because compaction is expensive, the GC <bpt id="p1">*</bpt>sweeps<ept id="p1">*</ept> the LOH; it makes a free list out of dead objects that can be reused later to satisfy large object allocation requests.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Adjacent dead objects are made into one free object.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>.NET Core and .NET Framework (starting with .NET Framework 4.5.1) include the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode?displayProperty=nameWithType&gt;</ph> property that allows users to specify that the LOH should be compacted during the next full blocking GC.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>And in the future, .NET may decide to compact the LOH automatically.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This means that, if you allocate large objects and want to make sure that they don’t move, you should still pin them.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Figure 1 illustrates a scenario where the GC forms generation 1 after the first generation 0 GC where <ph id="ph1">`Obj1`</ph> and <ph id="ph2">`Obj3`</ph> are dead, and it forms generation 2 after the first generation 1 GC where <ph id="ph3">`Obj2`</ph> and <ph id="ph4">`Obj5`</ph> are dead.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Note that this and the following figures are only for illustration purposes; they contain very few objects to better show what happens on the heap.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In reality, many more objects are typically involved in a GC.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Figure 1: A gen 0 GC and a gen 1 GC</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Figure 1: A generation 0 and a generation 1 GC.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Figure 2 shows that after a generation 2 GC which saw that <ph id="ph1">`Obj1`</ph> and <ph id="ph2">`Obj2`</ph> are dead, the GC forms contiguous free space out of memory that used to be occupied by <ph id="ph3">`Obj1`</ph> and <ph id="ph4">`Obj2`</ph>, which then was used to satisfy an allocation request for <ph id="ph5">`Obj4`</ph>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The space after the last object, <ph id="ph1">`Obj3`</ph>, to end of the segment can also be used to satisfy allocation requests.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Figure 2: After a gen 2 GC</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Figure 2: After a generation 2 GC</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>If there isn't enough free space to accommodate the large object allocation requests, the GC first attempts to acquire more segments from the OS.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If that fails, it triggers a generation 2 GC in the hope of freeing up some space.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>During a generation 1 or generation 2 GC, the garbage collector releases segments that have no live objects on them back to the OS by calling the <bpt id="p1">[</bpt>VirtualFree function<ept id="p1">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Space after the last live object to the end of the segment is decommitted (except on the ephemeral segment where gen0/gen1 live, where the garbage collector does keep some committed because your application will be allocating in it right away).</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>And the free spaces remain committed though they are reset, meaning that the OS doesn’t need to write data in them back to disk.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Since the LOH is only collected during generation 2 GCs, the LOH segment can only be freed during such a GC.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Figure 3 illustrates a scenario where the garbage collector releases one segment (segment 2) back to the OS and decommits more space on the remaining segments.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If it needs to use the decommitted space at the end of the segment to satisfy large object allocation requests, it commits the memory again.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>(For an explanation of commit/decommit, see the documentation for <bpt id="p1">[</bpt>VirtualAlloc<ept id="p1">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Figure 3: LOH after a gen 2 GC</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Figure 3: The LOH after a generation 2 GC</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When is a large object collected?</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In general, a GC occurs when one of the following 3 conditions happens:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Allocation exceeds the generation 0 or large object threshold.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The threshold is a property of a generation.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>A threshold for a generation is set when the garbage collector allocates objects into it.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>When the threshold is exceeded, a GC is triggered on that generation.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>When you allocate small or large objects, you consume generation 0 and the LOH’s thresholds, respectively.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When the garbage collector allocates into generation 1 and 2, it consumes their thresholds.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>These thresholds are dynamically tuned as the program runs.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This is the typical case; most GCs happen because of allocations on the managed heap.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%2A?displayProperty=nameWithType&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If the parameterless <ph id="ph1">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph> method is called or another overload is passed <ph id="ph2">&lt;xref:System.GC.MaxGeneration?displayProperty=nameWithType&gt;</ph> as an argument, the LOH is collected along with the rest of the managed heap.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The system is in low memory situation.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>This occurs when the garbage collector receives a high memory notification from the OS.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If the garbage collector thinks that doing a generation 2 GC will be productive, it triggers one.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>LOH Performance Implications</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Allocations on the large object heap impact performance in the following ways.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Allocation cost.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The CLR makes the guarantee that the memory for every new object it gives out is cleared.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This means the allocation cost of a large object is completely dominated by memory clearing (unless it triggers a GC).</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If it takes 2 cycles to clear one byte, it takes 170,000 cycles to clear the smallest large object.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Clearing the memory of a 16MB object on a 2GHz machine takes approximately 16ms.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>That's a rather large cost.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Collection cost.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Because the LOH and generation 2 are collected together, if either one's threshold is exceeded, a generation 2 collection is triggered.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If a generation 2 collection is triggered because of the LOH, generation 2 won't necessarily be much smaller after the GC.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If there's not much data on generation 2, this has minimal impact.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>But if generation 2 is large, it can cause performance problems if many generation 2 GCs are triggered.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If many large objects are allocated on a very temporary basis and you have a large SOH, you could be spending too much time doing GCs.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>In addition, the allocation cost can really add up if you keep allocating and letting go of really large objects.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Array elements with reference types.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Very large objects on the LOH are usually arrays (it's very rare to have an instance object that's really large).</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the elements of an array are reference-rich, it incurs a cost that is not present if the elements are not reference-rich.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>If the element doesn’t contain any references, the garbage collector doesn’t need to go through the array at all.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example, if you use an array to store nodes in a binary tree, one way to implement it is to refer to a node’s right and left node by the actual nodes:</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`num_nodes`</ph> is large, the garbage collector needs to go through at least two references per element.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>An alternative approach is to store the index of the right and the left nodes:</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Instead of referring the left node’s data as <ph id="ph1">`left.d`</ph>, you refer to it as <ph id="ph2">`binary_tr[left_index].d`</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>And the garbage collector doesn’t need to look at any references for the left and right node.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Out of the three factors, the first two are usually more significant than the third.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Because of this, we recommend that you allocate a pool of large objects that you reuse instead of allocating temporary ones.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Collecting performance data for the LOH</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Before you collect performance data for a specific area, you should already have done the following:</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Found evidence that you should be looking at this area.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Exhausted other areas that you know of without finding anything that could explain the performance problem you saw.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>See the blog <bpt id="p1">[</bpt>Understand the problem before you try to find a solution<ept id="p1">](https://blogs.msdn.microsoft.com/maoni/2006/09/01/understand-the-problem-before-you-try-to-find-a-solution/)</ept> for more information on the fundamentals of memory and the CPU.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can use the following tools to collect data on LOH performance:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET CLR memory performance counters<ept id="p1">](#net-clr-memory-performance-counters)</ept></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ETW events<ept id="p1">](#etw-events)</ept></source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>A debugger<ept id="p1">](#a-debugger)</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>.NET CLR Memory Performance counters</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>These performance counters are usually a good first step in investigating performance issues (although we recommend that you use <bpt id="p1">[</bpt>ETW events<ept id="p1">](#etw-events)</ept>).</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You configure Performance Monitor by adding the counters that you want, as Figure 4 shows.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The ones that are relevant for the LOH are:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Gen 2 Collections<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Displays the number of times generation 2 GCs have occurred since the process started.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The counter is incremented at the end of a generation 2 collection (also called a full garbage collection).</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This counter displays the last observed value.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Large Object Heap size<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Displays the current size, in bytes, including free space, of the LOH.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This counter is updated at the end of a garbage collection, not at each allocation.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>A common way to look at performance counters is with Performance Monitor (perfmon.exe).</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Use “Add Counters” to add the interesting counter for processes that you care about.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>You can save the performance counter data to a log file, as Figure 4 shows.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Figure 4: Adding performance counters.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Figure 4: The LOH after a generation 2 GC</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Performance counters can also be queried programmatically.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Many people collect them this way as part of their routine testing process.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>When they spot counters with values that are out of the ordinary, they use other means to get more detailed data to help with the investigation.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>We recommend that you to use ETW events instead of performance counters, because ETW provides much richer information.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>ETW events</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The garbage collector provides a rich set of ETW events to help you understand what the heap is doing and why.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The following blog posts show how to collect and understand GC events with ETW:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>GC ETW Events - 1<ept id="p1">](https://blogs.msdn.microsoft.com/maoni/2014/12/22/gc-etw-events-1/)</ept></source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>GC ETW Events - 2<ept id="p1">](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-2/)</ept></source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>GC ETW Events - 3<ept id="p1">](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-3/)</ept></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>GC ETW Events - 4<ept id="p1">](https://blogs.msdn.microsoft.com/maoni/2014/12/30/gc-etw-events-4/)</ept></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>To identify excessive generation 2 GCs caused by temporary LOH allocations, look at the Trigger Reason column for GCs.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For a simple test that only allocates temporary large objects, you can collect information on ETW events with the following <bpt id="p1">[</bpt>PerfView<ept id="p1">](https://www.microsoft.com/download/details.aspx?id=28567)</ept> command line:</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The result is something like this:</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![</ph>Figure 5: Examining ETW events using PerfView<ph id="ph2">](media/loh/perfview.png)</ph> Figure 5: ETW events shown using PerfView</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>As you can see, all GCs are generation 2 GCs, and they are all triggered by AllocLarge, which means that allocating a large object triggered this GC.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>We know that these allocations are temporary because the <bpt id="p1">**</bpt>LOH Survival Rate %<ept id="p1">**</ept> column says 1%.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>You can collect additional ETW events that tell you who allocated these large objects.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The following command line:</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>collects an AllocationTick event which is fired approximately every 100k worth of allocations.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>In other words, an event is fired each time a large object is allocated.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>You can then look at one of the GC Heap Alloc views which show you the callstacks that allocated large objects:</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Figure 6: A GC Heap Alloc view</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Figure 6: A GC Heap Alloc view</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>As you can see, this is a very simple test that just allocates large objects from its <ph id="ph1">`Main`</ph> method.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>A debugger</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If all you have is a memory dump and you need to look at what objects are actually on the LOH, you can use the <bpt id="p1">[</bpt>SoS debugger extension<ept id="p1">](../../../docs/framework/tools/sos-dll-sos-debugging-extension.md)</ept> provided by .NET.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The debugging commands mentioned in this section are applicable to the <bpt id="p1">[</bpt>Windows Debuggers<ept id="p1">](https://www.microsoft.com/whdc/devtools/debugging/default.mspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The following shows sample output from analyzing the LOH:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The LOH heap size is (16,754,224 + 16,699,288 + 16,284,504) = 49,738,016 bytes.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Between addresses 023e1000 and 033db630, 8,008,736 bytes are occupied by an array of <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> objects, 6,663,696 bytes are occupied by an array of <ph id="ph2">&lt;xref:System.Byte?displayProperty=nameWithType&gt;</ph>  objects, and 2,081,792 bytes are occupied by free space.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Sometimes, the debugger shows that the total size of the LOH is less than 85,000 bytes.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This happens because the runtime itself uses the LOH to allocate some objects that are smaller than a large object.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Because the LOH is not compacted, sometimes the LOH is thought to be the source of fragmentation.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Fragmentation means:</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Fragmentation of the managed heap, which is indicated by the amount of free space between managed objects.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>In SoS, the <ph id="ph1">`!dumpheap –type Free`</ph> command displays the amount of free space between managed objects.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Fragmentation of the virtual memory (VM) address space, which is the memory marked as <ph id="ph1">`MEM_FREE`</ph>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You can get it by using various debugger commands in windbg.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The following example shows fragmentation in the VM space:</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>It’s more common to see VM fragmentation caused by temporary large objects that require the garbage collector to frequently acquire new managed heap segments from the OS and to release empty ones back to the OS.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>To verify whether the LOH is causing VM fragmentation, you can set a breakpoint on <bpt id="p1">[</bpt>VirtualAlloc<ept id="p1">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept> and <bpt id="p2">[</bpt>VirtualFree<ept id="p2">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)</ept> to see who call them.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For example, to see who tried to allocate virtual memory chunks larger than 8MBB from the OS, you can set a breakpoint like this:</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This command breaks into the debugger and shows the callstack only if <bpt id="p1">[</bpt>VirtualAlloc<ept id="p1">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept> is called with an allocation size greater than 8MB (0x800000).</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>CLR 2.0 added a feature called <bpt id="p1">*</bpt>VM Hoarding<ept id="p1">*</ept> that can be useful for scenarios where segments (including on the large and small object heaps) are frequently acquired and released.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>To specify VM Hoarding, you specify a startup flag called <ph id="ph1">`STARTUP_HOARD_GC_VM`</ph> via the hosting API.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Instead of releasing empty segments back to the OS, the CLR decommits the memory on these segments and puts them on a standby list.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>(Note that the CLR doesn't do this for segments that are too large.) The CLR later uses those segments to satisfy new segment requests.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The next time that your app needs a new segment, the CLR uses one from this standby list if it can find one that’s big enough.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>VM hoarding is also useful for applications that want to hold onto the segments that they already acquired, such as some server apps that are the dominant apps running on the system, to avoid out of memory exceptions.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you carefully test your application when you use this feature to ensure your application has fairly stable memory usage.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>