{"content":"---\ntitle: Basic Types | C# Guide\ndescription: Learn about the core types (numerics, strings, and object) in all C# programs \nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nms.author: wiwagn\nms.date: 10/10/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f\n---\n\n# Types, variables, and values  \nC# is a strongly-typed language. Every variable and constant has a type, as does every expression that evaluates to a value. Every method signature specifies a type for each input parameter and for the return value. The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates. A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.  \n  \nThe information stored in a type can include the following:  \n  \n-   The storage space that a variable of the type requires.  \n  \n-   The maximum and minimum values that it can represent.  \n  \n-   The members (methods, fields, events, and so on) that it contains.  \n  \n-   The base type it inherits from.  \n  \n-   The location where the memory for variables will be allocated at run time.  \n  \n-   The kinds of operations that are permitted.  \n  \nThe compiler uses type information to make sure that all operations that are performed in your code are *type safe*. For example, if you declare a variable of type [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx), the compiler allows you to use the variable in addition and subtraction operations. If you try to perform those same operations on a variable of type [bool](https://msdn.microsoft.com/library/c8f5xwh7.aspx), the compiler generates an error, as shown in the following example:  \n  \n[!code-csharp[Type Safety](../../samples/snippets/csharp/concepts/basic-types/type-safety.cs)]  \n  \n> [!NOTE]  \n>  C and C++ developers, notice that in C#, [bool](https://msdn.microsoft.com/library/c8f5xwh7.aspx) is not convertible to [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx).  \n  \nThe compiler embeds the type information into the executable file as metadata. The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.  \n\n## Specifying types in variable declarations  \nWhen you declare a variable or constant in a program, you must either specify its type or use the [var](https://msdn.microsoft.com/library/bb383973.aspx) keyword to let the compiler infer the type. The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:  \n  \n[!code-csharp[Variable Declaration](../../samples/snippets/csharp/concepts/basic-types/variable-declaration.cs)]  \n  \nThe types of method parameters and return values are specified in the method signature. The following signature shows a method that requires an [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx) as an input argument and returns a string:  \n  \n[!code-csharp[Method Signature](../../samples/snippets/csharp/concepts/basic-types/method-signature.cs)]  \n  \nAfter a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type. For example, you cannot declare an [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx) and then assign it a Boolean value of [true](https://msdn.microsoft.com/library/06d3w013.aspx). However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments. A *type conversion* that does not cause data loss is performed automatically by the compiler. A conversion that might cause data loss requires a *cast* in the source code. \n\nFor more information, see [Casting and type conversions](https://msdn.microsoft.com/library/ms173105.aspx).\n \n## Built-in types\nC# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data. There are also built-in **string** and **object** types. These are available for you to use in any C# program. For a more information about the built-in types, see [Types reference tables](https://msdn.microsoft.com/library/1dhd7f2x.aspx).  \n  \n## Custom types  \nYou use the [struct](https://msdn.microsoft.com/library/ah19swz4.aspx), [class](https://msdn.microsoft.com/library/0b0thckt.aspx), [interface](https://msdn.microsoft.com/library/87d83y5b.aspx), and [enum](https://msdn.microsoft.com/library/sbbt4032.aspx) constructs to create your own custom types. The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications. By default, the most frequently used types in the class library are available in any C# program. Others become available only when you explicitly add a project reference to the assembly in which they are defined. After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code. For more information, see [.NET Framework class library](https://msdn.microsoft.com/library/gg145045(v=vs.110).aspx).  \n  \n## Generic types  \nA type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type. Such types are called *generic types*. For example, the .NET Framework type @System.Collections.Generic.List%601 has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:  \n  \n[!code-csharp[Generic types](../../samples/snippets/csharp/concepts/basic-types/generic-type.cs)] \n  \nThe use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](https://msdn.microsoft.com/library/9kkx3h3c.aspx). Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example. For more information, see [Generics](programming-guide/generics/index.md). \n\n## Implicit types, anonymous types, and tuple types  \nAs stated previously, you can implicitly type a local variable (but not class members) by using the [var](https://msdn.microsoft.com/library/bb383973.aspx) keyword. The variable still receives a type at compile time, but the type is provided by the compiler. For more information, see [Implicitly typed local variables](https://msdn.microsoft.com/library/bb384061.aspx).  \n  \nIn some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries. You can create *anonymous types* for this purpose. For more information, see [Anonymous types](https://msdn.microsoft.com/library/bb397696.aspx).\n\nIt's common to want to return more than one value from a method. You can create *tuple types* that return multiple values in a single method call. For more information, see [Tuples](tuples.md)\n\n## The Common type system  \nIt is important to understand two fundamental points about the type system in the .NET Framework:  \n  \n-   It supports the principle of inheritance. Types can derive from other types, called *base types*. The derived type inherits (with some restrictions) the methods, properties, and other members of the base type. The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy. All types, including built-in numeric types such as @System.Int32 (C# keyword: `int`), derive ultimately from a single base type, which is @System.Object (C# keyword: `object`). This unified type hierarchy is called the [Common type system](../standard/common-type-system.md) (CTS). For more information about inheritance in C#, see [Inheritance](https://msdn.microsoft.com/library/ms173149.aspx).  \n  \n-   Each type in the CTS is defined as either a *value type* or a *reference type*. This includes all custom types in the .NET Framework class library and also your own user-defined types. Types that you define by using the [struct](https://msdn.microsoft.com/library/ah19swz4.aspx) keyword are value types; all the built-in numeric types are **structs**. For more information about value types, see [Structs](structs.md). Types that you define by using the [class](https://msdn.microsoft.com/library/0b0thckt.aspx) keyword are reference types. For more information about reference types, see [Classes](classes.md). Reference types and value types have different compile-time rules, and different run-time behavior.\n \n  \n## See also\n[Structs](structs.md)\n\n[Classes](classes.md)\n","nodes":[{"pos":[4,342],"embed":true,"restype":"x-metadata","content":"title: Basic Types | C# Guide\ndescription: Learn about the core types (numerics, strings, and object) in all C# programs \nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nms.author: wiwagn\nms.date: 10/10/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f","nodes":[{"content":"Basic Types | C# Guide","nodes":[{"pos":[0,22],"content":"Basic Types | C# Guide","nodes":[{"content":"Basic Types | C# Guide","pos":[0,22]}]}],"path":["title"]},{"content":"Learn about the core types (numerics, strings, and object) in all C# programs","nodes":[{"pos":[0,77],"content":"Learn about the core types (numerics, strings, and object) in all C# programs","nodes":[{"content":"Learn about the core types (numerics, strings, and object) in all C# programs","pos":[0,77]}]}],"path":["description"]},{"content":".NET, .NET Core, C#","nodes":[{"pos":[0,19],"content":".NET, .NET Core, C#","nodes":[{"content":".NET, .NET Core, C#","pos":[0,19]}]}],"path":["keywords"]}],"yml":true},{"pos":[350,378],"content":"Types, variables, and values","linkify":"Types, variables, and values","nodes":[{"content":"Types, variables, and values","pos":[0,28]}]},{"content":"C# is a strongly-typed language.","pos":[381,413]},{"content":"Every variable and constant has a type, as does every expression that evaluates to a value.","pos":[414,505]},{"content":"Every method signature specifies a type for each input parameter and for the return value.","pos":[506,596]},{"content":"The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.","pos":[597,844]},{"content":"A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.","pos":[845,1004]},{"content":"The information stored in a type can include the following:","pos":[1010,1069]},{"content":"The storage space that a variable of the type requires.","pos":[1079,1134]},{"content":"The maximum and minimum values that it can represent.","pos":[1144,1197]},{"content":"The members (methods, fields, events, and so on) that it contains.","pos":[1207,1273]},{"content":"The base type it inherits from.","pos":[1283,1314]},{"content":"The location where the memory for variables will be allocated at run time.","pos":[1324,1398]},{"content":"The kinds of operations that are permitted.","pos":[1408,1451]},{"content":"The compiler uses type information to make sure that all operations that are performed in your code are <bpt id=\"p1\">*</bpt>type safe<ept id=\"p1\">*</ept>.","pos":[1457,1573],"source":"The compiler uses type information to make sure that all operations that are performed in your code are *type safe*."},{"content":"For example, if you declare a variable of type <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept>, the compiler allows you to use the variable in addition and subtraction operations.","pos":[1574,1761],"source":" For example, if you declare a variable of type [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx), the compiler allows you to use the variable in addition and subtraction operations."},{"content":"If you try to perform those same operations on a variable of type <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](https://msdn.microsoft.com/library/c8f5xwh7.aspx)</ept>, the compiler generates an error, as shown in the following example:","pos":[1762,1953],"source":" If you try to perform those same operations on a variable of type [bool](https://msdn.microsoft.com/library/c8f5xwh7.aspx), the compiler generates an error, as shown in the following example:"},{"pos":[2061,2250],"content":"[!NOTE]  \n C and C++ developers, notice that in C#, [bool](https://msdn.microsoft.com/library/c8f5xwh7.aspx) is not convertible to [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx).","leadings":["","> "],"nodes":[{"content":"C and C++ developers, notice that in C#, <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](https://msdn.microsoft.com/library/c8f5xwh7.aspx)</ept> is not convertible to <bpt id=\"p2\">[</bpt>int<ept id=\"p2\">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept>.","pos":[11,187],"source":"C and C++ developers, notice that in C#, [bool](https://msdn.microsoft.com/library/c8f5xwh7.aspx) is not convertible to [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx)."}]},{"content":"The compiler embeds the type information into the executable file as metadata.","pos":[2256,2334]},{"content":"The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.","pos":[2335,2471]},{"pos":[2478,2519],"content":"Specifying types in variable declarations","linkify":"Specifying types in variable declarations","nodes":[{"content":"Specifying types in variable declarations","pos":[0,41]}]},{"content":"When you declare a variable or constant in a program, you must either specify its type or use the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](https://msdn.microsoft.com/library/bb383973.aspx)</ept> keyword to let the compiler infer the type.","pos":[2522,2719],"source":"When you declare a variable or constant in a program, you must either specify its type or use the [var](https://msdn.microsoft.com/library/bb383973.aspx) keyword to let the compiler infer the type."},{"content":"The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:","pos":[2720,2843]},{"content":"The types of method parameters and return values are specified in the method signature.","pos":[2967,3054]},{"content":"The following signature shows a method that requires an <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept> as an input argument and returns a string:","pos":[3055,3209],"source":" The following signature shows a method that requires an [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx) as an input argument and returns a string:"},{"content":"After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.","pos":[3325,3477]},{"content":"For example, you cannot declare an <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept> and then assign it a Boolean value of <bpt id=\"p2\">[</bpt>true<ept id=\"p2\">](https://msdn.microsoft.com/library/06d3w013.aspx)</ept>.","pos":[3478,3664],"source":" For example, you cannot declare an [int](https://msdn.microsoft.com/library/5kzh1b5w.aspx) and then assign it a Boolean value of [true](https://msdn.microsoft.com/library/06d3w013.aspx)."},{"content":"However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.","pos":[3665,3796]},{"content":"A <bpt id=\"p1\">*</bpt>type conversion<ept id=\"p1\">*</ept> that does not cause data loss is performed automatically by the compiler.","pos":[3797,3890],"source":" A *type conversion* that does not cause data loss is performed automatically by the compiler."},{"content":"A conversion that might cause data loss requires a <bpt id=\"p1\">*</bpt>cast<ept id=\"p1\">*</ept> in the source code.","pos":[3891,3968],"source":" A conversion that might cause data loss requires a *cast* in the source code."},{"pos":[3971,4078],"content":"For more information, see <bpt id=\"p1\">[</bpt>Casting and type conversions<ept id=\"p1\">](https://msdn.microsoft.com/library/ms173105.aspx)</ept>.","source":"For more information, see [Casting and type conversions](https://msdn.microsoft.com/library/ms173105.aspx)."},{"pos":[4084,4098],"content":"Built-in types","linkify":"Built-in types","nodes":[{"content":"Built-in types","pos":[0,14]}]},{"content":"C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.","pos":[4099,4276]},{"content":"There are also built-in <bpt id=\"p1\">**</bpt>string<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>object<ept id=\"p2\">**</ept> types.","pos":[4277,4333],"source":" There are also built-in **string** and **object** types."},{"content":"These are available for you to use in any C# program.","pos":[4334,4387]},{"content":"For a more information about the built-in types, see <bpt id=\"p1\">[</bpt>Types reference tables<ept id=\"p1\">](https://msdn.microsoft.com/library/1dhd7f2x.aspx)</ept>.","pos":[4388,4516],"source":" For a more information about the built-in types, see [Types reference tables](https://msdn.microsoft.com/library/1dhd7f2x.aspx)."},{"pos":[4525,4537],"content":"Custom types","linkify":"Custom types","nodes":[{"content":"Custom types","pos":[0,12]}]},{"content":"You use the <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](https://msdn.microsoft.com/library/ah19swz4.aspx)</ept>, <bpt id=\"p2\">[</bpt>class<ept id=\"p2\">](https://msdn.microsoft.com/library/0b0thckt.aspx)</ept>, <bpt id=\"p3\">[</bpt>interface<ept id=\"p3\">](https://msdn.microsoft.com/library/87d83y5b.aspx)</ept>, and <bpt id=\"p4\">[</bpt>enum<ept id=\"p4\">](https://msdn.microsoft.com/library/sbbt4032.aspx)</ept> constructs to create your own custom types.","pos":[4540,4838],"source":"You use the [struct](https://msdn.microsoft.com/library/ah19swz4.aspx), [class](https://msdn.microsoft.com/library/0b0thckt.aspx), [interface](https://msdn.microsoft.com/library/87d83y5b.aspx), and [enum](https://msdn.microsoft.com/library/sbbt4032.aspx) constructs to create your own custom types."},{"content":"The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.","pos":[4839,4975]},{"content":"By default, the most frequently used types in the class library are available in any C# program.","pos":[4976,5072]},{"content":"Others become available only when you explicitly add a project reference to the assembly in which they are defined.","pos":[5073,5188]},{"content":"After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.","pos":[5189,5337]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>.NET Framework class library<ept id=\"p1\">](https://msdn.microsoft.com/library/gg145045(v=vs.110).aspx)</ept>.","pos":[5338,5455],"source":" For more information, see [.NET Framework class library](https://msdn.microsoft.com/library/gg145045(v=vs.110).aspx)."},{"pos":[5464,5477],"content":"Generic types","linkify":"Generic types","nodes":[{"content":"Generic types","pos":[0,13]}]},{"content":"A type can be declared with one or more <bpt id=\"p1\">*</bpt>type parameters<ept id=\"p1\">*</ept> that serve as a placeholder for the actual type (the <bpt id=\"p2\">*</bpt>concrete type<ept id=\"p2\">*</ept>) that client code will provide when it creates an instance of the type.","pos":[5480,5678],"source":"A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type."},{"content":"Such types are called <bpt id=\"p1\">*</bpt>generic types<ept id=\"p1\">*</ept>.","pos":[5679,5717],"source":" Such types are called *generic types*."},{"content":"For example, the .NET Framework type <ph id=\"ph1\">@System.Collections.Generic.List</ph>%601 has one type parameter that by convention is given the name <bpt id=\"p1\">*</bpt>T<ept id=\"p1\">*</ept>. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:","pos":[5718,5982],"source":" For example, the .NET Framework type @System.Collections.Generic.List%601 has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:"},{"content":"The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to <bpt id=\"p1\">[</bpt>object<ept id=\"p1\">](https://msdn.microsoft.com/library/9kkx3h3c.aspx)</ept>.","pos":[6090,6292],"source":"The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](https://msdn.microsoft.com/library/9kkx3h3c.aspx)."},{"content":"Generic collection classes are called <bpt id=\"p1\">*</bpt>strongly-typed collections<ept id=\"p1\">*</ept> because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the <ph id=\"ph1\">`strings`</ph> object in the previous example.","pos":[6293,6564],"source":" Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Generics<ept id=\"p1\">](programming-guide/generics/index.md)</ept>.","pos":[6565,6639],"source":" For more information, see [Generics](programming-guide/generics/index.md)."},{"pos":[6645,6693],"content":"Implicit types, anonymous types, and tuple types","linkify":"Implicit types, anonymous types, and tuple types","nodes":[{"content":"Implicit types, anonymous types, and tuple types","pos":[0,48]}]},{"content":"As stated previously, you can implicitly type a local variable (but not class members) by using the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](https://msdn.microsoft.com/library/bb383973.aspx)</ept> keyword.","pos":[6696,6860],"source":"As stated previously, you can implicitly type a local variable (but not class members) by using the [var](https://msdn.microsoft.com/library/bb383973.aspx) keyword."},{"content":"The variable still receives a type at compile time, but the type is provided by the compiler.","pos":[6861,6954]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Implicitly typed local variables<ept id=\"p1\">](https://msdn.microsoft.com/library/bb384061.aspx)</ept>.","pos":[6955,7066],"source":" For more information, see [Implicitly typed local variables](https://msdn.microsoft.com/library/bb384061.aspx)."},{"content":"In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.","pos":[7072,7229]},{"content":"You can create <bpt id=\"p1\">*</bpt>anonymous types<ept id=\"p1\">*</ept> for this purpose.","pos":[7230,7280],"source":" You can create *anonymous types* for this purpose."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Anonymous types<ept id=\"p1\">](https://msdn.microsoft.com/library/bb397696.aspx)</ept>.","pos":[7281,7375],"source":" For more information, see [Anonymous types](https://msdn.microsoft.com/library/bb397696.aspx)."},{"content":"It's common to want to return more than one value from a method.","pos":[7377,7441]},{"content":"You can create <bpt id=\"p1\">*</bpt>tuple types<ept id=\"p1\">*</ept> that return multiple values in a single method call.","pos":[7442,7523],"source":" You can create *tuple types* that return multiple values in a single method call."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Tuples<ept id=\"p1\">](tuples.md)</ept>","pos":[7524,7569],"source":" For more information, see [Tuples](tuples.md)"},{"pos":[7574,7596],"content":"The Common type system","linkify":"The Common type system","nodes":[{"content":"The Common type system","pos":[0,22]}]},{"content":"It is important to understand two fundamental points about the type system in the .NET Framework:","pos":[7599,7696]},{"content":"It supports the principle of inheritance.","pos":[7706,7747]},{"content":"Types can derive from other types, called <bpt id=\"p1\">*</bpt>base types<ept id=\"p1\">*</ept>.","pos":[7748,7803],"source":" Types can derive from other types, called *base types*."},{"content":"The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.","pos":[7804,7915]},{"content":"The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.","pos":[7916,8071]},{"content":"All types, including built-in numeric types such as <ph id=\"ph1\">@System.Int32</ph> (C# keyword: <ph id=\"ph2\">`int`</ph>), derive ultimately from a single base type, which is <ph id=\"ph3\">@System.Object</ph> (C# keyword: <ph id=\"ph4\">`object`</ph>).","pos":[8072,8249],"source":" All types, including built-in numeric types such as @System.Int32 (C# keyword: `int`), derive ultimately from a single base type, which is @System.Object (C# keyword: `object`)."},{"content":"This unified type hierarchy is called the <bpt id=\"p1\">[</bpt>Common type system<ept id=\"p1\">](../standard/common-type-system.md)</ept> (CTS).","pos":[8250,8354],"source":" This unified type hierarchy is called the [Common type system](../standard/common-type-system.md) (CTS)."},{"content":"For more information about inheritance in C#, see <bpt id=\"p1\">[</bpt>Inheritance<ept id=\"p1\">](https://msdn.microsoft.com/library/ms173149.aspx)</ept>.","pos":[8355,8469],"source":" For more information about inheritance in C#, see [Inheritance](https://msdn.microsoft.com/library/ms173149.aspx)."},{"content":"Each type in the CTS is defined as either a <bpt id=\"p1\">*</bpt>value type<ept id=\"p1\">*</ept> or a <bpt id=\"p2\">*</bpt>reference type<ept id=\"p2\">*</ept>.","pos":[8479,8558],"source":"Each type in the CTS is defined as either a *value type* or a *reference type*."},{"content":"This includes all custom types in the .NET Framework class library and also your own user-defined types.","pos":[8559,8663]},{"content":"Types that you define by using the <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](https://msdn.microsoft.com/library/ah19swz4.aspx)</ept> keyword are value types; all the built-in numeric types are <bpt id=\"p2\">**</bpt>structs<ept id=\"p2\">**</ept>.","pos":[8664,8830],"source":" Types that you define by using the [struct](https://msdn.microsoft.com/library/ah19swz4.aspx) keyword are value types; all the built-in numeric types are **structs**."},{"content":"For more information about value types, see <bpt id=\"p1\">[</bpt>Structs<ept id=\"p1\">](structs.md)</ept>.","pos":[8831,8897],"source":" For more information about value types, see [Structs](structs.md)."},{"content":"Types that you define by using the <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](https://msdn.microsoft.com/library/0b0thckt.aspx)</ept> keyword are reference types.","pos":[8898,9019],"source":" Types that you define by using the [class](https://msdn.microsoft.com/library/0b0thckt.aspx) keyword are reference types."},{"content":"For more information about reference types, see <bpt id=\"p1\">[</bpt>Classes<ept id=\"p1\">](classes.md)</ept>.","pos":[9020,9090],"source":" For more information about reference types, see [Classes](classes.md)."},{"content":"Reference types and value types have different compile-time rules, and different run-time behavior.","pos":[9091,9190]},{"pos":[9199,9207],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9208,9229],"content":"<bpt id=\"p1\">[</bpt>Structs<ept id=\"p1\">](structs.md)</ept>","source":"[Structs](structs.md)"},{"pos":[9231,9252],"content":"<bpt id=\"p1\">[</bpt>Classes<ept id=\"p1\">](classes.md)</ept>","source":"[Classes](classes.md)"}]}