{"content":"---\ntitle: \"ICorProfilerCallback4::SurvivingReferences2 Method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\napi_name: \n  - \"ICorProfilerCallback4.SurvivingReferences2\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerCallback4::SurvivingReferences2\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ICorProfilerCallback4::SurvivingReferences2 method [.NET Framework profiling]\"\n  - \"SurvivingReferences2 method, ICorProfilerCallback4 interface [.NET Framework profiling]\"\nms.assetid: 02b51888-5d89-4e50-a915-45b7e329aad9\ntopic_type: \n  - \"apiref\"\ncaps.latest.revision: 9\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# ICorProfilerCallback4::SurvivingReferences2 Method\nReports the layout of objects in the heap as a result of a non-compacting garbage collection. This method is called if the profiler has implemented the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface. This callback replaces the [ICorProfilerCallback2::SurvivingReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-survivingreferences-method.md) method, because it can report larger ranges of objects whose lengths exceed what can be expressed in a ULONG.  \n  \n## Syntax  \n  \n```  \nHRESULT SurvivingReferences2(  \n    [in] ULONG  cSurvivingObjectIDRanges,  \n    [in, size_is(cSurvivingObjectIDRanges)] ObjectID  \n                objectIDRangeStart[] ,  \n    [in, size_is(cSurvivingObjectIDRanges)] SIZE_T  \n                cObjectIDRangeLength[] );  \n```  \n  \n#### Parameters  \n `cSurvivingObjectIDRanges`  \n [in] The number of blocks of contiguous objects that survived as the result of the non-compacting garbage collection. That is, the value of `cSurvivingObjectIDRanges` is the size of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays, which store an `ObjectID` and a length, respectively, for each block of objects.  \n  \n The next two arguments of `SurvivingReferences2` are parallel arrays. In other words, `objectIDRangeStart` and `cObjectIDRangeLength` concern the same block of contiguous objects.  \n  \n `objectIDRangeStart`  \n [in] An array of `ObjectID` values, each of which is the starting address of a block of contiguous, live objects in memory.  \n  \n `cObjectIDRangeLength`  \n [in] An array of integers, each of which is the size of a surviving block of contiguous objects in memory.  \n  \n A size is specified for each block that is referenced in the `objectIDRangeStart` array.  \n  \n## Remarks  \n The elements of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays should be interpreted as follows to determine whether an object survived the garbage collection. Assume that an `ObjectID` value (`ObjectID`) lies within the following range:  \n  \n `ObjectIDRangeStart[i]` <= `ObjectID` < `ObjectIDRangeStart[i]` + `cObjectIDRangeLength[i]`  \n  \n For any value of `i` that is in the following range, the object has survived the garbage collection:  \n  \n 0 <= `i` < `cSurvivingObjectIDRanges`  \n  \n A non-compacting garbage collection reclaims the memory occupied by \"dead\" objects, but does not compact that freed space. As a result, memory is returned to the heap, but no \"live\" objects are moved.  \n  \n The common language runtime (CLR) calls `SurvivingReferences2` for non-compacting garbage collections. For compacting garbage collections, [MovedReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-movedreferences2-method.md) is called instead. A single garbage collection can be compacting for one generation and non-compacting for another. For a garbage collection on any particular generation, the profiler will receive either a `SurvivingReferences2` callback or a [MovedReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-movedreferences2-method.md) callback, but not both.  \n  \n Multiple `SurvivingReferences2` callbacks might be received during a particular garbage collection, because of limited internal buffering, multiple callbacks during server garbage collection, and other reasons. In the case of multiple callbacks during a garbage collection, the information is cumulative; all references that are reported in any `SurvivingReferences2` callback survive the garbage collection.  \n  \n If the profiler implements both the [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interfaces, the `SurvivingReferences2` method is called before the [ICorProfilerCallback2::SurvivingReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-survivingreferences-method.md) method, but only if `SurvivingReferences2` returns successfully. Profilers can return an HRESULT that indicates failure from the `SurvivingReferences2` method to avoid calling the second method.  \n  \n## Requirements  \n **Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).  \n  \n **Header:** CorProf.idl, CorProf.h  \n  \n **Library:** CorGuids.lib  \n  \n **.NET Framework Versions:** [!INCLUDE[net_current_v45plus](../../../../includes/net-current-v45plus-md.md)]  \n  \n## See Also  \n [ICorProfilerCallback Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)   \n [ICorProfilerCallback2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)   \n [ICorProfilerCallback4 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md)","nodes":[{"pos":[4,801],"embed":true,"restype":"x-metadata","content":"title: \"ICorProfilerCallback4::SurvivingReferences2 Method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\napi_name: \n  - \"ICorProfilerCallback4.SurvivingReferences2\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerCallback4::SurvivingReferences2\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ICorProfilerCallback4::SurvivingReferences2 method [.NET Framework profiling]\"\n  - \"SurvivingReferences2 method, ICorProfilerCallback4 interface [.NET Framework profiling]\"\nms.assetid: 02b51888-5d89-4e50-a915-45b7e329aad9\ntopic_type: \n  - \"apiref\"\ncaps.latest.revision: 9\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","nodes":[{"content":"ICorProfilerCallback4::SurvivingReferences2 Method | Microsoft Docs","nodes":[{"pos":[0,67],"content":"ICorProfilerCallback4::SurvivingReferences2 Method | Microsoft Docs","nodes":[{"content":"ICorProfilerCallback4::SurvivingReferences2 Method | Microsoft Docs","pos":[0,67]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[808,858],"content":"ICorProfilerCallback4::SurvivingReferences2 Method","linkify":"ICorProfilerCallback4::SurvivingReferences2 Method","nodes":[{"content":"ICorProfilerCallback4::SurvivingReferences2 Method","pos":[0,50]}]},{"content":"Reports the layout of objects in the heap as a result of a non-compacting garbage collection.","pos":[859,952]},{"content":"This method is called if the profiler has implemented the <bpt id=\"p1\">[</bpt>ICorProfilerCallback4<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md)</ept> interface.","pos":[953,1132],"source":" This method is called if the profiler has implemented the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface."},{"content":"This callback replaces the <bpt id=\"p1\">[</bpt>ICorProfilerCallback2::SurvivingReferences<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-survivingreferences-method.md)</ept> method, because it can report larger ranges of objects whose lengths exceed what can be expressed in a ULONG.","pos":[1133,1418],"source":" This callback replaces the [ICorProfilerCallback2::SurvivingReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-survivingreferences-method.md) method, because it can report larger ranges of objects whose lengths exceed what can be expressed in a ULONG."},{"pos":[1427,1433],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1728,1738],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] The number of blocks of contiguous objects that survived as the result of the non-compacting garbage collection.","pos":[1772,1889]},{"content":"That is, the value of <ph id=\"ph1\">`cSurvivingObjectIDRanges`</ph> is the size of the <ph id=\"ph2\">`objectIDRangeStart`</ph> and <ph id=\"ph3\">`cObjectIDRangeLength`</ph> arrays, which store an <ph id=\"ph4\">`ObjectID`</ph> and a length, respectively, for each block of objects.","pos":[1890,2094],"source":" That is, the value of `cSurvivingObjectIDRanges` is the size of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays, which store an `ObjectID` and a length, respectively, for each block of objects."},{"content":"The next two arguments of <ph id=\"ph1\">`SurvivingReferences2`</ph> are parallel arrays.","pos":[2101,2170],"source":"The next two arguments of `SurvivingReferences2` are parallel arrays."},{"content":"In other words, <ph id=\"ph1\">`objectIDRangeStart`</ph> and <ph id=\"ph2\">`cObjectIDRangeLength`</ph> concern the same block of contiguous objects.","pos":[2171,2280],"source":" In other words, `objectIDRangeStart` and `cObjectIDRangeLength` concern the same block of contiguous objects."},{"content":"[in] An array of <ph id=\"ph1\">`ObjectID`</ph> values, each of which is the starting address of a block of contiguous, live objects in memory.","pos":[2311,2434],"source":"[in] An array of `ObjectID` values, each of which is the starting address of a block of contiguous, live objects in memory."},{"content":"[in] An array of integers, each of which is the size of a surviving block of contiguous objects in memory.","pos":[2467,2573]},{"pos":[2580,2668],"content":"A size is specified for each block that is referenced in the <ph id=\"ph1\">`objectIDRangeStart`</ph> array.","source":"A size is specified for each block that is referenced in the `objectIDRangeStart` array."},{"pos":[2677,2684],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The elements of the <ph id=\"ph1\">`objectIDRangeStart`</ph> and <ph id=\"ph2\">`cObjectIDRangeLength`</ph> arrays should be interpreted as follows to determine whether an object survived the garbage collection.","pos":[2688,2859],"source":"The elements of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays should be interpreted as follows to determine whether an object survived the garbage collection."},{"content":"Assume that an <ph id=\"ph1\">`ObjectID`</ph> value (<ph id=\"ph2\">`ObjectID`</ph>) lies within the following range:","pos":[2860,2937],"source":" Assume that an `ObjectID` value (`ObjectID`) lies within the following range:"},{"pos":[3042,3142],"content":"For any value of <ph id=\"ph1\">`i`</ph> that is in the following range, the object has survived the garbage collection:","source":"For any value of `i` that is in the following range, the object has survived the garbage collection:"},{"pos":[3149,3186],"content":"0 &lt;= <ph id=\"ph1\">`i`</ph><ph id=\"ph2\"> &lt; </ph><ph id=\"ph3\">`cSurvivingObjectIDRanges`</ph>","source":"0 <= `i` < `cSurvivingObjectIDRanges`"},{"content":"A non-compacting garbage collection reclaims the memory occupied by \"dead\" objects, but does not compact that freed space.","pos":[3193,3315]},{"content":"As a result, memory is returned to the heap, but no \"live\" objects are moved.","pos":[3316,3393]},{"content":"The common language runtime (CLR) calls <ph id=\"ph1\">`SurvivingReferences2`</ph> for non-compacting garbage collections.","pos":[3400,3502],"source":"The common language runtime (CLR) calls `SurvivingReferences2` for non-compacting garbage collections."},{"content":"For compacting garbage collections, <bpt id=\"p1\">[</bpt>MovedReferences2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-movedreferences2-method.md)</ept> is called instead.","pos":[3503,3677],"source":" For compacting garbage collections, [MovedReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-movedreferences2-method.md) is called instead."},{"content":"A single garbage collection can be compacting for one generation and non-compacting for another.","pos":[3678,3774]},{"content":"For a garbage collection on any particular generation, the profiler will receive either a <ph id=\"ph1\">`SurvivingReferences2`</ph> callback or a <bpt id=\"p1\">[</bpt>MovedReferences2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-movedreferences2-method.md)</ept> callback, but not both.","pos":[3775,4045],"source":" For a garbage collection on any particular generation, the profiler will receive either a `SurvivingReferences2` callback or a [MovedReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-movedreferences2-method.md) callback, but not both."},{"content":"Multiple <ph id=\"ph1\">`SurvivingReferences2`</ph> callbacks might be received during a particular garbage collection, because of limited internal buffering, multiple callbacks during server garbage collection, and other reasons.","pos":[4052,4262],"source":"Multiple `SurvivingReferences2` callbacks might be received during a particular garbage collection, because of limited internal buffering, multiple callbacks during server garbage collection, and other reasons."},{"content":"In the case of multiple callbacks during a garbage collection, the information is cumulative; all references that are reported in any <ph id=\"ph1\">`SurvivingReferences2`</ph> callback survive the garbage collection.","pos":[4263,4460],"source":" In the case of multiple callbacks during a garbage collection, the information is cumulative; all references that are reported in any `SurvivingReferences2` callback survive the garbage collection."},{"content":"If the profiler implements both the <bpt id=\"p1\">[</bpt>ICorProfilerCallback<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept> and the <bpt id=\"p2\">[</bpt>ICorProfilerCallback4<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md)</ept> interfaces, the <ph id=\"ph1\">`SurvivingReferences2`</ph> method is called before the <bpt id=\"p3\">[</bpt>ICorProfilerCallback2::SurvivingReferences<ept id=\"p3\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-survivingreferences-method.md)</ept> method, but only if <ph id=\"ph2\">`SurvivingReferences2`</ph> returns successfully.","pos":[4467,5011],"source":"If the profiler implements both the [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interfaces, the `SurvivingReferences2` method is called before the [ICorProfilerCallback2::SurvivingReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-survivingreferences-method.md) method, but only if `SurvivingReferences2` returns successfully."},{"content":"Profilers can return an HRESULT that indicates failure from the <ph id=\"ph1\">`SurvivingReferences2`</ph> method to avoid calling the second method.","pos":[5012,5141],"source":" Profilers can return an HRESULT that indicates failure from the `SurvivingReferences2` method to avoid calling the second method."},{"pos":[5150,5162],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[5166,5270],"content":"<bpt id=\"p1\">**</bpt>Platforms:<ept id=\"p1\">**</ept> See <bpt id=\"p2\">[</bpt>System Requirements<ept id=\"p2\">](../../../../docs/framework/get-started/system-requirements.md)</ept>.","source":"**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md)."},{"pos":[5277,5311],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> CorProf.idl, CorProf.h","source":"**Header:** CorProf.idl, CorProf.h"},{"pos":[5318,5343],"content":"<bpt id=\"p1\">**</bpt>Library:<ept id=\"p1\">**</ept> CorGuids.lib","source":"**Library:** CorGuids.lib"},{"pos":[5350,5378],"content":"<bpt id=\"p1\">**</bpt>.NET Framework Versions:<ept id=\"p1\">**</ept>","source":"**.NET Framework Versions:**"},{"pos":[5467,5475],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept><ph id=\"ph1\"> </ph>","pos":[5479,5598],"source":"[ICorProfilerCallback Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) "},{"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback2 Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept><ph id=\"ph1\"> </ph>","pos":[5602,5723],"source":"[ICorProfilerCallback2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) "},{"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback4 Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md)</ept>","pos":[5727,5847],"source":"[ICorProfilerCallback4 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md)"}]}