{"content":"---\ntitle: \"Key Security Concepts\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\n  - \"cpp\"\nhelpviewer_keywords: \n  - \"unauthorized access\"\n  - \"permissions [.NET Framework]\"\n  - \"security [.NET Framework], about security\"\nms.assetid: 3cfced4f-ea02-4e66-ae98-d69286363e98\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Key Security Concepts\nThe Microsoft .NET Framework offers role-based security to help address security concerns about mobile code and to provide support that enables components to determine what users are authorized to do.  \n  \n## Type safety and security  \n Type-safe code accesses only the memory locations it is authorized to access. (For this discussion, type safety specifically refers to memory type safety and should not be confused with type safety in a broader respect.) For example, type-safe code cannot read values from another object's private fields. It accesses types only in well-defined, allowable ways.  \n  \n During just-in-time (JIT) compilation, an optional verification process examines the metadata and Microsoft intermediate language (MSIL) of a method to be JIT-compiled into native machine code to verify that they are type safe. This process is skipped if the code has permission to bypass verification. For more information about verification, see [Managed Execution Process](../../../docs/standard/managed-execution-process.md).  \n  \n Although verification of type safety is not mandatory to run managed code, type safety plays a crucial role in assembly isolation and security enforcement. When code is type safe, the common language runtime can completely isolate assemblies from each other. This isolation helps ensure that assemblies cannot adversely affect each other and it increases application reliability. Type-safe components can execute safely in the same process even if they are trusted at different levels. When code is not type safe, unwanted side effects can occur. For example, the runtime cannot prevent managed code from calling into native (unmanaged) code and performing malicious operations. When code is type safe, the runtime's security enforcement mechanism ensures that it does not access native code unless it has permission to do so. All code that is not type safe must have been granted <xref:System.Security.Permissions.SecurityPermission> with the passed enum member <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A> to run.  \n  \n For more information, see [Code Access Security Basics](../../../docs/framework/misc/code-access-security-basics.md).  \n  \n## Principal  \n A principal represents the identity and role of a user and acts on the user's behalf. Role-based security in the .NET Framework supports three kinds of principals:  \n  \n-   Generic principals represent users and roles that exist independent of Windows users and roles.  \n  \n-   Windows principals represent Windows users and their roles (or their Windows groups). A Windows principal can impersonate another user, which means that the principal can access a resource on a user's behalf while presenting the identity that belongs to that user.  \n  \n-   Custom principals can be defined by an application in any way that is needed for that particular application. They can extend the basic notion of the principal's identity and roles.  \n  \n For more information, see [Principal and Identity Objects](../../../docs/standard/security/principal-and-identity-objects.md).  \n  \n## Authentication  \n Authentication is the process of discovering and verifying the identity of a principal by examining the user's credentials and validating those credentials against some authority. The information obtained during authentication is directly usable by your code. You can also use .NET Framework role-based security to authenticate the current user and to determine whether to allow that principal to access your code. See the overloads of the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> method for examples of how to authenticate the principal for specific roles. For example, you can use the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> overload to determine if the current user is a member of the Administrators group.  \n  \n A variety of authentication mechanisms are used today, many of which can be used with .NET Framework role-based security. Some of the most commonly used mechanisms are basic, digest, Passport, operating system (such as NTLM or Kerberos), or application-defined mechanisms.  \n  \n### Example  \n The following example requires that the active principal be an administrator. The `name` parameter is `null`, which allows any user who is an administrator to pass the demand.  \n  \n> [!NOTE]\n>  In Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that requires you to be an administrator, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n [!code-cpp[Classic PrincipalPermission Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CPP/source.cpp#1)]\n [!code-csharp[Classic PrincipalPermission Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CS/source.cs#1)]\n [!code-vb[Classic PrincipalPermission Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/VB/source.vb#1)]  \n  \n The following example demonstrates how to determine the identity of the principal and the roles available to the principal. An application of this example might be to confirm that the current user is in a role you allow for using your application.  \n  \n [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]\n [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]\n [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  \n  \n## Authorization  \n Authorization is the process of determining whether a principal is allowed to perform a requested action. Authorization occurs after authentication and uses information about the principal's identity and roles to determine what resources the principal can access. You can use .NET Framework role-based security to implement authorization.\n","nodes":[{"pos":[4,348],"embed":true,"restype":"x-metadata","content":"title: \"Key Security Concepts\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\n  - \"cpp\"\nhelpviewer_keywords: \n  - \"unauthorized access\"\n  - \"permissions [.NET Framework]\"\n  - \"security [.NET Framework], about security\"\nms.assetid: 3cfced4f-ea02-4e66-ae98-d69286363e98\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Key Security Concepts","nodes":[{"pos":[0,21],"content":"Key Security Concepts","nodes":[{"content":"Key Security Concepts","pos":[0,21]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[355,376],"content":"Key Security Concepts","linkify":"Key Security Concepts","nodes":[{"content":"Key Security Concepts","pos":[0,21]}]},{"content":"The Microsoft .NET Framework offers role-based security to help address security concerns about mobile code and to provide support that enables components to determine what users are authorized to do.","pos":[377,577]},{"pos":[586,610],"content":"Type safety and security","linkify":"Type safety and security","nodes":[{"content":"Type safety and security","pos":[0,24]}]},{"content":"Type-safe code accesses only the memory locations it is authorized to access.","pos":[614,691]},{"content":"(For this discussion, type safety specifically refers to memory type safety and should not be confused with type safety in a broader respect.) For example, type-safe code cannot read values from another object's private fields.","pos":[692,919]},{"content":"It accesses types only in well-defined, allowable ways.","pos":[920,975]},{"content":"During just-in-time (JIT) compilation, an optional verification process examines the metadata and Microsoft intermediate language (MSIL) of a method to be JIT-compiled into native machine code to verify that they are type safe.","pos":[982,1209]},{"content":"This process is skipped if the code has permission to bypass verification.","pos":[1210,1284]},{"content":"For more information about verification, see <bpt id=\"p1\">[</bpt>Managed Execution Process<ept id=\"p1\">](../../../docs/standard/managed-execution-process.md)</ept>.","pos":[1285,1411],"source":" For more information about verification, see [Managed Execution Process](../../../docs/standard/managed-execution-process.md)."},{"content":"Although verification of type safety is not mandatory to run managed code, type safety plays a crucial role in assembly isolation and security enforcement.","pos":[1418,1573]},{"content":"When code is type safe, the common language runtime can completely isolate assemblies from each other.","pos":[1574,1676]},{"content":"This isolation helps ensure that assemblies cannot adversely affect each other and it increases application reliability.","pos":[1677,1797]},{"content":"Type-safe components can execute safely in the same process even if they are trusted at different levels.","pos":[1798,1903]},{"content":"When code is not type safe, unwanted side effects can occur.","pos":[1904,1964]},{"content":"For example, the runtime cannot prevent managed code from calling into native (unmanaged) code and performing malicious operations.","pos":[1965,2096]},{"content":"When code is type safe, the runtime's security enforcement mechanism ensures that it does not access native code unless it has permission to do so.","pos":[2097,2244]},{"content":"All code that is not type safe must have been granted <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the passed enum member <ph id=\"ph2\">&lt;xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A&gt;</ph> to run.","pos":[2245,2471],"source":" All code that is not type safe must have been granted <xref:System.Security.Permissions.SecurityPermission> with the passed enum member <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A> to run."},{"pos":[2478,2595],"content":"For more information, see <bpt id=\"p1\">[</bpt>Code Access Security Basics<ept id=\"p1\">](../../../docs/framework/misc/code-access-security-basics.md)</ept>.","source":"For more information, see [Code Access Security Basics](../../../docs/framework/misc/code-access-security-basics.md)."},{"pos":[2604,2613],"content":"Principal","linkify":"Principal","nodes":[{"content":"Principal","pos":[0,9]}]},{"content":"A principal represents the identity and role of a user and acts on the user's behalf.","pos":[2617,2702]},{"content":"Role-based security in the .NET Framework supports three kinds of principals:","pos":[2703,2780]},{"content":"Generic principals represent users and roles that exist independent of Windows users and roles.","pos":[2790,2885]},{"content":"Windows principals represent Windows users and their roles (or their Windows groups).","pos":[2895,2980]},{"content":"A Windows principal can impersonate another user, which means that the principal can access a resource on a user's behalf while presenting the identity that belongs to that user.","pos":[2981,3159]},{"content":"Custom principals can be defined by an application in any way that is needed for that particular application.","pos":[3169,3278]},{"content":"They can extend the basic notion of the principal's identity and roles.","pos":[3279,3350]},{"pos":[3357,3483],"content":"For more information, see <bpt id=\"p1\">[</bpt>Principal and Identity Objects<ept id=\"p1\">](../../../docs/standard/security/principal-and-identity-objects.md)</ept>.","source":"For more information, see [Principal and Identity Objects](../../../docs/standard/security/principal-and-identity-objects.md)."},{"pos":[3492,3506],"content":"Authentication","linkify":"Authentication","nodes":[{"content":"Authentication","pos":[0,14]}]},{"content":"Authentication is the process of discovering and verifying the identity of a principal by examining the user's credentials and validating those credentials against some authority.","pos":[3510,3689]},{"content":"The information obtained during authentication is directly usable by your code.","pos":[3690,3769]},{"content":"You can also use .NET Framework role-based security to authenticate the current user and to determine whether to allow that principal to access your code.","pos":[3770,3924]},{"content":"See the overloads of the <ph id=\"ph1\">&lt;xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType&gt;</ph> method for examples of how to authenticate the principal for specific roles.","pos":[3925,4117],"source":" See the overloads of the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> method for examples of how to authenticate the principal for specific roles."},{"content":"For example, you can use the <ph id=\"ph1\">&lt;xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType&gt;</ph> overload to determine if the current user is a member of the Administrators group.","pos":[4118,4336],"source":" For example, you can use the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> overload to determine if the current user is a member of the Administrators group."},{"content":"A variety of authentication mechanisms are used today, many of which can be used with .NET Framework role-based security.","pos":[4343,4464]},{"content":"Some of the most commonly used mechanisms are basic, digest, Passport, operating system (such as NTLM or Kerberos), or application-defined mechanisms.","pos":[4465,4615]},{"pos":[4625,4632],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example requires that the active principal be an administrator.","pos":[4636,4713]},{"content":"The <ph id=\"ph1\">`name`</ph> parameter is <ph id=\"ph2\">`null`</ph>, which allows any user who is an administrator to pass the demand.","pos":[4714,4811],"source":" The `name` parameter is `null`, which allows any user who is an administrator to pass the demand."},{"pos":[4819,5405],"content":"[!NOTE]\n In Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that requires you to be an administrator, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.","leadings":["","> "],"nodes":[{"content":"In Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that requires you to be an administrator, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.","pos":[9,584],"nodes":[{"content":"In Windows Vista, User Account Control (UAC) determines the privileges of a user.","pos":[0,81]},{"content":"If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token.","pos":[82,248]},{"content":"By default, you are in the standard user role.","pos":[249,295]},{"content":"To execute the code that requires you to be an administrator, you must first elevate your privileges from standard user to administrator.","pos":[296,433]},{"content":"You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.","pos":[434,575]}]}]},{"content":"The following example demonstrates how to determine the identity of the principal and the roles available to the principal.","pos":[5906,6029]},{"content":"An application of this example might be to confirm that the current user is in a role you allow for using your application.","pos":[6030,6153]},{"pos":[6755,6768],"content":"Authorization","linkify":"Authorization","nodes":[{"content":"Authorization","pos":[0,13]}]},{"content":"Authorization is the process of determining whether a principal is allowed to perform a requested action.","pos":[6772,6877]},{"content":"Authorization occurs after authentication and uses information about the principal's identity and roles to determine what resources the principal can access.","pos":[6878,7035]},{"content":"You can use .NET Framework role-based security to implement authorization.","pos":[7036,7110]}]}