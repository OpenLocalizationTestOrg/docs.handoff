<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">24d405ad33cb4f11dd9e7ba7edb39f10db8041a1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\tour-of-csharp\types-and-variables.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_hi-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c614e8e96551ca01eae0ff2e51c9046de4264ba6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7333b0b73ad6cbf26fa9675cc5702a4243dc6606</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>C# Types and Variables | A tour of the C# language</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn about defining types and declaring variables in C#</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, csharp, type, reference type, value type</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Types and variables</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>There are two kinds of types in C#: <bpt id="p1">*</bpt>value types<ept id="p1">*</ept> and <bpt id="p2">*</bpt>reference types<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of <ph id="ph1">`ref`</ph> and <ph id="ph2">`out`</ph> parameter variables).</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>C#’s value types are further divided into <bpt id="p1">*</bpt>simple types<ept id="p1">*</ept>, <bpt id="p2">*</bpt>enum types<ept id="p2">*</ept>, <bpt id="p3">*</bpt>struct types<ept id="p3">*</ept>, and <bpt id="p4">*</bpt>nullable value types<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>C#’s reference types are further divided into <bpt id="p1">*</bpt>class types<ept id="p1">*</ept>, <bpt id="p2">*</bpt>interface types<ept id="p2">*</ept>, <bpt id="p3">*</bpt>array types<ept id="p3">*</ept>, and <bpt id="p4">*</bpt>delegate types<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The following provides an overview of C#’s type system.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Value types</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Simple Types</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Signed integral: <ph id="ph1">`sbyte`</ph>, <ph id="ph2">`short`</ph>, <ph id="ph3">`int`</ph>, <ph id="ph4">`long`</ph></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Unsigned integral: <ph id="ph1">`byte`</ph>, <ph id="ph2">`ushort`</ph>, <ph id="ph3">`uint`</ph>, <ph id="ph4">`ulong`</ph></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Unicode characters: <ph id="ph1">`char`</ph></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>IEEE floating point: <ph id="ph1">`float`</ph>, <ph id="ph2">`double`</ph></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>High-precision decimal: <ph id="ph1">`decimal`</ph></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Boolean: <ph id="ph1">`bool`</ph></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Enum types</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>User-defined types of the form <ph id="ph1">`enum E {...}`</ph></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Struct types</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>User-defined types of the form <ph id="ph1">`struct S {...}`</ph></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Nullable value types</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Extensions of all other value types with a <ph id="ph1">`null`</ph> value</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Reference types</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Class types</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Ultimate base class of all other types: <ph id="ph1">`object`</ph></source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Unicode strings: <ph id="ph1">`string`</ph></source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>User-defined types of the form <ph id="ph1">`class C {...}`</ph></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Interface types</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>User-defined types of the form <ph id="ph1">`interface I {...}`</ph></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Array types</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Single- and multi-dimensional, for example, <ph id="ph1">`int[]`</ph> and <ph id="ph2">`int[,]`</ph></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Delegate types</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>User-defined types of the form <ph id="ph1">`delegate int D(...)`</ph></source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The two floating-point types, <ph id="ph1">`float`</ph> and <ph id="ph2">`double`</ph>, are represented using the 32-bit single-precision and 64-bit double-precision IEC-60559 formats, respectively.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`decimal`</ph> type is a 128-bit data type suitable for financial and monetary calculations.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>C#’s <ph id="ph1">`bool`</ph> type is used to represent Boolean values—values that are either <ph id="ph2">`true`</ph> or <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Character and string processing in C# uses Unicode encoding.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`char`</ph> type represents a UTF-16 code unit, and the <ph id="ph2">`string`</ph> type represents a sequence of UTF-16 code units.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This summarizes C#’s numeric types.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Signed Integral</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`sbyte`</ph>:  8 bits, range from -128 - 127</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`short`</ph>: 16 bits, range from -32,768 - 32,767</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`int`</ph>  : 32 bits, range from -2,147,483,648 - 2,147,483,647</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`long`</ph> : 64 bits, range from –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Unsigned integral</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`byte`</ph>   :  8 bits, range from 0 - 255</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ushort`</ph> : 16 bits, range from 0 - 65,535</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`uint`</ph>   : 32 bits, range from 0 - 4,294,967,295</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ulong`</ph>  : 64 bits, range from 0 - 18,446,744,073,709,551,615</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Floating point</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`float`</ph>  : 32 bits, range from 1.5 × 10<bpt id="p1">&lt;sup&gt;</bpt>−45<ept id="p1">&lt;/sup&gt;</ept> - 3.4 × 10<bpt id="p2">&lt;sup&gt;</bpt>38<ept id="p2">&lt;/sup&gt;</ept>,    7-digit precision</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`double`</ph> : 64 bits, range from 5.0 × 10<bpt id="p1">&lt;sup&gt;</bpt>−324<ept id="p1">&lt;/sup&gt;</ept> - 1.7 × 10<bpt id="p2">&lt;sup&gt;</bpt>308<ept id="p2">&lt;/sup&gt;</ept>, 15-digit precision</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Decimal</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`decimal`</ph> : 128 bits, range is at least –7.9 × 10<bpt id="p1">&lt;sup&gt;</bpt>−28<ept id="p1">&lt;/sup&gt;</ept> -  7.9 × 10<bpt id="p2">&lt;sup&gt;</bpt>28<ept id="p2">&lt;/sup&gt;</ept>, with at least 28-digit precision</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>C# programs use <bpt id="p1">*</bpt>type declarations<ept id="p1">*</ept> to create new types.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>A type declaration specifies the name and the members of the new type.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`class`</ph> type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`struct`</ph> type is similar to a class type in that it represents a structure with data members and function members.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>However, unlike classes, structs are value types and do not typically require heap allocation.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <ph id="ph1">`object`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`interface`</ph> type defines a contract as a named set of public function members.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`class`</ph> or <ph id="ph2">`struct`</ph> that implements an <ph id="ph3">`interface`</ph> must provide implementations of the interface’s function members.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`interface`</ph> may inherit from multiple base interfaces, and a <ph id="ph2">`class`</ph> or <ph id="ph3">`struct`</ph> may implement multiple interfaces.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`delegate`</ph> type represents references to methods with a particular parameter list and return type.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Delegates are analogous to function types provided by functional languages.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`class`</ph>, <ph id="ph2">`struct`</ph>, <ph id="ph3">`interface`</ph> and <ph id="ph4">`delegate`</ph> types all support generics, whereby they can be parameterized with other types.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`enum`</ph> type is a distinct type with named constants.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Every <ph id="ph1">`enum`</ph> type has an underlying type, which must be one of the eight integral types.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The set of values of an <ph id="ph1">`enum`</ph> type is the same as the set of values of the underlying type.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>C# supports single- and multi-dimensional arrays of any type.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Unlike the types listed above, array types do not have to be declared before they can be used.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Instead, array types are constructed by following a type name with square brackets.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`int[]`</ph> is a single-dimensional array of <ph id="ph2">`int`</ph>, <ph id="ph3">`int[,]`</ph> is a two-dimensional array of <ph id="ph4">`int`</ph>, and <ph id="ph5">`int[][]`</ph> is a single-dimensional array of single-dimensional array of <ph id="ph6">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Nullable value types also do not have to be declared before they can be used.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For each non-nullable value type <ph id="ph1">`T`</ph> there is a corresponding nullable value type <ph id="ph2">`T?`</ph>, which can hold an additional value, <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For instance, <ph id="ph1">`int?`</ph> is a type that can hold any 32-bit integer or the value <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>C#’s type system is unified such that a value of any type can be treated as an <ph id="ph1">`object`</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Every type in C# directly or indirectly derives from the <ph id="ph1">`object`</ph> class type, and <ph id="ph2">`object`</ph> is the ultimate base class of all types.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Values of reference types are treated as objects simply by viewing the values as type <ph id="ph1">`object`</ph>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Values of value types are treated as objects by performing <bpt id="p1">*</bpt>boxing<ept id="p1">*</ept> and <bpt id="p2">*</bpt>unboxing operations<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In the following example, an <ph id="ph1">`int`</ph> value is converted to <ph id="ph2">`object`</ph> and back again to <ph id="ph3">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Boxing<ept id="p2">](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>When a value of a value type is converted to type <ph id="ph1">`object`</ph>, an <ph id="ph2">`object`</ph> instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Conversely, when an <ph id="ph1">`object`</ph> reference is cast to a value type, a check is made that the referenced <ph id="ph2">`object`</ph> is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>C#’s unified type system effectively means that value types can become objects "on demand."</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Because of the unification, general-purpose libraries that use type <ph id="ph1">`object`</ph> can be used with both reference types and value types.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>There are several kinds of <bpt id="p1">*</bpt>variables<ept id="p1">*</ept> in C#, including fields, array elements, local variables, and parameters.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Non-nullable value type</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>A value of that exact type</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Nullable value type</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`null`</ph> value or a value of that exact type</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>object</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`null`</ph> reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Class type</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`null`</ph> reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Interface type</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`null`</ph> reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Array type</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`null`</ph> reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Delegate type</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`null`</ph> reference or a reference to an instance of a compatible delegate type</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Previous<ept id="p1">](program-structure.md)</ept><ph id="ph1">
</ph><bpt id="p2">[</bpt>Next<ept id="p2">](expressions.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>