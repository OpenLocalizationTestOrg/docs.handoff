<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">af227154fba65e3dbef24ed53330fb12d84b598e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\regular-expression-options.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c606f8cc10246146354a82c8fcc6502bd3775d09</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5a7cfd8470e7f24aa3c1d754f22569f0281a1f90</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular Expression Options | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular Expression Options</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex?displayProperty=fullName&gt;</ph> class constructor or static pattern matching method as a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> enumeration value.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>RegexOptions member</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Inline character</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Effect</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Not available</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Use default behavior.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Default Options<ept id="p1">](#Default)</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Use case-insensitive matching.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Case-Insensitive Matching<ept id="p1">](#Case)</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Use multiline mode, where <ph id="ph1">`^`</ph> and <ph id="ph2">`$`</ph> match the beginning and end of each line (instead of the beginning and end of the input string).</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Multiline Mode<ept id="p1">](#Multiline)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Use single-line mode, where the period (.) matches every character (instead of every character except <ph id="ph1">`\n`</ph>).</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Singleline Mode<ept id="p1">](#Singleline)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Do not capture unnamed groups.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The only valid captures are explicitly named or numbered groups of the form <ph id="ph1">`(?&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph> <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><ph id="ph3">`)`</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Explicit Captures Only<ept id="p1">](#Explicit)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Not available</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Compile the regular expression to an assembly.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiled Regular Expressions<ept id="p1">](#Compiled)</ept>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Exclude unescaped white space from the pattern, and enable comments after a number sign (<ph id="ph1">`#`</ph>).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Ignore Whitespace<ept id="p1">](#Whitespace)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Not available</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Change the search direction.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Search moves from right to left instead of from left to right.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Right-to-Left Mode<ept id="p1">](#RightToLeft)</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Not available</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Enable ECMAScript-compliant behavior for the expression.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ECMAScript Matching Behavior<ept id="p1">](#ECMAScript)</ept>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Not available</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Ignore cultural differences in language.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Comparison Using the Invariant Culture<ept id="p1">](#Invariant)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Specifying the Options</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can specify options for regular expressions in one of three ways:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`options`</ph> parameter of a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex?displayProperty=fullName&gt;</ph> class constructor or static (<ph id="ph3">`Shared`</ph> in Visual Basic) pattern-matching method, such as <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=fullName&gt;</ph> or <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`options`</ph> parameter is a bitwise OR combination of <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> enumerated values.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When options are supplied to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance by using the <ph id="ph2">`options`</ph> parameter of a class constructor, the options are are assigned to the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> property does not reflect inline options in the regular expression pattern itself.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>It uses the <ph id="ph1">`options`</ph> parameter of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=fullName&gt;</ph> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#6<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#6<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By applying inline options in a regular expression pattern with the syntax <ph id="ph1">`(?imnsx-imnsx)`</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> property of a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance does not reflect these inline options.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Miscellaneous Constructs<ept id="p1">](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#7<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#7<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>By applying inline options in a particular grouping construct in a regular expression pattern with the syntax <ph id="ph1">`(?imnsx-imnsx:`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`?`</ph> is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#8<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#8<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If options are specified inline, a minus sign (<ph id="ph1">`-`</ph>) before an option or set of options turns off those options.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, the inline construct <ph id="ph1">`(?ix-ms)`</ph> turns on the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> options and turns off the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> options.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>All regular expression options are turned off by default.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the regular expression options specified in the <ph id="ph1">`options`</ph> parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set both with the options parameter and inline:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set using the <ph id="ph1">`options`</ph> parameter but cannot be set inline:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Determining the Options</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You can determine which options were provided to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object when it was instantiated by retrieving the value of the read-only <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To test for the presence of any option except <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph>, perform an AND operation with the value of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=fullName&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> value in which you are interested.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Then test whether the result equals that <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following example tests whether the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option has been set.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#19<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#19<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>To test for <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph>, determine whether the value of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=fullName&gt;</ph> property is equal to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#20<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#20<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The following sections list the options supported by regular expression in .NET.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Default Options</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This includes the following:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is matched in the input string from left to right.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Comparisons are case-sensitive.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`^`</ph> and <ph id="ph2">`$`</ph> language elements match the beginning and end of the input string.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`.`</ph> language element matches every character except <ph id="ph2">`\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Any white space in a regular expression pattern is interpreted as a literal space character.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The conventions of the current culture are used when comparing the pattern to the input string.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Capturing groups in the regular expression pattern are implicit as well as explicit.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option has no inline equivalent.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i)`</ph> turns on case-insensitive comparison, and <ph id="ph2">`(?-i)`</ph> restores the default case-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A constructor or static pattern-matching method without an <ph id="ph1">`options`</ph> parameter is called instead.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Case-Insensitive Matching</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> option, or the <ph id="ph2">`i`</ph> inline option, provides case-insensitive matching.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>By default, the casing conventions of the current culture are used.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression pattern, <ph id="ph1">`\bthe\w*\b`</ph>, that matches all words starting with "the".</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Because the first call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>It is matched when the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method is called with options set to <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#1<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#1<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The following example modifies the regular expression pattern from the previous example to use inline options instead of the <ph id="ph1">`options`</ph> parameter to provide case-insensitive comparison.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#2<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#2<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Multiline Mode</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option, or the <ph id="ph2">`m`</ph> inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It changes the interpretation of the <ph id="ph1">`^`</ph> and <ph id="ph2">`$`</ph> language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">`$`</ph> matches only the end of the input string.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option, it matches either the newline character (<ph id="ph2">`\n`</ph>) or the end of the input string.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>It does not, however, match the carriage return/line feed character combination.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>To successfully match them, use the subexpression <ph id="ph1">`\r?$`</ph> instead of just <ph id="ph2">`$`</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The following example extracts bowlers' names and scores and adds them to a <ph id="ph1">&lt;xref:System.Collections.Generic.SortedList%602&gt;</ph> collection that sorts them in descending order.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method is called twice.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In the first method call, the regular expression is <ph id="ph1">`^(\w+)\s(\d+)$`</ph> and no options are set.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In the second method call, the regular expression is changed to <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> and the options are set to <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#3<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#3<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Begin at the start of the line.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Match zero or one carriage return character.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>End at the end of the line.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <ph id="ph1">`(?m)`</ph> to set the multiline option.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#4<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#4<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Single-line Mode</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option, or the <ph id="ph2">`s`</ph> inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>It does this by changing the behavior of the period (<ph id="ph1">`.`</ph>) language element so that it matches every character, instead of matching every character except for the newline character <ph id="ph2">`\n`</ph> or \u000A.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the behavior of the <ph id="ph1">`.`</ph> language element changes when you use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^.+`</ph> starts at the beginning of the string and matches every character.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, <ph id="ph1">`\r`</ph> or \u000D, but it does not match <ph id="ph2">`\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option interprets the entire input string as a single line, it matches every character in the input string, including <ph id="ph2">`\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.CharacterClasses#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.CharacterClasses#5<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <ph id="ph1">`(?s)`</ph> to enable single-line mode.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#5<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Explicit Captures Only</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Named groups are assigned a name or number by the <ph id="ph1">`(?&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><ph id="ph3">`)`</ph> language option, whereas unnamed groups are accessible by index.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object, unnamed groups precede named groups.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For example, if the following regular expression:</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object) is of interest.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The individual words in the collection are not.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> collection objects.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use either the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option or the <ph id="ph2">`n`</ph> inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the <ph id="ph3">`(?&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph4">`&gt;`</ph> <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><ph id="ph5">`)`</ph> construct.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The following example displays information about the matches returned by the <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> regular expression pattern when the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method is called with and without the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>As the output from the first method call shows, the regular expression engine fully populates the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> collection objects with information about captured substrings.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because the second method is called with <ph id="ph1">`options`</ph> set to <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph>, it does not capture information on groups.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#9<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#9<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The regular expression pattern<ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Begin at a word boundary.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrences of the opening parenthesis ("(").</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match one or more word characters, followed by zero or one commas.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Do not backtrack when matching word characters.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space characters.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>You can also use the <ph id="ph1">`(?n)`</ph> inline element to suppress automatic captures.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous regular expression pattern to use the <ph id="ph1">`(?n)`</ph> inline element instead of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#10<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#10<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Finally, you can use the inline group element <ph id="ph1">`(?n:)`</ph> to suppress automatic captures on a group-by-group basis.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous pattern to suppress unnamed captures in the outer group, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Note that this suppresses unnamed captures in the inner group as well.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#11<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#11<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Compiled Regular Expressions</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>By default, regular expressions in .NET are interpreted.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>When a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is instantiated or a static <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You can use compiled instead of interpreted regular expressions by using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions maximize run-time performance at the expense of initialization time.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>A regular expression can be compiled only by supplying the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> value to the <ph id="ph2">`options`</ph> parameter of a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or a static pattern-matching method.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>You can use compiled regular expressions in calls to both static and instance regular expressions.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In static regular expressions, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option is passed to the <ph id="ph2">`options`</ph> parameter of the regular expression pattern-matching method.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In instance regular expressions, it is passed to the <ph id="ph1">`options`</ph> parameter of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>In both cases, it results in enhanced performance.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>However, this improvement in performance occurs only under the following conditions:</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is not allowed to go out of scope, so it can be reused.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>A static regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option is unrelated to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=fullName&gt;</ph> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Ignore White Space</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Because of this, the regular expression "<ph id="ph1">`\b\w+\s`</ph>" and "<ph id="ph2">`\b\w+`</ph> " are roughly equivalent regular expressions.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option, or the <ph id="ph2">`x`</ph> inline option, changes this default behavior as follows:</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Unescaped white space in the regular expression pattern is ignored.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>To be part of a regular expression pattern, white-space characters must be escaped (for example, as <ph id="ph1">`\s`</ph> or "<ph id="ph2">`\`</ph> ").</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>However, in the following cases, white space characters in a regular expression aren't ignored, even if you use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option:</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>White space within a character class is always interpreted literally.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`[ .,;:]`</ph> matches any single white-space character, period, comma, semicolon, or colon.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a bracketed quantifier, such as <ph id="ph1">`{`</ph><bpt id="p1">*</bpt><ph id="ph2">n</ph><ept id="p1">*</ept><ph id="ph3">`}`</ph>, <ph id="ph4">`{`</ph><bpt id="p2">*</bpt><ph id="ph5">n</ph><ept id="p2">*</ept><ph id="ph6">`,}`</ph>, and <ph id="ph7">`{`</ph><bpt id="p3">*</bpt><ph id="ph8">n</ph><ept id="p3">*</ept><ph id="ph9">`,`</ph><bpt id="p4">*</bpt>m<ept id="p4">*</ept><ph id="ph10">`}`</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`\d{1. 3}`</ph> fails to match any sequences of digits from one to three digits because it contains a white-space character.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a character sequence that introduces a language element.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The language element <ph id="ph1">`(?:`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> represents a noncapturing group, and the <ph id="ph3">`(?:`</ph> portion of the element can't have embedded spaces.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The pattern <ph id="ph1">`(? :`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> throws an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph> at run time because the regular expression engine can't parse the pattern, and the pattern <ph id="ph4">`( ?:`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><ph id="ph5">`)`</ph> fails to match <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The language element <ph id="ph1">`\p{`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`}`</ph>, which represents a Unicode category or named block, can't include embedded spaces in the <ph id="ph3">`\p{`</ph> portion of the element.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>If you do include a white space, the element throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> at run time.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>It improves readability, and makes it possible to document a regular expression.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The following example defines the following regular expression pattern:</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>This pattern is similar to the pattern defined in the <bpt id="p1">[</bpt>Explicit Captures Only<ept id="p1">](#Explicit)</ept> section, except that it uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option to ignore pattern white space.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#12<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#12<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The following example uses the inline option <ph id="ph1">`(?x)`</ph> to ignore pattern white space.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#13<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#13<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Right-to-Left Mode</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine searches from left to right.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>You can reverse the search direction by using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The search automatically begins at the last character position of the string.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>For pattern-matching methods that include a starting position parameter, such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=fullName&gt;</ph>, the starting position is the index of the rightmost character position at which the search is to begin.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Right-to-left pattern mode is available only by supplying the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> value to the <ph id="ph2">`options`</ph> parameter of a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or static pattern-matching method.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\bb\w+\s`</ph> matches words that begin with the letter "b" and are followed by a white-space character.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>In the following example, the input string consists of three words that include one or more "b" characters.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, only the first word matches the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#17<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#17<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Also note that the lookahead assertion (the <ph id="ph1">`(?=`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> language element) and the lookbehind assertion (the <ph id="ph3">`(?&lt;=`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><ph id="ph4">`)`</ph> language element) do not change direction.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The lookahead assertions look to the right; the lookbehind assertions look to the left.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> uses the lookbehind assertion to test for a date that precedes a month name.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The regular expression then matches the month and the year.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>For information on lookahead and lookbehind assertsions, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#18<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#18<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The beginning of the match must be preceded by one or two decimal digits followed by a space.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Match zero or one comma characters.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>ECMAScript Matching Behavior</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>ECMAScript-compliant behavior is available only by supplying the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> value to the <ph id="ph2">`options`</ph> parameter of a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or static pattern-matching method.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option can be combined only with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> options.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The use of any other option in a regular expression results in an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Character class syntax.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>For example, ECMAScript does not support language elements such as the Unicode category or block elements <ph id="ph1">`\p`</ph> and <ph id="ph2">`\P`</ph>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Similarly, the <ph id="ph1">`\w`</ph> element, which matches a word character, is equivalent to the <ph id="ph2">`[a-zA-Z_0-9]`</ph> character class when using ECMAScript and <ph id="ph3">`[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]`</ph> when using canonical behavior.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character Classes<ept id="p1">](../../../docs/standard/base-types/character-classes-in-regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between canonical and ECMAScript pattern matching.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`\b(\w+\s*)+`</ph>, that matches words followed by white-space characters.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>As the output shows, the call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=fullName&gt;</ph> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#16<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#16<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Self-referencing capturing groups.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A regular expression capture class with a backreference to itself must be updated with each capture iteration.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>As the following example shows, this feature enables the regular expression <ph id="ph1">`((a+)(\1) ?)+`</ph> to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#21<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#21<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The regular expression is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>(a+)</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Match the letter "a" one or more times.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>(\1)</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Match the substring captured by the first capturing group.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>?</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Match zero or one space characters.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>((a+)(\1) ?)+</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Resolution of ambiguities between octal escapes and backreferences.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Regular expression</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Canonical behavior</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>ECMAScript behavior</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\0`</ph> followed by 0 to 2 octal digits</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Interpret as an octal.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`\044`</ph> is always interpreted as an octal value and means "$".</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Same behavior.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\`</ph> followed by a digit from 1 to 9, followed by no additional decimal digits,</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Interpret as a backreference.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`\9`</ph> always means backreference 9, even if a ninth capturing group does not exist.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>If the capturing group does not exist, the regular expression parser throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>If a single decimal digit capturing group exists, backreference to that digit.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Otherwise, interpret the value as a literal.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\`</ph> followed by a digit from 1 to 9, followed by additional decimal digits</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Interpret the digits as a decimal value.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>If that capturing group exists, interpret the expression as a backreference.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Interpret the remaining digits as literals.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>For example, in the expression <ph id="ph1">`\3000`</ph>, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Comparison Using the Invariant Culture</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>The following example illustrates such as scenario.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The code is intended to block access to any resource whose URL is prefaced with <bpt id="p1">**</bpt>FILE://<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The regular expression attempts a case-insensitive match with the string by using the regular expression <ph id="ph1">`$FILE://`</ph>.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>As a result, the call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method returns <ph id="ph2">`false`</ph>, and access to the file is allowed.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#14<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#14<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>For more information about string comparisons that are case-sensitive and that use the invariant culture, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](../../../docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Instead of using the case-insensitive comparisons of the current culture, you can specify the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option to ignore cultural differences in language and to use the conventions of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Comparison using the invariant culture is available only by supplying the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> value to the <ph id="ph2">`options`</ph> parameter of a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or static pattern-matching method.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous example, except that the static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=fullName&gt;</ph> method is called with options that include <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.Options#15<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.Options#15<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>