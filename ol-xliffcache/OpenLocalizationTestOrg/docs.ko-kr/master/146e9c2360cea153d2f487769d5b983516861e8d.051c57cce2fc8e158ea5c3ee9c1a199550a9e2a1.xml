{"content":"---\ntitle: \"Tuples in Visual Basic\"\nms.date: 04/23/2017\nhelpviewer_keywords: \n  - \"tuples [Visual Basic]\"\nms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f\n---\n# Tuples (Visual Basic)\n\nStarting with Visual Basic 2017, the Visual Basic language offers built-in support for tuples that makes creating tuples and accessing the elements of tuples easier. A tuple is a light-weight data structure that has a specific number and sequence of values. When you instantiate the tuple, you define the number and the data type of each value (or element). For example, a 2-tuple (or pair) has two elements. The first might be a `Boolean` value, while the second is a `String`. Because tuples make it easy to store multiple values in a single object, they are often used as a lightweight way to return multiple values from a method.\n\n> [!IMPORTANT]\n> Tuple support requires the <xref:System.ValueTuple> type. If the .NET Framework 4.7 is not installed, you must add the NuGet package `System.ValueTuple`, which is available on the NuGet Gallery. Without this package, you may get a compilation error similar to, \"Predefined type 'ValueTuple(Of,,,)' is not defined or imported.\"\n\n## Instantiating and using a tuple\n\nYou instantiate a tuple by enclosing its comma-delimited values im parentheses. Each of those values then becomes a field of the tuple. For example, the following code defines a triple (or 3-tuple) with a `Date` as its first value, a `String` as its second, and a `Boolean` as its third.\n\n[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]\n\nBy default, the name of each field in a tuple consists of the string `Item` along with the field's one-based position in the tuple. For this 3-tuple, the `Date` field is `Item1`, the `String` field is `Item2`, and the `Boolean` field is `Item3`. The following example displays the values of fields of the tuple instantiated in the previous line of code\n\n[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]\n\nThe fields of a Visual Basic tuple are read-write; after you've instantiated a tuple, you can modify its values. The following example modifies two of the three fields of the tuple created in the previous example and displays the result.\n\n[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]\n\n## Instantiating and using a named tuple\n\nRather than using default names for a tuple's fields, you can instantiate a *named tuple* by assigning your own names to the tuple's elements. The tuple's fields can then be accessed by their assigned names *or* by their default names. The following example instantiates the same 3-tuple as previously, except that it explicitly names the first field `EventDate`, the second `Name`, and the third `IsHoliday`. It then displays the field values, modifies them, and displays the field values again.\n\n[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]\n\n## Inferred tuple element names\n\nStarting with Visual Basic 15.3, Visual Basic can infer the names of tuple elements; you do not have to assign them explicitly. Inferred tuple names are useful when you initialize a tuple from a set of variables, and you want the tuple element name to be the same as the variable name. \n\nThe following example creates a `stateInfo` tuple that contains three explicitly named elements, `state`, `stateName`, and `capital`. Note that, in naming the elements, the tuple initialization statement simply assigns the named elements the values of the identically named variables.\n\n[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]\n \nBecause elements and variables have the same name, the Visual Basic compiler can infer the names of the fields, as the following example shows.\n\n[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]\n\nTo enable inferred tuple element names, you must define the version of the Visual Basic compiler to use in your Visual Basic project (\\*.vbproj) file: \n\n```xml \n<PropertyGroup> \n  <LangVersion>15.3</LangVersion> \n</PropertyGroup> \n```\n\nThe version number can be any version of the Visual Basic compiler starting with 15.3. Rather than hard-coding a specific compiler version, you can also specify \"Latest\" as the value of `LangVersion` to compile with the most recent version of the Visual Basic compiler installed on your system.\n\nFor more information, see [setting the Visual Basic language version](../../../language-reference/configure-language-version.md).\n\nIn some cases, the Visual Basic compiler cannot infer the tuple element name from the candidate name, and the tuple field can only be referenced using its default name, such as `Item1`, `Item2`, etc. These include:\n\n- The candidate name is the same as the name of a tuple member, such as `Item3`, `Rest`, or `ToString`.\n\n- The candidate name is duplicated in the tuple.\n \nWhen field name inference fails, Visual Basic does not generate a compiler error, nor is an exception thrown at runtime. Instead, tuple fields must be referenced by their predefined names, such as `Item1` and `Item2`. \n  \n## Tuples versus structures\n\nA Visual Basic tuple is a value type that is an instance of one of the a **System.ValueTuple** generic types. For example, the `holiday` tuple defined in the previous example is an instance of the <xref:System.ValueTuple%603> structure. It is designed to be a lightweight container for data. Since the tuple aims to make it easy to create an object with multiple data items, it lacks some of the features that a custom structure might have. These include:\n\n- Custom members. You cannot define your own properties, methods, or events for a tuple.\n\n- Validation. You cannot validate the data assigned to fields.\n\n- Immutability. Visual Basic tuples are mutable. In contrast, a custom structure allows you to control whether an instance is mutable or immutable.\n\nIf custom members, property and field validation, or immutability are important, you should use the Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) statement to define a custom value type.\n\nA Visual Basic tuple does inherit the members of its **ValueTuple** type. In addition to its fields, these include the following methods:\n\n| Member | Description |\n| ---|---|\n| CompareTo | Compares the current tuple to another tuple with the same number of elements. |\n| Equals | Determines whether the current tuple is equal to another tuple or object. |\n| GetHashCode | Calculates the hash code for the current instance. |\n| ToString | Returns the string representation of this tuple, which takes the form `(Item1, Item2...)`, where `Item1` and `Item2` represent the values of the tuple's fields. |\n\nIn addition, the **ValueTuple** types implement <xref:System.Collections.IStructuralComparable> and <xref:System.Collections.IStructuralEquatable> interfaces, which allow you to define customer comparers.\n\n## Assignment and tuples\n\nVisual Basic supports assignment between tuple types that have the same number of fields. The field types can be converted if one of the following is true:\n\n- The source and target field are of the same type.\n\n- A widening (or implicit) conversion of the source type to the target type is defined. \n\n- `Option Strict` is `On`, and a narrowing (or explicit) conversion of the source type to the target type is defined. This conversion can throw an exception if the source value is outside the range of the target type.\n\nOther conversions are not considered for assignments. Let's look at the kinds of assignments that are allowed between tuple types.\n\nConsider these variables used in the following examples:\n\n[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]\n\nThe first two variables, `unnamed` and `anonymous`, do not have semantic names provided for the fields. Their field names are the default `Item1` and `Item2`. The last two variables, `named` and `differentName` have semantic field names. Note that these two tuples have different names for the fields.\n\nAll four of these tuples have the same number of fields (referred to as 'arity'), and the types of those fields are identical. Therefore, all of these assignments work:\n\n[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]\n\nNotice that the names of the tuples are not assigned. The values of the fields are assigned following the order of the fields in the tuple.\n\nFinally, notice that we can assign the `named` tuple to the `conversion` tuple, even though the first field of `named` is an `Integer`, and the first field of `conversion` is a `Long`. This assignment succeeds because converting an `Integer` to a `Long` is a widening conversion.\n\n[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]\n\nTuples with different numbers of fields are not assignable:\n\n```vb\n' Does not compile.\n' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted\n'          to '(Answer As Integer, Message As String)'\nvar differentShape = (1, 2, 3)\nnamed = differentShape\n```\n\n## Tuples as method return values\n\nA method can return only a single value. Frequently, though, you'd like a method call to return multiple values. There are several ways to work around this limitation:\n\n- You can create a custom class or structure whose properties or fields represent values returned by the method. Thus is a heavyweight solution; it requires that you define a custom type whose only purpose is to retrieve values from a method call.\n\n- You can return a single value from the method, and return the remaining values by passing them by reference to the method. This involves the overhead of instantiating a variable and risks inadvertently overwriting the value of the variable that you pass by reference.\n\n- You can use a tuple, which provides a lightweight solution to retrieving multiple return values.\n\nFor example, the **TryParse** methods in .NET return a `Boolean` value that indicates whether the parsing operation succeeded. The result of the parsing operation is returned in a variable passed by reference to the method. Normally, a call to the a parsing method such as <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> looks like the following:\n\n[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]\n\nWe can return a tuple from the parsing operation if we wrap the call to the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method in our own method. In the following example, `NumericLibrary.ParseInteger` calls the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method and returns a named tuple with two elements. \n\n[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]\n\nYou can then call the method with code like the following:\n\n[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]\n\n## Visual Basic tuples and tuples in the .NET Framework\n\nA Visual Basic tuple is an instance of one of the **System.ValueTuple** generic types, which were introduced in the .NET Framework 4.7. The .NET Framework also includes a set of generic **System.Tuple** classes. These classes, however, differ from Visual Basic tuples and the **System.ValueTuple** generic types in a number of ways:\n\n- The elements of the **Tuple** classes are properties named `Item1`, `Item2`, and so on. In Visual Basic tuples and the **ValueTuple** types, tuple elements are fields.\n\n- You cannot assign meaningful names to the elements of a **Tuple** instance or of a **ValueTuple** instance. Visual Basic allows you to assign names that communicate the meaning of the fields.\n\n- The properties of a **Tuple** instance are read-only; the tuples are immutable. In Visual Basic tuples and the **ValueTuple** types, tuple fields are read-write; the tuples are mutable.\n\n- The generic **Tuple** types are reference types. Using these **Tuple** types means allocating objects. On hot paths, this can have a measurable impact on your application's performance. Visual Basic tuples and the **ValueTuple** types are value types.\n\nExtension methods in the <xref:System.TupleExtensions> class make it easy to convert between Visual Basic tuples and .NET **Tuple** objects. The **ToTuple** method converts a Visual Basic tuple to a .NET **Tuple** object, and the **ToValueTuple** method converts a .NET **Tuple** object to a Visual Basic tuple.\n\nThe following example creates a tuple, converts it to a .NET **Tuple** object, and converts it back to a Visual Basic tuple. The example then compares this tuple with the original one to ensure that they are equal.\n\n[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]\n\n## See also\n\n- [Visual Basic Language Reference](index.md)\n","nodes":[{"pos":[4,154],"embed":true,"restype":"x-metadata","content":"title: \"Tuples in Visual Basic\"\nms.date: 04/23/2017\nhelpviewer_keywords: \n  - \"tuples [Visual Basic]\"\nms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f","nodes":[{"content":"Tuples in Visual Basic","nodes":[{"pos":[0,22],"content":"Tuples in Visual Basic","nodes":[{"content":"Tuples in Visual Basic","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[161,182],"content":"Tuples (Visual Basic)","linkify":"Tuples (Visual Basic)","nodes":[{"content":"Tuples (Visual Basic)","pos":[0,21]}]},{"content":"Starting with Visual Basic 2017, the Visual Basic language offers built-in support for tuples that makes creating tuples and accessing the elements of tuples easier.","pos":[184,349]},{"content":"A tuple is a light-weight data structure that has a specific number and sequence of values.","pos":[350,441]},{"content":"When you instantiate the tuple, you define the number and the data type of each value (or element).","pos":[442,541]},{"content":"For example, a 2-tuple (or pair) has two elements.","pos":[542,592]},{"content":"The first might be a <ph id=\"ph1\">`Boolean`</ph> value, while the second is a <ph id=\"ph2\">`String`</ph>.","pos":[593,662],"source":" The first might be a `Boolean` value, while the second is a `String`."},{"content":"Because tuples make it easy to store multiple values in a single object, they are often used as a lightweight way to return multiple values from a method.","pos":[663,817]},{"pos":[821,1162],"content":"[!IMPORTANT]\nTuple support requires the <xref:System.ValueTuple> type. If the .NET Framework 4.7 is not installed, you must add the NuGet package `System.ValueTuple`, which is available on the NuGet Gallery. Without this package, you may get a compilation error similar to, \"Predefined type 'ValueTuple(Of,,,)' is not defined or imported.\"","leadings":["","> "],"nodes":[{"content":"Tuple support requires the <xref:System.ValueTuple> type. If the .NET Framework 4.7 is not installed, you must add the NuGet package `System.ValueTuple`, which is available on the NuGet Gallery. Without this package, you may get a compilation error similar to, \"Predefined type 'ValueTuple(Of,,,)' is not defined or imported.\"","pos":[13,339],"nodes":[{"content":"Tuple support requires the <ph id=\"ph1\">&lt;xref:System.ValueTuple&gt;</ph> type.","pos":[0,57],"source":"Tuple support requires the <xref:System.ValueTuple> type."},{"content":"If the .NET Framework 4.7 is not installed, you must add the NuGet package <ph id=\"ph1\">`System.ValueTuple`</ph>, which is available on the NuGet Gallery.","pos":[58,194],"source":" If the .NET Framework 4.7 is not installed, you must add the NuGet package `System.ValueTuple`, which is available on the NuGet Gallery."},{"content":"Without this package, you may get a compilation error similar to, \"Predefined type 'ValueTuple(Of,,,)' is not defined or imported.\"","pos":[195,326]}]}]},{"pos":[1167,1198],"content":"Instantiating and using a tuple","linkify":"Instantiating and using a tuple","nodes":[{"content":"Instantiating and using a tuple","pos":[0,31]}]},{"content":"You instantiate a tuple by enclosing its comma-delimited values im parentheses.","pos":[1200,1279]},{"content":"Each of those values then becomes a field of the tuple.","pos":[1280,1335]},{"content":"For example, the following code defines a triple (or 3-tuple) with a <ph id=\"ph1\">`Date`</ph> as its first value, a <ph id=\"ph2\">`String`</ph> as its second, and a <ph id=\"ph3\">`Boolean`</ph> as its third.","pos":[1336,1487],"source":" For example, the following code defines a triple (or 3-tuple) with a `Date` as its first value, a `String` as its second, and a `Boolean` as its third."},{"content":"By default, the name of each field in a tuple consists of the string <ph id=\"ph1\">`Item`</ph> along with the field's one-based position in the tuple.","pos":[1618,1749],"source":"By default, the name of each field in a tuple consists of the string `Item` along with the field's one-based position in the tuple."},{"content":"For this 3-tuple, the <ph id=\"ph1\">`Date`</ph> field is <ph id=\"ph2\">`Item1`</ph>, the <ph id=\"ph3\">`String`</ph> field is <ph id=\"ph4\">`Item2`</ph>, and the <ph id=\"ph5\">`Boolean`</ph> field is <ph id=\"ph6\">`Item3`</ph>.","pos":[1750,1863],"source":" For this 3-tuple, the `Date` field is `Item1`, the `String` field is `Item2`, and the `Boolean` field is `Item3`."},{"content":"The following example displays the values of fields of the tuple instantiated in the previous line of code","pos":[1864,1970]},{"content":"The fields of a Visual Basic tuple are read-write; after you've instantiated a tuple, you can modify its values.","pos":[2101,2213]},{"content":"The following example modifies two of the three fields of the tuple created in the previous example and displays the result.","pos":[2214,2338]},{"pos":[2472,2509],"content":"Instantiating and using a named tuple","linkify":"Instantiating and using a named tuple","nodes":[{"content":"Instantiating and using a named tuple","pos":[0,37]}]},{"content":"Rather than using default names for a tuple's fields, you can instantiate a <bpt id=\"p1\">*</bpt>named tuple<ept id=\"p1\">*</ept> by assigning your own names to the tuple's elements.","pos":[2511,2653],"source":"Rather than using default names for a tuple's fields, you can instantiate a *named tuple* by assigning your own names to the tuple's elements."},{"content":"The tuple's fields can then be accessed by their assigned names <bpt id=\"p1\">*</bpt>or<ept id=\"p1\">*</ept> by their default names.","pos":[2654,2746],"source":" The tuple's fields can then be accessed by their assigned names *or* by their default names."},{"content":"The following example instantiates the same 3-tuple as previously, except that it explicitly names the first field <ph id=\"ph1\">`EventDate`</ph>, the second <ph id=\"ph2\">`Name`</ph>, and the third <ph id=\"ph3\">`IsHoliday`</ph>.","pos":[2747,2920],"source":" The following example instantiates the same 3-tuple as previously, except that it explicitly names the first field `EventDate`, the second `Name`, and the third `IsHoliday`."},{"content":"It then displays the field values, modifies them, and displays the field values again.","pos":[2921,3007]},{"pos":[3141,3169],"content":"Inferred tuple element names","linkify":"Inferred tuple element names","nodes":[{"content":"Inferred tuple element names","pos":[0,28]}]},{"content":"Starting with Visual Basic 15.3, Visual Basic can infer the names of tuple elements; you do not have to assign them explicitly.","pos":[3171,3298]},{"content":"Inferred tuple names are useful when you initialize a tuple from a set of variables, and you want the tuple element name to be the same as the variable name.","pos":[3299,3456]},{"content":"The following example creates a <ph id=\"ph1\">`stateInfo`</ph> tuple that contains three explicitly named elements, <ph id=\"ph2\">`state`</ph>, <ph id=\"ph3\">`stateName`</ph>, and <ph id=\"ph4\">`capital`</ph>.","pos":[3459,3592],"source":"The following example creates a `stateInfo` tuple that contains three explicitly named elements, `state`, `stateName`, and `capital`."},{"content":"Note that, in naming the elements, the tuple initialization statement simply assigns the named elements the values of the identically named variables.","pos":[3593,3743]},{"content":"Because elements and variables have the same name, the Visual Basic compiler can infer the names of the fields, as the following example shows.","pos":[3893,4036]},{"content":"To enable inferred tuple element names, you must define the version of the Visual Basic compiler to use in your Visual Basic project (<ph id=\"ph1\">\\*</ph>.vbproj) file:","pos":[4185,4335],"source":"To enable inferred tuple element names, you must define the version of the Visual Basic compiler to use in your Visual Basic project (\\*.vbproj) file:"},{"content":"The version number can be any version of the Visual Basic compiler starting with 15.3.","pos":[4421,4507]},{"content":"Rather than hard-coding a specific compiler version, you can also specify \"Latest\" as the value of <ph id=\"ph1\">`LangVersion`</ph> to compile with the most recent version of the Visual Basic compiler installed on your system.","pos":[4508,4715],"source":" Rather than hard-coding a specific compiler version, you can also specify \"Latest\" as the value of `LangVersion` to compile with the most recent version of the Visual Basic compiler installed on your system."},{"pos":[4717,4846],"content":"For more information, see <bpt id=\"p1\">[</bpt>setting the Visual Basic language version<ept id=\"p1\">](../../../language-reference/configure-language-version.md)</ept>.","source":"For more information, see [setting the Visual Basic language version](../../../language-reference/configure-language-version.md)."},{"pos":[4848,5062],"content":"In some cases, the Visual Basic compiler cannot infer the tuple element name from the candidate name, and the tuple field can only be referenced using its default name, such as <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph>, etc. These include:","source":"In some cases, the Visual Basic compiler cannot infer the tuple element name from the candidate name, and the tuple field can only be referenced using its default name, such as `Item1`, `Item2`, etc. These include:"},{"pos":[5066,5167],"content":"The candidate name is the same as the name of a tuple member, such as <ph id=\"ph1\">`Item3`</ph>, <ph id=\"ph2\">`Rest`</ph>, or <ph id=\"ph3\">`ToString`</ph>.","source":"The candidate name is the same as the name of a tuple member, such as `Item3`, `Rest`, or `ToString`."},{"content":"The candidate name is duplicated in the tuple.","pos":[5171,5217]},{"content":"When field name inference fails, Visual Basic does not generate a compiler error, nor is an exception thrown at runtime.","pos":[5220,5340]},{"content":"Instead, tuple fields must be referenced by their predefined names, such as <ph id=\"ph1\">`Item1`</ph> and <ph id=\"ph2\">`Item2`</ph>.","pos":[5341,5437],"source":" Instead, tuple fields must be referenced by their predefined names, such as `Item1` and `Item2`."},{"pos":[5445,5469],"content":"Tuples versus structures","linkify":"Tuples versus structures","nodes":[{"content":"Tuples versus structures","pos":[0,24]}]},{"content":"A Visual Basic tuple is a value type that is an instance of one of the a <bpt id=\"p1\">**</bpt>System.ValueTuple<ept id=\"p1\">**</ept> generic types.","pos":[5471,5580],"source":"A Visual Basic tuple is a value type that is an instance of one of the a **System.ValueTuple** generic types."},{"content":"For example, the <ph id=\"ph1\">`holiday`</ph> tuple defined in the previous example is an instance of the <ph id=\"ph2\">&lt;xref:System.ValueTuple%603&gt;</ph> structure.","pos":[5581,5707],"source":" For example, the `holiday` tuple defined in the previous example is an instance of the <xref:System.ValueTuple%603> structure."},{"content":"It is designed to be a lightweight container for data.","pos":[5708,5762]},{"content":"Since the tuple aims to make it easy to create an object with multiple data items, it lacks some of the features that a custom structure might have.","pos":[5763,5911]},{"content":"These include:","pos":[5912,5926]},{"content":"Custom members.","pos":[5930,5945]},{"content":"You cannot define your own properties, methods, or events for a tuple.","pos":[5946,6016]},{"content":"Validation.","pos":[6020,6031]},{"content":"You cannot validate the data assigned to fields.","pos":[6032,6080]},{"content":"Immutability.","pos":[6084,6097]},{"content":"Visual Basic tuples are mutable.","pos":[6098,6130]},{"content":"In contrast, a custom structure allows you to control whether an instance is mutable or immutable.","pos":[6131,6229]},{"pos":[6231,6459],"content":"If custom members, property and field validation, or immutability are important, you should use the Visual Basic <bpt id=\"p1\">[</bpt>Structure<ept id=\"p1\">](../../../language-reference/statements/structure-statement.md)</ept> statement to define a custom value type.","source":"If custom members, property and field validation, or immutability are important, you should use the Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) statement to define a custom value type."},{"content":"A Visual Basic tuple does inherit the members of its <bpt id=\"p1\">**</bpt>ValueTuple<ept id=\"p1\">**</ept> type.","pos":[6461,6534],"source":"A Visual Basic tuple does inherit the members of its **ValueTuple** type."},{"content":"In addition to its fields, these include the following methods:","pos":[6535,6598]},{"content":"Member","pos":[6602,6608]},{"content":"Description","pos":[6611,6622]},{"content":"CompareTo","pos":[6638,6647]},{"content":"Compares the current tuple to another tuple with the same number of elements.","pos":[6650,6727]},{"content":"Equals","pos":[6732,6738]},{"content":"Determines whether the current tuple is equal to another tuple or object.","pos":[6741,6814]},{"content":"GetHashCode","pos":[6819,6830]},{"content":"Calculates the hash code for the current instance.","pos":[6833,6883]},{"content":"ToString","pos":[6888,6896]},{"pos":[6899,7059],"content":"Returns the string representation of this tuple, which takes the form <ph id=\"ph1\">`(Item1, Item2...)`</ph>, where <ph id=\"ph2\">`Item1`</ph> and <ph id=\"ph3\">`Item2`</ph> represent the values of the tuple's fields.","source":"Returns the string representation of this tuple, which takes the form `(Item1, Item2...)`, where `Item1` and `Item2` represent the values of the tuple's fields."},{"pos":[7063,7267],"content":"In addition, the <bpt id=\"p1\">**</bpt>ValueTuple<ept id=\"p1\">**</ept> types implement <ph id=\"ph1\">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interfaces, which allow you to define customer comparers.","source":"In addition, the **ValueTuple** types implement <xref:System.Collections.IStructuralComparable> and <xref:System.Collections.IStructuralEquatable> interfaces, which allow you to define customer comparers."},{"pos":[7272,7293],"content":"Assignment and tuples","linkify":"Assignment and tuples","nodes":[{"content":"Assignment and tuples","pos":[0,21]}]},{"content":"Visual Basic supports assignment between tuple types that have the same number of fields.","pos":[7295,7384]},{"content":"The field types can be converted if one of the following is true:","pos":[7385,7450]},{"content":"The source and target field are of the same type.","pos":[7454,7503]},{"content":"A widening (or implicit) conversion of the source type to the target type is defined.","pos":[7507,7592]},{"content":"<ph id=\"ph1\">`Option Strict`</ph> is <ph id=\"ph2\">`On`</ph>, and a narrowing (or explicit) conversion of the source type to the target type is defined.","pos":[7597,7712],"source":"`Option Strict` is `On`, and a narrowing (or explicit) conversion of the source type to the target type is defined."},{"content":"This conversion can throw an exception if the source value is outside the range of the target type.","pos":[7713,7812]},{"content":"Other conversions are not considered for assignments.","pos":[7814,7867]},{"content":"Let's look at the kinds of assignments that are allowed between tuple types.","pos":[7868,7944]},{"content":"Consider these variables used in the following examples:","pos":[7946,8002]},{"content":"The first two variables, <ph id=\"ph1\">`unnamed`</ph> and <ph id=\"ph2\">`anonymous`</ph>, do not have semantic names provided for the fields.","pos":[8128,8231],"source":"The first two variables, `unnamed` and `anonymous`, do not have semantic names provided for the fields."},{"content":"Their field names are the default <ph id=\"ph1\">`Item1`</ph> and <ph id=\"ph2\">`Item2`</ph>.","pos":[8232,8286],"source":" Their field names are the default `Item1` and `Item2`."},{"content":"The last two variables, <ph id=\"ph1\">`named`</ph> and <ph id=\"ph2\">`differentName`</ph> have semantic field names.","pos":[8287,8365],"source":" The last two variables, `named` and `differentName` have semantic field names."},{"content":"Note that these two tuples have different names for the fields.","pos":[8366,8429]},{"content":"All four of these tuples have the same number of fields (referred to as 'arity'), and the types of those fields are identical.","pos":[8431,8557]},{"content":"Therefore, all of these assignments work:","pos":[8558,8599]},{"content":"Notice that the names of the tuples are not assigned.","pos":[8725,8778]},{"content":"The values of the fields are assigned following the order of the fields in the tuple.","pos":[8779,8864]},{"content":"Finally, notice that we can assign the <ph id=\"ph1\">`named`</ph> tuple to the <ph id=\"ph2\">`conversion`</ph> tuple, even though the first field of <ph id=\"ph3\">`named`</ph> is an <ph id=\"ph4\">`Integer`</ph>, and the first field of <ph id=\"ph5\">`conversion`</ph> is a <ph id=\"ph6\">`Long`</ph>.","pos":[8866,9050],"source":"Finally, notice that we can assign the `named` tuple to the `conversion` tuple, even though the first field of `named` is an `Integer`, and the first field of `conversion` is a `Long`."},{"content":"This assignment succeeds because converting an <ph id=\"ph1\">`Integer`</ph> to a <ph id=\"ph2\">`Long`</ph> is a widening conversion.","pos":[9051,9145],"source":" This assignment succeeds because converting an `Integer` to a `Long` is a widening conversion."},{"content":"Tuples with different numbers of fields are not assignable:","pos":[9271,9330]},{"pos":[9550,9580],"content":"Tuples as method return values","linkify":"Tuples as method return values","nodes":[{"content":"Tuples as method return values","pos":[0,30]}]},{"content":"A method can return only a single value.","pos":[9582,9622]},{"content":"Frequently, though, you'd like a method call to return multiple values.","pos":[9623,9694]},{"content":"There are several ways to work around this limitation:","pos":[9695,9749]},{"content":"You can create a custom class or structure whose properties or fields represent values returned by the method.","pos":[9753,9863]},{"content":"Thus is a heavyweight solution; it requires that you define a custom type whose only purpose is to retrieve values from a method call.","pos":[9864,9998]},{"content":"You can return a single value from the method, and return the remaining values by passing them by reference to the method.","pos":[10002,10124]},{"content":"This involves the overhead of instantiating a variable and risks inadvertently overwriting the value of the variable that you pass by reference.","pos":[10125,10269]},{"content":"You can use a tuple, which provides a lightweight solution to retrieving multiple return values.","pos":[10273,10369]},{"content":"For example, the <bpt id=\"p1\">**</bpt>TryParse<ept id=\"p1\">**</ept> methods in .NET return a <ph id=\"ph1\">`Boolean`</ph> value that indicates whether the parsing operation succeeded.","pos":[10371,10497],"source":"For example, the **TryParse** methods in .NET return a `Boolean` value that indicates whether the parsing operation succeeded."},{"content":"The result of the parsing operation is returned in a variable passed by reference to the method.","pos":[10498,10594]},{"content":"Normally, a call to the a parsing method such as <ph id=\"ph1\">&lt;xref:System.Int32.TryParse%2A?displayProperty=nameWithType&gt;</ph> looks like the following:","pos":[10595,10730],"source":" Normally, a call to the a parsing method such as <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> looks like the following:"},{"content":"We can return a tuple from the parsing operation if we wrap the call to the <ph id=\"ph1\">&lt;xref:System.Int32.TryParse%2A?displayProperty=nameWithType&gt;</ph> method in our own method.","pos":[10863,11025],"source":"We can return a tuple from the parsing operation if we wrap the call to the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method in our own method."},{"content":"In the following example, <ph id=\"ph1\">`NumericLibrary.ParseInteger`</ph> calls the <ph id=\"ph2\">&lt;xref:System.Int32.TryParse%2A?displayProperty=nameWithType&gt;</ph> method and returns a named tuple with two elements.","pos":[11026,11204],"source":" In the following example, `NumericLibrary.ParseInteger` calls the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method and returns a named tuple with two elements."},{"content":"You can then call the method with code like the following:","pos":[11338,11396]},{"pos":[11532,11584],"content":"Visual Basic tuples and tuples in the .NET Framework","linkify":"Visual Basic tuples and tuples in the .NET Framework","nodes":[{"content":"Visual Basic tuples and tuples in the .NET Framework","pos":[0,52]}]},{"content":"A Visual Basic tuple is an instance of one of the <bpt id=\"p1\">**</bpt>System.ValueTuple<ept id=\"p1\">**</ept> generic types, which were introduced in the .NET Framework 4.7.","pos":[11586,11721],"source":"A Visual Basic tuple is an instance of one of the **System.ValueTuple** generic types, which were introduced in the .NET Framework 4.7."},{"content":"The .NET Framework also includes a set of generic <bpt id=\"p1\">**</bpt>System.Tuple<ept id=\"p1\">**</ept> classes.","pos":[11722,11797],"source":" The .NET Framework also includes a set of generic **System.Tuple** classes."},{"content":"These classes, however, differ from Visual Basic tuples and the <bpt id=\"p1\">**</bpt>System.ValueTuple<ept id=\"p1\">**</ept> generic types in a number of ways:","pos":[11798,11918],"source":" These classes, however, differ from Visual Basic tuples and the **System.ValueTuple** generic types in a number of ways:"},{"content":"The elements of the <bpt id=\"p1\">**</bpt>Tuple<ept id=\"p1\">**</ept> classes are properties named <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph>, and so on.","pos":[11922,12009],"source":"The elements of the **Tuple** classes are properties named `Item1`, `Item2`, and so on."},{"content":"In Visual Basic tuples and the <bpt id=\"p1\">**</bpt>ValueTuple<ept id=\"p1\">**</ept> types, tuple elements are fields.","pos":[12010,12089],"source":" In Visual Basic tuples and the **ValueTuple** types, tuple elements are fields."},{"content":"You cannot assign meaningful names to the elements of a <bpt id=\"p1\">**</bpt>Tuple<ept id=\"p1\">**</ept> instance or of a <bpt id=\"p2\">**</bpt>ValueTuple<ept id=\"p2\">**</ept> instance.","pos":[12093,12200],"source":"You cannot assign meaningful names to the elements of a **Tuple** instance or of a **ValueTuple** instance."},{"content":"Visual Basic allows you to assign names that communicate the meaning of the fields.","pos":[12201,12284]},{"content":"The properties of a <bpt id=\"p1\">**</bpt>Tuple<ept id=\"p1\">**</ept> instance are read-only; the tuples are immutable.","pos":[12288,12367],"source":"The properties of a **Tuple** instance are read-only; the tuples are immutable."},{"content":"In Visual Basic tuples and the <bpt id=\"p1\">**</bpt>ValueTuple<ept id=\"p1\">**</ept> types, tuple fields are read-write; the tuples are mutable.","pos":[12368,12473],"source":" In Visual Basic tuples and the **ValueTuple** types, tuple fields are read-write; the tuples are mutable."},{"content":"The generic <bpt id=\"p1\">**</bpt>Tuple<ept id=\"p1\">**</ept> types are reference types.","pos":[12477,12525],"source":"The generic **Tuple** types are reference types."},{"content":"Using these <bpt id=\"p1\">**</bpt>Tuple<ept id=\"p1\">**</ept> types means allocating objects.","pos":[12526,12579],"source":" Using these **Tuple** types means allocating objects."},{"content":"On hot paths, this can have a measurable impact on your application's performance.","pos":[12580,12662]},{"content":"Visual Basic tuples and the <bpt id=\"p1\">**</bpt>ValueTuple<ept id=\"p1\">**</ept> types are value types.","pos":[12663,12728],"source":" Visual Basic tuples and the **ValueTuple** types are value types."},{"content":"Extension methods in the <ph id=\"ph1\">&lt;xref:System.TupleExtensions&gt;</ph> class make it easy to convert between Visual Basic tuples and .NET <bpt id=\"p1\">**</bpt>Tuple<ept id=\"p1\">**</ept> objects.","pos":[12730,12870],"source":"Extension methods in the <xref:System.TupleExtensions> class make it easy to convert between Visual Basic tuples and .NET **Tuple** objects."},{"content":"The <bpt id=\"p1\">**</bpt>ToTuple<ept id=\"p1\">**</ept> method converts a Visual Basic tuple to a .NET <bpt id=\"p2\">**</bpt>Tuple<ept id=\"p2\">**</ept> object, and the <bpt id=\"p3\">**</bpt>ToValueTuple<ept id=\"p3\">**</ept> method converts a .NET <bpt id=\"p4\">**</bpt>Tuple<ept id=\"p4\">**</ept> object to a Visual Basic tuple.","pos":[12871,13041],"source":" The **ToTuple** method converts a Visual Basic tuple to a .NET **Tuple** object, and the **ToValueTuple** method converts a .NET **Tuple** object to a Visual Basic tuple."},{"content":"The following example creates a tuple, converts it to a .NET <bpt id=\"p1\">**</bpt>Tuple<ept id=\"p1\">**</ept> object, and converts it back to a Visual Basic tuple.","pos":[13043,13167],"source":"The following example creates a tuple, converts it to a .NET **Tuple** object, and converts it back to a Visual Basic tuple."},{"content":"The example then compares this tuple with the original one to ensure that they are equal.","pos":[13168,13257]},{"pos":[13387,13395],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[13399,13442],"content":"<bpt id=\"p1\">[</bpt>Visual Basic Language Reference<ept id=\"p1\">](index.md)</ept>","source":"[Visual Basic Language Reference](index.md)"}]}