{"content":"---\ntitle: \"Security and Race Conditions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"security [.NET Framework], race conditions\"\n  - \"race conditions\"\n  - \"secure coding, race conditions\"\n  - \"code security, race conditions\"\nms.assetid: ea3edb80-b2e8-4e85-bfed-311b20cb59b6\ncaps.latest.revision: 9\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# Security and Race Conditions\nAnother area of concern is the potential for security holes exploited by race conditions. There are several ways in which this might happen. The subtopics that follow outline some of the major pitfalls that the developer must avoid.  \n  \n## Race Conditions in the Dispose Method  \n If a class's **Dispose** method (for more information, see [Garbage Collection](../../../docs/standard/garbage-collection/index.md)) is not synchronized, it is possible that cleanup code inside **Dispose** can be run more than once, as shown in the following example.  \n  \n```vb  \nSub Dispose()  \n    If Not (myObj Is Nothing) Then  \n       Cleanup(myObj)  \n       myObj = Nothing  \n    End If  \nEnd Sub  \n  \n```  \n  \n```csharp  \nvoid Dispose()   \n{  \n    if( myObj != null )   \n    {  \n        Cleanup(myObj);  \n        myObj = null;  \n    }  \n}  \n```  \n  \n Because this **Dispose** implementation is not synchronized, it is possible for `Cleanup` to be called by first one thread and then a second thread before `_myObj` is set to **null**. Whether this is a security concern depends on what happens when the `Cleanup` code runs. A major issue with unsynchronized **Dispose** implementations involves the use of resource handles such as files. Improper disposal can cause the wrong handle to be used, which often leads to security vulnerabilities.  \n  \n## Race Conditions in Constructors  \n In some applications, it might be possible for other threads to access class members before their class constructors have completely run. You should review all class constructors to make sure that there are no security issues if this should happen, or synchronize threads if necessary.  \n  \n## Race Conditions with Cached Objects  \n Code that caches security information or uses the code access security [Assert](../../../docs/framework/misc/using-the-assert-method.md) operation might also be vulnerable to race conditions if other parts of the class are not appropriately synchronized, as shown in the following example.  \n  \n```vb  \nSub SomeSecureFunction()  \n    If SomeDemandPasses() Then  \n        fCallersOk = True  \n        DoOtherWork()  \n        fCallersOk = False()  \n    End If  \nEnd Sub  \n  \nSub DoOtherWork()  \n    If fCallersOK Then  \n        DoSomethingTrusted()  \n    Else  \n        DemandSomething()  \n        DoSomethingTrusted()  \n    End If  \nEnd Sub  \n  \n```  \n  \n```csharp  \nvoid SomeSecureFunction()   \n{  \n    if(SomeDemandPasses())   \n    {  \n        fCallersOk = true;  \n        DoOtherWork();  \n        fCallersOk = false();  \n    }  \n}  \nvoid DoOtherWork()   \n{  \n    if( fCallersOK )   \n    {  \n        DoSomethingTrusted();  \n    }  \n    else   \n    {  \n        DemandSomething();  \n        DoSomethingTrusted();  \n    }  \n}  \n```  \n  \n If there are other paths to `DoOtherWork` that can be called from another thread with the same object, an untrusted caller can slip past a demand.  \n  \n If your code caches security information, make sure that you review it for this vulnerability.  \n  \n## Race Conditions in Finalizers  \n Race conditions can also occur in an object that references a static or unmanaged resource that it then frees in its finalizer. If multiple objects share a resource that is manipulated in a class's finalizer, the objects must synchronize all access to that resource.  \n  \n## See Also  \n [Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)","nodes":[{"pos":[12,57],"content":"Security and Race Conditions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Security and Race Conditions | Microsoft Docs","pos":[0,45]}]},{"pos":[569,597],"content":"Security and Race Conditions","linkify":"Security and Race Conditions","nodes":[{"content":"Security and Race Conditions","pos":[0,28]}]},{"content":"Another area of concern is the potential for security holes exploited by race conditions.","pos":[598,687]},{"content":"There are several ways in which this might happen.","pos":[688,738]},{"content":"The subtopics that follow outline some of the major pitfalls that the developer must avoid.","pos":[739,830]},{"pos":[839,876],"content":"Race Conditions in the Dispose Method","linkify":"Race Conditions in the Dispose Method","nodes":[{"content":"Race Conditions in the Dispose Method","pos":[0,37]}]},{"pos":[880,1147],"content":"If a class's <bpt id=\"p1\">**</bpt>Dispose<ept id=\"p1\">**</ept> method (for more information, see <bpt id=\"p2\">[</bpt>Garbage Collection<ept id=\"p2\">](../../../docs/standard/garbage-collection/index.md)</ept>) is not synchronized, it is possible that cleanup code inside <bpt id=\"p3\">**</bpt>Dispose<ept id=\"p3\">**</ept> can be run more than once, as shown in the following example.","source":"If a class's **Dispose** method (for more information, see [Garbage Collection](../../../docs/standard/garbage-collection/index.md)) is not synchronized, it is possible that cleanup code inside **Dispose** can be run more than once, as shown in the following example."},{"content":"Because this <bpt id=\"p1\">**</bpt>Dispose<ept id=\"p1\">**</ept> implementation is not synchronized, it is possible for <ph id=\"ph1\">`Cleanup`</ph> to be called by first one thread and then a second thread before <ph id=\"ph2\">`_myObj`</ph> is set to <bpt id=\"p2\">**</bpt>null<ept id=\"p2\">**</ept>.","pos":[1439,1622],"source":"Because this **Dispose** implementation is not synchronized, it is possible for `Cleanup` to be called by first one thread and then a second thread before `_myObj` is set to **null**."},{"content":"Whether this is a security concern depends on what happens when the <ph id=\"ph1\">`Cleanup`</ph> code runs.","pos":[1623,1711],"source":" Whether this is a security concern depends on what happens when the `Cleanup` code runs."},{"content":"A major issue with unsynchronized <bpt id=\"p1\">**</bpt>Dispose<ept id=\"p1\">**</ept> implementations involves the use of resource handles such as files.","pos":[1712,1825],"source":" A major issue with unsynchronized **Dispose** implementations involves the use of resource handles such as files."},{"content":"Improper disposal can cause the wrong handle to be used, which often leads to security vulnerabilities.","pos":[1826,1929]},{"pos":[1938,1969],"content":"Race Conditions in Constructors","linkify":"Race Conditions in Constructors","nodes":[{"content":"Race Conditions in Constructors","pos":[0,31]}]},{"content":"In some applications, it might be possible for other threads to access class members before their class constructors have completely run.","pos":[1973,2110]},{"content":"You should review all class constructors to make sure that there are no security issues if this should happen, or synchronize threads if necessary.","pos":[2111,2258]},{"pos":[2267,2302],"content":"Race Conditions with Cached Objects","linkify":"Race Conditions with Cached Objects","nodes":[{"content":"Race Conditions with Cached Objects","pos":[0,35]}]},{"pos":[2306,2595],"content":"Code that caches security information or uses the code access security <bpt id=\"p1\">[</bpt>Assert<ept id=\"p1\">](../../../docs/framework/misc/using-the-assert-method.md)</ept> operation might also be vulnerable to race conditions if other parts of the class are not appropriately synchronized, as shown in the following example.","source":"Code that caches security information or uses the code access security [Assert](../../../docs/framework/misc/using-the-assert-method.md) operation might also be vulnerable to race conditions if other parts of the class are not appropriately synchronized, as shown in the following example."},{"pos":[3341,3487],"content":"If there are other paths to <ph id=\"ph1\">`DoOtherWork`</ph> that can be called from another thread with the same object, an untrusted caller can slip past a demand.","source":"If there are other paths to `DoOtherWork` that can be called from another thread with the same object, an untrusted caller can slip past a demand."},{"content":"If your code caches security information, make sure that you review it for this vulnerability.","pos":[3494,3588]},{"pos":[3597,3626],"content":"Race Conditions in Finalizers","linkify":"Race Conditions in Finalizers","nodes":[{"content":"Race Conditions in Finalizers","pos":[0,29]}]},{"content":"Race conditions can also occur in an object that references a static or unmanaged resource that it then frees in its finalizer.","pos":[3630,3757]},{"content":"If multiple objects share a resource that is manipulated in a class's finalizer, the objects must synchronize all access to that resource.","pos":[3758,3896]},{"pos":[3905,3913],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[3917,4004],"content":"<bpt id=\"p1\">[</bpt>Secure Coding Guidelines<ept id=\"p1\">](../../../docs/standard/security/secure-coding-guidelines.md)</ept>","source":"[Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)"}]}