{"content":"---\ntitle: \"Authorization and Permissions in SQL Server\"\nms.date: \"03/30/2017\"\nms.assetid: d340405c-91f4-4837-a3cc-a238ee89888a\n---\n# Authorization and Permissions in SQL Server\nWhen you create database objects, you must explicitly grant permissions to make them accessible to users. Every securable object has permissions that can be granted to a principal using permission statements.  \n  \n## The Principle of Least Privilege  \n Developing an application using a least-privileged user account (LUA) approach is an important part of a defensive, in-depth strategy for countering security threats. The LUA approach ensures that users follow the principle of least privilege and always log on with limited user accounts. Administrative tasks are broken out using fixed server roles, and the use of the `sysadmin` fixed server role is severely restricted.  \n  \n Always follow the principle of least privilege when granting permissions to database users. Grant the minimum permissions necessary to a user or role to accomplish a given task.  \n  \n> [!IMPORTANT]\n>  Developing and testing an application using the LUA approach adds a degree of difficulty to the development process. It is easier to create objects and write code while logged on as a system administrator or database owner than it is using a LUA account. However, developing applications using a highly privileged account can obfuscate the impact of reduced functionality when least privileged users attempt to run an application that requires elevated permissions in order to function correctly. Granting excessive permissions to users in order to reacquire lost functionality can leave your application vulnerable to attack. Designing, developing and testing your application logged on with a LUA account enforces a disciplined approach to security planning that eliminates unpleasant surprises and the temptation to grant elevated privileges as a quick fix. You can use a SQL Server login for testing even if your application is intended to deploy using Windows authentication.  \n  \n## Role-Based Permissions  \n Granting permissions to roles rather than to users simplifies security administration. Permission sets that are assigned to roles are inherited by all members of the role. It is easier to add or remove users from a role than it is to recreate separate permission sets for individual users. Roles can be nested; however, too many levels of nesting can degrade performance. You can also add users to fixed database roles to simplify assigning permissions.  \n  \n You can grant permissions at the schema level. Users automatically inherit permissions on all new objects created in the schema; you do not need to grant permissions as new objects are created.  \n  \n## Permissions Through Procedural Code  \n Encapsulating data access through modules such as stored procedures and user-defined functions provides an additional layer of protection around your application. You can prevent users from directly interacting with database objects by granting permissions only to stored procedures or functions while denying permissions to underlying objects such as tables. SQL Server achieves this by ownership chaining.  \n  \n## Permission Statements  \n The three Transact-SQL permission statements are described in the following table.  \n  \n|Permission Statement|Description|  \n|--------------------------|-----------------|  \n|GRANT|Grants a permission.|  \n|REVOKE|Revokes a permission. This is the default state of a new object. A permission revoked from a user or role can still be inherited from other groups or roles to which the principal is assigned.|  \n|DENY|DENY revokes a permission so that it cannot be inherited. DENY takes precedence over all permissions, except DENY does not apply to object owners or members of `sysadmin`. If you DENY permissions on an object to the `public` role it is denied to all users and roles except for object owners and `sysadmin` members.|  \n  \n-   The GRANT statement can assign permissions to a group or role that can be inherited by database users. However, the DENY statement takes precedence over all other permission statements. Therefore, a user who has been denied a permission cannot inherit it from another role.  \n  \n> [!NOTE]\n>  Members of the `sysadmin` fixed server role and object owners cannot be denied permissions.  \n  \n## Ownership Chains  \n SQL Server ensures that only principals that have been granted permission can access objects. When multiple database objects access each other, the sequence is known as a chain. When SQL Server is traversing the links in the chain, it evaluates permissions differently than it would if it were accessing each item separately. When an object is accessed through a chain, SQL Server first compares the object's owner to the owner of the calling object (the previous link in the chain). If both objects have the same owner, permissions on the referenced object are not checked. Whenever an object accesses another object that has a different owner, the ownership chain is broken and SQL Server must check the caller's security context.  \n  \n## Procedural Code and Ownership Chaining  \n Suppose that a user is granted execute permissions on a stored procedure that selects data from a table. If the stored procedure and the table have the same owner, the user doesn't need to be granted any permissions on the table and can even be denied permissions. However, if the stored procedure and the table have different owners, SQL Server must check the user's permissions on the table before allowing access to the data.  \n  \n> [!NOTE]\n>  Ownership chaining does not apply in the case of dynamic SQL statements. To call a procedure that executes an SQL statement, the caller must be granted permissions on the underlying tables, leaving your application vulnerable to SQL Injection attack. SQL Server provides new mechanisms, such as impersonation and signing modules with certificates, that do not require granting permissions on the underlying tables. These can also be used with CLR stored procedures.  \n  \n## External Resources  \n For more information, see the following resources.  \n  \n|Resource|Description|  \n|--------------|-----------------|  \n|[Permissions](/sql/relational-databases/security/permissions-database-engine)|Contains topics describing permissions hierarchy, catalog views, and permissions of fixed server and database roles.|\n  \n## See also\n\n- [Securing ADO.NET Applications](../../../../../docs/framework/data/adonet/securing-ado-net-applications.md)\n- [Application Security Scenarios in SQL Server](../../../../../docs/framework/data/adonet/sql/application-security-scenarios-in-sql-server.md)\n- [Authentication in SQL Server](../../../../../docs/framework/data/adonet/sql/authentication-in-sql-server.md)\n- [Server and Database Roles in SQL Server](../../../../../docs/framework/data/adonet/sql/server-and-database-roles-in-sql-server.md)\n- [Ownership and User-Schema Separation in SQL Server](../../../../../docs/framework/data/adonet/sql/ownership-and-user-schema-separation-in-sql-server.md)\n- [ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)\n","nodes":[{"pos":[4,127],"embed":true,"restype":"x-metadata","content":"title: \"Authorization and Permissions in SQL Server\"\nms.date: \"03/30/2017\"\nms.assetid: d340405c-91f4-4837-a3cc-a238ee89888a","nodes":[{"content":"Authorization and Permissions in SQL Server","nodes":[{"pos":[0,43],"content":"Authorization and Permissions in SQL Server","nodes":[{"content":"Authorization and Permissions in SQL Server","pos":[0,43]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[134,177],"content":"Authorization and Permissions in SQL Server","linkify":"Authorization and Permissions in SQL Server","nodes":[{"content":"Authorization and Permissions in SQL Server","pos":[0,43]}]},{"content":"When you create database objects, you must explicitly grant permissions to make them accessible to users.","pos":[178,283]},{"content":"Every securable object has permissions that can be granted to a principal using permission statements.","pos":[284,386]},{"pos":[395,427],"content":"The Principle of Least Privilege","linkify":"The Principle of Least Privilege","nodes":[{"content":"The Principle of Least Privilege","pos":[0,32]}]},{"content":"Developing an application using a least-privileged user account (LUA) approach is an important part of a defensive, in-depth strategy for countering security threats.","pos":[431,597]},{"content":"The LUA approach ensures that users follow the principle of least privilege and always log on with limited user accounts.","pos":[598,719]},{"content":"Administrative tasks are broken out using fixed server roles, and the use of the <ph id=\"ph1\">`sysadmin`</ph> fixed server role is severely restricted.","pos":[720,853],"source":" Administrative tasks are broken out using fixed server roles, and the use of the `sysadmin` fixed server role is severely restricted."},{"content":"Always follow the principle of least privilege when granting permissions to database users.","pos":[860,951]},{"content":"Grant the minimum permissions necessary to a user or role to accomplish a given task.","pos":[952,1037]},{"pos":[1045,2041],"content":"[!IMPORTANT]\n Developing and testing an application using the LUA approach adds a degree of difficulty to the development process. It is easier to create objects and write code while logged on as a system administrator or database owner than it is using a LUA account. However, developing applications using a highly privileged account can obfuscate the impact of reduced functionality when least privileged users attempt to run an application that requires elevated permissions in order to function correctly. Granting excessive permissions to users in order to reacquire lost functionality can leave your application vulnerable to attack. Designing, developing and testing your application logged on with a LUA account enforces a disciplined approach to security planning that eliminates unpleasant surprises and the temptation to grant elevated privileges as a quick fix. You can use a SQL Server login for testing even if your application is intended to deploy using Windows authentication.","leadings":["","> "],"nodes":[{"content":"Developing and testing an application using the LUA approach adds a degree of difficulty to the development process. It is easier to create objects and write code while logged on as a system administrator or database owner than it is using a LUA account. However, developing applications using a highly privileged account can obfuscate the impact of reduced functionality when least privileged users attempt to run an application that requires elevated permissions in order to function correctly. Granting excessive permissions to users in order to reacquire lost functionality can leave your application vulnerable to attack. Designing, developing and testing your application logged on with a LUA account enforces a disciplined approach to security planning that eliminates unpleasant surprises and the temptation to grant elevated privileges as a quick fix. You can use a SQL Server login for testing even if your application is intended to deploy using Windows authentication.","pos":[14,994],"nodes":[{"content":"Developing and testing an application using the LUA approach adds a degree of difficulty to the development process.","pos":[0,116]},{"content":"It is easier to create objects and write code while logged on as a system administrator or database owner than it is using a LUA account.","pos":[117,254]},{"content":"However, developing applications using a highly privileged account can obfuscate the impact of reduced functionality when least privileged users attempt to run an application that requires elevated permissions in order to function correctly.","pos":[255,496]},{"content":"Granting excessive permissions to users in order to reacquire lost functionality can leave your application vulnerable to attack.","pos":[497,626]},{"content":"Designing, developing and testing your application logged on with a LUA account enforces a disciplined approach to security planning that eliminates unpleasant surprises and the temptation to grant elevated privileges as a quick fix.","pos":[627,860]},{"content":"You can use a SQL Server login for testing even if your application is intended to deploy using Windows authentication.","pos":[861,980]}]}]},{"pos":[2050,2072],"content":"Role-Based Permissions","linkify":"Role-Based Permissions","nodes":[{"content":"Role-Based Permissions","pos":[0,22]}]},{"content":"Granting permissions to roles rather than to users simplifies security administration.","pos":[2076,2162]},{"content":"Permission sets that are assigned to roles are inherited by all members of the role.","pos":[2163,2247]},{"content":"It is easier to add or remove users from a role than it is to recreate separate permission sets for individual users.","pos":[2248,2365]},{"content":"Roles can be nested; however, too many levels of nesting can degrade performance.","pos":[2366,2447]},{"content":"You can also add users to fixed database roles to simplify assigning permissions.","pos":[2448,2529]},{"content":"You can grant permissions at the schema level.","pos":[2536,2582]},{"content":"Users automatically inherit permissions on all new objects created in the schema; you do not need to grant permissions as new objects are created.","pos":[2583,2729]},{"pos":[2738,2773],"content":"Permissions Through Procedural Code","linkify":"Permissions Through Procedural Code","nodes":[{"content":"Permissions Through Procedural Code","pos":[0,35]}]},{"content":"Encapsulating data access through modules such as stored procedures and user-defined functions provides an additional layer of protection around your application.","pos":[2777,2939]},{"content":"You can prevent users from directly interacting with database objects by granting permissions only to stored procedures or functions while denying permissions to underlying objects such as tables.","pos":[2940,3136]},{"content":"SQL Server achieves this by ownership chaining.","pos":[3137,3184]},{"pos":[3193,3214],"content":"Permission Statements","linkify":"Permission Statements","nodes":[{"content":"Permission Statements","pos":[0,21]}]},{"content":"The three Transact-SQL permission statements are described in the following table.","pos":[3218,3300]},{"content":"Permission Statement","pos":[3307,3327]},{"content":"Description","pos":[3328,3339]},{"content":"GRANT","pos":[3393,3398]},{"content":"Grants a permission.","pos":[3399,3419]},{"content":"REVOKE","pos":[3424,3430]},{"content":"Revokes a permission.","pos":[3431,3452]},{"content":"This is the default state of a new object.","pos":[3453,3495]},{"content":"A permission revoked from a user or role can still be inherited from other groups or roles to which the principal is assigned.","pos":[3496,3622]},{"content":"DENY","pos":[3627,3631]},{"content":"DENY revokes a permission so that it cannot be inherited.","pos":[3632,3689]},{"content":"DENY takes precedence over all permissions, except DENY does not apply to object owners or members of <ph id=\"ph1\">`sysadmin`</ph>.","pos":[3690,3803],"source":" DENY takes precedence over all permissions, except DENY does not apply to object owners or members of `sysadmin`."},{"content":"If you DENY permissions on an object to the <ph id=\"ph1\">`public`</ph> role it is denied to all users and roles except for object owners and <ph id=\"ph2\">`sysadmin`</ph> members.","pos":[3804,3946],"source":" If you DENY permissions on an object to the `public` role it is denied to all users and roles except for object owners and `sysadmin` members."},{"content":"The GRANT statement can assign permissions to a group or role that can be inherited by database users.","pos":[3957,4059]},{"content":"However, the DENY statement takes precedence over all other permission statements.","pos":[4060,4142]},{"content":"Therefore, a user who has been denied a permission cannot inherit it from another role.","pos":[4143,4230]},{"pos":[4238,4340],"content":"[!NOTE]\n Members of the `sysadmin` fixed server role and object owners cannot be denied permissions.","leadings":["","> "],"nodes":[{"content":"Members of the <ph id=\"ph1\">`sysadmin`</ph> fixed server role and object owners cannot be denied permissions.","pos":[9,100],"source":"Members of the `sysadmin` fixed server role and object owners cannot be denied permissions."}]},{"pos":[4349,4365],"content":"Ownership Chains","linkify":"Ownership Chains","nodes":[{"content":"Ownership Chains","pos":[0,16]}]},{"content":"SQL Server ensures that only principals that have been granted permission can access objects.","pos":[4369,4462]},{"content":"When multiple database objects access each other, the sequence is known as a chain.","pos":[4463,4546]},{"content":"When SQL Server is traversing the links in the chain, it evaluates permissions differently than it would if it were accessing each item separately.","pos":[4547,4694]},{"content":"When an object is accessed through a chain, SQL Server first compares the object's owner to the owner of the calling object (the previous link in the chain).","pos":[4695,4852]},{"content":"If both objects have the same owner, permissions on the referenced object are not checked.","pos":[4853,4943]},{"content":"Whenever an object accesses another object that has a different owner, the ownership chain is broken and SQL Server must check the caller's security context.","pos":[4944,5101]},{"pos":[5110,5148],"content":"Procedural Code and Ownership Chaining","linkify":"Procedural Code and Ownership Chaining","nodes":[{"content":"Procedural Code and Ownership Chaining","pos":[0,38]}]},{"content":"Suppose that a user is granted execute permissions on a stored procedure that selects data from a table.","pos":[5152,5256]},{"content":"If the stored procedure and the table have the same owner, the user doesn't need to be granted any permissions on the table and can even be denied permissions.","pos":[5257,5416]},{"content":"However, if the stored procedure and the table have different owners, SQL Server must check the user's permissions on the table before allowing access to the data.","pos":[5417,5580]},{"pos":[5588,6064],"content":"[!NOTE]\n Ownership chaining does not apply in the case of dynamic SQL statements. To call a procedure that executes an SQL statement, the caller must be granted permissions on the underlying tables, leaving your application vulnerable to SQL Injection attack. SQL Server provides new mechanisms, such as impersonation and signing modules with certificates, that do not require granting permissions on the underlying tables. These can also be used with CLR stored procedures.","leadings":["","> "],"nodes":[{"content":"Ownership chaining does not apply in the case of dynamic SQL statements. To call a procedure that executes an SQL statement, the caller must be granted permissions on the underlying tables, leaving your application vulnerable to SQL Injection attack. SQL Server provides new mechanisms, such as impersonation and signing modules with certificates, that do not require granting permissions on the underlying tables. These can also be used with CLR stored procedures.","pos":[9,474],"nodes":[{"content":"Ownership chaining does not apply in the case of dynamic SQL statements.","pos":[0,72]},{"content":"To call a procedure that executes an SQL statement, the caller must be granted permissions on the underlying tables, leaving your application vulnerable to SQL Injection attack.","pos":[73,250]},{"content":"SQL Server provides new mechanisms, such as impersonation and signing modules with certificates, that do not require granting permissions on the underlying tables.","pos":[251,414]},{"content":"These can also be used with CLR stored procedures.","pos":[415,465]}]}]},{"pos":[6073,6091],"content":"External Resources","linkify":"External Resources","nodes":[{"content":"External Resources","pos":[0,18]}]},{"content":"For more information, see the following resources.","pos":[6095,6145]},{"content":"Resource","pos":[6152,6160]},{"content":"Description","pos":[6161,6172]},{"pos":[6214,6291],"content":"<bpt id=\"p1\">[</bpt>Permissions<ept id=\"p1\">](/sql/relational-databases/security/permissions-database-engine)</ept>","source":"[Permissions](/sql/relational-databases/security/permissions-database-engine)"},{"content":"Contains topics describing permissions hierarchy, catalog views, and permissions of fixed server and database roles.","pos":[6292,6408]},{"pos":[6416,6424],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6428,6535],"content":"<bpt id=\"p1\">[</bpt>Securing ADO.NET Applications<ept id=\"p1\">](../../../../../docs/framework/data/adonet/securing-ado-net-applications.md)</ept>","source":"[Securing ADO.NET Applications](../../../../../docs/framework/data/adonet/securing-ado-net-applications.md)"},{"pos":[6538,6679],"content":"<bpt id=\"p1\">[</bpt>Application Security Scenarios in SQL Server<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/application-security-scenarios-in-sql-server.md)</ept>","source":"[Application Security Scenarios in SQL Server](../../../../../docs/framework/data/adonet/sql/application-security-scenarios-in-sql-server.md)"},{"pos":[6682,6791],"content":"<bpt id=\"p1\">[</bpt>Authentication in SQL Server<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/authentication-in-sql-server.md)</ept>","source":"[Authentication in SQL Server](../../../../../docs/framework/data/adonet/sql/authentication-in-sql-server.md)"},{"pos":[6794,6925],"content":"<bpt id=\"p1\">[</bpt>Server and Database Roles in SQL Server<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/server-and-database-roles-in-sql-server.md)</ept>","source":"[Server and Database Roles in SQL Server](../../../../../docs/framework/data/adonet/sql/server-and-database-roles-in-sql-server.md)"},{"pos":[6928,7081],"content":"<bpt id=\"p1\">[</bpt>Ownership and User-Schema Separation in SQL Server<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/ownership-and-user-schema-separation-in-sql-server.md)</ept>","source":"[Ownership and User-Schema Separation in SQL Server](../../../../../docs/framework/data/adonet/sql/ownership-and-user-schema-separation-in-sql-server.md)"},{"pos":[7084,7188],"content":"<bpt id=\"p1\">[</bpt>ADO.NET Managed Providers and DataSet Developer Center<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=217917)</ept>","source":"[ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)"}]}