<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3171b1e3f48907778be6e256780e06bad36481f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\generics\differences-between-cpp-templates-and-csharp-generics.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c8982019ea47acd4afac2cfce9cf63108c55c921</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8c07fd1107f027659a89bc8d62cc1a2f728cb337</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Differences Between C++ Templates and C# Generics (C# Programming Guide) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Differences Between C++ Templates and C# Generics (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C# Generics and C++ templates are both language features that provide support for parameterized types.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>However, there are many differences between the two.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>At the syntax level, C# generics are a simpler approach to parameterized types without the complexity of C++ templates.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In addition, C# does not attempt to provide all of the functionality that C++ templates provide.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>At the implementation level, the primary difference is that C# generic type substitutions are performed at runtime and generic type information is thereby preserved for instantiated objects.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Generics in the Run Time<ept id="p1">](../../../csharp/programming-guide/generics/generics-in-the-run-time.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following are the key differences between C# Generics and C++ templates:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>C# generics do not provide the same amount of flexibility as C++ templates.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, it is not possible to call arithmetic operators in a C# generic class, although it is possible to call user defined operators.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>C# does not allow non-type template parameters, such as <ph id="ph1">`template C&lt;int i&gt; {}`</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>C# does not support explicit specialization; that is, a custom implementation of a template for a specific type.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>C# does not support partial specialization: a custom implementation for a subset of the type arguments.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>C# does not allow the type parameter to be used as the base class for the generic type.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>C# does not allow type parameters to have default types.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In C#, a generic type parameter cannot itself be a generic, although constructed types can be used as generics.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>C++ does allow template parameters.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>C++ allows code that might not be valid for all type parameters in the template, which is then checked for the specific type used as the type parameter.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>C# requires code in a class to be written in such a way that it will work with any type that satisfies the constraints.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For example, in C++ it is possible to write a function that uses the arithmetic operators <ph id="ph1">`+`</ph> and <ph id="ph2">`-`</ph> on objects of the type parameter, which will produce an error at the time of instantiation of the template with a type that does not support these operators.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>C# disallows this; the only language constructs allowed are those that can be deduced from the constraints.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Introduction to Generics<ept id="p1">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Templates<ept id="p1">](https://docs.microsoft.com/cpp/cpp/templates-cpp)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>