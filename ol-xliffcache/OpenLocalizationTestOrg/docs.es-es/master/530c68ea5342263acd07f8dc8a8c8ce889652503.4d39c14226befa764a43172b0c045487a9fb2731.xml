{"content":"---\ntitle: \"Event Design\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"pre-events\"\n  - \"events [.NET Framework], design guidelines\"\n  - \"member design guidelines, events\"\n  - \"event handlers [.NET Framework], event design guidelines\"\n  - \"post-events\"\n  - \"signatures, event handling\"\nms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a\nauthor: \"KrzysztofCwalina\"\n---\n# Event Design\nEvents are the most commonly used form of callbacks (constructs that allow the framework to call into user code). Other callback mechanisms include members taking delegates, virtual members, and interface-based plug-ins. Data from usability studies indicate that the majority of developers are more comfortable using events than they are using the other callback mechanisms. Events are nicely integrated with Visual Studio and many languages.  \n  \n It is important to note that there are two groups of events: events raised before a state of the system changes, called pre-events, and events raised after a state changes, called post-events. An example of a pre-event would be `Form.Closing`, which is raised before a form is closed. An example of a post-event would be `Form.Closed`, which is raised after a form is closed.  \n  \n **✓ DO** use the term \"raise\" for events rather than \"fire\" or \"trigger.\"  \n  \n **✓ DO** use <xref:System.EventHandler%601?displayProperty=nameWithType> instead of manually creating new delegates to be used as event handlers.  \n  \n **✓ CONSIDER** using a subclass of <xref:System.EventArgs> as the event argument, unless you are absolutely sure the event will never need to carry any data to the event handling method, in which case you can use the `EventArgs` type directly.  \n  \n If you ship an API using `EventArgs` directly, you will never be able to add any data to be carried with the event without breaking compatibility. If you use a subclass, even if initially completely empty, you will be able to add properties to the subclass when needed.  \n  \n **✓ DO** use a protected virtual method to raise each event. This is only applicable to nonstatic events on unsealed classes, not to structs, sealed classes, or static events.  \n  \n The purpose of the method is to provide a way for a derived class to handle the event using an override. Overriding is a more flexible, faster, and more natural way to handle base class events in derived classes. By convention, the name of the method should start with \"On\" and be followed with the name of the event.  \n  \n The derived class can choose not to call the base implementation of the method in its override. Be prepared for this by not including any processing in the method that is required for the base class to work correctly.  \n  \n **✓ DO** take one parameter to the protected method that raises an event.  \n  \n The parameter should be named `e` and should be typed as the event argument class.  \n  \n **X DO NOT** pass null as the sender when raising a nonstatic event.  \n  \n **✓ DO** pass null as the sender when raising a static event.  \n  \n **X DO NOT** pass null as the event data parameter when raising an event.  \n  \n You should pass `EventArgs.Empty` if you don’t want to pass any data to the event handling method. Developers expect this parameter not to be null.  \n  \n **✓ CONSIDER** raising events that the end user can cancel. This only applies to pre-events.  \n  \n Use <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> or its subclass as the event argument to allow the end user to cancel events.  \n  \n### Custom Event Handler Design  \n There are cases in which `EventHandler<T>` cannot be used, such as when the framework needs to work with earlier versions of the CLR, which did not support Generics. In such cases, you might need to design and develop a custom event handler delegate.  \n  \n **✓ DO** use a return type of void for event handlers.  \n  \n An event handler can invoke multiple event handling methods, possibly on multiple objects. If event handling methods were allowed to return a value, there would be multiple return values for each event invocation.  \n  \n **✓ DO** use `object` as the type of the first parameter of the event handler, and call it `sender`.  \n  \n **✓ DO** use <xref:System.EventArgs?displayProperty=nameWithType> or its subclass as the type of the second parameter of the event handler, and call it `e`.  \n  \n **X DO NOT** have more than two parameters on event handlers.  \n  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See also\n\n- [Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)\n- [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)\n","nodes":[{"pos":[4,395],"embed":true,"restype":"x-metadata","content":"title: \"Event Design\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"pre-events\"\n  - \"events [.NET Framework], design guidelines\"\n  - \"member design guidelines, events\"\n  - \"event handlers [.NET Framework], event design guidelines\"\n  - \"post-events\"\n  - \"signatures, event handling\"\nms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a\nauthor: \"KrzysztofCwalina\"","nodes":[{"content":"Event Design","nodes":[{"pos":[0,12],"content":"Event Design","nodes":[{"content":"Event Design","pos":[0,12]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[402,414],"content":"Event Design","linkify":"Event Design","nodes":[{"content":"Event Design","pos":[0,12]}]},{"content":"Events are the most commonly used form of callbacks (constructs that allow the framework to call into user code).","pos":[415,528]},{"content":"Other callback mechanisms include members taking delegates, virtual members, and interface-based plug-ins. Data from usability studies indicate that the majority of developers are more comfortable using events than they are using the other callback mechanisms.","pos":[529,789]},{"content":"Events are nicely integrated with Visual Studio and many languages.","pos":[790,857]},{"content":"It is important to note that there are two groups of events: events raised before a state of the system changes, called pre-events, and events raised after a state changes, called post-events.","pos":[864,1056]},{"content":"An example of a pre-event would be <ph id=\"ph1\">`Form.Closing`</ph>, which is raised before a form is closed.","pos":[1057,1148],"source":" An example of a pre-event would be `Form.Closing`, which is raised before a form is closed."},{"content":"An example of a post-event would be <ph id=\"ph1\">`Form.Closed`</ph>, which is raised after a form is closed.","pos":[1149,1239],"source":" An example of a post-event would be `Form.Closed`, which is raised after a form is closed."},{"pos":[1246,1319],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use the term \"raise\" for events rather than \"fire\" or \"trigger.\"","source":"**✓ DO** use the term \"raise\" for events rather than \"fire\" or \"trigger.\""},{"pos":[1326,1471],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use <ph id=\"ph1\">&lt;xref:System.EventHandler%601?displayProperty=nameWithType&gt;</ph> instead of manually creating new delegates to be used as event handlers.","source":"**✓ DO** use <xref:System.EventHandler%601?displayProperty=nameWithType> instead of manually creating new delegates to be used as event handlers."},{"pos":[1478,1721],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using a subclass of <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> as the event argument, unless you are absolutely sure the event will never need to carry any data to the event handling method, in which case you can use the <ph id=\"ph2\">`EventArgs`</ph> type directly.","source":"**✓ CONSIDER** using a subclass of <xref:System.EventArgs> as the event argument, unless you are absolutely sure the event will never need to carry any data to the event handling method, in which case you can use the `EventArgs` type directly."},{"content":"If you ship an API using <ph id=\"ph1\">`EventArgs`</ph> directly, you will never be able to add any data to be carried with the event without breaking compatibility.","pos":[1728,1874],"source":"If you ship an API using `EventArgs` directly, you will never be able to add any data to be carried with the event without breaking compatibility."},{"content":"If you use a subclass, even if initially completely empty, you will be able to add properties to the subclass when needed.","pos":[1875,1997]},{"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use a protected virtual method to raise each event.","pos":[2004,2064],"source":"**✓ DO** use a protected virtual method to raise each event."},{"content":"This is only applicable to nonstatic events on unsealed classes, not to structs, sealed classes, or static events.","pos":[2065,2179]},{"content":"The purpose of the method is to provide a way for a derived class to handle the event using an override.","pos":[2186,2290]},{"content":"Overriding is a more flexible, faster, and more natural way to handle base class events in derived classes.","pos":[2291,2398]},{"content":"By convention, the name of the method should start with \"On\" and be followed with the name of the event.","pos":[2399,2503]},{"content":"The derived class can choose not to call the base implementation of the method in its override.","pos":[2510,2605]},{"content":"Be prepared for this by not including any processing in the method that is required for the base class to work correctly.","pos":[2606,2727]},{"pos":[2734,2807],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> take one parameter to the protected method that raises an event.","source":"**✓ DO** take one parameter to the protected method that raises an event."},{"pos":[2814,2896],"content":"The parameter should be named <ph id=\"ph1\">`e`</ph> and should be typed as the event argument class.","source":"The parameter should be named `e` and should be typed as the event argument class."},{"pos":[2903,2971],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> pass null as the sender when raising a nonstatic event.","source":"**X DO NOT** pass null as the sender when raising a nonstatic event."},{"pos":[2978,3039],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> pass null as the sender when raising a static event.","source":"**✓ DO** pass null as the sender when raising a static event."},{"pos":[3046,3119],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> pass null as the event data parameter when raising an event.","source":"**X DO NOT** pass null as the event data parameter when raising an event."},{"content":"You should pass <ph id=\"ph1\">`EventArgs.Empty`</ph> if you don’t want to pass any data to the event handling method.","pos":[3126,3224],"source":"You should pass `EventArgs.Empty` if you don’t want to pass any data to the event handling method."},{"content":"Developers expect this parameter not to be null.","pos":[3225,3273]},{"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> raising events that the end user can cancel.","pos":[3280,3339],"source":"**✓ CONSIDER** raising events that the end user can cancel."},{"content":"This only applies to pre-events.","pos":[3340,3372]},{"pos":[3379,3534],"content":"Use <ph id=\"ph1\">&lt;xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType&gt;</ph> or its subclass as the event argument to allow the end user to cancel events.","source":"Use <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> or its subclass as the event argument to allow the end user to cancel events."},{"pos":[3544,3571],"content":"Custom Event Handler Design","linkify":"Custom Event Handler Design","nodes":[{"content":"Custom Event Handler Design","pos":[0,27]}]},{"content":"There are cases in which <ph id=\"ph1\">`EventHandler&lt;T&gt;`</ph> cannot be used, such as when the framework needs to work with earlier versions of the CLR, which did not support Generics.","pos":[3575,3740],"source":"There are cases in which `EventHandler<T>` cannot be used, such as when the framework needs to work with earlier versions of the CLR, which did not support Generics."},{"content":"In such cases, you might need to design and develop a custom event handler delegate.","pos":[3741,3825]},{"pos":[3832,3886],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use a return type of void for event handlers.","source":"**✓ DO** use a return type of void for event handlers."},{"content":"An event handler can invoke multiple event handling methods, possibly on multiple objects.","pos":[3893,3983]},{"content":"If event handling methods were allowed to return a value, there would be multiple return values for each event invocation.","pos":[3984,4106]},{"pos":[4113,4213],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use <ph id=\"ph1\">`object`</ph> as the type of the first parameter of the event handler, and call it <ph id=\"ph2\">`sender`</ph>.","source":"**✓ DO** use `object` as the type of the first parameter of the event handler, and call it `sender`."},{"pos":[4220,4376],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use <ph id=\"ph1\">&lt;xref:System.EventArgs?displayProperty=nameWithType&gt;</ph> or its subclass as the type of the second parameter of the event handler, and call it <ph id=\"ph2\">`e`</ph>.","source":"**✓ DO** use <xref:System.EventArgs?displayProperty=nameWithType> or its subclass as the type of the second parameter of the event handler, and call it `e`."},{"pos":[4383,4444],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> have more than two parameters on event handlers.","source":"**X DO NOT** have more than two parameters on event handlers."},{"pos":[4451,4518],"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[4525,4930],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[4939,4947],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4951,5029],"content":"<bpt id=\"p1\">[</bpt>Member Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/member.md)</ept>","source":"[Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)"},{"pos":[5032,5112],"content":"<bpt id=\"p1\">[</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept>","source":"[Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)"}]}