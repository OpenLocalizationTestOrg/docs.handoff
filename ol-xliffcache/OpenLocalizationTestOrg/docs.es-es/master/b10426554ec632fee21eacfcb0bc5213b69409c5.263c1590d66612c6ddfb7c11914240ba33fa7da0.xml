{"content":"---\ntitle: \"Type Relationships in Query Operations (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"variable relationships [LINQ in Visual Basic]\"\n  - \"type information inferred [LINQ in Visual Basic]\"\n  - \"type relationships [LINQ in Visual Basic]\"\n  - \"queries [LINQ in Visual Basic], type relationships\"\n  - \"data sources [LINQ in Visual Basic], type relationships\"\n  - \"LINQ [Visual Basic], type relationships\"\n  - \"inferring type information [LINQ in Visual Basic]\"\n  - \"relationships [LINQ in Visual Basic]\"\nms.assetid: b5ff4da5-f3fd-4a8e-aaac-1cbf52fa16f6\ncaps.latest.revision: 34\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Type Relationships in Query Operations (Visual Basic)\nVariables used in [!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)] query operations are strongly typed and must be compatible with each other. Strong typing is used in the data source, in the query itself, and in the query execution. The following illustration identifies terms used to describe a [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] query. For more information about the parts of a query, see [Basic Query Operations (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md).  \n  \n ![Pseudocode query with elements highlighted.](../../../../visual-basic/programming-guide/concepts/linq/media/sjltyperels.png \"SJLtypeRels\")  \nParts of a LINQ query  \n  \n The type of the range variable in the query must be compatible with the type of the elements in the data source. The type of the query variable must be compatible with the sequence element defined in the `Select` clause. Finally, the type of the sequence elements also must be compatible with the type of the loop control variable that is used in the `For Each` statement that executes the query. This strong typing facilitates identification of type errors at compile time.  \n  \n [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] makes strong typing convenient by implementing local type inference, also known as *implicit typing*. That feature is used in the previous example, and you will see it used throughout the [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] samples and documentation. In Visual Basic, local type inference is accomplished simply by using a `Dim` statement without an `As` clause. In the following example, `city` is strongly typed as a string.  \n  \n [!code-vb[VbLINQTypeRels#1](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_1.vb)]  \n  \n> [!NOTE]\n>  Local type inference works only when `Option Infer` is set to `On`. For more information, see [Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md).  \n  \n However, even if you use local type inference in a query, the same type relationships are present among the variables in the data source, the query variable, and the query execution loop. It is useful to have a basic understanding of these type relationships when you are writing [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] queries, or working with the samples and code examples in the documentation.  \n  \n You may need to specify an explicit type for a range variable that does not match the type returned from the data source. You can specify the type of the range variable by using an `As` clause. However, this results in an error if the conversion is a [narrowing conversion](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md) and `Option Strict` is set to `On`. Therefore, we recommend that you perform the conversion on the values retrieved from the data source. You can convert the values from the data source to the explicit range variable type by using the <xref:System.Linq.Enumerable.Cast%2A> method. You can also cast the values selected in the `Select` clause to an explicit type that is different from the type of the range variable. These points are illustrated in the following code.  \n  \n [!code-vb[VbLINQTypeRels#4](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_2.vb)]  \n  \n## Queries That Return Entire Elements of the Source Data  \n The following example shows a [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] query operation that returns a sequence of elements selected from the source data. The source, `names`, contains an array of strings, and the query output is a sequence containing strings that start with the letter M.  \n  \n [!code-vb[VbLINQTypeRels#2](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_3.vb)]  \n  \n This is equivalent to the following code, but is much shorter and easier to write. Reliance on local type inference in queries is the preferred style in Visual Basic.  \n  \n [!code-vb[VbLINQTypeRels#3](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_4.vb)]  \n  \n The following relationships exist in both of the previous code examples, whether the types are determined implicitly or explicitly.  \n  \n1.  The type of the elements in the data source, `names`, is the type of the range variable, `name`, in the query.  \n  \n2.  The type of the object that is selected, `name`, determines the type of the query variable, `mNames`. Here `name` is a string, so the query variable is IEnumerable(Of String) in Visual Basic.  \n  \n3.  The query defined in `mNames` is executed in the `For Each` loop. The loop iterates over the result of executing the query. Because `mNames`, when it is executed, will return a sequence of strings, the loop iteration variable, `nm`, also is a string.  \n  \n## Queries That Return One Field from Selected Elements  \n The following example shows a [!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)] query operation that returns a sequence containing only one part of each element selected from the data source. The query takes a collection of `Customer` objects as its data source and projects only the `Name` property in the result. Because the customer name is a string, the query produces a sequence of strings as output.  \n  \n```vb  \n' Method GetTable returns a table of Customer objects.  \nDim customers = db.GetTable(Of Customer)()  \nDim custNames = From cust In customers   \n                Where cust.City = \"London\"   \n                Select cust.Name  \n  \nFor Each custName In custNames  \n    Console.WriteLine(custName)  \nNext  \n```  \n  \n The relationships between variables are like those in the simpler example.  \n  \n1.  The type of the elements in the data source, `customers`, is the type of the range variable, `cust`, in the query. In this example, that type is `Customer`.  \n  \n2.  The `Select` statement returns the `Name` property of each `Customer` object instead of the whole object. Because `Name` is a string, the query variable, `custNames`, will again be IEnumerable(Of String), not of `Customer`.  \n  \n3.  Because `custNames` represents a sequence of strings, the `For Each` loop's iteration variable, `custName`, must be a string.  \n  \n Without local type inference, the previous example would be more cumbersome to write and to understand, as the following example shows.  \n  \n```vb  \n' Method GetTable returns a table of Customer objects.  \n Dim customers As Table(Of Customer) = db.GetTable(Of Customer)()  \n Dim custNames As IEnumerable(Of String) =   \n     From cust As Customer In customers   \n     Where cust.City = \"London\"   \n     Select cust.Name  \n  \n For Each custName As String In custNames  \n     Console.WriteLine(custName)  \n Next  \n```  \n  \n## Queries That Require Anonymous Types  \n The following example shows a more complex situation. In the previous example, it was inconvenient to specify types for all the variables explicitly. In this example, it is impossible. Instead of selecting entire `Customer` elements from the data source, or a single field from each element, the `Select` clause in this query returns two properties of the original `Customer` object: `Name` and `City`. In response to the `Select` clause, the compiler defines an anonymous type that contains those two properties. The result of executing `nameCityQuery` in the `For Each` loop is a collection of instances of the new anonymous type. Because the anonymous type has no usable name, you cannot specify the type of `nameCityQuery` or `custInfo` explicitly. That is, with an anonymous type, you have no type name to use in place of `String` in `IEnumerable(Of String)`. For more information, see [Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md).  \n  \n```vb  \n' Method GetTable returns a table of Customer objects.  \nDim customers = db.GetTable(Of Customer)()  \nDim nameCityQuery = From cust In customers   \n                    Where cust.City = \"London\"   \n                    Select cust.Name, cust.City  \n  \nFor Each custInfo In nameCityQuery  \n    Console.WriteLine(custInfo.Name)  \nNext  \n```  \n  \n Although it is not possible to specify types for all the variables in the previous example, the relationships remain the same.  \n  \n1.  The type of the elements in the data source is again the type of the range variable in the query. In this example, `cust` is an instance of `Customer`.  \n  \n2.  Because the `Select` statement produces an anonymous type, the query variable, `nameCityQuery`, must be implicitly typed as an anonymous type. An anonymous type has no usable name, and therefore cannot be specified explicitly.  \n  \n3.  The type of the iteration variable in the `For Each` loop is the anonymous type created in step 2. Because the type has no usable name, the type of the loop iteration variable must be determined implicitly.  \n  \n## See Also  \n [Getting Started with LINQ in Visual Basic](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md)   \n [Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)   \n [Local Type Inference](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)   \n [Introduction to LINQ in Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)   \n [LINQ](../../../../visual-basic/programming-guide/language-features/linq/index.md)   \n [Queries](../../../../visual-basic/language-reference/queries/queries.md)","nodes":[{"pos":[4,1032],"embed":true,"restype":"x-metadata","content":"title: \"Type Relationships in Query Operations (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"variable relationships [LINQ in Visual Basic]\"\n  - \"type information inferred [LINQ in Visual Basic]\"\n  - \"type relationships [LINQ in Visual Basic]\"\n  - \"queries [LINQ in Visual Basic], type relationships\"\n  - \"data sources [LINQ in Visual Basic], type relationships\"\n  - \"LINQ [Visual Basic], type relationships\"\n  - \"inferring type information [LINQ in Visual Basic]\"\n  - \"relationships [LINQ in Visual Basic]\"\nms.assetid: b5ff4da5-f3fd-4a8e-aaac-1cbf52fa16f6\ncaps.latest.revision: 34\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","nodes":[{"content":"Type Relationships in Query Operations (Visual Basic) | Microsoft Docs","nodes":[{"pos":[0,70],"content":"Type Relationships in Query Operations (Visual Basic) | Microsoft Docs","nodes":[{"content":"Type Relationships in Query Operations (Visual Basic) | Microsoft Docs","pos":[0,70]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[1039,1092],"content":"Type Relationships in Query Operations (Visual Basic)","linkify":"Type Relationships in Query Operations (Visual Basic)","nodes":[{"content":"Type Relationships in Query Operations (Visual Basic)","pos":[0,53]}]},{"content":"Variables used in <ph id=\"ph1\">[!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)]</ph> query operations are strongly typed and must be compatible with each other.","pos":[1093,1275],"source":"Variables used in [!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)] query operations are strongly typed and must be compatible with each other."},{"content":"Strong typing is used in the data source, in the query itself, and in the query execution.","pos":[1276,1366]},{"content":"The following illustration identifies terms used to describe a <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query.","pos":[1367,1503],"source":" The following illustration identifies terms used to describe a [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] query."},{"content":"For more information about the parts of a query, see <bpt id=\"p1\">[</bpt>Basic Query Operations (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)</ept>.","pos":[1504,1681],"source":" For more information about the parts of a query, see [Basic Query Operations (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)."},{"content":"<bpt id=\"p1\">![</bpt>Pseudocode query with elements highlighted.<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../visual-basic/programming-guide/concepts/linq/media/sjltyperels.png \"</bpt>SJLtypeRels<ept id=\"p2\">\")</ept>","pos":[1688,1828],"source":"![Pseudocode query with elements highlighted.](../../../../visual-basic/programming-guide/concepts/linq/media/sjltyperels.png \"SJLtypeRels\")"},{"content":"Parts of a LINQ query","pos":[1831,1852]},{"content":"The type of the range variable in the query must be compatible with the type of the elements in the data source.","pos":[1859,1971]},{"content":"The type of the query variable must be compatible with the sequence element defined in the <ph id=\"ph1\">`Select`</ph> clause.","pos":[1972,2079],"source":" The type of the query variable must be compatible with the sequence element defined in the `Select` clause."},{"content":"Finally, the type of the sequence elements also must be compatible with the type of the loop control variable that is used in the <ph id=\"ph1\">`For Each`</ph> statement that executes the query.","pos":[2080,2255],"source":" Finally, the type of the sequence elements also must be compatible with the type of the loop control variable that is used in the `For Each` statement that executes the query."},{"content":"This strong typing facilitates identification of type errors at compile time.","pos":[2256,2333]},{"content":"makes strong typing convenient by implementing local type inference, also known as <bpt id=\"p1\">*</bpt>implicit typing<ept id=\"p1\">*</ept>.","pos":[2433,2534],"source":" makes strong typing convenient by implementing local type inference, also known as *implicit typing*."},{"content":"That feature is used in the previous example, and you will see it used throughout the <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> samples and documentation.","pos":[2535,2714],"source":" That feature is used in the previous example, and you will see it used throughout the [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] samples and documentation."},{"content":"In Visual Basic, local type inference is accomplished simply by using a <ph id=\"ph1\">`Dim`</ph> statement without an <ph id=\"ph2\">`As`</ph> clause.","pos":[2715,2826],"source":" In Visual Basic, local type inference is accomplished simply by using a `Dim` statement without an `As` clause."},{"content":"In the following example, <ph id=\"ph1\">`city`</ph> is strongly typed as a string.","pos":[2827,2890],"source":" In the following example, `city` is strongly typed as a string."},{"pos":[3059,3271],"content":"[!NOTE]\n Local type inference works only when `Option Infer` is set to `On`. For more information, see [Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md).","leadings":["","> "],"nodes":[{"content":"Local type inference works only when `Option Infer` is set to `On`. For more information, see [Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md).","pos":[9,210],"nodes":[{"content":"Local type inference works only when <ph id=\"ph1\">`Option Infer`</ph> is set to <ph id=\"ph2\">`On`</ph>.","pos":[0,67],"source":"Local type inference works only when `Option Infer` is set to `On`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Option Infer Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept>.","pos":[68,201],"source":" For more information, see [Option Infer Statement](../../../../visual-basic/language-reference/statements/option-infer-statement.md)."}]}]},{"content":"However, even if you use local type inference in a query, the same type relationships are present among the variables in the data source, the query variable, and the query execution loop.","pos":[3278,3465]},{"content":"It is useful to have a basic understanding of these type relationships when you are writing <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> queries, or working with the samples and code examples in the documentation.","pos":[3466,3701],"source":" It is useful to have a basic understanding of these type relationships when you are writing [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] queries, or working with the samples and code examples in the documentation."},{"content":"You may need to specify an explicit type for a range variable that does not match the type returned from the data source.","pos":[3708,3829]},{"content":"You can specify the type of the range variable by using an <ph id=\"ph1\">`As`</ph> clause.","pos":[3830,3901],"source":" You can specify the type of the range variable by using an `As` clause."},{"content":"However, this results in an error if the conversion is a <bpt id=\"p1\">[</bpt>narrowing conversion<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept> and <ph id=\"ph1\">`Option Strict`</ph> is set to <ph id=\"ph2\">`On`</ph>.","pos":[3902,4128],"source":" However, this results in an error if the conversion is a [narrowing conversion](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md) and `Option Strict` is set to `On`."},{"content":"Therefore, we recommend that you perform the conversion on the values retrieved from the data source.","pos":[4129,4230]},{"content":"You can convert the values from the data source to the explicit range variable type by using the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Cast%2A&gt;</ph> method.","pos":[4231,4373],"source":" You can convert the values from the data source to the explicit range variable type by using the <xref:System.Linq.Enumerable.Cast%2A> method."},{"content":"You can also cast the values selected in the <ph id=\"ph1\">`Select`</ph> clause to an explicit type that is different from the type of the range variable.","pos":[4374,4509],"source":" You can also cast the values selected in the `Select` clause to an explicit type that is different from the type of the range variable."},{"content":"These points are illustrated in the following code.","pos":[4510,4561]},{"pos":[4731,4785],"content":"Queries That Return Entire Elements of the Source Data","linkify":"Queries That Return Entire Elements of the Source Data","nodes":[{"content":"Queries That Return Entire Elements of the Source Data","pos":[0,54]}]},{"content":"The following example shows a <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query operation that returns a sequence of elements selected from the source data.","pos":[4789,4968],"source":"The following example shows a [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] query operation that returns a sequence of elements selected from the source data."},{"content":"The source, <ph id=\"ph1\">`names`</ph>, contains an array of strings, and the query output is a sequence containing strings that start with the letter M.","pos":[4969,5103],"source":" The source, `names`, contains an array of strings, and the query output is a sequence containing strings that start with the letter M."},{"content":"This is equivalent to the following code, but is much shorter and easier to write.","pos":[5271,5353]},{"content":"Reliance on local type inference in queries is the preferred style in Visual Basic.","pos":[5354,5437]},{"content":"The following relationships exist in both of the previous code examples, whether the types are determined implicitly or explicitly.","pos":[5605,5736]},{"pos":[5746,5856],"content":"The type of the elements in the data source, <ph id=\"ph1\">`names`</ph>, is the type of the range variable, <ph id=\"ph2\">`name`</ph>, in the query.","source":"The type of the elements in the data source, `names`, is the type of the range variable, `name`, in the query."},{"content":"The type of the object that is selected, <ph id=\"ph1\">`name`</ph>, determines the type of the query variable, <ph id=\"ph2\">`mNames`</ph>.","pos":[5866,5967],"source":"The type of the object that is selected, `name`, determines the type of the query variable, `mNames`."},{"content":"Here <ph id=\"ph1\">`name`</ph> is a string, so the query variable is IEnumerable(Of String) in Visual Basic.","pos":[5968,6057],"source":" Here `name` is a string, so the query variable is IEnumerable(Of String) in Visual Basic."},{"content":"The query defined in <ph id=\"ph1\">`mNames`</ph> is executed in the <ph id=\"ph2\">`For Each`</ph> loop.","pos":[6067,6132],"source":"The query defined in `mNames` is executed in the `For Each` loop."},{"content":"The loop iterates over the result of executing the query.","pos":[6133,6190]},{"content":"Because <ph id=\"ph1\">`mNames`</ph>, when it is executed, will return a sequence of strings, the loop iteration variable, <ph id=\"ph2\">`nm`</ph>, also is a string.","pos":[6191,6317],"source":" Because `mNames`, when it is executed, will return a sequence of strings, the loop iteration variable, `nm`, also is a string."},{"pos":[6326,6378],"content":"Queries That Return One Field from Selected Elements","linkify":"Queries That Return One Field from Selected Elements","nodes":[{"content":"Queries That Return One Field from Selected Elements","pos":[0,52]}]},{"content":"The following example shows a <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)]</ph> query operation that returns a sequence containing only one part of each element selected from the data source.","pos":[6382,6592],"source":"The following example shows a [!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)] query operation that returns a sequence containing only one part of each element selected from the data source."},{"content":"The query takes a collection of <ph id=\"ph1\">`Customer`</ph> objects as its data source and projects only the <ph id=\"ph2\">`Name`</ph> property in the result.","pos":[6593,6715],"source":" The query takes a collection of `Customer` objects as its data source and projects only the `Name` property in the result."},{"content":"Because the customer name is a string, the query produces a sequence of strings as output.","pos":[6716,6806]},{"content":"The relationships between variables are like those in the simpler example.","pos":[7132,7206]},{"content":"The type of the elements in the data source, <ph id=\"ph1\">`customers`</ph>, is the type of the range variable, <ph id=\"ph2\">`cust`</ph>, in the query.","pos":[7216,7330],"source":"The type of the elements in the data source, `customers`, is the type of the range variable, `cust`, in the query."},{"content":"In this example, that type is <ph id=\"ph1\">`Customer`</ph>.","pos":[7331,7372],"source":" In this example, that type is `Customer`."},{"content":"The <ph id=\"ph1\">`Select`</ph> statement returns the <ph id=\"ph2\">`Name`</ph> property of each <ph id=\"ph3\">`Customer`</ph> object instead of the whole object.","pos":[7382,7487],"source":"The `Select` statement returns the `Name` property of each `Customer` object instead of the whole object."},{"content":"Because <ph id=\"ph1\">`Name`</ph> is a string, the query variable, <ph id=\"ph2\">`custNames`</ph>, will again be IEnumerable(Of String), not of <ph id=\"ph3\">`Customer`</ph>.","pos":[7488,7605],"source":" Because `Name` is a string, the query variable, `custNames`, will again be IEnumerable(Of String), not of `Customer`."},{"pos":[7615,7740],"content":"Because <ph id=\"ph1\">`custNames`</ph> represents a sequence of strings, the <ph id=\"ph2\">`For Each`</ph> loop's iteration variable, <ph id=\"ph3\">`custName`</ph>, must be a string.","source":"Because `custNames` represents a sequence of strings, the `For Each` loop's iteration variable, `custName`, must be a string."},{"content":"Without local type inference, the previous example would be more cumbersome to write and to understand, as the following example shows.","pos":[7747,7882]},{"pos":[8271,8307],"content":"Queries That Require Anonymous Types","linkify":"Queries That Require Anonymous Types","nodes":[{"content":"Queries That Require Anonymous Types","pos":[0,36]}]},{"content":"The following example shows a more complex situation.","pos":[8311,8364]},{"content":"In the previous example, it was inconvenient to specify types for all the variables explicitly.","pos":[8365,8460]},{"content":"In this example, it is impossible.","pos":[8461,8495]},{"content":"Instead of selecting entire <ph id=\"ph1\">`Customer`</ph> elements from the data source, or a single field from each element, the <ph id=\"ph2\">`Select`</ph> clause in this query returns two properties of the original <ph id=\"ph3\">`Customer`</ph> object: <ph id=\"ph4\">`Name`</ph> and <ph id=\"ph5\">`City`</ph>.","pos":[8496,8713],"source":" Instead of selecting entire `Customer` elements from the data source, or a single field from each element, the `Select` clause in this query returns two properties of the original `Customer` object: `Name` and `City`."},{"content":"In response to the <ph id=\"ph1\">`Select`</ph> clause, the compiler defines an anonymous type that contains those two properties.","pos":[8714,8824],"source":" In response to the `Select` clause, the compiler defines an anonymous type that contains those two properties."},{"content":"The result of executing <ph id=\"ph1\">`nameCityQuery`</ph> in the <ph id=\"ph2\">`For Each`</ph> loop is a collection of instances of the new anonymous type.","pos":[8825,8943],"source":" The result of executing `nameCityQuery` in the `For Each` loop is a collection of instances of the new anonymous type."},{"content":"Because the anonymous type has no usable name, you cannot specify the type of <ph id=\"ph1\">`nameCityQuery`</ph> or <ph id=\"ph2\">`custInfo`</ph> explicitly.","pos":[8944,9063],"source":" Because the anonymous type has no usable name, you cannot specify the type of `nameCityQuery` or `custInfo` explicitly."},{"content":"That is, with an anonymous type, you have no type name to use in place of <ph id=\"ph1\">`String`</ph> in <ph id=\"ph2\">`IEnumerable(Of String)`</ph>.","pos":[9064,9175],"source":" That is, with an anonymous type, you have no type name to use in place of `String` in `IEnumerable(Of String)`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>.","pos":[9176,9321],"source":" For more information, see [Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)."},{"content":"Although it is not possible to specify types for all the variables in the previous example, the relationships remain the same.","pos":[9679,9805]},{"content":"The type of the elements in the data source is again the type of the range variable in the query.","pos":[9815,9912]},{"content":"In this example, <ph id=\"ph1\">`cust`</ph> is an instance of <ph id=\"ph2\">`Customer`</ph>.","pos":[9913,9966],"source":" In this example, `cust` is an instance of `Customer`."},{"content":"Because the <ph id=\"ph1\">`Select`</ph> statement produces an anonymous type, the query variable, <ph id=\"ph2\">`nameCityQuery`</ph>, must be implicitly typed as an anonymous type.","pos":[9976,10118],"source":"Because the `Select` statement produces an anonymous type, the query variable, `nameCityQuery`, must be implicitly typed as an anonymous type."},{"content":"An anonymous type has no usable name, and therefore cannot be specified explicitly.","pos":[10119,10202]},{"content":"The type of the iteration variable in the <ph id=\"ph1\">`For Each`</ph> loop is the anonymous type created in step 2.","pos":[10212,10310],"source":"The type of the iteration variable in the `For Each` loop is the anonymous type created in step 2."},{"content":"Because the type has no usable name, the type of the loop iteration variable must be determined implicitly.","pos":[10311,10418]},{"pos":[10427,10435],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Getting Started with LINQ in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md)</ept><ph id=\"ph1\"> </ph>","pos":[10439,10570],"source":"[Getting Started with LINQ in Visual Basic](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md) "},{"content":"<bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[10574,10693],"source":"[Anonymous Types](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Local Type Inference<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept><ph id=\"ph1\"> </ph>","pos":[10697,10816],"source":"[Local Type Inference](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md) "},{"content":"<bpt id=\"p1\">[</bpt>Introduction to LINQ in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id=\"ph1\"> </ph>","pos":[10820,10950],"source":"[Introduction to LINQ in Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md) "},{"content":"<bpt id=\"p1\">[</bpt>LINQ<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/linq/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[10954,11037],"source":"[LINQ](../../../../visual-basic/programming-guide/language-features/linq/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Queries<ept id=\"p1\">](../../../../visual-basic/language-reference/queries/queries.md)</ept>","pos":[11041,11114],"source":"[Queries](../../../../visual-basic/language-reference/queries/queries.md)"}]}