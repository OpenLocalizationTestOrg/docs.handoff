<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="csharp-6.md" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">478fd512f6b6facfce6d7f70f9691ce15e418d6e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\whats-new\csharp-6.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7e5f0be7527aba51ac09e19cc247e054d37773f0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7b11e3ee078200de115fb23f8f5bf1392bb1c0ea</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>What's New in C# 6 - C# Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn the new features in C# Version 6</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>What's New in C# 6</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The 6.0 release of C# contained many features that improve productivity for developers.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The overall effect of these features is that you write more concise code that is also more readable.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The syntax contains less ceremony for many common practices.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It's easier to see the design intent with less ceremony.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Learn these features well, and you'll be more productive and write more readable code.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can concentrate more on your features than on the constructs of the language.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The rest of this article provides an overview of each of these features, with a link to explore each feature.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can also explore the features in an <bpt id="p1">[</bpt>interactive exploration on C# 6<ept id="p1">](../tutorials/exploration/csharp-6.yml)</ept> in the tutorials section.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Read-only auto-properties</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Read-only auto-properties<ept id="p1">*</ept> provide a more concise syntax to create immutable types.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You declare the auto-property with only a get accessor:</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FirstName`</ph> and <ph id="ph2">`LastName`</ph> properties can be set only in the body of a constructor:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Trying to set <ph id="ph1">`LastName`</ph> in another method generates a <ph id="ph2">`CS0200`</ph> compilation error:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This feature enables true language support for creating immutable types and uses the more concise and convenient auto-property syntax.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If adding this syntax doesn't remove an accessible method, it's a <bpt id="p1">[</bpt>binary compatible change<ept id="p1">](version-update-considerations.md#binary-compatible-changes)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Auto-property initializers</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Auto-property initializers<ept id="p1">*</ept> let you declare the initial value for an auto-property as part of the property declaration.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Grades`</ph> member is initialized where it's declared.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That makes it easier to perform the initialization exactly once.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for <ph id="ph1">`Student`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Expression-bodied function members</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Many members that you write are single statements that could be single expressions.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Write an expression-bodied member instead.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It works for methods and read-only properties.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, an override of <ph id="ph1">`ToString()`</ph> is often a great candidate:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You can also use this syntax for read-only properties:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Changing an existing member to an expression bodied member is a <bpt id="p1">[</bpt>binary compatible change<ept id="p1">](version-update-considerations.md#binary-compatible-changes)</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>using static</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>using static<ept id="p1">*</ept> enhancement enables you to import the static methods of a single class.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You specify the class you're using:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Math&gt;</ph> does not contain any instance methods.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can also use <ph id="ph1">`using static`</ph> to import a class' static methods for a class that has both static and instance methods.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>One of the most useful examples is <ph id="ph1">&lt;xref:System.String&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You must use the fully qualified class name, <ph id="ph1">`System.String`</ph>  in a static using statement.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You cannot use the <ph id="ph1">`string`</ph> keyword instead.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When imported from a <ph id="ph1">`static using`</ph> statement, extension methods are only in scope when called using the extension method invocation syntax.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>They aren't in scope when called as a static method.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You'll often see this in LINQ queries.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can import the LINQ pattern by importing <ph id="ph1">&lt;xref:System.Linq.Enumerable&gt;</ph>, or <ph id="ph2">&lt;xref:System.Linq.Queryable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You typically call extension methods using extension method invocation expressions.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Adding the class name in the rare case where you call them using static method call syntax resolves ambiguity.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`static using`</ph> directive also imports any nested types.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can reference any nested types without qualification.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Null-conditional operators</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>null conditional operator<ept id="p1">*</ept> makes null checks much easier and fluid.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Replace the member access <ph id="ph1">`.`</ph> with <ph id="ph2">`?.`</ph>:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In the preceding example, the variable <ph id="ph1">`first`</ph> is assigned <ph id="ph2">`null`</ph> if the person object is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Otherwise, it is assigned the value of the <ph id="ph1">`FirstName`</ph> property.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Most importantly, the <ph id="ph1">`?.`</ph> means that this line of code doesn't generate a <ph id="ph2">`NullReferenceException`</ph> if the <ph id="ph3">`person`</ph> variable is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Instead, it short-circuits and returns <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can also use a null conditional operator for array or indexer access.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Replace <ph id="ph1">`[]`</ph> with <ph id="ph2">`?[]`</ph> in the index expression.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following expression returns a <ph id="ph1">`string`</ph>, regardless of the value of <ph id="ph2">`person`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You often use this construct with the <bpt id="p1">*</bpt>null coalescing<ept id="p1">*</ept> operator to assign default values when one of the properties is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When the expression short-circuits, the <ph id="ph1">`null`</ph> value returned is typed to match the full expression.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You can also use <ph id="ph1">`?.`</ph> to conditionally invoke methods.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You'll call the delegate's <ph id="ph1">`Invoke`</ph> method using the <ph id="ph2">`?.`</ph> operator to access the member.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You can see an example in the <bpt id="p1">[</bpt>delegate patterns<ept id="p1">](../delegates-patterns.md#handling-null-delegates)</ept> article.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The rules of the <ph id="ph1">`?.`</ph> operator ensure that the left-hand side of the operator is evaluated only once.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It enables many idioms, including the following example using event handlers:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the <ph id="ph1">`?.`</ph></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>String interpolation</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>With C# 6, the new <bpt id="p1">[</bpt>string interpolation<ept id="p1">](../language-reference/tokens/interpolated.md)</ept> feature enables you to embed expressions in a string.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Simply preface the string with <ph id="ph1">`$`</ph>and use expressions between <ph id="ph2">`{`</ph> and <ph id="ph3">`}`</ph> instead of ordinals:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This example uses properties for the substituted expressions.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You can use any expression.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, you could compute a student's grade point average as part of the interpolation:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The preceding line of code formats the value for <ph id="ph1">`Grades.Average()`</ph> as a floating-point number with two decimal places.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Often, you may need to format the string produced using a specific culture.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You use the fact that the object produced by a string interpolation can be implicitly converted to <ph id="ph1">&lt;xref:System.FormattableString?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.FormattableString&gt;</ph> instance contains the composite format string and the results of evaluating the expressions before converting them to strings.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType&gt;</ph> method to specify the culture when formatting a string.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following example produces a string using the German (de-DE) culture.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>(By default, the German culture uses the ',' character for the decimal separator, and the '.' character as the thousands separator.)</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>To get started with string interpolation, see the <bpt id="p1">[</bpt>String interpolation in C#<ept id="p1">](../tutorials/exploration/interpolated-strings.yml)</ept> interactive tutorial, the <bpt id="p2">[</bpt>String interpolation<ept id="p2">](../language-reference/tokens/interpolated.md)</ept> article, and the <bpt id="p3">[</bpt>String interpolation in C#<ept id="p3">](../tutorials/string-interpolation.md)</ept> tutorial.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Exception filters</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Exception Filters<ept id="p1">*</ept> are clauses that determine when a given catch clause should be applied.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If the expression used for an exception filter evaluates to <ph id="ph1">`true`</ph>, the catch clause performs its normal processing on an exception.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to <ph id="ph1">`false`</ph>, then the <ph id="ph2">`catch`</ph> clause is skipped.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>One use is to examine information about an exception to determine if a <ph id="ph1">`catch`</ph> clause can process the exception:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`nameof`</ph> expression</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`nameof`</ph> expression evaluates to the name of a symbol.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>One of the most common uses for <ph id="ph1">`nameof`</ph> is to provide the name of a symbol that caused an exception:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Another use is with XAML-based applications that implement the <ph id="ph1">`INotifyPropertyChanged`</ph> interface:</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Await in Catch and Finally blocks</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>C# 5 had several limitations around where you could place <ph id="ph1">`await`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>With C# 6, you can now use <ph id="ph1">`await`</ph> in <ph id="ph2">`catch`</ph> or <ph id="ph3">`finally`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This is most often used with logging scenarios:</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The implementation details for adding <ph id="ph1">`await`</ph> support inside <ph id="ph2">`catch`</ph> and <ph id="ph3">`finally`</ph> clauses ensure that the behavior is consistent with the behavior for synchronous code.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>When code executed in a <ph id="ph1">`catch`</ph> or <ph id="ph2">`finally`</ph> clause throws, execution looks for a suitable <ph id="ph3">`catch`</ph> clause in the next surrounding block.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If there was a current exception, that exception is lost.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The same happens with awaited expressions in <ph id="ph1">`catch`</ph> and <ph id="ph2">`finally`</ph> clauses: a suitable <ph id="ph3">`catch`</ph> is searched for, and the current exception, if any, is lost.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This behavior is the reason it's recommended to write <ph id="ph1">`catch`</ph> and <ph id="ph2">`finally`</ph> clauses carefully, to avoid introducing new exceptions.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Initialize associative collections using indexers</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Index Initializers<ept id="p1">*</ept> is one of two features that make collection initializers more consistent with index usage.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In earlier releases of C#, you could use <bpt id="p1">*</bpt>collection initializers<ept id="p1">*</ept> with sequence style collections, including <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>, by adding braces around key and value pairs:</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>You can use them with <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> collections and other types where the accessible <ph id="ph2">`Add`</ph> method accepts more than one argument.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The new syntax supports assignment using an index into the collection:</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Extension <ph id="ph1">`Add`</ph> methods in collection initializers</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Another feature that makes collection initialization easier is the ability to use an <bpt id="p1">*</bpt>extension method<ept id="p1">*</ept> for the <ph id="ph1">`Add`</ph> method.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This feature was added for parity with Visual Basic.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Improved overload resolution</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This last feature is one you probably won't notice.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Consider this method:</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In earlier versions of C#, calling that method using the method group syntax would fail:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The earlier compiler couldn't distinguish correctly between <ph id="ph1">`Task.Run(Action)`</ph> and <ph id="ph2">`Task.Run(Func&lt;Task&gt;())`</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In previous versions, you'd need to use a lambda expression as an argument:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The C# 6 compiler correctly determines that <ph id="ph1">`Task.Run(Func&lt;Task&gt;())`</ph> is a better choice.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Deterministic compiler output</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-deterministic`</ph> option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>By default, every compilation produces unique output on each compilation.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The compiler adds a timestamp, and a GUID generated from random numbers.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You use this option if you want to compare the byte-for-byte output to ensure consistency across builds.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>-deterministic compiler option<ept id="p1">](../language-reference/compiler-options/deterministic-compiler-option.md)</ept> article.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>