{"content":"---\ntitle: \"Default Marshaling for Arrays\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"interop marshaling, arrays\"\n  - \"arrays, interop marshaling\"\nms.assetid: 8a3cca8b-dd94-4e3d-ad9a-9ee7590654bc\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Default Marshaling for Arrays\nIn an application consisting entirely of managed code, the common language runtime passes array types as In/Out parameters. In contrast, the interop marshaler passes an array as In parameters by default.  \n  \n With [pinning optimization](copying-and-pinning.md), a blittable array can appear to operate as an In/Out parameter when interacting with objects in the same apartment. However, if you later export the code to a type library used to generate the cross-machine proxy, and that library is used to marshal your calls across apartments, the calls can revert to true In parameter behavior.  \n  \n Arrays are complex by nature, and the distinctions between managed and unmanaged arrays warrant more information than other non-blittable types.  \n  \n## Managed Arrays  \n Managed array types can vary; however, the <xref:System.Array?displayProperty=nameWithType> class is the base class of all array types. The **System.Array** class has properties for determining the rank, length, and lower and upper bounds of an array, as well as methods for accessing, sorting, searching, copying, and creating arrays.  \n  \n These array types are dynamic and do not have a corresponding static type defined in the base class library. It is convenient to think of each combination of element type and rank as a distinct type of array. Therefore, a one-dimensional array of integers is of a different type than a one-dimensional array of double types. Similarly a two-dimensional array of integers is different from a one-dimensional array of integers. The bounds of the array are not considered when comparing types.  \n  \n As the following table shows, any instance of a managed array must be of a specific element type, rank, and lower bound.  \n  \n|Managed array type|Element type|Rank|Lower bound|Signature notation|  \n|------------------------|------------------|----------|-----------------|------------------------|  \n|**ELEMENT_TYPE_ARRAY**|Specified by type.|Specified by rank.|Optionally specified by bounds.|*type* **[** *n*,*m* **]**|  \n|**ELEMENT_TYPE_CLASS**|Unknown|Unknown|Unknown|**System.Array**|  \n|**ELEMENT_TYPE_SZARRAY**|Specified by type.|1|0|*type* **[** *n* **]**|  \n  \n## Unmanaged Arrays  \n Unmanaged arrays are either COM-style safe arrays or C-style arrays with fixed or variable length. Safe arrays are self-describing arrays that carry the type, rank, and bounds of the associated array data. C-style arrays are one-dimensional typed arrays with a fixed lower bound of 0. The marshaling service has limited support for both types of arrays.  \n  \n## Passing Array Parameters to .NET Code  \n Both C-style arrays and safe arrays can be passed to .NET code from unmanaged code as either a safe array or a C-style array. The following table shows the unmanaged type value and the imported type.  \n  \n|Unmanaged type|Imported type|  \n|--------------------|-------------------|  \n|**SafeArray(** *Type* **)**|**ELEMENT_TYPE_SZARRAY** **\\<** *ConvertedType* **>**<br /><br /> Rank = 1, lower bound = 0. Size is known only if provided in the managed signature. Safe arrays that are not rank = 1 or lower bound = 0 cannot be marshaled as **SZARRAY**.|  \n|*Type*  **[]**|**ELEMENT_TYPE_SZARRAY** **\\<** *ConvertedType* **>**<br /><br /> Rank = 1, lower bound = 0. Size is known only if provided in the managed signature.|  \n  \n### Safe Arrays  \n When a safe array is imported from a type library to a .NET assembly, the array is converted to a one-dimensional array of a known type (such as **int**). The same type conversion rules that apply to parameters also apply to array elements. For example, a safe array of **BSTR** types becomes a managed array of strings and a safe array of variants becomes a managed array of objects. The **SAFEARRAY** element type is captured from the type library and saved in the **SAFEARRAY** value of the <xref:System.Runtime.InteropServices.UnmanagedType> enumeration.  \n  \n Because the rank and bounds of the safe array cannot be determined from the type library, the rank is assumed to equal 1 and the lower bound is assumed to equal 0. The rank and bounds must be defined in the managed signature produced by the [Type Library Importer (Tlbimp.exe)](../tools/tlbimp-exe-type-library-importer.md). If the rank passed to the method at run time differs, a <xref:System.Runtime.InteropServices.SafeArrayRankMismatchException> is thrown. If the type of the array passed at run time differs, a <xref:System.Runtime.InteropServices.SafeArrayTypeMismatchException> is thrown. The following example shows safe arrays in managed and unmanaged code.  \n  \n **Unmanaged signature**  \n  \n```  \nHRESULT New1([in] SAFEARRAY( int ) ar);  \nHRESULT New2([in] SAFEARRAY( DATE ) ar);  \nHRESULT New3([in, out] SAFEARRAY( BSTR ) *ar);  \n```  \n  \n **Managed signature**  \n  \n```vb  \nSub New1(<MarshalAs(UnmanagedType.SafeArray, SafeArraySubType:=VT_I4)> _  \n   ar() As Integer)  \nSub New2(<MarshalAs(UnmanagedType.SafeArray, SafeArraySubType:=VT_DATE)> _   \n   ar() As DateTime)  \nSub New3(ByRef <MarshalAs(UnmanagedType.SafeArray, SafeArraySubType:=VT_BSTR)> _   \n   ar() As String)  \n```  \n  \n```csharp  \nvoid New1([MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VT_I4)] int[] ar) ;  \nvoid New2([MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VT_DATE)]   \n   DateTime[] ar);  \nvoid New3([MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VT_BSTR)]   \n   ref String[] ar);  \n```  \n  \n Multidimensional, or nonzero-bound safe arrays, can be marshaled into managed code if the method signature produced by Tlbimp.exe is modified to indicate an element type of **ELEMENT_TYPE_ARRAY** instead of **ELEMENT_TYPE_SZARRAY**. Alternatively, you can use the **/sysarray** switch with Tlbimp.exe to import all arrays as <xref:System.Array?displayProperty=nameWithType> objects. In cases where the array being passed is known to be multidimensional, you can edit the Microsoft intermediate language (MSIL) code produced by Tlbimp.exe and then recompile it. For details about how to modify MSIL code, see [Customizing Runtime Callable Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e753eftz(v=vs.100)).  \n  \n### C-Style Arrays  \n When a C-style array is imported from a type library to a .NET assembly, the array is converted to **ELEMENT_TYPE_SZARRAY**.  \n  \n The array element type is determined from the type library and preserved during the import. The same conversion rules that apply to parameters also apply to array elements. For example, an array of **LPStr** types becomes an array of **String** types. Tlbimp.exe captures the array element type and applies the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute to the parameter.  \n  \n The array rank is assumed to equal 1. If the rank is greater than 1, the array is marshaled as a one-dimensional array in column-major order. The lower bound always equals 0.  \n  \n Type libraries can contain arrays of fixed or variable length. Tlbimp.exe can import only fixed-length arrays from type libraries because type libraries lack the information needed to marshal variable-length arrays. With fixed-length arrays, the size is imported from the type library and captured in the **MarshalAsAttribute** that is applied to the parameter.  \n  \n You must manually define type libraries containing variable-length arrays, as shown in the following example.  \n  \n **Unmanaged signature**  \n  \n```  \nHRESULT New1(int ar[10]);  \nHRESULT New2(double ar[10][20]);  \nHRESULT New3(LPWStr ar[10]);  \n```  \n  \n **Managed signature**  \n  \n```vb  \nSub New1(<MarshalAs(UnmanagedType.LPArray, SizeConst=10)> _  \n   ar() As Integer)  \nSub New2(<MarshalAs(UnmanagedType.LPArray, SizeConst=200)> _  \n   ar() As Double)  \nSub New2(<MarshalAs(UnmanagedType.LPArray, _  \n   ArraySubType=UnmanagedType.LPWStr, SizeConst=10)> _  \n   ar() As String)  \n```  \n  \n```csharp  \nvoid New1([MarshalAs(UnmanagedType.LPArray, SizeConst=10)] int[] ar);  \nvoid New2([MarshalAs(UnmanagedType.LPArray, SizeConst=200)] double[] ar);  \nvoid New2([MarshalAs(UnmanagedType.LPArray,   \n   ArraySubType=UnmanagedType.LPWStr, SizeConst=10)] String[] ar);  \n```  \n  \n Although you can apply the **size_is** or **length_is** attributes to an array in Interface Definition Language (IDL) source to convey the size to a client, the Microsoft Interface Definition Language (MIDL) compiler does not propagate that information to the type library. Without knowing the size, the interop marshaling service cannot marshal the array elements. Consequently, variable-length arrays are imported as reference arguments. For example:  \n  \n **Unmanaged signature**  \n  \n```  \nHRESULT New1(int ar[]);  \nHRESULT New2(int ArSize, [size_is(ArSize)] double ar[]);  \nHRESULT New3(int ElemCnt, [length_is(ElemCnt)] LPStr ar[]);  \n```  \n  \n **Managed signature**  \n  \n```vb  \nSub New1(ByRef ar As Integer)  \nSub New2(ByRef ar As Double)  \nSub New3(ByRef ar As String)  \n```  \n  \n```csharp  \nvoid New1(ref int ar);    \nvoid New2(ref double ar);    \nvoid New3(ref String ar);   \n```  \n  \n You can provide the marshaler with the array size by editing the Microsoft intermediate language (MSIL) code produced by Tlbimp.exe and then recompiling it. For details about how to modify MSIL code, see [Customizing Runtime Callable Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e753eftz(v=vs.100)). To indicate the number of elements in the array, apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute> type to the array parameter of the managed method definition in one of the following ways:  \n  \n-   Identify another parameter that contains the number of elements in the array. The parameters are identified by position, starting with the first parameter as number 0.     \n  \n    ```vb  \n    Sub [New](ElemCnt As Integer, _  \n       \\<MarshalAs(UnmanagedType.LPArray, SizeParamIndex:=1)> _  \n       ar() As Integer)  \n    ```  \n  \n    ```csharp  \n    void New(  \n       int ElemCnt,   \n       [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] int[] ar );  \n    ```  \n  \n-   Define the size of the array as a constant. For example:  \n  \n    ```vb  \n    Sub [New](\\<MarshalAs(UnmanagedType.LPArray, SizeConst:=128)> _  \n       ar() As Integer)  \n    ```  \n  \n    ```csharp  \n    void New(  \n       [MarshalAs(UnmanagedType.LPArray, SizeConst=128)] int[] ar );  \n    ```  \n  \n When marshaling arrays from unmanaged code to managed code, the marshaler checks the **MarshalAsAttribute** associated with the parameter to determine the array size. If the array size is not specified, only one element is marshaled.  \n  \n> [!NOTE]\n>  The **MarshalAsAttribute** has no effect on marshaling managed arrays to unmanaged code. In that direction, the array size is determined by examination. There is no way to marshal a subset of a managed array.  \n  \n The interop marshaler uses the **CoTaskMemAlloc** and **CoTaskMemFree** methods to allocate and retrieve memory. Memory allocation performed by unmanaged code must also use these methods.  \n  \n## Passing Arrays to COM  \n All managed array types can be passed to unmanaged code from managed code. Depending on the managed type and the attributes applied to it, the array can be accessed as a safe array or a C-style array, as shown in the following table.  \n  \n|Managed array type|Exported as|  \n|------------------------|-----------------|  \n|**ELEMENT_TYPE_SZARRAY** **\\<** *type* **>**|<xref:System.Runtime.InteropServices.UnmanagedType> **.SafeArray(** *type* **)**<br /><br /> **UnmanagedType.LPArray**<br /><br /> Type is provided in the signature. Rank is always 1, lower bound is always 0. Size is always known at run time.|  \n|**ELEMENT_TYPE_ARRAY** **\\<** *type* **>** **\\<** *rank* **>**[**\\<** *bounds* **>**]|**UnmanagedType.SafeArray(** *type* **)**<br /><br /> **UnmanagedType.LPArray**<br /><br /> Type, rank, bounds are provided in the signature. Size is always known at run time.|  \n|**ELEMENT_TYPE_CLASS** **\\<**<xref:System.Array?displayProperty=nameWithType>**>**|**UT_Interface**<br /><br /> **UnmanagedType.SafeArray(** *type* **)**<br /><br /> Type, rank, bounds, and size are always known at run time.|  \n  \n There is a limitation in OLE Automation relating to arrays of structures that contain LPSTR or LPWSTR.  Therefore, **String** fields have to be marshaled as **UnmanagedType.BSTR**. Otherwise, an exception will be thrown.  \n  \n### ELEMENT_TYPE_SZARRAY  \n When a method containing an **ELEMENT_TYPE_SZARRAY** parameter (one-dimensional array) is exported from a .NET assembly to a type library, the array parameter is converted to a **SAFEARRAY** of a given type. The same conversion rules apply to the array element types. The contents of the managed array are automatically copied from managed memory into the **SAFEARRAY**. For example:  \n  \n#### Managed signature  \n  \n```vb  \nSub [New](ar() As Long)  \nSub [New](ar() As String)  \n```  \n  \n```csharp  \nvoid New(long[] ar );  \nvoid New(String[] ar );  \n```  \n  \n#### Unmanaged signature  \n  \n```  \nHRESULT New([in] SAFEARRAY( long ) ar);   \nHRESULT New([in] SAFEARRAY( BSTR ) ar);  \n```  \n  \n The rank of the safe arrays is always 1 and the lower bound is always 0. The size is determined at run time by the size of the managed array being passed.  \n  \n The array can also be marshaled as a C-style array by using the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute. For example:  \n  \n#### Managed signature  \n  \n```vb  \nSub [New](<MarshalAs(UnmanagedType.LPArray, SizeParamIndex:=1)> _  \n   ar() As Long, size as Integer)  \nSub [New](<MarshalAs(UnmanagedType.LPArray, SizeParamIndex:=1)> _  \n   ar() As String, size as Integer)  \nSub [New](<MarshalAs(UnmanagedType.LPArray, _  \n   ArraySubType= UnmanagedType.LPStr, SizeParamIndex:=1)> _  \n   ar() As String, size as Integer)  \n```  \n  \n```csharp  \nvoid New([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)]   \n   long [] ar, int size );  \nvoid New([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)]   \n   String [] ar, int size );  \nvoid New([MarshalAs(UnmanagedType.LPArray, ArraySubType=   \n   UnmanagedType.LPStr, SizeParamIndex=1)]   \n   String [] ar, int size );  \n```  \n  \n#### Unmanaged signature  \n  \n```  \nHRESULT New(long ar[]);   \nHRESULT New(BSTR ar[]);   \nHRESULT New(LPStr ar[]);  \n```  \n  \n Although the marshaler has the length information needed to marshal the array, the array length is usually passed as a separate argument to convey the length to the callee.  \n  \n### ELEMENT_TYPE_ARRAY  \n When a method containing an **ELEMENT_TYPE_ARRAY** parameter is exported from a .NET assembly to a type library, the array parameter is converted to a **SAFEARRAY** of a given type. The contents of the managed array are automatically copied from managed memory into the **SAFEARRAY**. For example:  \n  \n#### Managed signature  \n  \n```vb  \nSub [New](ar(,) As Long)  \nSub [New](ar(,) As String)  \n```  \n  \n```csharp  \nvoid New( long [,] ar );  \nvoid New( String [,] ar );  \n```  \n  \n#### Unmanaged signature  \n  \n```  \nHRESULT New([in] SAFEARRAY( long ) ar);   \nHRESULT New([in] SAFEARRAY( BSTR ) ar);  \n```  \n  \n The rank, size, and bounds of the safe arrays are determined at run time by the characteristics of the managed array.  \n  \n The array can also be marshaled as a C-style array by applying the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute. For example:  \n  \n#### Managed signature  \n  \n```vb  \nSub [New](<MarshalAs(UnmanagedType.LPARRAY, SizeParamIndex:=1)> _  \n   ar(,) As Long, size As Integer)  \nSub [New](<MarshalAs(UnmanagedType.LPARRAY, _  \n   ArraySubType:=UnmanagedType.LPStr, SizeParamIndex:=1)> _  \n   ar(,) As String, size As Integer)  \n```  \n  \n```csharp  \nvoid New([MarshalAs(UnmanagedType.LPARRAY, SizeParamIndex=1)]   \n   long [,] ar, int size );  \nvoid New([MarshalAs(UnmanagedType.LPARRAY,   \n   ArraySubType= UnmanagedType.LPStr, SizeParamIndex=1)]   \n   String [,] ar, int size );  \n```  \n  \n#### Unmanaged signature  \n  \n```  \nHRESULT New(long ar[]);   \nHRESULT New(LPStr ar[]);  \n```  \n  \n Nested arrays cannot be marshaled. For example, the following signature generates an error when exported with the [Type Library Exporter (Tlbexp.exe)](../tools/tlbexp-exe-type-library-exporter.md).  \n  \n#### Managed signature  \n  \n```vb  \nSub [New](ar()()() As Long)  \n```  \n  \n```csharp  \nvoid New(long [][][] ar );  \n```  \n  \n### ELEMENT_TYPE_CLASS \\<System.Array>  \n When a method containing a <xref:System.Array?displayProperty=nameWithType> parameter is exported from a .NET assembly to a type library, the array parameter is converted to an **_Array** interface. The contents of the managed array are accessible only through the methods and properties of the **_Array** interface. **System.Array** can also be marshaled as a **SAFEARRAY** by using the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute. When marshaled as a safe array, the array elements are marshaled as variants. For example:  \n  \n#### Managed signature  \n  \n```vb  \nSub New1( ar As System.Array )  \nSub New2( <MarshalAs(UnmanagedType.Safe array)> ar As System.Array )  \n```  \n  \n```csharp  \nvoid New1( System.Array ar );  \nvoid New2( [MarshalAs(UnmanagedType.Safe array)] System.Array ar );  \n```  \n  \n#### Unmanaged signature  \n  \n```  \nHRESULT New([in] _Array *ar);   \nHRESULT New([in] SAFEARRAY(VARIANT) ar);  \n```  \n  \n### Arrays within Structures  \n Unmanaged structures can contain embedded arrays. By default, these embedded array fields are marshaled as a SAFEARRAY. In the following example, `s1` is an embedded array that is allocated directly within the structure itself.  \n  \n#### Unmanaged representation  \n  \n```  \nstruct MyStruct {  \n    short s1[128];  \n}  \n```  \n  \n Arrays can be marshaled as <xref:System.Runtime.InteropServices.UnmanagedType>, which requires you to set the <xref:System.Runtime.InteropServices.MarshalAsAttribute> field. The size can be set only as a constant. The following code shows the corresponding managed definition of `MyStruct`.  \n  \n```vb  \nPublic Structure <StructLayout(LayoutKind.Sequential)> MyStruct  \n   Public <MarshalAs(UnmanagedType.ByValArray, SizeConst := 128)> _  \n     s1() As Short  \nEnd Structure  \n```  \n  \n```csharp  \n[StructLayout(LayoutKind.Sequential)]  \npublic struct MyStruct {  \n   [MarshalAs(UnmanagedType.ByValArray, SizeConst=128)] public short[] s1;  \n}  \n```  \n  \n## See also\n\n- [Default Marshaling Behavior](default-marshaling-behavior.md)\n- [Blittable and Non-Blittable Types](blittable-and-non-blittable-types.md)\n- [Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))\n- [Copying and Pinning](copying-and-pinning.md)\n","nodes":[{"pos":[4,275],"embed":true,"restype":"x-metadata","content":"title: \"Default Marshaling for Arrays\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"interop marshaling, arrays\"\n  - \"arrays, interop marshaling\"\nms.assetid: 8a3cca8b-dd94-4e3d-ad9a-9ee7590654bc\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Default Marshaling for Arrays","nodes":[{"pos":[0,29],"content":"Default Marshaling for Arrays","nodes":[{"content":"Default Marshaling for Arrays","pos":[0,29]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[282,311],"content":"Default Marshaling for Arrays","linkify":"Default Marshaling for Arrays","nodes":[{"content":"Default Marshaling for Arrays","pos":[0,29]}]},{"content":"In an application consisting entirely of managed code, the common language runtime passes array types as In/Out parameters.","pos":[312,435]},{"content":"In contrast, the interop marshaler passes an array as In parameters by default.","pos":[436,515]},{"content":"With <bpt id=\"p1\">[</bpt>pinning optimization<ept id=\"p1\">](copying-and-pinning.md)</ept>, a blittable array can appear to operate as an In/Out parameter when interacting with objects in the same apartment.","pos":[522,690],"source":"With [pinning optimization](copying-and-pinning.md), a blittable array can appear to operate as an In/Out parameter when interacting with objects in the same apartment."},{"content":"However, if you later export the code to a type library used to generate the cross-machine proxy, and that library is used to marshal your calls across apartments, the calls can revert to true In parameter behavior.","pos":[691,906]},{"content":"Arrays are complex by nature, and the distinctions between managed and unmanaged arrays warrant more information than other non-blittable types.","pos":[913,1057]},{"pos":[1066,1080],"content":"Managed Arrays","linkify":"Managed Arrays","nodes":[{"content":"Managed Arrays","pos":[0,14]}]},{"content":"Managed array types can vary; however, the <ph id=\"ph1\">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph> class is the base class of all array types.","pos":[1084,1219],"source":"Managed array types can vary; however, the <xref:System.Array?displayProperty=nameWithType> class is the base class of all array types."},{"content":"The <bpt id=\"p1\">**</bpt>System.Array<ept id=\"p1\">**</ept> class has properties for determining the rank, length, and lower and upper bounds of an array, as well as methods for accessing, sorting, searching, copying, and creating arrays.","pos":[1220,1419],"source":" The **System.Array** class has properties for determining the rank, length, and lower and upper bounds of an array, as well as methods for accessing, sorting, searching, copying, and creating arrays."},{"content":"These array types are dynamic and do not have a corresponding static type defined in the base class library.","pos":[1426,1534]},{"content":"It is convenient to think of each combination of element type and rank as a distinct type of array.","pos":[1535,1634]},{"content":"Therefore, a one-dimensional array of integers is of a different type than a one-dimensional array of double types.","pos":[1635,1750]},{"content":"Similarly a two-dimensional array of integers is different from a one-dimensional array of integers.","pos":[1751,1851]},{"content":"The bounds of the array are not considered when comparing types.","pos":[1852,1916]},{"content":"As the following table shows, any instance of a managed array must be of a specific element type, rank, and lower bound.","pos":[1923,2043]},{"content":"Managed array type","pos":[2050,2068]},{"content":"Element type","pos":[2069,2081]},{"content":"Rank","pos":[2082,2086]},{"content":"Lower bound","pos":[2087,2098]},{"content":"Signature notation","pos":[2099,2117]},{"pos":[2224,2246],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_ARRAY<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_ARRAY**"},{"content":"Specified by type.","pos":[2247,2265]},{"content":"Specified by rank.","pos":[2266,2284]},{"content":"Optionally specified by bounds.","pos":[2285,2316]},{"pos":[2317,2343],"content":"<bpt id=\"p1\">*</bpt>type<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>[<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>n<ept id=\"p3\">*</ept>,<bpt id=\"p4\">*</bpt>m<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt>]<ept id=\"p5\">**</ept>","source":"*type* **[** *n*,*m* **]**"},{"pos":[2348,2370],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_CLASS<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_CLASS**"},{"content":"Unknown","pos":[2371,2378]},{"content":"Unknown","pos":[2379,2386]},{"content":"Unknown","pos":[2387,2394]},{"pos":[2395,2411],"content":"<bpt id=\"p1\">**</bpt>System.Array<ept id=\"p1\">**</ept>","source":"**System.Array**"},{"pos":[2416,2440],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_SZARRAY<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_SZARRAY**"},{"content":"Specified by type.","pos":[2441,2459]},{"content":"1","pos":[2460,2461]},{"content":"0","pos":[2462,2463]},{"pos":[2464,2486],"content":"<bpt id=\"p1\">*</bpt>type<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>[<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>n<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt>]<ept id=\"p4\">**</ept>","source":"*type* **[** *n* **]**"},{"pos":[2496,2512],"content":"Unmanaged Arrays","linkify":"Unmanaged Arrays","nodes":[{"content":"Unmanaged Arrays","pos":[0,16]}]},{"content":"Unmanaged arrays are either COM-style safe arrays or C-style arrays with fixed or variable length.","pos":[2516,2614]},{"content":"Safe arrays are self-describing arrays that carry the type, rank, and bounds of the associated array data.","pos":[2615,2721]},{"content":"C-style arrays are one-dimensional typed arrays with a fixed lower bound of 0.","pos":[2722,2800]},{"content":"The marshaling service has limited support for both types of arrays.","pos":[2801,2869]},{"pos":[2878,2915],"content":"Passing Array Parameters to .NET Code","linkify":"Passing Array Parameters to .NET Code","nodes":[{"content":"Passing Array Parameters to .NET Code","pos":[0,37]}]},{"content":"Both C-style arrays and safe arrays can be passed to .NET code from unmanaged code as either a safe array or a C-style array.","pos":[2919,3044]},{"content":"The following table shows the unmanaged type value and the imported type.","pos":[3045,3118]},{"content":"Unmanaged type","pos":[3125,3139]},{"content":"Imported type","pos":[3140,3153]},{"pos":[3203,3230],"content":"<bpt id=\"p1\">**</bpt>SafeArray(<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>Type<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","source":"**SafeArray(** *Type* **)**"},{"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_SZARRAY<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>ConvertedType<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt><ph id=\"ph2\">&gt;</ph><ept id=\"p4\">**</ept>","pos":[3231,3284],"source":"**ELEMENT_TYPE_SZARRAY** **\\<** *ConvertedType* **>**"},{"content":"Rank = 1, lower bound = 0.","pos":[3297,3323]},{"content":"Size is known only if provided in the managed signature.","pos":[3324,3380]},{"content":"Safe arrays that are not rank = 1 or lower bound = 0 cannot be marshaled as <bpt id=\"p1\">**</bpt>SZARRAY<ept id=\"p1\">**</ept>.","pos":[3381,3469],"source":" Safe arrays that are not rank = 1 or lower bound = 0 cannot be marshaled as **SZARRAY**."},{"pos":[3474,3488],"content":"<bpt id=\"p1\">*</bpt>Type<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt>[]<ept id=\"p2\">**</ept>","source":"*Type*  **[]**"},{"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_SZARRAY<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>ConvertedType<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt><ph id=\"ph2\">&gt;</ph><ept id=\"p4\">**</ept>","pos":[3489,3542],"source":"**ELEMENT_TYPE_SZARRAY** **\\<** *ConvertedType* **>**"},{"content":"Rank = 1, lower bound = 0.","pos":[3555,3581]},{"content":"Size is known only if provided in the managed signature.","pos":[3582,3638]},{"pos":[3649,3660],"content":"Safe Arrays","linkify":"Safe Arrays","nodes":[{"content":"Safe Arrays","pos":[0,11]}]},{"content":"When a safe array is imported from a type library to a .NET assembly, the array is converted to a one-dimensional array of a known type (such as <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept>).","pos":[3664,3818],"source":"When a safe array is imported from a type library to a .NET assembly, the array is converted to a one-dimensional array of a known type (such as **int**)."},{"content":"The same type conversion rules that apply to parameters also apply to array elements.","pos":[3819,3904]},{"content":"For example, a safe array of <bpt id=\"p1\">**</bpt>BSTR<ept id=\"p1\">**</ept> types becomes a managed array of strings and a safe array of variants becomes a managed array of objects.","pos":[3905,4048],"source":" For example, a safe array of **BSTR** types becomes a managed array of strings and a safe array of variants becomes a managed array of objects."},{"content":"The <bpt id=\"p1\">**</bpt>SAFEARRAY<ept id=\"p1\">**</ept> element type is captured from the type library and saved in the <bpt id=\"p2\">**</bpt>SAFEARRAY<ept id=\"p2\">**</ept> value of the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.UnmanagedType&gt;</ph> enumeration.","pos":[4049,4222],"source":" The **SAFEARRAY** element type is captured from the type library and saved in the **SAFEARRAY** value of the <xref:System.Runtime.InteropServices.UnmanagedType> enumeration."},{"content":"Because the rank and bounds of the safe array cannot be determined from the type library, the rank is assumed to equal 1 and the lower bound is assumed to equal 0.","pos":[4229,4392]},{"content":"The rank and bounds must be defined in the managed signature produced by the <bpt id=\"p1\">[</bpt>Type Library Importer (Tlbimp.exe)<ept id=\"p1\">](../tools/tlbimp-exe-type-library-importer.md)</ept>.","pos":[4393,4553],"source":" The rank and bounds must be defined in the managed signature produced by the [Type Library Importer (Tlbimp.exe)](../tools/tlbimp-exe-type-library-importer.md)."},{"content":"If the rank passed to the method at run time differs, a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeArrayRankMismatchException&gt;</ph> is thrown.","pos":[4554,4689],"source":" If the rank passed to the method at run time differs, a <xref:System.Runtime.InteropServices.SafeArrayRankMismatchException> is thrown."},{"content":"If the type of the array passed at run time differs, a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeArrayTypeMismatchException&gt;</ph> is thrown.","pos":[4690,4824],"source":" If the type of the array passed at run time differs, a <xref:System.Runtime.InteropServices.SafeArrayTypeMismatchException> is thrown."},{"content":"The following example shows safe arrays in managed and unmanaged code.","pos":[4825,4895]},{"pos":[4902,4925],"content":"<bpt id=\"p1\">**</bpt>Unmanaged signature<ept id=\"p1\">**</ept>","source":"**Unmanaged signature**"},{"pos":[5081,5102],"content":"<bpt id=\"p1\">**</bpt>Managed signature<ept id=\"p1\">**</ept>","source":"**Managed signature**"},{"content":"Multidimensional, or nonzero-bound safe arrays, can be marshaled into managed code if the method signature produced by Tlbimp.exe is modified to indicate an element type of <bpt id=\"p1\">**</bpt>ELEMENT_TYPE_ARRAY<ept id=\"p1\">**</ept> instead of <bpt id=\"p2\">**</bpt>ELEMENT_TYPE_SZARRAY<ept id=\"p2\">**</ept>.","pos":[5731,5963],"source":"Multidimensional, or nonzero-bound safe arrays, can be marshaled into managed code if the method signature produced by Tlbimp.exe is modified to indicate an element type of **ELEMENT_TYPE_ARRAY** instead of **ELEMENT_TYPE_SZARRAY**."},{"content":"Alternatively, you can use the <bpt id=\"p1\">**</bpt>/sysarray<ept id=\"p1\">**</ept> switch with Tlbimp.exe to import all arrays as <ph id=\"ph1\">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph> objects.","pos":[5964,6113],"source":" Alternatively, you can use the **/sysarray** switch with Tlbimp.exe to import all arrays as <xref:System.Array?displayProperty=nameWithType> objects."},{"content":"In cases where the array being passed is known to be multidimensional, you can edit the Microsoft intermediate language (MSIL) code produced by Tlbimp.exe and then recompile it.","pos":[6114,6291]},{"content":"For details about how to modify MSIL code, see <bpt id=\"p1\">[</bpt>Customizing Runtime Callable Wrappers<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e753eftz(v=vs.100))</ept>.","pos":[6292,6468],"source":" For details about how to modify MSIL code, see [Customizing Runtime Callable Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e753eftz(v=vs.100))."},{"pos":[6478,6492],"content":"C-Style Arrays","linkify":"C-Style Arrays","nodes":[{"content":"C-Style Arrays","pos":[0,14]}]},{"pos":[6496,6620],"content":"When a C-style array is imported from a type library to a .NET assembly, the array is converted to <bpt id=\"p1\">**</bpt>ELEMENT_TYPE_SZARRAY<ept id=\"p1\">**</ept>.","source":"When a C-style array is imported from a type library to a .NET assembly, the array is converted to **ELEMENT_TYPE_SZARRAY**."},{"content":"The array element type is determined from the type library and preserved during the import.","pos":[6627,6718]},{"content":"The same conversion rules that apply to parameters also apply to array elements.","pos":[6719,6799]},{"content":"For example, an array of <bpt id=\"p1\">**</bpt>LPStr<ept id=\"p1\">**</ept> types becomes an array of <bpt id=\"p2\">**</bpt>String<ept id=\"p2\">**</ept> types.","pos":[6800,6878],"source":" For example, an array of **LPStr** types becomes an array of **String** types."},{"content":"Tlbimp.exe captures the array element type and applies the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph> attribute to the parameter.","pos":[6879,7022],"source":" Tlbimp.exe captures the array element type and applies the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute to the parameter."},{"content":"The array rank is assumed to equal 1.","pos":[7029,7066]},{"content":"If the rank is greater than 1, the array is marshaled as a one-dimensional array in column-major order.","pos":[7067,7170]},{"content":"The lower bound always equals 0.","pos":[7171,7203]},{"content":"Type libraries can contain arrays of fixed or variable length.","pos":[7210,7272]},{"content":"Tlbimp.exe can import only fixed-length arrays from type libraries because type libraries lack the information needed to marshal variable-length arrays.","pos":[7273,7425]},{"content":"With fixed-length arrays, the size is imported from the type library and captured in the <bpt id=\"p1\">**</bpt>MarshalAsAttribute<ept id=\"p1\">**</ept> that is applied to the parameter.","pos":[7426,7571],"source":" With fixed-length arrays, the size is imported from the type library and captured in the **MarshalAsAttribute** that is applied to the parameter."},{"content":"You must manually define type libraries containing variable-length arrays, as shown in the following example.","pos":[7578,7687]},{"pos":[7694,7717],"content":"<bpt id=\"p1\">**</bpt>Unmanaged signature<ept id=\"p1\">**</ept>","source":"**Unmanaged signature**"},{"pos":[7833,7854],"content":"<bpt id=\"p1\">**</bpt>Managed signature<ept id=\"p1\">**</ept>","source":"**Managed signature**"},{"content":"Although you can apply the <bpt id=\"p1\">**</bpt>size_is<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>length_is<ept id=\"p2\">**</ept> attributes to an array in Interface Definition Language (IDL) source to convey the size to a client, the Microsoft Interface Definition Language (MIDL) compiler does not propagate that information to the type library.","pos":[8456,8729],"source":"Although you can apply the **size_is** or **length_is** attributes to an array in Interface Definition Language (IDL) source to convey the size to a client, the Microsoft Interface Definition Language (MIDL) compiler does not propagate that information to the type library."},{"content":"Without knowing the size, the interop marshaling service cannot marshal the array elements.","pos":[8730,8821]},{"content":"Consequently, variable-length arrays are imported as reference arguments.","pos":[8822,8895]},{"content":"For example:","pos":[8896,8908]},{"pos":[8915,8938],"content":"<bpt id=\"p1\">**</bpt>Unmanaged signature<ept id=\"p1\">**</ept>","source":"**Unmanaged signature**"},{"pos":[9107,9128],"content":"<bpt id=\"p1\">**</bpt>Managed signature<ept id=\"p1\">**</ept>","source":"**Managed signature**"},{"content":"You can provide the marshaler with the array size by editing the Microsoft intermediate language (MSIL) code produced by Tlbimp.exe and then recompiling it.","pos":[9353,9509]},{"content":"For details about how to modify MSIL code, see <bpt id=\"p1\">[</bpt>Customizing Runtime Callable Wrappers<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e753eftz(v=vs.100))</ept>.","pos":[9510,9686],"source":" For details about how to modify MSIL code, see [Customizing Runtime Callable Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e753eftz(v=vs.100))."},{"content":"To indicate the number of elements in the array, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph> type to the array parameter of the managed method definition in one of the following ways:","pos":[9687,9893],"source":" To indicate the number of elements in the array, apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute> type to the array parameter of the managed method definition in one of the following ways:"},{"content":"Identify another parameter that contains the number of elements in the array.","pos":[9903,9980]},{"content":"The parameters are identified by position, starting with the first parameter as number 0.","pos":[9981,10070]},{"content":"Define the size of the array as a constant.","pos":[10380,10423]},{"content":"For example:","pos":[10424,10436]},{"content":"When marshaling arrays from unmanaged code to managed code, the marshaler checks the <bpt id=\"p1\">**</bpt>MarshalAsAttribute<ept id=\"p1\">**</ept> associated with the parameter to determine the array size.","pos":[10680,10846],"source":"When marshaling arrays from unmanaged code to managed code, the marshaler checks the **MarshalAsAttribute** associated with the parameter to determine the array size."},{"content":"If the array size is not specified, only one element is marshaled.","pos":[10847,10913]},{"pos":[10921,11140],"content":"[!NOTE]\n The **MarshalAsAttribute** has no effect on marshaling managed arrays to unmanaged code. In that direction, the array size is determined by examination. There is no way to marshal a subset of a managed array.","leadings":["","> "],"nodes":[{"content":"The **MarshalAsAttribute** has no effect on marshaling managed arrays to unmanaged code. In that direction, the array size is determined by examination. There is no way to marshal a subset of a managed array.","pos":[9,217],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>MarshalAsAttribute<ept id=\"p1\">**</ept> has no effect on marshaling managed arrays to unmanaged code.","pos":[0,88],"source":"The **MarshalAsAttribute** has no effect on marshaling managed arrays to unmanaged code."},{"content":"In that direction, the array size is determined by examination.","pos":[89,152]},{"content":"There is no way to marshal a subset of a managed array.","pos":[153,208]}]}]},{"content":"The interop marshaler uses the <bpt id=\"p1\">**</bpt>CoTaskMemAlloc<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>CoTaskMemFree<ept id=\"p2\">**</ept> methods to allocate and retrieve memory.","pos":[11147,11259],"source":"The interop marshaler uses the **CoTaskMemAlloc** and **CoTaskMemFree** methods to allocate and retrieve memory."},{"content":"Memory allocation performed by unmanaged code must also use these methods.","pos":[11260,11334]},{"pos":[11343,11364],"content":"Passing Arrays to COM","linkify":"Passing Arrays to COM","nodes":[{"content":"Passing Arrays to COM","pos":[0,21]}]},{"content":"All managed array types can be passed to unmanaged code from managed code.","pos":[11368,11442]},{"content":"Depending on the managed type and the attributes applied to it, the array can be accessed as a safe array or a C-style array, as shown in the following table.","pos":[11443,11601]},{"content":"Managed array type","pos":[11608,11626]},{"content":"Exported as","pos":[11627,11638]},{"pos":[11690,11734],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_SZARRAY<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>type<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt><ph id=\"ph2\">&gt;</ph><ept id=\"p4\">**</ept>","source":"**ELEMENT_TYPE_SZARRAY** **\\<** *type* **>**"},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.UnmanagedType&gt;</ph> <bpt id=\"p1\">**</bpt>.SafeArray(<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","pos":[11735,11815],"source":"<xref:System.Runtime.InteropServices.UnmanagedType> **.SafeArray(** *type* **)**"},{"content":"<bpt id=\"p1\">**</bpt>UnmanagedType.LPArray<ept id=\"p1\">**</ept>","pos":[11828,11853],"source":"**UnmanagedType.LPArray**"},{"content":"Type is provided in the signature.","pos":[11866,11900]},{"content":"Rank is always 1, lower bound is always 0.","pos":[11901,11943]},{"content":"Size is always known at run time.","pos":[11944,11977]},{"pos":[11982,12067],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_ARRAY<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>type<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt><ph id=\"ph2\">&gt;</ph><ept id=\"p4\">**</ept> <bpt id=\"p5\">**</bpt><ph id=\"ph3\">\\&lt;</ph><ept id=\"p5\">**</ept> <bpt id=\"p6\">*</bpt>rank<ept id=\"p6\">*</ept> <bpt id=\"p7\">**</bpt><ph id=\"ph4\">&gt;</ph><ept id=\"p7\">**</ept>[<bpt id=\"p8\">**</bpt><ph id=\"ph5\">\\&lt;</ph><ept id=\"p8\">**</ept> <bpt id=\"p9\">*</bpt>bounds<ept id=\"p9\">*</ept> <bpt id=\"p10\">**</bpt><ph id=\"ph6\">&gt;</ph><ept id=\"p10\">**</ept>]","source":"**ELEMENT_TYPE_ARRAY** **\\<** *type* **>** **\\<** *rank* **>**[**\\<** *bounds* **>**]"},{"content":"<bpt id=\"p1\">**</bpt>UnmanagedType.SafeArray(<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","pos":[12068,12109],"source":"**UnmanagedType.SafeArray(** *type* **)**"},{"content":"<bpt id=\"p1\">**</bpt>UnmanagedType.LPArray<ept id=\"p1\">**</ept>","pos":[12122,12147],"source":"**UnmanagedType.LPArray**"},{"content":"Type, rank, bounds are provided in the signature.","pos":[12160,12209]},{"content":"Size is always known at run time.","pos":[12210,12243]},{"pos":[12248,12330],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_CLASS<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p2\">**</ept><ph id=\"ph2\">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph><bpt id=\"p3\">**</bpt><ph id=\"ph3\">&gt;</ph><ept id=\"p3\">**</ept>","source":"**ELEMENT_TYPE_CLASS** **\\<**<xref:System.Array?displayProperty=nameWithType>**>**"},{"content":"<bpt id=\"p1\">**</bpt>UT_Interface<ept id=\"p1\">**</ept>","pos":[12331,12347],"source":"**UT_Interface**"},{"content":"<bpt id=\"p1\">**</bpt>UnmanagedType.SafeArray(<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","pos":[12360,12401],"source":"**UnmanagedType.SafeArray(** *type* **)**"},{"content":"Type, rank, bounds, and size are always known at run time.","pos":[12414,12472]},{"content":"There is a limitation in OLE Automation relating to arrays of structures that contain LPSTR or LPWSTR.","pos":[12480,12582]},{"content":"Therefore, <bpt id=\"p1\">**</bpt>String<ept id=\"p1\">**</ept> fields have to be marshaled as <bpt id=\"p2\">**</bpt>UnmanagedType.BSTR<ept id=\"p2\">**</ept>.","pos":[12584,12660],"source":"  Therefore, **String** fields have to be marshaled as **UnmanagedType.BSTR**."},{"content":"Otherwise, an exception will be thrown.","pos":[12661,12700]},{"pos":[12710,12730],"content":"ELEMENT_TYPE_SZARRAY","linkify":"ELEMENT_TYPE_SZARRAY","nodes":[{"content":"ELEMENT_TYPE_SZARRAY","pos":[0,20]}]},{"content":"When a method containing an <bpt id=\"p1\">**</bpt>ELEMENT_TYPE_SZARRAY<ept id=\"p1\">**</ept> parameter (one-dimensional array) is exported from a .NET assembly to a type library, the array parameter is converted to a <bpt id=\"p2\">**</bpt>SAFEARRAY<ept id=\"p2\">**</ept> of a given type.","pos":[12734,12941],"source":"When a method containing an **ELEMENT_TYPE_SZARRAY** parameter (one-dimensional array) is exported from a .NET assembly to a type library, the array parameter is converted to a **SAFEARRAY** of a given type."},{"content":"The same conversion rules apply to the array element types.","pos":[12942,13001]},{"content":"The contents of the managed array are automatically copied from managed memory into the <bpt id=\"p1\">**</bpt>SAFEARRAY<ept id=\"p1\">**</ept>.","pos":[13002,13104],"source":" The contents of the managed array are automatically copied from managed memory into the **SAFEARRAY**."},{"content":"For example:","pos":[13105,13117]},{"pos":[13128,13145],"content":"Managed signature","linkify":"Managed signature","nodes":[{"content":"Managed signature","pos":[0,17]}]},{"pos":[13298,13317],"content":"Unmanaged signature","linkify":"Unmanaged signature","nodes":[{"content":"Unmanaged signature","pos":[0,19]}]},{"content":"The rank of the safe arrays is always 1 and the lower bound is always 0.","pos":[13424,13496]},{"content":"The size is determined at run time by the size of the managed array being passed.","pos":[13497,13578]},{"content":"The array can also be marshaled as a C-style array by using the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph> attribute.","pos":[13585,13716],"source":"The array can also be marshaled as a C-style array by using the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute."},{"content":"For example:","pos":[13717,13729]},{"pos":[13740,13757],"content":"Managed signature","linkify":"Managed signature","nodes":[{"content":"Managed signature","pos":[0,17]}]},{"pos":[14491,14510],"content":"Unmanaged signature","linkify":"Unmanaged signature","nodes":[{"content":"Unmanaged signature","pos":[0,19]}]},{"content":"Although the marshaler has the length information needed to marshal the array, the array length is usually passed as a separate argument to convey the length to the callee.","pos":[14613,14785]},{"pos":[14795,14813],"content":"ELEMENT_TYPE_ARRAY","linkify":"ELEMENT_TYPE_ARRAY","nodes":[{"content":"ELEMENT_TYPE_ARRAY","pos":[0,18]}]},{"content":"When a method containing an <bpt id=\"p1\">**</bpt>ELEMENT_TYPE_ARRAY<ept id=\"p1\">**</ept> parameter is exported from a .NET assembly to a type library, the array parameter is converted to a <bpt id=\"p2\">**</bpt>SAFEARRAY<ept id=\"p2\">**</ept> of a given type.","pos":[14817,14998],"source":"When a method containing an **ELEMENT_TYPE_ARRAY** parameter is exported from a .NET assembly to a type library, the array parameter is converted to a **SAFEARRAY** of a given type."},{"content":"The contents of the managed array are automatically copied from managed memory into the <bpt id=\"p1\">**</bpt>SAFEARRAY<ept id=\"p1\">**</ept>.","pos":[14999,15101],"source":" The contents of the managed array are automatically copied from managed memory into the **SAFEARRAY**."},{"content":"For example:","pos":[15102,15114]},{"pos":[15125,15142],"content":"Managed signature","linkify":"Managed signature","nodes":[{"content":"Managed signature","pos":[0,17]}]},{"pos":[15303,15322],"content":"Unmanaged signature","linkify":"Unmanaged signature","nodes":[{"content":"Unmanaged signature","pos":[0,19]}]},{"content":"The rank, size, and bounds of the safe arrays are determined at run time by the characteristics of the managed array.","pos":[15429,15546]},{"content":"The array can also be marshaled as a C-style array by applying the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph> attribute.","pos":[15553,15687],"source":"The array can also be marshaled as a C-style array by applying the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute."},{"content":"For example:","pos":[15688,15700]},{"pos":[15711,15728],"content":"Managed signature","linkify":"Managed signature","nodes":[{"content":"Managed signature","pos":[0,17]}]},{"pos":[16264,16283],"content":"Unmanaged signature","linkify":"Unmanaged signature","nodes":[{"content":"Unmanaged signature","pos":[0,19]}]},{"content":"Nested arrays cannot be marshaled.","pos":[16359,16393]},{"content":"For example, the following signature generates an error when exported with the <bpt id=\"p1\">[</bpt>Type Library Exporter (Tlbexp.exe)<ept id=\"p1\">](../tools/tlbexp-exe-type-library-exporter.md)</ept>.","pos":[16394,16556],"source":" For example, the following signature generates an error when exported with the [Type Library Exporter (Tlbexp.exe)](../tools/tlbexp-exe-type-library-exporter.md)."},{"pos":[16567,16584],"content":"Managed signature","linkify":"Managed signature","nodes":[{"content":"Managed signature","pos":[0,17]}]},{"pos":[16691,16725],"content":"ELEMENT_TYPE_CLASS \\<System.Array>","linkify":"ELEMENT_TYPE_CLASS \\<System.Array>","nodes":[{"content":"ELEMENT_TYPE_CLASS <ph id=\"ph1\">\\&lt;</ph>System.Array&gt;","pos":[0,34],"source":"ELEMENT_TYPE_CLASS \\<System.Array>"}]},{"content":"When a method containing a <ph id=\"ph1\">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph> parameter is exported from a .NET assembly to a type library, the array parameter is converted to an <bpt id=\"p1\">**</bpt>_Array<ept id=\"p1\">**</ept> interface.","pos":[16729,16927],"source":"When a method containing a <xref:System.Array?displayProperty=nameWithType> parameter is exported from a .NET assembly to a type library, the array parameter is converted to an **_Array** interface."},{"content":"The contents of the managed array are accessible only through the methods and properties of the <bpt id=\"p1\">**</bpt>_Array<ept id=\"p1\">**</ept> interface.","pos":[16928,17045],"source":" The contents of the managed array are accessible only through the methods and properties of the **_Array** interface."},{"content":"<bpt id=\"p1\">**</bpt>System.Array<ept id=\"p1\">**</ept> can also be marshaled as a <bpt id=\"p2\">**</bpt>SAFEARRAY<ept id=\"p2\">**</ept> by using the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph> attribute.","pos":[17046,17184],"source":"**System.Array** can also be marshaled as a **SAFEARRAY** by using the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute."},{"content":"When marshaled as a safe array, the array elements are marshaled as variants.","pos":[17185,17262]},{"content":"For example:","pos":[17263,17275]},{"pos":[17286,17303],"content":"Managed signature","linkify":"Managed signature","nodes":[{"content":"Managed signature","pos":[0,17]}]},{"pos":[17558,17577],"content":"Unmanaged signature","linkify":"Unmanaged signature","nodes":[{"content":"Unmanaged signature","pos":[0,19]}]},{"pos":[17678,17702],"content":"Arrays within Structures","linkify":"Arrays within Structures","nodes":[{"content":"Arrays within Structures","pos":[0,24]}]},{"content":"Unmanaged structures can contain embedded arrays.","pos":[17706,17755]},{"content":"By default, these embedded array fields are marshaled as a SAFEARRAY.","pos":[17756,17825]},{"content":"In the following example, <ph id=\"ph1\">`s1`</ph> is an embedded array that is allocated directly within the structure itself.","pos":[17826,17933],"source":" In the following example, `s1` is an embedded array that is allocated directly within the structure itself."},{"pos":[17944,17968],"content":"Unmanaged representation","linkify":"Unmanaged representation","nodes":[{"content":"Unmanaged representation","pos":[0,24]}]},{"content":"Arrays can be marshaled as <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.UnmanagedType&gt;</ph>, which requires you to set the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph> field.","pos":[18035,18208],"source":"Arrays can be marshaled as <xref:System.Runtime.InteropServices.UnmanagedType>, which requires you to set the <xref:System.Runtime.InteropServices.MarshalAsAttribute> field."},{"content":"The size can be set only as a constant.","pos":[18209,18248]},{"content":"The following code shows the corresponding managed definition of <ph id=\"ph1\">`MyStruct`</ph>.","pos":[18249,18325],"source":" The following code shows the corresponding managed definition of `MyStruct`."},{"pos":[18693,18701],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[18705,18766],"content":"<bpt id=\"p1\">[</bpt>Default Marshaling Behavior<ept id=\"p1\">](default-marshaling-behavior.md)</ept>","source":"[Default Marshaling Behavior](default-marshaling-behavior.md)"},{"pos":[18769,18842],"content":"<bpt id=\"p1\">[</bpt>Blittable and Non-Blittable Types<ept id=\"p1\">](blittable-and-non-blittable-types.md)</ept>","source":"[Blittable and Non-Blittable Types](blittable-and-non-blittable-types.md)"},{"pos":[18845,18958],"content":"<bpt id=\"p1\">[</bpt>Directional Attributes<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</ept>","source":"[Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))"},{"pos":[18961,19006],"content":"<bpt id=\"p1\">[</bpt>Copying and Pinning<ept id=\"p1\">](copying-and-pinning.md)</ept>","source":"[Copying and Pinning](copying-and-pinning.md)"}]}