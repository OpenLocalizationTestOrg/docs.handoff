{"content":"---\ntitle: \"Type Relationships in LINQ Query Operations (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"inferring type information [LINQ in C#]\"\n  - \"data sources [LINQ in C#], type relationships\"\n  - \"queries [LINQ in C#], type relationships\"\n  - \"relationships [LINQ in C#]\"\n  - \"type relationships [LINQ in C#]\"\n  - \"variable relationships [LINQ in C#]\"\n  - \"type information inferred [LINQ in C#]\"\n  - \"data transformations [LINQ in C#]\"\n  - \"LINQ [C#], type relationships\"\nms.assetid: 99118938-d47c-4d7e-bb22-2657a9f95268\ncaps.latest.revision: 25\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Type Relationships in LINQ Query Operations (C#)\nTo write queries effectively, you should understand how types of the variables in a complete query operation all relate to each other. If you understand these relationships you will more easily comprehend the [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] samples and code examples in the documentation. Furthermore, you will understand what occurs behind the scenes when variables are implicitly typed by using `var`.  \n  \n [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] query operations are strongly typed in the data source, in the query itself, and in the query execution. The type of the variables in the query must be compatible with the type of the elements in the data source and with the type of the iteration variable in the `foreach` statement. This strong typing guarantees that type errors are caught at compile time when they can be corrected before users encounter them.  \n  \n In order to demonstrate these type relationships, most of the examples that follow use explicit typing for all variables. The last example shows how the same principles apply even when you use implicit typing by using [var](../../../../csharp/language-reference/keywords/var.md).  \n  \n## Queries that do not Transform the Source Data  \n The following illustration shows a [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] to Objects query operation that performs no transformations on the data. The source contains a sequence of strings and the query output is also a sequence of strings.  \n  \n ![Relation of data types in a LINQ query](../../../../csharp/programming-guide/concepts/linq/media/linq_flow1.png \"LINQ_flow1\")  \n  \n1.  The type argument of the data source determines the type of the range variable.  \n  \n2.  The type of the object that is selected determines the type of the query variable. Here `name` is a string. Therefore, the query variable is an `IEnumerable`\\<string>.  \n  \n3.  The query variable is iterated over in the `foreach` statement. Because the query variable is a sequence of strings, the iteration variable is also a string.  \n  \n## Queries that Transform the Source Data  \n The following illustration shows a [!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)] query operation that performs a simple transformation on the data. The query takes a sequence of `Customer` objects as input, and selects only the `Name` property in the result. Because `Name` is a string, the query produces a sequence of strings as output.  \n  \n ![A query that transforms the data type](../../../../csharp/programming-guide/concepts/linq/media/linq_flow2.png \"LINQ_flow2\")  \n  \n1.  The type argument of the data source determines the type of the range variable.  \n  \n2.  The `select` statement returns the `Name` property instead of the complete `Customer` object. Because `Name` is a string, the type argument of `custNameQuery` is `string`, not `Customer`.  \n  \n3.  Because `custNameQuery` is a sequence of strings, the `foreach` loop's iteration variable must also be a `string`.  \n  \n The following illustration shows a slightly more complex transformation. The `select` statement returns an anonymous type that captures just two members of the original `Customer` object.  \n  \n ![A query that transforms the data type](../../../../csharp/programming-guide/concepts/linq/media/linq_flow3.png \"LINQ_flow3\")  \n  \n1.  The type argument of the data source is always the type of the range variable in the query.  \n  \n2.  Because the `select` statement produces an anonymous type, the query variable must be implicitly typed by using `var`.  \n  \n3.  Because the type of the query variable is implicit, the iteration variable in the `foreach` loop must also be implicit.  \n  \n## Letting the compiler infer type information  \n Although you should understand the type relationships in a query operation, you have the option to let the compiler do all the work for you. The keyword [var](../../../../csharp/language-reference/keywords/var.md) can be used for any local variable in a query operation. The following illustration is similar to example number 2 that was discussed earlier. However, the compiler supplies the strong type for each variable in the query operation.  \n  \n ![Type flow with implicit typing](../../../../csharp/programming-guide/concepts/linq/media/linq_flow4.png \"LINQ_flow4\")  \n  \n For more information about `var`, see [Implicitly Typed Local Variables](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).  \n  \n## See Also  \n [Getting Started with LINQ in C#](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)","nodes":[{"pos":[4,965],"embed":true,"restype":"x-metadata","content":"title: \"Type Relationships in LINQ Query Operations (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"inferring type information [LINQ in C#]\"\n  - \"data sources [LINQ in C#], type relationships\"\n  - \"queries [LINQ in C#], type relationships\"\n  - \"relationships [LINQ in C#]\"\n  - \"type relationships [LINQ in C#]\"\n  - \"variable relationships [LINQ in C#]\"\n  - \"type information inferred [LINQ in C#]\"\n  - \"data transformations [LINQ in C#]\"\n  - \"LINQ [C#], type relationships\"\nms.assetid: 99118938-d47c-4d7e-bb22-2657a9f95268\ncaps.latest.revision: 25\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","nodes":[{"content":"Type Relationships in LINQ Query Operations (C#) | Microsoft Docs","nodes":[{"pos":[0,65],"content":"Type Relationships in LINQ Query Operations (C#) | Microsoft Docs","nodes":[{"content":"Type Relationships in LINQ Query Operations (C#) | Microsoft Docs","pos":[0,65]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[972,1020],"content":"Type Relationships in LINQ Query Operations (C#)","linkify":"Type Relationships in LINQ Query Operations (C#)","nodes":[{"content":"Type Relationships in LINQ Query Operations (C#)","pos":[0,48]}]},{"content":"To write queries effectively, you should understand how types of the variables in a complete query operation all relate to each other.","pos":[1021,1155]},{"content":"If you understand these relationships you will more easily comprehend the <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> samples and code examples in the documentation.","pos":[1156,1344],"source":" If you understand these relationships you will more easily comprehend the [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] samples and code examples in the documentation."},{"content":"Furthermore, you will understand what occurs behind the scenes when variables are implicitly typed by using <ph id=\"ph1\">`var`</ph>.","pos":[1345,1459],"source":" Furthermore, you will understand what occurs behind the scenes when variables are implicitly typed by using `var`."},{"content":"query operations are strongly typed in the data source, in the query itself, and in the query execution.","pos":[1533,1637]},{"content":"The type of the variables in the query must be compatible with the type of the elements in the data source and with the type of the iteration variable in the <ph id=\"ph1\">`foreach`</ph> statement.","pos":[1638,1816],"source":" The type of the variables in the query must be compatible with the type of the elements in the data source and with the type of the iteration variable in the `foreach` statement."},{"content":"This strong typing guarantees that type errors are caught at compile time when they can be corrected before users encounter them.","pos":[1817,1946]},{"content":"In order to demonstrate these type relationships, most of the examples that follow use explicit typing for all variables.","pos":[1953,2074]},{"content":"The last example shows how the same principles apply even when you use implicit typing by using <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](../../../../csharp/language-reference/keywords/var.md)</ept>.","pos":[2075,2232],"source":" The last example shows how the same principles apply even when you use implicit typing by using [var](../../../../csharp/language-reference/keywords/var.md)."},{"pos":[2241,2286],"content":"Queries that do not Transform the Source Data","linkify":"Queries that do not Transform the Source Data","nodes":[{"content":"Queries that do not Transform the Source Data","pos":[0,45]}]},{"content":"The following illustration shows a <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> to Objects query operation that performs no transformations on the data.","pos":[2290,2464],"source":"The following illustration shows a [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] to Objects query operation that performs no transformations on the data."},{"content":"The source contains a sequence of strings and the query output is also a sequence of strings.","pos":[2465,2558]},{"pos":[2565,2692],"content":"<bpt id=\"p1\">![</bpt>Relation of data types in a LINQ query<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../csharp/programming-guide/concepts/linq/media/linq_flow1.png \"</bpt>LINQ_flow1<ept id=\"p2\">\")</ept>","source":"![Relation of data types in a LINQ query](../../../../csharp/programming-guide/concepts/linq/media/linq_flow1.png \"LINQ_flow1\")"},{"content":"The type argument of the data source determines the type of the range variable.","pos":[2702,2781]},{"content":"The type of the object that is selected determines the type of the query variable.","pos":[2791,2873]},{"content":"Here <ph id=\"ph1\">`name`</ph> is a string.","pos":[2874,2898],"source":" Here `name` is a string."},{"content":"Therefore, the query variable is an <ph id=\"ph1\">`IEnumerable`</ph><ph id=\"ph2\">\\&lt;</ph>string&gt;.","pos":[2899,2958],"source":" Therefore, the query variable is an `IEnumerable`\\<string>."},{"content":"The query variable is iterated over in the <ph id=\"ph1\">`foreach`</ph> statement.","pos":[2968,3031],"source":"The query variable is iterated over in the `foreach` statement."},{"content":"Because the query variable is a sequence of strings, the iteration variable is also a string.","pos":[3032,3125]},{"pos":[3134,3172],"content":"Queries that Transform the Source Data","linkify":"Queries that Transform the Source Data","nodes":[{"content":"Queries that Transform the Source Data","pos":[0,38]}]},{"content":"The following illustration shows a <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)]</ph> query operation that performs a simple transformation on the data.","pos":[3176,3346],"source":"The following illustration shows a [!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)] query operation that performs a simple transformation on the data."},{"content":"The query takes a sequence of <ph id=\"ph1\">`Customer`</ph> objects as input, and selects only the <ph id=\"ph2\">`Name`</ph> property in the result.","pos":[3347,3457],"source":" The query takes a sequence of `Customer` objects as input, and selects only the `Name` property in the result."},{"content":"Because <ph id=\"ph1\">`Name`</ph> is a string, the query produces a sequence of strings as output.","pos":[3458,3537],"source":" Because `Name` is a string, the query produces a sequence of strings as output."},{"pos":[3544,3670],"content":"<bpt id=\"p1\">![</bpt>A query that transforms the data type<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../csharp/programming-guide/concepts/linq/media/linq_flow2.png \"</bpt>LINQ_flow2<ept id=\"p2\">\")</ept>","source":"![A query that transforms the data type](../../../../csharp/programming-guide/concepts/linq/media/linq_flow2.png \"LINQ_flow2\")"},{"content":"The type argument of the data source determines the type of the range variable.","pos":[3680,3759]},{"content":"The <ph id=\"ph1\">`select`</ph> statement returns the <ph id=\"ph2\">`Name`</ph> property instead of the complete <ph id=\"ph3\">`Customer`</ph> object.","pos":[3769,3862],"source":"The `select` statement returns the `Name` property instead of the complete `Customer` object."},{"content":"Because <ph id=\"ph1\">`Name`</ph> is a string, the type argument of <ph id=\"ph2\">`custNameQuery`</ph> is <ph id=\"ph3\">`string`</ph>, not <ph id=\"ph4\">`Customer`</ph>.","pos":[3863,3956],"source":" Because `Name` is a string, the type argument of `custNameQuery` is `string`, not `Customer`."},{"pos":[3966,4080],"content":"Because <ph id=\"ph1\">`custNameQuery`</ph> is a sequence of strings, the <ph id=\"ph2\">`foreach`</ph> loop's iteration variable must also be a <ph id=\"ph3\">`string`</ph>.","source":"Because `custNameQuery` is a sequence of strings, the `foreach` loop's iteration variable must also be a `string`."},{"content":"The following illustration shows a slightly more complex transformation.","pos":[4087,4159]},{"content":"The <ph id=\"ph1\">`select`</ph> statement returns an anonymous type that captures just two members of the original <ph id=\"ph2\">`Customer`</ph> object.","pos":[4160,4274],"source":" The `select` statement returns an anonymous type that captures just two members of the original `Customer` object."},{"pos":[4281,4407],"content":"<bpt id=\"p1\">![</bpt>A query that transforms the data type<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../csharp/programming-guide/concepts/linq/media/linq_flow3.png \"</bpt>LINQ_flow3<ept id=\"p2\">\")</ept>","source":"![A query that transforms the data type](../../../../csharp/programming-guide/concepts/linq/media/linq_flow3.png \"LINQ_flow3\")"},{"content":"The type argument of the data source is always the type of the range variable in the query.","pos":[4417,4508]},{"pos":[4518,4636],"content":"Because the <ph id=\"ph1\">`select`</ph> statement produces an anonymous type, the query variable must be implicitly typed by using <ph id=\"ph2\">`var`</ph>.","source":"Because the `select` statement produces an anonymous type, the query variable must be implicitly typed by using `var`."},{"pos":[4646,4765],"content":"Because the type of the query variable is implicit, the iteration variable in the <ph id=\"ph1\">`foreach`</ph> loop must also be implicit.","source":"Because the type of the query variable is implicit, the iteration variable in the `foreach` loop must also be implicit."},{"pos":[4774,4817],"content":"Letting the compiler infer type information","linkify":"Letting the compiler infer type information","nodes":[{"content":"Letting the compiler infer type information","pos":[0,43]}]},{"content":"Although you should understand the type relationships in a query operation, you have the option to let the compiler do all the work for you.","pos":[4821,4961]},{"content":"The keyword <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](../../../../csharp/language-reference/keywords/var.md)</ept> can be used for any local variable in a query operation.","pos":[4962,5091],"source":" The keyword [var](../../../../csharp/language-reference/keywords/var.md) can be used for any local variable in a query operation."},{"content":"The following illustration is similar to example number 2 that was discussed earlier.","pos":[5092,5177]},{"content":"However, the compiler supplies the strong type for each variable in the query operation.","pos":[5178,5266]},{"pos":[5273,5392],"content":"<bpt id=\"p1\">![</bpt>Type flow with implicit typing<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../csharp/programming-guide/concepts/linq/media/linq_flow4.png \"</bpt>LINQ_flow4<ept id=\"p2\">\")</ept>","source":"![Type flow with implicit typing](../../../../csharp/programming-guide/concepts/linq/media/linq_flow4.png \"LINQ_flow4\")"},{"pos":[5399,5566],"content":"For more information about <ph id=\"ph1\">`var`</ph>, see <bpt id=\"p1\">[</bpt>Implicitly Typed Local Variables<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)</ept>.","source":"For more information about `var`, see [Implicitly Typed Local Variables](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)."},{"pos":[5575,5583],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[5587,5701],"content":"<bpt id=\"p1\">[</bpt>Getting Started with LINQ in C#<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)</ept>","source":"[Getting Started with LINQ in C#](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)"}]}