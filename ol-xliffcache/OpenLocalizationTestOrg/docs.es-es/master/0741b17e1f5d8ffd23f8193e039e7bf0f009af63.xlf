<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0741b17e1f5d8ffd23f8193e039e7bf0f009af63</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\security\cryptographic-services.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3de0d36b2774dd98b81c3541b6a05ad32e0499f6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f61fbccbf9ac82089bb145c85c91be80b1ba8abd</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Cryptographic Services | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Cryptographic Services</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Public networks such as the Internet do not provide a means of secure communication between entities.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Communication over such networks is susceptible to being read or even modified by unauthorized third parties.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If a third party intercepts the encrypted data, it will be difficult to decipher.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In the .NET Framework, the classes in the <ph id="ph1">&lt;xref:System.Security.Cryptography?displayProperty=fullName&gt;</ph> namespace manage many details of cryptography for you.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Some are wrappers for the unmanaged Microsoft Cryptography API (CryptoAPI), while others are purely managed implementations.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You do not need to be an expert in cryptography to use these classes.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This overview provides a synopsis of the encryption methods and practices supported by the .NET Framework, including the ClickOnce manifests, Suite B, and Cryptography Next Generation (CNG) support introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This overview contains the following sections:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Cryptographic Primitives<ept id="p1">](#primitives)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Secret-Key Encryption<ept id="p1">](#secret_key)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Public-Key Encryption<ept id="p1">](#public_key)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Digital Signatures<ept id="p1">](#digital_signatures)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Hash Values<ept id="p1">](#hash_values)</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Random Number Generation<ept id="p1">](#random_numbers)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ClickOnce Manifests<ept id="p1">](#clickonce)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Suite B Support<ept id="p1">](#suite_b)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Related Topics<ept id="p1">](#related_topics)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For additional information about cryptography and about Microsoft services, components, and tools that enable you to add cryptographic security to your applications, see the Win32 and COM Development, Security section of this documentation.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Cryptographic Primitives</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Cryptography is used to achieve the following goals:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Confidentiality: To help protect a user's identity or data from being read.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Data integrity: To help protect data from being changed.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Authentication: To ensure that data originates from a particular party.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Non-repudiation: To prevent a particular party from denying that they sent a message.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>To achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following table lists the cryptographic primitives and their uses.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Cryptographic primitive</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Use</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Secret-key encryption (symmetric cryptography)</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Performs a transformation on data to keep it from being read by third parties.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This type of encryption uses a single shared, secret key to encrypt and decrypt data.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Public-key encryption (asymmetric cryptography)</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Performs a transformation on data to keep it from being read by third parties.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This type of encryption uses a public/private key pair to encrypt and decrypt data.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Cryptographic signing</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Helps verify that data originates from a specific party by creating a digital signature that is unique to that party.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This process also uses hash functions.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Cryptographic hashes</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Maps data from any length to a fixed-length byte sequence.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Hashes are statistically unique; a different two-byte sequence will not hash to the same value.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Secret-Key Encryption</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Secret-key encryption algorithms use a single secret key to encrypt and decrypt data.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Secret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Symmetric encryption algorithms do not generally have those problems.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> bytes into an output block of encrypted bytes.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> have to be encrypted one block at a time.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Data values that are smaller than <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> have to be expanded to <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> in order to be processed.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>One simple form of block cipher is called the electronic codebook (ECB) mode.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For a given secret key <bpt id="p1">*</bpt>k<ept id="p1">*</ept>, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>CBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Each subsequent block of plaintext undergoes a bitwise exclusive OR (<ph id="ph1">`XOR`</ph>) operation with the previous ciphertext block before it is encrypted.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Each ciphertext block is therefore dependent on all previous blocks.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>One way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Larger key sizes are more difficult to decipher.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The IV is not considered a secret and can be transmitted in plaintext with the message.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>However, the key must be kept secret from unauthorized users.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Assuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Alice composes a message and creates a network stream (perhaps a named pipe or network e-mail) on which to send the message.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If the transmission is intercepted, the interceptor cannot recover the original message, because he does not know the key.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>In this scenario, only the key must remain secret.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information about public-key encryption, see the next section.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement secret-key encryption algorithms:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.AesManaged&gt;</ph> (introduced in the <ph id="ph2">[!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]</ph>).</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.DESCryptoServiceProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph> (This is technically a secret-key algorithm because it represents message authentication code that is calculated by using a cryptographic hash function combined with a secret key.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Hash Values<ept id="p1">](#hash_values)</ept>, later in this topic.)</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.RC2CryptoServiceProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.RijndaelManaged&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.TripleDESCryptoServiceProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Public-Key Encryption</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Public-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>However, in practice, asymmetric keys are generally long-lived.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Two parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If Bob wants to send Alice an encrypted message, he asks her for her public key.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Bob sends the encrypted message to Alice, and she decrypts it by using her private key.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Therefore, Bob must verify with Alice that he has a correct copy of her public key.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>During the transmission of Alice's public key, an unauthorized agent might intercept the key.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Furthermore, the same agent might intercept the encrypted message from Bob.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>However, the agent cannot decrypt the message with the public key.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The message can be decrypted only with Alice's private key, which has not been transmitted.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Bob then decrypts the message using his associated private key.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>In this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The following list offers comparisons between public-key and secret-key cryptographic algorithms:</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Therefore, asymmetric operations do not use the same streaming model as symmetric operations.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Public-key algorithms are useful only for transferring very small amounts of data.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>After the key and IV are transferred, secret-key encryption is used for the remainder of the session.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement public-key encryption algorithms:</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman&gt;</ph> (base class)</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey&gt;</ph> (base class)</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction&gt;</ph> (base class)</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>RSA allows both encryption and signing, but DSA can be used only for signing, and Diffie-Hellman can be used only for key generation.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>In general, public-key algorithms are more limited in their uses than private-key algorithms.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Digital Signatures</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Public-key algorithms can also be used to form digital signatures.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>To use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The message digest is a compact and unique representation of data.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Alice then encrypts the message digest with her private key to create her personal signature.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement digital signature algorithms:</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.ECDsa&gt;</ph> (base class)</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Hash Values</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Hash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>A hash value is a numerical representation of a piece of data.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If the hash is cryptographically strong, its value will change significantly.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Many input values may hash to the same output value.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>However, it is computationally infeasible to find two distinct inputs that hash to the same value.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Two parties (Alice and Bob) could use a hash function to ensure message integrity.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>They would select a hash algorithm to sign their messages.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Alice would write a message, and then create a hash of that message by using the selected algorithm.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>They would then follow one of the following methods:</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Alice sends the plaintext message and the hashed message (digital signature) to Bob.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>If the hash values are identical, the message was not altered.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>If the values are not identical, the message was altered after Alice wrote it.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Unfortunately, this method does not establish the authenticity of the sender.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Anyone can impersonate Alice and send a message to Bob.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This is one form of a man-in-the-middle attack.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>NIB: Cryptography Next Generation (CNG) Secure Communication Example<ept id="p1">](http://msdn.microsoft.com/en-us/8048e94e-054a-417b-87c6-4f5e26710e6e)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Alice sends the plaintext message to Bob over a nonsecure public channel.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>She sends the hashed message to Bob over a secure private channel.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>If the hashes match, Bob knows two things:</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The message was not altered.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The sender of the message (Alice) is authentic.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>For this system to work, Alice must hide her original hash value from all parties except Bob.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>This method prevents message tampering by preventing anyone from modifying the hash value.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Although the message and its hash can be read by anyone, the hash value can be changed only by Alice.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An attacker who wants to impersonate Alice would require access to Alice's Web site.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>None of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Full security typically requires digital signatures (message signing) and encryption.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement hashing algorithms:</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.MACTripleDES&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.MD5CryptoServiceProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.RIPEMD160&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1Managed&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.SHA256Managed&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.SHA384Managed&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.SHA512Managed&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>HMAC variants of all of the Secure Hash Algorithm (SHA), Message Digest 5 (MD5), and RIPEMD-160 algorithms.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>CryptoServiceProvider implementations (managed code wrappers) of all the SHA algorithms.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Cryptography Next Generation (CNG) implementations of all the MD5 and SHA algorithms.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>MD5 design flaws were discovered in 1996, and SHA-1 was recommended instead.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>In 2004, additional flaws were discovered, and the MD5 algorithm is no longer considered secure.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The SHA-1 algorithm has also been found to be insecure, and SHA-2 is now recommended instead.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Random Number Generation</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Random number generation is integral to many cryptographic operations.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Therefore, any method of predicting the next output bit must not perform better than random guessing.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The classes in the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> use random number generators to generate cryptographic keys.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class is an implementation of a random number generator algorithm.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>ClickOnce Manifests</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)]</ph>, the following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using <bpt id="p1">[</bpt>ClickOnce technology<ept id="p1">](/visualstudio/deployment/clickonce-security-and-deployment)</ept>:</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.ManifestSignatureInformation&gt;</ph> class obtains information about a manifest signature when you use its <ph id="ph2">&lt;xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Security.ManifestKinds&gt;</ph> enumeration to specify which manifests to verify.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The result of the verification is one of the <ph id="ph1">&lt;xref:System.Security.Cryptography.SignatureVerificationResult&gt;</ph> enumeration values.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.ManifestSignatureInformationCollection&gt;</ph> class provides a read-only collection of <ph id="ph2">&lt;xref:System.Security.Cryptography.ManifestSignatureInformation&gt;</ph> objects of the verified signatures.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>In addition, the following classes provide specific signature information:</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.StrongNameSignatureInformation&gt;</ph> holds the strong name signature information for a manifest.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation&gt;</ph> represents the Authenticode signature information for a manifest.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.X509Certificates.TimestampInformation&gt;</ph> contains information about the time stamp on an Authenticode signature.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.X509Certificates.TrustStatus&gt;</ph> provides a simple way to check whether an Authenticode signature is trusted.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Suite B Support</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)]</ph> supports the Suite B set of cryptographic algorithms published by the National Security Agency (NSA).</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>For more information about Suite B, see the <bpt id="p1">[</bpt>NSA Suite B Cryptography Fact Sheet<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=100111)</ept>.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following algorithms are included:</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Advanced Encryption Standard (AES) algorithm with key sizes of 128, 192, , and 256 bits for encryption.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Secure Hash Algorithms SHA-1, SHA-256, SHA-384, and SHA-512 for hashing.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>(The last three are generally grouped together and referred to as SHA-2.)</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Elliptic Curve Digital Signature Algorithm (ECDSA), using curves of 256-bit, 384-bit, and 521-bit prime moduli for signing.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The NSA documentation specifically defines these curves, and calls them P-256, P-384, and P-521.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>This algorithm is provided by the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDsaCng&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>It enables you to sign with a private key and verify the signature with a public key.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Elliptic Curve Diffie-Hellman (ECDH) algorithm, using curves of 256-bit, 384-bit, and 521-bit prime moduli for the key exchange and secret agreement.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This algorithm is provided by the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCng&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Managed code wrappers for the Federal Information Processing Standard (FIPS) certified implementations of the AES, SHA-256, SHA-384, and SHA-512 implementations are available in the new <ph id="ph1">&lt;xref:System.Security.Cryptography.AesCryptoServiceProvider&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.Cryptography.SHA256CryptoServiceProvider&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.Cryptography.SHA384CryptoServiceProvider&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.Cryptography.SHA512CryptoServiceProvider&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Cryptography Next Generation (CNG) Classes</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>(CNG is the replacement for CryptoAPI.) These classes have "Cng" as part of their names.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Central to the CNG wrapper classes is the <ph id="ph1">&lt;xref:System.Security.Cryptography.CngKey&gt;</ph> key container class, which abstracts the storage and use of CNG keys.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>This class lets you store a key pair or a public key securely and refer to it by using a simple string name.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The elliptic curve-based <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDsaCng&gt;</ph> signature class and the <ph id="ph2">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCng&gt;</ph> encryption class can use <ph id="ph3">&lt;xref:System.Security.Cryptography.CngKey&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.CngKey&gt;</ph> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>It also provides access to the underlying key handle to use when calling native functions directly.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)]</ph> also includes a variety of supporting CNG classes, such as the following:</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.CngProvider&gt;</ph> maintains a key storage provider.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.CngAlgorithm&gt;</ph> maintains a CNG algorithm.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.CngProperty&gt;</ph> maintains frequently used key properties.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Title</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Cryptography Model<ept id="p1">](../../../docs/standard/security/cryptography-model.md)</ept></source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Describes how cryptography is implemented in the base class library.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Walkthrough: Creating a Cryptographic Application<ept id="p1">](../../../docs/standard/security/walkthrough-creating-a-cryptographic-application.md)</ept></source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Demonstrates basic encryption and decryption tasks.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Configuring Cryptography Classes<ept id="p1">](../../../docs/framework/configure-apps/configure-cryptography-classes.md)</ept></source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Describes how to map algorithm names to cryptographic classes and map object identifiers to a cryptographic algorithm.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>