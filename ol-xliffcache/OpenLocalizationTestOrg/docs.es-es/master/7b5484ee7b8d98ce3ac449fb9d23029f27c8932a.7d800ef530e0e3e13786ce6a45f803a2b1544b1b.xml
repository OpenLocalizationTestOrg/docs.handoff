{"content":"---\ntitle: \"KnownAssemblyAttribute\"\nms.date: \"03/30/2017\"\nms.assetid: b3bc7f31-95ff-46e1-8308-d206ec426f6e\n---\n# KnownAssemblyAttribute\nThis sample demonstrates how the serialization and deserialization processes can be customized by using the <xref:System.Runtime.Serialization.DataContractResolver> class. This sample shows how to dynamically add known types during serialization and deserialization.  \n  \n## Sample Details  \n This sample is composed of four projects. One of them corresponds to the service, to be hosted by IIS, which defines the following service contract.  \n  \n```csharp\n// Definition of a service contract.  \n[ServiceContract(Namespace = \"http://Microsoft.Samples.KAA\")]  \n[KnownAssembly(\"Types\")]  \npublic interface IDataContractCalculator  \n {  \n    [OperationContract]  \n    ComplexNumber Add(ComplexNumber n1, ComplexNumber n2);  \n  \n    [OperationContract]  \n    ComplexNumber Subtract(ComplexNumber n1, ComplexNumber n2);  \n  \n    [OperationContract]  \n    ComplexNumber Multiply(ComplexNumber n1, ComplexNumber n2);  \n  \n    [OperationContract]  \n    ComplexNumber Divide(ComplexNumber n1, ComplexNumber n2);  \n  \n    [OperationContract]  \n    List<ComplexNumber> CombineLists(List<ComplexNumber> list1, List<ComplexNumber> list2);  \n}  \n```  \n  \n The service contract is implemented as shown in the following example.  \n  \n```csharp\n// Service class that implements the service contract.  \n public class DataContractCalculatorService : IDataContractCalculator  \n {  \n    public ComplexNumber Add(ComplexNumber n1, ComplexNumber n2)  \n    {  \n        return new ComplexNumberWithMagnitude(n1.Real + n2.Real, n1.Imaginary + n2.Imaginary);  \n    }  \n  \n    public ComplexNumber Subtract(ComplexNumber n1, ComplexNumber n2)  \n    {  \n        return new ComplexNumberWithMagnitude(n1.Real - n2.Real, n1.Imaginary - n2.Imaginary);  \n    }  \n  \n    public ComplexNumber Multiply(ComplexNumber n1, ComplexNumber n2)  \n    {  \n        double real1 = n1.Real * n2.Real;  \n        double imaginary1 = n1.Real * n2.Imaginary;  \n        double imaginary2 = n2.Real * n1.Imaginary;  \n        double real2 = n1.Imaginary * n2.Imaginary * -1;  \n  \n        return new ComplexNumber(real1 + real2, imaginary1 + imaginary2);  \n    }  \n  \n    public ComplexNumber Divide(ComplexNumber n1, ComplexNumber n2)  \n    {  \n        ComplexNumber conjugate = new ComplexNumber(n2.Real, -1 * n2.Imaginary);  \n        ComplexNumber numerator = Multiply(n1, conjugate);  \n        ComplexNumber denominator = Multiply(n2, conjugate);  \n  \n        return new ComplexNumber(numerator.Real / denominator.Real, numerator.Imaginary);  \n    }  \n  \n    public List<ComplexNumber> CombineLists(List<ComplexNumber> list1, List<ComplexNumber> list2)  \n    {  \n        List<ComplexNumber> result  = new List<ComplexNumber>();  \n        result.AddRange(list1);  \n        result.AddRange(list2);  \n  \n        return result;  \n    }  \n}  \n```  \n  \n Another project corresponds to the client, which communicates with the server and invokes the methods that it exposes. The definition of the client is shown in the following example.  \n  \n```csharp  \n // Client implementation code.  \n class Client  \n {  \n    static void Main()  \n    {  \n        // Create a channel.  \n         EndpointAddress address = new EndpointAddress(\"http://localhost/servicemodelsamples/service.svc/IDataContractCalculator\");  \n        BasicHttpBinding binding = new BasicHttpBinding();  \n        ChannelFactory<IDataContractCalculator> factory = new ChannelFactory<IDataContractCalculator>(binding, address);  \n        IDataContractCalculator channel = factory.CreateChannel();  \n  \n        // Call the Add service operation.  \n         ComplexNumber value1 = new ComplexNumber(1, 2);  \n        ComplexNumber value2 = new ComplexNumberWithMagnitude(3, 4);  \n        ComplexNumber result = channel.Add(value1, value2);  \n        Console.WriteLine(\"Add({0} + {1}i, {2} + {3}i) = {4} + {5}i\",  \n            value1.Real, value1.Imaginary, value2.Real, value2.Imaginary, result.Real, result.Imaginary);  \n        if (result is ComplexNumberWithMagnitude)  \n        {  \n            Console.WriteLine(\"Magnitude: {0}\", ((ComplexNumberWithMagnitude)result).Magnitude);  \n        }  \n        else  \n         {  \n            Console.WriteLine(\"No magnitude was sent from the service\");  \n        }  \n        Console.WriteLine();  \n  \n        // Call the Subtract service operation.  \n         value1 = new ComplexNumber(1, 2);  \n        value2 = new ComplexNumber(3, 4);  \n        result = channel.Subtract(value1, value2);  \n        Console.WriteLine(\"Subtract({0} + {1}i, {2} + {3}i) = {4} + {5}i\",  \n            value1.Real, value1.Imaginary, value2.Real, value2.Imaginary, result.Real, result.Imaginary);  \n        if (result is ComplexNumberWithMagnitude)  \n        {  \n            Console.WriteLine(\"Magnitude: {0}\", ((ComplexNumberWithMagnitude)result).Magnitude);  \n        }  \n        else  \n         {  \n            Console.WriteLine(\"No magnitude was sent from the service\");  \n        }  \n        Console.WriteLine();  \n  \n        // Call the Multiply service operation.  \n         value1 = new ComplexNumber(2, 3);  \n        value2 = new ComplexNumber(4, 7);  \n        result = channel.Multiply(value1, value2);  \n        Console.WriteLine(\"Multiply({0} + {1}i, {2} + {3}i) = {4} + {5}i\",  \n            value1.Real, value1.Imaginary, value2.Real, value2.Imaginary, result.Real, result.Imaginary);  \n        if (result is ComplexNumberWithMagnitude)  \n        {  \n            Console.WriteLine(\"Magnitude: {0}\", ((ComplexNumberWithMagnitude)result).Magnitude);  \n        }  \n        else  \n         {  \n            Console.WriteLine(\"No magnitude was sent from the service\");  \n        }  \n        Console.WriteLine();  \n  \n        // Call the Divide service operation.  \n         value1 = new ComplexNumber(3, 7);  \n        value2 = new ComplexNumber(5, -2);  \n        result = channel.Divide(value1, value2);  \n        Console.WriteLine(\"Divide({0} + {1}i, {2} + {3}i) = {4} + {5}i\",  \n            value1.Real, value1.Imaginary, value2.Real, value2.Imaginary, result.Real, result.Imaginary);  \n        if (result is ComplexNumberWithMagnitude)  \n        {  \n            Console.WriteLine(\"Magnitude: {0}\", ((ComplexNumberWithMagnitude)result).Magnitude);  \n        }  \n        else  \n         {  \n            Console.WriteLine(\"No magnitude was sent from the service\");  \n        }  \n        Console.WriteLine();  \n  \n        // Call the CombineLists service operation.  \n         List<ComplexNumber> list1 = new List<ComplexNumber>();  \n        List<ComplexNumber> list2 = new List<ComplexNumber>();  \n        list1.Add(new ComplexNumber(1, 1));  \n        list1.Add(new ComplexNumber(2, 2));  \n        list1.Add(new ComplexNumberWithMagnitude(3, 3));  \n        list1.Add(new ComplexNumberWithMagnitude(4, 4));  \n        List<ComplexNumber> listResult = channel.CombineLists(list1, list2);  \n        Console.WriteLine(\"Lists combined:\");  \n        foreach (ComplexNumber n in listResult)  \n        {  \n            Console.WriteLine(\"{0} + {1}i\", n.Real, n.Imaginary);  \n        }  \n        Console.WriteLine();  \n  \n        // Close the channel  \n         ((IChannel)channel).Close();  \n  \n        Console.WriteLine();  \n        Console.WriteLine(\"Press <ENTER> to terminate client.\");  \n        Console.ReadLine();  \n    }  \n}  \n```  \n  \n The definition of the service contract is marked with the `KnownAssembly` attribute. This attribute contains the name of a library of types, which all become known at runtime by both the service and the client.  \n  \n The `KnownAssembly` attribute implements `IContractBehavior` in order to define a `DataContractSerializer` with a `DataContractResolver` defined for each of the operation behaviors. The `DataContractResolver` reflects over the assembly when it is created, and creates the dictionary with the mapping between types and names to be used when serializing and deserializing the different types. In that way, the `ResolveType` and `ResolveName` types must look up the data required in the dictionary.  \n  \n The `DataContractResolver` defined for this sample is shown in the following example.  \n  \n```csharp\npublic class MyDataContractResolver : DataContractResolver  \n    {  \n       Dictionary<string, XmlDictionaryString> dictionary = new Dictionary<string, XmlDictionaryString>();  \n       Assembly assembly;  \n  \n       public MyDataContractResolver(string assemblyName)  \n       {  \n           this.KnownTypes = new List<Type>();  \n  \n           assembly = Assembly.Load(new AssemblyName(assemblyName));  \n           foreach (Type type in assembly.GetTypes())  \n           {  \n               bool knownTypeFound = false;  \n               System.Attribute[] attrs = System.Attribute.GetCustomAttributes(type);  \n               if (attrs.Length != 0)  \n               {  \n                   foreach (System.Attribute attr in attrs)  \n                   {  \n                       if (attr is KnownTypeAttribute)  \n                       {  \n                           Type t = ((KnownTypeAttribute)attr).Type;  \n                           if (this.KnownTypes.IndexOf(t) < 0)  \n                           {  \n                               this.KnownTypes.Add(t);  \n                           }  \n                           knownTypeFound = true;  \n                       }  \n                   }  \n               }  \n               if (!knownTypeFound)  \n               {  \n                   string name = type.Name;  \n                   string namesp = type.Namespace;  \n                   if (!dictionary.ContainsKey(name))  \n                   {  \n                       dictionary.Add(name, new XmlDictionaryString(XmlDictionary.Empty, name, 0));  \n                   }  \n                   if (!dictionary.ContainsKey(namesp))  \n                   {  \n                       dictionary.Add(namesp, new XmlDictionaryString(XmlDictionary.Empty, namesp, 0));  \n                   }  \n               }  \n           }  \n       }  \n  \n       public IList<Type> KnownTypes  \n       {  \n           get; set;  \n       }  \n  \n       // Used at deserialization  \n        // Allows users to map xsi:type name to any Type   \n        public override Type ResolveName(string typeName, string typeNamespace, DataContractResolver knownTypeResolver)  \n       {  \n           XmlDictionaryString tName;  \n           XmlDictionaryString tNamespace;  \n  \n           if (dictionary.TryGetValue(typeName, out tName) && dictionary.TryGetValue(typeNamespace, out tNamespace))  \n           {  \n               return this.assembly.GetType(tNamespace.Value + \".\" + tName.Value);  \n           }  \n           else  \n            {  \n               return knownTypeResolver.ResolveName(typeName, typeNamespace, null);  \n           }  \n       }  \n  \n       // Used at serialization  \n        // Maps any Type to a new xsi:type representation  \n        public override void ResolveType(Type dataContractType, DataContractResolver knownTypeResolver, out XmlDictionaryString typeName, out XmlDictionaryString typeNamespace)  \n       {  \n           knownTypeResolver.ResolveType(dataContractType, null, out typeName, out typeNamespace);  \n           if (typeName == null || typeNamespace == null)  \n           {  \n               typeName = new XmlDictionaryString(XmlDictionary.Empty, dataContractType.Name, 0);  \n               typeNamespace = new XmlDictionaryString(XmlDictionary.Empty, dataContractType.Namespace, 0);  \n           }  \n       }  \n   }  \n```  \n  \n The library of types used in this sample is shown in the following example.  \n  \n```csharp \n [DataContract]  \n public class ComplexNumber  \n {  \n    [DataMember]  \n    private double real;  \n  \n    [DataMember]  \n    private double imaginary;  \n  \n    public ComplexNumber(double r1, double i1)  \n    {  \n        this.Real = r1;  \n        this.Imaginary = i1;  \n    }  \n  \n    public double Real  \n    {  \n        get { return real; }  \n        set { real = value; }  \n    }  \n  \n    public double Imaginary  \n    {  \n        get { return imaginary; }  \n        set { imaginary = value; }  \n    }  \n}  \n  \n[DataContract]  \npublic class ComplexNumberWithMagnitude : ComplexNumber  \n {  \n    public ComplexNumberWithMagnitude(double real, double imaginary) : base(real, imaginary) { }  \n  \n    [DataMember]  \n    public double Magnitude  \n    {  \n        get { return Math.Sqrt(Imaginary * Imaginary + Real * Real); }  \n        set { }  \n    }  \n}  \n```  \n  \n Note that `ComplexNumber` does not need to statically know the `ComplexNumberWithMagnitude` type, because it becomes known at runtime.  \n  \n When the sample is built and executed, this is the expected output obtained in the client:  \n  \n```console  \nAdd(1 + 2i, 3 + 4i) = 4 + 6i  \nMagnitude: 7.21110255092798  \n  \nSubtract(1 + 2i, 3 + 4i) = -2 + -2i  \nMagnitude: 2.82842712474619  \n  \nMultiply(2 + 3i, 4 + 7i) = -13 + 26i  \nNo magnitude was sent from the service  \n  \nDivide(3 + 7i, 5 + -2i) = 0.0344827586206897 + 41i  \nNo magnitude was sent from the service  \n  \nLists combined:  \n1 + 1i  \n2 + 2i  \n3 + 3i  \n4 + 4i  \n```  \n  \n#### To set up, run, and build the sample  \n  \n1.  Right-click the solution **KnownAssemblyAttribute** and select **Properties**.  \n  \n2.  In **Common Properties**, select **Startup Project**, and then click **Multiple startup projects**.  \n  \n3.  Add the **Start** action to the **Service** and **Client** projects.  \n  \n4.  Click **OK**, and press **F5** to run the sample.  \n  \n5.  If the application does not run properly, follow these steps to make sure your environment has been properly set up:  \n  \n6.  Ensure that you have performed the [One-Time Set Up Procedure for the Windows Communication Foundation Samples](https://go.microsoft.com/fwlink/?LinkId=150774).  \n  \n7.  To build the solution, follow the instructions in [Building the Windows Communication Foundation Sample](https://go.microsoft.com/fwlink/?LinkId=150775).  \n  \n8.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](https://go.microsoft.com/fwlink/?LinkId=150776).  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Basic\\Contract\\Data\\KnownAssemblyAttribute`  \n","nodes":[{"pos":[4,106],"embed":true,"restype":"x-metadata","content":"title: \"KnownAssemblyAttribute\"\nms.date: \"03/30/2017\"\nms.assetid: b3bc7f31-95ff-46e1-8308-d206ec426f6e","nodes":[{"content":"KnownAssemblyAttribute","nodes":[{"pos":[0,22],"content":"KnownAssemblyAttribute","nodes":[{"content":"KnownAssemblyAttribute","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[113,135],"content":"KnownAssemblyAttribute","linkify":"KnownAssemblyAttribute","nodes":[{"content":"KnownAssemblyAttribute","pos":[0,22]}]},{"content":"This sample demonstrates how the serialization and deserialization processes can be customized by using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractResolver&gt;</ph> class.","pos":[136,307],"source":"This sample demonstrates how the serialization and deserialization processes can be customized by using the <xref:System.Runtime.Serialization.DataContractResolver> class."},{"content":"This sample shows how to dynamically add known types during serialization and deserialization.","pos":[308,402]},{"pos":[411,425],"content":"Sample Details","linkify":"Sample Details","nodes":[{"content":"Sample Details","pos":[0,14]}]},{"content":"This sample is composed of four projects.","pos":[429,470]},{"content":"One of them corresponds to the service, to be hosted by IIS, which defines the following service contract.","pos":[471,577]},{"content":"The service contract is implemented as shown in the following example.","pos":[1278,1348]},{"content":"Another project corresponds to the client, which communicates with the server and invokes the methods that it exposes.","pos":[2934,3052]},{"content":"The definition of the client is shown in the following example.","pos":[3053,3116]},{"content":"The definition of the service contract is marked with the <ph id=\"ph1\">`KnownAssembly`</ph> attribute.","pos":[7404,7488],"source":"The definition of the service contract is marked with the `KnownAssembly` attribute."},{"content":"This attribute contains the name of a library of types, which all become known at runtime by both the service and the client.","pos":[7489,7614]},{"content":"The <ph id=\"ph1\">`KnownAssembly`</ph> attribute implements <ph id=\"ph2\">`IContractBehavior`</ph> in order to define a <ph id=\"ph3\">`DataContractSerializer`</ph> with a <ph id=\"ph4\">`DataContractResolver`</ph> defined for each of the operation behaviors.","pos":[7621,7802],"source":"The `KnownAssembly` attribute implements `IContractBehavior` in order to define a `DataContractSerializer` with a `DataContractResolver` defined for each of the operation behaviors."},{"content":"The <ph id=\"ph1\">`DataContractResolver`</ph> reflects over the assembly when it is created, and creates the dictionary with the mapping between types and names to be used when serializing and deserializing the different types.","pos":[7803,8011],"source":" The `DataContractResolver` reflects over the assembly when it is created, and creates the dictionary with the mapping between types and names to be used when serializing and deserializing the different types."},{"content":"In that way, the <ph id=\"ph1\">`ResolveType`</ph> and <ph id=\"ph2\">`ResolveName`</ph> types must look up the data required in the dictionary.","pos":[8012,8116],"source":" In that way, the `ResolveType` and `ResolveName` types must look up the data required in the dictionary."},{"pos":[8123,8208],"content":"The <ph id=\"ph1\">`DataContractResolver`</ph> defined for this sample is shown in the following example.","source":"The `DataContractResolver` defined for this sample is shown in the following example."},{"content":"The library of types used in this sample is shown in the following example.","pos":[11554,11629]},{"pos":[12512,12646],"content":"Note that <ph id=\"ph1\">`ComplexNumber`</ph> does not need to statically know the <ph id=\"ph2\">`ComplexNumberWithMagnitude`</ph> type, because it becomes known at runtime.","source":"Note that `ComplexNumber` does not need to statically know the `ComplexNumberWithMagnitude` type, because it becomes known at runtime."},{"content":"When the sample is built and executed, this is the expected output obtained in the client:","pos":[12653,12743]},{"pos":[13145,13181],"content":"To set up, run, and build the sample","linkify":"To set up, run, and build the sample","nodes":[{"content":"To set up, run, and build the sample","pos":[0,36]}]},{"pos":[13191,13269],"content":"Right-click the solution <bpt id=\"p1\">**</bpt>KnownAssemblyAttribute<ept id=\"p1\">**</ept> and select <bpt id=\"p2\">**</bpt>Properties<ept id=\"p2\">**</ept>.","source":"Right-click the solution **KnownAssemblyAttribute** and select **Properties**."},{"pos":[13279,13378],"content":"In <bpt id=\"p1\">**</bpt>Common Properties<ept id=\"p1\">**</ept>, select <bpt id=\"p2\">**</bpt>Startup Project<ept id=\"p2\">**</ept>, and then click <bpt id=\"p3\">**</bpt>Multiple startup projects<ept id=\"p3\">**</ept>.","source":"In **Common Properties**, select **Startup Project**, and then click **Multiple startup projects**."},{"pos":[13388,13456],"content":"Add the <bpt id=\"p1\">**</bpt>Start<ept id=\"p1\">**</ept> action to the <bpt id=\"p2\">**</bpt>Service<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>Client<ept id=\"p3\">**</ept> projects.","source":"Add the **Start** action to the **Service** and **Client** projects."},{"pos":[13466,13515],"content":"Click <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept>, and press <bpt id=\"p2\">**</bpt>F5<ept id=\"p2\">**</ept> to run the sample.","source":"Click **OK**, and press **F5** to run the sample."},{"content":"If the application does not run properly, follow these steps to make sure your environment has been properly set up:","pos":[13525,13641]},{"pos":[13651,13811],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Set Up Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150774)</ept>.","source":"Ensure that you have performed the [One-Time Set Up Procedure for the Windows Communication Foundation Samples](https://go.microsoft.com/fwlink/?LinkId=150774)."},{"pos":[13821,13974],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Sample<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150775)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Sample](https://go.microsoft.com/fwlink/?LinkId=150775)."},{"pos":[13984,14177],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150776)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](https://go.microsoft.com/fwlink/?LinkId=150776)."},{"pos":[14185,14317],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[14,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[0,53]},{"content":"Check for the following (default) directory before continuing.","pos":[54,116]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[14371,14681],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[14682,14732]}]}