{"content":"---\ntitle: \"Guidelines for Collections\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e\nauthor: \"KrzysztofCwalina\"\n---\n# Guidelines for Collections\nAny type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection. It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.  \n  \n **X DO NOT** use weakly typed collections in public APIs.  \n  \n The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).  \n  \n **X DO NOT** use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.  \n  \n These types are data structures designed to be used in internal implementation, not in public APIs. `List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility. For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection. Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios. The following two sections describe types (abstractions) designed specifically for use in public APIs.  \n  \n **X DO NOT** use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.  \n  \n These types are data structures designed to be used in internal implementation. Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.  \n  \n **X DO NOT** use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.  \n  \n Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.  \n  \n **X DO NOT** implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type. The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.  \n  \n## Collection Parameters  \n **✓ DO** use the least-specialized type possible as a parameter type. Most members taking collections as parameters use the `IEnumerable<T>` interface.  \n  \n **X AVOID** using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.  \n  \n Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.  \n  \n## Collection Properties and Return Values  \n **X DO NOT** provide settable collection properties.  \n  \n Users can replace the contents of the collection by clearing the collection first and then adding the new contents. If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.  \n  \n **✓ DO** use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.  \n  \n If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.  \n  \n **✓ DO** use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.  \n  \n In general, prefer `ReadOnlyCollection<T>`. If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`. If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.  \n  \n In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.  \n  \n **✓ CONSIDER** using subclasses of generic base collections instead of using the collections directly.  \n  \n This allows for a better name and for adding helper members that are not present on the base collection types. This is especially applicable to high-level APIs.  \n  \n **✓ CONSIDER** returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.  \n  \n This will make it possible for you to add helper methods or change the collection implementation in the future.  \n  \n **✓ CONSIDER** using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.). Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.  \n  \n Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.  \n  \n **X DO NOT** return null values from collection properties or from methods returning collections. Return an empty collection or an empty array instead.  \n  \n The general rule is that null and empty (0 item) collections or arrays should be treated the same.  \n  \n### Snapshots Versus Live Collections  \n Collections representing a state at some point in time are called snapshot collections. For example, a collection containing rows returned from a database query would be a snapshot. Collections that always represent the current state are called live collections. For example, a collection of `ComboBox` items is a live collection.  \n  \n **X DO NOT** return snapshot collections from properties. Properties should return live collections.  \n  \n Property getters should be very lightweight operations. Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.  \n  \n **✓ DO** use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).  \n  \n In general, all collections representing a shared resource (e.g., files in a directory) are volatile. Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.  \n  \n## Choosing Between Arrays and Collections  \n **✓ DO** prefer collections over arrays.  \n  \n Collections provide more control over contents, can evolve over time, and are more usable. In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive. Usability studies have shown that some developers feel more comfortable using collection-based APIs.  \n  \n However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios. Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.  \n  \n **✓ CONSIDER** using arrays in low-level APIs to minimize memory consumption and maximize performance.  \n  \n **✓ DO** use byte arrays instead of collections of bytes.  \n  \n **X DO NOT** use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.  \n  \n## Implementing Custom Collections  \n **✓ CONSIDER** inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.  \n  \n **✓ DO** implement `IEnumerable<T>` when designing new collections. Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.  \n  \n When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible. That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.  \n  \n **✓ CONSIDER** implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.  \n  \n **X AVOID** implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.  \n  \n **X DO NOT** inherit from nongeneric base collections such as `CollectionBase`. Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.  \n  \n### Naming Custom Collections  \n Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>). Data structures are most often used in the internal implementation of applications and libraries. Specialized collections are mainly to be exposed in APIs (as property and parameter types).  \n  \n **✓ DO** use the \"Dictionary\" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.  \n  \n **✓ DO** use the \"Collection\" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.  \n  \n **✓ DO** use the appropriate data structure name for custom data structures.  \n  \n **X AVOID** using any suffixes implying particular implementation, such as \"LinkedList\" or \"Hashtable,\" in names of collection abstractions.  \n  \n **✓ CONSIDER** prefixing collection names with the name of the item type. For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`. If the item type is an interface, the \"I\" prefix of the item type can be omitted. Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.  \n  \n **✓ CONSIDER** using the \"ReadOnly\" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.  \n  \n For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.  \n  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See also\n\n- [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)\n- [Usage Guidelines](../../../docs/standard/design-guidelines/usage-guidelines.md)\n","nodes":[{"pos":[4,168],"embed":true,"restype":"x-metadata","content":"title: \"Guidelines for Collections\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e\nauthor: \"KrzysztofCwalina\"","nodes":[{"content":"Guidelines for Collections","nodes":[{"pos":[0,26],"content":"Guidelines for Collections","nodes":[{"content":"Guidelines for Collections","pos":[0,26]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[175,201],"content":"Guidelines for Collections","linkify":"Guidelines for Collections","nodes":[{"content":"Guidelines for Collections","pos":[0,26]}]},{"content":"Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.","pos":[202,331]},{"content":"It is almost always appropriate for such types to implement <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, so in this section we only consider types implementing one or both of those interfaces to be collections.","pos":[332,589],"source":" It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections."},{"pos":[596,653],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use weakly typed collections in public APIs.","source":"**X DO NOT** use weakly typed collections in public APIs."},{"content":"The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).","pos":[660,848]},{"pos":[855,969],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> in public APIs.","source":"**X DO NOT** use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs."},{"content":"These types are data structures designed to be used in internal implementation, not in public APIs.","pos":[976,1075]},{"content":"<ph id=\"ph1\">`List&lt;T&gt;`</ph> is optimized for performance and power at the cost of cleanness of the APIs and flexibility.","pos":[1076,1178],"source":"`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility."},{"content":"For example, if you return <ph id=\"ph1\">`List&lt;T&gt;`</ph>, you will not ever be able to receive notifications when client code modifies the collection.","pos":[1179,1309],"source":" For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection."},{"content":"Also, <ph id=\"ph1\">`List&lt;T&gt;`</ph> exposes many members, such as <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph>, that are not useful or applicable in many scenarios.","pos":[1310,1468],"source":" Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios."},{"content":"The following two sections describe types (abstractions) designed specifically for use in public APIs.","pos":[1469,1571]},{"pos":[1578,1651],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use <ph id=\"ph1\">`Hashtable`</ph> or <ph id=\"ph2\">`Dictionary&lt;TKey,TValue&gt;`</ph> in public APIs.","source":"**X DO NOT** use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs."},{"content":"These types are data structures designed to be used in internal implementation.","pos":[1658,1737]},{"content":"Public APIs should use <ph id=\"ph1\">&lt;xref:System.Collections.IDictionary&gt;</ph>, <ph id=\"ph2\">`IDictionary &lt;TKey, TValue&gt;`</ph>, or a custom type implementing one or both of the interfaces.","pos":[1738,1890],"source":" Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces."},{"pos":[1897,2120],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerator&gt;</ph>, or any other type that implements either of these interfaces, except as the return type of a <ph id=\"ph3\">`GetEnumerator`</ph> method.","source":"**X DO NOT** use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method."},{"pos":[2127,2239],"content":"Types returning enumerators from methods other than <ph id=\"ph1\">`GetEnumerator`</ph> cannot be used with the <ph id=\"ph2\">`foreach`</ph> statement.","source":"Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement."},{"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> implement both <ph id=\"ph1\">`IEnumerator&lt;T&gt;`</ph> and <ph id=\"ph2\">`IEnumerable&lt;T&gt;`</ph> on the same type.","pos":[2246,2329],"source":"**X DO NOT** implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type."},{"content":"The same applies to the nongeneric interfaces <ph id=\"ph1\">`IEnumerator`</ph> and <ph id=\"ph2\">`IEnumerable`</ph>.","pos":[2330,2408],"source":" The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`."},{"pos":[2417,2438],"content":"Collection Parameters","linkify":"Collection Parameters","nodes":[{"content":"Collection Parameters","pos":[0,21]}]},{"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use the least-specialized type possible as a parameter type.","pos":[2442,2511],"source":"**✓ DO** use the least-specialized type possible as a parameter type."},{"content":"Most members taking collections as parameters use the <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> interface.","pos":[2512,2593],"source":" Most members taking collections as parameters use the `IEnumerable<T>` interface."},{"pos":[2600,2760],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> using <ph id=\"ph1\">&lt;xref:System.Collections.Generic.ICollection%601&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Collections.ICollection&gt;</ph> as a parameter just to access the <ph id=\"ph3\">`Count`</ph> property.","source":"**X AVOID** using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property."},{"pos":[2767,2914],"content":"Instead, consider using <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> or <ph id=\"ph2\">`IEnumerable`</ph> and dynamically checking whether the object implements <ph id=\"ph3\">`ICollection&lt;T&gt;`</ph> or <ph id=\"ph4\">`ICollection`</ph>.","source":"Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`."},{"pos":[2923,2962],"content":"Collection Properties and Return Values","linkify":"Collection Properties and Return Values","nodes":[{"content":"Collection Properties and Return Values","pos":[0,39]}]},{"pos":[2966,3018],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> provide settable collection properties.","source":"**X DO NOT** provide settable collection properties."},{"content":"Users can replace the contents of the collection by clearing the collection first and then adding the new contents.","pos":[3025,3140]},{"content":"If replacing the whole collection is a common scenario, consider providing the <ph id=\"ph1\">`AddRange`</ph> method on the collection.","pos":[3141,3256],"source":" If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection."},{"pos":[3263,3393],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use <ph id=\"ph1\">`Collection&lt;T&gt;`</ph> or a subclass of <ph id=\"ph2\">`Collection&lt;T&gt;`</ph> for properties or return values representing read/write collections.","source":"**✓ DO** use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections."},{"pos":[3400,3648],"content":"If <ph id=\"ph1\">`Collection&lt;T&gt;`</ph> does not meet some requirement (e.g., the collection must not implement <ph id=\"ph2\">&lt;xref:System.Collections.IList&gt;</ph>), use a custom collection by implementing <ph id=\"ph3\">`IEnumerable&lt;T&gt;`</ph>, <ph id=\"ph4\">`ICollection&lt;T&gt;`</ph>, or <ph id=\"ph5\">&lt;xref:System.Collections.Generic.IList%601&gt;</ph>.","source":"If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>."},{"pos":[3655,3870],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use <ph id=\"ph1\">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>, a subclass of <ph id=\"ph2\">`ReadOnlyCollection&lt;T&gt;`</ph>, or in rare cases <ph id=\"ph3\">`IEnumerable&lt;T&gt;`</ph> for properties or return values representing read-only collections.","source":"**✓ DO** use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections."},{"content":"In general, prefer <ph id=\"ph1\">`ReadOnlyCollection&lt;T&gt;`</ph>.","pos":[3877,3920],"source":"In general, prefer `ReadOnlyCollection<T>`."},{"content":"If it does not meet some requirement (e.g., the collection must not implement <ph id=\"ph1\">`IList`</ph>), use a custom collection by implementing <ph id=\"ph2\">`IEnumerable&lt;T&gt;`</ph>, <ph id=\"ph3\">`ICollection&lt;T&gt;`</ph>, or <ph id=\"ph4\">`IList&lt;T&gt;`</ph>.","pos":[3921,4099],"source":" If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`."},{"content":"If you do implement a custom read-only collection, implement <ph id=\"ph1\">`ICollection&lt;T&gt;.IsReadOnly`</ph> to return <ph id=\"ph2\">`true`</ph>.","pos":[4100,4206],"source":" If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`."},{"pos":[4213,4357],"content":"In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph>.","source":"In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`."},{"pos":[4364,4466],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using subclasses of generic base collections instead of using the collections directly.","source":"**✓ CONSIDER** using subclasses of generic base collections instead of using the collections directly."},{"content":"This allows for a better name and for adding helper members that are not present on the base collection types.","pos":[4473,4583]},{"content":"This is especially applicable to high-level APIs.","pos":[4584,4633]},{"pos":[4640,4769],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> returning a subclass of <ph id=\"ph1\">`Collection&lt;T&gt;`</ph> or <ph id=\"ph2\">`ReadOnlyCollection&lt;T&gt;`</ph> from very commonly used methods and properties.","source":"**✓ CONSIDER** returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties."},{"content":"This will make it possible for you to add helper methods or change the collection implementation in the future.","pos":[4776,4887]},{"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).","pos":[4894,5008],"source":"**✓ CONSIDER** using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.)."},{"content":"Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from <ph id=\"ph1\">`KeyedCollection&lt;TKey,TItem&gt;`</ph>.","pos":[5009,5169],"source":" Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`."},{"content":"Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.","pos":[5176,5320]},{"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> return null values from collection properties or from methods returning collections.","pos":[5327,5424],"source":"**X DO NOT** return null values from collection properties or from methods returning collections."},{"content":"Return an empty collection or an empty array instead.","pos":[5425,5478]},{"content":"The general rule is that null and empty (0 item) collections or arrays should be treated the same.","pos":[5485,5583]},{"pos":[5593,5626],"content":"Snapshots Versus Live Collections","linkify":"Snapshots Versus Live Collections","nodes":[{"content":"Snapshots Versus Live Collections","pos":[0,33]}]},{"content":"Collections representing a state at some point in time are called snapshot collections.","pos":[5630,5717]},{"content":"For example, a collection containing rows returned from a database query would be a snapshot.","pos":[5718,5811]},{"content":"Collections that always represent the current state are called live collections.","pos":[5812,5892]},{"content":"For example, a collection of <ph id=\"ph1\">`ComboBox`</ph> items is a live collection.","pos":[5893,5960],"source":" For example, a collection of `ComboBox` items is a live collection."},{"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> return snapshot collections from properties.","pos":[5967,6024],"source":"**X DO NOT** return snapshot collections from properties."},{"content":"Properties should return live collections.","pos":[6025,6067]},{"content":"Property getters should be very lightweight operations.","pos":[6074,6129]},{"content":"Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.","pos":[6130,6223]},{"pos":[6230,6427],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use either a snapshot collection or a live <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).","source":"**✓ DO** use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection)."},{"content":"In general, all collections representing a shared resource (e.g., files in a directory) are volatile.","pos":[6434,6535]},{"content":"Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.","pos":[6536,6681]},{"pos":[6690,6729],"content":"Choosing Between Arrays and Collections","linkify":"Choosing Between Arrays and Collections","nodes":[{"content":"Choosing Between Arrays and Collections","pos":[0,39]}]},{"pos":[6733,6773],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> prefer collections over arrays.","source":"**✓ DO** prefer collections over arrays."},{"content":"Collections provide more control over contents, can evolve over time, and are more usable.","pos":[6780,6870]},{"content":"In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.","pos":[6871,6989]},{"content":"Usability studies have shown that some developers feel more comfortable using collection-based APIs.","pos":[6990,7090]},{"content":"However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.","pos":[7097,7202]},{"content":"Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.","pos":[7203,7363]},{"pos":[7370,7472],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using arrays in low-level APIs to minimize memory consumption and maximize performance.","source":"**✓ CONSIDER** using arrays in low-level APIs to minimize memory consumption and maximize performance."},{"pos":[7479,7536],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use byte arrays instead of collections of bytes.","source":"**✓ DO** use byte arrays instead of collections of bytes."},{"pos":[7543,7708],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.","source":"**X DO NOT** use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called."},{"pos":[7717,7748],"content":"Implementing Custom Collections","linkify":"Implementing Custom Collections","nodes":[{"content":"Implementing Custom Collections","pos":[0,31]}]},{"pos":[7752,7889],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> inheriting from <ph id=\"ph1\">`Collection&lt;T&gt;`</ph>, <ph id=\"ph2\">`ReadOnlyCollection&lt;T&gt;`</ph>, or <ph id=\"ph3\">`KeyedCollection&lt;TKey,TItem&gt;`</ph> when designing new collections.","source":"**✓ CONSIDER** inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections."},{"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> implement <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> when designing new collections.","pos":[7896,7963],"source":"**✓ DO** implement `IEnumerable<T>` when designing new collections."},{"content":"Consider implementing <ph id=\"ph1\">`ICollection&lt;T&gt;`</ph> or even <ph id=\"ph2\">`IList&lt;T&gt;`</ph> where it makes sense.","pos":[7964,8043],"source":" Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense."},{"content":"When implementing such custom collection, follow the API pattern established by <ph id=\"ph1\">`Collection&lt;T&gt;`</ph> and <ph id=\"ph2\">`ReadOnlyCollection&lt;T&gt;`</ph> as closely as possible.","pos":[8050,8197],"source":"When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible."},{"content":"That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.","pos":[8198,8314]},{"pos":[8321,8490],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> implementing nongeneric collection interfaces (<ph id=\"ph1\">`IList`</ph> and <ph id=\"ph2\">`ICollection`</ph>) if the collection will often be passed to APIs taking these interfaces as input.","source":"**✓ CONSIDER** implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input."},{"pos":[8497,8612],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.","source":"**X AVOID** implementing collection interfaces on types with complex APIs unrelated to the concept of a collection."},{"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> inherit from nongeneric base collections such as <ph id=\"ph1\">`CollectionBase`</ph>.","pos":[8619,8698],"source":"**X DO NOT** inherit from nongeneric base collections such as `CollectionBase`."},{"content":"Use <ph id=\"ph1\">`Collection&lt;T&gt;`</ph>, <ph id=\"ph2\">`ReadOnlyCollection&lt;T&gt;`</ph>, and <ph id=\"ph3\">`KeyedCollection&lt;TKey,TItem&gt;`</ph> instead.","pos":[8699,8787],"source":" Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead."},{"pos":[8797,8822],"content":"Naming Custom Collections","linkify":"Naming Custom Collections","nodes":[{"content":"Naming Custom Collections","pos":[0,25]}]},{"content":"Collections (types that implement <ph id=\"ph1\">`IEnumerable`</ph>) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Collections.Generic.LinkedList%601&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <ph id=\"ph5\">&lt;xref:System.Collections.Specialized.StringCollection&gt;</ph>).","pos":[8826,9350],"source":"Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>)."},{"content":"Data structures are most often used in the internal implementation of applications and libraries.","pos":[9351,9448]},{"content":"Specialized collections are mainly to be exposed in APIs (as property and parameter types).","pos":[9449,9540]},{"pos":[9547,9666],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use the \"Dictionary\" suffix in names of abstractions implementing <ph id=\"ph1\">`IDictionary`</ph> or <ph id=\"ph2\">`IDictionary&lt;TKey,TValue&gt;`</ph>.","source":"**✓ DO** use the \"Dictionary\" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`."},{"pos":[9673,9816],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use the \"Collection\" suffix in names of types implementing <ph id=\"ph1\">`IEnumerable`</ph> (or any of its descendants) and representing a list of items.","source":"**✓ DO** use the \"Collection\" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items."},{"pos":[9823,9899],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use the appropriate data structure name for custom data structures.","source":"**✓ DO** use the appropriate data structure name for custom data structures."},{"pos":[9906,10046],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> using any suffixes implying particular implementation, such as \"LinkedList\" or \"Hashtable,\" in names of collection abstractions.","source":"**X AVOID** using any suffixes implying particular implementation, such as \"LinkedList\" or \"Hashtable,\" in names of collection abstractions."},{"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> prefixing collection names with the name of the item type.","pos":[10053,10126],"source":"**✓ CONSIDER** prefixing collection names with the name of the item type."},{"content":"For example, a collection storing items of type <ph id=\"ph1\">`Address`</ph> (implementing <ph id=\"ph2\">`IEnumerable&lt;Address&gt;`</ph>) should be named <ph id=\"ph3\">`AddressCollection`</ph>.","pos":[10127,10259],"source":" For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`."},{"content":"If the item type is an interface, the \"I\" prefix of the item type can be omitted.","pos":[10260,10341]},{"content":"Thus, a collection of <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> items can be called <ph id=\"ph2\">`DisposableCollection`</ph>.","pos":[10342,10433],"source":" Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`."},{"pos":[10440,10607],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using the \"ReadOnly\" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.","source":"**✓ CONSIDER** using the \"ReadOnly\" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework."},{"pos":[10614,10705],"content":"For example, a read-only collection of strings should be called <ph id=\"ph1\">`ReadOnlyStringCollection`</ph>.","source":"For example, a read-only collection of strings should be called `ReadOnlyStringCollection`."},{"pos":[10712,10779],"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[10786,11191],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[11200,11208],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[11212,11292],"content":"<bpt id=\"p1\">[</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept>","source":"[Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)"},{"pos":[11295,11375],"content":"<bpt id=\"p1\">[</bpt>Usage Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/usage-guidelines.md)</ept>","source":"[Usage Guidelines](../../../docs/standard/design-guidelines/usage-guidelines.md)"}]}