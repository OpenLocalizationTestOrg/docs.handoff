{"content":"---\ntitle: \"SQL Server Connection Pooling (ADO.NET)\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 7e51d44e-7c4e-4040-9332-f0190fe36f07\n---\n# SQL Server Connection Pooling (ADO.NET)\nConnecting to a database server typically consists of several time-consuming steps. A physical channel such as a socket or a named pipe must be established, the initial handshake with the server must occur, the connection string information must be parsed, the connection must be authenticated by the server, checks must be run for enlisting in the current transaction, and so on.  \n  \n In practice, most applications use only one or a few different configurations for connections. This means that during application execution, many identical connections will be repeatedly opened and closed. To minimize the cost of opening connections, [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] uses an optimization technique called *connection pooling*.  \n  \n Connection pooling reduces the number of times that new connections must be opened. The *pooler* maintains ownership of the physical connection. It manages connections by keeping alive a set of active connections for each given connection configuration. Whenever a user calls `Open` on a connection, the pooler looks for an available connection in the pool. If a pooled connection is available, it returns it to the caller instead of opening a new connection. When the application calls `Close` on the connection, the pooler returns it to the pooled set of active connections instead of closing it. Once the connection is returned to the pool, it is ready to be reused on the next `Open` call.  \n  \n Only connections with the same configuration can be pooled. [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] keeps several pools at the same time, one for each configuration. Connections are separated into pools by connection string, and by Windows identity when integrated security is used. Connections are also pooled based on whether they are enlisted in a transaction. When using <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>, the <xref:System.Data.SqlClient.SqlCredential> instance affects the connection pool. Different instances of <xref:System.Data.SqlClient.SqlCredential> will use different connection pools, even if the user ID and password are the same.  \n  \n Pooling connections can significantly enhance the performance and scalability of your application. By default, connection pooling is enabled in [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]. Unless you explicitly disable it, the pooler optimizes the connections as they are opened and closed in your application. You can also supply several connection string modifiers to control connection pooling behavior. For more information, see \"Controlling Connection Pooling with Connection String Keywords\" later in this topic.  \n  \n> [!NOTE]\n>  When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the \"blocking period\". If the application attempts to connect within the blocking period, the first exception will be thrown again. Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.  \n  \n## Pool Creation and Assignment  \n When a connection is first opened, a connection pool is created based on an exact matching algorithm that associates the pool with the connection string in the connection. Each connection pool is associated with a distinct connection string. When a new connection is opened, if the connection string is not an exact match to an existing pool, a new pool is created. Connections are pooled per process, per application domain, per connection string and when integrated security is used, per Windows identity. Connection strings must also be an exact match; keywords supplied in a different order for the same connection will be pooled separately.  \n  \n In the following C# example, three new <xref:System.Data.SqlClient.SqlConnection> objects are created, but only two connection pools are required to manage them. Note that the first and second connection strings differ by the value assigned for `Initial Catalog`.  \n  \n```csharp\nusing (SqlConnection connection = new SqlConnection(  \n  \"Integrated Security=SSPI;Initial Catalog=Northwind\"))  \n    {  \n        connection.Open();        \n        // Pool A is created.  \n    }  \n  \nusing (SqlConnection connection = new SqlConnection(  \n  \"Integrated Security=SSPI;Initial Catalog=pubs\"))  \n    {  \n        connection.Open();        \n        // Pool B is created because the connection strings differ.  \n    }  \n  \nusing (SqlConnection connection = new SqlConnection(  \n  \"Integrated Security=SSPI;Initial Catalog=Northwind\"))  \n    {  \n        connection.Open();        \n        // The connection string matches pool A.  \n    }  \n```  \n  \n If `MinPoolSize` is either not specified in the connection string or is specified as zero, the connections in the pool will be closed after a period of inactivity. However, if the specified `MinPoolSize` is greater than zero, the connection pool is not destroyed until the `AppDomain` is unloaded and the process ends. Maintenance of inactive or empty pools involves minimal system overhead.  \n  \n> [!NOTE]\n>  The pool is automatically cleared when a fatal error occurs, such as a failover.  \n  \n## Adding Connections  \n A connection pool is created for each unique connection string. When a pool is created, multiple connection objects are created and added to the pool so that the minimum pool size requirement is satisfied. Connections are added to the pool as needed, up to the maximum pool size specified (100 is the default). Connections are released back into the pool when they are closed or disposed.  \n  \n When a <xref:System.Data.SqlClient.SqlConnection> object is requested, it is obtained from the pool if a usable connection is available. To be usable, a connection must be unused, have a matching transaction context or be unassociated with any transaction context, and have a valid link to the server.  \n  \n The connection pooler satisfies requests for connections by reallocating connections as they are released back into the pool. If the maximum pool size has been reached and no usable connection is available, the request is queued. The pooler then tries to reclaim any connections until the time-out is reached (the default is 15 seconds). If the pooler cannot satisfy the request before the connection times out, an exception is thrown.  \n  \n> [!CAUTION]\n>  We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool. You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic. Connections that are not explicitly closed might not be added or returned to the pool. For more information, see [using Statement](~/docs/csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](~/docs/visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic.  \n  \n> [!NOTE]\n>  Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class. In a finalizer, only release unmanaged resources that your class owns directly. If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition. For more information, see [Garbage Collection](../../../../docs/standard/garbage-collection/index.md).  \n  \nFor more info about the events associated with opening and closing connections, see [Audit Login Event Class](/sql/relational-databases/event-classes/audit-login-event-class) and [Audit Logout Event Class](/sql/relational-databases/event-classes/audit-logout-event-class) in the SQL Server documentation.  \n  \n## Removing Connections  \n The connection pooler removes a connection from the pool after it has been idle for approximately 4-8 minutes, or if the pooler detects that the connection with the server has been severed. Note that a severed connection can be detected only after attempting to communicate with the server. If a connection is found that is no longer connected to the server, it is marked as invalid. Invalid connections are removed from the connection pool only when they are closed or reclaimed.  \n  \n If a connection exists to a server that has disappeared, this connection can be drawn from the pool even if the connection pooler has not detected the severed connection and marked it as invalid. This is the case because the overhead of checking that the connection is still valid would eliminate the benefits of having a pooler by causing another round trip to the server to occur. When this occurs, the first attempt to use the connection will detect that the connection has been severed, and an exception is thrown.  \n  \n## Clearing the Pool  \n [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] 2.0 introduced two new methods to clear the pool: <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> and <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>. `ClearAllPools` clears the connection pools for a given provider, and `ClearPool` clears the connection pool that is associated with a specific connection. If there are connections being used at the time of the call, they are marked appropriately. When they are closed, they are discarded instead of being returned to the pool.  \n  \n## Transaction Support  \n Connections are drawn from the pool and assigned based on transaction context. Unless `Enlist=false` is specified in the connection string, the connection pool makes sure that the connection is enlisted in the <xref:System.Transactions.Transaction.Current%2A> context. When a connection is closed and returned to the pool with an enlisted `System.Transactions` transaction, it is set aside in such a way that the next request for that connection pool with the same `System.Transactions` transaction will return the same connection if it is available. If such a request is issued, and there are no pooled connections available, a connection is drawn from the non-transacted part of the pool and enlisted. If no connections are available in either area of the pool, a new connection is created and enlisted.  \n  \n When a connection is closed, it is released back into the pool and into the appropriate subdivision based on its transaction context. Therefore, you can close the connection without generating an error, even though a distributed transaction is still pending. This allows you to commit or abort the distributed transaction later.  \n  \n## Controlling Connection Pooling with Connection String Keywords  \n The `ConnectionString` property of the <xref:System.Data.SqlClient.SqlConnection> object supports connection string key/value pairs that can be used to adjust the behavior of the connection pooling logic. For more information, see <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.  \n  \n## Pool Fragmentation  \n Pool fragmentation is a common problem in many Web applications where the application can create a large number of pools that are not freed until the process exits. This leaves a large number of connections open and consuming memory, which results in poor performance.  \n  \n### Pool Fragmentation Due to Integrated Security  \n Connections are pooled according to the connection string plus the user identity. Therefore, if you use Basic authentication or Windows Authentication on the Web site and an integrated security login, you get one pool per user. Although this improves the performance of subsequent database requests for a single user, that user cannot take advantage of connections made by other users. It also results in at least one connection per user to the database server. This is a side effect of a particular Web application architecture that developers must weigh against security and auditing requirements.  \n  \n### Pool Fragmentation Due to Many Databases  \n Many Internet service providers host several Web sites on a single server. They may use a single database to confirm a Forms authentication login and then open a connection to a specific database for that user or group of users. The connection to the authentication database is pooled and used by everyone. However, there is a separate pool of connections to each database, which increase the number of connections to the server.  \n  \n This is also a side-effect of the application design. There is a relatively simple way to avoid this side effect without compromising security when you connect to SQL Server. Instead of connecting to a separate database for each user or group, connect to the same database on the server and then execute the [!INCLUDE[tsql](../../../../includes/tsql-md.md)] USE statement to change to the desired database. The following code fragment demonstrates creating an initial connection to the `master` database and then switching to the desired database specified in the `databaseName` string variable.  \n  \n```vb  \n' Assumes that command is a valid SqlCommand object and that  \n' connectionString connects to master.  \n    command.Text = \"USE DatabaseName\"  \nUsing connection As New SqlConnection(connectionString)  \n    connection.Open()  \n    command.ExecuteNonQuery()  \nEnd Using  \n```  \n  \n```csharp  \n// Assumes that command is a SqlCommand object and that  \n// connectionString connects to master.  \ncommand.Text = \"USE DatabaseName\";  \nusing (SqlConnection connection = new SqlConnection(  \n  connectionString))  \n  {  \n    connection.Open();  \n    command.ExecuteNonQuery();  \n  }  \n```  \n  \n## Application Roles and Connection Pooling  \n After a SQL Server application role has been activated by calling the `sp_setapprole` system stored procedure, the security context of that connection cannot be reset. However, if pooling is enabled, the connection is returned to the pool, and an error occurs when the pooled connection is reused. For more information, see the Knowledge Base article, \"[SQL application role errors with OLE DB resource pooling](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564).\"  \n  \n### Application Role Alternatives  \n We recommend that you take advantage of security mechanisms that you can use instead of application roles. For more information, see [Creating Application Roles in SQL Server](../../../../docs/framework/data/adonet/sql/creating-application-roles-in-sql-server.md).  \n  \n## See also\n\n- [Connection Pooling](../../../../docs/framework/data/adonet/connection-pooling.md)\n- [SQL Server and ADO.NET](../../../../docs/framework/data/adonet/sql/index.md)\n- [Performance Counters](../../../../docs/framework/data/adonet/performance-counters.md)\n- [ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)\n","nodes":[{"pos":[4,157],"embed":true,"restype":"x-metadata","content":"title: \"SQL Server Connection Pooling (ADO.NET)\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 7e51d44e-7c4e-4040-9332-f0190fe36f07","nodes":[{"content":"SQL Server Connection Pooling (ADO.NET)","nodes":[{"pos":[0,39],"content":"SQL Server Connection Pooling (ADO.NET)","nodes":[{"content":"SQL Server Connection Pooling (ADO.NET)","pos":[0,39]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[164,203],"content":"SQL Server Connection Pooling (ADO.NET)","linkify":"SQL Server Connection Pooling (ADO.NET)","nodes":[{"content":"SQL Server Connection Pooling (ADO.NET)","pos":[0,39]}]},{"content":"Connecting to a database server typically consists of several time-consuming steps.","pos":[204,287]},{"content":"A physical channel such as a socket or a named pipe must be established, the initial handshake with the server must occur, the connection string information must be parsed, the connection must be authenticated by the server, checks must be run for enlisting in the current transaction, and so on.","pos":[288,584]},{"content":"In practice, most applications use only one or a few different configurations for connections.","pos":[591,685]},{"content":"This means that during application execution, many identical connections will be repeatedly opened and closed.","pos":[686,796]},{"content":"To minimize the cost of opening connections, <ph id=\"ph1\">[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]</ph> uses an optimization technique called <bpt id=\"p1\">*</bpt>connection pooling<ept id=\"p1\">*</ept>.","pos":[797,959],"source":" To minimize the cost of opening connections, [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] uses an optimization technique called *connection pooling*."},{"content":"Connection pooling reduces the number of times that new connections must be opened.","pos":[966,1049]},{"content":"The <bpt id=\"p1\">*</bpt>pooler<ept id=\"p1\">*</ept> maintains ownership of the physical connection.","pos":[1050,1110],"source":" The *pooler* maintains ownership of the physical connection."},{"content":"It manages connections by keeping alive a set of active connections for each given connection configuration.","pos":[1111,1219]},{"content":"Whenever a user calls <ph id=\"ph1\">`Open`</ph> on a connection, the pooler looks for an available connection in the pool.","pos":[1220,1323],"source":" Whenever a user calls `Open` on a connection, the pooler looks for an available connection in the pool."},{"content":"If a pooled connection is available, it returns it to the caller instead of opening a new connection.","pos":[1324,1425]},{"content":"When the application calls <ph id=\"ph1\">`Close`</ph> on the connection, the pooler returns it to the pooled set of active connections instead of closing it.","pos":[1426,1564],"source":" When the application calls `Close` on the connection, the pooler returns it to the pooled set of active connections instead of closing it."},{"content":"Once the connection is returned to the pool, it is ready to be reused on the next <ph id=\"ph1\">`Open`</ph> call.","pos":[1565,1659],"source":" Once the connection is returned to the pool, it is ready to be reused on the next `Open` call."},{"content":"Only connections with the same configuration can be pooled.","pos":[1666,1725]},{"content":"<ph id=\"ph1\">[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]</ph> keeps several pools at the same time, one for each configuration.","pos":[1726,1849],"source":"[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] keeps several pools at the same time, one for each configuration."},{"content":"Connections are separated into pools by connection string, and by Windows identity when integrated security is used.","pos":[1850,1966]},{"content":"Connections are also pooled based on whether they are enlisted in a transaction.","pos":[1967,2047]},{"content":"When using <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlCredential&gt;</ph> instance affects the connection pool.","pos":[2048,2205],"source":" When using <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>, the <xref:System.Data.SqlClient.SqlCredential> instance affects the connection pool."},{"content":"Different instances of <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlCredential&gt;</ph> will use different connection pools, even if the user ID and password are the same.","pos":[2206,2355],"source":" Different instances of <xref:System.Data.SqlClient.SqlCredential> will use different connection pools, even if the user ID and password are the same."},{"content":"Pooling connections can significantly enhance the performance and scalability of your application.","pos":[2362,2460]},{"content":"By default, connection pooling is enabled in <ph id=\"ph1\">[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]</ph>.","pos":[2461,2564],"source":" By default, connection pooling is enabled in [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]."},{"content":"Unless you explicitly disable it, the pooler optimizes the connections as they are opened and closed in your application.","pos":[2565,2686]},{"content":"You can also supply several connection string modifiers to control connection pooling behavior.","pos":[2687,2782]},{"content":"For more information, see \"Controlling Connection Pooling with Connection String Keywords\" later in this topic.","pos":[2783,2894]},{"pos":[2902,3405],"content":"[!NOTE]\n When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the \"blocking period\". If the application attempts to connect within the blocking period, the first exception will be thrown again. Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.","leadings":["","> "],"nodes":[{"content":"When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the \"blocking period\". If the application attempts to connect within the blocking period, the first exception will be thrown again. Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.","pos":[9,501],"nodes":[{"content":"When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the \"blocking period\".","pos":[0,210]},{"content":"If the application attempts to connect within the blocking period, the first exception will be thrown again.","pos":[211,319]},{"content":"Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.","pos":[320,492]}]}]},{"pos":[3414,3442],"content":"Pool Creation and Assignment","linkify":"Pool Creation and Assignment","nodes":[{"content":"Pool Creation and Assignment","pos":[0,28]}]},{"content":"When a connection is first opened, a connection pool is created based on an exact matching algorithm that associates the pool with the connection string in the connection.","pos":[3446,3617]},{"content":"Each connection pool is associated with a distinct connection string.","pos":[3618,3687]},{"content":"When a new connection is opened, if the connection string is not an exact match to an existing pool, a new pool is created.","pos":[3688,3811]},{"content":"Connections are pooled per process, per application domain, per connection string and when integrated security is used, per Windows identity.","pos":[3812,3953]},{"content":"Connection strings must also be an exact match; keywords supplied in a different order for the same connection will be pooled separately.","pos":[3954,4091]},{"content":"In the following C# example, three new <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlConnection&gt;</ph> objects are created, but only two connection pools are required to manage them.","pos":[4098,4259],"source":"In the following C# example, three new <xref:System.Data.SqlClient.SqlConnection> objects are created, but only two connection pools are required to manage them."},{"content":"Note that the first and second connection strings differ by the value assigned for <ph id=\"ph1\">`Initial Catalog`</ph>.","pos":[4260,4361],"source":" Note that the first and second connection strings differ by the value assigned for `Initial Catalog`."},{"content":"If <ph id=\"ph1\">`MinPoolSize`</ph> is either not specified in the connection string or is specified as zero, the connections in the pool will be closed after a period of inactivity.","pos":[5036,5199],"source":"If `MinPoolSize` is either not specified in the connection string or is specified as zero, the connections in the pool will be closed after a period of inactivity."},{"content":"However, if the specified <ph id=\"ph1\">`MinPoolSize`</ph> is greater than zero, the connection pool is not destroyed until the <ph id=\"ph2\">`AppDomain`</ph> is unloaded and the process ends.","pos":[5200,5354],"source":" However, if the specified `MinPoolSize` is greater than zero, the connection pool is not destroyed until the `AppDomain` is unloaded and the process ends."},{"content":"Maintenance of inactive or empty pools involves minimal system overhead.","pos":[5355,5427]},{"pos":[5435,5526],"content":"[!NOTE]\n The pool is automatically cleared when a fatal error occurs, such as a failover.","leadings":["","> "],"nodes":[{"content":"The pool is automatically cleared when a fatal error occurs, such as a failover.","pos":[9,89]}]},{"pos":[5535,5553],"content":"Adding Connections","linkify":"Adding Connections","nodes":[{"content":"Adding Connections","pos":[0,18]}]},{"content":"A connection pool is created for each unique connection string.","pos":[5557,5620]},{"content":"When a pool is created, multiple connection objects are created and added to the pool so that the minimum pool size requirement is satisfied.","pos":[5621,5762]},{"content":"Connections are added to the pool as needed, up to the maximum pool size specified (100 is the default).","pos":[5763,5867]},{"content":"Connections are released back into the pool when they are closed or disposed.","pos":[5868,5945]},{"content":"When a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlConnection&gt;</ph> object is requested, it is obtained from the pool if a usable connection is available.","pos":[5952,6088],"source":"When a <xref:System.Data.SqlClient.SqlConnection> object is requested, it is obtained from the pool if a usable connection is available."},{"content":"To be usable, a connection must be unused, have a matching transaction context or be unassociated with any transaction context, and have a valid link to the server.","pos":[6089,6253]},{"content":"The connection pooler satisfies requests for connections by reallocating connections as they are released back into the pool.","pos":[6260,6385]},{"content":"If the maximum pool size has been reached and no usable connection is available, the request is queued.","pos":[6386,6489]},{"content":"The pooler then tries to reclaim any connections until the time-out is reached (the default is 15 seconds).","pos":[6490,6597]},{"content":"If the pooler cannot satisfy the request before the connection times out, an exception is thrown.","pos":[6598,6695]},{"pos":[6703,7415],"content":"[!CAUTION]\n We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool. You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic. Connections that are not explicitly closed might not be added or returned to the pool. For more information, see [using Statement](~/docs/csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](~/docs/visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic.","leadings":["","> "],"nodes":[{"content":"We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool. You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic. Connections that are not explicitly closed might not be added or returned to the pool. For more information, see [using Statement](~/docs/csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](~/docs/visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic.","pos":[12,710],"nodes":[{"content":"We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool.","pos":[0,142]},{"content":"You can do this using either the <ph id=\"ph1\">`Close`</ph> or <ph id=\"ph2\">`Dispose`</ph> methods of the <ph id=\"ph3\">`Connection`</ph> object, or by opening all connections inside a <ph id=\"ph4\">`using`</ph> statement in C#, or a <ph id=\"ph5\">`Using`</ph> statement in Visual Basic.","pos":[143,336],"source":" You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic."},{"content":"Connections that are not explicitly closed might not be added or returned to the pool.","pos":[337,423]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>using Statement<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/using-statement.md)</ept> or <bpt id=\"p2\">[</bpt>How to: Dispose of a System Resource<ept id=\"p2\">](~/docs/visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md)</ept> for Visual Basic.","pos":[424,698],"source":" For more information, see [using Statement](~/docs/csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](~/docs/visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic."}]}]},{"pos":[7423,7865],"content":"[!NOTE]\n Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class. In a finalizer, only release unmanaged resources that your class owns directly. If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition. For more information, see [Garbage Collection](../../../../docs/standard/garbage-collection/index.md).","leadings":["","> "],"nodes":[{"content":"Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class. In a finalizer, only release unmanaged resources that your class owns directly. If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition. For more information, see [Garbage Collection](../../../../docs/standard/garbage-collection/index.md).","pos":[9,440],"nodes":[{"content":"Do not call <ph id=\"ph1\">`Close`</ph> or <ph id=\"ph2\">`Dispose`</ph> on a <ph id=\"ph3\">`Connection`</ph>, a <ph id=\"ph4\">`DataReader`</ph>, or any other managed object in the <ph id=\"ph5\">`Finalize`</ph> method of your class.","pos":[0,135],"source":"Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class."},{"content":"In a finalizer, only release unmanaged resources that your class owns directly.","pos":[136,215]},{"content":"If your class does not own any unmanaged resources, do not include a <ph id=\"ph1\">`Finalize`</ph> method in your class definition.","pos":[216,328],"source":" If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Garbage Collection<ept id=\"p1\">](../../../../docs/standard/garbage-collection/index.md)</ept>.","pos":[329,431],"source":" For more information, see [Garbage Collection](../../../../docs/standard/garbage-collection/index.md)."}]}]},{"pos":[7871,8175],"content":"For more info about the events associated with opening and closing connections, see <bpt id=\"p1\">[</bpt>Audit Login Event Class<ept id=\"p1\">](/sql/relational-databases/event-classes/audit-login-event-class)</ept> and <bpt id=\"p2\">[</bpt>Audit Logout Event Class<ept id=\"p2\">](/sql/relational-databases/event-classes/audit-logout-event-class)</ept> in the SQL Server documentation.","source":"For more info about the events associated with opening and closing connections, see [Audit Login Event Class](/sql/relational-databases/event-classes/audit-login-event-class) and [Audit Logout Event Class](/sql/relational-databases/event-classes/audit-logout-event-class) in the SQL Server documentation."},{"pos":[8184,8204],"content":"Removing Connections","linkify":"Removing Connections","nodes":[{"content":"Removing Connections","pos":[0,20]}]},{"content":"The connection pooler removes a connection from the pool after it has been idle for approximately 4-8 minutes, or if the pooler detects that the connection with the server has been severed.","pos":[8208,8397]},{"content":"Note that a severed connection can be detected only after attempting to communicate with the server.","pos":[8398,8498]},{"content":"If a connection is found that is no longer connected to the server, it is marked as invalid.","pos":[8499,8591]},{"content":"Invalid connections are removed from the connection pool only when they are closed or reclaimed.","pos":[8592,8688]},{"content":"If a connection exists to a server that has disappeared, this connection can be drawn from the pool even if the connection pooler has not detected the severed connection and marked it as invalid.","pos":[8695,8890]},{"content":"This is the case because the overhead of checking that the connection is still valid would eliminate the benefits of having a pooler by causing another round trip to the server to occur.","pos":[8891,9077]},{"content":"When this occurs, the first attempt to use the connection will detect that the connection has been severed, and an exception is thrown.","pos":[9078,9213]},{"pos":[9222,9239],"content":"Clearing the Pool","linkify":"Clearing the Pool","nodes":[{"content":"Clearing the Pool","pos":[0,17]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]</ph> 2.0 introduced two new methods to clear the pool: <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Data.SqlClient.SqlConnection.ClearPool%2A&gt;</ph>.","pos":[9243,9471],"source":"[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] 2.0 introduced two new methods to clear the pool: <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> and <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>."},{"content":"<ph id=\"ph1\">`ClearAllPools`</ph> clears the connection pools for a given provider, and <ph id=\"ph2\">`ClearPool`</ph> clears the connection pool that is associated with a specific connection.","pos":[9472,9627],"source":"`ClearAllPools` clears the connection pools for a given provider, and `ClearPool` clears the connection pool that is associated with a specific connection."},{"content":"If there are connections being used at the time of the call, they are marked appropriately.","pos":[9628,9719]},{"content":"When they are closed, they are discarded instead of being returned to the pool.","pos":[9720,9799]},{"pos":[9808,9827],"content":"Transaction Support","linkify":"Transaction Support","nodes":[{"content":"Transaction Support","pos":[0,19]}]},{"content":"Connections are drawn from the pool and assigned based on transaction context.","pos":[9831,9909]},{"content":"Unless <ph id=\"ph1\">`Enlist=false`</ph> is specified in the connection string, the connection pool makes sure that the connection is enlisted in the <ph id=\"ph2\">&lt;xref:System.Transactions.Transaction.Current%2A&gt;</ph> context.","pos":[9910,10099],"source":" Unless `Enlist=false` is specified in the connection string, the connection pool makes sure that the connection is enlisted in the <xref:System.Transactions.Transaction.Current%2A> context."},{"content":"When a connection is closed and returned to the pool with an enlisted <ph id=\"ph1\">`System.Transactions`</ph> transaction, it is set aside in such a way that the next request for that connection pool with the same <ph id=\"ph2\">`System.Transactions`</ph> transaction will return the same connection if it is available.","pos":[10100,10381],"source":" When a connection is closed and returned to the pool with an enlisted `System.Transactions` transaction, it is set aside in such a way that the next request for that connection pool with the same `System.Transactions` transaction will return the same connection if it is available."},{"content":"If such a request is issued, and there are no pooled connections available, a connection is drawn from the non-transacted part of the pool and enlisted.","pos":[10382,10534]},{"content":"If no connections are available in either area of the pool, a new connection is created and enlisted.","pos":[10535,10636]},{"content":"When a connection is closed, it is released back into the pool and into the appropriate subdivision based on its transaction context.","pos":[10643,10776]},{"content":"Therefore, you can close the connection without generating an error, even though a distributed transaction is still pending.","pos":[10777,10901]},{"content":"This allows you to commit or abort the distributed transaction later.","pos":[10902,10971]},{"pos":[10980,11042],"content":"Controlling Connection Pooling with Connection String Keywords","linkify":"Controlling Connection Pooling with Connection String Keywords","nodes":[{"content":"Controlling Connection Pooling with Connection String Keywords","pos":[0,62]}]},{"content":"The <ph id=\"ph1\">`ConnectionString`</ph> property of the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlConnection&gt;</ph> object supports connection string key/value pairs that can be used to adjust the behavior of the connection pooling logic.","pos":[11046,11250],"source":"The `ConnectionString` property of the <xref:System.Data.SqlClient.SqlConnection> object supports connection string key/value pairs that can be used to adjust the behavior of the connection pooling logic."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A&gt;</ph>.","pos":[11251,11340],"source":" For more information, see <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>."},{"pos":[11349,11367],"content":"Pool Fragmentation","linkify":"Pool Fragmentation","nodes":[{"content":"Pool Fragmentation","pos":[0,18]}]},{"content":"Pool fragmentation is a common problem in many Web applications where the application can create a large number of pools that are not freed until the process exits.","pos":[11371,11535]},{"content":"This leaves a large number of connections open and consuming memory, which results in poor performance.","pos":[11536,11639]},{"pos":[11649,11694],"content":"Pool Fragmentation Due to Integrated Security","linkify":"Pool Fragmentation Due to Integrated Security","nodes":[{"content":"Pool Fragmentation Due to Integrated Security","pos":[0,45]}]},{"content":"Connections are pooled according to the connection string plus the user identity.","pos":[11698,11779]},{"content":"Therefore, if you use Basic authentication or Windows Authentication on the Web site and an integrated security login, you get one pool per user.","pos":[11780,11925]},{"content":"Although this improves the performance of subsequent database requests for a single user, that user cannot take advantage of connections made by other users.","pos":[11926,12083]},{"content":"It also results in at least one connection per user to the database server.","pos":[12084,12159]},{"content":"This is a side effect of a particular Web application architecture that developers must weigh against security and auditing requirements.","pos":[12160,12297]},{"pos":[12307,12347],"content":"Pool Fragmentation Due to Many Databases","linkify":"Pool Fragmentation Due to Many Databases","nodes":[{"content":"Pool Fragmentation Due to Many Databases","pos":[0,40]}]},{"content":"Many Internet service providers host several Web sites on a single server.","pos":[12351,12425]},{"content":"They may use a single database to confirm a Forms authentication login and then open a connection to a specific database for that user or group of users.","pos":[12426,12579]},{"content":"The connection to the authentication database is pooled and used by everyone.","pos":[12580,12657]},{"content":"However, there is a separate pool of connections to each database, which increase the number of connections to the server.","pos":[12658,12780]},{"content":"This is also a side-effect of the application design.","pos":[12787,12840]},{"content":"There is a relatively simple way to avoid this side effect without compromising security when you connect to SQL Server.","pos":[12841,12961]},{"content":"Instead of connecting to a separate database for each user or group, connect to the same database on the server and then execute the <ph id=\"ph1\">[!INCLUDE[tsql](../../../../includes/tsql-md.md)]</ph> USE statement to change to the desired database.","pos":[12962,13193],"source":" Instead of connecting to a separate database for each user or group, connect to the same database on the server and then execute the [!INCLUDE[tsql](../../../../includes/tsql-md.md)] USE statement to change to the desired database."},{"content":"The following code fragment demonstrates creating an initial connection to the <ph id=\"ph1\">`master`</ph> database and then switching to the desired database specified in the <ph id=\"ph2\">`databaseName`</ph> string variable.","pos":[13194,13382],"source":" The following code fragment demonstrates creating an initial connection to the `master` database and then switching to the desired database specified in the `databaseName` string variable."},{"pos":[13984,14024],"content":"Application Roles and Connection Pooling","linkify":"Application Roles and Connection Pooling","nodes":[{"content":"Application Roles and Connection Pooling","pos":[0,40]}]},{"content":"After a SQL Server application role has been activated by calling the <ph id=\"ph1\">`sp_setapprole`</ph> system stored procedure, the security context of that connection cannot be reset.","pos":[14028,14195],"source":"After a SQL Server application role has been activated by calling the `sp_setapprole` system stored procedure, the security context of that connection cannot be reset."},{"content":"However, if pooling is enabled, the connection is returned to the pool, and an error occurs when the pooled connection is reused.","pos":[14196,14325]},{"content":"For more information, see the Knowledge Base article, \"<bpt id=\"p1\">[</bpt>SQL application role errors with OLE DB resource pooling<ept id=\"p1\">](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)</ept>.\"","pos":[14326,14507],"source":" For more information, see the Knowledge Base article, \"[SQL application role errors with OLE DB resource pooling](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564).\""},{"pos":[14517,14546],"content":"Application Role Alternatives","linkify":"Application Role Alternatives","nodes":[{"content":"Application Role Alternatives","pos":[0,29]}]},{"content":"We recommend that you take advantage of security mechanisms that you can use instead of application roles.","pos":[14550,14656]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Creating Application Roles in SQL Server<ept id=\"p1\">](../../../../docs/framework/data/adonet/sql/creating-application-roles-in-sql-server.md)</ept>.","pos":[14657,14814],"source":" For more information, see [Creating Application Roles in SQL Server](../../../../docs/framework/data/adonet/sql/creating-application-roles-in-sql-server.md)."},{"pos":[14823,14831],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[14835,14917],"content":"<bpt id=\"p1\">[</bpt>Connection Pooling<ept id=\"p1\">](../../../../docs/framework/data/adonet/connection-pooling.md)</ept>","source":"[Connection Pooling](../../../../docs/framework/data/adonet/connection-pooling.md)"},{"pos":[14920,14997],"content":"<bpt id=\"p1\">[</bpt>SQL Server and ADO.NET<ept id=\"p1\">](../../../../docs/framework/data/adonet/sql/index.md)</ept>","source":"[SQL Server and ADO.NET](../../../../docs/framework/data/adonet/sql/index.md)"},{"pos":[15000,15086],"content":"<bpt id=\"p1\">[</bpt>Performance Counters<ept id=\"p1\">](../../../../docs/framework/data/adonet/performance-counters.md)</ept>","source":"[Performance Counters](../../../../docs/framework/data/adonet/performance-counters.md)"},{"pos":[15089,15193],"content":"<bpt id=\"p1\">[</bpt>ADO.NET Managed Providers and DataSet Developer Center<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=217917)</ept>","source":"[ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)"}]}