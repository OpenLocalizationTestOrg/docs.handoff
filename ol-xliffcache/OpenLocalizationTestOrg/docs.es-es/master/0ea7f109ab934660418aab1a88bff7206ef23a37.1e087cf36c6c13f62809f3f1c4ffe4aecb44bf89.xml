{"content":"---\ntitle: \"long (C# Reference) | Microsoft Docs\"\nms.date: \"2017-03-14\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"long_CSharpKeyword\"\n  - \"long\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"long keyword [C#]\"\nms.assetid: f9b24319-1f39-48be-a42b-d528ee28a7fd\ncaps.latest.revision: 17\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# long (C# Reference)\n\n`long` denotes an integral type that stores values according to the size and range shown in the following table.  \n  \n|Type|Range|Size|.NET Framework type|  \n|----------|-----------|----------|-------------------------|  \n|`long`|–9,223,372,036,854,775,808 to 9,223,372,036,854,775,807|Signed 64-bit integer|<xref:System.Int64?displayProperty=fullName>|  \n  \n## Literals \n\nYou can declare and initialize a `long` variable by assigning a decimal literal, a hexadecimal literal, or (starting with C# 7) a binary literal to it. \n\nIn the following example, integers equal to 4,294,967,296 that are represented as decimal, hexadecimal, and binary literals are assigned to `long` values.  \n  \n[!code-cs[long](../../../../samples/snippets/csharp/language-reference/keywords/numeric-literals.cs#Long)]  \n\n> [!NOTE] \n> You use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal. Decimal literals have no prefix. \n\nStarting with C# 7, you can also use the underscore character, `_`, as a digit separator to enhance readability, as the following example shows.\n\n[!code-cs[long](../../../../samples/snippets/csharp/language-reference/keywords/numeric-literals.cs#LongS)]  \n \n Integer literals can also include a suffix that denotes the type. The suffix `L` denotes a `long`. The following example uses the `L` suffix to denote a long integer:\n \n```csharp\nlong value = 4294967296L;  \n```  \n\n> [!NOTE]\n>  You can also use the lowercase letter \"l\" as a suffix. However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\" Use \"L\" for clarity.  \n  \n When you use the suffix `L`, the type of the literal integer is determined to be either `long` or [ulong](../../../csharp/language-reference/keywords/ulong.md), depending on its size. In this case, it is `long` because it less than the range of [ulong](../../../csharp/language-reference/keywords/ulong.md).  \n  \n A common use of the suffix is to call overloaded methods. For example, the following overloaded methods have parameters of type `long` and [int](../../../csharp/language-reference/keywords/int.md):  \n  \n```csharp\npublic static void SampleMethod(int i) {}  \npublic static void SampleMethod(long l) {}  \n```  \n  \n The `L` suffix guarantees that the correct overload is called:  \n  \n```csharp  \nSampleMethod(5);    // Calls the method with the int parameter  \nSampleMethod(5L);   // Calls the method with the long parameter  \n```  \nIf an integer literal has no suffix, its type is the first of the following types in which its value can be represented: \n\n1. [int](int.md)\n2. [uint](../../../csharp/language-reference/keywords/uint.md)\n3. `long`\n4. [ulong](../../../csharp/language-reference/keywords/ulong.md) \n\nThe literal 4294967296 in the previous examples is of type `long`, because it exceeds the range of [uint](../../../csharp/language-reference/keywords/uint.md) (see [Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md) for the storage sizes of integral types).  \n  \n If you use the `long` type with other integral types in the same expression, the expression is evaluated as `long` (or [bool](../../../csharp/language-reference/keywords/bool.md) in the case of relational or Boolean expressions). For example, the following expression evaluates as `long`:  \n  \n```csharp  \n898L + 88  \n```  \n  \n For information on arithmetic expressions with mixed floating-point types and integral types, see [float](../../../csharp/language-reference/keywords/float.md) and [double](../../../csharp/language-reference/keywords/double.md).  \n  \n## Conversions  \n There is a predefined implicit conversion from `long` to [float](../../../csharp/language-reference/keywords/float.md), [double](../../../csharp/language-reference/keywords/double.md), or [decimal](../../../csharp/language-reference/keywords/decimal.md). Otherwise a cast must be used. For example, the following statement will produce a compilation error without an explicit cast:  \n  \n```csharp  \nint x = 8L;        // Error: no implicit conversion from long to int  \nint x = (int)8L;   // OK: explicit conversion to int  \n```  \n  \n There is a predefined implicit conversion from [sbyte](../../../csharp/language-reference/keywords/sbyte.md), [byte](../../../csharp/language-reference/keywords/byte.md), [short](../../../csharp/language-reference/keywords/short.md), [ushort](../../../csharp/language-reference/keywords/ushort.md), [int](../../../csharp/language-reference/keywords/int.md), [uint](../../../csharp/language-reference/keywords/uint.md), or [char](../../../csharp/language-reference/keywords/char.md) to `long`.  \n  \n Notice also that there is no implicit conversion from floating-point types to `long`. For example, the following statement generates a compiler error unless an explicit cast is used:  \n  \n```csharp  \nlong x = 3.0;         // Error: no implicit conversion from double  \nlong y = (long)3.0;   // OK: explicit conversion  \n```  \n  \n## C# Language Specification  \n [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n## See Also  \n <xref:System.Int64>   \n [C# Reference](../../../csharp/language-reference/index.md)   \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [C# Keywords](../../../csharp/language-reference/keywords/index.md)   \n [Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md)   \n [Built-In Types Table](../../../csharp/language-reference/keywords/built-in-types-table.md)   \n [Implicit Numeric Conversions Table](../../../csharp/language-reference/keywords/implicit-numeric-conversions-table.md)   \n [Explicit Numeric Conversions Table](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md)","nodes":[{"pos":[4,560],"embed":true,"restype":"x-metadata","content":"title: \"long (C# Reference) | Microsoft Docs\"\nms.date: \"2017-03-14\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"long_CSharpKeyword\"\n  - \"long\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"long keyword [C#]\"\nms.assetid: f9b24319-1f39-48be-a42b-d528ee28a7fd\ncaps.latest.revision: 17\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","nodes":[{"content":"long (C# Reference) | Microsoft Docs","nodes":[{"pos":[0,36],"content":"long (C# Reference) | Microsoft Docs","nodes":[{"content":"long (C# Reference) | Microsoft Docs","pos":[0,36]}]}],"path":["title"]}],"yml":true},{"pos":[567,586],"content":"long (C# Reference)","linkify":"long (C# Reference)","nodes":[{"content":"long (C# Reference)","pos":[0,19]}]},{"pos":[588,700],"content":"<ph id=\"ph1\">`long`</ph> denotes an integral type that stores values according to the size and range shown in the following table.","source":"`long` denotes an integral type that stores values according to the size and range shown in the following table."},{"content":"Type","pos":[707,711]},{"content":"Range","pos":[712,717]},{"content":"Size","pos":[718,722]},{"content":".NET Framework type","pos":[723,742]},{"content":"–9,223,372,036,854,775,808 to 9,223,372,036,854,775,807","pos":[818,873]},{"content":"Signed 64-bit integer","pos":[874,895]},{"pos":[950,958],"content":"Literals","linkify":"Literals","nodes":[{"content":"Literals","pos":[0,8]}]},{"pos":[961,1112],"content":"You can declare and initialize a <ph id=\"ph1\">`long`</ph> variable by assigning a decimal literal, a hexadecimal literal, or (starting with C# 7) a binary literal to it.","source":"You can declare and initialize a `long` variable by assigning a decimal literal, a hexadecimal literal, or (starting with C# 7) a binary literal to it."},{"pos":[1115,1269],"content":"In the following example, integers equal to 4,294,967,296 that are represented as decimal, hexadecimal, and binary literals are assigned to <ph id=\"ph1\">`long`</ph> values.","source":"In the following example, integers equal to 4,294,967,296 that are represented as decimal, hexadecimal, and binary literals are assigned to `long` values."},{"pos":[1387,1550],"content":"[!NOTE] \nYou use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal. Decimal literals have no prefix.","leadings":["","> "],"nodes":[{"content":"You use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal. Decimal literals have no prefix.","pos":[9,161],"nodes":[{"content":"You use the prefix <ph id=\"ph1\">`0x`</ph> or <ph id=\"ph2\">`0X`</ph> to denote a hexadecimal literal and the prefix <ph id=\"ph3\">`0b`</ph> or <ph id=\"ph4\">`0B`</ph> to denote a binary literal.","pos":[0,119],"source":"You use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal."},{"content":"Decimal literals have no prefix.","pos":[120,152]}]}]},{"pos":[1553,1697],"content":"Starting with C# 7, you can also use the underscore character, <ph id=\"ph1\">`_`</ph>, as a digit separator to enhance readability, as the following example shows.","source":"Starting with C# 7, you can also use the underscore character, `_`, as a digit separator to enhance readability, as the following example shows."},{"content":"Integer literals can also include a suffix that denotes the type.","pos":[1812,1877]},{"content":"The suffix <ph id=\"ph1\">`L`</ph> denotes a <ph id=\"ph2\">`long`</ph>.","pos":[1878,1910],"source":" The suffix `L` denotes a `long`."},{"content":"The following example uses the <ph id=\"ph1\">`L`</ph> suffix to denote a long integer:","pos":[1911,1978],"source":" The following example uses the `L` suffix to denote a long integer:"},{"pos":[2028,2219],"content":"[!NOTE]\n You can also use the lowercase letter \"l\" as a suffix. However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\" Use \"L\" for clarity.","leadings":["","> "],"nodes":[{"content":"You can also use the lowercase letter \"l\" as a suffix. However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\" Use \"L\" for clarity.","pos":[9,189],"nodes":[{"content":"You can also use the lowercase letter \"l\" as a suffix.","pos":[0,54]},{"content":"However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\"","pos":[55,159]},{"content":"Use \"L\" for clarity.","pos":[160,180]}]}]},{"content":"When you use the suffix <ph id=\"ph1\">`L`</ph>, the type of the literal integer is determined to be either <ph id=\"ph2\">`long`</ph> or <bpt id=\"p1\">[</bpt>ulong<ept id=\"p1\">](../../../csharp/language-reference/keywords/ulong.md)</ept>, depending on its size.","pos":[2226,2409],"source":"When you use the suffix `L`, the type of the literal integer is determined to be either `long` or [ulong](../../../csharp/language-reference/keywords/ulong.md), depending on its size."},{"content":"In this case, it is <ph id=\"ph1\">`long`</ph> because it less than the range of <bpt id=\"p1\">[</bpt>ulong<ept id=\"p1\">](../../../csharp/language-reference/keywords/ulong.md)</ept>.","pos":[2410,2533],"source":" In this case, it is `long` because it less than the range of [ulong](../../../csharp/language-reference/keywords/ulong.md)."},{"content":"A common use of the suffix is to call overloaded methods.","pos":[2540,2597]},{"content":"For example, the following overloaded methods have parameters of type <ph id=\"ph1\">`long`</ph> and <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../../../csharp/language-reference/keywords/int.md)</ept>:","pos":[2598,2737],"source":" For example, the following overloaded methods have parameters of type `long` and [int](../../../csharp/language-reference/keywords/int.md):"},{"pos":[2852,2914],"content":"The <ph id=\"ph1\">`L`</ph> suffix guarantees that the correct overload is called:","source":"The `L` suffix guarantees that the correct overload is called:"},{"content":"If an integer literal has no suffix, its type is the first of the following types in which its value can be represented:","pos":[3069,3189]},{"pos":[3195,3208],"content":"<bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](int.md)</ept>","source":"[int](int.md)"},{"pos":[3212,3271],"content":"<bpt id=\"p1\">[</bpt>uint<ept id=\"p1\">](../../../csharp/language-reference/keywords/uint.md)</ept>","source":"[uint](../../../csharp/language-reference/keywords/uint.md)"},{"pos":[3285,3346],"content":"<bpt id=\"p1\">[</bpt>ulong<ept id=\"p1\">](../../../csharp/language-reference/keywords/ulong.md)</ept>","source":"[ulong](../../../csharp/language-reference/keywords/ulong.md)"},{"pos":[3349,3646],"content":"The literal 4294967296 in the previous examples is of type <ph id=\"ph1\">`long`</ph>, because it exceeds the range of <bpt id=\"p1\">[</bpt>uint<ept id=\"p1\">](../../../csharp/language-reference/keywords/uint.md)</ept> (see <bpt id=\"p2\">[</bpt>Integral Types Table<ept id=\"p2\">](../../../csharp/language-reference/keywords/integral-types-table.md)</ept> for the storage sizes of integral types).","source":"The literal 4294967296 in the previous examples is of type `long`, because it exceeds the range of [uint](../../../csharp/language-reference/keywords/uint.md) (see [Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md) for the storage sizes of integral types)."},{"content":"If you use the <ph id=\"ph1\">`long`</ph> type with other integral types in the same expression, the expression is evaluated as <ph id=\"ph2\">`long`</ph> (or <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](../../../csharp/language-reference/keywords/bool.md)</ept> in the case of relational or Boolean expressions).","pos":[3653,3882],"source":"If you use the `long` type with other integral types in the same expression, the expression is evaluated as `long` (or [bool](../../../csharp/language-reference/keywords/bool.md) in the case of relational or Boolean expressions)."},{"content":"For example, the following expression evaluates as <ph id=\"ph1\">`long`</ph>:","pos":[3883,3941],"source":" For example, the following expression evaluates as `long`:"},{"pos":[3981,4209],"content":"For information on arithmetic expressions with mixed floating-point types and integral types, see <bpt id=\"p1\">[</bpt>float<ept id=\"p1\">](../../../csharp/language-reference/keywords/float.md)</ept> and <bpt id=\"p2\">[</bpt>double<ept id=\"p2\">](../../../csharp/language-reference/keywords/double.md)</ept>.","source":"For information on arithmetic expressions with mixed floating-point types and integral types, see [float](../../../csharp/language-reference/keywords/float.md) and [double](../../../csharp/language-reference/keywords/double.md)."},{"pos":[4218,4229],"content":"Conversions","linkify":"Conversions","nodes":[{"content":"Conversions","pos":[0,11]}]},{"content":"There is a predefined implicit conversion from <ph id=\"ph1\">`long`</ph> to <bpt id=\"p1\">[</bpt>float<ept id=\"p1\">](../../../csharp/language-reference/keywords/float.md)</ept>, <bpt id=\"p2\">[</bpt>double<ept id=\"p2\">](../../../csharp/language-reference/keywords/double.md)</ept>, or <bpt id=\"p3\">[</bpt>decimal<ept id=\"p3\">](../../../csharp/language-reference/keywords/decimal.md)</ept>.","pos":[4233,4487],"source":"There is a predefined implicit conversion from `long` to [float](../../../csharp/language-reference/keywords/float.md), [double](../../../csharp/language-reference/keywords/double.md), or [decimal](../../../csharp/language-reference/keywords/decimal.md)."},{"content":"Otherwise a cast must be used.","pos":[4488,4518]},{"content":"For example, the following statement will produce a compilation error without an explicit cast:","pos":[4519,4614]},{"pos":[4768,5260],"content":"There is a predefined implicit conversion from <bpt id=\"p1\">[</bpt>sbyte<ept id=\"p1\">](../../../csharp/language-reference/keywords/sbyte.md)</ept>, <bpt id=\"p2\">[</bpt>byte<ept id=\"p2\">](../../../csharp/language-reference/keywords/byte.md)</ept>, <bpt id=\"p3\">[</bpt>short<ept id=\"p3\">](../../../csharp/language-reference/keywords/short.md)</ept>, <bpt id=\"p4\">[</bpt>ushort<ept id=\"p4\">](../../../csharp/language-reference/keywords/ushort.md)</ept>, <bpt id=\"p5\">[</bpt>int<ept id=\"p5\">](../../../csharp/language-reference/keywords/int.md)</ept>, <bpt id=\"p6\">[</bpt>uint<ept id=\"p6\">](../../../csharp/language-reference/keywords/uint.md)</ept>, or <bpt id=\"p7\">[</bpt>char<ept id=\"p7\">](../../../csharp/language-reference/keywords/char.md)</ept> to <ph id=\"ph1\">`long`</ph>.","source":"There is a predefined implicit conversion from [sbyte](../../../csharp/language-reference/keywords/sbyte.md), [byte](../../../csharp/language-reference/keywords/byte.md), [short](../../../csharp/language-reference/keywords/short.md), [ushort](../../../csharp/language-reference/keywords/ushort.md), [int](../../../csharp/language-reference/keywords/int.md), [uint](../../../csharp/language-reference/keywords/uint.md), or [char](../../../csharp/language-reference/keywords/char.md) to `long`."},{"content":"Notice also that there is no implicit conversion from floating-point types to <ph id=\"ph1\">`long`</ph>.","pos":[5267,5352],"source":"Notice also that there is no implicit conversion from floating-point types to `long`."},{"content":"For example, the following statement generates a compiler error unless an explicit cast is used:","pos":[5353,5449]},{"pos":[5599,5624],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[5738,5746],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Int64&gt;</ph>","pos":[5750,5769],"source":"<xref:System.Int64> "},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5774,5834],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5838,5905],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5909,5977],"source":"[C# Keywords](../../../csharp/language-reference/keywords/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Integral Types Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/integral-types-table.md)</ept><ph id=\"ph1\"> </ph>","pos":[5981,6073],"source":"[Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md) "},{"content":"<bpt id=\"p1\">[</bpt>Built-In Types Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/built-in-types-table.md)</ept><ph id=\"ph1\"> </ph>","pos":[6077,6169],"source":"[Built-In Types Table](../../../csharp/language-reference/keywords/built-in-types-table.md) "},{"content":"<bpt id=\"p1\">[</bpt>Implicit Numeric Conversions Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/implicit-numeric-conversions-table.md)</ept><ph id=\"ph1\"> </ph>","pos":[6173,6293],"source":"[Implicit Numeric Conversions Table](../../../csharp/language-reference/keywords/implicit-numeric-conversions-table.md) "},{"content":"<bpt id=\"p1\">[</bpt>Explicit Numeric Conversions Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md)</ept>","pos":[6297,6416],"source":"[Explicit Numeric Conversions Table](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md)"}]}