{"content":"---\ntitle: \"How to: Add and Remove Items from a ConcurrentDictionary | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"thread-safe collections, concurrent dictionary\"\nms.assetid: 81b64b95-13f7-4532-9249-ab532f629598\ncaps.latest.revision: 13\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# How to: Add and Remove Items from a ConcurrentDictionary\nThis example shows how to add, retrieve, update, and remove items from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=fullName>. This collection class is a thread-safe implementation. We recommend that you use it whenever multiple threads might be attempting to access the elements concurrently.  \n  \n <xref:System.Collections.Concurrent.ConcurrentDictionary%602> provides several convenience methods that make it unnecessary for code to first check whether a key exists before it attempts to add or remove data. The following table lists these convenience methods and describes when to use them.  \n  \n|Method|Use when…|  \n|------------|---------------|  \n|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A>|You want to add a new value for a specified key and, if the key already exists, you want to replace its value.|  \n|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>|You want to retrieve the existing value for a specified key and, if the key does not exist, you want to specify a key/value pair.|  \n|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A>, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryGetValue%2A> , <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> , <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A>|You want to add, get, update, or remove a key/value pair, and, if the key already exists or the attempt fails for any other reason, you want to take some alternative action.|  \n  \n## Example  \n The following example uses two <xref:System.Threading.Tasks.Task> instances to add some elements to a <xref:System.Collections.Concurrent.ConcurrentDictionary%602> concurrently, and then outputs all of the contents to show that the elements were added successfully. The example also shows how to use the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A>, <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A>, and <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> methods to add, update, and retrieve  items from the collection.  \n  \n [!code-csharp[CDS#16](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds/cs/cds_dictionaryhowto.cs#16)]\n [!code-vb[CDS#16](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds/vb/cds_concdict.vb#16)]  \n  \n <xref:System.Collections.Concurrent.ConcurrentDictionary%602> is designed for multithreaded scenarios. You do not have to use locks in your code to add or remove items from the collection. However, it is always possible for one thread to retrieve a value, and another thread to immediately update the collection by giving the same key a new value.  \n  \n Also, although all methods of <xref:System.Collections.Concurrent.ConcurrentDictionary%602> are thread-safe, not all methods are atomic, specifically <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> and <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A>. The user delegate that is passed to these methods is invoked outside of the dictionary's internal lock. (This is done to prevent unknown code from blocking all threads.) Therefore it is possible for this sequence of events to occur:  \n  \n 1\\) threadA calls <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>, finds no item and creates a new item to Add by invoking the valueFactory delegate.  \n  \n 2\\) threadB calls <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> concurrently, its valueFactory delegate is invoked and it arrives at the internal lock before threadA, and so its new key-value pair is added to the dictionary.  \n  \n 3\\) threadA's user delegate completes, and the thread arrives at the lock, but now sees that the item exists already  \n  \n 4\\) threadA performs a \"Get\", and returns the data that was previously added by threadB.  \n  \n Therefore, it is not guaranteed that the data that is returned by <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is the same data that was created by the thread's valueFactory. A similar sequence of events can occur when <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is called.  \n  \n## See Also  \n <xref:System.Collections.Concurrent?displayProperty=fullName>   \n [Thread-Safe Collections](../../../../docs/standard/collections/thread-safe/index.md)","nodes":[{"pos":[4,442],"embed":true,"restype":"x-metadata","content":"title: \"How to: Add and Remove Items from a ConcurrentDictionary | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"thread-safe collections, concurrent dictionary\"\nms.assetid: 81b64b95-13f7-4532-9249-ab532f629598\ncaps.latest.revision: 13\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","nodes":[{"content":"How to: Add and Remove Items from a ConcurrentDictionary | Microsoft Docs","nodes":[{"pos":[0,73],"content":"How to: Add and Remove Items from a ConcurrentDictionary | Microsoft Docs","nodes":[{"content":"How to: Add and Remove Items from a ConcurrentDictionary | Microsoft Docs","pos":[0,73]}]}],"path":["title"]}],"yml":true},{"pos":[449,505],"content":"How to: Add and Remove Items from a ConcurrentDictionary","linkify":"How to: Add and Remove Items from a ConcurrentDictionary","nodes":[{"content":"How to: Add and Remove Items from a ConcurrentDictionary","pos":[0,56]}]},{"content":"This example shows how to add, retrieve, update, and remove items from a <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=fullName&gt;</ph>.","pos":[506,666],"source":"This example shows how to add, retrieve, update, and remove items from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=fullName>."},{"content":"This collection class is a thread-safe implementation.","pos":[667,721]},{"content":"We recommend that you use it whenever multiple threads might be attempting to access the elements concurrently.","pos":[722,833]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> provides several convenience methods that make it unnecessary for code to first check whether a key exists before it attempts to add or remove data.","pos":[840,1050],"source":"<xref:System.Collections.Concurrent.ConcurrentDictionary%602> provides several convenience methods that make it unnecessary for code to first check whether a key exists before it attempts to add or remove data."},{"content":"The following table lists these convenience methods and describes when to use them.","pos":[1051,1134]},{"content":"Method","pos":[1141,1147]},{"content":"Use when…","pos":[1148,1157]},{"content":"You want to add a new value for a specified key and, if the key already exists, you want to replace its value.","pos":[1272,1382]},{"content":"You want to retrieve the existing value for a specified key and, if the key does not exist, you want to specify a key/value pair.","pos":[1461,1590]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryGetValue%2A&gt;</ph> , <ph id=\"ph3\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A&gt;</ph> , <ph id=\"ph4\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A&gt;</ph>","pos":[1595,1898],"source":"<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A>, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryGetValue%2A> , <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> , <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A>"},{"content":"You want to add, get, update, or remove a key/value pair, and, if the key already exists or the attempt fails for any other reason, you want to take some alternative action.","pos":[1899,2072]},{"pos":[2082,2089],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example uses two <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances to add some elements to a <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> concurrently, and then outputs all of the contents to show that the elements were added successfully.","pos":[2093,2358],"source":"The following example uses two <xref:System.Threading.Tasks.Task> instances to add some elements to a <xref:System.Collections.Concurrent.ConcurrentDictionary%602> concurrently, and then outputs all of the contents to show that the elements were added successfully."},{"content":"The example also shows how to use the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> methods to add, update, and retrieve  items from the collection.","pos":[2359,2682],"source":" The example also shows how to use the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A>, <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A>, and <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> methods to add, update, and retrieve  items from the collection."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CDS#16<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds/cs/cds_dictionaryhowto.cs#16)</ept><ept id=\"p1\">]</ept>","pos":[2689,2798],"source":"[!code-csharp[CDS#16](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds/cs/cds_dictionaryhowto.cs#16)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CDS#16<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds/vb/cds_concdict.vb#16)</ept><ept id=\"p1\">]</ept>","pos":[2800,2903],"source":"[!code-vb[CDS#16](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds/vb/cds_concdict.vb#16)]"},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> is designed for multithreaded scenarios.","pos":[2910,3012],"source":"<xref:System.Collections.Concurrent.ConcurrentDictionary%602> is designed for multithreaded scenarios."},{"content":"You do not have to use locks in your code to add or remove items from the collection.","pos":[3013,3098]},{"content":"However, it is always possible for one thread to retrieve a value, and another thread to immediately update the collection by giving the same key a new value.","pos":[3099,3257]},{"content":"Also, although all methods of <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> are thread-safe, not all methods are atomic, specifically <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph>.","pos":[3264,3569],"source":"Also, although all methods of <xref:System.Collections.Concurrent.ConcurrentDictionary%602> are thread-safe, not all methods are atomic, specifically <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> and <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A>."},{"content":"The user delegate that is passed to these methods is invoked outside of the dictionary's internal lock.","pos":[3570,3673]},{"content":"(This is done to prevent unknown code from blocking all threads.) Therefore it is possible for this sequence of events to occur:","pos":[3674,3802]},{"content":"1<ph id=\"ph1\">\\)</ph> threadA calls <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph>, finds no item and creates a new item to Add by invoking the valueFactory delegate.","pos":[3809,3984],"source":"1\\) threadA calls <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>, finds no item and creates a new item to Add by invoking the valueFactory delegate."},{"content":"2<ph id=\"ph1\">\\)</ph> threadB calls <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> concurrently, its valueFactory delegate is invoked and it arrives at the internal lock before threadA, and so its new key-value pair is added to the dictionary.","pos":[3991,4243],"source":"2\\) threadB calls <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> concurrently, its valueFactory delegate is invoked and it arrives at the internal lock before threadA, and so its new key-value pair is added to the dictionary."},{"content":"3<ph id=\"ph1\">\\)</ph> threadA's user delegate completes, and the thread arrives at the lock, but now sees that the item exists already","pos":[4250,4366],"source":"3\\) threadA's user delegate completes, and the thread arrives at the lock, but now sees that the item exists already"},{"content":"4<ph id=\"ph1\">\\)</ph> threadA performs a \"Get\", and returns the data that was previously added by threadB.","pos":[4373,4461],"source":"4\\) threadA performs a \"Get\", and returns the data that was previously added by threadB."},{"content":"Therefore, it is not guaranteed that the data that is returned by <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> is the same data that was created by the thread's valueFactory.","pos":[4468,4671],"source":"Therefore, it is not guaranteed that the data that is returned by <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is the same data that was created by the thread's valueFactory."},{"content":"A similar sequence of events can occur when <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> is called.","pos":[4672,4803],"source":" A similar sequence of events can occur when <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is called."},{"pos":[4812,4820],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent?displayProperty=fullName&gt;</ph>","pos":[4824,4885],"source":"<xref:System.Collections.Concurrent?displayProperty=fullName> "},{"content":"<bpt id=\"p1\">[</bpt>Thread-Safe Collections<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/index.md)</ept>","pos":[4890,4975],"source":"[Thread-Safe Collections](../../../../docs/standard/collections/thread-safe/index.md)"}]}