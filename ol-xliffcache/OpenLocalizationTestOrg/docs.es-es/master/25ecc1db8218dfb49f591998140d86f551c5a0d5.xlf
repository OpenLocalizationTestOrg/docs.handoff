<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="large-data-and-streaming.md" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25ecc1db8218dfb49f591998140d86f551c5a0d5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\large-data-and-streaming.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c28e8334135913a325897227d68f2e9e46655364</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">249d97a67845612151decb1bef599e75ee6f2d1c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Large Data and Streaming</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Large Data and Streaming</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Because XML data is commonly encoded in the standard text format defined in the <bpt id="p1">[</bpt>XML 1.0 specification<ept id="p1">](https://go.microsoft.com/fwlink/?LinkId=94838)</ept>, connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Basic Considerations</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Encoding Data: Text vs. Binary</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The payload then follows this common metadata block declaration with minimal further overhead.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For more information, see the "Encodings" section later in this topic.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Binary Content</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For more information, see the "Encodings" section later in this topic.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Large Data Content</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>By default, WCF processes messages in <bpt id="p1">*</bpt>buffered mode<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This means that the entire content of a message is present in memory before it is sent or after it is received.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The strategy to deal with large payloads is streaming.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Cannot be easily broken up into a message sequence.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Must be delivered in a timely manner.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Are not available in their entirety when the transfer is initiated.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see the "Streaming Data" section later in this topic.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When sending large amounts of data you will need to set the <ph id="ph1">`maxAllowedContentLength`</ph> IIS setting (for more information see <bpt id="p1">[</bpt>Configuring IIS Request Limits<ept id="p1">](https://go.microsoft.com/fwlink/?LinkId=253165)</ept>) and the <ph id="ph2">`maxReceivedMessageSize`</ph> binding setting (for example <bpt id="p2">[</bpt>System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize<ept id="p2">](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A)</ept> or <ph id="ph3">&lt;xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`maxAllowedContentLength`</ph> property defaults to 28.6 M and the <ph id="ph2">`maxReceivedMessageSize`</ph> property defaults to 64KB.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Encodings</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>encoding<ept id="p1">*</ept> defines a set of rules about how to present messages on the wire.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>encoder<ept id="p1">*</ept> implements such an encoding and is responsible, on the sender side, for turning an in-memory <ph id="ph1">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> into a byte stream or byte buffer that can be sent across the network.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net* prefix use the binary encoder (by including the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement&gt;</ph> class) while the <ph id="ph2">&lt;xref:System.ServiceModel.BasicHttpBinding&gt;</ph> and <ph id="ph3">&lt;xref:System.ServiceModel.WSHttpBinding&gt;</ph> classes use the text message encoder (by means of the <ph id="ph4">&lt;xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement&gt;</ph> class) by default.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Encoder binding element</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType&gt;</ph> property of a message is set to <ph id="ph2">&lt;xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType&gt;</ph>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>See Enabling MTOM later in this section.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The binary message encoder is the default encoder for the Net* bindings and the appropriate choice whenever both communicating parties are based on WCF.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement&gt;</ph> into a custom binding that uses the <ph id="ph2">&lt;xref:System.ServiceModel.Channels.HttpTransportBindingElement&gt;</ph> class for the transport.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Enabling MTOM</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <ph id="ph1">&lt;xref:System.ServiceModel.BasicHttpBinding&gt;</ph> or <ph id="ph2">&lt;xref:System.ServiceModel.WSHttpBinding&gt;</ph> bindings by setting the respective <ph id="ph3">`MessageEncoding`</ph> property to <ph id="ph4">&lt;xref:System.ServiceModel.WSMessageEncoding.Mtom&gt;</ph> or by composing the <ph id="ph5">&lt;xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement&gt;</ph> into a <ph id="ph6">&lt;xref:System.ServiceModel.Channels.CustomBinding&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The following example code, extracted from the <bpt id="p1">[</bpt>MTOM Encoding<ept id="p1">](../../../../docs/framework/wcf/samples/mtom-encoding.md)</ept> sample demonstrates how to enable MTOM in configuration.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Related control functionality should reside on a separate contract.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Using the MTOM encoder conforms with all other WCF features.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Note that it may not be possible to observe this rule in all cases, such as when session support is required.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Programming Model</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The difference is in how WCF handles the data based on their data types.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When using MTOM, the preceding data contract is serialized according to the following rules:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`binaryBuffer`</ph> is not <ph id="ph2">`null`</ph> and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If the threshold is not exceeded, the data is encoded as Base64.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>You should not be using <ph id="ph1">&lt;xref:System.IO.Stream?displayProperty=nameWithType&gt;</ph> derived types inside of data contracts.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Streaming Data</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Restrictions</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You cannot use a significant number of WCF features when streaming is enabled:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Streaming is only available with the following system-defined bindings:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Because the underlying transports of <ph id="ph1">&lt;xref:System.ServiceModel.NetTcpBinding&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.NetNamedPipeBinding&gt;</ph> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <ph id="ph1">&lt;xref:System.ServiceModel.NetMsmqBinding&gt;</ph> or the <ph id="ph2">&lt;xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Streaming is also not available when using the Peer Channel transport, so is not available with the <ph id="ph1">&lt;xref:System.ServiceModel.NetPeerTcpBinding&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Streaming and Sessions</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You may get unexpected behavior when streaming calls with a session-based binding.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>MaxConcurrentSessions has no effect in this case because there is only one "session" available.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Enabling Streaming</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>You can enable streaming in the following ways:</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Send and accept requests in streaming mode, and accept and return responses in buffered mode (<ph id="ph1">&lt;xref:System.ServiceModel.TransferMode.StreamedRequest&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Send and accept requests in buffered mode, and accept and return responses in streamed mode (<ph id="ph1">&lt;xref:System.ServiceModel.TransferMode.StreamedResponse&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Send and receive requests and responses in streamed mode in both directions.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">&lt;xref:System.ServiceModel.TransferMode.Streamed&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You can disable streaming by setting the transfer mode to <ph id="ph1">&lt;xref:System.ServiceModel.TransferMode.Buffered&gt;</ph>, which is the default setting on all bindings.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following code shows how to set the transfer mode in configuration.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>When you instantiate your binding in code, you must set the respective <ph id="ph1">`TransferMode`</ph> property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Enabling Asynchronous Streaming</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To enable asynchronous streaming, add the  <ph id="ph1">&lt;xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior&gt;</ph> endpoint behavior to the service host and set its <ph id="ph2">&lt;xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A&gt;</ph> property to <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>We have also added the capability of true asynchronous streaming on the send side.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In these scenarios we now do not block individual threads on the service per client.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>This ensures that the service is able to process many more clients thereby improving the scalability of the service.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Programming Model for Streamed Transfers</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The programming model for streaming is straightforward.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For receiving streamed data, specify an operation contract that has a single <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> typed input parameter.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For returning streamed data, return a <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> reference.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The operation <ph id="ph1">`Echo`</ph> in the preceding example receives and returns a stream and should therefore be used on a binding with <ph id="ph2">&lt;xref:System.ServiceModel.TransferMode.Streamed&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For the operation <ph id="ph1">`RequestInfo`</ph>, <ph id="ph2">&lt;xref:System.ServiceModel.TransferMode.StreamedResponse&gt;</ph> is best suited, because it only returns a <ph id="ph3">&lt;xref:System.IO.Stream&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The one-way operation is best suited for <ph id="ph1">&lt;xref:System.ServiceModel.TransferMode.StreamedRequest&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Note that adding a second parameter to the following <ph id="ph1">`Echo`</ph> or <ph id="ph2">`ProvideInfo`</ph> operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Only operations with a single input stream parameter are compatible with end-to-end request streaming.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This rule similarly applies to message contracts.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If you want to communicate additional information with the stream, this information must be a carried in message headers.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The message body is exclusively reserved for the stream content.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When sending a message (returning a value or invoking an operation), you can pass a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>To transfer streamed data for the source that no such pre-built <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Special Security Considerations for Large Data</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.BasicHttpBinding&gt;</ph>, for example, exposes a <bpt id="p1">[</bpt>System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize<ept id="p1">](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A)</ept> property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>This unit is set in bytes with a default value of 65,536 bytes.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>When streaming is enabled, the <ph id="ph1">`MaxReceivedMessageSize`</ph> may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If WCF is forced to buffer the message, a memory overflow occurs.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Therefore, restricting the maximum incoming message size is not enough in this case.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MaxBufferSize`</ph> property is required to constrain the memory that WCF buffers.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>It is important to set this to a safe value (or keep it at the default value) when streaming.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Then you would set the <ph id="ph1">`MaxReceivedMessageSize`</ph> to 4 GB and <ph id="ph2">`MaxBufferSize`</ph> to 64 KB.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>For more information about additional security considerations, see <bpt id="p1">[</bpt>Security Considerations for Data<ept id="p1">](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The decision to use either buffered or streamed transfers is a local decision of the endpoint.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Setting the transfer mode is not reflected in the description of the service interface.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Enable Streaming<ept id="p1">](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>