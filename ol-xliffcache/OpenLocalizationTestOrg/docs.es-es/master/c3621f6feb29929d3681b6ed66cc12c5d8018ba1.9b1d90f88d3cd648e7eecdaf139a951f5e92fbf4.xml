{"content":"---\ntitle: Implicitly typed lambda expressions\ndescription: Implicitly typed lambda expressions\nkeywords: .NET, .NET Core\nauthor: BillWagner\nms.author: wiwagn\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: a3851da9-e018-4389-9922-233db7d0f841\n---\n\n# Implicitly typed lambda expressions\n\nI'm not using `var` to declare this expression tree. You can't use\nan implicitly typed variable declaration to declare a lambda expression.\nIt creates a circular logic problem for the compiler. The `var` declaration\ntells the compiler to figure out the type of the variable from the type\nof expression on the right hand side of the assignment operator. A lambda\nexpression does not have a compile time type, but is convertible to any\nmatching delegate or expression type. When you assign a lambda expression\nto a variable of a delegate or expression type, you tell the compiler to\ntry and convert the lambda expression into an expression or delegate that\nmatches the signature of the 'assigned to' variable. The compiler must\ntry to make the thing on the right hand side of the assignment match\nthe type on the left hand side of the assignment. \n\nBoth sides of the assignment can't be telling the compiler to look at the\nobject on the other side of the assignment operator and see if my type\nmatches.\n\nYou can get even more details on why the C# language specifies that behavior\nby reading [this article](http://download.microsoft.com/download/5/4/B/54B83DFE-D7AA-4155-9687-B0CF58FF65D7/type-inference.pdf) (PDF Download)\n\n\n","nodes":[{"pos":[11,46],"content":"Implicitly typed lambda expressions","needQuote":true,"needEscape":true,"nodes":[{"content":"Implicitly typed lambda expressions","pos":[0,35]}]},{"pos":[60,95],"content":"Implicitly typed lambda expressions","needQuote":true,"needEscape":true,"nodes":[{"content":"Implicitly typed lambda expressions","pos":[0,35]}]},{"pos":[106,121],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[316,351],"content":"Implicitly typed lambda expressions","linkify":"Implicitly typed lambda expressions","nodes":[{"content":"Implicitly typed lambda expressions","pos":[0,35]}]},{"content":"I'm not using <ph id=\"ph1\">`var`</ph> to declare this expression tree.","pos":[353,405],"source":"I'm not using `var` to declare this expression tree."},{"content":"You can't use an implicitly typed variable declaration to declare a lambda expression.","pos":[406,492],"source":" You can't use\nan implicitly typed variable declaration to declare a lambda expression."},{"content":"It creates a circular logic problem for the compiler.","pos":[493,546],"source":"\nIt creates a circular logic problem for the compiler."},{"content":"The <ph id=\"ph1\">`var`</ph> declaration tells the compiler to figure out the type of the variable from the type of expression on the right hand side of the assignment operator.","pos":[547,705],"source":" The `var` declaration\ntells the compiler to figure out the type of the variable from the type\nof expression on the right hand side of the assignment operator."},{"content":"A lambda expression does not have a compile time type, but is convertible to any matching delegate or expression type.","pos":[706,824],"source":" A lambda\nexpression does not have a compile time type, but is convertible to any\nmatching delegate or expression type."},{"content":"When you assign a lambda expression to a variable of a delegate or expression type, you tell the compiler to try and convert the lambda expression into an expression or delegate that matches the signature of the 'assigned to' variable.","pos":[825,1060],"source":" When you assign a lambda expression\nto a variable of a delegate or expression type, you tell the compiler to\ntry and convert the lambda expression into an expression or delegate that\nmatches the signature of the 'assigned to' variable."},{"content":"The compiler must try to make the thing on the right hand side of the assignment match the type on the left hand side of the assignment.","pos":[1061,1197],"source":" The compiler must\ntry to make the thing on the right hand side of the assignment match\nthe type on the left hand side of the assignment."},{"pos":[1200,1353],"content":"Both sides of the assignment can't be telling the compiler to look at the object on the other side of the assignment operator and see if my type matches.","source":"Both sides of the assignment can't be telling the compiler to look at the\nobject on the other side of the assignment operator and see if my type\nmatches."},{"pos":[1355,1574],"content":"You can get even more details on why the C# language specifies that behavior by reading <bpt id=\"p1\">[</bpt>this article<ept id=\"p1\">](http://download.microsoft.com/download/5/4/B/54B83DFE-D7AA-4155-9687-B0CF58FF65D7/type-inference.pdf)</ept> (PDF Download)","source":"You can get even more details on why the C# language specifies that behavior\nby reading [this article](http://download.microsoft.com/download/5/4/B/54B83DFE-D7AA-4155-9687-B0CF58FF65D7/type-inference.pdf) (PDF Download)"}]}