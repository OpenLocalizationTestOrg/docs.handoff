{"content":"---\ntitle: \"Dispose Pattern | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"Dispose method\"\n  - \"class library design guidelines [.NET Framework], Dispose method\"\n  - \"class library design guidelines [.NET Framework], Finalize method\"\n  - \"customizing Dispose method name\"\n  - \"Finalize method\"\nms.assetid: 31a6c13b-d6a2-492b-9a9f-e5238c983bcb\ncaps.latest.revision: 22\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Dispose Pattern\nAll programs acquire one or more system resources, such as memory, system handles, or database connections, during the course of their execution. Developers have to be careful when using such system resources, because they must be released after they have been acquired and used.  \n  \n The CLR provides support for automatic memory management. Managed memory (memory allocated using the C# operator `new`) does not need to be explicitly released. It is released automatically by the garbage collector (GC). This frees developers from the tedious and difficult task of releasing memory and has been one of the main reasons for the unprecedented productivity afforded by the .NET Framework.  \n  \n Unfortunately, managed memory is just one of many types of system resources. Resources other than managed memory still need to be released explicitly and are referred to as unmanaged resources. The GC was specifically not designed to manage such unmanaged resources, which means that the responsibility for managing unmanaged resources lies in the hands of the developers.  \n  \n The CLR provides some help in releasing unmanaged resources. <xref:System.Object?displayProperty=fullName> declares a virtual method <xref:System.Object.Finalize%2A> (also called the finalizer) that is called by the GC before the object’s memory is reclaimed by the GC and can be overridden to release unmanaged resources. Types that override the finalizer are referred to as finalizable types.  \n  \n Although finalizers are effective in some cleanup scenarios, they have two significant drawbacks:  \n  \n-   The finalizer is called when the GC detects that an object is eligible for collection. This happens at some undetermined period of time after the resource is not needed anymore. The delay between when the developer could or would like to release the resource and the time when the resource is actually released by the finalizer might be unacceptable in programs that acquire many scarce resources (resources that can be easily exhausted) or in cases in which resources are costly to keep in use (e.g., large unmanaged memory buffers).  \n  \n-   When the CLR needs to call a finalizer, it must postpone collection of the object’s memory until the next round of garbage collection (the finalizers run between collections). This means that the object’s memory (and all objects it refers to) will not be released for a longer period of time.  \n  \n Therefore, relying exclusively on finalizers might not be appropriate in many scenarios when it is important to reclaim unmanaged resources as quickly as possible, when dealing with scarce resources, or in highly performant scenarios in which the added GC overhead of finalization is unacceptable.  \n  \n The Framework provides the <xref:System.IDisposable?displayProperty=fullName> interface that should be implemented to provide the developer a manual way to release unmanaged resources as soon as they are not needed. It also provides the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method that can tell the GC that an object was manually disposed of and does not need to be finalized anymore, in which case the object’s memory can be reclaimed earlier. Types that implement the `IDisposable` interface are referred to as disposable types.  \n  \n The Dispose Pattern is intended to standardize the usage and implementation of finalizers and the `IDisposable` interface.  \n  \n The main motivation for the pattern is to reduce the complexity of the implementation of the <xref:System.Object.Finalize%2A> and the <xref:System.IDisposable.Dispose%2A> methods. The complexity stems from the fact that the methods share some but not all code paths (the differences are described later in the chapter). In addition, there are historical reasons for some elements of the pattern related to the evolution of language support for deterministic resource management.  \n  \n **✓ DO** implement the Basic Dispose Pattern on types containing instances of disposable types. See the [Basic Dispose Pattern](#basic_pattern) section for details on the basic pattern.  \n  \n If a type is responsible for the lifetime of other disposable objects, developers need a way to dispose of them, too. Using the container’s `Dispose` method is a convenient way to make this possible.  \n  \n **✓ DO** implement the Basic Dispose Pattern and provide a finalizer on types holding resources that need to be freed explicitly and that do not have finalizers.  \n  \n For example, the pattern should be implemented on types storing unmanaged memory buffers. The [Finalizable Types](#finalizable_types) section discusses guidelines related to implementing finalizers.  \n  \n **✓ CONSIDER** implementing the Basic Dispose Pattern on classes that themselves don’t hold unmanaged resources or disposable objects but are likely to have subtypes that do.  \n  \n A great example of this is the <xref:System.IO.Stream?displayProperty=fullName> class. Although it is an abstract base class that doesn’t hold any resources, most of its subclasses do and because of this, it implements this pattern.  \n  \n<a name=\"basic_pattern\"></a>   \n## Basic Dispose Pattern  \n The basic implementation of the pattern involves implementing the `System.IDisposable` interface and declaring the `Dispose(bool)` method that implements all resource cleanup logic to be shared between the `Dispose` method and the optional finalizer.  \n  \n The following example shows a simple implementation of the basic pattern:  \n  \n```  \npublic class DisposableResourceHolder : IDisposable {  \n  \n    private SafeHandle resource; // handle to a resource  \n  \n    public DisposableResourceHolder(){  \n        this.resource = ... // allocates the resource  \n    }  \n  \n    public void Dispose(){  \n        Dispose(true);  \n        GC.SuppressFinalize(this);  \n    }  \n  \n    protected virtual void Dispose(bool disposing){  \n        if (disposing){  \n            if (resource!= null) resource.Dispose();  \n        }  \n    }  \n}  \n```  \n  \n The Boolean parameter `disposing` indicates whether the method was invoked from the `IDisposable.Dispose` implementation or from the finalizer. The `Dispose(bool)` implementation should check the parameter before accessing other reference objects (e.g., the resource field in the preceding sample). Such objects should only be accessed when the method is called from the `IDisposable.Dispose` implementation (when the `disposing` parameter is equal to true). If the method is invoked from the finalizer (`disposing` is false), other objects should not be accessed. The reason is that objects are finalized in an unpredictable order and so they, or any of their dependencies, might already have been finalized.  \n  \n Also, this section applies to classes with a base that does not already implement the Dispose Pattern. If you are inheriting from a class that already implements the pattern, simply override the `Dispose(bool)` method to provide additional resource cleanup logic.  \n  \n **✓ DO** declare a protected virtual void `Dispose(bool disposing)` method to centralize all logic related to releasing unmanaged resources.  \n  \n All resource cleanup should occur in this method. The method is called from both the finalizer and the `IDisposable.Dispose` method. The parameter will be false if being invoked from inside a finalizer. It should be used to ensure any code running during finalization is not accessing other finalizable objects. Details of implementing finalizers are described in the next section.  \n  \n```  \nprotected virtual void Dispose(bool disposing){  \n    if (disposing){  \n        if (resource!= null) resource.Dispose();  \n    }  \n}  \n```  \n  \n **✓ DO** implement the `IDisposable` interface by simply calling `Dispose(true)` followed by `GC.SuppressFinalize(this)`.  \n  \n The call to `SuppressFinalize` should only occur if `Dispose(true)` executes successfully.  \n  \n```  \npublic void Dispose(){  \n    Dispose(true);  \n    GC.SuppressFinalize(this);  \n}  \n```  \n  \n **X DO NOT** make the parameterless `Dispose` method virtual.  \n  \n The `Dispose(bool)` method is the one that should be overridden by subclasses.  \n  \n```  \n// bad design  \npublic class DisposableResourceHolder : IDisposable {  \n    public virtual void Dispose(){ ... }  \n    protected virtual void Dispose(bool disposing){ ... }  \n}  \n  \n// good design  \npublic class DisposableResourceHolder : IDisposable {  \n    public void Dispose(){ ... }  \n    protected virtual void Dispose(bool disposing){ ... }  \n}  \n```  \n  \n **X DO NOT** declare any overloads of the `Dispose` method other than `Dispose()` and `Dispose(bool)`.  \n  \n `Dispose` should be considered a reserved word to help codify this pattern and prevent confusion among implementers, users, and compilers. Some languages might choose to automatically implement this pattern on certain types.  \n  \n **✓ DO** allow the `Dispose(bool)` method to be called more than once. The method might choose to do nothing after the first call.  \n  \n```  \npublic class DisposableResourceHolder : IDisposable {  \n  \n    bool disposed = false;  \n  \n    protected virtual void Dispose(bool disposing){  \n        if(disposed) return;  \n        // cleanup  \n        ...  \n        disposed = true;  \n    }  \n}  \n```  \n  \n **X AVOID** throwing an exception from within `Dispose(bool)` except under critical situations where the containing process has been corrupted (leaks, inconsistent shared state, etc.).  \n  \n Users expect that a call to `Dispose` will not raise an exception.  \n  \n If `Dispose` could raise an exception, further finally-block cleanup logic will not execute. To work around this, the user would need to wrap every call to `Dispose` (within the finally block!) in a try block, which leads to very complex cleanup handlers. If executing a `Dispose(bool disposing)` method, never throw an exception if disposing is false. Doing so will terminate the process if executing inside a finalizer context.  \n  \n **✓ DO** throw an <xref:System.ObjectDisposedException> from any member that cannot be used after the object has been disposed of.  \n  \n```  \npublic class DisposableResourceHolder : IDisposable {  \n    bool disposed = false;  \n    SafeHandle resource; // handle to a resource  \n  \n    public void DoSomething(){  \n           if(disposed) throw new ObjectDisposedException(...);  \n        // now call some native methods using the resource   \n            ...  \n    }  \n    protected virtual void Dispose(bool disposing){  \n        if(disposed) return;  \n        // cleanup  \n        ...  \n        disposed = true;  \n    }  \n}  \n```  \n  \n **✓ CONSIDER** providing method `Close()`, in addition to the `Dispose()`, if close is standard terminology in the area.  \n  \n When doing so, it is important that you make the `Close` implementation identical to `Dispose` and consider implementing the `IDisposable.Dispose` method explicitly.  \n  \n```  \npublic class Stream : IDisposable {  \n    IDisposable.Dispose(){  \n        Close();  \n    }  \n    public void Close(){  \n        Dispose(true);  \n        GC.SuppressFinalize(this);  \n    }  \n}  \n```  \n  \n<a name=\"finalizable_types\"></a>   \n## Finalizable Types  \n Finalizable types are types that extend the Basic Dispose Pattern by overriding the finalizer and providing finalization code path in the `Dispose(bool)` method.  \n  \n Finalizers are notoriously difficult to implement correctly, primarily because you cannot make certain (normally valid) assumptions about the state of the system during their execution. The following guidelines should be taken into careful consideration.  \n  \n Note that some of the guidelines apply not just to the `Finalize` method, but to any code called from a finalizer. In the case of the Basic Dispose Pattern previously defined, this means logic that executes inside `Dispose(bool disposing)` when the `disposing` parameter is false.  \n  \n If the base class already is finalizable and implements the Basic Dispose Pattern, you should not override `Finalize` again. You should instead just override the `Dispose(bool)` method to provide additional resource cleanup logic.  \n  \n The following code shows an example of a finalizable type:  \n  \n```  \npublic class ComplexResourceHolder : IDisposable {  \n  \n    private IntPtr buffer; // unmanaged memory buffer  \n    private SafeHandle resource; // disposable handle to a resource  \n  \n    public ComplexResourceHolder(){  \n        this.buffer = ... // allocates memory  \n        this.resource = ... // allocates the resource  \n    }  \n  \n    protected virtual void Dispose(bool disposing){  \n            ReleaseBuffer(buffer); // release unmanaged memory  \n        if (disposing){ // release other disposable objects  \n            if (resource!= null) resource.Dispose();  \n        }  \n    }  \n  \n    ~ ComplexResourceHolder(){  \n        Dispose(false);  \n    }  \n  \n    public void Dispose(){  \n        Dispose(true);  \n        GC.SuppressFinalize(this);  \n    }  \n}  \n```  \n  \n **X AVOID** making types finalizable.  \n  \n Carefully consider any case in which you think a finalizer is needed. There is a real cost associated with instances with finalizers, from both a performance and code complexity standpoint. Prefer using resource wrappers such as <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate unmanaged resources where possible, in which case a finalizer becomes unnecessary because the wrapper is responsible for its own resource cleanup.  \n  \n **X DO NOT** make value types finalizable.  \n  \n Only reference types actually get finalized by the CLR, and thus any attempt to place a finalizer on a value type will be ignored. The C# and C++ compilers enforce this rule.  \n  \n **✓ DO** make a type finalizable if the type is responsible for releasing an unmanaged resource that does not have its own finalizer.  \n  \n When implementing the finalizer, simply call `Dispose(false)` and place all resource cleanup logic inside the `Dispose(bool disposing)` method.  \n  \n```  \npublic class ComplexResourceHolder : IDisposable {  \n  \n    ~ ComplexResourceHolder(){  \n        Dispose(false);  \n    }  \n  \n    protected virtual void Dispose(bool disposing){  \n        ...  \n    }  \n}  \n```  \n  \n **✓ DO** implement the Basic Dispose Pattern on every finalizable type.  \n  \n This gives users of the type a means to explicitly perform deterministic cleanup of those same resources for which the finalizer is responsible.  \n  \n **X DO NOT** access any finalizable objects in the finalizer code path, because there is significant risk that they will have already been finalized.  \n  \n For example, a finalizable object A that has a reference to another finalizable object B cannot reliably use B in A’s finalizer, or vice versa. Finalizers are called in a random order (short of a weak ordering guarantee for critical finalization).  \n  \n Also, be aware that objects stored in static variables will get collected at certain points during an application domain unload or while exiting the process. Accessing a static variable that refers to a finalizable object (or calling a static method that might use values stored in static variables) might not be safe if <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> returns true.  \n  \n **✓ DO** make your `Finalize` method protected.  \n  \n C#, C++, and VB.NET developers do not need to worry about this, because the compilers help to enforce this guideline.  \n  \n **X DO NOT** let exceptions escape from the finalizer logic, except for system-critical failures.  \n  \n If an exception is thrown from a finalizer, the CLR will shut down the entire process (as of .NET Framework version 2.0), preventing other finalizers from executing and resources from being released in a controlled manner.  \n  \n **✓ CONSIDER** creating and using a critical finalizable object (a type with a type hierarchy that contains <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>) for situations in which a finalizer absolutely must execute even in the face of forced application domain unloads and thread aborts.  \n  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See Also  \n <xref:System.IDisposable.Dispose%2A?displayProperty=fullName>   \n <xref:System.Object.Finalize%2A?displayProperty=fullName>   \n [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)   \n [Common Design Patterns](../../../docs/standard/design-guidelines/common-design-patterns.md)   \n [Garbage Collection](../../../docs/standard/garbage-collection/index.md)","nodes":[{"pos":[12,44],"content":"Dispose Pattern | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Dispose Pattern | Microsoft Docs","pos":[0,32]}]},{"pos":[639,654],"content":"Dispose Pattern","linkify":"Dispose Pattern","nodes":[{"content":"Dispose Pattern","pos":[0,15]}]},{"content":"All programs acquire one or more system resources, such as memory, system handles, or database connections, during the course of their execution.","pos":[655,800]},{"content":"Developers have to be careful when using such system resources, because they must be released after they have been acquired and used.","pos":[801,934]},{"content":"The CLR provides support for automatic memory management.","pos":[941,998]},{"content":"Managed memory (memory allocated using the C# operator <ph id=\"ph1\">`new`</ph>) does not need to be explicitly released.","pos":[999,1101],"source":" Managed memory (memory allocated using the C# operator `new`) does not need to be explicitly released."},{"content":"It is released automatically by the garbage collector (GC).","pos":[1102,1161]},{"content":"This frees developers from the tedious and difficult task of releasing memory and has been one of the main reasons for the unprecedented productivity afforded by the .NET Framework.","pos":[1162,1343]},{"content":"Unfortunately, managed memory is just one of many types of system resources.","pos":[1350,1426]},{"content":"Resources other than managed memory still need to be released explicitly and are referred to as unmanaged resources.","pos":[1427,1543]},{"content":"The GC was specifically not designed to manage such unmanaged resources, which means that the responsibility for managing unmanaged resources lies in the hands of the developers.","pos":[1544,1722]},{"content":"The CLR provides some help in releasing unmanaged resources.","pos":[1729,1789]},{"content":"<ph id=\"ph1\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> declares a virtual method <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> (also called the finalizer) that is called by the GC before the object’s memory is reclaimed by the GC and can be overridden to release unmanaged resources.","pos":[1790,2051],"source":" <xref:System.Object?displayProperty=fullName> declares a virtual method <xref:System.Object.Finalize%2A> (also called the finalizer) that is called by the GC before the object’s memory is reclaimed by the GC and can be overridden to release unmanaged resources."},{"content":"Types that override the finalizer are referred to as finalizable types.","pos":[2052,2123]},{"content":"Although finalizers are effective in some cleanup scenarios, they have two significant drawbacks:","pos":[2130,2227]},{"content":"The finalizer is called when the GC detects that an object is eligible for collection.","pos":[2237,2323]},{"content":"This happens at some undetermined period of time after the resource is not needed anymore.","pos":[2324,2414]},{"content":"The delay between when the developer could or would like to release the resource and the time when the resource is actually released by the finalizer might be unacceptable in programs that acquire many scarce resources (resources that can be easily exhausted) or in cases in which resources are costly to keep in use (e.g., large unmanaged memory buffers).","pos":[2415,2771]},{"content":"When the CLR needs to call a finalizer, it must postpone collection of the object’s memory until the next round of garbage collection (the finalizers run between collections).","pos":[2781,2956]},{"content":"This means that the object’s memory (and all objects it refers to) will not be released for a longer period of time.","pos":[2957,3073]},{"content":"Therefore, relying exclusively on finalizers might not be appropriate in many scenarios when it is important to reclaim unmanaged resources as quickly as possible, when dealing with scarce resources, or in highly performant scenarios in which the added GC overhead of finalization is unacceptable.","pos":[3080,3377]},{"content":"The Framework provides the <ph id=\"ph1\">&lt;xref:System.IDisposable?displayProperty=fullName&gt;</ph> interface that should be implemented to provide the developer a manual way to release unmanaged resources as soon as they are not needed.","pos":[3384,3599],"source":"The Framework provides the <xref:System.IDisposable?displayProperty=fullName> interface that should be implemented to provide the developer a manual way to release unmanaged resources as soon as they are not needed."},{"content":"It also provides the <ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> method that can tell the GC that an object was manually disposed of and does not need to be finalized anymore, in which case the object’s memory can be reclaimed earlier.","pos":[3600,3853],"source":" It also provides the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method that can tell the GC that an object was manually disposed of and does not need to be finalized anymore, in which case the object’s memory can be reclaimed earlier."},{"content":"Types that implement the <ph id=\"ph1\">`IDisposable`</ph> interface are referred to as disposable types.","pos":[3854,3939],"source":" Types that implement the `IDisposable` interface are referred to as disposable types."},{"pos":[3946,4068],"content":"The Dispose Pattern is intended to standardize the usage and implementation of finalizers and the <ph id=\"ph1\">`IDisposable`</ph> interface.","source":"The Dispose Pattern is intended to standardize the usage and implementation of finalizers and the `IDisposable` interface."},{"content":"The main motivation for the pattern is to reduce the complexity of the implementation of the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> methods.","pos":[4075,4254],"source":"The main motivation for the pattern is to reduce the complexity of the implementation of the <xref:System.Object.Finalize%2A> and the <xref:System.IDisposable.Dispose%2A> methods."},{"content":"The complexity stems from the fact that the methods share some but not all code paths (the differences are described later in the chapter).","pos":[4255,4394]},{"content":"In addition, there are historical reasons for some elements of the pattern related to the evolution of language support for deterministic resource management.","pos":[4395,4553]},{"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> implement the Basic Dispose Pattern on types containing instances of disposable types.","pos":[4560,4655],"source":"**✓ DO** implement the Basic Dispose Pattern on types containing instances of disposable types."},{"content":"See the <bpt id=\"p1\">[</bpt>Basic Dispose Pattern<ept id=\"p1\">](#basic_pattern)</ept> section for details on the basic pattern.","pos":[4656,4745],"source":" See the [Basic Dispose Pattern](#basic_pattern) section for details on the basic pattern."},{"content":"If a type is responsible for the lifetime of other disposable objects, developers need a way to dispose of them, too.","pos":[4752,4869]},{"content":"Using the container’s <ph id=\"ph1\">`Dispose`</ph> method is a convenient way to make this possible.","pos":[4870,4951],"source":" Using the container’s `Dispose` method is a convenient way to make this possible."},{"pos":[4958,5119],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> implement the Basic Dispose Pattern and provide a finalizer on types holding resources that need to be freed explicitly and that do not have finalizers.","source":"**✓ DO** implement the Basic Dispose Pattern and provide a finalizer on types holding resources that need to be freed explicitly and that do not have finalizers."},{"content":"For example, the pattern should be implemented on types storing unmanaged memory buffers.","pos":[5126,5215]},{"content":"The <bpt id=\"p1\">[</bpt>Finalizable Types<ept id=\"p1\">](#finalizable_types)</ept> section discusses guidelines related to implementing finalizers.","pos":[5216,5324],"source":" The [Finalizable Types](#finalizable_types) section discusses guidelines related to implementing finalizers."},{"pos":[5331,5505],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> implementing the Basic Dispose Pattern on classes that themselves don’t hold unmanaged resources or disposable objects but are likely to have subtypes that do.","source":"**✓ CONSIDER** implementing the Basic Dispose Pattern on classes that themselves don’t hold unmanaged resources or disposable objects but are likely to have subtypes that do."},{"content":"A great example of this is the <ph id=\"ph1\">&lt;xref:System.IO.Stream?displayProperty=fullName&gt;</ph> class.","pos":[5512,5598],"source":"A great example of this is the <xref:System.IO.Stream?displayProperty=fullName> class."},{"content":"Although it is an abstract base class that doesn’t hold any resources, most of its subclasses do and because of this, it implements this pattern.","pos":[5599,5744]},{"pos":[5785,5806],"content":"Basic Dispose Pattern","linkify":"Basic Dispose Pattern","nodes":[{"content":"Basic Dispose Pattern","pos":[0,21]}]},{"pos":[5810,6060],"content":"The basic implementation of the pattern involves implementing the <ph id=\"ph1\">`System.IDisposable`</ph> interface and declaring the <ph id=\"ph2\">`Dispose(bool)`</ph> method that implements all resource cleanup logic to be shared between the <ph id=\"ph3\">`Dispose`</ph> method and the optional finalizer.","source":"The basic implementation of the pattern involves implementing the `System.IDisposable` interface and declaring the `Dispose(bool)` method that implements all resource cleanup logic to be shared between the `Dispose` method and the optional finalizer."},{"content":"The following example shows a simple implementation of the basic pattern:","pos":[6067,6140]},{"content":"The Boolean parameter <ph id=\"ph1\">`disposing`</ph> indicates whether the method was invoked from the <ph id=\"ph2\">`IDisposable.Dispose`</ph> implementation or from the finalizer.","pos":[6652,6795],"source":"The Boolean parameter `disposing` indicates whether the method was invoked from the `IDisposable.Dispose` implementation or from the finalizer."},{"content":"The <ph id=\"ph1\">`Dispose(bool)`</ph> implementation should check the parameter before accessing other reference objects (e.g., the resource field in the preceding sample).","pos":[6796,6950],"source":" The `Dispose(bool)` implementation should check the parameter before accessing other reference objects (e.g., the resource field in the preceding sample)."},{"content":"Such objects should only be accessed when the method is called from the <ph id=\"ph1\">`IDisposable.Dispose`</ph> implementation (when the <ph id=\"ph2\">`disposing`</ph> parameter is equal to true).","pos":[6951,7110],"source":" Such objects should only be accessed when the method is called from the `IDisposable.Dispose` implementation (when the `disposing` parameter is equal to true)."},{"content":"If the method is invoked from the finalizer (<ph id=\"ph1\">`disposing`</ph> is false), other objects should not be accessed.","pos":[7111,7216],"source":" If the method is invoked from the finalizer (`disposing` is false), other objects should not be accessed."},{"content":"The reason is that objects are finalized in an unpredictable order and so they, or any of their dependencies, might already have been finalized.","pos":[7217,7361]},{"content":"Also, this section applies to classes with a base that does not already implement the Dispose Pattern.","pos":[7368,7470]},{"content":"If you are inheriting from a class that already implements the pattern, simply override the <ph id=\"ph1\">`Dispose(bool)`</ph> method to provide additional resource cleanup logic.","pos":[7471,7631],"source":" If you are inheriting from a class that already implements the pattern, simply override the `Dispose(bool)` method to provide additional resource cleanup logic."},{"pos":[7638,7778],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> declare a protected virtual void <ph id=\"ph1\">`Dispose(bool disposing)`</ph> method to centralize all logic related to releasing unmanaged resources.","source":"**✓ DO** declare a protected virtual void `Dispose(bool disposing)` method to centralize all logic related to releasing unmanaged resources."},{"content":"All resource cleanup should occur in this method.","pos":[7785,7834]},{"content":"The method is called from both the finalizer and the <ph id=\"ph1\">`IDisposable.Dispose`</ph> method.","pos":[7835,7917],"source":" The method is called from both the finalizer and the `IDisposable.Dispose` method."},{"content":"The parameter will be false if being invoked from inside a finalizer.","pos":[7918,7987]},{"content":"It should be used to ensure any code running during finalization is not accessing other finalizable objects.","pos":[7988,8096]},{"content":"Details of implementing finalizers are described in the next section.","pos":[8097,8166]},{"pos":[8323,8444],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> implement the <ph id=\"ph1\">`IDisposable`</ph> interface by simply calling <ph id=\"ph2\">`Dispose(true)`</ph> followed by <ph id=\"ph3\">`GC.SuppressFinalize(this)`</ph>.","source":"**✓ DO** implement the `IDisposable` interface by simply calling `Dispose(true)` followed by `GC.SuppressFinalize(this)`."},{"pos":[8451,8541],"content":"The call to <ph id=\"ph1\">`SuppressFinalize`</ph> should only occur if <ph id=\"ph2\">`Dispose(true)`</ph> executes successfully.","source":"The call to `SuppressFinalize` should only occur if `Dispose(true)` executes successfully."},{"pos":[8646,8707],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> make the parameterless <ph id=\"ph1\">`Dispose`</ph> method virtual.","source":"**X DO NOT** make the parameterless `Dispose` method virtual."},{"pos":[8714,8792],"content":"The <ph id=\"ph1\">`Dispose(bool)`</ph> method is the one that should be overridden by subclasses.","source":"The `Dispose(bool)` method is the one that should be overridden by subclasses."},{"pos":[9168,9270],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> declare any overloads of the <ph id=\"ph1\">`Dispose`</ph> method other than <ph id=\"ph2\">`Dispose()`</ph> and <ph id=\"ph3\">`Dispose(bool)`</ph>.","source":"**X DO NOT** declare any overloads of the `Dispose` method other than `Dispose()` and `Dispose(bool)`."},{"content":"<ph id=\"ph1\">`Dispose`</ph> should be considered a reserved word to help codify this pattern and prevent confusion among implementers, users, and compilers.","pos":[9277,9415],"source":"`Dispose` should be considered a reserved word to help codify this pattern and prevent confusion among implementers, users, and compilers."},{"content":"Some languages might choose to automatically implement this pattern on certain types.","pos":[9416,9501]},{"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> allow the <ph id=\"ph1\">`Dispose(bool)`</ph> method to be called more than once.","pos":[9508,9578],"source":"**✓ DO** allow the `Dispose(bool)` method to be called more than once."},{"content":"The method might choose to do nothing after the first call.","pos":[9579,9638]},{"pos":[9910,10094],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> throwing an exception from within <ph id=\"ph1\">`Dispose(bool)`</ph> except under critical situations where the containing process has been corrupted (leaks, inconsistent shared state, etc.).","source":"**X AVOID** throwing an exception from within `Dispose(bool)` except under critical situations where the containing process has been corrupted (leaks, inconsistent shared state, etc.)."},{"pos":[10101,10167],"content":"Users expect that a call to <ph id=\"ph1\">`Dispose`</ph> will not raise an exception.","source":"Users expect that a call to `Dispose` will not raise an exception."},{"content":"If <ph id=\"ph1\">`Dispose`</ph> could raise an exception, further finally-block cleanup logic will not execute.","pos":[10174,10266],"source":"If `Dispose` could raise an exception, further finally-block cleanup logic will not execute."},{"content":"To work around this, the user would need to wrap every call to <ph id=\"ph1\">`Dispose`</ph> (within the finally block!) in a try block, which leads to very complex cleanup handlers.","pos":[10267,10429],"source":" To work around this, the user would need to wrap every call to `Dispose` (within the finally block!) in a try block, which leads to very complex cleanup handlers."},{"content":"If executing a <ph id=\"ph1\">`Dispose(bool disposing)`</ph> method, never throw an exception if disposing is false.","pos":[10430,10526],"source":" If executing a `Dispose(bool disposing)` method, never throw an exception if disposing is false."},{"content":"Doing so will terminate the process if executing inside a finalizer context.","pos":[10527,10603]},{"pos":[10610,10740],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> throw an <ph id=\"ph1\">&lt;xref:System.ObjectDisposedException&gt;</ph> from any member that cannot be used after the object has been disposed of.","source":"**✓ DO** throw an <xref:System.ObjectDisposedException> from any member that cannot be used after the object has been disposed of."},{"pos":[11247,11367],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> providing method <ph id=\"ph1\">`Close()`</ph>, in addition to the <ph id=\"ph2\">`Dispose()`</ph>, if close is standard terminology in the area.","source":"**✓ CONSIDER** providing method `Close()`, in addition to the `Dispose()`, if close is standard terminology in the area."},{"pos":[11374,11539],"content":"When doing so, it is important that you make the <ph id=\"ph1\">`Close`</ph> implementation identical to <ph id=\"ph2\">`Dispose`</ph> and consider implementing the <ph id=\"ph3\">`IDisposable.Dispose`</ph> method explicitly.","source":"When doing so, it is important that you make the `Close` implementation identical to `Dispose` and consider implementing the `IDisposable.Dispose` method explicitly."},{"pos":[11794,11811],"content":"Finalizable Types","linkify":"Finalizable Types","nodes":[{"content":"Finalizable Types","pos":[0,17]}]},{"pos":[11815,11976],"content":"Finalizable types are types that extend the Basic Dispose Pattern by overriding the finalizer and providing finalization code path in the <ph id=\"ph1\">`Dispose(bool)`</ph> method.","source":"Finalizable types are types that extend the Basic Dispose Pattern by overriding the finalizer and providing finalization code path in the `Dispose(bool)` method."},{"content":"Finalizers are notoriously difficult to implement correctly, primarily because you cannot make certain (normally valid) assumptions about the state of the system during their execution.","pos":[11983,12168]},{"content":"The following guidelines should be taken into careful consideration.","pos":[12169,12237]},{"content":"Note that some of the guidelines apply not just to the <ph id=\"ph1\">`Finalize`</ph> method, but to any code called from a finalizer.","pos":[12244,12358],"source":"Note that some of the guidelines apply not just to the `Finalize` method, but to any code called from a finalizer."},{"content":"In the case of the Basic Dispose Pattern previously defined, this means logic that executes inside <ph id=\"ph1\">`Dispose(bool disposing)`</ph> when the <ph id=\"ph2\">`disposing`</ph> parameter is false.","pos":[12359,12524],"source":" In the case of the Basic Dispose Pattern previously defined, this means logic that executes inside `Dispose(bool disposing)` when the `disposing` parameter is false."},{"content":"If the base class already is finalizable and implements the Basic Dispose Pattern, you should not override <ph id=\"ph1\">`Finalize`</ph> again.","pos":[12531,12655],"source":"If the base class already is finalizable and implements the Basic Dispose Pattern, you should not override `Finalize` again."},{"content":"You should instead just override the <ph id=\"ph1\">`Dispose(bool)`</ph> method to provide additional resource cleanup logic.","pos":[12656,12761],"source":" You should instead just override the `Dispose(bool)` method to provide additional resource cleanup logic."},{"content":"The following code shows an example of a finalizable type:","pos":[12768,12826]},{"pos":[13618,13655],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> making types finalizable.","source":"**X AVOID** making types finalizable."},{"content":"Carefully consider any case in which you think a finalizer is needed.","pos":[13662,13731]},{"content":"There is a real cost associated with instances with finalizers, from both a performance and code complexity standpoint.","pos":[13732,13851]},{"content":"Prefer using resource wrappers such as <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to encapsulate unmanaged resources where possible, in which case a finalizer becomes unnecessary because the wrapper is responsible for its own resource cleanup.","pos":[13852,14101],"source":" Prefer using resource wrappers such as <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate unmanaged resources where possible, in which case a finalizer becomes unnecessary because the wrapper is responsible for its own resource cleanup."},{"pos":[14108,14150],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> make value types finalizable.","source":"**X DO NOT** make value types finalizable."},{"content":"Only reference types actually get finalized by the CLR, and thus any attempt to place a finalizer on a value type will be ignored.","pos":[14157,14287]},{"content":"The C# and C++ compilers enforce this rule.","pos":[14288,14331]},{"pos":[14338,14471],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> make a type finalizable if the type is responsible for releasing an unmanaged resource that does not have its own finalizer.","source":"**✓ DO** make a type finalizable if the type is responsible for releasing an unmanaged resource that does not have its own finalizer."},{"pos":[14478,14621],"content":"When implementing the finalizer, simply call <ph id=\"ph1\">`Dispose(false)`</ph> and place all resource cleanup logic inside the <ph id=\"ph2\">`Dispose(bool disposing)`</ph> method.","source":"When implementing the finalizer, simply call `Dispose(false)` and place all resource cleanup logic inside the `Dispose(bool disposing)` method."},{"pos":[14849,14920],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> implement the Basic Dispose Pattern on every finalizable type.","source":"**✓ DO** implement the Basic Dispose Pattern on every finalizable type."},{"content":"This gives users of the type a means to explicitly perform deterministic cleanup of those same resources for which the finalizer is responsible.","pos":[14927,15071]},{"pos":[15078,15227],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> access any finalizable objects in the finalizer code path, because there is significant risk that they will have already been finalized.","source":"**X DO NOT** access any finalizable objects in the finalizer code path, because there is significant risk that they will have already been finalized."},{"content":"For example, a finalizable object A that has a reference to another finalizable object B cannot reliably use B in A’s finalizer, or vice versa.","pos":[15234,15377]},{"content":"Finalizers are called in a random order (short of a weak ordering guarantee for critical finalization).","pos":[15378,15481]},{"content":"Also, be aware that objects stored in static variables will get collected at certain points during an application domain unload or while exiting the process.","pos":[15488,15645]},{"content":"Accessing a static variable that refers to a finalizable object (or calling a static method that might use values stored in static variables) might not be safe if <ph id=\"ph1\">&lt;xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName&gt;</ph> returns true.","pos":[15646,15895],"source":" Accessing a static variable that refers to a finalizable object (or calling a static method that might use values stored in static variables) might not be safe if <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> returns true."},{"pos":[15902,15949],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> make your <ph id=\"ph1\">`Finalize`</ph> method protected.","source":"**✓ DO** make your `Finalize` method protected."},{"content":"C#, C++, and VB.NET developers do not need to worry about this, because the compilers help to enforce this guideline.","pos":[15956,16073]},{"pos":[16080,16177],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> let exceptions escape from the finalizer logic, except for system-critical failures.","source":"**X DO NOT** let exceptions escape from the finalizer logic, except for system-critical failures."},{"content":"If an exception is thrown from a finalizer, the CLR will shut down the entire process (as of .NET Framework version 2.0), preventing other finalizers from executing and resources from being released in a controlled manner.","pos":[16184,16406]},{"pos":[16413,16721],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> creating and using a critical finalizable object (a type with a type hierarchy that contains <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph>) for situations in which a finalizer absolutely must execute even in the face of forced application domain unloads and thread aborts.","source":"**✓ CONSIDER** creating and using a critical finalizable object (a type with a type hierarchy that contains <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>) for situations in which a finalizer absolutely must execute even in the face of forced application domain unloads and thread aborts."},{"pos":[16728,16795],"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[16802,17206],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[17215,17223],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph>","pos":[17227,17288],"source":"<xref:System.IDisposable.Dispose%2A?displayProperty=fullName> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph>","pos":[17293,17350],"source":" <xref:System.Object.Finalize%2A?displayProperty=fullName> "},{"content":"<bpt id=\"p1\"> [</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[17354,17436],"source":" [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Common Design Patterns<ept id=\"p1\">](../../../docs/standard/design-guidelines/common-design-patterns.md)</ept><ph id=\"ph1\"> </ph>","pos":[17439,17533],"source":" [Common Design Patterns](../../../docs/standard/design-guidelines/common-design-patterns.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Garbage Collection<ept id=\"p1\">](../../../docs/standard/garbage-collection/index.md)</ept>","pos":[17536,17609],"source":" [Garbage Collection](../../../docs/standard/garbage-collection/index.md)"}]}