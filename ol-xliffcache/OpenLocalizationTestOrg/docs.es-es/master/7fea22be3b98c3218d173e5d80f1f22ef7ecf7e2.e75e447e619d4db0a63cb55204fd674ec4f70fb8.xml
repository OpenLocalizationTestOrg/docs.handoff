{"content":"---\ntitle: Iterators\ndescription: Iterators\nkeywords: .NET, .NET Core\nauthor: BillWagner\nms.author: wiwagn\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 5cf36f45-f91a-4fca-a0b7-87f233e108e9\n---\n\n# Iterators\n\nAlmost every program you write will have some need to iterate\nover a collection. You'll write code that examines every item in\na collection. \n\nYou'll also create iterator methods which are methods that produces an\niterator for the elements of that class. These can be used for:\n\n+ Performing an action on each item in a collection.\n+ Enumerating a custom collection.\n+ Extending [LINQ](linq/index.md) or other libraries.\n+ Creating a data pipeline where data flows efficiently through iterator\nmethods.\n\nThe C# language provides\nfeatures for both these scenarios. This article provides an overview\nof those features.\n\nThis tutorial has multiple steps. After each step, you can run the application and see the progress. You can also [view or download the completed sample](https://github.com/dotnet/docs/blob/master/samples/csharp/iterators) for this topic. For download instructions, see [Samples and Tutorials](../samples-and-tutorials/index.md#viewing-and-downloading-samples).\n\n## Iterating with foreach\n\nEnumerating a collection is simple: The `foreach` keyword enumerates\na collection, executing the embedded statement once for each element\nin the collection:\n \n```csharp\nforeach (var item in collection)\n{\n   Console.WriteLine(item.ToString());\n}\n```\n\nThat's all there is to it. To iterate over all the contents of a collection,\nthe `foreach` statement is all you need. The `foreach` statement isn't magic,\nthough. It relies on two generic interfaces defined in the .NET core library in order\nto generate the code necessary to iterate a collection: `IEnumerable<T>` and\n`IEnumerator<T>`. This mechanism is explained in more detail below.\n\nBoth of these interfaces also have non-generic counterparts: `IEnumerable` and \n`IEnumerator`. The [generic](programming-guide/generics/index.md) versions are preferred for modern code.\n\n## Enumeration sources with iterator methods\n\nAnother great feature of the C# language enables you to build methods that create\na source for an enumeration. These are referred to as *iterator methods*. An iterator\nmethod defines how to generate the objects in a sequence when requested. You\nuse the `yield return` contextual keywords to define an iterator method. \n\nYou could write this method to produce the sequence of integers from 0 through 9:\n\n```csharp\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    yield return 0;\n    yield return 1;\n    yield return 2;\n    yield return 3;\n    yield return 4;\n    yield return 5;\n    yield return 6;\n    yield return 7;\n    yield return 8;\n    yield return 9;\n}\n```\n\nThe code above shows distinct `yield return` statements to highlight the fact that\nyou can use multiple discrete `yield return` statements in an iterator method.\nYou can (and often do) use other language constructs to simplify the code of an\niterator method. The method definition below produces the exact same sequence\nof numbers:\n\n```csharp\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n}\n```\n\nYou don't have to decide one or the other. You can have as many `yield return`\nstatements as necessary to meet the needs of your method:\n\n```csharp\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n        \n    yield return 50;\n    \n    index = 100;\n    while (index++ < 110)\n        yield return index;\n}\n```\n\nThat's the basic syntax. Let's consider a real world example where you would\nwrite an iterator method. Imagine you're on an IoT project and the device\nsensors generate a very large stream of data. To get a feel for the data, you\nmight write a method that samples every Nth data element. This small iterator\nmethod does the trick:\n\n```csharp\npublic static IEnumerable<T> Sample(this IEnumerable<T> sourceSequence, int interval)\n{\n    int index = 0;\n    foreach (T item in sourceSequence)\n    {\n        if (index++ % interval == 0)\n            yield return item;\n    }\n}\n```\n\nThere is one important restriction on iterator methods: you can't have both a\n`return` statement and a `yield return` statement in the same method. The following\nwill not compile:\n\n```csharp\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n        \n    yield return 50;\n   \n    // generates a compile time error: \n    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };\n    return items;  \n}\n```\n\nThis restriction normally isn't a problem. You have a choice of either using\n`yield return` throughout the method, or separating the original method into\nmultiple methods, some using `return`, and some using `yield return`.\n\nYou can modify the last method slightly to use `yield return` everywhere:\n\n```csharp\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n        \n    yield return 50;\n   \n    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };\n    foreach (var item in items)\n        yield return item;\n}\n```\n \nSometimes, the right answer is to split an iterator method into two different\nmethods. One that uses `return`, and a second that uses `yield return`. Consider\na situation where you might want to return an empty collection, or the first 5\nodd numbers, based on a boolean argument. You could write that as these two\nmethods:\n\n```csharp\npublic IEnumerable<int> GetSingleDigitOddNumbers(bool getCollection)\n{\n    if (getCollection == false)\n        return new int[0];\n    else\n        return IteratorMethod();\n}\n\nprivate IEnumerable<int> IteratorMethod()\n{\n    int index = 0;\n    while (index++ < 10)\n        if (index % 2 == 1)\n            yield return index;\n}\n```\n \nLook at the methods above. The first uses the standard `return` statement to return\neither an empty collection, or the iterator created by the second method. The second\nmethod uses the `yield return` statement to create the requested sequence.\n\n## Deeper Dive into `foreach`\n\nThe `foreach` statement expands into a standard idiom that uses the\n`IEnumable<T>` and `IEnumerator<T>` interfaces to iterate across all\nelements of a collection. It also  minimizes errors developers make\nby not properly managing resources. \n\nThe compiler translates the `foreach` loop shown in the first\nexample into something similar to this construct:\n\n```csharp\nIEnumerator<int> enumerator = collection.GetEnumerator();\nwhile (enumerator.MoveNext())\n{\n    var item = enumerator.Current;\n    Console.WriteLine(item.ToString());\n}\n```\n\nThe construct above represents the code generated by the C# compiler as of\nversion 5 and above. Prior to version 5, the `item` variable had a different scope:\n\n```csharp\n// C# versions 1 through 4:\nIEnumerator<int> enumerator = collection.GetEnumerator();\nint item = default(int);\nwhile (enumerator.MoveNext())\n{\n    item = enumerator.Current;\n    Console.WriteLine(item.ToString());\n}\n```\n\nThis was changed because the earlier behavior could lead to subtle and hard\nto diagnose bugs involving lambda expressions. See the section on\n[lambda expressions](lambda-expressions.md) for more information. \n\nThe exact code generated by the compiler is somewhat more complicated, and\nhandles situations where the object returned by `GetEnumerator()` implements\nthe `IDisposable` interface. The full expansion generates code more like this:\n\n```csharp\n{\n    var enumerator = collection.GetEnumerator();\n    try \n    {\n        while (enumerator.MoveNext())\n        {\n            var item = enumerator.Current;\n            Console.WriteLine(item.ToString());\n        }\n    } finally \n    {\n        // dispose of enumerator.\n    }\n}\n```\n\nThe manner in which the enumerator is disposed of depends on the characteristics of\nthe type of `enumerator`. In the general case, the `finally` clause expands to:\n\n```csharp\nfinally \n{\n   (enumerator as IDisposable)?.Dispose();\n} \n```\n\nHowever, if the type of `enumerator` is a sealed type and there is no implicit\nconversion from the type of `enumerator` to `IDisposable`, the `finally` clause\nexpands to an empty block:\n```csharp\nfinally \n{\n} \n```\n\nIf there is an implicit conversion from the type of `enumerator` to `IDisposable`,\nand `enumerator` is a non-nullable value type, the `finally` clause expands to:\n\n```csharp\nfinally \n{\n   ((IDisposable)enumerator).Dispose();\n} \n```\n\nThankfully, you don't need to remember all these details. The `foreach` statement\nhandles all those nuances for you. The compiler will generate the correct code for\nany of these constructs. \n\n\n","nodes":[{"pos":[11,20],"content":"Iterators","needQuote":true,"needEscape":true,"nodes":[{"content":"Iterators","pos":[0,9]}]},{"pos":[34,43],"content":"Iterators","needQuote":true,"needEscape":true,"nodes":[{"content":"Iterators","pos":[0,9]}]},{"pos":[54,69],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[264,273],"content":"Iterators","linkify":"Iterators","nodes":[{"content":"Iterators","pos":[0,9]}]},{"content":"Almost every program you write will have some need to iterate over a collection.","pos":[275,355],"source":"Almost every program you write will have some need to iterate\nover a collection."},{"content":"You'll write code that examines every item in a collection.","pos":[356,415],"source":" You'll write code that examines every item in\na collection."},{"content":"You'll also create iterator methods which are methods that produces an iterator for the elements of that class.","pos":[418,529],"source":"You'll also create iterator methods which are methods that produces an\niterator for the elements of that class."},{"content":"These can be used for:","pos":[530,552]},{"content":"Performing an action on each item in a collection.","pos":[556,606]},{"content":"Enumerating a custom collection.","pos":[609,641]},{"pos":[644,695],"content":"Extending <bpt id=\"p1\">[</bpt>LINQ<ept id=\"p1\">](linq/index.md)</ept> or other libraries.","source":"Extending [LINQ](linq/index.md) or other libraries."},{"pos":[698,777],"content":"Creating a data pipeline where data flows efficiently through iterator methods.","source":"Creating a data pipeline where data flows efficiently through iterator\nmethods."},{"content":"The C# language provides features for both these scenarios.","pos":[779,838],"source":"The C# language provides\nfeatures for both these scenarios."},{"content":"This article provides an overview of those features.","pos":[839,891],"source":" This article provides an overview\nof those features."},{"content":"This tutorial has multiple steps.","pos":[893,926]},{"content":"After each step, you can run the application and see the progress.","pos":[927,993]},{"content":"You can also <bpt id=\"p1\">[</bpt>view or download the completed sample<ept id=\"p1\">](https://github.com/dotnet/docs/blob/master/samples/csharp/iterators)</ept> for this topic.","pos":[994,1131],"source":" You can also [view or download the completed sample](https://github.com/dotnet/docs/blob/master/samples/csharp/iterators) for this topic."},{"content":"For download instructions, see <bpt id=\"p1\">[</bpt>Samples and Tutorials<ept id=\"p1\">](../samples-and-tutorials/index.md#viewing-and-downloading-samples)</ept>.","pos":[1132,1254],"source":" For download instructions, see [Samples and Tutorials](../samples-and-tutorials/index.md#viewing-and-downloading-samples)."},{"pos":[1259,1281],"content":"Iterating with foreach","linkify":"Iterating with foreach","nodes":[{"content":"Iterating with foreach","pos":[0,22]}]},{"pos":[1283,1439],"content":"Enumerating a collection is simple: The <ph id=\"ph1\">`foreach`</ph> keyword enumerates a collection, executing the embedded statement once for each element in the collection:","source":"Enumerating a collection is simple: The `foreach` keyword enumerates\na collection, executing the embedded statement once for each element\nin the collection:"},{"content":"That's all there is to it.","pos":[1533,1559]},{"content":"To iterate over all the contents of a collection, the <ph id=\"ph1\">`foreach`</ph> statement is all you need.","pos":[1560,1650],"source":" To iterate over all the contents of a collection,\nthe `foreach` statement is all you need."},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement isn't magic, though.","pos":[1651,1695],"source":" The `foreach` statement isn't magic,\nthough."},{"content":"It relies on two generic interfaces defined in the .NET core library in order to generate the code necessary to iterate a collection: <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> and <ph id=\"ph2\">`IEnumerator&lt;T&gt;`</ph>.","pos":[1696,1868],"source":" It relies on two generic interfaces defined in the .NET core library in order\nto generate the code necessary to iterate a collection: `IEnumerable<T>` and\n`IEnumerator<T>`."},{"content":"This mechanism is explained in more detail below.","pos":[1869,1918]},{"content":"Both of these interfaces also have non-generic counterparts: <ph id=\"ph1\">`IEnumerable`</ph> and <ph id=\"ph2\">`IEnumerator`</ph>.","pos":[1920,2014],"source":"Both of these interfaces also have non-generic counterparts: `IEnumerable` and \n`IEnumerator`."},{"content":"The <bpt id=\"p1\">[</bpt>generic<ept id=\"p1\">](programming-guide/generics/index.md)</ept> versions are preferred for modern code.","pos":[2015,2105],"source":" The [generic](programming-guide/generics/index.md) versions are preferred for modern code."},{"pos":[2110,2151],"content":"Enumeration sources with iterator methods","linkify":"Enumeration sources with iterator methods","nodes":[{"content":"Enumeration sources with iterator methods","pos":[0,41]}]},{"content":"Another great feature of the C# language enables you to build methods that create a source for an enumeration.","pos":[2153,2263],"source":"Another great feature of the C# language enables you to build methods that create\na source for an enumeration."},{"content":"These are referred to as <bpt id=\"p1\">*</bpt>iterator methods<ept id=\"p1\">*</ept>.","pos":[2264,2308],"source":" These are referred to as *iterator methods*."},{"content":"An iterator method defines how to generate the objects in a sequence when requested.","pos":[2309,2393],"source":" An iterator\nmethod defines how to generate the objects in a sequence when requested."},{"content":"You use the <ph id=\"ph1\">`yield return`</ph> contextual keywords to define an iterator method.","pos":[2394,2470],"source":" You\nuse the `yield return` contextual keywords to define an iterator method."},{"content":"You could write this method to produce the sequence of integers from 0 through 9:","pos":[2473,2554]},{"content":"The code above shows distinct <ph id=\"ph1\">`yield return`</ph> statements to highlight the fact that you can use multiple discrete <ph id=\"ph2\">`yield return`</ph> statements in an iterator method.","pos":[2823,2984],"source":"The code above shows distinct `yield return` statements to highlight the fact that\nyou can use multiple discrete `yield return` statements in an iterator method."},{"content":"You can (and often do) use other language constructs to simplify the code of an iterator method.","pos":[2985,3081],"source":"\nYou can (and often do) use other language constructs to simplify the code of an\niterator method."},{"content":"The method definition below produces the exact same sequence of numbers:","pos":[3082,3154],"source":" The method definition below produces the exact same sequence\nof numbers:"},{"content":"You don't have to decide one or the other.","pos":[3295,3337]},{"content":"You can have as many <ph id=\"ph1\">`yield return`</ph> statements as necessary to meet the needs of your method:","pos":[3338,3431],"source":" You can have as many `yield return`\nstatements as necessary to meet the needs of your method:"},{"content":"That's the basic syntax.","pos":[3678,3702]},{"content":"Let's consider a real world example where you would write an iterator method.","pos":[3703,3780],"source":" Let's consider a real world example where you would\nwrite an iterator method."},{"content":"Imagine you're on an IoT project and the device sensors generate a very large stream of data.","pos":[3781,3874],"source":" Imagine you're on an IoT project and the device\nsensors generate a very large stream of data."},{"content":"To get a feel for the data, you might write a method that samples every Nth data element.","pos":[3875,3964],"source":" To get a feel for the data, you\nmight write a method that samples every Nth data element."},{"content":"This small iterator method does the trick:","pos":[3965,4007],"source":" This small iterator\nmethod does the trick:"},{"content":"There is one important restriction on iterator methods: you can't have both a <ph id=\"ph1\">`return`</ph> statement and a <ph id=\"ph2\">`yield return`</ph> statement in the same method.","pos":[4252,4399],"source":"There is one important restriction on iterator methods: you can't have both a\n`return` statement and a `yield return` statement in the same method."},{"content":"The following will not compile:","pos":[4400,4431],"source":" The following\nwill not compile:"},{"content":"This restriction normally isn't a problem.","pos":[4745,4787]},{"content":"You have a choice of either using <ph id=\"ph1\">`yield return`</ph> throughout the method, or separating the original method into multiple methods, some using <ph id=\"ph2\">`return`</ph>, and some using <ph id=\"ph3\">`yield return`</ph>.","pos":[4788,4968],"source":" You have a choice of either using\n`yield return` throughout the method, or separating the original method into\nmultiple methods, some using `return`, and some using `yield return`."},{"pos":[4970,5043],"content":"You can modify the last method slightly to use <ph id=\"ph1\">`yield return`</ph> everywhere:","source":"You can modify the last method slightly to use `yield return` everywhere:"},{"content":"Sometimes, the right answer is to split an iterator method into two different methods.","pos":[5357,5443],"source":"Sometimes, the right answer is to split an iterator method into two different\nmethods."},{"content":"One that uses <ph id=\"ph1\">`return`</ph>, and a second that uses <ph id=\"ph2\">`yield return`</ph>.","pos":[5444,5506],"source":" One that uses `return`, and a second that uses `yield return`."},{"content":"Consider a situation where you might want to return an empty collection, or the first 5 odd numbers, based on a boolean argument.","pos":[5507,5636],"source":" Consider\na situation where you might want to return an empty collection, or the first 5\nodd numbers, based on a boolean argument."},{"content":"You could write that as these two methods:","pos":[5637,5679],"source":" You could write that as these two\nmethods:"},{"content":"Look at the methods above.","pos":[6022,6048]},{"content":"The first uses the standard <ph id=\"ph1\">`return`</ph> statement to return either an empty collection, or the iterator created by the second method.","pos":[6049,6179],"source":" The first uses the standard `return` statement to return\neither an empty collection, or the iterator created by the second method."},{"content":"The second method uses the <ph id=\"ph1\">`yield return`</ph> statement to create the requested sequence.","pos":[6180,6265],"source":" The second\nmethod uses the `yield return` statement to create the requested sequence."},{"pos":[6270,6296],"content":"Deeper Dive into <ph id=\"ph1\">`foreach`</ph>","linkify":"Deeper Dive into `foreach`","source":"Deeper Dive into `foreach`"},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement expands into a standard idiom that uses the <ph id=\"ph2\">`IEnumable&lt;T&gt;`</ph> and <ph id=\"ph3\">`IEnumerator&lt;T&gt;`</ph> interfaces to iterate across all elements of a collection.","pos":[6298,6460],"source":"The `foreach` statement expands into a standard idiom that uses the\n`IEnumable<T>` and `IEnumerator<T>` interfaces to iterate across all\nelements of a collection."},{"content":"It also  minimizes errors developers make by not properly managing resources.","pos":[6461,6538],"source":" It also  minimizes errors developers make\nby not properly managing resources."},{"pos":[6541,6652],"content":"The compiler translates the <ph id=\"ph1\">`foreach`</ph> loop shown in the first example into something similar to this construct:","source":"The compiler translates the `foreach` loop shown in the first\nexample into something similar to this construct:"},{"content":"The construct above represents the code generated by the C# compiler as of version 5 and above.","pos":[6836,6931],"source":"The construct above represents the code generated by the C# compiler as of\nversion 5 and above."},{"content":"Prior to version 5, the <ph id=\"ph1\">`item`</ph> variable had a different scope:","pos":[6932,6994],"source":" Prior to version 5, the `item` variable had a different scope:"},{"content":"This was changed because the earlier behavior could lead to subtle and hard to diagnose bugs involving lambda expressions.","pos":[7227,7349],"source":"This was changed because the earlier behavior could lead to subtle and hard\nto diagnose bugs involving lambda expressions."},{"content":"See the section on <bpt id=\"p1\">[</bpt>lambda expressions<ept id=\"p1\">](lambda-expressions.md)</ept> for more information.","pos":[7350,7434],"source":" See the section on\n[lambda expressions](lambda-expressions.md) for more information."},{"content":"The exact code generated by the compiler is somewhat more complicated, and handles situations where the object returned by <ph id=\"ph1\">`GetEnumerator()`</ph> implements the <ph id=\"ph2\">`IDisposable`</ph> interface.","pos":[7437,7617],"source":"The exact code generated by the compiler is somewhat more complicated, and\nhandles situations where the object returned by `GetEnumerator()` implements\nthe `IDisposable` interface."},{"content":"The full expansion generates code more like this:","pos":[7618,7667]},{"content":"The manner in which the enumerator is disposed of depends on the characteristics of the type of <ph id=\"ph1\">`enumerator`</ph>.","pos":[7962,8071],"source":"The manner in which the enumerator is disposed of depends on the characteristics of\nthe type of `enumerator`."},{"content":"In the general case, the <ph id=\"ph1\">`finally`</ph> clause expands to:","pos":[8072,8125],"source":" In the general case, the `finally` clause expands to:"},{"pos":[8199,8384],"content":"However, if the type of <ph id=\"ph1\">`enumerator`</ph> is a sealed type and there is no implicit conversion from the type of <ph id=\"ph2\">`enumerator`</ph> to <ph id=\"ph3\">`IDisposable`</ph>, the <ph id=\"ph4\">`finally`</ph> clause expands to an empty block:","source":"However, if the type of `enumerator` is a sealed type and there is no implicit\nconversion from the type of `enumerator` to `IDisposable`, the `finally` clause\nexpands to an empty block:"},{"pos":[8414,8576],"content":"If there is an implicit conversion from the type of <ph id=\"ph1\">`enumerator`</ph> to <ph id=\"ph2\">`IDisposable`</ph>, and <ph id=\"ph3\">`enumerator`</ph> is a non-nullable value type, the <ph id=\"ph4\">`finally`</ph> clause expands to:","source":"If there is an implicit conversion from the type of `enumerator` to `IDisposable`,\nand `enumerator` is a non-nullable value type, the `finally` clause expands to:"},{"content":"Thankfully, you don't need to remember all these details.","pos":[8647,8704]},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement handles all those nuances for you.","pos":[8705,8763],"source":" The `foreach` statement\nhandles all those nuances for you."},{"content":"The compiler will generate the correct code for any of these constructs.","pos":[8764,8836],"source":" The compiler will generate the correct code for\nany of these constructs."}]}