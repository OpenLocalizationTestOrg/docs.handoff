{"content":"---\ntitle: \"Dataflow (Task Parallel Library)\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"Task Parallel Library, dataflows\"\n  - \"TPL dataflow library\"\nms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Dataflow (Task Parallel Library)\n<a name=\"top\"></a> The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications. These dataflow components are collectively referred to as the *TPL Dataflow Library*. This dataflow model promotes actor-based programming by providing in-process message passing for coarse-grained dataflow and pipelining tasks. The dataflow components build on the types and scheduling infrastructure of the TPL and integrate with the C#, Visual Basic, and F# language support for asynchronous programming. These dataflow components are useful when you have multiple operations that must communicate with one another asynchronously or when you want to process data as it becomes available. For example, consider an application that processes image data from a web camera. By using the dataflow model, the application can process image frames as they become available. If the application enhances image frames, for example, by performing light correction or red-eye reduction, you can create a *pipeline* of dataflow components. Each stage of the pipeline might use more coarse-grained parallelism functionality, such as the functionality that is provided by the TPL, to transform the image.  \n  \n This document provides an overview of the TPL Dataflow Library. It describes the programming model, the predefined dataflow block types, and how to configure dataflow blocks to meet the specific requirements of your applications.  \n\n[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]\n  \n This document contains the following sections:  \n  \n-   [Programming Model](#model)  \n  \n-   [Predefined Dataflow Block Types](#predefined_types)  \n  \n-   [Configuring Dataflow Block Behavior](#behavior)  \n  \n-   [Custom Dataflow Blocks](#custom)  \n  \n<a name=\"model\"></a>   \n## Programming Model  \n The TPL Dataflow Library provides a foundation for message passing and parallelizing CPU-intensive and I/O-intensive applications that have high throughput and low latency. It also gives you explicit control over how data is buffered and moves around the system. To better understand the dataflow programming model, consider an application that asynchronously loads images from disk and creates a composite of those images. Traditional programming models typically require that you use callbacks and synchronization objects, such as locks, to coordinate tasks and access to shared data. By using the dataflow programming model, you can create dataflow objects that process images as they are read from disk. Under the dataflow model, you declare how data is handled when it becomes available, and also any dependencies between data. Because the runtime manages dependencies between data, you can often avoid the requirement to synchronize access to shared data. In addition, because the runtime schedules work based on the asynchronous arrival of data, dataflow can improve responsiveness and throughput by efficiently managing the underlying threads. For an example that uses the dataflow programming model to implement image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  \n  \n### Sources and Targets  \n The TPL Dataflow Library consists of *dataflow blocks*, which are data structures that buffer and process data. The TPL defines three kinds of dataflow blocks: *source blocks*, *target blocks*, and *propagator blocks*. A source block acts as a source of data and can be read from. A target block acts as a receiver of data and can be written to. A propagator block acts as both a source block and a target block, and can be read from and written to. The TPL defines the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interface to represent sources, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> to represent targets, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> to represent propagators. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> inherits from both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  \n  \n The TPL Dataflow Library provides several predefined dataflow block types that implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces. These dataflow block types are described in this document in the section [Predefined Dataflow Block Types](#predefined_types).  \n  \n### Connecting Blocks  \n You can connect dataflow blocks to form *pipelines*, which are linear sequences of dataflow blocks, or *networks*, which are graphs of dataflow blocks. A pipeline is one form of network. In a pipeline or network, sources asynchronously propagate data to targets as that data becomes available. The <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method links a source dataflow block to a target block. A source can be linked to zero or more targets; targets can be linked from zero or more sources. You can add or remove dataflow blocks to or from a pipeline or network concurrently. The predefined dataflow block types handle all thread-safety aspects of linking and unlinking.  \n  \n For an example that connects dataflow blocks to form a basic pipeline, see [Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). For an example that connects dataflow blocks to form a more complex network, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). For an example that unlinks a target from a source after the source offers the target a message, see [How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  \n  \n#### Filtering  \n When you call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method to link a source to a target, you can supply a delegate that determines whether the target block accepts or rejects a message based on the value of that message. This filtering mechanism is a useful way to guarantee that a dataflow block receives only certain values. For most of the predefined dataflow block types, if a source block is connected to multiple target blocks, when a target block rejects a message, the source offers that message to the next target. The order in which a source offers messages to targets is defined by the source and can vary according to the type of the source. Most source block types stop offering a message after one target accepts that message. One exception to this rule is the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, which offers each message to all targets, even if some targets reject the message. For an example that uses filtering to process only certain messages, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  \n  \n> [!IMPORTANT]\n>  Because each predefined source dataflow block type guarantees that messages are propagated out in the order in which they are received, every message must be read from the source block before the source block can process the next message. Therefore, when you use filtering to connect multiple targets to a source, make sure that at least one target block receives each message. Otherwise, your application might deadlock.  \n  \n### Message Passing  \n The dataflow programming model is related to the concept of *message passing*, where independent components of a program communicate with one another by sending messages. One way to propagate messages among application components is to call the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> methods to send messages to target dataflow blocks post (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> acts synchronously; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> acts asynchronously) and the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> methods to receive messages from source blocks. You can combine these methods with dataflow pipelines or networks by sending input data to the head node (a target block), and receiving output data from the terminal node of the pipeline or the terminal nodes of the network (one or more source blocks). You can also use the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> method to read from the first of the provided sources that has data available and perform action on that data.  \n  \n Source blocks offer data to target blocks by calling the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> method. The target block responds to an offered message in one of three ways: it can accept the message, decline the message, or postpone the message. When the target accepts the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. When the target declines the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. When the target requires that it no longer receives any messages from the source, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. The predefined source block types do not offer messages to linked targets after such a return value is received, and they automatically unlink from such targets.  \n  \n When a target block postpones the message for later use, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. A target block that postpones a message can later call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> method to try to reserve the offered message. At this point, the message is either still available and can be used by the target block, or the message has been taken by another target. When the target block later requires the message or no longer needs the message, it calls the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> method, respectively. Message reservation is typically used by the dataflow block types that operate in non-greedy mode. Non-greedy mode is explained later in this document. Instead of reserving a postponed message, a target block can also use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> method to attempt to directly consume the postponed message.  \n  \n### Dataflow Block Completion  \n Dataflow blocks also support the concept of *completion*. A dataflow block that is in the completed state does not perform any further work. Each dataflow block has an associated <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object, known as a *completion task*, that represents the completion status of the block. Because you can wait for a <xref:System.Threading.Tasks.Task> object to finish, by using completion tasks, you can wait for one or more terminal nodes of a dataflow network to finish. The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface defines the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method, which informs the dataflow block of a request for it to complete, and the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, which returns the completion task for the dataflow block. Both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> inherit the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface.  \n  \n There are two ways to determine whether a dataflow block completed without error, encountered one or more errors, or was canceled. The first way is to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method on the completion task in a `try`-`catch` block (`Try`-`Catch` in Visual Basic). The following example creates an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object that throws <xref:System.ArgumentOutOfRangeException> if its input value is less than zero. <xref:System.AggregateException> is thrown when this example calls <xref:System.Threading.Tasks.Task.Wait%2A> on the completion task. The <xref:System.ArgumentOutOfRangeException> is accessed through the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> object.  \n  \n [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]\n [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  \n  \n This example demonstrates the case in which an exception goes unhandled in the delegate of an execution dataflow block. We recommend that you handle exceptions in the bodies of such blocks. However, if you are unable to do so, the block behaves as though it was canceled and does not process incoming messages.  \n  \n When a dataflow block is canceled explicitly, the <xref:System.AggregateException> object contains <xref:System.OperationCanceledException> in the <xref:System.AggregateException.InnerExceptions%2A> property. For more information about dataflow cancellation, see [Enabling Cancellation](#enabling-cancellation) section.  \n  \n The second way to determine the completion status of a dataflow block is to use a continuation of the completion task, or to use the asynchronous language features of C# and Visual Basic to asynchronously wait for the completion task. The delegate that you provide to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method takes a <xref:System.Threading.Tasks.Task> object that represents the antecedent task. In the case of the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, the delegate for the continuation takes the completion task itself. The following example resembles the previous one, except that it also uses the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method to create a continuation task that prints the status of the overall dataflow operation.  \n  \n [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]\n [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  \n  \n You can also use properties such as <xref:System.Threading.Tasks.Task.IsCanceled%2A> in the body of the continuation task to determine additional information about the completion status of a dataflow block. For more information about continuation tasks and how they relate to cancellation and error handling, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md), and [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  \n  \n [[go to top](#top)]  \n  \n<a name=\"predefined_types\"></a>   \n## Predefined Dataflow Block Types  \n The TPL Dataflow Library provides several predefined dataflow block types. These types are divided into three categories: *buffering blocks*, *execution blocks*, and *grouping blocks*. The following sections describe the block types that make up these categories.  \n  \n### Buffering Blocks  \n Buffering blocks hold data for use by data consumers. The TPL Dataflow Library provides three buffering block types: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  \n  \n#### BufferBlock(T)  \n The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class represents a general-purpose asynchronous messaging structure. This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets. When a target receives a message from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, that message is removed from the message queue. Therefore, although a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object can have multiple targets, only one target will receive each message. The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class is useful when you want to pass multiple messages to another component, and that component must receive each message.  \n  \n The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object and then reads those values back from that object.  \n  \n [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]\n [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  \n  \n For a complete example that demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, see [How to: Write Messages to and Read Messages from a Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  \n  \n#### BroadcastBlock(T)  \n The <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class is useful when you must pass multiple messages to another component, but that component needs only the most recent value. This class is also useful when you want to broadcast a message to multiple components.  \n  \n The following basic example posts a <xref:System.Double> value to a <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> object and then reads that value back from that object several times. Because values are not removed from <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objects after they are read, the same value is available every time.  \n  \n [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]\n [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  \n  \n For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> to broadcast a message to multiple target blocks, see [How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  \n  \n#### WriteOnceBlock(T)  \n The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class resembles the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only. You can think of <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> as being similar to the C# [readonly](~/docs/csharp/language-reference/keywords/readonly.md) ([ReadOnly](~/docs/visual-basic/language-reference/modifiers/readonly.md) in Visual Basic) keyword, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object becomes immutable after it receives a value instead of at construction. Like the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, when a target receives a message from a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object, that message is not removed from that object. Therefore, multiple targets receive a copy of the message. The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class is useful when you want to propagate only the first of multiple messages.  \n  \n The following basic example posts multiple <xref:System.String> values to a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object and then reads the value back from that object. Because a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only, after a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object receives a message, it discards subsequent messages.  \n  \n [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]\n [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  \n  \n For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> to receive the value of the first operation that finishes, see [How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  \n  \n### Execution Blocks  \n Execution blocks call a user-provided delegate for each piece of received data. The TPL Dataflow Library provides three execution block types: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  \n  \n#### ActionBlock(T)  \n The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class is a target block that calls a delegate when it receives data. Think of a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object as a delegate that runs asynchronously when data becomes available. The delegate that you provide to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object can be of type <xref:System.Action%601> or type `System.Func<TInput, Task>`. When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with <xref:System.Action%601>, processing of each input element is considered completed when the delegate returns. When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with `System.Func<TInput, Task>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task> object is completed. By using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> for both synchronous and asynchronous processing of each input element.  \n  \n The following basic example posts multiple <xref:System.Int32> values to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object. The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object prints those values to the console. This example then sets the block to the completed state and waits for all dataflow tasks to finish.  \n  \n [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]\n [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  \n  \n For complete examples that demonstrate how to use delegates with the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, see [How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  \n  \n#### TransformBlock(TInput, TOutput)  \n The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, except that it acts as both a source and as a target. The delegate that you pass to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object returns a value of type `TOutput`. The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object can be of type `System.Func<TInput, TOutput>` or type `System.Func<TInput, Task<TOutput>>`. When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object with `System.Func<TInput, TOutput>`, processing of each input element is considered completed when the delegate returns. When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object used with `System.Func<TInput, Task<TOutput>>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task%601> object is completed. As with <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, by using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> for both synchronous and asynchronous processing of each input element.  \n  \n The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object that computes the square root of its input. The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object takes <xref:System.Int32> values as input and produces <xref:System.Double> values as output.  \n  \n [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]\n [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  \n  \n For complete examples that uses <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in a network of dataflow blocks that performs image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  \n  \n#### TransformManyBlock(TInput, TOutput)  \n The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class, except that <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produces zero or more output values for each input value, instead of only one output value for each input value. The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object can be of type `System.Func<TInput, IEnumerable<TOutput>>` or type `System.Func<TInput, Task<IEnumerable<TOutput>>>`. When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, IEnumerable<TOutput>>`, processing of each input element is considered completed when the delegate returns. When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, Task<IEnumerable<TOutput>>>`, processing of each input element is considered complete only when the returned `System.Threading.Tasks.Task<IEnumerable<TOutput>>` object is completed.  \n  \n The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object that splits strings into their individual character sequences. The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object takes <xref:System.String> values as input and produces <xref:System.Char> values as output.  \n  \n [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]\n [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  \n  \n For complete examples that use <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> to produce multiple independent outputs for each input in a dataflow pipeline, see [Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  \n  \n#### Degree of Parallelism  \n Every <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object buffers input messages until the block is ready to process them. By default, these classes process messages in the order in which they are received, one message at a time. You can also specify the degree of parallelism to enable <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects to process multiple messages concurrently. For more information about concurrent execution, see the section Specifying the Degree of Parallelism later in this document. For an example that sets the degree of parallelism to enable an execution dataflow block to process more than one message at a time, see [How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  \n  \n#### Summary of Delegate Types  \n The following table summarizes the delegate types that you can provide to <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects. This table also specifies whether the delegate type operates synchronously or asynchronously.  \n  \n|Type|Synchronous Delegate Type|Asynchronous Delegate Type|  \n|----------|-------------------------------|--------------------------------|  \n|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  \n|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  \n|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  \n  \n You can also use lambda expressions when you work with execution block types. For an example that shows how to use a lambda expression with an execution block, see [How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  \n  \n### Grouping Blocks  \n Grouping blocks combine data from one or more sources and under various constraints. The TPL Dataflow Library provides three join block types: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  \n  \n#### BatchBlock(T)  \n The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class combines sets of input data, which are known as batches, into arrays of output data. You specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object. When the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object receives the specified count of input elements, it asynchronously propagates out an array that contains those elements. If a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object is set to the completed state but does not contain enough elements to form a batch, it propagates out a final array that contains the remaining input elements.  \n  \n The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class operates in either *greedy* or *non-greedy* mode. In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object accepts every message that it is offered and propagates out an array after it receives the specified count of elements. In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough sources have offered messages to the block to form a batch. Greedy mode typically performs better than non-greedy mode because it requires less processing overhead. However, you can use non-greedy mode when you must coordinate consumption from multiple sources in an atomic fashion. Specify non-greedy mode by setting <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False` in the `dataflowBlockOptions` parameter in the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> constructor.  \n  \n The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object that holds ten elements in a batch. To guarantee that all values propagate out of the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, this example calls the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method. The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method sets the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object to the completed state, and therefore, the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object propagates out any remaining elements as a final batch.  \n  \n [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]\n [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  \n  \n For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> to improve the efficiency of database insert operations, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  \n  \n#### JoinBlock(T1, T2, ...)  \n The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes collect input elements and propagate out <xref:System.Tuple%602?displayProperty=nameWithType> or <xref:System.Tuple%603?displayProperty=nameWithType> objects that contain those elements. The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes do not inherit from <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Instead, they provide properties, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  \n  \n Like <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operate in either greedy or non-greedy mode. In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object accepts every message that it is offered and propagates out a tuple after each of its targets receives at least one message. In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object postpones all incoming messages until all targets have been offered the data that is required to create a tuple. At this point, the block engages in a two-phase commit protocol to atomically retrieve all required items from the sources. This postponement makes it possible for another entity to consume the data in the meantime, to allow the overall system to make forward progress.  \n  \n The following basic example demonstrates a case in which a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object requires multiple data to compute a value. This example creates a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object that requires two <xref:System.Int32> values and a <xref:System.Char> value to perform an arithmetic operation.  \n  \n [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]\n [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  \n  \n For a complete example that uses <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects in non-greedy mode to cooperatively share a resource, see [How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  \n  \n#### BatchedJoinBlock(T1, T2, ...)  \n The <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classes collect batches of input elements and propagate out `System.Tuple(IList(T1), IList(T2))` or `System.Tuple(IList(T1), IList(T2), IList(T3))` objects that contain those elements. Think of <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> as a combination of <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> also provides properties, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. When the specified count of input elements are received from across all targets, the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object asynchronously propagates out a `System.Tuple(IList(T1), IList(T2))` object that contains those elements.  \n  \n The following basic example creates a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object that holds results, <xref:System.Int32> values, and errors that are <xref:System.Exception> objects. This example performs multiple operations and writes results to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> property, and errors to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> property, of the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object. Because the count of successful and failed operations is unknown in advance, the <xref:System.Collections.Generic.IList%601> objects enable each target to receive zero or more values.  \n  \n [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]\n [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  \n  \n For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> to capture both the results and any exceptions that occur while the program reads from a database, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  \n  \n [[go to top](#top)]  \n  \n<a name=\"behavior\"></a>   \n## Configuring Dataflow  Block Behavior  \n You can enable additional options by providing a <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> object to the constructor of dataflow block types. These options control behavior such the scheduler that manages the underlying task and the degree of parallelism. The <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> also has derived types that specify behavior that is specific to certain dataflow block types. The following table summarizes which options type is associated with each dataflow block type.  \n  \n|Dataflow Block Type|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> type|  \n|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  \n|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  \n|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  \n  \n The following sections provide additional information about the important kinds of dataflow block options that are available through the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> classes.  \n  \n### Specifying the Task Scheduler  \n Every predefined dataflow block uses the TPL task scheduling mechanism to perform activities such as propagating data to a target, receiving data from a source, and running user-defined delegates when data becomes available. <xref:System.Threading.Tasks.TaskScheduler> is an abstract class that represents a task scheduler that queues tasks onto threads. The default task scheduler, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, uses the <xref:System.Threading.ThreadPool> class to queue and execute work. You can override the default task scheduler by setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> property when you construct a dataflow block object.  \n  \n When the same task scheduler manages multiple dataflow blocks, it can enforce policies across them. For example, if multiple dataflow blocks are each configured to target the exclusive scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, all work that runs across these blocks is serialized. Similarly, if these blocks are configured to target the concurrent scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, and that scheduler is configured to have a maximum concurrency level, all work from these blocks is limited to that number of concurrent operations. For an example that uses the <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> class to enable read operations to occur in parallel, but write operations to occur exclusively of all other operations, see [How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). For more information about task schedulers in the TPL, see the <xref:System.Threading.Tasks.TaskScheduler> class topic.  \n  \n### Specifying the Degree of Parallelism  \n By default, the three execution block types that the TPL Dataflow Library provides, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, process one message at a time. These dataflow block types also process messages in the order in which they are received. To enable these dataflow blocks to process messages concurrently, set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> property when you construct the dataflow block object.  \n  \n The default value of <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> is 1, which guarantees that the dataflow block processes one message at a time. Setting this property to a value that is larger than 1 enables the dataflow block to process multiple messages concurrently. Setting this property to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> enables the underlying task scheduler to manage the maximum degree of concurrency.  \n  \n> [!IMPORTANT]\n>  When you specify a maximum degree of parallelism that is larger than 1, multiple messages are processed simultaneously, and therefore messages might not be processed in the order in which they are received. The order in which the messages are output from the block is, however, the same one in which they are received.  \n  \n Because the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property represents the maximum degree of parallelism, the dataflow block might execute with a lesser degree of parallelism than you specify. The dataflow block might use a lesser degree of parallelism to meet its functional requirements or because there is a lack of available system resources. A dataflow block never chooses more parallelism than you specify.  \n  \n The value of the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property is exclusive to each dataflow block object. For example, if four dataflow block objects each specify 1 for the maximum degree of parallelism, all four dataflow block objects can potentially run in parallel.  \n  \n For an example that sets the maximum degree of parallelism to enable lengthy operations to occur in parallel, see [How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  \n  \n### Specifying the Number of Messages per Task  \n The predefined dataflow block types use tasks to process multiple input elements. This helps minimize the number of task objects that are required to process data, which enables applications to run more efficiently. However, when the tasks from one set of dataflow blocks are processing data, the tasks from other dataflow blocks might need to wait for processing time by queuing messages. To enable better fairness among dataflow tasks, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property. When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, which is the default, the task used by a dataflow block processes as many messages as are available. When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to a value other than <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, the dataflow block processes at most this number of messages per <xref:System.Threading.Tasks.Task> object. Although setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property can increase fairness among tasks, it can cause the system to create more tasks than are necessary, which can decrease performance.  \n  \n### Enabling Cancellation  \n The TPL provides a mechanism that enables tasks to coordinate cancellation in a cooperative manner. To enable dataflow blocks to participate in this cancellation mechanism, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> property. When this <xref:System.Threading.CancellationToken> object is set to the canceled state, all dataflow blocks that monitor this token finish execution of their current item but do not start processing subsequent items. These dataflow blocks also clear any buffered messages, release connections to any source and target blocks, and transition to the canceled state. By transitioning to the canceled state, the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property has the <xref:System.Threading.Tasks.Task.Status%2A> property set to <xref:System.Threading.Tasks.TaskStatus.Canceled>, unless an exception occurred during processing. In that case, <xref:System.Threading.Tasks.Task.Status%2A> is set to <xref:System.Threading.Tasks.TaskStatus.Faulted>.  \n  \n For an example that demonstrates how to use cancellation in a Windows Forms application, see [How to: Cancel a Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). For more information about cancellation in the TPL, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).  \n  \n### Specifying Greedy Versus Non-Greedy Behavior  \n Several grouping dataflow block types can operate in either *greedy* or *non-greedy* mode. By default, the predefined dataflow block types operate in greedy mode.  \n  \n For join block types such as <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, greedy mode means that the block immediately accepts data even if the corresponding data with which to join is not yet available. Non-greedy mode means that the block postpones all incoming messages until one is available on each of its targets to complete the join. If any of the postponed messages are no longer available, the join block releases all postponed messages and restarts the process. For the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class, greedy and non-greedy behavior is similar, except that under non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough are available from distinct sources to complete a batch.  \n  \n To specify non-greedy mode for a dataflow block, set <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False`. For an example that demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently, see [How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  \n  \n [[go to top](#top)]  \n  \n<a name=\"custom\"></a>   \n## Custom Dataflow Blocks  \n Although the TPL Dataflow Library provides many predefined block types, you can create additional block types that perform custom behavior. Implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> or <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfaces directly or use the  <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> method to build a complex block that encapsulates the behavior of existing block types. For examples that show how to implement custom dataflow block functionality, see [Walkthrough: Creating a Custom Dataflow Block Type](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  \n  \n [[go to top](#top)]  \n  \n## Related Topics  \n  \n|Title|Description|  \n|-----------|-----------------|  \n|[How to: Write Messages to and Read Messages from a Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object.|  \n|[How to: Implement a Producer-Consumer Dataflow Pattern](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Describes how to use the dataflow model to implement a producer-consumer pattern, where the producer sends messages to a dataflow block, and the consumer reads messages from that block.|  \n|[How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Describes how to provide delegates to the execution dataflow block types, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  \n|[Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Describes how to create a dataflow pipeline that downloads text from the web and performs operations on that text.|  \n|[How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Demonstrates how to use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> method to unlink a target block from its source after the source offers a message to the target.|  \n|[Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Demonstrates how to create a network of dataflow blocks that perform image processing in a Windows Forms application.|  \n|[How to: Cancel a Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Demonstrates how to use cancellation in a Windows Forms application.|  \n|[How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Explains how to use the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class to perform an operation when data is available from multiple sources, and how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently.|  \n|[How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Describes how to set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property to enable an execution dataflow block to process more than one message at a time.|  \n|[How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Demonstrates how to associate a specific task scheduler when you use dataflow in your application.|  \n|[Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Describes how to use the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class to improve the efficiency of database insert operations, and how to use the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> class to capture both the results and any exceptions that occur while the program reads from a database.|  \n|[Walkthrough: Creating a Custom Dataflow Block Type](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Demonstrates two ways to create a dataflow block type that implements custom behavior.|  \n|[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Introduces the TPL, a library that simplifies parallel and concurrent programming in [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] applications.|\n","nodes":[{"pos":[4,309],"embed":true,"restype":"x-metadata","content":"title: \"Dataflow (Task Parallel Library)\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"Task Parallel Library, dataflows\"\n  - \"TPL dataflow library\"\nms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Dataflow (Task Parallel Library)","nodes":[{"pos":[0,32],"content":"Dataflow (Task Parallel Library)","nodes":[{"content":"Dataflow (Task Parallel Library)","pos":[0,32]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[316,348],"content":"Dataflow (Task Parallel Library)","linkify":"Dataflow (Task Parallel Library)","nodes":[{"content":"Dataflow (Task Parallel Library)","pos":[0,32]}]},{"content":"<bpt id=\"p1\">&lt;a name=\"top\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications.","pos":[349,497],"source":"<a name=\"top\"></a> The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications."},{"content":"These dataflow components are collectively referred to as the <bpt id=\"p1\">*</bpt>TPL Dataflow Library<ept id=\"p1\">*</ept>.","pos":[498,583],"source":" These dataflow components are collectively referred to as the *TPL Dataflow Library*."},{"content":"This dataflow model promotes actor-based programming by providing in-process message passing for coarse-grained dataflow and pipelining tasks.","pos":[584,726]},{"content":"The dataflow components build on the types and scheduling infrastructure of the TPL and integrate with the C#, Visual Basic, and F# language support for asynchronous programming.","pos":[727,905]},{"content":"These dataflow components are useful when you have multiple operations that must communicate with one another asynchronously or when you want to process data as it becomes available.","pos":[906,1088]},{"content":"For example, consider an application that processes image data from a web camera.","pos":[1089,1170]},{"content":"By using the dataflow model, the application can process image frames as they become available.","pos":[1171,1266]},{"content":"If the application enhances image frames, for example, by performing light correction or red-eye reduction, you can create a <bpt id=\"p1\">*</bpt>pipeline<ept id=\"p1\">*</ept> of dataflow components.","pos":[1267,1426],"source":" If the application enhances image frames, for example, by performing light correction or red-eye reduction, you can create a *pipeline* of dataflow components."},{"content":"Each stage of the pipeline might use more coarse-grained parallelism functionality, such as the functionality that is provided by the TPL, to transform the image.","pos":[1427,1589]},{"content":"This document provides an overview of the TPL Dataflow Library.","pos":[1596,1659]},{"content":"It describes the programming model, the predefined dataflow block types, and how to configure dataflow blocks to meet the specific requirements of your applications.","pos":[1660,1825]},{"content":"This document contains the following sections:","pos":[1918,1964]},{"pos":[1974,2001],"content":"<bpt id=\"p1\">[</bpt>Programming Model<ept id=\"p1\">](#model)</ept>","source":"[Programming Model](#model)"},{"pos":[2011,2063],"content":"<bpt id=\"p1\">[</bpt>Predefined Dataflow Block Types<ept id=\"p1\">](#predefined_types)</ept>","source":"[Predefined Dataflow Block Types](#predefined_types)"},{"pos":[2073,2121],"content":"<bpt id=\"p1\">[</bpt>Configuring Dataflow Block Behavior<ept id=\"p1\">](#behavior)</ept>","source":"[Configuring Dataflow Block Behavior](#behavior)"},{"pos":[2131,2164],"content":"<bpt id=\"p1\">[</bpt>Custom Dataflow Blocks<ept id=\"p1\">](#custom)</ept>","source":"[Custom Dataflow Blocks](#custom)"},{"pos":[2197,2214],"content":"Programming Model","linkify":"Programming Model","nodes":[{"content":"Programming Model","pos":[0,17]}]},{"content":"The TPL Dataflow Library provides a foundation for message passing and parallelizing CPU-intensive and I/O-intensive applications that have high throughput and low latency.","pos":[2218,2390]},{"content":"It also gives you explicit control over how data is buffered and moves around the system.","pos":[2391,2480]},{"content":"To better understand the dataflow programming model, consider an application that asynchronously loads images from disk and creates a composite of those images.","pos":[2481,2641]},{"content":"Traditional programming models typically require that you use callbacks and synchronization objects, such as locks, to coordinate tasks and access to shared data.","pos":[2642,2804]},{"content":"By using the dataflow programming model, you can create dataflow objects that process images as they are read from disk.","pos":[2805,2925]},{"content":"Under the dataflow model, you declare how data is handled when it becomes available, and also any dependencies between data.","pos":[2926,3050]},{"content":"Because the runtime manages dependencies between data, you can often avoid the requirement to synchronize access to shared data.","pos":[3051,3179]},{"content":"In addition, because the runtime schedules work based on the asynchronous arrival of data, dataflow can improve responsiveness and throughput by efficiently managing the underlying threads.","pos":[3180,3369]},{"content":"For an example that uses the dataflow programming model to implement image processing in a Windows Forms application, see <bpt id=\"p1\">[</bpt>Walkthrough: Using Dataflow in a Windows Forms Application<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)</ept>.","pos":[3370,3659],"source":" For an example that uses the dataflow programming model to implement image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)."},{"pos":[3669,3688],"content":"Sources and Targets","linkify":"Sources and Targets","nodes":[{"content":"Sources and Targets","pos":[0,19]}]},{"content":"The TPL Dataflow Library consists of <bpt id=\"p1\">*</bpt>dataflow blocks<ept id=\"p1\">*</ept>, which are data structures that buffer and process data.","pos":[3692,3803],"source":"The TPL Dataflow Library consists of *dataflow blocks*, which are data structures that buffer and process data."},{"content":"The TPL defines three kinds of dataflow blocks: <bpt id=\"p1\">*</bpt>source blocks<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>target blocks<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>propagator blocks<ept id=\"p3\">*</ept>.","pos":[3804,3910],"source":" The TPL defines three kinds of dataflow blocks: *source blocks*, *target blocks*, and *propagator blocks*."},{"content":"A source block acts as a source of data and can be read from.","pos":[3911,3972]},{"content":"A target block acts as a receiver of data and can be written to.","pos":[3973,4037]},{"content":"A propagator block acts as both a source block and a target block, and can be read from and written to.","pos":[4038,4141]},{"content":"The TPL defines the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType&gt;</ph> interface to represent sources, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType&gt;</ph> to represent targets, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType&gt;</ph> to represent propagators.","pos":[4142,4504],"source":" The TPL defines the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interface to represent sources, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> to represent targets, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> to represent propagators."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602&gt;</ph> inherits from both <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601&gt;</ph>.","pos":[4505,4701],"source":"<xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> inherits from both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>."},{"content":"The TPL Dataflow Library provides several predefined dataflow block types that implement the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602&gt;</ph> interfaces.","pos":[4708,4990],"source":"The TPL Dataflow Library provides several predefined dataflow block types that implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces."},{"content":"These dataflow block types are described in this document in the section <bpt id=\"p1\">[</bpt>Predefined Dataflow Block Types<ept id=\"p1\">](#predefined_types)</ept>.","pos":[4991,5117],"source":" These dataflow block types are described in this document in the section [Predefined Dataflow Block Types](#predefined_types)."},{"pos":[5127,5144],"content":"Connecting Blocks","linkify":"Connecting Blocks","nodes":[{"content":"Connecting Blocks","pos":[0,17]}]},{"content":"You can connect dataflow blocks to form <bpt id=\"p1\">*</bpt>pipelines<ept id=\"p1\">*</ept>, which are linear sequences of dataflow blocks, or <bpt id=\"p2\">*</bpt>networks<ept id=\"p2\">*</ept>, which are graphs of dataflow blocks.","pos":[5148,5299],"source":"You can connect dataflow blocks to form *pipelines*, which are linear sequences of dataflow blocks, or *networks*, which are graphs of dataflow blocks."},{"content":"A pipeline is one form of network.","pos":[5300,5334]},{"content":"In a pipeline or network, sources asynchronously propagate data to targets as that data becomes available.","pos":[5335,5441]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType&gt;</ph> method links a source dataflow block to a target block.","pos":[5442,5596],"source":" The <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method links a source dataflow block to a target block."},{"content":"A source can be linked to zero or more targets; targets can be linked from zero or more sources.","pos":[5597,5693]},{"content":"You can add or remove dataflow blocks to or from a pipeline or network concurrently.","pos":[5694,5778]},{"content":"The predefined dataflow block types handle all thread-safety aspects of linking and unlinking.","pos":[5779,5873]},{"content":"For an example that connects dataflow blocks to form a basic pipeline, see <bpt id=\"p1\">[</bpt>Walkthrough: Creating a Dataflow Pipeline<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)</ept>.","pos":[5880,6088],"source":"For an example that connects dataflow blocks to form a basic pipeline, see [Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)."},{"content":"For an example that connects dataflow blocks to form a more complex network, see <bpt id=\"p1\">[</bpt>Walkthrough: Using Dataflow in a Windows Forms Application<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)</ept>.","pos":[6089,6337],"source":" For an example that connects dataflow blocks to form a more complex network, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)."},{"content":"For an example that unlinks a target from a source after the source offers the target a message, see <bpt id=\"p1\">[</bpt>How to: Unlink Dataflow Blocks<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)</ept>.","pos":[6338,6550],"source":" For an example that unlinks a target from a source after the source offers the target a message, see [How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)."},{"pos":[6561,6570],"content":"Filtering","linkify":"Filtering","nodes":[{"content":"Filtering","pos":[0,9]}]},{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType&gt;</ph> method to link a source to a target, you can supply a delegate that determines whether the target block accepts or rejects a message based on the value of that message.","pos":[6574,6855],"source":"When you call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method to link a source to a target, you can supply a delegate that determines whether the target block accepts or rejects a message based on the value of that message."},{"content":"This filtering mechanism is a useful way to guarantee that a dataflow block receives only certain values.","pos":[6856,6961]},{"content":"For most of the predefined dataflow block types, if a source block is connected to multiple target blocks, when a target block rejects a message, the source offers that message to the next target.","pos":[6962,7158]},{"content":"The order in which a source offers messages to targets is defined by the source and can vary according to the type of the source.","pos":[7159,7288]},{"content":"Most source block types stop offering a message after one target accepts that message.","pos":[7289,7375]},{"content":"One exception to this rule is the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601&gt;</ph> class, which offers each message to all targets, even if some targets reject the message.","pos":[7376,7557],"source":" One exception to this rule is the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, which offers each message to all targets, even if some targets reject the message."},{"content":"For an example that uses filtering to process only certain messages, see <bpt id=\"p1\">[</bpt>Walkthrough: Using Dataflow in a Windows Forms Application<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)</ept>.","pos":[7558,7798],"source":" For an example that uses filtering to process only certain messages, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)."},{"pos":[7806,8243],"content":"[!IMPORTANT]\n Because each predefined source dataflow block type guarantees that messages are propagated out in the order in which they are received, every message must be read from the source block before the source block can process the next message. Therefore, when you use filtering to connect multiple targets to a source, make sure that at least one target block receives each message. Otherwise, your application might deadlock.","leadings":["","> "],"nodes":[{"content":"Because each predefined source dataflow block type guarantees that messages are propagated out in the order in which they are received, every message must be read from the source block before the source block can process the next message. Therefore, when you use filtering to connect multiple targets to a source, make sure that at least one target block receives each message. Otherwise, your application might deadlock.","pos":[14,435],"nodes":[{"content":"Because each predefined source dataflow block type guarantees that messages are propagated out in the order in which they are received, every message must be read from the source block before the source block can process the next message.","pos":[0,238]},{"content":"Therefore, when you use filtering to connect multiple targets to a source, make sure that at least one target block receives each message.","pos":[239,377]},{"content":"Otherwise, your application might deadlock.","pos":[378,421]}]}]},{"pos":[8253,8268],"content":"Message Passing","linkify":"Message Passing","nodes":[{"content":"Message Passing","pos":[0,15]}]},{"content":"The dataflow programming model is related to the concept of <bpt id=\"p1\">*</bpt>message passing<ept id=\"p1\">*</ept>, where independent components of a program communicate with one another by sending messages.","pos":[8272,8442],"source":"The dataflow programming model is related to the concept of *message passing*, where independent components of a program communicate with one another by sending messages."},{"content":"One way to propagate messages among application components is to call the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType&gt;</ph> methods to send messages to target dataflow blocks post (<ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A&gt;</ph> acts synchronously; <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A&gt;</ph> acts asynchronously) and the <ph id=\"ph5\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A&gt;</ph>, and <ph id=\"ph7\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A&gt;</ph> methods to receive messages from source blocks.","pos":[8443,9163],"source":" One way to propagate messages among application components is to call the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> methods to send messages to target dataflow blocks post (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> acts synchronously; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> acts asynchronously) and the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> methods to receive messages from source blocks."},{"content":"You can combine these methods with dataflow pipelines or networks by sending input data to the head node (a target block), and receiving output data from the terminal node of the pipeline or the terminal nodes of the network (one or more source blocks).","pos":[9164,9417]},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A&gt;</ph> method to read from the first of the provided sources that has data available and perform action on that data.","pos":[9418,9612],"source":" You can also use the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> method to read from the first of the provided sources that has data available and perform action on that data."},{"content":"Source blocks offer data to target blocks by calling the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[9619,9784],"source":"Source blocks offer data to target blocks by calling the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> method."},{"content":"The target block responds to an offered message in one of three ways: it can accept the message, decline the message, or postpone the message.","pos":[9785,9927]},{"content":"When the target accepts the message, the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A&gt;</ph> method returns <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&gt;</ph>.","pos":[9928,10126],"source":" When the target accepts the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>."},{"content":"When the target declines the message, the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A&gt;</ph> method returns <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&gt;</ph>.","pos":[10127,10326],"source":" When the target declines the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>."},{"content":"When the target requires that it no longer receives any messages from the source, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A&gt;</ph> returns <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&gt;</ph>.","pos":[10327,10571],"source":" When the target requires that it no longer receives any messages from the source, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>."},{"content":"The predefined source block types do not offer messages to linked targets after such a return value is received, and they automatically unlink from such targets.","pos":[10572,10733]},{"content":"When a target block postpones the message for later use, the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A&gt;</ph> method returns <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&gt;</ph>.","pos":[10740,10959],"source":"When a target block postpones the message for later use, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>."},{"content":"A target block that postpones a message can later call the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType&gt;</ph> method to try to reserve the offered message.","pos":[10960,11167],"source":" A target block that postpones a message can later call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> method to try to reserve the offered message."},{"content":"At this point, the message is either still available and can be used by the target block, or the message has been taken by another target.","pos":[11168,11306]},{"content":"When the target block later requires the message or no longer needs the message, it calls the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A&gt;</ph> method, respectively.","pos":[11307,11606],"source":" When the target block later requires the message or no longer needs the message, it calls the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> method, respectively."},{"content":"Message reservation is typically used by the dataflow block types that operate in non-greedy mode.","pos":[11607,11705]},{"content":"Non-greedy mode is explained later in this document.","pos":[11706,11758]},{"content":"Instead of reserving a postponed message, a target block can also use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType&gt;</ph> method to attempt to directly consume the postponed message.","pos":[11759,11996],"source":" Instead of reserving a postponed message, a target block can also use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> method to attempt to directly consume the postponed message."},{"pos":[12006,12031],"content":"Dataflow Block Completion","linkify":"Dataflow Block Completion","nodes":[{"content":"Dataflow Block Completion","pos":[0,25]}]},{"content":"Dataflow blocks also support the concept of <bpt id=\"p1\">*</bpt>completion<ept id=\"p1\">*</ept>.","pos":[12035,12092],"source":"Dataflow blocks also support the concept of *completion*."},{"content":"A dataflow block that is in the completed state does not perform any further work.","pos":[12093,12175]},{"content":"Each dataflow block has an associated <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> object, known as a <bpt id=\"p1\">*</bpt>completion task<ept id=\"p1\">*</ept>, that represents the completion status of the block.","pos":[12176,12367],"source":" Each dataflow block has an associated <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object, known as a *completion task*, that represents the completion status of the block."},{"content":"Because you can wait for a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object to finish, by using completion tasks, you can wait for one or more terminal nodes of a dataflow network to finish.","pos":[12368,12551],"source":" Because you can wait for a <xref:System.Threading.Tasks.Task> object to finish, by using completion tasks, you can wait for one or more terminal nodes of a dataflow network to finish."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock&gt;</ph> interface defines the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A&gt;</ph> method, which informs the dataflow block of a request for it to complete, and the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A&gt;</ph> property, which returns the completion task for the dataflow block.","pos":[12552,12915],"source":" The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface defines the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method, which informs the dataflow block of a request for it to complete, and the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, which returns the completion task for the dataflow block."},{"content":"Both <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601&gt;</ph> inherit the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock&gt;</ph> interface.","pos":[12916,13113],"source":" Both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> inherit the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface."},{"content":"There are two ways to determine whether a dataflow block completed without error, encountered one or more errors, or was canceled.","pos":[13120,13250]},{"content":"The first way is to call the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method on the completion task in a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">-</ph><ph id=\"ph4\">`catch`</ph> block (<ph id=\"ph5\">`Try`</ph><ph id=\"ph6\">-</ph><ph id=\"ph7\">`Catch`</ph> in Visual Basic).","pos":[13251,13439],"source":" The first way is to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method on the completion task in a `try`-`catch` block (`Try`-`Catch` in Visual Basic)."},{"content":"The following example creates an <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> object that throws <ph id=\"ph2\">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> if its input value is less than zero.","pos":[13440,13626],"source":" The following example creates an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object that throws <xref:System.ArgumentOutOfRangeException> if its input value is less than zero."},{"content":"<ph id=\"ph1\">&lt;xref:System.AggregateException&gt;</ph> is thrown when this example calls <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> on the completion task.","pos":[13627,13760],"source":"<xref:System.AggregateException> is thrown when this example calls <xref:System.Threading.Tasks.Task.Wait%2A> on the completion task."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> is accessed through the <ph id=\"ph2\">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> property of the <ph id=\"ph3\">&lt;xref:System.AggregateException&gt;</ph> object.","pos":[13761,13939],"source":" The <xref:System.ArgumentOutOfRangeException> is accessed through the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> object."},{"content":"This example demonstrates the case in which an exception goes unhandled in the delegate of an execution dataflow block.","pos":[14212,14331]},{"content":"We recommend that you handle exceptions in the bodies of such blocks.","pos":[14332,14401]},{"content":"However, if you are unable to do so, the block behaves as though it was canceled and does not process incoming messages.","pos":[14402,14522]},{"content":"When a dataflow block is canceled explicitly, the <ph id=\"ph1\">&lt;xref:System.AggregateException&gt;</ph> object contains <ph id=\"ph2\">&lt;xref:System.OperationCanceledException&gt;</ph> in the <ph id=\"ph3\">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> property.","pos":[14529,14737],"source":"When a dataflow block is canceled explicitly, the <xref:System.AggregateException> object contains <xref:System.OperationCanceledException> in the <xref:System.AggregateException.InnerExceptions%2A> property."},{"content":"For more information about dataflow cancellation, see <bpt id=\"p1\">[</bpt>Enabling Cancellation<ept id=\"p1\">](#enabling-cancellation)</ept> section.","pos":[14738,14848],"source":" For more information about dataflow cancellation, see [Enabling Cancellation](#enabling-cancellation) section."},{"content":"The second way to determine the completion status of a dataflow block is to use a continuation of the completion task, or to use the asynchronous language features of C# and Visual Basic to asynchronously wait for the completion task.","pos":[14855,15089]},{"content":"The delegate that you provide to the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType&gt;</ph> method takes a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that represents the antecedent task.","pos":[15090,15300],"source":" The delegate that you provide to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method takes a <xref:System.Threading.Tasks.Task> object that represents the antecedent task."},{"content":"In the case of the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A&gt;</ph> property, the delegate for the continuation takes the completion task itself.","pos":[15301,15465],"source":" In the case of the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, the delegate for the continuation takes the completion task itself."},{"content":"The following example resembles the previous one, except that it also uses the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> method to create a continuation task that prints the status of the overall dataflow operation.","pos":[15466,15690],"source":" The following example resembles the previous one, except that it also uses the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method to create a continuation task that prints the status of the overall dataflow operation."},{"content":"You can also use properties such as <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> in the body of the continuation task to determine additional information about the completion status of a dataflow block.","pos":[15963,16169],"source":"You can also use properties such as <xref:System.Threading.Tasks.Task.IsCanceled%2A> in the body of the continuation task to determine additional information about the completion status of a dataflow block."},{"content":"For more information about continuation tasks and how they relate to cancellation and error handling, see <bpt id=\"p1\">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id=\"p1\">](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>, <bpt id=\"p2\">[</bpt>Task Cancellation<ept id=\"p2\">](../../../docs/standard/parallel-programming/task-cancellation.md)</ept>, and <bpt id=\"p3\">[</bpt>Exception Handling<ept id=\"p3\">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.","pos":[16170,16614],"source":" For more information about continuation tasks and how they relate to cancellation and error handling, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md), and [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)."},{"pos":[16621,16640],"content":"[<bpt id=\"p1\">[</bpt>go to top<ept id=\"p1\">](#top)</ept>]","source":"[[go to top](#top)]"},{"pos":[16684,16715],"content":"Predefined Dataflow Block Types","linkify":"Predefined Dataflow Block Types","nodes":[{"content":"Predefined Dataflow Block Types","pos":[0,31]}]},{"content":"The TPL Dataflow Library provides several predefined dataflow block types.","pos":[16719,16793]},{"content":"These types are divided into three categories: <bpt id=\"p1\">*</bpt>buffering blocks<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>execution blocks<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>grouping blocks<ept id=\"p3\">*</ept>.","pos":[16794,16903],"source":" These types are divided into three categories: *buffering blocks*, *execution blocks*, and *grouping blocks*."},{"content":"The following sections describe the block types that make up these categories.","pos":[16904,16982]},{"pos":[16992,17008],"content":"Buffering Blocks","linkify":"Buffering Blocks","nodes":[{"content":"Buffering Blocks","pos":[0,16]}]},{"content":"Buffering blocks hold data for use by data consumers.","pos":[17012,17065]},{"content":"The TPL Dataflow Library provides three buffering block types: <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType&gt;</ph>.","pos":[17066,17393],"source":" The TPL Dataflow Library provides three buffering block types: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>."},{"pos":[17404,17418],"content":"BufferBlock(T)","linkify":"BufferBlock(T)","nodes":[{"content":"BufferBlock(T)","pos":[0,14]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> class represents a general-purpose asynchronous messaging structure.","pos":[17422,17549],"source":"The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class represents a general-purpose asynchronous messaging structure."},{"content":"This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets.","pos":[17550,17691]},{"content":"When a target receives a message from a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> object, that message is removed from the message queue.","pos":[17692,17842],"source":" When a target receives a message from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, that message is removed from the message queue."},{"content":"Therefore, although a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> object can have multiple targets, only one target will receive each message.","pos":[17843,17996],"source":" Therefore, although a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object can have multiple targets, only one target will receive each message."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> class is useful when you want to pass multiple messages to another component, and that component must receive each message.","pos":[17997,18179],"source":" The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class is useful when you want to pass multiple messages to another component, and that component must receive each message."},{"pos":[18186,18372],"content":"The following basic example posts several <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph> values to a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> object and then reads those values back from that object.","source":"The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object and then reads those values back from that object."},{"pos":[18641,18980],"content":"For a complete example that demonstrates how to write messages to and read messages from a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> object, see <bpt id=\"p1\">[</bpt>How to: Write Messages to and Read Messages from a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)</ept>.","source":"For a complete example that demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, see [How to: Write Messages to and Read Messages from a Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)."},{"pos":[18991,19008],"content":"BroadcastBlock(T)","linkify":"BroadcastBlock(T)","nodes":[{"content":"BroadcastBlock(T)","pos":[0,17]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601&gt;</ph> class is useful when you must pass multiple messages to another component, but that component needs only the most recent value.","pos":[19012,19201],"source":"The <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class is useful when you must pass multiple messages to another component, but that component needs only the most recent value."},{"content":"This class is also useful when you want to broadcast a message to multiple components.","pos":[19202,19288]},{"content":"The following basic example posts a <ph id=\"ph1\">&lt;xref:System.Double&gt;</ph> value to a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601&gt;</ph> object and then reads that value back from that object several times.","pos":[19295,19490],"source":"The following basic example posts a <xref:System.Double> value to a <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> object and then reads that value back from that object several times."},{"content":"Because values are not removed from <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601&gt;</ph> objects after they are read, the same value is available every time.","pos":[19491,19653],"source":" Because values are not removed from <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objects after they are read, the same value is available every time."},{"pos":[19922,20241],"content":"For a complete example that demonstrates how to use <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601&gt;</ph> to broadcast a message to multiple target blocks, see <bpt id=\"p1\">[</bpt>How to: Specify a Task Scheduler in a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)</ept>.","source":"For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> to broadcast a message to multiple target blocks, see [How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)."},{"pos":[20252,20269],"content":"WriteOnceBlock(T)","linkify":"WriteOnceBlock(T)","nodes":[{"content":"WriteOnceBlock(T)","pos":[0,17]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> class resembles the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601&gt;</ph> class, except that a <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> object can be written to one time only.","pos":[20273,20531],"source":"The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class resembles the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only."},{"content":"You can think of <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> as being similar to the C# <bpt id=\"p1\">[</bpt>readonly<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/readonly.md)</ept> (<bpt id=\"p2\">[</bpt>ReadOnly<ept id=\"p2\">](~/docs/visual-basic/language-reference/modifiers/readonly.md)</ept> in Visual Basic) keyword, except that a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> object becomes immutable after it receives a value instead of at construction.","pos":[20532,20950],"source":" You can think of <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> as being similar to the C# [readonly](~/docs/csharp/language-reference/keywords/readonly.md) ([ReadOnly](~/docs/visual-basic/language-reference/modifiers/readonly.md) in Visual Basic) keyword, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object becomes immutable after it receives a value instead of at construction."},{"content":"Like the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601&gt;</ph> class, when a target receives a message from a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> object, that message is not removed from that object.","pos":[20951,21176],"source":" Like the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, when a target receives a message from a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object, that message is not removed from that object."},{"content":"Therefore, multiple targets receive a copy of the message.","pos":[21177,21235]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> class is useful when you want to propagate only the first of multiple messages.","pos":[21236,21377],"source":" The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class is useful when you want to propagate only the first of multiple messages."},{"content":"The following basic example posts multiple <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> values to a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> object and then reads the value back from that object.","pos":[21384,21572],"source":"The following basic example posts multiple <xref:System.String> values to a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object and then reads the value back from that object."},{"content":"Because a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> object can be written to one time only, after a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> object receives a message, it discards subsequent messages.","pos":[21573,21806],"source":" Because a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only, after a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object receives a message, it discards subsequent messages."},{"pos":[22075,22359],"content":"For a complete example that demonstrates how to use <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601&gt;</ph> to receive the value of the first operation that finishes, see <bpt id=\"p1\">[</bpt>How to: Unlink Dataflow Blocks<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)</ept>.","source":"For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> to receive the value of the first operation that finishes, see [How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)."},{"pos":[22369,22385],"content":"Execution Blocks","linkify":"Execution Blocks","nodes":[{"content":"Execution Blocks","pos":[0,16]}]},{"content":"Execution blocks call a user-provided delegate for each piece of received data.","pos":[22389,22468]},{"content":"The TPL Dataflow Library provides three execution block types: <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType&gt;</ph>.","pos":[22469,22771],"source":" The TPL Dataflow Library provides three execution block types: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>."},{"pos":[22782,22796],"content":"ActionBlock(T)","linkify":"ActionBlock(T)","nodes":[{"content":"ActionBlock(T)","pos":[0,14]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> class is a target block that calls a delegate when it receives data.","pos":[22800,22927],"source":"The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class is a target block that calls a delegate when it receives data."},{"content":"Think of a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> object as a delegate that runs asynchronously when data becomes available.","pos":[22928,23068],"source":" Think of a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object as a delegate that runs asynchronously when data becomes available."},{"content":"The delegate that you provide to an <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> object can be of type <ph id=\"ph2\">&lt;xref:System.Action%601&gt;</ph> or type <ph id=\"ph3\">`System.Func&lt;TInput, Task&gt;`</ph>.","pos":[23069,23243],"source":" The delegate that you provide to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object can be of type <xref:System.Action%601> or type `System.Func<TInput, Task>`."},{"content":"When you use an <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> object with <ph id=\"ph2\">&lt;xref:System.Action%601&gt;</ph>, processing of each input element is considered completed when the delegate returns.","pos":[23244,23436],"source":" When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with <xref:System.Action%601>, processing of each input element is considered completed when the delegate returns."},{"content":"When you use an <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> object with <ph id=\"ph2\">`System.Func&lt;TInput, Task&gt;`</ph>, processing of each input element is considered completed only when the returned <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object is completed.","pos":[23437,23684],"source":" When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with `System.Func<TInput, Task>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task> object is completed."},{"content":"By using these two mechanisms, you can use <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> for both synchronous and asynchronous processing of each input element.","pos":[23685,23854],"source":" By using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> for both synchronous and asynchronous processing of each input element."},{"content":"The following basic example posts multiple <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph> values to an <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> object.","pos":[23861,23999],"source":"The following basic example posts multiple <xref:System.Int32> values to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> object prints those values to the console.","pos":[24000,24101],"source":" The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object prints those values to the console."},{"content":"This example then sets the block to the completed state and waits for all dataflow tasks to finish.","pos":[24102,24201]},{"pos":[24470,24772],"content":"For complete examples that demonstrate how to use delegates with the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> class, see <bpt id=\"p1\">[</bpt>How to: Perform Action When a Dataflow Block Receives Data<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)</ept>.","source":"For complete examples that demonstrate how to use delegates with the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, see [How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)."},{"pos":[24783,24814],"content":"TransformBlock(TInput, TOutput)","linkify":"TransformBlock(TInput, TOutput)","nodes":[{"content":"TransformBlock(TInput, TOutput)","pos":[0,31]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> class resembles the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph> class, except that it acts as both a source and as a target.","pos":[24818,25015],"source":"The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, except that it acts as both a source and as a target."},{"content":"The delegate that you pass to a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> object returns a value of type <ph id=\"ph2\">`TOutput`</ph>.","pos":[25016,25147],"source":" The delegate that you pass to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object returns a value of type `TOutput`."},{"content":"The delegate that you provide to a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> object can be of type <ph id=\"ph2\">`System.Func&lt;TInput, TOutput&gt;`</ph> or type <ph id=\"ph3\">`System.Func&lt;TInput, Task&lt;TOutput&gt;&gt;`</ph>.","pos":[25148,25339],"source":" The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object can be of type `System.Func<TInput, TOutput>` or type `System.Func<TInput, Task<TOutput>>`."},{"content":"When you use a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> object with <ph id=\"ph2\">`System.Func&lt;TInput, TOutput&gt;`</ph>, processing of each input element is considered completed when the delegate returns.","pos":[25340,25540],"source":" When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object with `System.Func<TInput, TOutput>`, processing of each input element is considered completed when the delegate returns."},{"content":"When you use a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> object used with <ph id=\"ph2\">`System.Func&lt;TInput, Task&lt;TOutput&gt;&gt;`</ph>, processing of each input element is considered completed only when the returned <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object is completed.","pos":[25541,25808],"source":" When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object used with `System.Func<TInput, Task<TOutput>>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task%601> object is completed."},{"content":"As with <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph>, by using these two mechanisms, you can use <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> for both synchronous and asynchronous processing of each input element.","pos":[25809,26045],"source":" As with <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, by using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> for both synchronous and asynchronous processing of each input element."},{"content":"The following basic example creates a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> object that computes the square root of its input.","pos":[26052,26198],"source":"The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object that computes the square root of its input."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> object takes <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> values as input and produces <ph id=\"ph3\">&lt;xref:System.Double&gt;</ph> values as output.","pos":[26199,26361],"source":" The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object takes <xref:System.Int32> values as input and produces <xref:System.Double> values as output."},{"pos":[26630,26986],"content":"For complete examples that uses <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> in a network of dataflow blocks that performs image processing in a Windows Forms application, see <bpt id=\"p1\">[</bpt>Walkthrough: Using Dataflow in a Windows Forms Application<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)</ept>.","source":"For complete examples that uses <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in a network of dataflow blocks that performs image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)."},{"pos":[26997,27032],"content":"TransformManyBlock(TInput, TOutput)","linkify":"TransformManyBlock(TInput, TOutput)","nodes":[{"content":"TransformManyBlock(TInput, TOutput)","pos":[0,35]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> class resembles the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> class, except that <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> produces zero or more output values for each input value, instead of only one output value for each input value.","pos":[27036,27373],"source":"The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class, except that <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produces zero or more output values for each input value, instead of only one output value for each input value."},{"content":"The delegate that you provide to a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> object can be of type <ph id=\"ph2\">`System.Func&lt;TInput, IEnumerable&lt;TOutput&gt;&gt;`</ph> or type <ph id=\"ph3\">`System.Func&lt;TInput, Task&lt;IEnumerable&lt;TOutput&gt;&gt;&gt;`</ph>.","pos":[27374,27595],"source":" The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object can be of type `System.Func<TInput, IEnumerable<TOutput>>` or type `System.Func<TInput, Task<IEnumerable<TOutput>>>`."},{"content":"When you use a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> object with <ph id=\"ph2\">`System.Func&lt;TInput, IEnumerable&lt;TOutput&gt;&gt;`</ph>, processing of each input element is considered completed when the delegate returns.","pos":[27596,27813],"source":" When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, IEnumerable<TOutput>>`, processing of each input element is considered completed when the delegate returns."},{"content":"When you use a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> object with <ph id=\"ph2\">`System.Func&lt;TInput, Task&lt;IEnumerable&lt;TOutput&gt;&gt;&gt;`</ph>, processing of each input element is considered complete only when the returned <ph id=\"ph3\">`System.Threading.Tasks.Task&lt;IEnumerable&lt;TOutput&gt;&gt;`</ph> object is completed.","pos":[27814,28105],"source":" When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, Task<IEnumerable<TOutput>>>`, processing of each input element is considered complete only when the returned `System.Threading.Tasks.Task<IEnumerable<TOutput>>` object is completed."},{"content":"The following basic example creates a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> object that splits strings into their individual character sequences.","pos":[28112,28281],"source":"The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object that splits strings into their individual character sequences."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> object takes <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> values as input and produces <ph id=\"ph3\">&lt;xref:System.Char&gt;</ph> values as output.","pos":[28282,28447],"source":" The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object takes <xref:System.String> values as input and produces <xref:System.Char> values as output."},{"pos":[28716,29025],"content":"For complete examples that use <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> to produce multiple independent outputs for each input in a dataflow pipeline, see <bpt id=\"p1\">[</bpt>Walkthrough: Creating a Dataflow Pipeline<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)</ept>.","source":"For complete examples that use <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> to produce multiple independent outputs for each input in a dataflow pipeline, see [Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)."},{"pos":[29036,29057],"content":"Degree of Parallelism","linkify":"Degree of Parallelism","nodes":[{"content":"Degree of Parallelism","pos":[0,21]}]},{"content":"Every <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> object buffers input messages until the block is ready to process them.","pos":[29061,29319],"source":"Every <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object buffers input messages until the block is ready to process them."},{"content":"By default, these classes process messages in the order in which they are received, one message at a time.","pos":[29320,29426]},{"content":"You can also specify the degree of parallelism to enable <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> objects to process multiple messages concurrently.","pos":[29427,29714],"source":" You can also specify the degree of parallelism to enable <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects to process multiple messages concurrently."},{"content":"For more information about concurrent execution, see the section Specifying the Degree of Parallelism later in this document.","pos":[29715,29840]},{"content":"For an example that sets the degree of parallelism to enable an execution dataflow block to process more than one message at a time, see <bpt id=\"p1\">[</bpt>How to: Specify the Degree of Parallelism in a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)</ept>.","pos":[29841,30151],"source":" For an example that sets the degree of parallelism to enable an execution dataflow block to process more than one message at a time, see [How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)."},{"pos":[30162,30187],"content":"Summary of Delegate Types","linkify":"Summary of Delegate Types","nodes":[{"content":"Summary of Delegate Types","pos":[0,25]}]},{"content":"The following table summarizes the delegate types that you can provide to <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph> objects.","pos":[30191,30454],"source":"The following table summarizes the delegate types that you can provide to <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects."},{"content":"This table also specifies whether the delegate type operates synchronously or asynchronously.","pos":[30455,30548]},{"content":"Type","pos":[30555,30559]},{"content":"Synchronous Delegate Type","pos":[30560,30585]},{"content":"Asynchronous Delegate Type","pos":[30586,30612]},{"content":"You can also use lambda expressions when you work with execution block types.","pos":[31093,31170]},{"content":"For an example that shows how to use a lambda expression with an execution block, see <bpt id=\"p1\">[</bpt>How to: Perform Action When a Dataflow Block Receives Data<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)</ept>.","pos":[31171,31424],"source":" For an example that shows how to use a lambda expression with an execution block, see [How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)."},{"pos":[31434,31449],"content":"Grouping Blocks","linkify":"Grouping Blocks","nodes":[{"content":"Grouping Blocks","pos":[0,15]}]},{"content":"Grouping blocks combine data from one or more sources and under various constraints.","pos":[31453,31537]},{"content":"The TPL Dataflow Library provides three join block types: <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph>.","pos":[31538,31769],"source":" The TPL Dataflow Library provides three join block types: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>."},{"pos":[31780,31793],"content":"BatchBlock(T)","linkify":"BatchBlock(T)","nodes":[{"content":"BatchBlock(T)","pos":[0,13]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> class combines sets of input data, which are known as batches, into arrays of output data.","pos":[31797,31945],"source":"The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class combines sets of input data, which are known as batches, into arrays of output data."},{"content":"You specify the size of each batch when you create a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object.","pos":[31946,32060],"source":" You specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object receives the specified count of input elements, it asynchronously propagates out an array that contains those elements.","pos":[32061,32250],"source":" When the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object receives the specified count of input elements, it asynchronously propagates out an array that contains those elements."},{"content":"If a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object is set to the completed state but does not contain enough elements to form a batch, it propagates out a final array that contains the remaining input elements.","pos":[32251,32476],"source":" If a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object is set to the completed state but does not contain enough elements to form a batch, it propagates out a final array that contains the remaining input elements."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> class operates in either <bpt id=\"p1\">*</bpt>greedy<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>non-greedy<ept id=\"p2\">*</ept> mode.","pos":[32483,32596],"source":"The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class operates in either *greedy* or *non-greedy* mode."},{"content":"In greedy mode, which is the default, a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object accepts every message that it is offered and propagates out an array after it receives the specified count of elements.","pos":[32597,32817],"source":" In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object accepts every message that it is offered and propagates out an array after it receives the specified count of elements."},{"content":"In non-greedy mode, a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object postpones all incoming messages until enough sources have offered messages to the block to form a batch.","pos":[32818,33005],"source":" In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough sources have offered messages to the block to form a batch."},{"content":"Greedy mode typically performs better than non-greedy mode because it requires less processing overhead.","pos":[33006,33110]},{"content":"However, you can use non-greedy mode when you must coordinate consumption from multiple sources in an atomic fashion.","pos":[33111,33228]},{"content":"Specify non-greedy mode by setting <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A&gt;</ph> to <ph id=\"ph2\">`False`</ph> in the <ph id=\"ph3\">`dataflowBlockOptions`</ph> parameter in the <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A&gt;</ph> constructor.","pos":[33229,33477],"source":" Specify non-greedy mode by setting <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False` in the `dataflowBlockOptions` parameter in the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> constructor."},{"content":"The following basic example posts several <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph> values to a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object that holds ten elements in a batch.","pos":[33484,33654],"source":"The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object that holds ten elements in a batch."},{"content":"To guarantee that all values propagate out of the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph>, this example calls the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A&gt;</ph> method.","pos":[33655,33856],"source":" To guarantee that all values propagate out of the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, this example calls the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A&gt;</ph> method sets the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object to the completed state, and therefore, the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object propagates out any remaining elements as a final batch.","pos":[33857,34163],"source":" The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method sets the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object to the completed state, and therefore, the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object propagates out any remaining elements as a final batch."},{"pos":[34432,34775],"content":"For a complete example that uses <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> to improve the efficiency of database insert operations, see <bpt id=\"p1\">[</bpt>Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)</ept>.","source":"For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> to improve the efficiency of database insert operations, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)."},{"pos":[34786,34808],"content":"JoinBlock(T1, T2, ...)","linkify":"JoinBlock(T1, T2, ...)","nodes":[{"content":"JoinBlock(T1, T2, ...)","pos":[0,22]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603&gt;</ph> classes collect input elements and propagate out <ph id=\"ph3\">&lt;xref:System.Tuple%602?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Tuple%603?displayProperty=nameWithType&gt;</ph> objects that contain those elements.","pos":[34812,35120],"source":"The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes collect input elements and propagate out <xref:System.Tuple%602?displayProperty=nameWithType> or <xref:System.Tuple%603?displayProperty=nameWithType> objects that contain those elements."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603&gt;</ph> classes do not inherit from <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601&gt;</ph>.","pos":[35121,35319],"source":" The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes do not inherit from <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>."},{"content":"Instead, they provide properties, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A&gt;</ph>, that implement <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601&gt;</ph>.","pos":[35320,35624],"source":" Instead, they provide properties, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>."},{"content":"Like <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603&gt;</ph> operate in either greedy or non-greedy mode.","pos":[35631,35845],"source":"Like <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operate in either greedy or non-greedy mode."},{"content":"In greedy mode, which is the default, a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603&gt;</ph> object accepts every message that it is offered and propagates out a tuple after each of its targets receives at least one message.","pos":[35846,36126],"source":" In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object accepts every message that it is offered and propagates out a tuple after each of its targets receives at least one message."},{"content":"In non-greedy mode, a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603&gt;</ph> object postpones all incoming messages until all targets have been offered the data that is required to create a tuple.","pos":[36127,36377],"source":" In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object postpones all incoming messages until all targets have been offered the data that is required to create a tuple."},{"content":"At this point, the block engages in a two-phase commit protocol to atomically retrieve all required items from the sources.","pos":[36378,36501]},{"content":"This postponement makes it possible for another entity to consume the data in the meantime, to allow the overall system to make forward progress.","pos":[36502,36647]},{"content":"The following basic example demonstrates a case in which a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603&gt;</ph> object requires multiple data to compute a value.","pos":[36654,36815],"source":"The following basic example demonstrates a case in which a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object requires multiple data to compute a value."},{"content":"This example creates a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%603&gt;</ph> object that requires two <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> values and a <ph id=\"ph3\">&lt;xref:System.Char&gt;</ph> value to perform an arithmetic operation.","pos":[36816,37010],"source":" This example creates a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object that requires two <xref:System.Int32> values and a <xref:System.Char> value to perform an arithmetic operation."},{"pos":[37279,37594],"content":"For a complete example that uses <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph> objects in non-greedy mode to cooperatively share a resource, see <bpt id=\"p1\">[</bpt>How to: Use JoinBlock to Read Data From Multiple Sources<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)</ept>.","source":"For a complete example that uses <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects in non-greedy mode to cooperatively share a resource, see [How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)."},{"pos":[37605,37634],"content":"BatchedJoinBlock(T1, T2, ...)","linkify":"BatchedJoinBlock(T1, T2, ...)","nodes":[{"content":"BatchedJoinBlock(T1, T2, ...)","pos":[0,29]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603&gt;</ph> classes collect batches of input elements and propagate out <ph id=\"ph3\">`System.Tuple(IList(T1), IList(T2))`</ph> or <ph id=\"ph4\">`System.Tuple(IList(T1), IList(T2), IList(T3))`</ph> objects that contain those elements.","pos":[37638,37950],"source":"The <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classes collect batches of input elements and propagate out `System.Tuple(IList(T1), IList(T2))` or `System.Tuple(IList(T1), IList(T2), IList(T3))` objects that contain those elements."},{"content":"Think of <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> as a combination of <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph>.","pos":[37951,38151],"source":" Think of <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> as a combination of <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>."},{"content":"Specify the size of each batch when you create a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> object.","pos":[38152,38268],"source":" Specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> also provides properties, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A&gt;</ph>, that implement <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601&gt;</ph>.","pos":[38269,38573],"source":"<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> also provides properties, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>."},{"content":"When the specified count of input elements are received from across all targets, the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> object asynchronously propagates out a <ph id=\"ph2\">`System.Tuple(IList(T1), IList(T2))`</ph> object that contains those elements.","pos":[38574,38831],"source":" When the specified count of input elements are received from across all targets, the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object asynchronously propagates out a `System.Tuple(IList(T1), IList(T2))` object that contains those elements."},{"content":"The following basic example creates a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> object that holds results, <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> values, and errors that are <ph id=\"ph3\">&lt;xref:System.Exception&gt;</ph> objects.","pos":[38838,39043],"source":"The following basic example creates a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object that holds results, <xref:System.Int32> values, and errors that are <xref:System.Exception> objects."},{"content":"This example performs multiple operations and writes results to the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A&gt;</ph> property, and errors to the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A&gt;</ph> property, of the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> object.","pos":[39044,39366],"source":" This example performs multiple operations and writes results to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> property, and errors to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> property, of the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object."},{"content":"Because the count of successful and failed operations is unknown in advance, the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> objects enable each target to receive zero or more values.","pos":[39367,39550],"source":" Because the count of successful and failed operations is unknown in advance, the <xref:System.Collections.Generic.IList%601> objects enable each target to receive zero or more values."},{"pos":[39819,40210],"content":"For a complete example that uses <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> to capture both the results and any exceptions that occur while the program reads from a database, see <bpt id=\"p1\">[</bpt>Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)</ept>.","source":"For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> to capture both the results and any exceptions that occur while the program reads from a database, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)."},{"pos":[40217,40236],"content":"[<bpt id=\"p1\">[</bpt>go to top<ept id=\"p1\">](#top)</ept>]","source":"[[go to top](#top)]"},{"pos":[40272,40308],"content":"Configuring Dataflow  Block Behavior","linkify":"Configuring Dataflow  Block Behavior","nodes":[{"content":"Configuring Dataflow  Block Behavior","pos":[0,36]}]},{"content":"You can enable additional options by providing a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType&gt;</ph> object to the constructor of dataflow block types.","pos":[40312,40500],"source":"You can enable additional options by providing a <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> object to the constructor of dataflow block types."},{"content":"These options control behavior such the scheduler that manages the underlying task and the degree of parallelism.","pos":[40501,40614]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions&gt;</ph> also has derived types that specify behavior that is specific to certain dataflow block types.","pos":[40615,40773],"source":" The <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> also has derived types that specify behavior that is specific to certain dataflow block types."},{"content":"The following table summarizes which options type is associated with each dataflow block type.","pos":[40774,40868]},{"content":"Dataflow Block Type","pos":[40875,40894]},{"pos":[40895,40959],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions&gt;</ph> type","source":"<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> type"},{"pos":[42306,42741],"content":"The following sections provide additional information about the important kinds of dataflow block options that are available through the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType&gt;</ph> classes.","source":"The following sections provide additional information about the important kinds of dataflow block options that are available through the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> classes."},{"pos":[42751,42780],"content":"Specifying the Task Scheduler","linkify":"Specifying the Task Scheduler","nodes":[{"content":"Specifying the Task Scheduler","pos":[0,29]}]},{"content":"Every predefined dataflow block uses the TPL task scheduling mechanism to perform activities such as propagating data to a target, receiving data from a source, and running user-defined delegates when data becomes available.","pos":[42784,43008]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> is an abstract class that represents a task scheduler that queues tasks onto threads.","pos":[43009,43138],"source":"<xref:System.Threading.Tasks.TaskScheduler> is an abstract class that represents a task scheduler that queues tasks onto threads."},{"content":"The default task scheduler, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph>, uses the <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool&gt;</ph> class to queue and execute work.","pos":[43139,43299],"source":" The default task scheduler, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, uses the <xref:System.Threading.ThreadPool> class to queue and execute work."},{"content":"You can override the default task scheduler by setting the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A&gt;</ph> property when you construct a dataflow block object.","pos":[43300,43488],"source":" You can override the default task scheduler by setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> property when you construct a dataflow block object."},{"content":"When the same task scheduler manages multiple dataflow blocks, it can enforce policies across them.","pos":[43495,43594]},{"content":"For example, if multiple dataflow blocks are each configured to target the exclusive scheduler of the same <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair&gt;</ph> object, all work that runs across these blocks is serialized.","pos":[43595,43826],"source":" For example, if multiple dataflow blocks are each configured to target the exclusive scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, all work that runs across these blocks is serialized."},{"content":"Similarly, if these blocks are configured to target the concurrent scheduler of the same <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair&gt;</ph> object, and that scheduler is configured to have a maximum concurrency level, all work from these blocks is limited to that number of concurrent operations.","pos":[43827,44135],"source":" Similarly, if these blocks are configured to target the concurrent scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, and that scheduler is configured to have a maximum concurrency level, all work from these blocks is limited to that number of concurrent operations."},{"content":"For an example that uses the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair&gt;</ph> class to enable read operations to occur in parallel, but write operations to occur exclusively of all other operations, see <bpt id=\"p1\">[</bpt>How to: Specify a Task Scheduler in a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)</ept>.","pos":[44136,44508],"source":" For an example that uses the <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> class to enable read operations to occur in parallel, but write operations to occur exclusively of all other operations, see [How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)."},{"content":"For more information about task schedulers in the TPL, see the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class topic.","pos":[44509,44628],"source":" For more information about task schedulers in the TPL, see the <xref:System.Threading.Tasks.TaskScheduler> class topic."},{"pos":[44638,44674],"content":"Specifying the Degree of Parallelism","linkify":"Specifying the Degree of Parallelism","nodes":[{"content":"Specifying the Degree of Parallelism","pos":[0,36]}]},{"content":"By default, the three execution block types that the TPL Dataflow Library provides, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph>, process one message at a time.","pos":[44678,44974],"source":"By default, the three execution block types that the TPL Dataflow Library provides, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, process one message at a time."},{"content":"These dataflow block types also process messages in the order in which they are received.","pos":[44975,45064]},{"content":"To enable these dataflow blocks to process messages concurrently, set the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType&gt;</ph> property when you construct the dataflow block object.","pos":[45065,45317],"source":" To enable these dataflow blocks to process messages concurrently, set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> property when you construct the dataflow block object."},{"content":"The default value of <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A&gt;</ph> is 1, which guarantees that the dataflow block processes one message at a time.","pos":[45324,45519],"source":"The default value of <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> is 1, which guarantees that the dataflow block processes one message at a time."},{"content":"Setting this property to a value that is larger than 1 enables the dataflow block to process multiple messages concurrently.","pos":[45520,45644]},{"content":"Setting this property to <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType&gt;</ph> enables the underlying task scheduler to manage the maximum degree of concurrency.","pos":[45645,45851],"source":" Setting this property to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> enables the underlying task scheduler to manage the maximum degree of concurrency."},{"pos":[45859,46193],"content":"[!IMPORTANT]\n When you specify a maximum degree of parallelism that is larger than 1, multiple messages are processed simultaneously, and therefore messages might not be processed in the order in which they are received. The order in which the messages are output from the block is, however, the same one in which they are received.","leadings":["","> "],"nodes":[{"content":"When you specify a maximum degree of parallelism that is larger than 1, multiple messages are processed simultaneously, and therefore messages might not be processed in the order in which they are received. The order in which the messages are output from the block is, however, the same one in which they are received.","pos":[14,332],"nodes":[{"content":"When you specify a maximum degree of parallelism that is larger than 1, multiple messages are processed simultaneously, and therefore messages might not be processed in the order in which they are received.","pos":[0,206]},{"content":"The order in which the messages are output from the block is, however, the same one in which they are received.","pos":[207,318]}]}]},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A&gt;</ph> property represents the maximum degree of parallelism, the dataflow block might execute with a lesser degree of parallelism than you specify.","pos":[46200,46448],"source":"Because the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property represents the maximum degree of parallelism, the dataflow block might execute with a lesser degree of parallelism than you specify."},{"content":"The dataflow block might use a lesser degree of parallelism to meet its functional requirements or because there is a lack of available system resources.","pos":[46449,46602]},{"content":"A dataflow block never chooses more parallelism than you specify.","pos":[46603,46668]},{"content":"The value of the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A&gt;</ph> property is exclusive to each dataflow block object.","pos":[46675,46839],"source":"The value of the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property is exclusive to each dataflow block object."},{"content":"For example, if four dataflow block objects each specify 1 for the maximum degree of parallelism, all four dataflow block objects can potentially run in parallel.","pos":[46840,47002]},{"pos":[47009,47296],"content":"For an example that sets the maximum degree of parallelism to enable lengthy operations to occur in parallel, see <bpt id=\"p1\">[</bpt>How to: Specify the Degree of Parallelism in a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)</ept>.","source":"For an example that sets the maximum degree of parallelism to enable lengthy operations to occur in parallel, see [How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)."},{"pos":[47306,47348],"content":"Specifying the Number of Messages per Task","linkify":"Specifying the Number of Messages per Task","nodes":[{"content":"Specifying the Number of Messages per Task","pos":[0,42]}]},{"content":"The predefined dataflow block types use tasks to process multiple input elements.","pos":[47352,47433]},{"content":"This helps minimize the number of task objects that are required to process data, which enables applications to run more efficiently.","pos":[47434,47567]},{"content":"However, when the tasks from one set of dataflow blocks are processing data, the tasks from other dataflow blocks might need to wait for processing time by queuing messages.","pos":[47568,47741]},{"content":"To enable better fairness among dataflow tasks, set the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A&gt;</ph> property.","pos":[47742,47889],"source":" To enable better fairness among dataflow tasks, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A&gt;</ph> is set to <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType&gt;</ph>, which is the default, the task used by a dataflow block processes as many messages as are available.","pos":[47890,48187],"source":" When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, which is the default, the task used by a dataflow block processes as many messages as are available."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A&gt;</ph> is set to a value other than <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded&gt;</ph>, the dataflow block processes at most this number of messages per <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object.","pos":[48188,48482],"source":" When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to a value other than <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, the dataflow block processes at most this number of messages per <xref:System.Threading.Tasks.Task> object."},{"content":"Although setting the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A&gt;</ph> property can increase fairness among tasks, it can cause the system to create more tasks than are necessary, which can decrease performance.","pos":[48483,48726],"source":" Although setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property can increase fairness among tasks, it can cause the system to create more tasks than are necessary, which can decrease performance."},{"pos":[48736,48757],"content":"Enabling Cancellation","linkify":"Enabling Cancellation","nodes":[{"content":"Enabling Cancellation","pos":[0,21]}]},{"content":"The TPL provides a mechanism that enables tasks to coordinate cancellation in a cooperative manner.","pos":[48761,48860]},{"content":"To enable dataflow blocks to participate in this cancellation mechanism, set the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A&gt;</ph> property.","pos":[48861,49032],"source":" To enable dataflow blocks to participate in this cancellation mechanism, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> property."},{"content":"When this <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken&gt;</ph> object is set to the canceled state, all dataflow blocks that monitor this token finish execution of their current item but do not start processing subsequent items.","pos":[49033,49250],"source":" When this <xref:System.Threading.CancellationToken> object is set to the canceled state, all dataflow blocks that monitor this token finish execution of their current item but do not start processing subsequent items."},{"content":"These dataflow blocks also clear any buffered messages, release connections to any source and target blocks, and transition to the canceled state.","pos":[49251,49397]},{"content":"By transitioning to the canceled state, the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A&gt;</ph> property has the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property set to <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>, unless an exception occurred during processing.","pos":[49398,49686],"source":" By transitioning to the canceled state, the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property has the <xref:System.Threading.Tasks.Task.Status%2A> property set to <xref:System.Threading.Tasks.TaskStatus.Canceled>, unless an exception occurred during processing."},{"content":"In that case, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> is set to <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>.","pos":[49687,49805],"source":" In that case, <xref:System.Threading.Tasks.Task.Status%2A> is set to <xref:System.Threading.Tasks.TaskStatus.Faulted>."},{"content":"For an example that demonstrates how to use cancellation in a Windows Forms application, see <bpt id=\"p1\">[</bpt>How to: Cancel a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)</ept>.","pos":[49812,50018],"source":"For an example that demonstrates how to use cancellation in a Windows Forms application, see [How to: Cancel a Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)."},{"content":"For more information about cancellation in the TPL, see <bpt id=\"p1\">[</bpt>Task Cancellation<ept id=\"p1\">](../../../docs/standard/parallel-programming/task-cancellation.md)</ept>.","pos":[50019,50161],"source":" For more information about cancellation in the TPL, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md)."},{"pos":[50171,50215],"content":"Specifying Greedy Versus Non-Greedy Behavior","linkify":"Specifying Greedy Versus Non-Greedy Behavior","nodes":[{"content":"Specifying Greedy Versus Non-Greedy Behavior","pos":[0,44]}]},{"content":"Several grouping dataflow block types can operate in either <bpt id=\"p1\">*</bpt>greedy<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>non-greedy<ept id=\"p2\">*</ept> mode.","pos":[50219,50309],"source":"Several grouping dataflow block types can operate in either *greedy* or *non-greedy* mode."},{"content":"By default, the predefined dataflow block types operate in greedy mode.","pos":[50310,50381]},{"content":"For join block types such as <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph>, greedy mode means that the block immediately accepts data even if the corresponding data with which to join is not yet available.","pos":[50388,50600],"source":"For join block types such as <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, greedy mode means that the block immediately accepts data even if the corresponding data with which to join is not yet available."},{"content":"Non-greedy mode means that the block postpones all incoming messages until one is available on each of its targets to complete the join.","pos":[50601,50737]},{"content":"If any of the postponed messages are no longer available, the join block releases all postponed messages and restarts the process.","pos":[50738,50868]},{"content":"For the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> class, greedy and non-greedy behavior is similar, except that under non-greedy mode, a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> object postpones all incoming messages until enough are available from distinct sources to complete a batch.","pos":[50869,51180],"source":" For the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class, greedy and non-greedy behavior is similar, except that under non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough are available from distinct sources to complete a batch."},{"content":"To specify non-greedy mode for a dataflow block, set <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A&gt;</ph> to <ph id=\"ph2\">`False`</ph>.","pos":[51187,51329],"source":"To specify non-greedy mode for a dataflow block, set <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False`."},{"content":"For an example that demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently, see <bpt id=\"p1\">[</bpt>How to: Use JoinBlock to Read Data From Multiple Sources<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)</ept>.","pos":[51330,51629],"source":" For an example that demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently, see [How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)."},{"pos":[51636,51655],"content":"[<bpt id=\"p1\">[</bpt>go to top<ept id=\"p1\">](#top)</ept>]","source":"[[go to top](#top)]"},{"pos":[51689,51711],"content":"Custom Dataflow Blocks","linkify":"Custom Dataflow Blocks","nodes":[{"content":"Custom Dataflow Blocks","pos":[0,22]}]},{"content":"Although the TPL Dataflow Library provides many predefined block types, you can create additional block types that perform custom behavior.","pos":[51715,51854]},{"content":"Implement the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.ITargetBlock%601&gt;</ph> interfaces directly or use the  <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A&gt;</ph> method to build a complex block that encapsulates the behavior of existing block types.","pos":[51855,52171],"source":" Implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> or <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfaces directly or use the  <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> method to build a complex block that encapsulates the behavior of existing block types."},{"content":"For examples that show how to implement custom dataflow block functionality, see <bpt id=\"p1\">[</bpt>Walkthrough: Creating a Custom Dataflow Block Type<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)</ept>.","pos":[52172,52404],"source":" For examples that show how to implement custom dataflow block functionality, see [Walkthrough: Creating a Custom Dataflow Block Type](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)."},{"pos":[52411,52430],"content":"[<bpt id=\"p1\">[</bpt>go to top<ept id=\"p1\">](#top)</ept>]","source":"[[go to top](#top)]"},{"pos":[52439,52453],"content":"Related Topics","linkify":"Related Topics","nodes":[{"content":"Related Topics","pos":[0,14]}]},{"content":"Title","pos":[52460,52465]},{"content":"Description","pos":[52466,52477]},{"pos":[52516,52696],"content":"<bpt id=\"p1\">[</bpt>How to: Write Messages to and Read Messages from a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)</ept>","source":"[How to: Write Messages to and Read Messages from a Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)"},{"pos":[52697,52822],"content":"Demonstrates how to write messages to and read messages from a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> object.","source":"Demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object."},{"pos":[52827,52985],"content":"<bpt id=\"p1\">[</bpt>How to: Implement a Producer-Consumer Dataflow Pattern<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)</ept>","source":"[How to: Implement a Producer-Consumer Dataflow Pattern](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)"},{"content":"Describes how to use the dataflow model to implement a producer-consumer pattern, where the producer sends messages to a dataflow block, and the consumer reads messages from that block.","pos":[52986,53171]},{"pos":[53176,53342],"content":"<bpt id=\"p1\">[</bpt>How to: Perform Action When a Dataflow Block Receives Data<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)</ept>","source":"[How to: Perform Action When a Dataflow Block Receives Data](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)"},{"pos":[53343,53598],"content":"Describes how to provide delegates to the execution dataflow block types, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ActionBlock%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.TransformBlock%602&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602&gt;</ph>.","source":"Describes how to provide delegates to the execution dataflow block types, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>."},{"pos":[53603,53735],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Creating a Dataflow Pipeline<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)</ept>","source":"[Walkthrough: Creating a Dataflow Pipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)"},{"content":"Describes how to create a dataflow pipeline that downloads text from the web and performs operations on that text.","pos":[53736,53850]},{"pos":[53855,53965],"content":"<bpt id=\"p1\">[</bpt>How to: Unlink Dataflow Blocks<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)</ept>","source":"[How to: Unlink Dataflow Blocks](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)"},{"pos":[53966,54156],"content":"Demonstrates how to use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A&gt;</ph> method to unlink a target block from its source after the source offers a message to the target.","source":"Demonstrates how to use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> method to unlink a target block from its source after the source offers a message to the target."},{"pos":[54161,54327],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Using Dataflow in a Windows Forms Application<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)</ept>","source":"[Walkthrough: Using Dataflow in a Windows Forms Application](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)"},{"content":"Demonstrates how to create a network of dataflow blocks that perform image processing in a Windows Forms application.","pos":[54328,54445]},{"pos":[54450,54562],"content":"<bpt id=\"p1\">[</bpt>How to: Cancel a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)</ept>","source":"[How to: Cancel a Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)"},{"content":"Demonstrates how to use cancellation in a Windows Forms application.","pos":[54563,54631]},{"pos":[54636,54798],"content":"<bpt id=\"p1\">[</bpt>How to: Use JoinBlock to Read Data From Multiple Sources<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)</ept>","source":"[How to: Use JoinBlock to Read Data From Multiple Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)"},{"pos":[54799,55054],"content":"Explains how to use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.JoinBlock%602&gt;</ph> class to perform an operation when data is available from multiple sources, and how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently.","source":"Explains how to use the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class to perform an operation when data is available from multiple sources, and how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently."},{"pos":[55059,55231],"content":"<bpt id=\"p1\">[</bpt>How to: Specify the Degree of Parallelism in a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)</ept>","source":"[How to: Specify the Degree of Parallelism in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)"},{"pos":[55232,55442],"content":"Describes how to set the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A&gt;</ph> property to enable an execution dataflow block to process more than one message at a time.","source":"Describes how to set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property to enable an execution dataflow block to process more than one message at a time."},{"pos":[55447,55601],"content":"<bpt id=\"p1\">[</bpt>How to: Specify a Task Scheduler in a Dataflow Block<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)</ept>","source":"[How to: Specify a Task Scheduler in a Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)"},{"content":"Demonstrates how to associate a specific task scheduler when you use dataflow in your application.","pos":[55602,55700]},{"pos":[55705,55899],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)</ept>","source":"[Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)"},{"pos":[55900,56225],"content":"Describes how to use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow.BatchBlock%601&gt;</ph> class to improve the efficiency of database insert operations, and how to use the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602&gt;</ph> class to capture both the results and any exceptions that occur while the program reads from a database.","source":"Describes how to use the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class to improve the efficiency of database insert operations, and how to use the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> class to capture both the results and any exceptions that occur while the program reads from a database."},{"pos":[56230,56380],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Creating a Custom Dataflow Block Type<ept id=\"p1\">](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)</ept>","source":"[Walkthrough: Creating a Custom Dataflow Block Type](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)"},{"content":"Demonstrates two ways to create a dataflow block type that implements custom behavior.","pos":[56381,56467]},{"pos":[56472,56575],"content":"<bpt id=\"p1\">[</bpt>Task Parallel Library (TPL)<ept id=\"p1\">](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)</ept>","source":"[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)"},{"pos":[56576,56735],"content":"Introduces the TPL, a library that simplifies parallel and concurrent programming in <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> applications.","source":"Introduces the TPL, a library that simplifies parallel and concurrent programming in [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] applications."}]}