{"content":"---\ntitle: \"Sessions and Queues\"\nms.date: \"03/30/2017\"\nms.assetid: 47d7c5c2-1e6f-4619-8003-a0ff67dcfbd6\n---\n# Sessions and Queues\nThis sample demonstrates how to send and receive a set of related messages in queued communication over the Message Queuing (MSMQ) transport. This sample uses the `netMsmqBinding` binding. The service is a self-hosted console application to enable you to observe the service receiving queued messages.  \n  \n> [!NOTE]\n>  The setup procedure and build instructions for this sample are located at the end of this topic.  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Basic\\Binding\\Net\\MSMQ\\Session`  \n  \n In queued communication, the client communicates to the service using a queue. More precisely, the client sends messages to a queue. The service receives messages from the queue. The service and client therefore, do not have to be running at the same time to communicate using a queue.  \n  \n Sometimes, a client sends a set of messages that are related to each other in a group. When messages must be processed together or in a specified order, a queue can be used to group them together, for processing by a single receiving application. This is particularly important when there are several receiving applications on a group of servers and it is necessary to ensure that a group of messages is processed by the same receiving application. Queued sessions are a mechanism used to send and receive a related set of messages that must get processed all at once. Queued sessions require a transaction to exhibit this pattern.  \n  \n In the sample, the client sends a number of messages to the service as part of a session within the scope of a single transaction.  \n  \n The service contract is `IOrderTaker`, which defines a one-way service that is suitable for use with queues. The <xref:System.ServiceModel.SessionMode> used in the contract shown in the following sample code indicates that the messages are part of the session.  \n\n```csharp\n[ServiceContract(Namespace = \"http://Microsoft.ServiceModel.Samples\", SessionMode=SessionMode.Required)]  \npublic interface IOrderTaker  \n{  \n    [OperationContract(IsOneWay = true)]  \n    void OpenPurchaseOrder(string customerId);  \n  \n    [OperationContract(IsOneWay = true)]  \n    void AddProductLineItem(string productId, int quantity);  \n  \n    [OperationContract(IsOneWay = true)]  \n    void EndPurchaseOrder();  \n}  \n```\n\n The service defines service operations in such a way that the first operation enlists in a transaction but does not automatically complete the transaction. Subsequent operations also enlist in the same transaction but do not automatically complete. The last operation in the session automatically completes the transaction. Thus, the same transaction is used for several operation invocations in the service contract. If any of the operations throw an exception, then the transaction rolls back and the session is put back into the queue. Upon successful completion of the last operation, the transaction is committed. The service uses `PerSession` as the <xref:System.ServiceModel.InstanceContextMode> to receive all messages in a session on the same instance of the service.  \n\n```csharp\n[ServiceBehavior(InstanceContextMode=InstanceContextMode.PerSession)]  \npublic class OrderTakerService : IOrderTaker  \n{  \n    PurchaseOrder po;  \n  \n    [OperationBehavior(TransactionScopeRequired = true,   \n                                 TransactionAutoComplete = false)]  \n    public void OpenPurchaseOrder(string customerId)  \n    {  \n        Console.WriteLine(\"Creating purchase order\");  \n        po = new PurchaseOrder(customerId);  \n    }  \n  \n    [OperationBehavior(TransactionScopeRequired = true,   \n                                  TransactionAutoComplete = false)]  \n    public void AddProductLineItem(string productId, int quantity)  \n    {  \n        po.AddProductLineItem(productId, quantity);  \n        Console.WriteLine(\"Product \" + productId + \" quantity \" +   \n                            quantity + \" added to purchase order\");  \n    }  \n  \n    [OperationBehavior(TransactionScopeRequired = true,   \n                                  TransactionAutoComplete = true)]  \n    public void EndPurchaseOrder()  \n    {  \n       Console.WriteLine(\"Purchase Order Completed\");  \n       Console.WriteLine();  \n       Console.WriteLine(po.ToString());  \n    }  \n}  \n```\n\n The service is self hosted. When using the MSMQ transport, the queue used must be created in advance. This can be done manually or through code. In this sample, the service contains <xref:System.Messaging> code to check for the existence of the queue and creates it, if necessary. The queue name is read from the configuration file using the <xref:System.Configuration.ConfigurationManager.AppSettings%2A> class.  \n\n```csharp\n// Host the service within this EXE console application.  \npublic static void Main()  \n{  \n    // Get MSMQ queue name from app settings in configuration.  \n    string queueName = ConfigurationManager.AppSettings[\"queueName\"];  \n  \n    // Create the transacted MSMQ queue if necessary.  \n    if (!MessageQueue.Exists(queueName))  \n        MessageQueue.Create(queueName, true);  \n  \n    // Create a ServiceHost for the OrderTakerService type.  \n    using (ServiceHost serviceHost = new ServiceHost(typeof(OrderTakerService)))  \n    {  \n        // Open the ServiceHost to create listeners and start listening for messages.  \n        serviceHost.Open();  \n  \n        // The service can now be accessed.  \n        Console.WriteLine(\"The service is ready.\");  \n        Console.WriteLine(\"Press <ENTER> to terminate service.\");  \n        Console.WriteLine();  \n        Console.ReadLine();  \n  \n        // Close the ServiceHost to shutdown the service.  \n        serviceHost.Close();   \n    }  \n}  \n```\n\n The MSMQ queue name is specified in an appSettings section of the configuration file. The endpoint for the service is defined in the system.serviceModel section of the configuration file and specifies the `netMsmqBinding` binding.  \n  \n```xml  \n<appSettings>  \n  <!-- Use appSetting to configure MSMQ queue name. -->  \n  <add key=\"queueName\" value=\".\\private$\\ServiceModelSamplesSession\" />  \n</appSettings>  \n  \n<system.serviceModel>  \n  <services>  \n    <service name=\"Microsoft.ServiceModel.Samples.OrderTakerService\"  \n        behaviorConfiguration=\"CalculatorServiceBehavior\">  \n      ...  \n      <!-- Define NetMsmqEndpoint -->  \n      <endpoint address=\"net.msmq://localhost/private/ServiceModelSamplesSession\"  \n                binding=\"netMsmqBinding\"  \n                contract=\"Microsoft.ServiceModel.Samples.IOrderTaker\" />  \n      ...  \n    </service>  \n  </services>  \n  ...  \n<system.serviceModel>  \n```  \n  \n The client creates a transaction scope. All messages in the session are sent to the queue within the transaction scope, causing it to be treated as an atomic unit where all messages succeed or fail. The transaction is committed by calling <xref:System.Transactions.TransactionScope.Complete%2A>.  \n\n```csharp\n//Create a transaction scope.  \nusing (TransactionScope scope = new TransactionScope(TransactionScopeOption.Required))  \n{  \n    // Create a client with given client endpoint configuration.  \n    OrderTakerClient client = new OrderTakerClient(\"OrderTakerEndpoint\");  \n    // Open a purchase order.  \n    client.OpenPurchaseOrder(\"somecustomer.com\");  \n    Console.WriteLine(\"Purchase Order created\");  \n  \n    // Add product line items.  \n    Console.WriteLine(\"Adding 10 quantities of blue widget\");  \n    client.AddProductLineItem(\"Blue Widget\", 10);  \n  \n    Console.WriteLine(\"Adding 23 quantities of red widget\");  \n    client.AddProductLineItem(\"Red Widget\", 23);  \n  \n    // Close the purchase order.  \n    Console.WriteLine(\"Closing the purchase order\");  \n    client.EndPurchaseOrder();  \n  \n    //Closing the client gracefully closes the connection and cleans up resources.  \n    client.Close();                  \n  \n    // Complete the transaction.  \n    scope.Complete();  \n}  \n```\n\n> [!NOTE]\n>  You can use only a single transaction for all messages in the session and all messages in the session must be sent before committing the transaction. Closing the client closes the session. Therefore, the client has to be closed before the transaction is completed to send all messages in the session to the queue.  \n  \n When you run the sample, the client and service activities are displayed in both the service and client console windows. You can see the service receive messages from the client. Press ENTER in each console window to shut down the service and client. Note that because queuing is in use, the client and service do not have to be up and running at the same time. You can run the client, shut it down, and then start up the service and it still receives its messages.  \n  \n On the client.  \n  \n```  \nPurchase Order created  \nAdding 10 quantities of blue widget  \nAdding 23 quantities of red widget  \nClosing the purchase order  \n  \nPress <ENTER> to terminate client.  \n```  \n  \n On the service.  \n  \n```  \nThe service is ready.  \nPress <ENTER> to terminate service.  \n  \nCreating purchase order  \nProduct Blue Widget quantity 10 added to purchase order  \nProduct Red Widget quantity 23 added to purchase order  \nPurchase Order Completed  \n  \nPurchase Order: 7c86fef0-2306-4c51-80e6-bcabcc1a6e5e  \n        Customer: somecustomer.com  \n        OrderDetails  \n                Order LineItem: 10 of Blue Widget @unit price: $2985  \n                Order LineItem: 23 of Red Widget @unit price: $156  \n        Total cost of this order: $33438  \n        Order status: Pending  \n```  \n  \n### To set up, build, and run the sample  \n  \n1.  Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).  \n  \n2.  To build the C#, C++, or Visual Basic .NET edition of the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n3.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n By default with the <xref:System.ServiceModel.NetMsmqBinding>, transport security is enabled. There are two relevant properties for MSMQ transport security namely, <xref:System.ServiceModel.MsmqTransportSecurity.MsmqAuthenticationMode%2A> and <xref:System.ServiceModel.MsmqTransportSecurity.MsmqProtectionLevel%2A>`.` By default, the authentication mode is set to `Windows` and the protection level is set to `Sign`. For MSMQ to provide the authentication and signing feature, it must be part of a domain and the active directory integration option for MSMQ must be installed. If you run this sample on a computer that does not satisfy these criteria you receive an error.  \n  \n### To run the sample on a computer joined to a workgroup or without active directory integration  \n  \n1.  If your computer is not part of a domain or does not have active directory integration installed, turn off transport security by setting the authentication mode and protection level to `None` as shown in the following sample configuration.  \n  \n    ```xml  \n    <system.serviceModel>  \n      <services>  \n        <service name=\"Microsoft.ServiceModel.Samples.OrderTakerService\"  \n                 behaviorConfiguration=\"OrderTakerServiceBehavior\">  \n          <host>  \n            <baseAddresses>  \n              <add baseAddress=  \n             \"http://localhost:8000/ServiceModelSamples/service\"/>  \n            </baseAddresses>  \n          </host>  \n          <!-- Define NetMsmqEndpoint -->  \n          <endpoint  \n              address=  \n            \"net.msmq://localhost/private/ServiceModelSamplesSession\"  \n              binding=\"netMsmqBinding\"  \n              bindingConfiguration=\"Binding1\"  \n           contract=\"Microsoft.ServiceModel.Samples.IOrderTaker\" />  \n          <!-- The mex endpoint is exposed at-->      \n          <!--http://localhost:8000/ServiceModelSamples/service/mex. -->  \n          <endpoint address=\"mex\"  \n                    binding=\"mexHttpBinding\"  \n                    contract=\"IMetadataExchange\" />  \n        </service>  \n      </services>  \n  \n      <bindings>  \n        <netMsmqBinding>  \n          <binding name=\"Binding1\">  \n            <security mode=\"None\" />  \n          </binding>  \n        </netMsmqBinding>  \n      </bindings>  \n  \n        <behaviors>  \n          <serviceBehaviors>  \n            <behavior name=\"OrderTakerServiceBehavior\">  \n              <serviceMetadata httpGetEnabled=\"True\"/>  \n            </behavior>  \n          </serviceBehaviors>  \n        </behaviors>  \n  \n      </system.serviceModel>  \n    ```  \n  \n2.  Ensure that you change the configuration on both the server and the client before you run the sample.  \n  \n    > [!NOTE]\n    >  Setting security mode to `None` is equivalent to setting <xref:System.ServiceModel.MsmqTransportSecurity.MsmqAuthenticationMode%2A>, <xref:System.ServiceModel.MsmqTransportSecurity.MsmqProtectionLevel%2A>, and `Message` security to `None`.  \n","nodes":[{"pos":[4,103],"embed":true,"restype":"x-metadata","content":"title: \"Sessions and Queues\"\nms.date: \"03/30/2017\"\nms.assetid: 47d7c5c2-1e6f-4619-8003-a0ff67dcfbd6","nodes":[{"content":"Sessions and Queues","nodes":[{"pos":[0,19],"content":"Sessions and Queues","nodes":[{"content":"Sessions and Queues","pos":[0,19]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[110,129],"content":"Sessions and Queues","linkify":"Sessions and Queues","nodes":[{"content":"Sessions and Queues","pos":[0,19]}]},{"content":"This sample demonstrates how to send and receive a set of related messages in queued communication over the Message Queuing (MSMQ) transport.","pos":[130,271]},{"content":"This sample uses the <ph id=\"ph1\">`netMsmqBinding`</ph> binding.","pos":[272,318],"source":" This sample uses the `netMsmqBinding` binding."},{"content":"The service is a self-hosted console application to enable you to observe the service receiving queued messages.","pos":[319,431]},{"pos":[439,546],"content":"[!NOTE]\n The setup procedure and build instructions for this sample are located at the end of this topic.","leadings":["","> "],"nodes":[{"content":"The setup procedure and build instructions for this sample are located at the end of this topic.","pos":[9,105]}]},{"pos":[554,686],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[14,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[0,53]},{"content":"Check for the following (default) directory before continuing.","pos":[54,116]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[740,1050],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[1051,1101]},{"content":"In queued communication, the client communicates to the service using a queue.","pos":[1186,1264]},{"content":"More precisely, the client sends messages to a queue.","pos":[1265,1318]},{"content":"The service receives messages from the queue.","pos":[1319,1364]},{"content":"The service and client therefore, do not have to be running at the same time to communicate using a queue.","pos":[1365,1471]},{"content":"Sometimes, a client sends a set of messages that are related to each other in a group.","pos":[1478,1564]},{"content":"When messages must be processed together or in a specified order, a queue can be used to group them together, for processing by a single receiving application.","pos":[1565,1724]},{"content":"This is particularly important when there are several receiving applications on a group of servers and it is necessary to ensure that a group of messages is processed by the same receiving application.","pos":[1725,1926]},{"content":"Queued sessions are a mechanism used to send and receive a related set of messages that must get processed all at once.","pos":[1927,2046]},{"content":"Queued sessions require a transaction to exhibit this pattern.","pos":[2047,2109]},{"content":"In the sample, the client sends a number of messages to the service as part of a session within the scope of a single transaction.","pos":[2116,2246]},{"content":"The service contract is <ph id=\"ph1\">`IOrderTaker`</ph>, which defines a one-way service that is suitable for use with queues.","pos":[2253,2361],"source":"The service contract is `IOrderTaker`, which defines a one-way service that is suitable for use with queues."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.SessionMode&gt;</ph> used in the contract shown in the following sample code indicates that the messages are part of the session.","pos":[2362,2513],"source":" The <xref:System.ServiceModel.SessionMode> used in the contract shown in the following sample code indicates that the messages are part of the session."},{"content":"The service defines service operations in such a way that the first operation enlists in a transaction but does not automatically complete the transaction.","pos":[2957,3112]},{"content":"Subsequent operations also enlist in the same transaction but do not automatically complete.","pos":[3113,3205]},{"content":"The last operation in the session automatically completes the transaction.","pos":[3206,3280]},{"content":"Thus, the same transaction is used for several operation invocations in the service contract.","pos":[3281,3374]},{"content":"If any of the operations throw an exception, then the transaction rolls back and the session is put back into the queue.","pos":[3375,3495]},{"content":"Upon successful completion of the last operation, the transaction is committed.","pos":[3496,3575]},{"content":"The service uses <ph id=\"ph1\">`PerSession`</ph> as the <ph id=\"ph2\">&lt;xref:System.ServiceModel.InstanceContextMode&gt;</ph> to receive all messages in a session on the same instance of the service.","pos":[3576,3733],"source":" The service uses `PerSession` as the <xref:System.ServiceModel.InstanceContextMode> to receive all messages in a session on the same instance of the service."},{"content":"The service is self hosted.","pos":[4931,4958]},{"content":"When using the MSMQ transport, the queue used must be created in advance.","pos":[4959,5032]},{"content":"This can be done manually or through code.","pos":[5033,5075]},{"content":"In this sample, the service contains <ph id=\"ph1\">&lt;xref:System.Messaging&gt;</ph> code to check for the existence of the queue and creates it, if necessary.","pos":[5076,5211],"source":" In this sample, the service contains <xref:System.Messaging> code to check for the existence of the queue and creates it, if necessary."},{"content":"The queue name is read from the configuration file using the <ph id=\"ph1\">&lt;xref:System.Configuration.ConfigurationManager.AppSettings%2A&gt;</ph> class.","pos":[5212,5343],"source":" The queue name is read from the configuration file using the <xref:System.Configuration.ConfigurationManager.AppSettings%2A> class."},{"content":"The MSMQ queue name is specified in an appSettings section of the configuration file.","pos":[6354,6439]},{"content":"The endpoint for the service is defined in the system.serviceModel section of the configuration file and specifies the <ph id=\"ph1\">`netMsmqBinding`</ph> binding.","pos":[6440,6584],"source":" The endpoint for the service is defined in the system.serviceModel section of the configuration file and specifies the `netMsmqBinding` binding."},{"content":"The client creates a transaction scope.","pos":[7279,7318]},{"content":"All messages in the session are sent to the queue within the transaction scope, causing it to be treated as an atomic unit where all messages succeed or fail.","pos":[7319,7477]},{"content":"The transaction is committed by calling <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A&gt;</ph>.","pos":[7478,7574],"source":" The transaction is committed by calling <xref:System.Transactions.TransactionScope.Complete%2A>."},{"pos":[8585,8909],"content":"[!NOTE]\n You can use only a single transaction for all messages in the session and all messages in the session must be sent before committing the transaction. Closing the client closes the session. Therefore, the client has to be closed before the transaction is completed to send all messages in the session to the queue.","leadings":["","> "],"nodes":[{"content":"You can use only a single transaction for all messages in the session and all messages in the session must be sent before committing the transaction. Closing the client closes the session. Therefore, the client has to be closed before the transaction is completed to send all messages in the session to the queue.","pos":[9,322],"nodes":[{"content":"You can use only a single transaction for all messages in the session and all messages in the session must be sent before committing the transaction.","pos":[0,149]},{"content":"Closing the client closes the session.","pos":[150,188]},{"content":"Therefore, the client has to be closed before the transaction is completed to send all messages in the session to the queue.","pos":[189,313]}]}]},{"content":"When you run the sample, the client and service activities are displayed in both the service and client console windows.","pos":[8916,9036]},{"content":"You can see the service receive messages from the client.","pos":[9037,9094]},{"content":"Press ENTER in each console window to shut down the service and client.","pos":[9095,9166]},{"content":"Note that because queuing is in use, the client and service do not have to be up and running at the same time.","pos":[9167,9277]},{"content":"You can run the client, shut it down, and then start up the service and it still receives its messages.","pos":[9278,9381]},{"content":"On the client.","pos":[9388,9402]},{"content":"On the service.","pos":[9593,9608]},{"pos":[10199,10235],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[10245,10444],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[10454,10669],"content":"To build the C#, C++, or Visual Basic .NET edition of the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the C#, C++, or Visual Basic .NET edition of the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[10679,10887],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"content":"By default with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.NetMsmqBinding&gt;</ph>, transport security is enabled.","pos":[10894,10987],"source":"By default with the <xref:System.ServiceModel.NetMsmqBinding>, transport security is enabled."},{"content":"There are two relevant properties for MSMQ transport security namely, <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqTransportSecurity.MsmqAuthenticationMode%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.MsmqTransportSecurity.MsmqProtectionLevel%2A&gt;</ph><ph id=\"ph3\">`.`</ph> By default, the authentication mode is set to <ph id=\"ph4\">`Windows`</ph> and the protection level is set to <ph id=\"ph5\">`Sign`</ph>.","pos":[10988,11310],"source":" There are two relevant properties for MSMQ transport security namely, <xref:System.ServiceModel.MsmqTransportSecurity.MsmqAuthenticationMode%2A> and <xref:System.ServiceModel.MsmqTransportSecurity.MsmqProtectionLevel%2A>`.` By default, the authentication mode is set to `Windows` and the protection level is set to `Sign`."},{"content":"For MSMQ to provide the authentication and signing feature, it must be part of a domain and the active directory integration option for MSMQ must be installed.","pos":[11311,11470]},{"content":"If you run this sample on a computer that does not satisfy these criteria you receive an error.","pos":[11471,11566]},{"pos":[11576,11669],"content":"To run the sample on a computer joined to a workgroup or without active directory integration","linkify":"To run the sample on a computer joined to a workgroup or without active directory integration","nodes":[{"content":"To run the sample on a computer joined to a workgroup or without active directory integration","pos":[0,93]}]},{"pos":[11679,11918],"content":"If your computer is not part of a domain or does not have active directory integration installed, turn off transport security by setting the authentication mode and protection level to <ph id=\"ph1\">`None`</ph> as shown in the following sample configuration.","source":"If your computer is not part of a domain or does not have active directory integration installed, turn off transport security by setting the authentication mode and protection level to `None` as shown in the following sample configuration."},{"content":"Ensure that you change the configuration on both the server and the client before you run the sample.","pos":[13462,13563]},{"pos":[13575,13829],"content":"[!NOTE]\nSetting security mode to `None` is equivalent to setting <xref:System.ServiceModel.MsmqTransportSecurity.MsmqAuthenticationMode%2A>, <xref:System.ServiceModel.MsmqTransportSecurity.MsmqProtectionLevel%2A>, and `Message` security to `None`.","leadings":["","    >  "],"nodes":[{"content":"Setting security mode to <ph id=\"ph1\">`None`</ph> is equivalent to setting <ph id=\"ph2\">&lt;xref:System.ServiceModel.MsmqTransportSecurity.MsmqAuthenticationMode%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.ServiceModel.MsmqTransportSecurity.MsmqProtectionLevel%2A&gt;</ph>, and <ph id=\"ph4\">`Message`</ph> security to <ph id=\"ph5\">`None`</ph>.","pos":[8,247],"source":"Setting security mode to `None` is equivalent to setting <xref:System.ServiceModel.MsmqTransportSecurity.MsmqAuthenticationMode%2A>, <xref:System.ServiceModel.MsmqTransportSecurity.MsmqProtectionLevel%2A>, and `Message` security to `None`."}]}]}