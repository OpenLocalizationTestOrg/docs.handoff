<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="using-delegates.md" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eb5721d1c04ad761821bcdae03159f290a802ec0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\delegates\using-delegates.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2449b5c101fcfe32610eb53676256fc28361b73f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e857b8c18d23fe85becd7cdb7c70e4b3037ad2d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Using Delegates - C# Programming Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Using Delegates (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>delegate<ept id="p1">](../../../csharp/language-reference/keywords/delegate.md)</ept> is a type that safely encapsulates a method, similar to a function pointer in C and C++.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Unlike C function pointers, delegates are object-oriented, type safe, and secure.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The type of a delegate is defined by the name of the delegate.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The following example declares a delegate named <ph id="ph1">`Del`</ph> that can encapsulate a method that takes a <bpt id="p1">[</bpt>string<ept id="p1">](../../../csharp/language-reference/keywords/string.md)</ept> as an argument and returns <bpt id="p2">[</bpt>void<ept id="p2">](../../../csharp/language-reference/keywords/void.md)</ept>:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an <bpt id="p1">[</bpt>anonymous Method<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This is known as invoking the delegate.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>An instantiated delegate can be invoked as if it were the wrapped method itself.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Delegate types are derived from the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Delegate types are <bpt id="p1">[</bpt>sealed<ept id="p1">](../../../csharp/language-reference/keywords/sealed.md)</ept>—they cannot be derived from— and it is not possible to derive custom classes from <ph id="ph1">&lt;xref:System.Delegate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This allows a method to accept a delegate as a parameter, and call the delegate at some later time.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The functionality is similar to the encapsulation interfaces provide.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It allows the caller's code to become part of the sort algorithm.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following example method uses the <ph id="ph1">`Del`</ph> type as a parameter:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can then pass the delegate created above to that method:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>and receive the following output to the console:</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Using the delegate as an abstraction, <ph id="ph1">`MethodWithCallback`</ph> does not need to call the console directly—it does not have to be designed with a console in mind.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>What <ph id="ph1">`MethodWithCallback`</ph> does is simply prepare a string and pass the string to another method.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This is especially powerful since a delegated method can use any number of parameters.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When a delegate is constructed to wrap a static method, it only references the method.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Consider the following declarations:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Along with the static <ph id="ph1">`DelegateMethod`</ph> shown previously, we now have three methods that can be wrapped by a <ph id="ph2">`Del`</ph> instance.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A delegate can call more than one method when invoked.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This is referred to as multicasting.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To add an extra method to the delegate's list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators ('+' or '+=').</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>At this point <ph id="ph1">`allMethodsDelegate`</ph> contains three methods in its invocation list—<ph id="ph2">`Method1`</ph>, <ph id="ph3">`Method2`</ph>, and <ph id="ph4">`DelegateMethod`</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The original three delegates, <ph id="ph1">`d1`</ph>, <ph id="ph2">`d2`</ph>, and <ph id="ph3">`d3`</ph>, remain unchanged.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`allMethodsDelegate`</ph> is invoked, all three methods are called in order.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To remove a method from the invocation list, use the decrement or decrement assignment operator ('-' or '-=').</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Because delegate types are derived from <ph id="ph1">`System.Delegate`</ph>, the methods and properties defined by that class can be called on the delegate.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example, to find the number of methods in a delegate's invocation list, you may write:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Delegates with more than one method in their invocation list derive from <ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph>, which is a subclass of <ph id="ph2">`System.Delegate`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The above code works in either case because both classes support <ph id="ph1">`GetInvocationList`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Multicast delegates are used extensively in event handling.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Event source objects send event notifications to recipient objects that have registered to receive that event.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The source calls the delegate when the event occurs.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The delegate then calls the event handling method on the recipient, delivering the event data.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The delegate type for a given event is defined by the event source.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more, see <bpt id="p1">[</bpt>Events<ept id="p1">](../../../csharp/programming-guide/events/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Comparing delegates of two different types assigned at compile-time will result in a compilation error.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If the delegate instances are statically of the type <ph id="ph1">`System.Delegate`</ph>, then the comparison is allowed, but will return false at run time.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](../../../csharp/programming-guide/delegates/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Variance in Delegates<ept id="p1">](../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates.md)</ept></source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Variance in Delegates<ept id="p1">](../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Variance for Func and Action Generic Delegates<ept id="p1">](../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](../../../csharp/programming-guide/events/index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>