{"content":"---\ntitle: Inheritance in C#\ndescription: Learn to use inheritance in C# libraries and applications.\nauthor: rpetrusha\nms.author: ronpet\nms.date: 07/05/2018\nms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31\n---\n# Inheritance in C# and .NET\n\nThis tutorial introduces you to inheritance in C#. Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.\n\n## Prerequisites\n\nThis tutorial assumes that you've installed .NET Core. For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core). You also need a code editor. This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.\n\n## Running the examples\n\nTo create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line. Follow these steps for each example:\n\n1. Create a directory to store the example.\n1. Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.\n1. Copy and paste the code from the example into your code editor.\n1. Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.\n\n  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]\n\n1. Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.\n\n## Background: What is inheritance?\n\n*Inheritance* is one of the fundamental attributes of object-oriented programming. It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class. The class whose members are inherited is called the *base class*. The class that inherits the members of the base class is called the *derived class*.\n\nC# and .NET support *single inheritance* only. That is, a class can only inherit from a single class. However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types. In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`. Because inheritance is transitive, the members of type `A` are available to type `D`.\n\nNot all members of a base class are inherited by derived classes. The following members are not inherited:\n\n- [Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.\n\n- [Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class. Each class must define its own constructors.\n\n- [Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.\n\nWhile all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility. A member's accessibility affects its visibility for derived classes as follows:\n\n- [Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class. Otherwise, they are not visible in derived classes. In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`. The private `A.value` field is visible in A.B. However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: \"'A.value' is inaccessible due to its protection level.\"\n\n  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]\n\n- [Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.\n\n- [Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class. They are not visible in derived classes located in a different assembly from the base class.\n\n- [Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface. Public inherited members can be called just as if they are defined in the derived class. In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`. The example then calls `Method1` as if it were an instance method on `B`.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]\n\nDerived classes can also *override* inherited members by providing an alternate implementation. In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword. By default, base class members are not marked as `virtual` and cannot be overridden. Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: \"\\<member> cannot override inherited member \\<member> because it is not marked virtual, abstract, or override.\n\n```csharp\npublic class A\n{\n    public void Method1()\n    {\n        // Do something.\n    }\n}\n\npublic class B : A\n{\n    public override void Method1() // Generates CS0506.\n    {\n        // Do something else.\n    }\n}\n```\n\nIn some cases, a derived class *must* override the base class implementation. Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them. Attempting to compile the following example generates compiler error CS0534, \"&lt;class&gt; does not implement inherited abstract member &lt;member&gt;\", because class `B` provides no implementation for `A.Method1`.\n\n```csharp\npublic abstract class A\n{\n    public abstract void Method1();\n}\n\npublic class B : A // Generates CS0534.\n{\n    public void Method3()\n    {\n        // Do something.\n    }\n}\n```\n\nInheritance applies only to classes and interfaces. Other type categories (structs, delegates, and enums) do not support inheritance. Because of these rules, attempting to compile code like the following example produces compiler error CS0527: \"Type 'ValueType' in interface list is not an interface.\" The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.\n\n```csharp\nusing System;\n\npublic struct ValueStructure : ValueType // Generates CS0527.\n{\n}\n```\n\n## Implicit inheritance\n\nBesides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it. The common functionality of <xref:System.Object> is available to any type.\n\nTo see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]\n\nYou can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type. Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members. One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler. The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]\n\nImplicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:\n\n- The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name. In this case, the `ToString` method returns the string \"SimpleClass\".\n\n- Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method. By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.\n\n- The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.\n\n- The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.\n\n- The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.\n\n- The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.\n\nBecause of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class. For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]\n\nThe following table lists the categories of types that you can create in C# and the types from which they implicitly inherit. Each base type makes a different set of members available through inheritance to implicitly derived types.\n\n| Type category | Implicitly inherits from                                                      |\n| ------------- | ----------------------------------------------------------------------------- |\n| class         | <xref:System.Object>                                                          |\n| struct        | <xref:System.ValueType>, <xref:System.Object>                                 |\n| enum          | <xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object>             |\n| delegate      | <xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object> |\n\n## Inheritance and an \"is a\" relationship\n\nOrdinarily, inheritance is used to express an \"is a\" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class. For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.\n\n> [!NOTE]\n> A class or struct can implement one or more interfaces. While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a \"can do\" relationship) between an interface and its implementing type than inheritance. An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.\n\nNote that \"is a\" also expresses the relationship between a type and a specific instantiation of that type. In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture. Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]\n\nIn this case, you shouldn't rely on inheritance to represent specific car makes and models. For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company. Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]\n\nAn is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.\n\n## Designing the base class and derived classes\n\nLet's look at the process of designing a base class and its derived classes. In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`. You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.\n\n### The base Publication class\n\nIn designing your `Publication` class, you need to make several design decisions:\n\n- What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.\n\n  In this case, the `Publication` class will provide method implementations. The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override. Derived classes are free to provide any implementation that is suitable for the derived type.\n\n  The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes. Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types. If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class. The need to maintain duplicated code in multiple locations is a potential source of bugs.\n\n  Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications. Derived classes then implement members that are unique to the particular kinds of publication that they represent.\n\n- How far to extend your class hierarchy. Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes? For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.\n\n  For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`. You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.\n\n- Whether it makes sense to instantiate the base class. If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class. Otherwise, your `Publication` class can be instantiated by calling its class constructor. If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, \"Cannot create an instance of the abstract class or interface.\" If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.\n\n  By default, a base class can be instantiated by calling its class constructor. You do not have to explicitly define a class constructor. If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.\n\n  For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.  An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).\n\n- Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation. You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation. You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method. By default, methods defined in the base class are *not* overridable.\n\n The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.\n\n- Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes. By default, any class can serve as a base class. You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes. Attempting to derive from a sealed class generated compiler error CS0509, \"cannot derive from sealed type \\<typeName>\".\n\n  For your example, you'll mark your derived class as `sealed`.\n\nThe following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property. In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]\n\n- A constructor\n\n  Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:\n\n  ```csharp\n  var publication = new Publication(\"Tiddlywinks for Experts\", \"Fun and Games\",\n                                    PublicationType.Book);\n  ```\n\n  However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.\n\n- Two publication-related properties\n\n  `Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.\n\n  `Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has. The value is stored in a private field named `totalPages`. It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.\n\n- Publisher-related members\n\n  Two read-only properties, `Publisher` and `Type`. The values are originally supplied by the call to the `Publication` class constructor.\n\n- Publishing-related members\n\n  Two methods, `Publish` and `GetPublicationDate`, set and return the publication date. The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field. The `GetPublicationDate` method returns the string \"NYP\" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.\n\n- Copyright-related members\n\n  The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.\n\n- An override of the `ToString` method\n\n  If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another. The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.\n\nThe following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.\n\n![The Object and Publication classes](media/publication-class.jpg)\n\n### The `Book` class\n\nThe `Book` class represents a book as a specialized type of publication. The following example shows the source code for the `Book` class.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]\n\nIn addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:\n\n- Two constructors\n\n  The two `Book` constructors share three common parameters. Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor. The third is *author*, which is stored to a public immutable `Author` property. One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.\n\n  The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor. Constructor chaining is a common pattern in defining constructors. Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.\n\n  The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor. If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.\n\n- A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number. The ISBN is supplied as an argument to one of the `Book` constructors. The ISBN is stored in a private backing field, which is auto-generated by the compiler.\n\n- A read-only `Author` property. The author name is supplied as an argument to both `Book` constructors and is stored in the property.\n\n- Two read-only price-related properties, `Price` and `Currency`. Their values are provided as arguments in a `SetPrice` method call. The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar). ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property. Both of these properties are externally read-only, but both can be set by code in the `Book` class.\n\n- A `SetPrice` method, which sets the values of the `Price` and `Currency` properties. Those values are returned by those same properties.\n\n- Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).\n\n  Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality. That is, two object variables are considered to be equal if they refer to the same object. In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.\n\n  When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval. The hash code should return a value that's consistent with the test for equality. Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.\n\nThe following figure illustrates the relationship between the `Book` class and `Publication`, its base class.\n\n![Publication and Book classes](media/book-class.jpg)\n\nYou can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]\n\n## Designing abstract base classes and their derived classes\n<a name=\"abstract\"></a>\n\nIn the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code. In many cases, however, the base class is not expected to provide an implementation. Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement. Typically in an abstract base class, the implementation of each derived type is unique to that type. You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.\n\nFor example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape. The way in which these properties are calculated, however, depends completely on the specific shape. The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle. The `Shape` class is an `abstract` class with `abstract` methods. That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.\n\nThe following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`. In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword. In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name. And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class. When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]\n\nYou can then derive some classes from `Shape` that represent specific shapes. The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`. Each uses a formula unique for that particular shape to compute the area and perimeter. Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.\n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]\n\nThe following example uses objects derived from `Shape`. It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values. The runtime retrieves values from the overridden properties of the derived types. The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`. \n\n[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]\n\n## See also\n\n- [Classes and objects](../tour-of-csharp/classes-and-objects.md)\n- [Inheritance (C# Programming Guide)](../programming-guide/classes-and-structs/inheritance.md)\n","nodes":[{"pos":[4,205],"embed":true,"restype":"x-metadata","content":"title: Inheritance in C#\ndescription: Learn to use inheritance in C# libraries and applications.\nauthor: rpetrusha\nms.author: ronpet\nms.date: 07/05/2018\nms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31","nodes":[{"content":"Inheritance in C#","nodes":[{"pos":[0,17],"content":"Inheritance in C#","nodes":[{"content":"Inheritance in C#","pos":[0,17]}]}],"path":["title"],"nosxs":false},{"content":"Learn to use inheritance in C# libraries and applications.","nodes":[{"pos":[0,58],"content":"Learn to use inheritance in C# libraries and applications.","nodes":[{"content":"Learn to use inheritance in C# libraries and applications.","pos":[0,58]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[212,238],"content":"Inheritance in C# and .NET","linkify":"Inheritance in C# and .NET","nodes":[{"content":"Inheritance in C# and .NET","pos":[0,26]}]},{"content":"This tutorial introduces you to inheritance in C#.","pos":[240,290]},{"content":"Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.","pos":[291,534]},{"pos":[539,552],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"This tutorial assumes that you've installed .NET Core.","pos":[554,608]},{"content":"For installation instructions, see <bpt id=\"p1\">[</bpt>.NET Core installation guide<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept>.","pos":[609,711],"source":" For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core)."},{"content":"You also need a code editor.","pos":[712,740]},{"content":"This tutorial uses <bpt id=\"p1\">[</bpt>Visual Studio Code<ept id=\"p1\">](https://code.visualstudio.com)</ept>, although you can use any code editor of your choice.","pos":[741,865],"source":" This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice."},{"pos":[870,890],"content":"Running the examples","linkify":"Running the examples","nodes":[{"content":"Running the examples","pos":[0,20]}]},{"content":"To create and run the examples in this tutorial, you use the <bpt id=\"p1\">[</bpt>dotnet<ept id=\"p1\">](../../core/tools/dotnet.md)</ept> utility from the command line.","pos":[892,1020],"source":"To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line."},{"content":"Follow these steps for each example:","pos":[1021,1057]},{"content":"Create a directory to store the example.","pos":[1062,1102]},{"pos":[1106,1231],"content":"Enter the <bpt id=\"p1\">[</bpt>dotnet new console<ept id=\"p1\">](../../core/tools/dotnet-new.md)</ept> command at a command prompt to create a new .NET Core project.","source":"Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project."},{"content":"Copy and paste the code from the example into your code editor.","pos":[1235,1298]},{"pos":[1302,1441],"content":"Enter the <bpt id=\"p1\">[</bpt>dotnet restore<ept id=\"p1\">](../../core/tools/dotnet-restore.md)</ept> command from the command line to load or restore the project's dependencies.","source":"Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies."},{"pos":[1516,1614],"content":"Enter the <bpt id=\"p1\">[</bpt>dotnet run<ept id=\"p1\">](../../core/tools/dotnet-run.md)</ept> command to compile and execute the example.","source":"Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example."},{"pos":[1619,1651],"content":"Background: What is inheritance?","linkify":"Background: What is inheritance?","nodes":[{"content":"Background: What is inheritance?","pos":[0,32]}]},{"content":"<bpt id=\"p1\">*</bpt>Inheritance<ept id=\"p1\">*</ept> is one of the fundamental attributes of object-oriented programming.","pos":[1653,1735],"source":"*Inheritance* is one of the fundamental attributes of object-oriented programming."},{"content":"It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.","pos":[1736,1850]},{"content":"The class whose members are inherited is called the <bpt id=\"p1\">*</bpt>base class<ept id=\"p1\">*</ept>.","pos":[1851,1916],"source":" The class whose members are inherited is called the *base class*."},{"content":"The class that inherits the members of the base class is called the <bpt id=\"p1\">*</bpt>derived class<ept id=\"p1\">*</ept>.","pos":[1917,2001],"source":" The class that inherits the members of the base class is called the *derived class*."},{"content":"C# and .NET support <bpt id=\"p1\">*</bpt>single inheritance<ept id=\"p1\">*</ept> only.","pos":[2003,2049],"source":"C# and .NET support *single inheritance* only."},{"content":"That is, a class can only inherit from a single class.","pos":[2050,2104]},{"content":"However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.","pos":[2105,2212]},{"content":"In other words, type <ph id=\"ph1\">`D`</ph> can inherit from type <ph id=\"ph2\">`C`</ph>, which inherits from type <ph id=\"ph3\">`B`</ph>, which inherits from the base class type <ph id=\"ph4\">`A`</ph>.","pos":[2213,2339],"source":" In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`."},{"content":"Because inheritance is transitive, the members of type <ph id=\"ph1\">`A`</ph> are available to type <ph id=\"ph2\">`D`</ph>.","pos":[2340,2425],"source":" Because inheritance is transitive, the members of type `A` are available to type `D`."},{"content":"Not all members of a base class are inherited by derived classes.","pos":[2427,2492]},{"content":"The following members are not inherited:","pos":[2493,2533]},{"pos":[2537,2669],"content":"<bpt id=\"p1\">[</bpt>Static constructors<ept id=\"p1\">](../programming-guide/classes-and-structs/static-constructors.md)</ept>, which initialize the static data of a class.","source":"[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class."},{"content":"<bpt id=\"p1\">[</bpt>Instance constructors<ept id=\"p1\">](../programming-guide/classes-and-structs/constructors.md)</ept>, which you call to create a new instance of the class.","pos":[2673,2809],"source":"[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class."},{"content":"Each class must define its own constructors.","pos":[2810,2854]},{"pos":[2858,3013],"content":"<bpt id=\"p1\">[</bpt>Finalizers<ept id=\"p1\">](../programming-guide/classes-and-structs/destructors.md)</ept>, which are called by the runtime's garbage collector to destroy instances of a class.","source":"[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class."},{"content":"While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.","pos":[3015,3152]},{"content":"A member's accessibility affects its visibility for derived classes as follows:","pos":[3153,3232]},{"content":"<bpt id=\"p1\">[</bpt>Private<ept id=\"p1\">](../language-reference/keywords/private.md)</ept> members are visible only in derived classes that are nested in their base class.","pos":[3236,3369],"source":"[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class."},{"content":"Otherwise, they are not visible in derived classes.","pos":[3370,3421]},{"content":"In the following example, <ph id=\"ph1\">`A.B`</ph> is a nested class that derives from <ph id=\"ph2\">`A`</ph>, and <ph id=\"ph3\">`C`</ph> derives from <ph id=\"ph4\">`A`</ph>.","pos":[3422,3520],"source":" In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`."},{"content":"The private <ph id=\"ph1\">`A.value`</ph> field is visible in A.B.","pos":[3521,3567],"source":" The private `A.value` field is visible in A.B."},{"content":"However, if you remove the comments from the <ph id=\"ph1\">`C.GetValue`</ph> method and attempt to compile the example, it produces compiler error CS0122: \"'A.value' is inaccessible due to its protection level.\"","pos":[3568,3760],"source":" However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: \"'A.value' is inaccessible due to its protection level.\""},{"pos":[3864,3965],"content":"<bpt id=\"p1\">[</bpt>Protected<ept id=\"p1\">](../language-reference/keywords/protected.md)</ept> members are visible only in derived classes.","source":"[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes."},{"content":"<bpt id=\"p1\">[</bpt>Internal<ept id=\"p1\">](../language-reference/keywords/internal.md)</ept> members are visible only in derived classes that are located in the same assembly as the base class.","pos":[3969,4124],"source":"[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class."},{"content":"They are not visible in derived classes located in a different assembly from the base class.","pos":[4125,4217]},{"content":"<bpt id=\"p1\">[</bpt>Public<ept id=\"p1\">](../language-reference/keywords/public.md)</ept> members are visible in derived classes and are part of the derived class' public interface.","pos":[4221,4363],"source":"[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface."},{"content":"Public inherited members can be called just as if they are defined in the derived class.","pos":[4364,4452]},{"content":"In the following example, class <ph id=\"ph1\">`A`</ph> defines a method named <ph id=\"ph2\">`Method1`</ph>, and class <ph id=\"ph3\">`B`</ph> inherits from class <ph id=\"ph4\">`A`</ph>.","pos":[4453,4561],"source":" In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`."},{"content":"The example then calls <ph id=\"ph1\">`Method1`</ph> as if it were an instance method on <ph id=\"ph2\">`B`</ph>.","pos":[4562,4635],"source":" The example then calls `Method1` as if it were an instance method on `B`."},{"content":"Derived classes can also <bpt id=\"p1\">*</bpt>override<ept id=\"p1\">*</ept> inherited members by providing an alternate implementation.","pos":[4734,4829],"source":"Derived classes can also *override* inherited members by providing an alternate implementation."},{"content":"In order to be able to override a member, the member in the base class must be marked with the <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../language-reference/keywords/virtual.md)</ept> keyword.","pos":[4830,4986],"source":" In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword."},{"content":"By default, base class members are not marked as <ph id=\"ph1\">`virtual`</ph> and cannot be overridden.","pos":[4987,5071],"source":" By default, base class members are not marked as `virtual` and cannot be overridden."},{"content":"Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: \"<ph id=\"ph1\">\\&lt;</ph>member&gt; cannot override inherited member <ph id=\"ph2\">\\&lt;</ph>member&gt; because it is not marked virtual, abstract, or override.","pos":[5072,5291],"source":" Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: \"\\<member> cannot override inherited member \\<member> because it is not marked virtual, abstract, or override."},{"content":"In some cases, a derived class <bpt id=\"p1\">*</bpt>must<ept id=\"p1\">*</ept> override the base class implementation.","pos":[5512,5589],"source":"In some cases, a derived class *must* override the base class implementation."},{"content":"Base class members marked with the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> keyword require that derived classes override them.","pos":[5590,5731],"source":" Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them."},{"content":"Attempting to compile the following example generates compiler error CS0534, \"<ph id=\"ph1\">&amp;lt;</ph>class<ph id=\"ph2\">&amp;gt;</ph> does not implement inherited abstract member <ph id=\"ph3\">&amp;lt;</ph>member<ph id=\"ph4\">&amp;gt;</ph>\", because class <ph id=\"ph5\">`B`</ph> provides no implementation for <ph id=\"ph6\">`A.Method1`</ph>.","pos":[5732,5947],"source":" Attempting to compile the following example generates compiler error CS0534, \"&lt;class&gt; does not implement inherited abstract member &lt;member&gt;\", because class `B` provides no implementation for `A.Method1`."},{"content":"Inheritance applies only to classes and interfaces.","pos":[6136,6187]},{"content":"Other type categories (structs, delegates, and enums) do not support inheritance.","pos":[6188,6269]},{"content":"Because of these rules, attempting to compile code like the following example produces compiler error CS0527: \"Type 'ValueType' in interface list is not an interface.\"","pos":[6270,6437]},{"content":"The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.","pos":[6438,6566]},{"pos":[6667,6687],"content":"Implicit inheritance","linkify":"Implicit inheritance","nodes":[{"content":"Implicit inheritance","pos":[0,20]}]},{"content":"Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> or a type derived from it.","pos":[6689,6867],"source":"Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it."},{"content":"The common functionality of <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> is available to any type.","pos":[6868,6942],"source":" The common functionality of <xref:System.Object> is available to any type."},{"pos":[6944,7066],"content":"To see what implicit inheritance means, let's define a new class, <ph id=\"ph1\">`SimpleClass`</ph>, that is simply an empty class definition:","source":"To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:"},{"content":"You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the <ph id=\"ph1\">`SimpleClass`</ph> type.","pos":[7170,7343],"source":"You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type."},{"content":"Although you haven't defined any members in your <ph id=\"ph1\">`SimpleClass`</ph> class, output from the example indicates that it actually has nine members.","pos":[7344,7482],"source":" Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members."},{"content":"One of these members is a parameterless (or default) constructor that is automatically supplied for the <ph id=\"ph1\">`SimpleClass`</ph> type by the C# compiler.","pos":[7483,7625],"source":" One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler."},{"content":"The remaining eight are members of <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.","pos":[7626,7784],"source":" The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit."},{"pos":[7888,8002],"content":"Implicit inheritance from the <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> class makes these methods available to the <ph id=\"ph2\">`SimpleClass`</ph> class:","source":"Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:"},{"content":"The public <ph id=\"ph1\">`ToString`</ph> method, which converts a <ph id=\"ph2\">`SimpleClass`</ph> object to its string representation, returns the fully qualified type name.","pos":[8006,8142],"source":"The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name."},{"content":"In this case, the <ph id=\"ph1\">`ToString`</ph> method returns the string \"SimpleClass\".","pos":[8143,8212],"source":" In this case, the `ToString` method returns the string \"SimpleClass\"."},{"content":"Three methods that test for equality of two objects: the public instance <ph id=\"ph1\">`Equals(Object)`</ph> method, the public static <ph id=\"ph2\">`Equals(Object, Object)`</ph> method, and the public static <ph id=\"ph3\">`ReferenceEquals(Object, Object)`</ph> method.","pos":[8216,8428],"source":"Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method."},{"content":"By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.","pos":[8429,8557]},{"pos":[8561,8686],"content":"The public <ph id=\"ph1\">`GetHashCode`</ph> method, which computes a value that allows an instance of the type to be used in hashed collections.","source":"The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections."},{"pos":[8690,8800],"content":"The public <ph id=\"ph1\">`GetType`</ph> method, which returns a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that represents the <ph id=\"ph3\">`SimpleClass`</ph> type.","source":"The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type."},{"pos":[8804,8972],"content":"The protected <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.","source":"The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector."},{"pos":[8976,9090],"content":"The protected <ph id=\"ph1\">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method, which creates a shallow clone of the current object.","source":"The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object."},{"content":"Because of implicit inheritance, you can call any inherited member from a <ph id=\"ph1\">`SimpleClass`</ph> object just as if it was actually a member defined in the <ph id=\"ph2\">`SimpleClass`</ph> class.","pos":[9092,9258],"source":"Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class."},{"content":"For instance, the following example calls the <ph id=\"ph1\">`SimpleClass.ToString`</ph> method, which <ph id=\"ph2\">`SimpleClass`</ph> inherits from <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>.","pos":[9259,9391],"source":" For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>."},{"content":"The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.","pos":[9496,9621]},{"content":"Each base type makes a different set of members available through inheritance to implicitly derived types.","pos":[9622,9728]},{"content":"Type category","pos":[9732,9745]},{"content":"Implicitly inherits from","pos":[9748,9772]},{"content":"class","pos":[9928,9933]},{"content":"struct","pos":[10026,10032]},{"pos":[10042,10087],"content":"<ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>","source":"<xref:System.ValueType>, <xref:System.Object>"},{"content":"enum","pos":[10124,10128]},{"pos":[10140,10205],"content":"<ph id=\"ph1\">&lt;xref:System.Enum&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>","source":"<xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object>"},{"content":"delegate","pos":[10222,10230]},{"pos":[10238,10315],"content":"<ph id=\"ph1\">&lt;xref:System.MulticastDelegate&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Delegate&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>","source":"<xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object>"},{"pos":[10322,10360],"content":"Inheritance and an \"is a\" relationship","linkify":"Inheritance and an \"is a\" relationship","nodes":[{"content":"Inheritance and an \"is a\" relationship","pos":[0,38]}]},{"content":"Ordinarily, inheritance is used to express an \"is a\" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.","pos":[10362,10598]},{"content":"For example, the <ph id=\"ph1\">`Publication`</ph> class represents a publication of any kind, and the <ph id=\"ph2\">`Book`</ph> and <ph id=\"ph3\">`Magazine`</ph> classes represent specific types of publications.","pos":[10599,10753],"source":" For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications."},{"pos":[10757,11336],"content":"[!NOTE]\nA class or struct can implement one or more interfaces. While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a \"can do\" relationship) between an interface and its implementing type than inheritance. An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.","leadings":["","> "],"nodes":[{"content":"A class or struct can implement one or more interfaces. While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a \"can do\" relationship) between an interface and its implementing type than inheritance. An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.","pos":[8,577],"nodes":[{"content":"A class or struct can implement one or more interfaces.","pos":[0,55]},{"content":"While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a \"can do\" relationship) between an interface and its implementing type than inheritance.","pos":[56,333]},{"content":"An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.","pos":[334,569]}]}]},{"content":"Note that \"is a\" also expresses the relationship between a type and a specific instantiation of that type.","pos":[11338,11444]},{"content":"In the following example, <ph id=\"ph1\">`Automobile`</ph> is a class that has three unique read-only properties: <ph id=\"ph2\">`Make`</ph>, the manufacturer of the automobile; <ph id=\"ph3\">`Model`</ph>, the kind of automobile; and <ph id=\"ph4\">`Year`</ph>, its year of manufacture.","pos":[11445,11652],"source":" In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture."},{"content":"Your <ph id=\"ph1\">`Automobile`</ph> class also has a constructor whose arguments are assigned to the property values, and it overrides the <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to produce a string that uniquely identifies the <ph id=\"ph3\">`Automobile`</ph> instance rather than the <ph id=\"ph4\">`Automobile`</ph> class.","pos":[11653,11949],"source":" Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class."},{"content":"In this case, you shouldn't rely on inheritance to represent specific car makes and models.","pos":[12046,12137]},{"content":"For example, you don't need to define a <ph id=\"ph1\">`Packard`</ph> type to represent automobiles manufactured by the Packard Motor Car Company.","pos":[12138,12264],"source":" For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company."},{"content":"Instead, you can represent them by creating an <ph id=\"ph1\">`Automobile`</ph> object with the appropriate values passed to its class constructor, as the following example does.","pos":[12265,12423],"source":" Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does."},{"content":"An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.","pos":[12520,12734]},{"pos":[12739,12783],"content":"Designing the base class and derived classes","linkify":"Designing the base class and derived classes","nodes":[{"content":"Designing the base class and derived classes","pos":[0,44]}]},{"content":"Let's look at the process of designing a base class and its derived classes.","pos":[12785,12861]},{"content":"In this section, you'll define a base class, <ph id=\"ph1\">`Publication`</ph>, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a <ph id=\"ph2\">`Book`</ph> class that derives from <ph id=\"ph3\">`Publication`</ph>.","pos":[12862,13101],"source":" In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`."},{"content":"You could easily extend the example to define other derived classes, such as <ph id=\"ph1\">`Magazine`</ph>, <ph id=\"ph2\">`Journal`</ph>, <ph id=\"ph3\">`Newspaper`</ph>, and <ph id=\"ph4\">`Article`</ph>.","pos":[13102,13229],"source":" You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`."},{"pos":[13235,13261],"content":"The base Publication class","linkify":"The base Publication class","nodes":[{"content":"The base Publication class","pos":[0,26]}]},{"pos":[13263,13344],"content":"In designing your <ph id=\"ph1\">`Publication`</ph> class, you need to make several design decisions:","source":"In designing your `Publication` class, you need to make several design decisions:"},{"pos":[13348,13576],"content":"What members to include in your base <ph id=\"ph1\">`Publication`</ph> class, and whether the <ph id=\"ph2\">`Publication`</ph> members provide method implementations or whether <ph id=\"ph3\">`Publication`</ph> is an abstract base class that serves as a template for its derived classes.","source":"What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes."},{"content":"In this case, the <ph id=\"ph1\">`Publication`</ph> class will provide method implementations.","pos":[13580,13654],"source":"In this case, the `Publication` class will provide method implementations."},{"content":"The <bpt id=\"p1\">[</bpt>Designing abstract base classes and their derived classes<ept id=\"p1\">](#abstract)</ept> section contains an example that uses an abstract base class to define the methods that derived classes must override.","pos":[13655,13848],"source":" The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override."},{"content":"Derived classes are free to provide any implementation that is suitable for the derived type.","pos":[13849,13942]},{"content":"The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.","pos":[13946,14149]},{"content":"Therefore, you should add members to <ph id=\"ph1\">`Publication`</ph> if their code is likely to be shared by some or most specialized <ph id=\"ph2\">`Publication`</ph> types.","pos":[14150,14286],"source":" Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types."},{"content":"If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.","pos":[14287,14491]},{"content":"The need to maintain duplicated code in multiple locations is a potential source of bugs.","pos":[14492,14581]},{"content":"Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the <ph id=\"ph1\">`Publication`</ph> class only the data and functionality that is common to all or to most publications.","pos":[14585,14816],"source":"Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications."},{"content":"Derived classes then implement members that are unique to the particular kinds of publication that they represent.","pos":[14817,14931]},{"content":"How far to extend your class hierarchy.","pos":[14935,14974]},{"content":"Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?","pos":[14975,15100]},{"content":"For example, <ph id=\"ph1\">`Publication`</ph> could be a base class of <ph id=\"ph2\">`Periodical`</ph>, which in turn is a base class of <ph id=\"ph3\">`Magazine`</ph>, <ph id=\"ph4\">`Journal`</ph> and <ph id=\"ph5\">`Newspaper`</ph>.","pos":[15101,15238],"source":" For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`."},{"content":"For your example, you'll use the small hierarchy of a <ph id=\"ph1\">`Publication`</ph> class and a single derived class, <ph id=\"ph2\">`Book`</ph>.","pos":[15242,15351],"source":"For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`."},{"content":"You could easily extend the example to create a number of additional   classes that derive from <ph id=\"ph1\">`Publication`</ph>, such as <ph id=\"ph2\">`Magazine`</ph> and <ph id=\"ph3\">`Article`</ph>.","pos":[15352,15496],"source":" You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`."},{"content":"Whether it makes sense to instantiate the base class.","pos":[15500,15553]},{"content":"If it does not, you should apply the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> keyword to the class.","pos":[15554,15667],"source":" If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class."},{"content":"Otherwise, your <ph id=\"ph1\">`Publication`</ph> class can be instantiated by calling its class constructor.","pos":[15668,15757],"source":" Otherwise, your `Publication` class can be instantiated by calling its class constructor."},{"content":"If an attempt is made to instantiate a class marked with the <ph id=\"ph1\">`abstract`</ph> keyword by a direct call to its class constructor, the C# compiler generates error CS0144, \"Cannot create an instance of the abstract class or interface.\"","pos":[15758,15984],"source":" If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, \"Cannot create an instance of the abstract class or interface.\""},{"content":"If an attempt is made to instantiate the class by using reflection, the reflection method throws a <ph id=\"ph1\">&lt;xref:System.MemberAccessException&gt;</ph>.","pos":[15985,16120],"source":" If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>."},{"content":"By default, a base class can be instantiated by calling its class constructor.","pos":[16124,16202]},{"content":"You do not have to explicitly define a class constructor.","pos":[16203,16260]},{"content":"If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.","pos":[16261,16392]},{"content":"For your example, you'll mark the <ph id=\"ph1\">`Publication`</ph> class as <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> so that it cannot be instantiated.","pos":[16396,16542],"source":"For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated."},{"content":"An <ph id=\"ph1\">`abstract`</ph> class without any <ph id=\"ph2\">`abstract`</ph> methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a <ph id=\"ph3\">`Book`</ph>, <ph id=\"ph4\">`Journal`</ph>).","pos":[16544,16725],"source":"  An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`)."},{"content":"Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.","pos":[16729,16938]},{"content":"You use the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> keyword to force derived classes to provide an implementation.","pos":[16939,17068],"source":" You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation."},{"content":"You use the <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../language-reference/keywords/virtual.md)</ept> keyword to allow derived classes to override a base class method.","pos":[17069,17199],"source":" You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method."},{"content":"By default, methods defined in the base class are <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> overridable.","pos":[17200,17268],"source":" By default, methods defined in the base class are *not* overridable."},{"pos":[17271,17368],"content":"The <ph id=\"ph1\">`Publication`</ph> class does not have any <ph id=\"ph2\">`abstract`</ph> methods, but the class itself is <ph id=\"ph3\">`abstract`</ph>.","source":"The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`."},{"content":"Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.","pos":[17372,17525]},{"content":"By default, any class can serve as a base class.","pos":[17526,17574]},{"content":"You can apply the <bpt id=\"p1\">[</bpt>sealed<ept id=\"p1\">](../language-reference/keywords/sealed.md)</ept> keyword to indicate that a class cannot serve as a base class for any additional classes.","pos":[17575,17733],"source":" You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes."},{"content":"Attempting to derive from a sealed class generated compiler error CS0509, \"cannot derive from sealed type <ph id=\"ph1\">\\&lt;</ph>typeName&gt;\".","pos":[17734,17853],"source":" Attempting to derive from a sealed class generated compiler error CS0509, \"cannot derive from sealed type \\<typeName>\"."},{"pos":[17857,17918],"content":"For your example, you'll mark your derived class as <ph id=\"ph1\">`sealed`</ph>.","source":"For your example, you'll mark your derived class as `sealed`."},{"content":"The following example shows the source code for the <ph id=\"ph1\">`Publication`</ph> class, as well as a <ph id=\"ph2\">`PublicationType`</ph> enumeration that is returned by the <ph id=\"ph3\">`Publication.PublicationType`</ph> property.","pos":[17920,18099],"source":"The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property."},{"content":"In addition to the members that it inherits from <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, the <ph id=\"ph2\">`Publication`</ph> class defines the following unique members and member overrides:","pos":[18100,18253],"source":" In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:"},{"content":"A constructor","pos":[18364,18377]},{"pos":[18381,18500],"content":"Because the <ph id=\"ph1\">`Publication`</ph> class is <ph id=\"ph2\">`abstract`</ph>, it cannot be instantiated directly from code like the following example:","source":"Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:"},{"pos":[18662,18798],"content":"However, its instance constructor can be called directly from derived class constructors, as the source code for the <ph id=\"ph1\">`Book`</ph> class shows.","source":"However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows."},{"content":"Two publication-related properties","pos":[18802,18836]},{"pos":[18840,18958],"content":"<ph id=\"ph1\">`Title`</ph> is a read-only <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> property whose value is supplied by calling the <ph id=\"ph3\">`Publication`</ph> constructor.","source":"`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor."},{"content":"<ph id=\"ph1\">`Pages`</ph> is a read-write <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> property that indicates how many total pages the publication has.","pos":[18962,19071],"source":"`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has."},{"content":"The value is stored in a private field named <ph id=\"ph1\">`totalPages`</ph>.","pos":[19072,19130],"source":" The value is stored in a private field named `totalPages`."},{"content":"It must be a positive number or an <ph id=\"ph1\">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> is thrown.","pos":[19131,19218],"source":" It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown."},{"content":"Publisher-related members","pos":[19222,19247]},{"content":"Two read-only properties, <ph id=\"ph1\">`Publisher`</ph> and <ph id=\"ph2\">`Type`</ph>.","pos":[19251,19300],"source":"Two read-only properties, `Publisher` and `Type`."},{"content":"The values are originally supplied by the call to the <ph id=\"ph1\">`Publication`</ph> class constructor.","pos":[19301,19387],"source":" The values are originally supplied by the call to the `Publication` class constructor."},{"content":"Publishing-related members","pos":[19391,19417]},{"content":"Two methods, <ph id=\"ph1\">`Publish`</ph> and <ph id=\"ph2\">`GetPublicationDate`</ph>, set and return the publication date.","pos":[19421,19506],"source":"Two methods, `Publish` and `GetPublicationDate`, set and return the publication date."},{"content":"The <ph id=\"ph1\">`Publish`</ph> method sets a private  <ph id=\"ph2\">`published`</ph> flag to <ph id=\"ph3\">`true`</ph> when it is called and assigns the date passed to it as an argument to the private <ph id=\"ph4\">`datePublished`</ph> field.","pos":[19507,19675],"source":" The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field."},{"content":"The <ph id=\"ph1\">`GetPublicationDate`</ph> method returns the string \"NYP\" if the <ph id=\"ph2\">`published`</ph> flag is <ph id=\"ph3\">`false`</ph>, and the value of the <ph id=\"ph4\">`datePublished`</ph> field if it is <ph id=\"ph5\">`true`</ph>.","pos":[19676,19828],"source":" The `GetPublicationDate` method returns the string \"NYP\" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`."},{"content":"Copyright-related members","pos":[19832,19857]},{"pos":[19861,20037],"content":"The <ph id=\"ph1\">`Copyright`</ph> method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the <ph id=\"ph2\">`CopyrightName`</ph> and <ph id=\"ph3\">`CopyrightDate`</ph> properties.","source":"The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties."},{"pos":[20041,20077],"content":"An override of the <ph id=\"ph1\">`ToString`</ph> method","source":"An override of the `ToString` method"},{"content":"If a type does not override the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.","pos":[20081,20300],"source":"If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another."},{"content":"The <ph id=\"ph1\">`Publication`</ph> class overrides <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> to return the value of the <ph id=\"ph3\">`Title`</ph> property.","pos":[20301,20441],"source":" The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property."},{"pos":[20443,20587],"content":"The following figure illustrates the relationship between your base <ph id=\"ph1\">`Publication`</ph> class and its implicitly inherited <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> class.","source":"The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class."},{"content":"The Object and Publication classes","pos":[20591,20625]},{"pos":[20661,20677],"content":"The <ph id=\"ph1\">`Book`</ph> class","linkify":"The `Book` class","source":"The `Book` class"},{"content":"The <ph id=\"ph1\">`Book`</ph> class represents a book as a specialized type of publication.","pos":[20679,20751],"source":"The `Book` class represents a book as a specialized type of publication."},{"content":"The following example shows the source code for the <ph id=\"ph1\">`Book`</ph> class.","pos":[20752,20817],"source":" The following example shows the source code for the `Book` class."},{"pos":[20926,21065],"content":"In addition to the members that it inherits from <ph id=\"ph1\">`Publication`</ph>, the <ph id=\"ph2\">`Book`</ph> class defines the following unique members and member overrides:","source":"In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:"},{"content":"Two constructors","pos":[21069,21085]},{"content":"The two <ph id=\"ph1\">`Book`</ph> constructors share three common parameters.","pos":[21089,21147],"source":"The two `Book` constructors share three common parameters."},{"content":"Two, <bpt id=\"p1\">*</bpt>title<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>publisher<ept id=\"p2\">*</ept>, correspond to parameters of the <ph id=\"ph1\">`Publication`</ph> constructor.","pos":[21148,21236],"source":" Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor."},{"content":"The third is <bpt id=\"p1\">*</bpt>author<ept id=\"p1\">*</ept>, which is stored to a public immutable <ph id=\"ph1\">`Author`</ph> property.","pos":[21237,21316],"source":" The third is *author*, which is stored to a public immutable `Author` property."},{"content":"One constructor includes an <bpt id=\"p1\">*</bpt>isbn<ept id=\"p1\">*</ept> parameter, which is stored in the <ph id=\"ph1\">`ISBN`</ph> auto-property.","pos":[21317,21407],"source":" One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property."},{"content":"The first constructor uses the <bpt id=\"p1\">[</bpt>this<ept id=\"p1\">](../language-reference/keywords/this.md)</ept> keyword to call the other constructor.","pos":[21411,21527],"source":"The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor."},{"content":"Constructor chaining is a common pattern in defining constructors.","pos":[21528,21594]},{"content":"Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.","pos":[21595,21721]},{"content":"The second constructor uses the <bpt id=\"p1\">[</bpt>base<ept id=\"p1\">](../language-reference/keywords/base.md)</ept> keyword to pass the title and publisher name to the base class constructor.","pos":[21725,21879],"source":"The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor."},{"content":"If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.","pos":[21880,22066]},{"content":"A read-only <ph id=\"ph1\">`ISBN`</ph> property, which returns the <ph id=\"ph2\">`Book`</ph> object's International Standard Book Number, a unique 10- or 13-digit number.","pos":[22070,22201],"source":"A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number."},{"content":"The ISBN is supplied as an argument to one of the <ph id=\"ph1\">`Book`</ph> constructors.","pos":[22202,22272],"source":" The ISBN is supplied as an argument to one of the `Book` constructors."},{"content":"The ISBN is stored in a private backing field, which is auto-generated by the compiler.","pos":[22273,22360]},{"content":"A read-only <ph id=\"ph1\">`Author`</ph> property.","pos":[22364,22394],"source":"A read-only `Author` property."},{"content":"The author name is supplied as an argument to both <ph id=\"ph1\">`Book`</ph> constructors and is stored in the property.","pos":[22395,22496],"source":" The author name is supplied as an argument to both `Book` constructors and is stored in the property."},{"content":"Two read-only price-related properties, <ph id=\"ph1\">`Price`</ph> and <ph id=\"ph2\">`Currency`</ph>.","pos":[22500,22563],"source":"Two read-only price-related properties, `Price` and `Currency`."},{"content":"Their values are provided as arguments in a <ph id=\"ph1\">`SetPrice`</ph> method call.","pos":[22564,22631],"source":" Their values are provided as arguments in a `SetPrice` method call."},{"content":"The <ph id=\"ph1\">`Currency`</ph> property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).","pos":[22632,22734],"source":" The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar)."},{"content":"ISO currency symbols can be retrieved from the <ph id=\"ph1\">&lt;xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A&gt;</ph> property.","pos":[22735,22851],"source":" ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property."},{"content":"Both of these properties are externally read-only, but both can be set by code in the <ph id=\"ph1\">`Book`</ph> class.","pos":[22852,22951],"source":" Both of these properties are externally read-only, but both can be set by code in the `Book` class."},{"content":"A <ph id=\"ph1\">`SetPrice`</ph> method, which sets the values of the <ph id=\"ph2\">`Price`</ph> and <ph id=\"ph3\">`Currency`</ph> properties.","pos":[22955,23039],"source":"A `SetPrice` method, which sets the values of the `Price` and `Currency` properties."},{"content":"Those values are returned by those same properties.","pos":[23040,23091]},{"pos":[23095,23331],"content":"Overrides to the <ph id=\"ph1\">`ToString`</ph> method (inherited from <ph id=\"ph2\">`Publication`</ph>) and the <ph id=\"ph3\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods (inherited from <ph id=\"ph5\">&lt;xref:System.Object&gt;</ph>).","source":"Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>)."},{"content":"Unless it is overridden, the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method tests for reference equality.","pos":[23335,23476],"source":"Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality."},{"content":"That is, two object variables are considered to be equal if they refer to the same object.","pos":[23477,23567]},{"content":"In the <ph id=\"ph1\">`Book`</ph> class, on the other hand, two <ph id=\"ph2\">`Book`</ph> objects should be equal if they have the same ISBN.","pos":[23568,23670],"source":" In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN."},{"content":"When you override the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, you must also override the <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.","pos":[23674,23956],"source":"When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval."},{"content":"The hash code should return a value that's consistent with the test for equality.","pos":[23957,24038]},{"content":"Since you've overridden <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to return <ph id=\"ph2\">`true`</ph> if the ISBN properties of two <ph id=\"ph3\">`Book`</ph> objects are equal, you return the hash code computed by calling the <ph id=\"ph4\">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method of the string returned by the <ph id=\"ph5\">`ISBN`</ph> property.","pos":[24039,24350],"source":" Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property."},{"pos":[24352,24461],"content":"The following figure illustrates the relationship between the <ph id=\"ph1\">`Book`</ph> class and <ph id=\"ph2\">`Publication`</ph>, its base class.","source":"The following figure illustrates the relationship between the `Book` class and `Publication`, its base class."},{"content":"Publication and Book classes","pos":[24465,24493]},{"pos":[24518,24741],"content":"You can now instantiate a <ph id=\"ph1\">`Book`</ph> object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type <ph id=\"ph2\">`Publication`</ph> or of type <ph id=\"ph3\">`Book`</ph>, as the following example shows.","source":"You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows."},{"pos":[24852,24909],"content":"Designing abstract base classes and their derived classes","linkify":"Designing abstract base classes and their derived classes","nodes":[{"content":"Designing abstract base classes and their derived classes","pos":[0,57]}]},{"content":"In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.","pos":[24935,25080]},{"content":"In many cases, however, the base class is not expected to provide an implementation.","pos":[25081,25165]},{"content":"Instead, the base class is an <bpt id=\"p1\">*</bpt>abstract class<ept id=\"p1\">*</ept> that declares <bpt id=\"p2\">*</bpt>abstract methods<ept id=\"p2\">*</ept>; it serves as a template that defines the members that each derived class must implement.","pos":[25166,25335],"source":" Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement."},{"content":"Typically in an abstract base class, the implementation of each derived type is unique to that type.","pos":[25336,25436]},{"content":"You marked the class with the abstract keyword because it made no sense to instantiate a <ph id=\"ph1\">`Publication`</ph> object, although the class did provide implementations of functionality common to publications.","pos":[25437,25635],"source":" You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications."},{"content":"For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.","pos":[25637,25816]},{"content":"The way in which these properties are calculated, however, depends completely on the specific shape.","pos":[25817,25917]},{"content":"The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.","pos":[25918,26042]},{"content":"The <ph id=\"ph1\">`Shape`</ph> class is an <ph id=\"ph2\">`abstract`</ph> class with <ph id=\"ph3\">`abstract`</ph> methods.","pos":[26043,26108],"source":" The `Shape` class is an `abstract` class with `abstract` methods."},{"content":"That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.","pos":[26109,26237]},{"content":"The following example defines an abstract base class named <ph id=\"ph1\">`Shape`</ph> that defines two properties: <ph id=\"ph2\">`Area`</ph> and <ph id=\"ph3\">`Perimeter`</ph>.","pos":[26239,26358],"source":"The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`."},{"content":"In addition to marking the class with the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../language-reference/keywords/abstract.md)</ept> keyword, each instance member is also marked with the <bpt id=\"p2\">[</bpt>abstract<ept id=\"p2\">](../language-reference/keywords/abstract.md)</ept> keyword.","pos":[26359,26573],"source":" In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword."},{"content":"In this case, <ph id=\"ph1\">`Shape`</ph> also overrides the <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return the name of the type, rather than its fully qualified name.","pos":[26574,26753],"source":" In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name."},{"content":"And it defines two static members, <ph id=\"ph1\">`GetArea`</ph> and <ph id=\"ph2\">`GetPerimeter`</ph>, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.","pos":[26754,26916],"source":" And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class."},{"content":"When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.","pos":[26917,27049]},{"content":"You can then derive some classes from <ph id=\"ph1\">`Shape`</ph> that represent specific shapes.","pos":[27147,27224],"source":"You can then derive some classes from `Shape` that represent specific shapes."},{"content":"The following example defines three classes, <ph id=\"ph1\">`Triangle`</ph>, <ph id=\"ph2\">`Rectangle`</ph>, and <ph id=\"ph3\">`Circle`</ph>.","pos":[27225,27308],"source":" The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`."},{"content":"Each uses a formula unique for that particular shape to compute the area and perimeter.","pos":[27309,27396]},{"content":"Some of the derived classes also define properties, such as <ph id=\"ph1\">`Rectangle.Diagonal`</ph> and <ph id=\"ph2\">`Circle.Diameter`</ph>, that are unique to the shape that they represent.","pos":[27397,27550],"source":" Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent."},{"content":"The following example uses objects derived from <ph id=\"ph1\">`Shape`</ph>.","pos":[27648,27704],"source":"The following example uses objects derived from `Shape`."},{"content":"It instantiates an array of objects derived from <ph id=\"ph1\">`Shape`</ph> and calls the static methods of the <ph id=\"ph2\">`Shape`</ph> class, which wraps return <ph id=\"ph3\">`Shape`</ph> property values.","pos":[27705,27856],"source":" It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values."},{"content":"The runtime retrieves values from the overridden properties of the derived types.","pos":[27857,27938]},{"content":"The example also casts each <ph id=\"ph1\">`Shape`</ph> object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of <ph id=\"ph2\">`Shape`</ph>.","pos":[27939,28102],"source":" The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`."},{"pos":[28204,28212],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[28216,28279],"content":"<bpt id=\"p1\">[</bpt>Classes and objects<ept id=\"p1\">](../tour-of-csharp/classes-and-objects.md)</ept>","source":"[Classes and objects](../tour-of-csharp/classes-and-objects.md)"},{"pos":[28282,28375],"content":"<bpt id=\"p1\">[</bpt>Inheritance (C# Programming Guide)<ept id=\"p1\">](../programming-guide/classes-and-structs/inheritance.md)</ept>","source":"[Inheritance (C# Programming Guide)](../programming-guide/classes-and-structs/inheritance.md)"}]}