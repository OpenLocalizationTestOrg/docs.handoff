{"content":"---\ntitle: \"Iterators (C#) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: c93f6dd4-e72a-4a06-be1c-a98b3255b734\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Iterators (C#)\nAn *iterator* can be used to step through collections such as lists and arrays.  \n  \n An iterator method or `get` accessor performs a custom iteration over a collection. An iterator method uses the [yield return](../../../csharp/language-reference/keywords/yield.md) statement to return each element one at a time. When a `yield return` statement is reached, the current location in code is remembered. Execution is restarted from that location the next time the iterator function is called.  \n  \n You consume an iterator from client code by using a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statement or by using a LINQ query.  \n  \n In the following example, the first iteration of the `foreach` loop causes execution to proceed  in the `SomeNumbers` iterator method until the first `yield return` statement is reached. This iteration returns a value of 3, and the current location in the iterator method is retained. On the next iteration of the loop, execution in the iterator method continues from where it left off, again stopping when it reaches a `yield return` statement. This iteration returns a value of 5, and the current location in the iterator method is again retained. The loop completes when the end of the iterator method is reached.  \n  \n```csharp  \nstatic void Main()  \n{  \n    foreach (int number in SomeNumbers())  \n    {  \n        Console.Write(number.ToString() + \" \");  \n    }  \n    // Output: 3 5 8  \n    Console.ReadKey();  \n}  \n  \npublic static System.Collections.IEnumerable SomeNumbers()  \n{  \n    yield return 3;  \n    yield return 5;  \n    yield return 8;  \n}  \n```  \n  \n The return type of an iterator method or `get` accessor can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.  \n  \n You can use a`yield break` statement to end the iteration.  \n  \n Iterators were introduced in C# in Visual Studio 2005.  \n  \n **In this topic**  \n  \n-   [Simple Iterator](#BKMK_SimpleIterator)  \n  \n-   [Creating a Collection Class](#BKMK_CollectionClass)  \n  \n-   [Using Iterators with a Generic List](#BKMK_GenericList)  \n  \n-   [Syntax Information](#BKMK_SyntaxInformation)  \n  \n-   [Technical Implementation](#BKMK_Technical)  \n  \n-   [Use of Iterators](#BKMK_UseOfIterators)  \n  \n> [!NOTE]\n>  For all examples in this topic except the Simple Iterator example, include [using](../../../csharp/language-reference/keywords/using-directive.md) directives for the `System.Collections` and `System.Collections.Generic` namespaces.  \n  \n##  <a name=\"BKMK_SimpleIterator\"></a> Simple Iterator  \n The following example has a single `yield return` statement that is inside a [for](../../../csharp/language-reference/keywords/for.md) loop. In `Main`, each iteration of the `foreach` statement body creates a call to the iterator function, which proceeds to the next `yield return` statement.  \n  \n```csharp  \nstatic void Main()  \n{  \n    foreach (int number in EvenSequence(5, 18))  \n    {  \n        Console.Write(number.ToString() + \" \");  \n    }  \n    // Output: 6 8 10 12 14 16 18  \n    Console.ReadKey();  \n}  \n  \npublic static System.Collections.Generic.IEnumerable<int>  \n    EvenSequence(int firstNumber, int lastNumber)  \n{  \n    // Yield even numbers in the range.  \n    for (int number = firstNumber; number <= lastNumber; number++)  \n    {  \n        if (number % 2 == 0)  \n        {  \n            yield return number;  \n        }  \n    }  \n}  \n```  \n  \n##  <a name=\"BKMK_CollectionClass\"></a> Creating a Collection Class  \n In the following example, the `DaysOfTheWeek` class implements the <xref:System.Collections.IEnumerable> interface, which requires a <xref:System.Collections.IEnumerable.GetEnumerator%2A> method. The compiler implicitly calls the `GetEnumerator` method, which returns an <xref:System.Collections.IEnumerator>.  \n  \n The `GetEnumerator` method returns each string one at a time by using the `yield return` statement.  \n  \n```csharp  \nstatic void Main()  \n{  \n    DaysOfTheWeek days = new DaysOfTheWeek();  \n  \n    foreach (string day in days)  \n    {  \n        Console.Write(day + \" \");  \n    }  \n    // Output: Sun Mon Tue Wed Thu Fri Sat  \n    Console.ReadKey();  \n}  \n  \npublic class DaysOfTheWeek : IEnumerable  \n{  \n    private string[] days = { \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" };  \n  \n    public IEnumerator GetEnumerator()  \n    {  \n        for (int index = 0; index < days.Length; index++)  \n        {  \n            // Yield each day of the week.  \n            yield return days[index];  \n        }  \n    }  \n}  \n```  \n  \n The following example creates a `Zoo` class that contains a collection of animals.  \n  \n The `foreach` statement that refers to the class instance (`theZoo`) implicitly calls the `GetEnumerator` method. The `foreach` statements that refer to the `Birds` and `Mammals` properties use the `AnimalsForType` named iterator method.  \n  \n```csharp  \nstatic void Main()  \n{  \n    Zoo theZoo = new Zoo();  \n  \n    theZoo.AddMammal(\"Whale\");  \n    theZoo.AddMammal(\"Rhinoceros\");  \n    theZoo.AddBird(\"Penguin\");  \n    theZoo.AddBird(\"Warbler\");  \n  \n    foreach (string name in theZoo)  \n    {  \n        Console.Write(name + \" \");  \n    }  \n    Console.WriteLine();  \n    // Output: Whale Rhinoceros Penguin Warbler  \n  \n    foreach (string name in theZoo.Birds)  \n    {  \n        Console.Write(name + \" \");  \n    }  \n    Console.WriteLine();  \n    // Output: Penguin Warbler  \n  \n    foreach (string name in theZoo.Mammals)  \n    {  \n        Console.Write(name + \" \");  \n    }  \n    Console.WriteLine();  \n    // Output: Whale Rhinoceros  \n  \n    Console.ReadKey();  \n}  \n  \npublic class Zoo : IEnumerable  \n{  \n    // Private members.  \n    private List<Animal> animals = new List<Animal>();  \n  \n    // Public methods.  \n    public void AddMammal(string name)  \n    {  \n        animals.Add(new Animal { Name = name, Type = Animal.TypeEnum.Mammal });  \n    }  \n  \n    public void AddBird(string name)  \n    {  \n        animals.Add(new Animal { Name = name, Type = Animal.TypeEnum.Bird });  \n    }  \n  \n    public IEnumerator GetEnumerator()  \n    {  \n        foreach (Animal theAnimal in animals)  \n        {  \n            yield return theAnimal.Name;  \n        }  \n    }  \n  \n    // Public members.  \n    public IEnumerable Mammals  \n    {  \n        get { return AnimalsForType(Animal.TypeEnum.Mammal); }  \n    }  \n  \n    public IEnumerable Birds  \n    {  \n        get { return AnimalsForType(Animal.TypeEnum.Bird); }  \n    }  \n  \n    // Private methods.  \n    private IEnumerable AnimalsForType(Animal.TypeEnum type)  \n    {  \n        foreach (Animal theAnimal in animals)  \n        {  \n            if (theAnimal.Type == type)  \n            {  \n                yield return theAnimal.Name;  \n            }  \n        }  \n    }  \n  \n    // Private class.  \n    private class Animal  \n    {  \n        public enum TypeEnum { Bird, Mammal }  \n  \n        public string Name { get; set; }  \n        public TypeEnum Type { get; set; }  \n    }  \n}  \n```  \n  \n##  <a name=\"BKMK_GenericList\"></a> Using Iterators with a Generic List  \n In the following example, the `Stack(Of T)` generic class implements the <xref:System.Collections.Generic.IEnumerable%601> generic interface. The `Push` method assigns values to an array of type `T`. The <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method returns the array values by using the `yield return` statement.  \n  \n In addition to the generic <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method, the non-generic <xref:System.Collections.IEnumerable.GetEnumerator%2A> method must also be implemented. This is because <xref:System.Collections.Generic.IEnumerable%601> inherits from <xref:System.Collections.IEnumerable>. The non-generic implementation defers to the generic implementation.  \n  \n The example uses named iterators to support various ways of iterating through the same collection of data. These named iterators are the `TopToBottom` and `BottomToTop` properties, and the `TopN` method.  \n  \n The `BottomToTop` property uses an iterator in a `get` accessor.  \n  \n```csharp  \nstatic void Main()  \n{  \n    Stack<int> theStack = new Stack<int>();  \n  \n    //  Add items to the stack.  \n    for (int number = 0; number <= 9; number++)  \n    {  \n        theStack.Push(number);  \n    }  \n  \n    // Retrieve items from the stack.  \n    // foreach is allowed because theStack implements  \n    // IEnumerable<int>.  \n    foreach (int number in theStack)  \n    {  \n        Console.Write(\"{0} \", number);  \n    }  \n    Console.WriteLine();  \n    // Output: 9 8 7 6 5 4 3 2 1 0  \n  \n    // foreach is allowed, because theStack.TopToBottom  \n    // returns IEnumerable(Of Integer).  \n    foreach (int number in theStack.TopToBottom)  \n    {  \n        Console.Write(\"{0} \", number);  \n    }  \n    Console.WriteLine();  \n    // Output: 9 8 7 6 5 4 3 2 1 0  \n  \n    foreach (int number in theStack.BottomToTop)  \n    {  \n        Console.Write(\"{0} \", number);  \n    }  \n    Console.WriteLine();  \n    // Output: 0 1 2 3 4 5 6 7 8 9  \n  \n    foreach (int number in theStack.TopN(7))  \n    {  \n        Console.Write(\"{0} \", number);  \n    }  \n    Console.WriteLine();  \n    // Output: 9 8 7 6 5 4 3  \n  \n    Console.ReadKey();  \n}  \n  \npublic class Stack<T> : IEnumerable<T>  \n{  \n    private T[] values = new T[100];  \n    private int top = 0;  \n  \n    public void Push(T t)  \n    {  \n        values[top] = t;  \n        top++;  \n    }  \n    public T Pop()  \n    {  \n        top--;  \n        return values[top];  \n    }  \n  \n    // This method implements the GetEnumerator method. It allows  \n    // an instance of the class to be used in a foreach statement.  \n    public IEnumerator<T> GetEnumerator()  \n    {  \n        for (int index = top - 1; index >= 0; index--)  \n        {  \n            yield return values[index];  \n        }  \n    }  \n  \n    IEnumerator IEnumerable.GetEnumerator()  \n    {  \n        return GetEnumerator();  \n    }  \n  \n    public IEnumerable<T> TopToBottom  \n    {  \n        get { return this; }  \n    }  \n  \n    public IEnumerable<T> BottomToTop  \n    {  \n        get  \n        {  \n            for (int index = 0; index <= top - 1; index++)  \n            {  \n                yield return values[index];  \n            }  \n        }  \n    }  \n  \n    public IEnumerable<T> TopN(int itemsFromTop)  \n    {  \n        // Return less than itemsFromTop if necessary.  \n        int startIndex = itemsFromTop >= top ? 0 : top - itemsFromTop;  \n  \n        for (int index = top - 1; index >= startIndex; index--)  \n        {  \n            yield return values[index];  \n        }  \n    }  \n  \n}  \n```  \n  \n##  <a name=\"BKMK_SyntaxInformation\"></a> Syntax Information  \n An iterator can occur as a method or `get` accessor. An iterator cannot occur in an event, instance constructor, static constructor, or static finalizer.  \n  \n An implicit conversion must exist from the expression type in the `yield return` statement to the return type of the iterator.  \n  \n In C#, an iterator method cannot have any `ref` or `out` parameters.  \n  \n In C#, \"yield\" is not a reserved word and has special meaning only when it is used before a `return` or `break` keyword.  \n  \n##  <a name=\"BKMK_Technical\"></a> Technical Implementation  \n Although you write an iterator as a method, the compiler translates it into a nested class that is, in effect, a state machine. This class keeps track of the position of the iterator as long the `foreach` loop in the client code continues.  \n  \n To see what the compiler does, you can use the Ildasm.exe tool to view the Microsoft intermediate language code that is generated for an iterator method.  \n  \n When you create an iterator for a [class](../../../csharp/language-reference/keywords/class.md) or [struct](../../../csharp/language-reference/keywords/struct.md), you don't have to implement the whole <xref:System.Collections.IEnumerator> interface. When the compiler detects the iterator, it automatically generates the `Current`, `MoveNext`, and `Dispose` methods of the <xref:System.Collections.IEnumerator> or <xref:System.Collections.Generic.IEnumerator%601> interface.  \n  \n On each successive iteration of the `foreach` loop (or the direct call to `IEnumerator.MoveNext`), the next iterator code body resumes after the previous `yield return` statement. It then continues to the next `yield return` statement until the end of the iterator body is reached, or until a `yield break` statement is encountered.  \n  \n Iterators don't support the <xref:System.Collections.IEnumerator.Reset%2A?displayProperty=fullName> method. To re-iterate from the start, you must obtain a new iterator.  \n  \n For additional information, see the [C# Language Specification](../../../csharp/language-reference/language-specification.md).  \n  \n##  <a name=\"BKMK_UseOfIterators\"></a> Use of Iterators  \n Iterators enable you to maintain the simplicity of a `foreach` loop when you need to use complex code to populate a list sequence. This can be useful when you want to do the following:  \n  \n-   Modify the list sequence after the first `foreach` loop iteration.  \n  \n-   Avoid fully loading a large list before the first iteration of a `foreach` loop. An example is a paged fetch to load a batch of table rows. Another example is the <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> method, which implements iterators within the .NET Framework.  \n  \n-   Encapsulate building the list in the iterator. In the iterator method, you can build the list and then yield each result in a loop.  \n  \n## See Also  \n <xref:System.Collections.Generic>   \n <xref:System.Collections.Generic.IEnumerable%601>   \n [foreach, in](../../../csharp/language-reference/keywords/foreach-in.md)   \n [yield](../../../csharp/language-reference/keywords/yield.md)   \n [Using foreach with Arrays](../../../csharp/programming-guide/arrays/using-foreach-with-arrays.md)   \n [Generics](../../../csharp/programming-guide/generics/index.md)","nodes":[{"pos":[12,43],"content":"Iterators (C#) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Iterators (C#) | Microsoft Docs","pos":[0,31]}]},{"pos":[362,376],"content":"Iterators (C#)","linkify":"Iterators (C#)","nodes":[{"content":"Iterators (C#)","pos":[0,14]}]},{"pos":[377,456],"content":"An <bpt id=\"p1\">*</bpt>iterator<ept id=\"p1\">*</ept> can be used to step through collections such as lists and arrays.","source":"An *iterator* can be used to step through collections such as lists and arrays."},{"content":"An iterator method or <ph id=\"ph1\">`get`</ph> accessor performs a custom iteration over a collection.","pos":[463,546],"source":"An iterator method or `get` accessor performs a custom iteration over a collection."},{"content":"An iterator method uses the <bpt id=\"p1\">[</bpt>yield return<ept id=\"p1\">](../../../csharp/language-reference/keywords/yield.md)</ept> statement to return each element one at a time.","pos":[547,691],"source":" An iterator method uses the [yield return](../../../csharp/language-reference/keywords/yield.md) statement to return each element one at a time."},{"content":"When a <ph id=\"ph1\">`yield return`</ph> statement is reached, the current location in code is remembered.","pos":[692,779],"source":" When a `yield return` statement is reached, the current location in code is remembered."},{"content":"Execution is restarted from that location the next time the iterator function is called.","pos":[780,868]},{"pos":[875,1031],"content":"You consume an iterator from client code by using a <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](../../../csharp/language-reference/keywords/foreach-in.md)</ept> statement or by using a LINQ query.","source":"You consume an iterator from client code by using a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statement or by using a LINQ query."},{"content":"In the following example, the first iteration of the <ph id=\"ph1\">`foreach`</ph> loop causes execution to proceed  in the <ph id=\"ph2\">`SomeNumbers`</ph> iterator method until the first <ph id=\"ph3\">`yield return`</ph> statement is reached.","pos":[1038,1224],"source":"In the following example, the first iteration of the `foreach` loop causes execution to proceed  in the `SomeNumbers` iterator method until the first `yield return` statement is reached."},{"content":"This iteration returns a value of 3, and the current location in the iterator method is retained.","pos":[1225,1322]},{"content":"On the next iteration of the loop, execution in the iterator method continues from where it left off, again stopping when it reaches a <ph id=\"ph1\">`yield return`</ph> statement.","pos":[1323,1483],"source":" On the next iteration of the loop, execution in the iterator method continues from where it left off, again stopping when it reaches a `yield return` statement."},{"content":"This iteration returns a value of 5, and the current location in the iterator method is again retained.","pos":[1484,1587]},{"content":"The loop completes when the end of the iterator method is reached.","pos":[1588,1654]},{"pos":[2007,2252],"content":"The return type of an iterator method or <ph id=\"ph1\">`get`</ph> accessor can be <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Collections.IEnumerator&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph>.","source":"The return type of an iterator method or `get` accessor can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>."},{"pos":[2259,2317],"content":"You can use a<ph id=\"ph1\">`yield break`</ph> statement to end the iteration.","source":"You can use a`yield break` statement to end the iteration."},{"content":"Iterators were introduced in C# in Visual Studio 2005.","pos":[2324,2378]},{"pos":[2385,2402],"content":"<bpt id=\"p1\">**</bpt>In this topic<ept id=\"p1\">**</ept>","source":"**In this topic**"},{"pos":[2412,2451],"content":"<bpt id=\"p1\">[</bpt>Simple Iterator<ept id=\"p1\">](#BKMK_SimpleIterator)</ept>","source":"[Simple Iterator](#BKMK_SimpleIterator)"},{"pos":[2461,2513],"content":"<bpt id=\"p1\">[</bpt>Creating a Collection Class<ept id=\"p1\">](#BKMK_CollectionClass)</ept>","source":"[Creating a Collection Class](#BKMK_CollectionClass)"},{"pos":[2523,2579],"content":"<bpt id=\"p1\">[</bpt>Using Iterators with a Generic List<ept id=\"p1\">](#BKMK_GenericList)</ept>","source":"[Using Iterators with a Generic List](#BKMK_GenericList)"},{"pos":[2589,2634],"content":"<bpt id=\"p1\">[</bpt>Syntax Information<ept id=\"p1\">](#BKMK_SyntaxInformation)</ept>","source":"[Syntax Information](#BKMK_SyntaxInformation)"},{"pos":[2644,2687],"content":"<bpt id=\"p1\">[</bpt>Technical Implementation<ept id=\"p1\">](#BKMK_Technical)</ept>","source":"[Technical Implementation](#BKMK_Technical)"},{"pos":[2697,2737],"content":"<bpt id=\"p1\">[</bpt>Use of Iterators<ept id=\"p1\">](#BKMK_UseOfIterators)</ept>","source":"[Use of Iterators](#BKMK_UseOfIterators)"},{"pos":[2745,2987],"content":"[!NOTE]\n For all examples in this topic except the Simple Iterator example, include [using](../../../csharp/language-reference/keywords/using-directive.md) directives for the `System.Collections` and `System.Collections.Generic` namespaces.","leadings":["","> "],"nodes":[{"content":"For all examples in this topic except the Simple Iterator example, include <bpt id=\"p1\">[</bpt>using<ept id=\"p1\">](../../../csharp/language-reference/keywords/using-directive.md)</ept> directives for the <ph id=\"ph1\">`System.Collections`</ph> and <ph id=\"ph2\">`System.Collections.Generic`</ph> namespaces.","pos":[9,240],"source":" For all examples in this topic except the Simple Iterator example, include [using](../../../csharp/language-reference/keywords/using-directive.md) directives for the `System.Collections` and `System.Collections.Generic` namespaces."}]},{"pos":[2997,3047],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_SimpleIterator\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Simple Iterator","linkify":"<a name=\"BKMK_SimpleIterator\"></a> Simple Iterator","source":"<a name=\"BKMK_SimpleIterator\"></a> Simple Iterator"},{"content":"The following example has a single <ph id=\"ph1\">`yield return`</ph> statement that is inside a <bpt id=\"p1\">[</bpt>for<ept id=\"p1\">](../../../csharp/language-reference/keywords/for.md)</ept> loop.","pos":[3051,3191],"source":"The following example has a single `yield return` statement that is inside a [for](../../../csharp/language-reference/keywords/for.md) loop."},{"content":"In <ph id=\"ph1\">`Main`</ph>, each iteration of the <ph id=\"ph2\">`foreach`</ph> statement body creates a call to the iterator function, which proceeds to the next <ph id=\"ph3\">`yield return`</ph> statement.","pos":[3192,3343],"source":" In `Main`, each iteration of the `foreach` statement body creates a call to the iterator function, which proceeds to the next `yield return` statement."},{"pos":[3920,3983],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_CollectionClass\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Creating a Collection Class","linkify":"<a name=\"BKMK_CollectionClass\"></a> Creating a Collection Class","source":"<a name=\"BKMK_CollectionClass\"></a> Creating a Collection Class"},{"content":"In the following example, the <ph id=\"ph1\">`DaysOfTheWeek`</ph> class implements the <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface, which requires a <ph id=\"ph3\">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A&gt;</ph> method.","pos":[3987,4182],"source":"In the following example, the `DaysOfTheWeek` class implements the <xref:System.Collections.IEnumerable> interface, which requires a <xref:System.Collections.IEnumerable.GetEnumerator%2A> method."},{"content":"The compiler implicitly calls the <ph id=\"ph1\">`GetEnumerator`</ph> method, which returns an <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerator&gt;</ph>.","pos":[4183,4296],"source":" The compiler implicitly calls the `GetEnumerator` method, which returns an <xref:System.Collections.IEnumerator>."},{"pos":[4303,4402],"content":"The <ph id=\"ph1\">`GetEnumerator`</ph> method returns each string one at a time by using the <ph id=\"ph2\">`yield return`</ph> statement.","source":"The `GetEnumerator` method returns each string one at a time by using the `yield return` statement."},{"pos":[5033,5115],"content":"The following example creates a <ph id=\"ph1\">`Zoo`</ph> class that contains a collection of animals.","source":"The following example creates a `Zoo` class that contains a collection of animals."},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement that refers to the class instance (<ph id=\"ph2\">`theZoo`</ph>) implicitly calls the <ph id=\"ph3\">`GetEnumerator`</ph> method.","pos":[5122,5235],"source":"The `foreach` statement that refers to the class instance (`theZoo`) implicitly calls the `GetEnumerator` method."},{"content":"The <ph id=\"ph1\">`foreach`</ph> statements that refer to the <ph id=\"ph2\">`Birds`</ph> and <ph id=\"ph3\">`Mammals`</ph> properties use the <ph id=\"ph4\">`AnimalsForType`</ph> named iterator method.","pos":[5236,5359],"source":" The `foreach` statements that refer to the `Birds` and `Mammals` properties use the `AnimalsForType` named iterator method."},{"pos":[7483,7550],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_GenericList\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Using Iterators with a Generic List","linkify":"<a name=\"BKMK_GenericList\"></a> Using Iterators with a Generic List","source":"<a name=\"BKMK_GenericList\"></a> Using Iterators with a Generic List"},{"content":"In the following example, the <ph id=\"ph1\">`Stack(Of T)`</ph> generic class implements the <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> generic interface.","pos":[7554,7695],"source":"In the following example, the `Stack(Of T)` generic class implements the <xref:System.Collections.Generic.IEnumerable%601> generic interface."},{"content":"The <ph id=\"ph1\">`Push`</ph> method assigns values to an array of type <ph id=\"ph2\">`T`</ph>.","pos":[7696,7753],"source":" The `Push` method assigns values to an array of type `T`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method returns the array values by using the <ph id=\"ph2\">`yield return`</ph> statement.","pos":[7754,7895],"source":" The <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method returns the array values by using the `yield return` statement."},{"content":"In addition to the generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method, the non-generic <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A&gt;</ph> method must also be implemented.","pos":[7902,8107],"source":"In addition to the generic <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method, the non-generic <xref:System.Collections.IEnumerable.GetEnumerator%2A> method must also be implemented."},{"content":"This is because <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> inherits from <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable&gt;</ph>.","pos":[8108,8226],"source":" This is because <xref:System.Collections.Generic.IEnumerable%601> inherits from <xref:System.Collections.IEnumerable>."},{"content":"The non-generic implementation defers to the generic implementation.","pos":[8227,8295]},{"content":"The example uses named iterators to support various ways of iterating through the same collection of data.","pos":[8302,8408]},{"content":"These named iterators are the <ph id=\"ph1\">`TopToBottom`</ph> and <ph id=\"ph2\">`BottomToTop`</ph> properties, and the <ph id=\"ph3\">`TopN`</ph> method.","pos":[8409,8505],"source":" These named iterators are the `TopToBottom` and `BottomToTop` properties, and the `TopN` method."},{"pos":[8512,8576],"content":"The <ph id=\"ph1\">`BottomToTop`</ph> property uses an iterator in a <ph id=\"ph2\">`get`</ph> accessor.","source":"The `BottomToTop` property uses an iterator in a `get` accessor."},{"pos":[11126,11182],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_SyntaxInformation\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Syntax Information","linkify":"<a name=\"BKMK_SyntaxInformation\"></a> Syntax Information","source":"<a name=\"BKMK_SyntaxInformation\"></a> Syntax Information"},{"content":"An iterator can occur as a method or <ph id=\"ph1\">`get`</ph> accessor.","pos":[11186,11238],"source":"An iterator can occur as a method or `get` accessor."},{"content":"An iterator cannot occur in an event, instance constructor, static constructor, or static finalizer.","pos":[11239,11339]},{"pos":[11346,11472],"content":"An implicit conversion must exist from the expression type in the <ph id=\"ph1\">`yield return`</ph> statement to the return type of the iterator.","source":"An implicit conversion must exist from the expression type in the `yield return` statement to the return type of the iterator."},{"pos":[11479,11547],"content":"In C#, an iterator method cannot have any <ph id=\"ph1\">`ref`</ph> or <ph id=\"ph2\">`out`</ph> parameters.","source":"In C#, an iterator method cannot have any `ref` or `out` parameters."},{"pos":[11554,11674],"content":"In C#, \"yield\" is not a reserved word and has special meaning only when it is used before a <ph id=\"ph1\">`return`</ph> or <ph id=\"ph2\">`break`</ph> keyword.","source":"In C#, \"yield\" is not a reserved word and has special meaning only when it is used before a `return` or `break` keyword."},{"pos":[11684,11738],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_Technical\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Technical Implementation","linkify":"<a name=\"BKMK_Technical\"></a> Technical Implementation","source":"<a name=\"BKMK_Technical\"></a> Technical Implementation"},{"content":"Although you write an iterator as a method, the compiler translates it into a nested class that is, in effect, a state machine.","pos":[11742,11869]},{"content":"This class keeps track of the position of the iterator as long the <ph id=\"ph1\">`foreach`</ph> loop in the client code continues.","pos":[11870,11981],"source":" This class keeps track of the position of the iterator as long the `foreach` loop in the client code continues."},{"content":"To see what the compiler does, you can use the Ildasm.exe tool to view the Microsoft intermediate language code that is generated for an iterator method.","pos":[11988,12141]},{"content":"When you create an iterator for a <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../../../csharp/language-reference/keywords/class.md)</ept> or <bpt id=\"p2\">[</bpt>struct<ept id=\"p2\">](../../../csharp/language-reference/keywords/struct.md)</ept>, you don't have to implement the whole <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerator&gt;</ph> interface.","pos":[12148,12398],"source":"When you create an iterator for a [class](../../../csharp/language-reference/keywords/class.md) or [struct](../../../csharp/language-reference/keywords/struct.md), you don't have to implement the whole <xref:System.Collections.IEnumerator> interface."},{"content":"When the compiler detects the iterator, it automatically generates the <ph id=\"ph1\">`Current`</ph>, <ph id=\"ph2\">`MoveNext`</ph>, and <ph id=\"ph3\">`Dispose`</ph> methods of the <ph id=\"ph4\">&lt;xref:System.Collections.IEnumerator&gt;</ph> or <ph id=\"ph5\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph> interface.","pos":[12399,12623],"source":" When the compiler detects the iterator, it automatically generates the `Current`, `MoveNext`, and `Dispose` methods of the <xref:System.Collections.IEnumerator> or <xref:System.Collections.Generic.IEnumerator%601> interface."},{"content":"On each successive iteration of the <ph id=\"ph1\">`foreach`</ph> loop (or the direct call to <ph id=\"ph2\">`IEnumerator.MoveNext`</ph>), the next iterator code body resumes after the previous <ph id=\"ph3\">`yield return`</ph> statement.","pos":[12630,12809],"source":"On each successive iteration of the `foreach` loop (or the direct call to `IEnumerator.MoveNext`), the next iterator code body resumes after the previous `yield return` statement."},{"content":"It then continues to the next <ph id=\"ph1\">`yield return`</ph> statement until the end of the iterator body is reached, or until a <ph id=\"ph2\">`yield break`</ph> statement is encountered.","pos":[12810,12962],"source":" It then continues to the next `yield return` statement until the end of the iterator body is reached, or until a `yield break` statement is encountered."},{"content":"Iterators don't support the <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerator.Reset%2A?displayProperty=fullName&gt;</ph> method.","pos":[12969,13076],"source":"Iterators don't support the <xref:System.Collections.IEnumerator.Reset%2A?displayProperty=fullName> method."},{"content":"To re-iterate from the start, you must obtain a new iterator.","pos":[13077,13138]},{"pos":[13145,13271],"content":"For additional information, see the <bpt id=\"p1\">[</bpt>C# Language Specification<ept id=\"p1\">](../../../csharp/language-reference/language-specification.md)</ept>.","source":"For additional information, see the [C# Language Specification](../../../csharp/language-reference/language-specification.md)."},{"pos":[13281,13332],"content":"<bpt id=\"p1\">&lt;a name=\"BKMK_UseOfIterators\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Use of Iterators","linkify":"<a name=\"BKMK_UseOfIterators\"></a> Use of Iterators","source":"<a name=\"BKMK_UseOfIterators\"></a> Use of Iterators"},{"content":"Iterators enable you to maintain the simplicity of a <ph id=\"ph1\">`foreach`</ph> loop when you need to use complex code to populate a list sequence.","pos":[13336,13466],"source":"Iterators enable you to maintain the simplicity of a `foreach` loop when you need to use complex code to populate a list sequence."},{"content":"This can be useful when you want to do the following:","pos":[13467,13520]},{"pos":[13530,13596],"content":"Modify the list sequence after the first <ph id=\"ph1\">`foreach`</ph> loop iteration.","source":"Modify the list sequence after the first `foreach` loop iteration."},{"content":"Avoid fully loading a large list before the first iteration of a <ph id=\"ph1\">`foreach`</ph> loop.","pos":[13606,13686],"source":"Avoid fully loading a large list before the first iteration of a `foreach` loop."},{"content":"An example is a paged fetch to load a batch of table rows.","pos":[13687,13745]},{"content":"Another example is the <ph id=\"ph1\">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> method, which implements iterators within the .NET Framework.","pos":[13746,13879],"source":" Another example is the <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> method, which implements iterators within the .NET Framework."},{"content":"Encapsulate building the list in the iterator.","pos":[13889,13935]},{"content":"In the iterator method, you can build the list and then yield each result in a loop.","pos":[13936,14020]},{"pos":[14029,14037],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\"> [</bpt>foreach, in<ept id=\"p1\">](../../../csharp/language-reference/keywords/foreach-in.md)</ept><ph id=\"ph1\"> </ph>","pos":[14132,14206],"source":" [foreach, in](../../../csharp/language-reference/keywords/foreach-in.md) "},{"content":"<bpt id=\"p1\"> [</bpt>yield<ept id=\"p1\">](../../../csharp/language-reference/keywords/yield.md)</ept><ph id=\"ph1\"> </ph>","pos":[14209,14272],"source":" [yield](../../../csharp/language-reference/keywords/yield.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Using foreach with Arrays<ept id=\"p1\">](../../../csharp/programming-guide/arrays/using-foreach-with-arrays.md)</ept><ph id=\"ph1\"> </ph>","pos":[14275,14375],"source":" [Using foreach with Arrays](../../../csharp/programming-guide/arrays/using-foreach-with-arrays.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/index.md)</ept>","pos":[14378,14442],"source":" [Generics](../../../csharp/programming-guide/generics/index.md)"}]}