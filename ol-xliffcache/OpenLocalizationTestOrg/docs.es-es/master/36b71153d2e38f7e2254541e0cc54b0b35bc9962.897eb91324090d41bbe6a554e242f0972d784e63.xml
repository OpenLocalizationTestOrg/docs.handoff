{"content":"---\ntitle: \"is (C# Reference) | Microsoft Docs\"\nkeywords: is keyword (C#), is (C#)\nms.date: \"2017-02-17\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"is_CSharpKeyword\"\n  - \"is\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"is keyword [C#]\"\nms.assetid: bc62316a-d41f-4f90-8300-c6f4f0556e43\ncaps.latest.revision: 20\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# is (C# Reference) #\n\nChecks if an object is compatible with a given type, or (starting with C# 7) tests an expression against a pattern.\n\n## Testing for type compatibility ##\n\nThe `is` keyword evaluates type compatibility at runtime. It determines whether an object instance or the result of an expression can be converted to a specified type. It has the syntax\n\n```csharp\n   expr is type\n```\n\nwhere *expr* is an expression that evaluates to an instance of some type, and *type* is the name of the type to which the result of *expr* is to be converted. The `is` statement is `true` if *expr* is non-null and the object that results from evaluating the expression can be converted to *type*; otherwise, it returns `false`.\n\nFor example, the following code determines if `obj` can be cast to an instance of the `Person` type:\n\n[!code-cs[is#1](../../../../samples/snippets/csharp/language-reference/keywords/is/is1.cs#1)]\n\nThe `is` statement is true if:\n\n- *expr* is an instance of the same type as *type*.\n\n- *expr* is an instance of a type that derives from *type*. In other words, the result of *expr* can be upcast to an instance of *type*.\n\n- *expr* has a compile-time type that is a base class of *type*, and *expr* has a runtime type that is *type* or is derived from *type*. The *compile-time type* of a variable is the variable's type as defined in its declaration. The *runtime type* of a variable is the type of the instance that is assigned to that variable.\n\n- *expr* is an instance of a type that implements the *type* interface.\n\nThe following example shows that the `is` expression evaluates to `true` for each of these conversions.\n\n[!code-cs[is#3](../../../../samples/snippets/csharp/language-reference/keywords/is/is3.cs#3)]\n\nThe `is` keyword generates a compile-time warning if the expression is known to always be either `true` or `false`. It only considers reference conversions, boxing conversions, and unboxing conversions; it does not consider user-defined conversions or conversions defined by a type's [implicit](implicit.md) and [explicit](explicit.md) operators. The following example generates warnings because the result of the conversion is known at compile-time. Note that the `is` expression for conversions from `int` to `long` and `double` return false, since these conversions are handled by the [implicit](implicit.md) operator.\n\n[!code-cs[is#2](../../../../samples/snippets/csharp/language-reference/keywords/is/is2.cs#2)]\n\n`expr` can be any expression that returns a value, with the exception of anonymous methods and lambda expressions. The following example uses  `is` to evaluate the return value of a method call.   \n[!code-cs[is#4](../../../../samples/snippets/csharp/language-reference/keywords/is/is4.cs#4)]\n\nStarting with C# 7, you can use pattern matching with the [type pattern](#type) to write more concise code that uses the `is` statement.\n\n## Pattern matching with `is` ##\n\nStarting with C# 7, the `is` and [switch](../../../csharp/language-reference/keywords/switch.md) statements support pattern matching. The `is` keyword supports the following patterns:\n\n- [Type pattern](#type),  which tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type.\n\n- [Constant pattern](#constant), which tests whether an expression evaluates to a specified constant value.\n\n- [var pattern](#var), a match that always succeeds and binds the value of an expression to a new local variable. \n\n### <a name=\"type\" /> Type pattern </a>\n\nWhen using the type pattern to perform pattern matching, `is` tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type. It is a straightforward extension of the `is` statement that enables concise type evaluation and conversion. The general form of the `is` type pattern is:\n\n```csharp\n   expr is type varname \n```\n\nwhere *expr* is an expression that evaluates to an instance of some type, *type* is the name of the type to which the result of *expr* is to be converted, and *varname* is the object to which the result of *expr* is converted if the `is` test is `true`. \n\nThe `is` expression is `true` if any of the following is true:\n\n- *expr* is an instance of the same type as *type*.\n\n- *expr* is an instance of a type that derives from *type*. In other words, the result of *expr* can be upcast to an instance of *type*.\n\n- *expr* has a compile-time type that is a base class of *type*, and *expr* has a runtime type that is *type* or is derived from *type*. The *compile-time type* of a variable is the variable's type as defined in its declaration. The *runtime type* of a variable is the type of the instance that is assigned to that variable.\n\n- *expr* is an instance of a type that implements the *type* interface.\n\nIf *exp* is `true` and `is` is used with an `if` statement, *varname* is assigned and has local scope within the `if` statement only.\n\nThe following example uses the `is` type pattern to provide the implementation of a type's <xref:System.IComparable.CompareTo(System.Object)?displayProperty=fullName> method.\n\n[!code-cs[is#5](../../../../samples/snippets/csharp/language-reference/keywords/is/is-type-pattern5.cs#5)]\n\nWithout pattern matching, this code might be written as follows. The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a `null`.  \n\n[!code-cs[is#6](../../../../samples/snippets/csharp/language-reference/keywords/is/is-type-pattern6.cs#6)]\n\nThe `is` type pattern also produces more compact code when determining the type of a value type. The following example uses the `is` type pattern to determine whether an object is a `Person` or a `Dog` instance before displaying the value of an appropriate property. \n\n[!code-cs[is#9](../../../../samples/snippets/csharp/language-reference/keywords/is/is-type-pattern9.cs#9)]\n\nThe equivalent code without pattern matching requires a separate assignment that includes an explicit cast.\n\n[!code-cs[is#10](../../../../samples/snippets/csharp/language-reference/keywords/is/is-type-pattern10.cs#10)]\n\n### <a name=\"constant\" /> Constant pattern ###\n\nWhen performing pattern matching with the constant pattern, `is` tests whether an expression equals a specified constant. In C# 6 and earlier versions, the constant pattern is supported by the [switch](switch.md) statement. Starting with C# 7, it is supported by the `is` statement as well. Its syntax is:\n\n```csharp\n   expr is constant\n```\n\nwhere *expr* is the expression to evaluate, and *constant* is the value to test for. *constant* can be any of the following constant expressions: \n\n- A literal value.\n\n- The name of a declared `const` variable.\n\n- An enumeration constant.\n\nThe constant expression is evaluated as follows:\n\n- If *expr* and *constant* are integral types, the C# equality operator determines whether the expression returns `true` (that is, whether `expr == constant`).\n\n- Otherwise, the value of the expression is determined by a call to the static [Object.Equals(expr, constant)](xref:System.Object.Equals(System.Object,System.Object)) method.  \n\nThe following example combines the type and constant patterns to test whether an object is a `Dice` instance and, if it is, to determine whether the value of a dice roll is 6.\n\n[!code-cs[is#7](../../../../samples/snippets/csharp/language-reference/keywords/is/is-const-pattern7.cs#7)]\n \n### <a name=\"var\" /> var pattern </a>\n\nA pattern match with the var pattern always succeeds. Its syntax is\n\n```csharp \n   expr is var varname\n```\n\nwhere the value of *expr* is always assigned to a local variable named *varname*. *varname* is a static variable of the same type as *expr*. The following example uses the var pattern to assign an expression to a variable named `obj`. It then displays the value and the type of `obj`.\n\n[!code-cs[is#8](../../../../samples/snippets/csharp/language-reference/keywords/is/is-var-pattern8.cs#8)]\n\nNote that if *expr* is `null`, the `is` expression still is true and assigns `null` to *varname*. \n\n# C# Language Specification\n  \n[!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n## See also  \n [C# Reference](../../../csharp/language-reference/index.md)   \n [C# Keywords](../../../csharp/language-reference/keywords/index.md)   \n [typeof](../../../csharp/language-reference/keywords/typeof.md)   \n [as](../../../csharp/language-reference/keywords/as.md)   \n [Operator Keywords](../../../csharp/language-reference/keywords/operator-keywords.md)\n","nodes":[{"pos":[4,587],"embed":true,"restype":"x-metadata","content":"title: \"is (C# Reference) | Microsoft Docs\"\nkeywords: is keyword (C#), is (C#)\nms.date: \"2017-02-17\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"is_CSharpKeyword\"\n  - \"is\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"is keyword [C#]\"\nms.assetid: bc62316a-d41f-4f90-8300-c6f4f0556e43\ncaps.latest.revision: 20\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","nodes":[{"content":"is (C# Reference) | Microsoft Docs","nodes":[{"pos":[0,34],"content":"is (C# Reference) | Microsoft Docs","nodes":[{"content":"is (C# Reference) | Microsoft Docs","pos":[0,34]}]}],"path":["title"]},{"content":"is keyword (C#), is (C#)","nodes":[{"pos":[0,24],"content":"is keyword (C#), is (C#)","nodes":[{"content":"is keyword (C#), is (C#)","pos":[0,24]}]}],"path":["keywords"]}],"yml":true},{"pos":[594,611],"content":"is (C# Reference)","linkify":"is (C# Reference)","nodes":[{"content":"is (C# Reference)","pos":[0,17]}]},{"content":"Checks if an object is compatible with a given type, or (starting with C# 7) tests an expression against a pattern.","pos":[615,730]},{"pos":[735,765],"content":"Testing for type compatibility","linkify":"Testing for type compatibility","nodes":[{"content":"Testing for type compatibility","pos":[0,30]}]},{"content":"The <ph id=\"ph1\">`is`</ph> keyword evaluates type compatibility at runtime.","pos":[770,827],"source":"The `is` keyword evaluates type compatibility at runtime."},{"content":"It determines whether an object instance or the result of an expression can be converted to a specified type.","pos":[828,937]},{"content":"It has the syntax","pos":[938,955]},{"content":"where <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an expression that evaluates to an instance of some type, and <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> is the name of the type to which the result of <bpt id=\"p3\">*</bpt>expr<ept id=\"p3\">*</ept> is to be converted.","pos":[988,1146],"source":"where *expr* is an expression that evaluates to an instance of some type, and *type* is the name of the type to which the result of *expr* is to be converted."},{"content":"The <ph id=\"ph1\">`is`</ph> statement is <ph id=\"ph2\">`true`</ph> if <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is non-null and the object that results from evaluating the expression can be converted to <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>; otherwise, it returns <ph id=\"ph3\">`false`</ph>.","pos":[1147,1315],"source":" The `is` statement is `true` if *expr* is non-null and the object that results from evaluating the expression can be converted to *type*; otherwise, it returns `false`."},{"pos":[1317,1417],"content":"For example, the following code determines if <ph id=\"ph1\">`obj`</ph> can be cast to an instance of the <ph id=\"ph2\">`Person`</ph> type:","source":"For example, the following code determines if `obj` can be cast to an instance of the `Person` type:"},{"pos":[1514,1544],"content":"The <ph id=\"ph1\">`is`</ph> statement is true if:","source":"The `is` statement is true if:"},{"pos":[1548,1597],"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of the same type as <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","source":"*expr* is an instance of the same type as *type*."},{"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of a type that derives from <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","pos":[1601,1658],"source":"*expr* is an instance of a type that derives from *type*."},{"content":"In other words, the result of <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> can be upcast to an instance of <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","pos":[1659,1735],"source":" In other words, the result of *expr* can be upcast to an instance of *type*."},{"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> has a compile-time type that is a base class of <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>expr<ept id=\"p3\">*</ept> has a runtime type that is <bpt id=\"p4\">*</bpt>type<ept id=\"p4\">*</ept> or is derived from <bpt id=\"p5\">*</bpt>type<ept id=\"p5\">*</ept>.","pos":[1739,1873],"source":"*expr* has a compile-time type that is a base class of *type*, and *expr* has a runtime type that is *type* or is derived from *type*."},{"content":"The <bpt id=\"p1\">*</bpt>compile-time type<ept id=\"p1\">*</ept> of a variable is the variable's type as defined in its declaration.","pos":[1874,1965],"source":" The *compile-time type* of a variable is the variable's type as defined in its declaration."},{"content":"The <bpt id=\"p1\">*</bpt>runtime type<ept id=\"p1\">*</ept> of a variable is the type of the instance that is assigned to that variable.","pos":[1966,2061],"source":" The *runtime type* of a variable is the type of the instance that is assigned to that variable."},{"pos":[2065,2134],"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of a type that implements the <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> interface.","source":"*expr* is an instance of a type that implements the *type* interface."},{"pos":[2136,2239],"content":"The following example shows that the <ph id=\"ph1\">`is`</ph> expression evaluates to <ph id=\"ph2\">`true`</ph> for each of these conversions.","source":"The following example shows that the `is` expression evaluates to `true` for each of these conversions."},{"content":"The <ph id=\"ph1\">`is`</ph> keyword generates a compile-time warning if the expression is known to always be either <ph id=\"ph2\">`true`</ph> or <ph id=\"ph3\">`false`</ph>.","pos":[2336,2451],"source":"The `is` keyword generates a compile-time warning if the expression is known to always be either `true` or `false`."},{"content":"It only considers reference conversions, boxing conversions, and unboxing conversions; it does not consider user-defined conversions or conversions defined by a type's <bpt id=\"p1\">[</bpt>implicit<ept id=\"p1\">](implicit.md)</ept> and <bpt id=\"p2\">[</bpt>explicit<ept id=\"p2\">](explicit.md)</ept> operators.","pos":[2452,2682],"source":" It only considers reference conversions, boxing conversions, and unboxing conversions; it does not consider user-defined conversions or conversions defined by a type's [implicit](implicit.md) and [explicit](explicit.md) operators."},{"content":"The following example generates warnings because the result of the conversion is known at compile-time.","pos":[2683,2786]},{"content":"Note that the <ph id=\"ph1\">`is`</ph> expression for conversions from <ph id=\"ph2\">`int`</ph> to <ph id=\"ph3\">`long`</ph> and <ph id=\"ph4\">`double`</ph> return false, since these conversions are handled by the <bpt id=\"p1\">[</bpt>implicit<ept id=\"p1\">](implicit.md)</ept> operator.","pos":[2787,2957],"source":" Note that the `is` expression for conversions from `int` to `long` and `double` return false, since these conversions are handled by the [implicit](implicit.md) operator."},{"content":"<ph id=\"ph1\">`expr`</ph> can be any expression that returns a value, with the exception of anonymous methods and lambda expressions.","pos":[3054,3168],"source":"`expr` can be any expression that returns a value, with the exception of anonymous methods and lambda expressions."},{"content":"The following example uses  <ph id=\"ph1\">`is`</ph> to evaluate the return value of a method call.","pos":[3169,3248],"source":" The following example uses  `is` to evaluate the return value of a method call."},{"pos":[3347,3483],"content":"Starting with C# 7, you can use pattern matching with the <bpt id=\"p1\">[</bpt>type pattern<ept id=\"p1\">](#type)</ept> to write more concise code that uses the <ph id=\"ph1\">`is`</ph> statement.","source":"Starting with C# 7, you can use pattern matching with the [type pattern](#type) to write more concise code that uses the `is` statement."},{"pos":[3488,3514],"content":"Pattern matching with <ph id=\"ph1\">`is`</ph>","linkify":"Pattern matching with `is`","source":"Pattern matching with `is`"},{"content":"Starting with C# 7, the <ph id=\"ph1\">`is`</ph> and <bpt id=\"p1\">[</bpt>switch<ept id=\"p1\">](../../../csharp/language-reference/keywords/switch.md)</ept> statements support pattern matching.","pos":[3519,3652],"source":"Starting with C# 7, the `is` and [switch](../../../csharp/language-reference/keywords/switch.md) statements support pattern matching."},{"content":"The <ph id=\"ph1\">`is`</ph> keyword supports the following patterns:","pos":[3653,3702],"source":" The `is` keyword supports the following patterns:"},{"pos":[3706,3856],"content":"<bpt id=\"p1\">[</bpt>Type pattern<ept id=\"p1\">](#type)</ept>,  which tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type.","source":"[Type pattern](#type),  which tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type."},{"pos":[3860,3965],"content":"<bpt id=\"p1\">[</bpt>Constant pattern<ept id=\"p1\">](#constant)</ept>, which tests whether an expression evaluates to a specified constant value.","source":"[Constant pattern](#constant), which tests whether an expression evaluates to a specified constant value."},{"pos":[3969,4080],"content":"<bpt id=\"p1\">[</bpt>var pattern<ept id=\"p1\">](#var)</ept>, a match that always succeeds and binds the value of an expression to a new local variable.","source":"[var pattern](#var), a match that always succeeds and binds the value of an expression to a new local variable."},{"pos":[4087,4122],"content":"<ph id=\"ph1\">&lt;a name=\"type\" /&gt;</ph> Type pattern <ph id=\"ph2\">&lt;/a&gt;</ph>","linkify":"<a name=\"type\" /> Type pattern </a>","source":"<a name=\"type\" /> Type pattern </a>"},{"content":"When using the type pattern to perform pattern matching, <ph id=\"ph1\">`is`</ph> tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type.","pos":[4124,4306],"source":"When using the type pattern to perform pattern matching, `is` tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type."},{"content":"It is a straightforward extension of the <ph id=\"ph1\">`is`</ph> statement that enables concise type evaluation and conversion.","pos":[4307,4415],"source":" It is a straightforward extension of the `is` statement that enables concise type evaluation and conversion."},{"content":"The general form of the <ph id=\"ph1\">`is`</ph> type pattern is:","pos":[4416,4461],"source":" The general form of the `is` type pattern is:"},{"pos":[4503,4756],"content":"where <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an expression that evaluates to an instance of some type, <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> is the name of the type to which the result of <bpt id=\"p3\">*</bpt>expr<ept id=\"p3\">*</ept> is to be converted, and <bpt id=\"p4\">*</bpt>varname<ept id=\"p4\">*</ept> is the object to which the result of <bpt id=\"p5\">*</bpt>expr<ept id=\"p5\">*</ept> is converted if the <ph id=\"ph1\">`is`</ph> test is <ph id=\"ph2\">`true`</ph>.","source":"where *expr* is an expression that evaluates to an instance of some type, *type* is the name of the type to which the result of *expr* is to be converted, and *varname* is the object to which the result of *expr* is converted if the `is` test is `true`."},{"pos":[4759,4821],"content":"The <ph id=\"ph1\">`is`</ph> expression is <ph id=\"ph2\">`true`</ph> if any of the following is true:","source":"The `is` expression is `true` if any of the following is true:"},{"pos":[4825,4874],"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of the same type as <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","source":"*expr* is an instance of the same type as *type*."},{"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of a type that derives from <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","pos":[4878,4935],"source":"*expr* is an instance of a type that derives from *type*."},{"content":"In other words, the result of <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> can be upcast to an instance of <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","pos":[4936,5012],"source":" In other words, the result of *expr* can be upcast to an instance of *type*."},{"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> has a compile-time type that is a base class of <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>expr<ept id=\"p3\">*</ept> has a runtime type that is <bpt id=\"p4\">*</bpt>type<ept id=\"p4\">*</ept> or is derived from <bpt id=\"p5\">*</bpt>type<ept id=\"p5\">*</ept>.","pos":[5016,5150],"source":"*expr* has a compile-time type that is a base class of *type*, and *expr* has a runtime type that is *type* or is derived from *type*."},{"content":"The <bpt id=\"p1\">*</bpt>compile-time type<ept id=\"p1\">*</ept> of a variable is the variable's type as defined in its declaration.","pos":[5151,5242],"source":" The *compile-time type* of a variable is the variable's type as defined in its declaration."},{"content":"The <bpt id=\"p1\">*</bpt>runtime type<ept id=\"p1\">*</ept> of a variable is the type of the instance that is assigned to that variable.","pos":[5243,5338],"source":" The *runtime type* of a variable is the type of the instance that is assigned to that variable."},{"pos":[5342,5411],"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of a type that implements the <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> interface.","source":"*expr* is an instance of a type that implements the *type* interface."},{"pos":[5413,5546],"content":"If <bpt id=\"p1\">*</bpt>exp<ept id=\"p1\">*</ept> is <ph id=\"ph1\">`true`</ph> and <ph id=\"ph2\">`is`</ph> is used with an <ph id=\"ph3\">`if`</ph> statement, <bpt id=\"p2\">*</bpt>varname<ept id=\"p2\">*</ept> is assigned and has local scope within the <ph id=\"ph4\">`if`</ph> statement only.","source":"If *exp* is `true` and `is` is used with an `if` statement, *varname* is assigned and has local scope within the `if` statement only."},{"pos":[5548,5722],"content":"The following example uses the <ph id=\"ph1\">`is`</ph> type pattern to provide the implementation of a type's <ph id=\"ph2\">&lt;xref:System.IComparable.CompareTo(System.Object)?displayProperty=fullName&gt;</ph> method.","source":"The following example uses the `is` type pattern to provide the implementation of a type's <xref:System.IComparable.CompareTo(System.Object)?displayProperty=fullName> method."},{"content":"Without pattern matching, this code might be written as follows.","pos":[5832,5896]},{"content":"The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a <ph id=\"ph1\">`null`</ph>.","pos":[5897,6046],"source":" The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a `null`."},{"content":"The <ph id=\"ph1\">`is`</ph> type pattern also produces more compact code when determining the type of a value type.","pos":[6158,6254],"source":"The `is` type pattern also produces more compact code when determining the type of a value type."},{"content":"The following example uses the <ph id=\"ph1\">`is`</ph> type pattern to determine whether an object is a <ph id=\"ph2\">`Person`</ph> or a <ph id=\"ph3\">`Dog`</ph> instance before displaying the value of an appropriate property.","pos":[6255,6424],"source":" The following example uses the `is` type pattern to determine whether an object is a `Person` or a `Dog` instance before displaying the value of an appropriate property."},{"content":"The equivalent code without pattern matching requires a separate assignment that includes an explicit cast.","pos":[6535,6642]},{"pos":[6759,6797],"content":"<ph id=\"ph1\">&lt;a name=\"constant\" /&gt;</ph> Constant pattern","linkify":"<a name=\"constant\" /> Constant pattern","source":"<a name=\"constant\" /> Constant pattern"},{"content":"When performing pattern matching with the constant pattern, <ph id=\"ph1\">`is`</ph> tests whether an expression equals a specified constant.","pos":[6803,6924],"source":"When performing pattern matching with the constant pattern, `is` tests whether an expression equals a specified constant."},{"content":"In C# 6 and earlier versions, the constant pattern is supported by the <bpt id=\"p1\">[</bpt>switch<ept id=\"p1\">](switch.md)</ept> statement.","pos":[6925,7026],"source":" In C# 6 and earlier versions, the constant pattern is supported by the [switch](switch.md) statement."},{"content":"Starting with C# 7, it is supported by the <ph id=\"ph1\">`is`</ph> statement as well.","pos":[7027,7093],"source":" Starting with C# 7, it is supported by the `is` statement as well."},{"content":"Its syntax is:","pos":[7094,7108]},{"content":"where <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is the expression to evaluate, and <bpt id=\"p2\">*</bpt>constant<ept id=\"p2\">*</ept> is the value to test for.","pos":[7145,7229],"source":"where *expr* is the expression to evaluate, and *constant* is the value to test for."},{"content":"<bpt id=\"p1\">*</bpt>constant<ept id=\"p1\">*</ept> can be any of the following constant expressions:","pos":[7230,7290],"source":"*constant* can be any of the following constant expressions:"},{"content":"A literal value.","pos":[7295,7311]},{"pos":[7315,7355],"content":"The name of a declared <ph id=\"ph1\">`const`</ph> variable.","source":"The name of a declared `const` variable."},{"content":"An enumeration constant.","pos":[7359,7383]},{"content":"The constant expression is evaluated as follows:","pos":[7385,7433]},{"pos":[7437,7594],"content":"If <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>constant<ept id=\"p2\">*</ept> are integral types, the C# equality operator determines whether the expression returns <ph id=\"ph1\">`true`</ph> (that is, whether <ph id=\"ph2\">`expr == constant`</ph>).","source":"If *expr* and *constant* are integral types, the C# equality operator determines whether the expression returns `true` (that is, whether `expr == constant`)."},{"pos":[7598,7770],"content":"Otherwise, the value of the expression is determined by a call to the static <bpt id=\"p1\">[</bpt>Object.Equals(expr, constant)<ept id=\"p1\">](xref:System.Object.Equals(System.Object,System.Object))</ept> method.","source":"Otherwise, the value of the expression is determined by a call to the static [Object.Equals(expr, constant)](xref:System.Object.Equals(System.Object,System.Object)) method."},{"pos":[7774,7949],"content":"The following example combines the type and constant patterns to test whether an object is a <ph id=\"ph1\">`Dice`</ph> instance and, if it is, to determine whether the value of a dice roll is 6.","source":"The following example combines the type and constant patterns to test whether an object is a `Dice` instance and, if it is, to determine whether the value of a dice roll is 6."},{"pos":[8065,8098],"content":"<ph id=\"ph1\">&lt;a name=\"var\" /&gt;</ph> var pattern <ph id=\"ph2\">&lt;/a&gt;</ph>","linkify":"<a name=\"var\" /> var pattern </a>","source":"<a name=\"var\" /> var pattern </a>"},{"content":"A pattern match with the var pattern always succeeds.","pos":[8100,8153]},{"content":"Its syntax is","pos":[8154,8167]},{"content":"where the value of <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is always assigned to a local variable named <bpt id=\"p2\">*</bpt>varname<ept id=\"p2\">*</ept>.","pos":[8208,8289],"source":"where the value of *expr* is always assigned to a local variable named *varname*."},{"content":"<bpt id=\"p1\">*</bpt>varname<ept id=\"p1\">*</ept> is a static variable of the same type as <bpt id=\"p2\">*</bpt>expr<ept id=\"p2\">*</ept>.","pos":[8290,8348],"source":"*varname* is a static variable of the same type as *expr*."},{"content":"The following example uses the var pattern to assign an expression to a variable named <ph id=\"ph1\">`obj`</ph>.","pos":[8349,8442],"source":" The following example uses the var pattern to assign an expression to a variable named `obj`."},{"content":"It then displays the value and the type of <ph id=\"ph1\">`obj`</ph>.","pos":[8443,8492],"source":" It then displays the value and the type of `obj`."},{"pos":[8601,8698],"content":"Note that if <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is <ph id=\"ph1\">`null`</ph>, the <ph id=\"ph2\">`is`</ph> expression still is true and assigns <ph id=\"ph3\">`null`</ph> to <bpt id=\"p2\">*</bpt>varname<ept id=\"p2\">*</ept>.","source":"Note that if *expr* is `null`, the `is` expression still is true and assigns `null` to *varname*."},{"pos":[8703,8728],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[8842,8850],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[8854,8914],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[8918,8986],"source":"[C# Keywords](../../../csharp/language-reference/keywords/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>typeof<ept id=\"p1\">](../../../csharp/language-reference/keywords/typeof.md)</ept><ph id=\"ph1\"> </ph>","pos":[8990,9054],"source":"[typeof](../../../csharp/language-reference/keywords/typeof.md) "},{"content":"<bpt id=\"p1\">[</bpt>as<ept id=\"p1\">](../../../csharp/language-reference/keywords/as.md)</ept><ph id=\"ph1\"> </ph>","pos":[9058,9114],"source":"[as](../../../csharp/language-reference/keywords/as.md) "},{"content":"<bpt id=\"p1\">[</bpt>Operator Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/operator-keywords.md)</ept>","pos":[9118,9203],"source":"[Operator Keywords](../../../csharp/language-reference/keywords/operator-keywords.md)"}]}