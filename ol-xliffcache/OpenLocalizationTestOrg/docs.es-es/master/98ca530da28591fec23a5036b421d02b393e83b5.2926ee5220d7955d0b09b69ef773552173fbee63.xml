{"content":"---\ntitle: \"XAML Syntax In Detail\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"XML [WPF], namespaces\"\n  - \"XAML [WPF], parsing of attributes\"\n  - \"parsing of attributes [WPF]\"\n  - \"XAML [WPF], markup extensions\"\n  - \"attached properties [WPF]\"\n  - \"tag syntax [XAML]\"\n  - \"markup extensions [WPF]\"\n  - \"XAML [WPF], object element syntax\"\n  - \"XAML [WPF], syntax terminology\"\n  - \"attached events [WPF]\"\n  - \"lookup semantics [WPF]\"\n  - \"XAML [WPF], attached events\"\n  - \"XAML [WPF], content syntax\"\n  - \"XAML [WPF], lookup semantics\"\n  - \"content syntax [WPF]\"\n  - \"object element syntax [WPF]\"\n  - \"syntax terminology [XAML]\"\n  - \"XAML [WPF], attached properties\"\n  - \"attributes [XAML], parsing\"\n  - \"XAML [WPF], tag syntax\"\n  - \"XAML [WPF], attribute syntax\"\n  - \"property element syntax [WPF]\"\n  - \"terminology [XAML]\"\n  - \"namespaces [WPF], XML\"\n  - \"attribute syntax [XAML]\"\n  - \"XAML [WPF], property element syntax\"\nms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479\n---\n# XAML Syntax In Detail\nThis topic defines the terms that are used to describe the elements of XAML syntax. These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level. This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](xaml-overview-wpf.md).  \n\n<a name=\"the_xaml_language_specification\"></a>   \n## The XAML Language Specification  \n The XAML syntax terminology defined here is also defined or referenced within the XAML language specification. XAML is a language based on XML and follows or expands upon XML structural rules. Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.  \n  \n For more information about the XAML language specification, download [\\[MS-XAML\\]](https://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.  \n  \n<a name=\"xaml_and_clr\"></a>   \n## XAML and CLR  \n XAML is a markup language. The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution. XAML is not by itself one of the common languages that is directly consumed by the CLR runtime. Instead, you can think of XAML as supporting its own type system. The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system. XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed. For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not. (Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)  \n  \n#### Members of Types and Class Inheritance  \n Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types. For example, consider this example: `<Button Background=\"Blue\" .../>`. The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation. Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.  \n  \n The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup. Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved. This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format. Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.  \n  \n<a name=\"object_element_syntax\"></a>   \n## Object Element Syntax  \n *Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element. This syntax resembles the element syntax of other markup languages such as HTML. Object element syntax begins with a left angle bracket (\\<), followed immediately by the type name of the class or structure being instantiated. Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name=\"value\" pair. Finally, one of the following must be true:  \n  \n-   The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).  \n  \n-   The opening tag must be completed by a right angle bracket (>). Other object elements, property elements, or inner text, can follow the opening tag. Exactly what content may be contained here is typically constrained by the object model of the element. The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.  \n  \n XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly. For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types. When you reference a CLR type in XAML, you have access to the inherited members of that type as well.  \n  \n For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:  \n  \n [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  \n  \n The following example is object element syntax that also includes XAML content property syntax. The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.  \n  \n [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  \n  \n### Content Models  \n A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree. For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>. Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.  \n  \n<a name=\"properties_of_object_elements\"></a>   \n## Properties of Object Elements  \n Properties in XAML are set by a variety of possible syntaxes. Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.  \n  \n By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph. The initial state of the created object from a object element is based on the default constructor behavior. Typically, your application will use something other than a completely default instance of any given object.  \n  \n<a name=\"attribute_syntax_properties\"></a>   \n## Attribute Syntax (Properties)  \n Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element. The attribute name must match the CLR member name of the property of the class that backs the relevant object element. The attribute name is followed by an assignment operator (=). The attribute value must be a string enclosed within quotes.  \n  \n> [!NOTE]\n>  You can use alternating quotes to place a literal quotation mark within an attribute. For instance you can use single quotes as a means to declare a string that contains a double quote character within it. Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string. There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax. See [XML Character Entities and XAML](../../xaml-services/xml-character-entities-and-xaml.md).  \n  \n In order to be set through attribute syntax, a property must be public and must be writeable. The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.  \n  \n For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.  \n  \n The property or event must be a member of the class or structure that is instantiated by the containing object element.  \n  \n### Processing of Attribute Values  \n The string value contained within the opening and closing quotation marks is processed by a XAML processor. For properties, the default processing behavior is determined by the type of the underlying CLR property.  \n  \n The attribute value is filled by one of the following, using this processing order:  \n  \n1.  If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value. In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.  \n  \n2.  If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.  \n  \n3.  If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted. This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).  \n  \n#### Enumeration Attribute Values  \n Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.  \n  \n For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values. You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code. Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting. If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.  \n  \n For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method. You can specify multiple values for a flagwise enumeration by separating each value with a comma. However, you cannot combine enumeration values that are not flagwise. For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:  \n  \n```  \n<!--This will not compile, because Visibility is not a flagwise enumeration.-->  \n...  \n<Trigger Property=\"Visibility\" Value=\"Collapsed,Hidden\">  \n  <Setter ... />  \n</Trigger>  \n...  \n```  \n  \n Flagwise enumerations that support attributes that are settable in XAML are rare in WPF. However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>. You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = \"BoldSimulation\"` could become `StyleSimulations = \"BoldSimulation,ItalicSimulation\"`. <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified. However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter. The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,). This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as \"Ctrl+Alt\".  \n  \n### Properties and Event Member Name References  \n When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.  \n  \n Or, you can reference an attached property or attached event, independent of the containing object element. (Attached properties are discussed in an upcoming section.)  \n  \n You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table. This syntax resembles an attached event syntax, but the event here is not a true attached event. Instead, you are referencing an event with a qualified name. For more information, see [Routed Events Overview](routed-events-overview.md).  \n  \n For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name. That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*. This scenario is common when writing styles or templates in XAML. The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems. For details, see [Styling and Templating](../controls/styling-and-templating.md).  \n  \n Another usage for property names is when an attribute value describes a property-property relationship. This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter. For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).  \n  \n<a name=\"property_element_syntax\"></a>   \n## Property Element Syntax  \n *Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements. In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used. In XAML, you can assign other object elements to be the value of a property. This capability is enabled by the property element syntax. Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.  \n  \n Specifically, the syntax begins with a left angle bracket (\\<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>). As with attribute syntax, that property must exist within the declared public members of the specified type. The value to be assigned to the property is contained within the property element. Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address. Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.  \n  \n For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.  \n  \n [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  \n  \n The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified. These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax. One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text. Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../xaml-services/whitespace-processing-in-xaml.md)). Another scenario is so that [x:Uid Directive](../../xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.  \n  \n A property element is not represented in the WPF logical tree. A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it. (For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)  \n  \n For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.  \n  \n<a name=\"collection_syntax\"></a>   \n## Collection Syntax  \n The XAML specification requires XAML processor implementations to identify properties where the value type is a collection. The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:  \n  \n-   Type implements <xref:System.Collections.IList>.  \n  \n-   Type implements <xref:System.Collections.IDictionary>.  \n  \n-   Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)  \n  \n If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element. Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element. Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection. For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>. It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup. Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.  \n  \n [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  \n  \n A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.  \n  \n An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element. Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.  \n  \n> [!NOTE]\n>  The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection. However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.  \n  \n In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.  \n  \n With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section). In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent. This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.  \n  \n The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.  \n  \n```xaml  \n<LinearGradientBrush>  \n  <LinearGradientBrush.GradientStops>  \n    <GradientStopCollection>  \n      <GradientStop Offset=\"0.0\" Color=\"Red\" />  \n      <GradientStop Offset=\"1.0\" Color=\"Blue\" />  \n    </GradientStopCollection>  \n  </LinearGradientBrush.GradientStops>  \n</LinearGradientBrush>  \n```  \n  \n Note that it is not always possible to explicitly declare the collection. For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail. Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor.  \n  \n<a name=\"xaml_content_properties\"></a>   \n## XAML Content Properties  \n XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration. The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes). When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object. You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference. The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly. Property element tags for other properties on an element are not assigned as \"content\" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be \"content\".  \n  \n### XAML Content Property Values Must Be Contiguous  \n The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element. This is true whether the value of a XAML content property is specified as a string, or as one or more objects. For example, the following markup does not parse:  \n  \n```  \n<Button>I am a   \n  <Button.Background>Blue</Button.Background>  \n  blue button</Button>  \n```  \n  \n This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:  \n  \n```xml  \n<Button>  \n  <Button.Content>I am a </Button.Content>  \n  <Button.Background>Blue</Button.Background>  \n  <Button.Content> blue button</Button.Content>  \n</Button>  \n```  \n  \n A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:  \n  \n```xml  \n<StackPanel>  \n  <Button>This example</Button>  \n  <StackPanel.Resources>  \n    <SolidColorBrush x:Key=\"BlueBrush\" Color=\"Blue\"/>  \n  </StackPanel.Resources>  \n  <Button>... is illegal XAML</Button>  \n</StackPanel>  \n```  \n  \n<a name=\"content_properties_and_collection_syntax_combined\"></a>   \n## Content Properties and Collection Syntax Combined  \n In order to accept more than a single object element as content, the type of the content property must specifically be a collection type. Similar to property element syntax for collection types, a XAML processor must identify types that are collection types. If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element. Therefore the apparent content model in the markup can now have more than one child element assigned as the content. The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class. All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.  \n  \n [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  \n  \n Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup. This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects. In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design. Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element.  \n  \n### Mixing Property Elements and Object Elements in an Object with a Content Property  \n The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed. This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.  \n  \n You can have a child object element as the first immediate markup within an object element. Then you can introduce property elements. Or, you can specify one or more property elements, then content, then more property elements. But once a property element follows content, you cannot introduce any further content, you can only add property elements.  \n  \n This content / property element order requirement does not apply to inner text used as content. However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.  \n  \n<a name=\"xaml_namespaces\"></a>   \n## XAML Namespaces  \n None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace. In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace. You can specify XAML namespaces other than the default XAML namespace and still use similar syntax. But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace. For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.  \n  \n For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  \n  \n<a name=\"markup_extensions\"></a>   \n## Markup Extensions  \n XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class. The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}). The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring \"Extension\" if that substring is part of the true class name. Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.  \n  \n The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies. The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time. For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take. Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible. For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties. Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource. The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:  \n  \n `<Button Style=\"{StaticResource MyStyle}\">My button</Button>`  \n  \n Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation. The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>. `MyStyle` is expected to be the [x:Key](../../xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource. The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.  \n  \n For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md). For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md). For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).  \n  \n<a name=\"attached_properties\"></a>   \n## Attached Properties  \n Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element. The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements. Conversely, attached properties can be used by parent elements to report information to child elements. For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).  \n  \n Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination. There are two important differences:  \n  \n-   You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax. Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.  \n  \n-   You can also use property element syntax for attached properties. However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element. If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.  \n  \n<a name=\"attached_events\"></a>   \n## Attached Events  \n Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element. In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service. Handlers for attached events are specified through attribute syntax. As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.  \n  \n<a name=\"anatomy_of_a_xaml_page_root_element\"></a>   \n## Anatomy of a XAML Root Element  \n The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:  \n  \n|||  \n|-|-|  \n|`<Page`|Opening object element of the root element|  \n|`xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"`|The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace|  \n|`xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"`|The XAML language XAML namespace|  \n|`x:Class=\"ExampleNamespace.ExampleCode\"`|The partial class declaration that connects markup to any code-behind defined for the partial class|  \n|`>`|End of object element for the root. Object is not closed yet because the element contains child elements|  \n  \n<a name=\"optional_and_nonrecommended_xaml_usages\"></a>   \n## Optional and Nonrecommended XAML Usages  \n The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.  \n  \n### Optional Property Element Usages  \n Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit. For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection. Sometimes the optional usages can help to visually clarify the object structure as represented in the markup. Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.  \n  \n### Full typeName.memberName Qualified Attributes  \n The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case. But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability. In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:  \n  \n [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  \n  \n `Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class. `Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.  \n  \n However, the following *typeName*.*memberName* form example does not work and is thus shown commented:  \n  \n [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  \n  \n <xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked. However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property. `Label.Background` is not an available attached property, and this usage fails.  \n  \n### baseTypeName.memberName Property Elements  \n In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax. For instance, the following syntax works:  \n  \n [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  \n  \n Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.  \n  \n But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.  \n  \n## See also\n\n- [XAML Overview (WPF)](xaml-overview-wpf.md)\n- [XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md)\n- [WPF XAML Extensions](wpf-xaml-extensions.md)\n- [Dependency Properties Overview](dependency-properties-overview.md)\n- [TypeConverters and XAML](typeconverters-and-xaml.md)\n- [XAML and Custom Classes for WPF](xaml-and-custom-classes-for-wpf.md)\n","nodes":[{"pos":[4,976],"embed":true,"restype":"x-metadata","content":"title: \"XAML Syntax In Detail\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"XML [WPF], namespaces\"\n  - \"XAML [WPF], parsing of attributes\"\n  - \"parsing of attributes [WPF]\"\n  - \"XAML [WPF], markup extensions\"\n  - \"attached properties [WPF]\"\n  - \"tag syntax [XAML]\"\n  - \"markup extensions [WPF]\"\n  - \"XAML [WPF], object element syntax\"\n  - \"XAML [WPF], syntax terminology\"\n  - \"attached events [WPF]\"\n  - \"lookup semantics [WPF]\"\n  - \"XAML [WPF], attached events\"\n  - \"XAML [WPF], content syntax\"\n  - \"XAML [WPF], lookup semantics\"\n  - \"content syntax [WPF]\"\n  - \"object element syntax [WPF]\"\n  - \"syntax terminology [XAML]\"\n  - \"XAML [WPF], attached properties\"\n  - \"attributes [XAML], parsing\"\n  - \"XAML [WPF], tag syntax\"\n  - \"XAML [WPF], attribute syntax\"\n  - \"property element syntax [WPF]\"\n  - \"terminology [XAML]\"\n  - \"namespaces [WPF], XML\"\n  - \"attribute syntax [XAML]\"\n  - \"XAML [WPF], property element syntax\"\nms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479","nodes":[{"content":"XAML Syntax In Detail","nodes":[{"pos":[0,21],"content":"XAML Syntax In Detail","nodes":[{"content":"XAML Syntax In Detail","pos":[0,21]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[983,1004],"content":"XAML Syntax In Detail","linkify":"XAML Syntax In Detail","nodes":[{"content":"XAML Syntax In Detail","pos":[0,21]}]},{"content":"This topic defines the terms that are used to describe the elements of XAML syntax.","pos":[1005,1088]},{"content":"These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.","pos":[1089,1341]},{"content":"This topic expands on the basic terminology introduced in the topic <bpt id=\"p1\">[</bpt>XAML Overview (WPF)<ept id=\"p1\">](xaml-overview-wpf.md)</ept>.","pos":[1342,1454],"source":" This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](xaml-overview-wpf.md)."},{"pos":[1511,1542],"content":"The XAML Language Specification","linkify":"The XAML Language Specification","nodes":[{"content":"The XAML Language Specification","pos":[0,31]}]},{"content":"The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.","pos":[1546,1656]},{"content":"XAML is a language based on XML and follows or expands upon XML structural rules.","pos":[1657,1738]},{"content":"Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.","pos":[1739,1889]},{"pos":[1896,2062],"content":"For more information about the XAML language specification, download <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\[</ph>MS-XAML<ph id=\"ph2\">\\]</ph><ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=114525)</ept> from the Microsoft Download Center.","source":"For more information about the XAML language specification, download [\\[MS-XAML\\]](https://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center."},{"pos":[2102,2114],"content":"XAML and CLR","linkify":"XAML and CLR","nodes":[{"content":"XAML and CLR","pos":[0,12]}]},{"content":"XAML is a markup language.","pos":[2118,2144]},{"content":"The <ph id=\"ph1\">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph>, as implied by its name, enables runtime execution.","pos":[2145,2268],"source":" The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution."},{"content":"XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.","pos":[2269,2364]},{"content":"Instead, you can think of XAML as supporting its own type system.","pos":[2365,2430]},{"content":"The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.","pos":[2431,2530]},{"content":"XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.","pos":[2531,2639]},{"content":"For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.","pos":[2640,2848]},{"content":"(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)","pos":[2849,3053]},{"pos":[3064,3102],"content":"Members of Types and Class Inheritance","linkify":"Members of Types and Class Inheritance","nodes":[{"content":"Members of Types and Class Inheritance","pos":[0,38]}]},{"content":"Properties and events as they appear as XAML members of a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> type are often inherited from base types.","pos":[3106,3287],"source":"Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types."},{"content":"For example, consider this example: <ph id=\"ph1\">`&lt;Button Background=\"Blue\" .../&gt;`</ph>.","pos":[3288,3358],"source":" For example, consider this example: `<Button Background=\"Blue\" .../>`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> property is not an immediately declared property on the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph> class, if you were to look at the class definition, reflection results, or the documentation.","pos":[3359,3603],"source":" The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation."},{"content":"Instead, <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> is inherited from the base <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control&gt;</ph> class.","pos":[3604,3738],"source":" Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class."},{"content":"The class inheritance behavior of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> XAML elements is a significant departure from a schema-enforced interpretation of XML markup.","pos":[3745,3954],"source":"The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup."},{"content":"Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.","pos":[3955,4083]},{"content":"This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]</ph> programming, such as DTD or XSD format.","pos":[4084,4378],"source":" This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format."},{"content":"Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.","pos":[4379,4557]},{"pos":[4606,4627],"content":"Object Element Syntax","linkify":"Object Element Syntax","nodes":[{"content":"Object Element Syntax","pos":[0,21]}]},{"content":"<bpt id=\"p1\">*</bpt>Object element syntax<ept id=\"p1\">*</ept> is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.","pos":[4631,4752],"source":"*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element."},{"content":"This syntax resembles the element syntax of other markup languages such as HTML.","pos":[4753,4833]},{"content":"Object element syntax begins with a left angle bracket (<ph id=\"ph1\">\\&lt;</ph>), followed immediately by the type name of the class or structure being instantiated.","pos":[4834,4978],"source":" Object element syntax begins with a left angle bracket (\\<), followed immediately by the type name of the class or structure being instantiated."},{"content":"Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name=\"value\" pair.","pos":[4979,5165]},{"content":"Finally, one of the following must be true:","pos":[5166,5209]},{"content":"The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (&gt;).","pos":[5219,5327],"source":"The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>)."},{"content":"The opening tag must be completed by a right angle bracket (&gt;).","pos":[5337,5400],"source":"The opening tag must be completed by a right angle bracket (>)."},{"content":"Other object elements, property elements, or inner text, can follow the opening tag.","pos":[5401,5485]},{"content":"Exactly what content may be contained here is typically constrained by the object model of the element.","pos":[5486,5589]},{"content":"The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.","pos":[5590,5728]},{"content":"XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.","pos":[5735,5909]},{"content":"For WPF and the .NET Framework, XAML object elements map to <ph id=\"ph1\">[!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)]</ph> types as defined in referenced assemblies, and the attributes map to members of those types.","pos":[5910,6130],"source":" For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types."},{"content":"When you reference a CLR type in XAML, you have access to the inherited members of that type as well.","pos":[6131,6232]},{"pos":[6239,6493],"content":"For example, the following example is object element syntax that instantiates a new instance of the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> class, and also specifies a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> attribute and a value for that attribute:","source":"For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:"},{"content":"The following example is object element syntax that also includes XAML content property syntax.","pos":[6629,6724]},{"content":"The inner text contained within will be used to set the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> XAML content property, <ph id=\"ph2\">&lt;xref:System.Windows.Controls.TextBox.Text%2A&gt;</ph>.","pos":[6725,6890],"source":" The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>."},{"pos":[7041,7055],"content":"Content Models","linkify":"Content Models","nodes":[{"content":"Content Models","pos":[0,14]}]},{"content":"A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.","pos":[7059,7295]},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.MenuItem&gt;</ph> should typically only be placed as a child of a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Primitives.MenuBase&gt;</ph> derived class such as <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Menu&gt;</ph>.","pos":[7296,7508],"source":" For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>."},{"content":"Content models for specific elements are documented as part of the remarks on the class pages for controls and other <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> classes that can be used as XAML elements.","pos":[7509,7750],"source":" Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements."},{"pos":[7807,7836],"content":"Properties of Object Elements","linkify":"Properties of Object Elements","nodes":[{"content":"Properties of Object Elements","pos":[0,29]}]},{"content":"Properties in XAML are set by a variety of possible syntaxes.","pos":[7840,7901]},{"content":"Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.","pos":[7902,8053]},{"content":"By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.","pos":[8060,8183]},{"content":"The initial state of the created object from a object element is based on the default constructor behavior.","pos":[8184,8291]},{"content":"Typically, your application will use something other than a completely default instance of any given object.","pos":[8292,8400]},{"pos":[8455,8484],"content":"Attribute Syntax (Properties)","linkify":"Attribute Syntax (Properties)","nodes":[{"content":"Attribute Syntax (Properties)","pos":[0,29]}]},{"content":"Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.","pos":[8488,8620]},{"content":"The attribute name must match the CLR member name of the property of the class that backs the relevant object element.","pos":[8621,8739]},{"content":"The attribute name is followed by an assignment operator (=).","pos":[8740,8801]},{"content":"The attribute value must be a string enclosed within quotes.","pos":[8802,8862]},{"pos":[8870,9448],"content":"[!NOTE]\n You can use alternating quotes to place a literal quotation mark within an attribute. For instance you can use single quotes as a means to declare a string that contains a double quote character within it. Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string. There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax. See [XML Character Entities and XAML](../../xaml-services/xml-character-entities-and-xaml.md).","leadings":["","> "],"nodes":[{"content":"You can use alternating quotes to place a literal quotation mark within an attribute. For instance you can use single quotes as a means to declare a string that contains a double quote character within it. Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string. There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax. See [XML Character Entities and XAML](../../xaml-services/xml-character-entities-and-xaml.md).","pos":[9,576],"nodes":[{"content":"You can use alternating quotes to place a literal quotation mark within an attribute.","pos":[0,85]},{"content":"For instance you can use single quotes as a means to declare a string that contains a double quote character within it.","pos":[86,205]},{"content":"Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.","pos":[206,329]},{"content":"There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.","pos":[330,472]},{"content":"See <bpt id=\"p1\">[</bpt>XML Character Entities and XAML<ept id=\"p1\">](../../xaml-services/xml-character-entities-and-xaml.md)</ept>.","pos":[473,567],"source":" See [XML Character Entities and XAML](../../xaml-services/xml-character-entities-and-xaml.md)."}]}]},{"content":"In order to be set through attribute syntax, a property must be public and must be writeable.","pos":[9455,9548]},{"content":"The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.","pos":[9549,9752]},{"content":"For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.","pos":[9759,9873]},{"content":"The property or event must be a member of the class or structure that is instantiated by the containing object element.","pos":[9880,9999]},{"pos":[10009,10039],"content":"Processing of Attribute Values","linkify":"Processing of Attribute Values","nodes":[{"content":"Processing of Attribute Values","pos":[0,30]}]},{"content":"The string value contained within the opening and closing quotation marks is processed by a XAML processor.","pos":[10043,10150]},{"content":"For properties, the default processing behavior is determined by the type of the underlying CLR property.","pos":[10151,10256]},{"content":"The attribute value is filled by one of the following, using this processing order:","pos":[10263,10346]},{"content":"If the XAML processor encounters a curly brace, or an object element that derives from <ph id=\"ph1\">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.","pos":[10356,10660],"source":"If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value."},{"content":"In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.","pos":[10661,10855]},{"pos":[10865,11210],"content":"If the property is declared with an attributed <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph>, or the value type of that property is declared with an attributed <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.","source":"If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance."},{"content":"If there is no <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph>, a direct conversion to the property type is attempted.","pos":[11220,11333],"source":"If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted."},{"content":"This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).","pos":[11334,11549]},{"pos":[11560,11588],"content":"Enumeration Attribute Values","linkify":"Enumeration Attribute Values","nodes":[{"content":"Enumeration Attribute Values","pos":[0,28]}]},{"content":"Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.","pos":[11592,11786]},{"content":"For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.","pos":[11793,11940]},{"content":"You do not specify the enumeration in the format <bpt id=\"p1\">*</bpt>Enumeration<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>Value<ept id=\"p2\">*</ept>, as you do in code.","pos":[11941,12031],"source":" You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code."},{"content":"Instead, you specify only <bpt id=\"p1\">*</bpt>Value<ept id=\"p1\">*</ept>, and <bpt id=\"p2\">*</bpt>Enumeration<ept id=\"p2\">*</ept> is inferred by the type of the property you are setting.","pos":[12032,12141],"source":" Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting."},{"content":"If you specify an attribute in the <bpt id=\"p1\">*</bpt>Enumeration<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>Value<ept id=\"p2\">*</ept> form, it will not resolve correctly.","pos":[12142,12235],"source":" If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly."},{"content":"For flagwise enumerations, the behavior is based on the <ph id=\"ph1\">&lt;xref:System.Enum.Parse%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[12242,12362],"source":"For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method."},{"content":"You can specify multiple values for a flagwise enumeration by separating each value with a comma.","pos":[12363,12460]},{"content":"However, you cannot combine enumeration values that are not flagwise.","pos":[12461,12530]},{"content":"For instance, you cannot use the comma syntax to attempt to create a <ph id=\"ph1\">&lt;xref:System.Windows.Trigger&gt;</ph> that acts on multiple conditions of a nonflag enumeration:","pos":[12531,12688],"source":" For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:"},{"content":"Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.","pos":[12895,12983]},{"content":"However, one such enumeration is <ph id=\"ph1\">&lt;xref:System.Windows.Media.StyleSimulations&gt;</ph>.","pos":[12984,13062],"source":" However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>."},{"content":"You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <ph id=\"ph1\">&lt;xref:System.Windows.Documents.Glyphs&gt;</ph> class; <ph id=\"ph2\">`StyleSimulations = \"BoldSimulation\"`</ph> could become <ph id=\"ph3\">`StyleSimulations = \"BoldSimulation,ItalicSimulation\"`</ph>.","pos":[13063,13344],"source":" You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = \"BoldSimulation\"` could become `StyleSimulations = \"BoldSimulation,ItalicSimulation\"`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType&gt;</ph> is another property where more than one enumeration value can be specified.","pos":[13345,13501],"source":"<xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified."},{"content":"However, this property happens to be a special case, because the <ph id=\"ph1\">&lt;xref:System.Windows.Input.ModifierKeys&gt;</ph> enumeration supports its own type converter.","pos":[13502,13652],"source":" However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter."},{"content":"The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).","pos":[13653,13746]},{"content":"This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as \"Ctrl+Alt\".","pos":[13747,13883]},{"pos":[13893,13936],"content":"Properties and Event Member Name References","linkify":"Properties and Event Member Name References","nodes":[{"content":"Properties and Event Member Name References","pos":[0,43]}]},{"content":"When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.","pos":[13940,14101]},{"content":"Or, you can reference an attached property or attached event, independent of the containing object element.","pos":[14108,14215]},{"content":"(Attached properties are discussed in an upcoming section.)","pos":[14216,14275]},{"content":"You can also name any event from any object that is accessible through the default namespace by using a <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>event<ept id=\"p2\">*</ept> partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.","pos":[14282,14639],"source":"You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table."},{"content":"This syntax resembles an attached event syntax, but the event here is not a true attached event.","pos":[14640,14736]},{"content":"Instead, you are referencing an event with a qualified name.","pos":[14737,14797]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Routed Events Overview<ept id=\"p1\">](routed-events-overview.md)</ept>.","pos":[14798,14876],"source":" For more information, see [Routed Events Overview](routed-events-overview.md)."},{"content":"For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.","pos":[14883,15002]},{"content":"That property name can also include qualifiers, such as the property specified in the form <bpt id=\"p1\">*</bpt>ownerType<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>dependencyPropertyName<ept id=\"p2\">*</ept>.","pos":[15003,15131],"source":" That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*."},{"content":"This scenario is common when writing styles or templates in XAML.","pos":[15132,15197]},{"content":"The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.","pos":[15198,15388]},{"content":"For details, see <bpt id=\"p1\">[</bpt>Styling and Templating<ept id=\"p1\">](../controls/styling-and-templating.md)</ept>.","pos":[15389,15470],"source":" For details, see [Styling and Templating](../controls/styling-and-templating.md)."},{"content":"Another usage for property names is when an attribute value describes a property-property relationship.","pos":[15477,15580]},{"content":"This feature is used for data binding and for storyboard targets, and is enabled by the <ph id=\"ph1\">&lt;xref:System.Windows.PropertyPath&gt;</ph> class and its type converter.","pos":[15581,15733],"source":" This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter."},{"content":"For a more complete description of the lookup semantics, see <bpt id=\"p1\">[</bpt>PropertyPath XAML Syntax<ept id=\"p1\">](propertypath-xaml-syntax.md)</ept>.","pos":[15734,15851],"source":" For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md)."},{"pos":[15902,15925],"content":"Property Element Syntax","linkify":"Property Element Syntax","nodes":[{"content":"Property Element Syntax","pos":[0,23]}]},{"content":"<bpt id=\"p1\">*</bpt>Property element syntax<ept id=\"p1\">*</ept> is a syntax that diverges somewhat from the basic XML syntax rules for elements.","pos":[15929,16035],"source":"*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements."},{"content":"In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.","pos":[16036,16174]},{"content":"In XAML, you can assign other object elements to be the value of a property.","pos":[16175,16251]},{"content":"This capability is enabled by the property element syntax.","pos":[16252,16310]},{"content":"Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in <bpt id=\"p1\">*</bpt>elementTypeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>propertyName<ept id=\"p2\">*</ept> form, the value of the property is specified within, and then the property element is closed.","pos":[16311,16575],"source":" Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed."},{"content":"Specifically, the syntax begins with a left angle bracket (<ph id=\"ph1\">\\&lt;</ph>), followed immediately by the type name of the class or structure that the property element syntax is contained within.","pos":[16582,16763],"source":"Specifically, the syntax begins with a left angle bracket (\\<), followed immediately by the type name of the class or structure that the property element syntax is contained within."},{"content":"This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (&gt;).","pos":[16764,16880],"source":" This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>)."},{"content":"As with attribute syntax, that property must exist within the declared public members of the specified type.","pos":[16881,16989]},{"content":"The value to be assigned to the property is contained within the property element.","pos":[16990,17072]},{"content":"Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.","pos":[17073,17240]},{"content":"Finally, an equivalent closing tag specifying the same <bpt id=\"p1\">*</bpt>elementTypeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>propertyName<ept id=\"p2\">*</ept> combination must be provided, in proper nesting and balance with other element tags.","pos":[17241,17413],"source":" Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags."},{"pos":[17420,17588],"content":"For example, the following is property element syntax for the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> property of a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph>.","source":"For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>."},{"content":"The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <ph id=\"ph1\">&lt;xref:System.String&gt;</ph>, or an enumeration where a name is specified.","pos":[17730,17949],"source":"The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified."},{"content":"These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.","pos":[17950,18060]},{"content":"One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.","pos":[18061,18319]},{"content":"Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see <bpt id=\"p1\">[</bpt>White space processing in XAML<ept id=\"p1\">](../../xaml-services/whitespace-processing-in-xaml.md)</ept>).","pos":[18320,18561],"source":" Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../xaml-services/whitespace-processing-in-xaml.md))."},{"content":"Another scenario is so that <bpt id=\"p1\">[</bpt>x:Uid Directive<ept id=\"p1\">](../../xaml-services/x-uid-directive.md)</ept> can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.","pos":[18562,18800],"source":" Another scenario is so that [x:Uid Directive](../../xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques."},{"content":"A property element is not represented in the WPF logical tree.","pos":[18807,18869]},{"content":"A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.","pos":[18870,19005]},{"content":"(For details on the logical tree concept, see <bpt id=\"p1\">[</bpt>Trees in WPF<ept id=\"p1\">](trees-in-wpf.md)</ept>.)","pos":[19006,19085],"source":" (For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)"},{"content":"For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.","pos":[19092,19304]},{"pos":[19349,19366],"content":"Collection Syntax","linkify":"Collection Syntax","nodes":[{"content":"Collection Syntax","pos":[0,17]}]},{"content":"The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.","pos":[19370,19493]},{"content":"The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:","pos":[19494,19646]},{"pos":[19656,19704],"content":"Type implements <ph id=\"ph1\">&lt;xref:System.Collections.IList&gt;</ph>.","source":"Type implements <xref:System.Collections.IList>."},{"pos":[19714,19768],"content":"Type implements <ph id=\"ph1\">&lt;xref:System.Collections.IDictionary&gt;</ph>.","source":"Type implements <xref:System.Collections.IDictionary>."},{"pos":[19778,19941],"content":"Type derives from <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> (for more information about arrays in XAML, see <bpt id=\"p1\">[</bpt>x:Array Markup Extension<ept id=\"p1\">](../../xaml-services/x-array-markup-extension.md)</ept>.)","source":"Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)"},{"content":"If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.","pos":[19948,20090]},{"content":"Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.","pos":[20091,20237]},{"content":"Each such item is evaluated to an object during loading and added to the collection by calling the <ph id=\"ph1\">`Add`</ph> method of the implied collection.","pos":[20238,20376],"source":" Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Windows.Style.Triggers%2A&gt;</ph> property of <ph id=\"ph2\">&lt;xref:System.Windows.Style&gt;</ph> takes the specialized collection type <ph id=\"ph3\">&lt;xref:System.Windows.TriggerCollection&gt;</ph>, which implements <ph id=\"ph4\">&lt;xref:System.Collections.IList&gt;</ph>.","pos":[20377,20602],"source":" For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>."},{"content":"It is not necessary to instantiate a <ph id=\"ph1\">&lt;xref:System.Windows.TriggerCollection&gt;</ph> object element in the markup.","pos":[20603,20709],"source":" It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup."},{"content":"Instead, you specify one or more <ph id=\"ph1\">&lt;xref:System.Windows.Trigger&gt;</ph> items as elements within the <ph id=\"ph2\">`Style.Triggers`</ph> property element, where <ph id=\"ph3\">&lt;xref:System.Windows.Trigger&gt;</ph> (or a derived class) is the type expected as the item type for the strongly typed and implicit <ph id=\"ph4\">&lt;xref:System.Windows.TriggerCollection&gt;</ph>.","pos":[20710,21008],"source":" Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>."},{"content":"A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.","pos":[21164,21321]},{"content":"An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.","pos":[21328,21471]},{"content":"Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.","pos":[21472,21659]},{"pos":[21667,22158],"content":"[!NOTE]\n The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection. However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.","leadings":["","> "],"nodes":[{"content":"The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection. However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.","pos":[9,489],"nodes":[{"content":"The generic list and dictionary interfaces (<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>) are not supported for collection detection.","pos":[0,186],"source":"The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection."},{"content":"However, you can use the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class as a base class, because it implements <ph id=\"ph2\">&lt;xref:System.Collections.IList&gt;</ph> directly, or <ph id=\"ph3\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> as a base class, because it implements <ph id=\"ph4\">&lt;xref:System.Collections.IDictionary&gt;</ph> directly.","pos":[187,480],"source":" However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly."}]}]},{"content":"In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.","pos":[22165,22375]},{"content":"With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).","pos":[22382,22801]},{"content":"In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.","pos":[22802,23145]},{"content":"This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <ph id=\"ph1\">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>.","pos":[23146,23315],"source":" This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>."},{"pos":[23322,23471],"content":"The following example is a syntax with the object element for a collection (<ph id=\"ph1\">&lt;xref:System.Windows.Media.GradientStopCollection&gt;</ph>) specified explicitly.","source":"The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly."},{"content":"Note that it is not always possible to explicitly declare the collection.","pos":[23791,23864]},{"content":"For instance, attempting to declare <ph id=\"ph1\">&lt;xref:System.Windows.TriggerCollection&gt;</ph> explicitly in the previously shown <ph id=\"ph2\">&lt;xref:System.Windows.Style.Triggers%2A&gt;</ph> example would fail.","pos":[23865,24035],"source":" For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail."},{"content":"Explicitly declaring the collection requires that the collection class must support a default constructor, and <ph id=\"ph1\">&lt;xref:System.Windows.TriggerCollection&gt;</ph> does not have a default constructor.","pos":[24036,24223],"source":" Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor."},{"pos":[24274,24297],"content":"XAML Content Properties","linkify":"XAML Content Properties","nodes":[{"content":"XAML Content Properties","pos":[0,23]}]},{"content":"XAML content syntax is a syntax that is only enabled on classes that specify the <ph id=\"ph1\">&lt;xref:System.Windows.Markup.ContentPropertyAttribute&gt;</ph> as part of their class declaration.","pos":[24301,24471],"source":"XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Markup.ContentPropertyAttribute&gt;</ph> references the property name that is the content property for that type of element (including derived classes).","pos":[24472,24641],"source":" The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes)."},{"content":"When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.","pos":[24642,24863]},{"content":"You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.","pos":[24864,25034]},{"content":"The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.","pos":[25035,25296]},{"content":"Property element tags for other properties on an element are not assigned as \"content\" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be \"content\".","pos":[25297,25530]},{"pos":[25540,25587],"content":"XAML Content Property Values Must Be Contiguous","linkify":"XAML Content Property Values Must Be Contiguous","nodes":[{"content":"XAML Content Property Values Must Be Contiguous","pos":[0,47]}]},{"content":"The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.","pos":[25591,25734]},{"content":"This is true whether the value of a XAML content property is specified as a string, or as one or more objects.","pos":[25735,25845]},{"content":"For example, the following markup does not parse:","pos":[25846,25895]},{"content":"This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:","pos":[26008,26182]},{"content":"A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:","pos":[26373,26504]},{"pos":[26816,26865],"content":"Content Properties and Collection Syntax Combined","linkify":"Content Properties and Collection Syntax Combined","nodes":[{"content":"Content Properties and Collection Syntax Combined","pos":[0,49]}]},{"content":"In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.","pos":[26869,27006]},{"content":"Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.","pos":[27007,27127]},{"content":"If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.","pos":[27128,27409]},{"content":"Therefore the apparent content model in the markup can now have more than one child element assigned as the content.","pos":[27410,27526]},{"content":"The following is content syntax for a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Panel&gt;</ph> derived class.","pos":[27527,27616],"source":" The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class."},{"content":"All <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Panel&gt;</ph> derived classes establish the XAML content property to be <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Panel.Children%2A&gt;</ph>, which requires a value of type <ph id=\"ph3\">&lt;xref:System.Windows.Controls.UIElementCollection&gt;</ph>.","pos":[27617,27848],"source":" All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>."},{"content":"Note that neither the property element for <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Panel.Children%2A&gt;</ph> nor the element for the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.UIElementCollection&gt;</ph> is required in the markup.","pos":[27994,28187],"source":"Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup."},{"content":"This is a design feature of XAML so that recursively contained elements that define a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.","pos":[28188,28519],"source":" This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects."},{"content":"In fact, <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UIElementCollection&gt;</ph> cannot be specified explicitly in markup as an object element, by design.","pos":[28520,28653],"source":" In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design."},{"content":"Because its only intended use is as an implicit collection, <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UIElementCollection&gt;</ph> does not expose a public default constructor and thus cannot be instantiated as an object element.","pos":[28654,28863],"source":" Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element."},{"pos":[28873,28954],"content":"Mixing Property Elements and Object Elements in an Object with a Content Property","linkify":"Mixing Property Elements and Object Elements in an Object with a Content Property","nodes":[{"content":"Mixing Property Elements and Object Elements in an Object with a Content Property","pos":[0,81]}]},{"content":"The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.","pos":[28958,29160]},{"content":"This restriction against mixing property elements and content is enforced by the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> XAML processors.","pos":[29161,29340],"source":" This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors."},{"content":"You can have a child object element as the first immediate markup within an object element.","pos":[29347,29438]},{"content":"Then you can introduce property elements.","pos":[29439,29480]},{"content":"Or, you can specify one or more property elements, then content, then more property elements.","pos":[29481,29574]},{"content":"But once a property element follows content, you cannot introduce any further content, you can only add property elements.","pos":[29575,29697]},{"content":"This content / property element order requirement does not apply to inner text used as content.","pos":[29704,29799]},{"content":"However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.","pos":[29800,30009]},{"pos":[30052,30067],"content":"XAML Namespaces","linkify":"XAML Namespaces","nodes":[{"content":"XAML Namespaces","pos":[0,15]}]},{"content":"None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.","pos":[30071,30174]},{"content":"In typical <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications, the default XAML namespace is specified to be the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> namespace.","pos":[30175,30424],"source":" In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace."},{"content":"You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.","pos":[30425,30524]},{"content":"But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.","pos":[30525,30741]},{"content":"For example, <ph id=\"ph1\">`&lt;custom:Example/&gt;`</ph> is object element syntax to instantiate an instance of the <ph id=\"ph2\">`Example`</ph> class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the <ph id=\"ph3\">`custom`</ph> prefix.","pos":[30742,31019],"source":" For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix."},{"pos":[31026,31182],"content":"For more information about XAML namespaces, see <bpt id=\"p1\">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id=\"p1\">](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.","source":"For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)."},{"pos":[31227,31244],"content":"Markup Extensions","linkify":"Markup Extensions","nodes":[{"content":"Markup Extensions","pos":[0,17]}]},{"content":"XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.","pos":[31248,31454]},{"content":"The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).","pos":[31455,31647]},{"content":"The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring \"Extension\" if that substring is part of the true class name.","pos":[31648,31877]},{"content":"Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.","pos":[31878,32050]},{"content":"The .NET XAML implementation uses the <ph id=\"ph1\">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph> abstract class as the basis for all of the markup extensions supported by <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> as well as other frameworks or technologies.","pos":[32057,32340],"source":"The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies."},{"content":"The markup extensions that <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.","pos":[32341,32626],"source":" The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time."},{"content":"For example, a simple WPF data binding is accomplished by specifying the <ph id=\"ph1\">`{Binding}`</ph> markup extension in place of the value that a particular property would ordinarily take.","pos":[32627,32800],"source":" For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take."},{"content":"Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.","pos":[32801,32935]},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Windows.Style&gt;</ph> object is a relatively complex type that contains a nested series of objects and properties.","pos":[32936,33071],"source":" For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties."},{"content":"Styles in WPF are typically defined as a resource in a <ph id=\"ph1\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>, and then referenced through one of the two WPF markup extensions that request a resource.","pos":[33072,33258],"source":" Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource."},{"content":"The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property, taking type <ph id=\"ph2\">&lt;xref:System.Windows.Style&gt;</ph>, in attribute syntax as in the following example:","pos":[33259,33531],"source":" The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:"},{"content":"Here, <ph id=\"ph1\">`StaticResource`</ph> identifies the <ph id=\"ph2\">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph> class providing the markup extension implementation.","pos":[33606,33742],"source":"Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation."},{"content":"The next string <ph id=\"ph1\">`MyStyle`</ph> is used as the input for the non-default <ph id=\"ph2\">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph> constructor, where the parameter as taken from the extension string declares the requested <ph id=\"ph3\">&lt;xref:System.Windows.ResourceKey&gt;</ph>.","pos":[33743,33981],"source":" The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>."},{"content":"<ph id=\"ph1\">`MyStyle`</ph> is expected to be the <bpt id=\"p1\">[</bpt>x:Key<ept id=\"p1\">](../../xaml-services/x-key-directive.md)</ept> value of a <ph id=\"ph2\">&lt;xref:System.Windows.Style&gt;</ph> defined as a resource.","pos":[33982,34123],"source":"`MyStyle` is expected to be the [x:Key](../../xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource."},{"content":"The <bpt id=\"p1\">[</bpt>StaticResource Markup Extension<ept id=\"p1\">](staticresource-markup-extension.md)</ept> usage requests that the resource be used to provide the <ph id=\"ph1\">&lt;xref:System.Windows.Style&gt;</ph> property value through static resource lookup logic at load time.","pos":[34124,34347],"source":" The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time."},{"content":"For more information about markup extensions, see <bpt id=\"p1\">[</bpt>Markup Extensions and WPF XAML<ept id=\"p1\">](markup-extensions-and-wpf-xaml.md)</ept>.","pos":[34354,34472],"source":"For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md)."},{"content":"For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see <bpt id=\"p1\">[</bpt>XAML Namespace (x:) Language Features<ept id=\"p1\">](../../xaml-services/xaml-namespace-x-language-features.md)</ept>.","pos":[34473,34698],"source":" For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md)."},{"content":"For WPF-specific markup extensions, see <bpt id=\"p1\">[</bpt>WPF XAML Extensions<ept id=\"p1\">](wpf-xaml-extensions.md)</ept>.","pos":[34699,34785],"source":" For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md)."},{"pos":[34832,34851],"content":"Attached Properties","linkify":"Attached Properties","nodes":[{"content":"Attached Properties","pos":[0,19]}]},{"content":"Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.","pos":[34855,35044]},{"content":"The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.","pos":[35045,35273]},{"content":"Conversely, attached properties can be used by parent elements to report information to child elements.","pos":[35274,35377]},{"content":"For more information on the purpose of attached properties and how to create your own attached properties, see <bpt id=\"p1\">[</bpt>Attached Properties Overview<ept id=\"p1\">](attached-properties-overview.md)</ept>.","pos":[35378,35553],"source":" For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md)."},{"content":"Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>propertyName<ept id=\"p2\">*</ept> combination.","pos":[35560,35712],"source":"Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination."},{"content":"There are two important differences:","pos":[35713,35749]},{"content":"You can use the <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>propertyName<ept id=\"p2\">*</ept> combination even when setting an attached property through attribute syntax.","pos":[35759,35877],"source":"You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax."},{"content":"Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.","pos":[35878,35991]},{"content":"You can also use property element syntax for attached properties.","pos":[36001,36066]},{"content":"However, for typical property element syntax, the <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept> you specify is the object element that contains the property element.","pos":[36067,36197],"source":" However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element."},{"content":"If you are referring to an attached property, then the <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept> is the class that defines the attached property, not the containing object element.","pos":[36198,36347],"source":" If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element."},{"pos":[36390,36405],"content":"Attached Events","linkify":"Attached Events","nodes":[{"content":"Attached Events","pos":[0,15]}]},{"content":"Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.","pos":[36409,36575]},{"content":"In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.","pos":[36576,36795]},{"content":"Handlers for attached events are specified through attribute syntax.","pos":[36796,36864]},{"content":"As with attached events, the attribute syntax is expanded for attached events to allow a <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>eventName<ept id=\"p2\">*</ept> usage, where <bpt id=\"p3\">*</bpt>typeName<ept id=\"p3\">*</ept> is the class that provides <ph id=\"ph1\">`Add`</ph> and <ph id=\"ph2\">`Remove`</ph> event handler accessors for the attached event infrastructure, and <bpt id=\"p4\">*</bpt>eventName<ept id=\"p4\">*</ept> is the event name.","pos":[36865,37144],"source":" As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name."},{"pos":[37207,37237],"content":"Anatomy of a XAML Root Element","linkify":"Anatomy of a XAML Root Element","nodes":[{"content":"Anatomy of a XAML Root Element","pos":[0,30]}]},{"content":"The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:","pos":[37241,37358]},{"content":"Opening object element of the root element","pos":[37387,37429]},{"pos":[37502,37612],"content":"The default (<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>) XAML namespace","source":"The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace"},{"content":"The XAML language XAML namespace","pos":[37674,37706]},{"content":"The partial class declaration that connects markup to any code-behind defined for the partial class","pos":[37752,37851]},{"content":"End of object element for the root.","pos":[37860,37895]},{"content":"Object is not closed yet because the element contains child elements","pos":[37896,37964]},{"pos":[38032,38071],"content":"Optional and Nonrecommended XAML Usages","linkify":"Optional and Nonrecommended XAML Usages","nodes":[{"content":"Optional and Nonrecommended XAML Usages","pos":[0,39]}]},{"content":"The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.","pos":[38075,38335]},{"pos":[38345,38377],"content":"Optional Property Element Usages","linkify":"Optional Property Element Usages","nodes":[{"content":"Optional Property Element Usages","pos":[0,32]}]},{"content":"Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.","pos":[38381,38515]},{"content":"For example, when you declare the contents of a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Menu&gt;</ph>, you could choose to explicitly declare the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> collection of the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Menu&gt;</ph> as a <ph id=\"ph4\">`&lt;Menu.Items&gt;`</ph> property element tag, and place each <ph id=\"ph5\">&lt;xref:System.Windows.Controls.MenuItem&gt;</ph> within <ph id=\"ph6\">`&lt;Menu.Items&gt;`</ph>, rather than using the implicit XAML processor behavior that all child elements of a <ph id=\"ph7\">&lt;xref:System.Windows.Controls.Menu&gt;</ph> must be a <ph id=\"ph8\">&lt;xref:System.Windows.Controls.MenuItem&gt;</ph> and are placed in the <ph id=\"ph9\">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> collection.","pos":[38516,39127],"source":" For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection."},{"content":"Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.","pos":[39128,39237]},{"content":"Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.","pos":[39238,39417]},{"pos":[39427,39472],"content":"Full typeName.memberName Qualified Attributes","linkify":"Full typeName.memberName Qualified Attributes","nodes":[{"content":"Full typeName.memberName Qualified Attributes","pos":[0,45]}]},{"content":"The <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>memberName<ept id=\"p2\">*</ept> form for an attribute actually works more universally than just the routed event case.","pos":[39476,39590],"source":"The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case."},{"content":"But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.","pos":[39591,39717]},{"content":"In the following example, each of the three references to the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> attribute are completely equivalent:","pos":[39718,39869],"source":" In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:"},{"content":"<ph id=\"ph1\">`Button.Background`</ph> works because the qualified lookup for that property on <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph> is successful (<ph id=\"ph3\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> was inherited from Control) and <ph id=\"ph4\">&lt;xref:System.Windows.Controls.Button&gt;</ph> is the class of the object element or a base class.","pos":[40013,40316],"source":"`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class."},{"content":"<ph id=\"ph1\">`Control.Background`</ph> works because the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control&gt;</ph> class actually defines <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Windows.Controls.Control&gt;</ph> is a <ph id=\"ph5\">&lt;xref:System.Windows.Controls.Button&gt;</ph> base class.","pos":[40317,40568],"source":"`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class."},{"pos":[40575,40677],"content":"However, the following <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>memberName<ept id=\"p2\">*</ept> form example does not work and is thus shown commented:","source":"However, the following *typeName*.*memberName* form example does not work and is thus shown commented:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Controls.Label&gt;</ph> is another derived class of <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control&gt;</ph>, and if you had specified <ph id=\"ph3\">`Label.Background`</ph> within a <ph id=\"ph4\">&lt;xref:System.Windows.Controls.Label&gt;</ph> object element, this usage would have worked.","pos":[40827,41067],"source":"<xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked."},{"content":"However, because <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Label&gt;</ph> is not the class or base class of <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph>, the specified XAML processor behavior is to then process <ph id=\"ph3\">`Label.Background`</ph> as an attached property.","pos":[41068,41295],"source":" However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property."},{"content":"<ph id=\"ph1\">`Label.Background`</ph> is not an available attached property, and this usage fails.","pos":[41296,41375],"source":"`Label.Background` is not an available attached property, and this usage fails."},{"pos":[41385,41426],"content":"baseTypeName.memberName Property Elements","linkify":"baseTypeName.memberName Property Elements","nodes":[{"content":"baseTypeName.memberName Property Elements","pos":[0,41]}]},{"content":"In an analogous way to how the <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>memberName<ept id=\"p2\">*</ept> form works for attribute syntax, a <bpt id=\"p3\">*</bpt>baseTypeName<ept id=\"p3\">*</ept>.<bpt id=\"p4\">*</bpt>memberName<ept id=\"p4\">*</ept> syntax works for property element syntax.","pos":[41430,41589],"source":"In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax."},{"content":"For instance, the following syntax works:","pos":[41590,41631]},{"pos":[41765,41885],"content":"Here, the property element was given as <ph id=\"ph1\">`Control.Background`</ph> even though the property element was contained in <ph id=\"ph2\">`Button`</ph>.","source":"Here, the property element was given as `Control.Background` even though the property element was contained in `Button`."},{"pos":[41892,42028],"content":"But just like <bpt id=\"p1\">*</bpt>typeName<ept id=\"p1\">*</ept>.<bpt id=\"p2\">*</bpt>memberName<ept id=\"p2\">*</ept> form for attributes, <bpt id=\"p3\">*</bpt>baseTypeName<ept id=\"p3\">*</ept>.<bpt id=\"p4\">*</bpt>memberName<ept id=\"p4\">*</ept> is poor style in markup, and you should avoid it.","source":"But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it."},{"pos":[42037,42045],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[42049,42092],"content":"<bpt id=\"p1\">[</bpt>XAML Overview (WPF)<ept id=\"p1\">](xaml-overview-wpf.md)</ept>","source":"[XAML Overview (WPF)](xaml-overview-wpf.md)"},{"pos":[42095,42193],"content":"<bpt id=\"p1\">[</bpt>XAML Namespace (x:) Language Features<ept id=\"p1\">](../../xaml-services/xaml-namespace-x-language-features.md)</ept>","source":"[XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md)"},{"pos":[42196,42241],"content":"<bpt id=\"p1\">[</bpt>WPF XAML Extensions<ept id=\"p1\">](wpf-xaml-extensions.md)</ept>","source":"[WPF XAML Extensions](wpf-xaml-extensions.md)"},{"pos":[42244,42311],"content":"<bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](dependency-properties-overview.md)</ept>","source":"[Dependency Properties Overview](dependency-properties-overview.md)"},{"pos":[42314,42367],"content":"<bpt id=\"p1\">[</bpt>TypeConverters and XAML<ept id=\"p1\">](typeconverters-and-xaml.md)</ept>","source":"[TypeConverters and XAML](typeconverters-and-xaml.md)"},{"pos":[42370,42439],"content":"<bpt id=\"p1\">[</bpt>XAML and Custom Classes for WPF<ept id=\"p1\">](xaml-and-custom-classes-for-wpf.md)</ept>","source":"[XAML and Custom Classes for WPF](xaml-and-custom-classes-for-wpf.md)"}]}