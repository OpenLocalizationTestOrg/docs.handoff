{"content":"---\ntitle: \"ICorProfilerCallback2::SurvivingReferences Method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\napi_name: \n  - \"ICorProfilerCallback2.SurvivingReferences\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences method [.NET Framework profiling]\"\n  - \"SurvivingReferences method [.NET Framework profiling]\"\nms.assetid: f165200e-3a91-47f7-88fc-13ff10c8babc\ntopic_type: \n  - \"apiref\"\ncaps.latest.revision: 16\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# ICorProfilerCallback2::SurvivingReferences Method\nReports the layout of objects in the heap as a result of a non-compacting garbage collection.  \n  \n## Syntax  \n  \n```  \nHRESULT SurvivingReferences(  \n    [in] ULONG  cSurvivingObjectIDRanges,  \n    [in, size_is(cSurvivingObjectIDRanges)] ObjectID  \n                objectIDRangeStart[] ,  \n    [in, size_is(cSurvivingObjectIDRanges)] ULONG  \n                cObjectIDRangeLength[] );  \n```  \n  \n#### Parameters  \n `cSurvivingObjectIDRanges`  \n [in] The number of blocks of contiguous objects that survived as the result of the non-compacting garbage collection. That is, the value of `cSurvivingObjectIDRanges` is the size of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays, which store an `ObjectID` and a length, respectively, for each block of objects.  \n  \n The next two arguments of `SurvivingReferences` are parallel arrays. In other words, `objectIDRangeStart` and `cObjectIDRangeLength` concern the same block of contiguous objects.  \n  \n `objectIDRangeStart`  \n [in] An array of `ObjectID` values, each of which is the starting address of a block of contiguous, live objects in memory.  \n  \n `cObjectIDRangeLength`  \n [in] An array of integers, each of which is the size of a surviving block of contiguous objects in memory.  \n  \n A size is specified for each block that is referenced in the `objectIDRangeStart` array.  \n  \n## Remarks  \n  \n> [!IMPORTANT]\n>  This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms. For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead.  \n  \n The elements of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays should be interpreted as follows to determine whether an object survived the garbage collection. Assume that an `ObjectID` value (`ObjectID`) lies within the following range:  \n  \n `ObjectIDRangeStart[i]` <= `ObjectID` < `ObjectIDRangeStart[i]` + `cObjectIDRangeLength[i]`  \n  \n For any value of `i` that is in the following range, the object has survived the garbage collection:  \n  \n 0 <= `i` < `cSurvivingObjectIDRanges`  \n  \n A non-compacting garbage collection reclaims the memory occupied by \"dead\" objects, but does not compact that freed space. As a result, memory is returned to the heap, but no \"live\" objects are moved.  \n  \n The common language runtime (CLR) calls `SurvivingReferences` for non-compacting garbage collections. For compacting garbage collections, [ICorProfilerCallback::MovedReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-movedreferences-method.md) is called instead. A single garbage collection can be compacting for one generation and non-compacting for another. For a garbage collection on any particular generation, the profiler will receive either a `SurvivingReferences` callback or a `MovedReferences` callback, but not both.  \n  \n Multiple `SurvivingReferences` callbacks might be received during a particular garbage collection, due to limited internal buffering, multiple threads reporting in the case of server garbage collection, and other reasons. In the case of multiple callbacks during a garbage collection, the information is cumulative — all references that are reported in any `SurvivingReferences` callback survive the garbage collection.  \n  \n## Requirements  \n **Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).  \n  \n **Header:** CorProf.idl, CorProf.h  \n  \n **Library:** CorGuids.lib  \n  \n **.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]  \n  \n## See Also  \n [ICorProfilerCallback Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)   \n [ICorProfilerCallback2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)   \n [SurvivingReferences2 Method](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)","nodes":[{"pos":[4,764],"embed":true,"restype":"x-metadata","content":"title: \"ICorProfilerCallback2::SurvivingReferences Method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\napi_name: \n  - \"ICorProfilerCallback2.SurvivingReferences\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences method [.NET Framework profiling]\"\n  - \"SurvivingReferences method [.NET Framework profiling]\"\nms.assetid: f165200e-3a91-47f7-88fc-13ff10c8babc\ntopic_type: \n  - \"apiref\"\ncaps.latest.revision: 16\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","nodes":[{"content":"ICorProfilerCallback2::SurvivingReferences Method | Microsoft Docs","nodes":[{"pos":[0,66],"content":"ICorProfilerCallback2::SurvivingReferences Method | Microsoft Docs","nodes":[{"content":"ICorProfilerCallback2::SurvivingReferences Method | Microsoft Docs","pos":[0,66]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[771,820],"content":"ICorProfilerCallback2::SurvivingReferences Method","linkify":"ICorProfilerCallback2::SurvivingReferences Method","nodes":[{"content":"ICorProfilerCallback2::SurvivingReferences Method","pos":[0,49]}]},{"content":"Reports the layout of objects in the heap as a result of a non-compacting garbage collection.","pos":[821,914]},{"pos":[923,929],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1222,1232],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] The number of blocks of contiguous objects that survived as the result of the non-compacting garbage collection.","pos":[1266,1383]},{"content":"That is, the value of <ph id=\"ph1\">`cSurvivingObjectIDRanges`</ph> is the size of the <ph id=\"ph2\">`objectIDRangeStart`</ph> and <ph id=\"ph3\">`cObjectIDRangeLength`</ph> arrays, which store an <ph id=\"ph4\">`ObjectID`</ph> and a length, respectively, for each block of objects.","pos":[1384,1588],"source":" That is, the value of `cSurvivingObjectIDRanges` is the size of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays, which store an `ObjectID` and a length, respectively, for each block of objects."},{"content":"The next two arguments of <ph id=\"ph1\">`SurvivingReferences`</ph> are parallel arrays.","pos":[1595,1663],"source":"The next two arguments of `SurvivingReferences` are parallel arrays."},{"content":"In other words, <ph id=\"ph1\">`objectIDRangeStart`</ph> and <ph id=\"ph2\">`cObjectIDRangeLength`</ph> concern the same block of contiguous objects.","pos":[1664,1773],"source":" In other words, `objectIDRangeStart` and `cObjectIDRangeLength` concern the same block of contiguous objects."},{"content":"[in] An array of <ph id=\"ph1\">`ObjectID`</ph> values, each of which is the starting address of a block of contiguous, live objects in memory.","pos":[1804,1927],"source":"[in] An array of `ObjectID` values, each of which is the starting address of a block of contiguous, live objects in memory."},{"content":"[in] An array of integers, each of which is the size of a surviving block of contiguous objects in memory.","pos":[1960,2066]},{"pos":[2073,2161],"content":"A size is specified for each block that is referenced in the <ph id=\"ph1\">`objectIDRangeStart`</ph> array.","source":"A size is specified for each block that is referenced in the `objectIDRangeStart` array."},{"pos":[2170,2177],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2185,2515],"content":"[!IMPORTANT]\n This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms. For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead.","leadings":["","> "],"nodes":[{"content":"This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms. For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead.","pos":[14,328],"nodes":[{"content":"This method reports sizes as <ph id=\"ph1\">`MAX_ULONG`</ph> for objects that are greater than 4 GB on 64-bit platforms.","pos":[0,100],"source":"This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms."},{"content":"For objects that are larger than 4 GB, use the <bpt id=\"p1\">[</bpt>ICorProfilerCallback4::SurvivingReferences2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)</ept> method instead.","pos":[101,314],"source":" For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead."}]}]},{"content":"The elements of the <ph id=\"ph1\">`objectIDRangeStart`</ph> and <ph id=\"ph2\">`cObjectIDRangeLength`</ph> arrays should be interpreted as follows to determine whether an object survived the garbage collection.","pos":[2522,2693],"source":"The elements of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays should be interpreted as follows to determine whether an object survived the garbage collection."},{"content":"Assume that an <ph id=\"ph1\">`ObjectID`</ph> value (<ph id=\"ph2\">`ObjectID`</ph>) lies within the following range:","pos":[2694,2771],"source":" Assume that an `ObjectID` value (`ObjectID`) lies within the following range:"},{"pos":[2876,2976],"content":"For any value of <ph id=\"ph1\">`i`</ph> that is in the following range, the object has survived the garbage collection:","source":"For any value of `i` that is in the following range, the object has survived the garbage collection:"},{"pos":[2983,3020],"content":"0 &lt;= <ph id=\"ph1\">`i`</ph><ph id=\"ph2\"> &lt; </ph><ph id=\"ph3\">`cSurvivingObjectIDRanges`</ph>","source":"0 <= `i` < `cSurvivingObjectIDRanges`"},{"content":"A non-compacting garbage collection reclaims the memory occupied by \"dead\" objects, but does not compact that freed space.","pos":[3027,3149]},{"content":"As a result, memory is returned to the heap, but no \"live\" objects are moved.","pos":[3150,3227]},{"content":"The common language runtime (CLR) calls <ph id=\"ph1\">`SurvivingReferences`</ph> for non-compacting garbage collections.","pos":[3234,3335],"source":"The common language runtime (CLR) calls `SurvivingReferences` for non-compacting garbage collections."},{"content":"For compacting garbage collections, <bpt id=\"p1\">[</bpt>ICorProfilerCallback::MovedReferences<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-movedreferences-method.md)</ept> is called instead.","pos":[3336,3529],"source":" For compacting garbage collections, [ICorProfilerCallback::MovedReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-movedreferences-method.md) is called instead."},{"content":"A single garbage collection can be compacting for one generation and non-compacting for another.","pos":[3530,3626]},{"content":"For a garbage collection on any particular generation, the profiler will receive either a <ph id=\"ph1\">`SurvivingReferences`</ph> callback or a <ph id=\"ph2\">`MovedReferences`</ph> callback, but not both.","pos":[3627,3794],"source":" For a garbage collection on any particular generation, the profiler will receive either a `SurvivingReferences` callback or a `MovedReferences` callback, but not both."},{"content":"Multiple <ph id=\"ph1\">`SurvivingReferences`</ph> callbacks might be received during a particular garbage collection, due to limited internal buffering, multiple threads reporting in the case of server garbage collection, and other reasons.","pos":[3801,4022],"source":"Multiple `SurvivingReferences` callbacks might be received during a particular garbage collection, due to limited internal buffering, multiple threads reporting in the case of server garbage collection, and other reasons."},{"content":"In the case of multiple callbacks during a garbage collection, the information is cumulative — all references that are reported in any <ph id=\"ph1\">`SurvivingReferences`</ph> callback survive the garbage collection.","pos":[4023,4220],"source":" In the case of multiple callbacks during a garbage collection, the information is cumulative — all references that are reported in any `SurvivingReferences` callback survive the garbage collection."},{"pos":[4229,4241],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[4245,4349],"content":"<bpt id=\"p1\">**</bpt>Platforms:<ept id=\"p1\">**</ept> See <bpt id=\"p2\">[</bpt>System Requirements<ept id=\"p2\">](../../../../docs/framework/get-started/system-requirements.md)</ept>.","source":"**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md)."},{"pos":[4356,4390],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> CorProf.idl, CorProf.h","source":"**Header:** CorProf.idl, CorProf.h"},{"pos":[4397,4422],"content":"<bpt id=\"p1\">**</bpt>Library:<ept id=\"p1\">**</ept> CorGuids.lib","source":"**Library:** CorGuids.lib"},{"pos":[4429,4457],"content":"<bpt id=\"p1\">**</bpt>.NET Framework Versions:<ept id=\"p1\">**</ept>","source":"**.NET Framework Versions:**"},{"pos":[4546,4554],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept><ph id=\"ph1\"> </ph>","pos":[4558,4677],"source":"[ICorProfilerCallback Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) "},{"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback2 Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept><ph id=\"ph1\"> </ph>","pos":[4681,4802],"source":"[ICorProfilerCallback2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) "},{"content":"<bpt id=\"p1\">[</bpt>SurvivingReferences2 Method<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)</ept>","pos":[4806,4940],"source":"[SurvivingReferences2 Method](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)"}]}