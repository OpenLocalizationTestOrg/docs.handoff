<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="index.md" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6b131d073e10f99feaf770fe5fd3c393551fa5a3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\arrays\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">p1-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5ea94e7794bdbac475daee05846679472ae17f7</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8caf4e8b33bdadfa12cb10149699272e954c8791</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Arrays in Visual Basic</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Arrays in Visual Basic</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An array is a set of values, which are termed <bpt id="p1">*</bpt>elements<ept id="p1">*</ept>, that are logically related to each other.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For example, an array may consist of the number of students in each grade in a grammar school; each element of the array is the number of students in a single grade.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Similarly, an array may consist of a student's grades for a class; each element of the array is a single grade.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It is possible individual variables to store each of our data items.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, if our application analyzes student grades, we can use a separate variable for each student's grade, such as <ph id="ph1">`englishGrade1`</ph>, <ph id="ph2">`englishGrade2`</ph>, etc. This approach has three major limitations:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>We have to know at design time exactly how many grades we have to handle.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Handling large numbers of grades quickly becomes unwieldy.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This in turn makes an application much more likely to have serious bugs.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>It is difficult to maintain.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Each new grade that we add requires that the application be modified, recompiled, and redeployed.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>By using an array, you can refer to these related values by the same name, and use a number that’s called an <bpt id="p1">*</bpt>index<ept id="p1">*</ept> or <bpt id="p2">*</bpt>subscript<ept id="p2">*</ept> to identify an individual element based on its position in the array.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The indexes of an array range from 0 to one less than the total number of elements in the array.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>When you use Visual Basic syntax to define the size of an array, you specify its highest index, not the total number of elements in the array.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can work with the array as a unit, and the ability to iterate its elements frees you from needing to know exactly how many elements it contains at design time.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Some quick examples before explanation:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Array elements in a simple array</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Let's create an array named <ph id="ph1">`students`</ph> to store the number of students in each grade in a grammar school.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The indexes of the elements range from 0 through 6.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Using this array is simpler than declaring seven variables.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following illustration shows the <ph id="ph1">`students`</ph> array.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For each element of the array:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The index of the element represents the grade (index 0 represents kindergarten).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The value that’s contained in the element represents the number of students in that grade.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Diagram showing an array of the numbers of students</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following example contains the Visual Basic code that creates and uses the array:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The example does three things:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It declares a <ph id="ph1">`students`</ph> array with seven elements.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The number <ph id="ph1">`6`</ph> in the array declaration indicates the last index in the array; it is one less than the number of elements in the array.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>It assigns values to each element in the array.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Array elements are accessed by using the array name and including the index of the individual element in parentheses.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>It lists each value of the array.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The example uses a <bpt id="p1">[</bpt><ph id="ph1">`For`</ph><ept id="p1">](../../../language-reference/statements/for-next-statement.md)</ept> statement to access each element of the array by its index number.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`students`</ph> array in the preceding example is a one-dimensional array because it uses one index.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>An array that uses more than one index or subscript is called <bpt id="p1">*</bpt>multidimensional<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For more information, see the rest of this article and <bpt id="p1">[</bpt>Array Dimensions in Visual Basic<ept id="p1">](../../language-features/arrays/array-dimensions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Creating an array</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You can define the size of an array in several ways:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can specify the size when the array is declared:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You can use a <ph id="ph1">`New`</ph> clause to supply the size of an array when it’s created:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you have an existing array, you can redefine its size by using the <bpt id="p1">[</bpt><ph id="ph1">`ReDim`</ph><ept id="p1">](../../../language-reference/statements/redim-statement.md)</ept> statement.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can specify that the <ph id="ph1">`ReDim`</ph> statement keep the values that are in the array, or you can specify that it create an empty array.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following example shows different uses of the <ph id="ph1">`ReDim`</ph> statement to modify the size of an existing array.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>ReDim Statement<ept id="p1">](../../../language-reference/statements/redim-statement.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Storing values in an array</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can access each location in an array by using an index of type <ph id="ph1">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can store and retrieve values in an array by referencing each array location by using its index enclosed in parentheses.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Indexes for multidimensional arrays are separated by commas (,).</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You need one index for each array dimension.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example shows some statements that store and retrieve values in arrays.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Populating an array with array literals</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>By using an array literal, you can populate an array with an initial set of values at the same time that you create it.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>An array literal consists of a list of comma-separated values that are enclosed in braces (<ph id="ph1">`{}`</ph>).</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>When you create an array by using an array literal, you can either supply the array type or use type inference to determine the array type.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example shows both options.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When you use type inference, the type of the array is determined by the <bpt id="p1">*</bpt>dominant type<ept id="p1">*</ept> in the list of literal values.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The dominant type is the type to which all other types in the array can widen.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If this unique type can’t be determined, the dominant type is the unique type to which all other types in the array can narrow.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If neither of these unique types can be determined, the dominant type is <ph id="ph1">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For example, if the list of values that’s supplied to the array literal contains values of type <ph id="ph1">`Integer`</ph>, <ph id="ph2">`Long`</ph>, and <ph id="ph3">`Double`</ph>, the resulting array is of type <ph id="ph4">`Double`</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`Integer`</ph> and <ph id="ph2">`Long`</ph> widen only to <ph id="ph3">`Double`</ph>, <ph id="ph4">`Double`</ph> is the dominant type.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You can use type inference only for arrays that are defined as local variables in a type member.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If an explicit type definition is absent, arrays defined with array literals at the class level are of type <ph id="ph1">`Object[]`</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Local type inference<ept id="p1">](../variables/local-type-inference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Note that the previous example defines <ph id="ph1">`values`</ph> as an array of type <ph id="ph2">`Double`</ph> even though all the array literals are of type <ph id="ph3">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>You can create this array because the values in the array literal can widen to <ph id="ph1">`Double`</ph> values.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can also create and populate a multidimensional array by using <bpt id="p1">*</bpt>nested array literals<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Nested array literals must have a number of dimensions that’s consistent with the resulting array.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following example creates a two-dimensional array of integers by using nested array literals.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>When using nested array literals to create and populate an array, an error occurs if the number of elements in the nested array literals don't match.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>An error also occurs if you explicitly declare the array variable to have a different number of dimensions than the array literals.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Just as you can for one-dimensional arrays, you can rely on type inference when creating a multidimensional array with nested array literals.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The inferred type is the dominant type for all the values in all the array literals for all nesting level.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The following example creates a two-dimensional array of type <ph id="ph1">`Double[,]`</ph> from values that are of type <ph id="ph2">`Integer`</ph> and <ph id="ph3">`Double`</ph>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For additional examples, see <bpt id="p1">[</bpt>How to: Initialize an Array Variable in Visual Basic<ept id="p1">](../../language-features/arrays/how-to-initialize-an-array-variable.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Iterating through an array</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When you iterate through an array, you access each element in the array from the lowest index to the highest or from the highest to the lowest.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Typically, use either the <bpt id="p1">[</bpt>For...Next Statement<ept id="p1">](../../../language-reference/statements/for-next-statement.md)</ept> or the <bpt id="p2">[</bpt>For Each...Next Statement<ept id="p2">](../../../language-reference/statements/for-each-next-statement.md)</ept> to iterate through the elements of an array.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>When you don't know the upper bounds of the array, you can call the <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> method to get the highest value of the index.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Although lowest index value is almost always 0, you can call the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A?displayProperty=nameWithType&gt;</ph> method to get the lowest value of the index.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example iterates through a one-dimensional array by using the <bpt id="p1">[</bpt><ph id="ph1">`For...Next`</ph><ept id="p1">](../../../language-reference/statements/for-next-statement.md)</ept> statement.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following example iterates through a multidimensional array by using a <bpt id="p1">[</bpt><ph id="ph1">`For...Next`</ph><ept id="p1">](../../../language-reference/statements/for-next-statement.md)</ept> statement.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> method has a parameter that specifies the dimension.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`GetUpperBound(0)`</ph> returns the highest index of the first dimension, and <ph id="ph2">`GetUpperBound(1)`</ph> returns the highest index of the second dimension.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The following example uses a <bpt id="p1">[</bpt>For Each...Next Statement<ept id="p1">](../../../language-reference/statements/for-each-next-statement.md)</ept>to iterate through a one-dimensional array and a two-dimensional array.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Array size</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The size of an array is the product of the lengths of all its dimensions.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>It represents the total number of elements currently contained in the array.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, the following example declares a 2-dimensional array with four elements in each dimension.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the array's size is 16 (or (3 + 1) * (3 + 1).</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This discussion of array size does not apply to jagged arrays.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For information on jagged arrays and determining the size of a jagged array, see the <bpt id="p1">[</bpt>Jagged arrays<ept id="p1">](#jagged-arrays)</ept> section.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can find the size of an array by using the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can find the length of each dimension of a multidimensional array by using the <ph id="ph1">&lt;xref:System.Array.GetLength%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You can resize an array variable by assigning a new array object to it or by using the <bpt id="p1">[</bpt><ph id="ph1">`ReDim`</ph> Statement<ept id="p1">](../../../language-reference/statements/redim-statement.md)</ept> statement.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`ReDim`</ph> statement to change a 100-element array to a 51-element array.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>There are several things to keep in mind when dealing with the size of an array.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Dimension Length</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The index of each dimension is 0-based, which means it ranges from 0 to its upper bound.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Therefore, the length of a given dimension is one greater than the declared upper bound of that dimension.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Length Limits</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The length of every dimension of an array is limited to the maximum value of the <ph id="ph1">`Integer`</ph> data type, which is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> or (2 ^ 31) - 1.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>However, the total size of an array is also limited by the memory available on your system.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If you attempt to initialize an array that exceeds the amount of available memory, the runtime throws an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Size and Element Size</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>An array's size is independent of the data type of its elements.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The size always represents the total number of elements, not the number of bytes that they consume in memory.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Memory Consumption</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>It is not safe to make any assumptions regarding how an array is stored in memory.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Storage varies on platforms of different data widths, so the same array can consume more memory on a 64-bit system than on a 32-bit system.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Depending on system configuration when you initialize an array, the common language runtime (CLR) can assign storage either to pack elements as close together as possible, or to align them all on natural hardware boundaries.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Also, an array requires a storage overhead for its control information, and this overhead increases with each added dimension.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The array type</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Every array has a data type, which differs from the data type of its elements.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>There is no single data type for all arrays.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Instead, the data type of an array is determined by the number of dimensions, or <bpt id="p1">*</bpt>rank<ept id="p1">*</ept>, of the array, and the data type of the elements in the array.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Two array variables are of the same data type only when they have the same rank and their elements have the same data type.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The lengths of the dimensions of an array do not influence the array data type.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Every array inherits from the <ph id="ph1">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph> class, and you can declare a variable to be of type <ph id="ph2">`Array`</ph>, but you cannot create an array of type <ph id="ph3">`Array`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For example, although the following code declares the <ph id="ph1">`arr`</ph> variable to be of type <ph id="ph2">`Array`</ph> and calls the <ph id="ph3">&lt;xref:System.Array.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method to instantiate the array, the array's type proves to be Object[].</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Also, the <bpt id="p1">[</bpt>ReDim Statement<ept id="p1">](../../../language-reference/statements/redim-statement.md)</ept> cannot operate on a variable declared as type <ph id="ph1">`Array`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For these reasons, and for type safety, it is advisable to declare every array as a specific type.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>You can find out the data type of either an array or its elements in several ways.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>You can call the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method on the variable to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the run-time type of the variable.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object holds extensive information in its properties and methods.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You can pass the variable to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.Information.TypeName%2A&gt;</ph> function to get a <ph id="ph2">`String`</ph> with the name of run-time type.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following example calls the both the <ph id="ph1">`GetType`</ph> method and the <ph id="ph2">`TypeName`</ph> function to determine the type of an array.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The array type is <ph id="ph1">`Byte(,)`</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">&lt;xref:System.Type.BaseType%2A?displayProperty=nameWithType&gt;</ph> property also indicates that the base type of the byte array is the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Arrays as return values and parameters</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>To return an array from a <ph id="ph1">`Function`</ph> procedure, specify the array data type and the number of dimensions as the return type of the <bpt id="p1">[</bpt>Function Statement<ept id="p1">](../../../language-reference/statements/function-statement.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Within the function, declare a local array variable with same data type and number of dimensions.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>Return Statement<ept id="p1">](../../../language-reference/statements/return-statement.md)</ept>, include the local array variable without parentheses.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>To specify an array as a parameter to a <ph id="ph1">`Sub`</ph> or <ph id="ph2">`Function`</ph> procedure, define the parameter as an array with a specified data type and number of dimensions.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>In the call to the procedure, pass an array variable with the same data type and number of dimensions.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`GetNumbers`</ph> function returns an <ph id="ph2">`Integer()`</ph>, a one-dimensional array of type <ph id="ph3">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ShowNumbers`</ph> procedure accepts an <ph id="ph2">`Integer()`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`GetNumbersMultiDim`</ph> function returns an <ph id="ph2">`Integer(,)`</ph>, a two-dimensional array of type <ph id="ph3">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ShowNumbersMultiDim`</ph> procedure accepts an <ph id="ph2">`Integer(,)`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Jagged arrays</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Sometimes the data structure in your application is two-dimensional but not rectangular.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>For example, you might use an array to store data about the high temperature of each day of the month.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The first dimension of the array represents the month, but the second dimension represents the number of days, and the number of days in a month is not uniform.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>jagged array<ept id="p1">*</ept>, which is also called an <bpt id="p2">*</bpt>array of arrays<ept id="p2">*</ept>, is designed for such scenarios.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>A jagged array is an array whose elements are also arrays.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>A jagged array and each element in a jagged array can have one or more dimensions.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The following example uses an array of months, each element of which is an array of days.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The example uses a jagged array because different months have different numbers of days.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The example shows how to create a jagged array, assign values to it, and retrieve and display its values.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The previous example assigns values to the jagged array on an element-by-element basis by using a <ph id="ph1">`For...Next`</ph> loop.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>You can also assign values to the elements of a jagged array by using nested array literals.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>However, the attempt to use nested array literals (for example, <ph id="ph1">`Dim valuesjagged = {{1, 2}, {2, 3, 4}}`</ph>) generates compiler error <bpt id="p1">[</bpt>BC30568<ept id="p1">](../../../,,/../misc/bc30568.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>To correct the error, enclose the inner array literals in parentheses.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The parentheses force the array literal expression to be evaluated, and the resulting values are used with the outer array literal, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>A jagged array is a one-dimensional array whose elements contain arrays.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">`Array.GetLength(0)`</ph> method return the number of elements in the one-dimensional array, and <ph id="ph3">`Array.GetLength(1)`</ph> throws an <ph id="ph4">&lt;xref:System.IndexOutOfRangeException&gt;</ph> because a jagged array is not multidimensional.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>You determine the number of elements in each subarray by retrieving the value of each subarray's <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to determine the number of elements in a jagged array.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Zero-length arrays</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Visual Basic differentiates between a uninitialized array (an array whose value is <ph id="ph1">`Nothing`</ph>) and a <bpt id="p1">*</bpt>zero-length array<ept id="p1">*</ept> or empty array (an array that has no elements.) An uninitialized array is one that has not been dimensioned or had any values assigned to it.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>A zero-length array is declared with a dimension of -1.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>You might need to create a zero-length array under the following circumstances:</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Without risking a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> exception, your code must access members of the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class, such as <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Array.Rank%2A&gt;</ph>, or call a Visual Basic function such as <ph id="ph5">&lt;xref:Microsoft.VisualBasic.Information.UBound%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>You want to keep your code simple by not having to check for <ph id="ph1">`Nothing`</ph> as a special case.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Your code interacts with an application programming interface (API) that either requires you to pass a zero-length array to one or more procedures or returns a zero-length array from one or more procedures.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Splitting an array</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to split a single array into multiple arrays.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This involves identifying the point or points at which the array is to be split, and then spitting the array into two or more separate arrays.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This section does not discuss splitting a single string into a string array based on some delimiter.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For information on splitting a string, see the <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The most common criteria for splitting an array are:</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For example, you might want to split an array of more than a specified number of elements into a number of approximately equal parts.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For this purpose, you can use the value returned by either the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Array.GetLength%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The value of an element, which serves as a delimiter that indicates where the array should be split.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>You can search for a specific value by calling the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.FindLastIndex%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Once you've determined the index or indexes at which the array should be split, you can then create the individual arrays by calling the <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The following example splits an array into two arrays of approximately equal size.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>(If the total number of array elements is odd, the first array has one more element than the second.)</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The following example splits a string array into two arrays based on the presence of an element whose value is "zzz", which serves as the array delimiter.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The new arrays do not include the element that contains the delimiter.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>You can also combine a number of arrays into a single larger array.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>To do this, you also use the <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>This section does not discuss joining a string array into a single string.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For information on joining a string array, see the <ph id="ph1">&lt;xref:System.String.Join%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Before copying the elements of each array into the new array, you must first ensure that you have initialized the array so that it is large enough to accommodate the new array.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>You can do this in one of two ways:</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt><ph id="ph1">`ReDim Preserve`</ph><ept id="p1">](../../../language-reference/statements/redim-statement.md)</ept> statement to dynamically expand the array before adding new elements to it.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>This is the easiest technique, but it can result in performance degradation and excessive memory consumption when you are copying large arrays.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Calculate the total number of elements needed for the new large array, then add the elements of each source array to it.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The following example uses the second approach to add four arrays with ten elements each to a single array.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Since in this case the source arrays are all small, we can also dynamically expand the array as we add the elements of each new array to it.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The following example does that.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Collections as an alternative to arrays</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Arrays are most useful for creating and working with a fixed number of strongly typed objects.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Collections provide a more flexible way to work with groups of objects.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Unlike arrays, which require that you explicitly change the size of an array with the <bpt id="p1">[</bpt><ph id="ph1">`ReDim`</ph> Statement<ept id="p1">](../../../language-reference/statements/redim-statement.md)</ept>, collections grow and shrink dynamically as the needs of an application change.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>When you use <ph id="ph1">`ReDim`</ph> to redimension an array, Visual Basic creates a new array and releases the previous one.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>This takes execution time.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Therefore, if the number of items you are working with changes frequently, or you cannot predict the maximum number of items you need, you'll usually obtain better performance by using a collection.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>For some collections, you can assign a key to any object that you put into the collection so that you can quickly retrieve the object by using the key.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>If your collection contains elements of only one data type, you can use one of the classes in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>A generic collection enforces type safety so that no other data type can be added to it.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>For more information about collections, see <bpt id="p1">[</bpt>Collections<ept id="p1">](../../concepts/collections.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Related topics</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Term</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Definition</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Array Dimensions in Visual Basic<ept id="p1">](../../language-features/arrays/array-dimensions.md)</ept></source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Explains rank and dimensions in arrays.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Initialize an Array Variable in Visual Basic<ept id="p1">](../../language-features/arrays/how-to-initialize-an-array-variable.md)</ept></source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Describes how to populate arrays with initial values.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Sort An Array in Visual Basic<ept id="p1">](../../language-features/arrays/how-to-sort-an-array.md)</ept></source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Shows how to sort the elements of an array alphabetically.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Assign One Array to Another Array<ept id="p1">](../../language-features/arrays/how-to-assign-one-array-to-another-array.md)</ept></source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Describes the rules and steps for assigning an array to another array variable.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Troubleshooting Arrays<ept id="p1">](../../language-features/arrays/troubleshooting-arrays.md)</ept></source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Discusses some common problems that arise when working with arrays.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Dim Statement<ept id="p1">](../../../language-reference/statements/dim-statement.md)</ept></source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ReDim Statement<ept id="p1">](../../../language-reference/statements/redim-statement.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>