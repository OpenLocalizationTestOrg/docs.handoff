{"content":"---\ntitle: \"Custom Serialization | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"binary serialization, custom serialization\"\n  - \"custom serialization\"\n  - \"binary serialization, controlling\"\n  - \"OptionalFieldAttribute class, custom serialization\"\n  - \"ISerializable interface, custom serialization\"\n  - \"OnDeserializingAttribute class, custom serialization\"\n  - \"OnSerializedAttribute class, custom serialization\"\n  - \"serialization, custom serialization\"\n  - \"serialization, controlling\"\n  - \"OnDeserializedAttribute class, custom serialization\"\n  - \"OnSerializingAttribute class, custom serialization\"\nms.assetid: 12ed422d-5280-49b8-9b71-a2ed129c0384\ncaps.latest.revision: 11\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Custom Serialization\nCustom serialization is the process of controlling the serialization and deserialization of a type. By controlling serialization, it is possible to ensure serialization compatibility, which is the ability to serialize and deserialize between versions of a type without breaking the core functionality of the type. For example, in the first version of a type, there may be only two fields. In the next version of a type, several more fields are added. Yet the second version of an application must be able to serialize and deserialize both types. The following sections describe how to control serialization.  \n  \n> [!IMPORTANT]\n>  In versions previous to.NET Framework 4.0, serialization of custom user data in a partially trusted assembly was accomplished using the GetObjectData. Starting with version 4.0, that method is marked with the <xref:System.Security.SecurityCriticalAttribute> attribute which prevents execution in partially trusted assemblies. To work around this condition, implement the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.  \n  \n## Running Custom Methods During and After Serialization  \n The best practice and easiest way (introduced in version 2.0 of the .NET Framework) is to apply the following attributes to methods that are used to correct data during and after serialization:  \n  \n-   <xref:System.Runtime.Serialization.OnDeserializedAttribute>  \n  \n-   <xref:System.Runtime.Serialization.OnDeserializingAttribute>  \n  \n-   <xref:System.Runtime.Serialization.OnSerializedAttribute>  \n  \n-   <xref:System.Runtime.Serialization.OnSerializingAttribute>  \n  \n These attributes allow the type to participate in any one of, or all four of the phases, of the serialization and deserialization processes. The attributes specify the methods of the type that should be invoked during each phase. The methods do not access the serialization stream but instead allow you to alter the object before and after serialization, or before and after deserialization. The attributes can be applied at all levels of the type inheritance hierarchy, and each method is called in the hierarchy from the base to the most derived. This mechanism avoids the complexity and any resulting issues of implementing the <xref:System.Runtime.Serialization.ISerializable> interface by giving the responsibility for serialization and deserialization to the most derived implementation. Additionally, this mechanism allows the formatters to ignore the population of fields and retrieval from the serialization stream. For details and examples of controlling serialization and deserialization, click any of the previous links.  \n  \n In addition, when adding a new field to an existing serializable type, apply the <xref:System.Runtime.Serialization.OptionalFieldAttribute> attribute to the field. The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> ignores the absence of the field when a stream that is missing the new field is processed.  \n  \n## Implementing the ISerializable Interface  \n The other way to control serialization is achieved by implementing the `ISerializable` interface on an object. Note, however, that the method in the previous section supersedes this method to control serialization.  \n  \n In addition, you should not use default serialization on a class that is marked with the `Serializable` attribute and has declarative or imperative security at the class level or on its constructors. Instead, these classes should always implement the **ISerializable** interface.  \n  \n Implementing **ISerializable** involves implementing the `GetObjectData` method and a special constructor that is used when the object is deserialized. The following sample code shows how to implement **ISerializable** on the `MyObject` class from a previous section.  \n  \n```csharp  \n[Serializable]  \npublic class MyObject : ISerializable   \n{  \n  public int n1;  \n  public int n2;  \n  public String str;  \n  \n  public MyObject()  \n  {  \n  }  \n  \n  protected MyObject(SerializationInfo info, StreamingContext context)  \n  {  \n    n1 = info.GetInt32(\"i\");  \n    n2 = info.GetInt32(\"j\");  \n    str = info.GetString(\"k\");  \n  }  \n[SecurityPermissionAttribute(SecurityAction.Demand,   \nSerializationFormatter =true)]  \n  \npublic virtual void GetObjectData(SerializationInfo info, StreamingContext context)  \n  {  \n    info.AddValue(\"i\", n1);  \n    info.AddValue(\"j\", n2);  \n    info.AddValue(\"k\", str);  \n  }  \n}  \n```  \n  \n```vb  \n<Serializable()>  _  \nPublic Class MyObject  \n    Implements ISerializable  \n    Public n1 As Integer  \n    Public n2 As Integer  \n    Public str As String  \n  \n    Public Sub New()   \n    End Sub   \n  \n    Protected Sub New(ByVal info As SerializationInfo, _  \n    ByVal context As StreamingContext)   \n        n1 = info.GetInt32(\"i\")  \n        n2 = info.GetInt32(\"j\")  \n        str = info.GetString(\"k\")  \n    End Sub 'New  \n  \n    <SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter := True)>  _  \n    Public Overridable Sub GetObjectData(ByVal info As _  \n    SerializationInfo, ByVal context As StreamingContext)   \n        info.AddValue(\"i\", n1)  \n        info.AddValue(\"j\", n2)  \n        info.AddValue(\"k\", str)  \n    End Sub   \nEnd Class  \n```  \n  \n When **GetObjectData** is called during serialization, you are responsible for populating the `SerializationInfo` provided with the method call. Add the variables to be serialized as name and value pairs. Any text can be used as the name. You have the freedom to decide which member variables are added to the **SerializationInfo**, provided that sufficient data is serialized to restore the object during deserialization. Derived classes should call the **GetObjectData** method on the base object if the latter implements **ISerializable.**  \n  \n Note that serialization can allow other code to see or modify object instance data that is otherwise inaccessible. Therefore, code that performs serialization requires the `SecurityPermission` with the `SerializationFormatter` flag specified. Under default policy, this permission is not given to Internet-downloaded or intranet code; only code on the local computer is granted this permission. The **GetObjectData** method must be explicitly protected either by demanding the **SecurityPermission**with the**SerializationFormatter** flag specified or by demanding other permissions that specifically help protect private data.  \n  \n If a private field stores sensitive information, you should demand the appropriate permissions on **GetObjectData** to protect the data. Remember that code that has been granted **SecurityPermission**with the**SerializationFormatter** flag specified can view and modify the data stored in private fields. A malicious caller granted this **SecurityPermission** can view data such as hidden directory locations or granted permissions and use the data to exploit a security vulnerability on the computer. For a complete list of the security permission flags you can specify, see the `SecurityPermissionFlag Enumeration`.  \n  \n It is important to stress that when **ISerializable** is added to a class you must implement both **GetObjectData** and the special constructor. The compiler warns you if **GetObjectData** is missing. However, because it is impossible to enforce the implementation of a constructor, no warning is provided if the constructor is absent, and an exception is thrown when an attempt is made to deserialize a class without the constructor.  \n  \n The current design was favored above a <xref:System.Runtime.Serialization.ISerializationSurrogate.SetObjectData%2A> method to get around potential security and versioning problems. For example, a `SetObjectData` method must be public if it is defined as part of an interface; thus users must write code to defend against having the **SetObjectData** method called multiple times. Otherwise, a malicious application that calls the **SetObjectData** method on an object in the process of executing an operation can cause potential problems.  \n  \n During deserialization, **SerializationInfo** is passed to the class using the constructor provided for this purpose. Any visibility constraints placed on the constructor are ignored when the object is deserialized; so you can mark the class as public, protected, internal, or private. However, it is a best practice to make the constructor protected unless the class is sealed, in which case the constructor should be marked private. The constructor should also perform thorough input validation. To avoid misuse by malicious code, the constructor should enforce the same security checks and permissions required to obtain an instance of the class using any other constructor. If you do not follow this recommendation, malicious code can preserialize an object, obtain control with the **SecurityPermission**with the**SerializationFormatter** flag specified and deserialize the object on a client computer bypassing any security that would have been applied during standard instance construction using a public constructor.  \n  \n To restore the state of the object, simply retrieve the values of the variables from **SerializationInfo** using the names used during serialization. If the base class implements **ISerializable**, the base constructor should be called to allow the base object to restore its variables.  \n  \n When you derive a new class from one that implements **ISerializable,** the derived class must implement both the constructor as well as the **GetObjectData** method if it has variables that need to be serialized. The following code example shows how this is done using the `MyObject` class shown previously.  \n  \n```csharp  \n[Serializable]  \npublic class ObjectTwo : MyObject  \n{  \n    public int num;  \n  \n    public ObjectTwo() : base()  \n    {  \n    }  \n  \n    protected ObjectTwo(SerializationInfo si,   \n    StreamingContext context) : base(si,context)  \n    {  \n        num = si.GetInt32(\"num\");  \n    }  \n[SecurityPermissionAttribute(SecurityAction.Demand,  \nSerializationFormatter = true)]  \n    public override void GetObjectData(SerializationInfo si,   \n    StreamingContext context)  \n    {  \n        base.GetObjectData(si,context);  \n        si.AddValue(\"num\", num);  \n    }  \n}  \n```  \n  \n```vb  \n<Serializable()>  _  \nPublic Class ObjectTwo  \n    Inherits MyObject  \n    Public num As Integer  \n  \n    Public Sub New()   \n  \n    End Sub       \n  \n    Protected Sub New(ByVal si As SerializationInfo, _  \n    ByVal context As StreamingContext)   \n        MyBase.New(si, context)  \n        num = si.GetInt32(\"num\")      \n    End Sub   \n  \n    <SecurityPermissionAttribute(SecurityAction.Demand, _  \n    SerializationFormatter := True)>  _  \n    Public Overrides Sub GetObjectData(ByVal si As _  \n    SerializationInfo, ByVal context As StreamingContext)   \n        MyBase.GetObjectData(si, context)  \n        si.AddValue(\"num\", num)      \n    End Sub   \nEnd Class  \n```  \n  \n Do not forget to call the base class in the deserialization constructor. If this is not done, the constructor on the base class is never called, and the object is not fully constructed after deserialization.  \n  \n Objects are reconstructed from the inside out; and calling methods during deserialization can have undesirable side effects, because the methods called might refer to object references that have not been deserialized by the time the call is made. If the class being deserialized implements the IDeserializationCallback`, the `OnDeserialization` method is automatically called when the entire object graph has been deserialized. At this point, all the child objects referenced have been fully restored. A hash table is a typical example of a class that is difficult to deserialize without using the event listener. It is easy to retrieve the key and value pairs during deserialization, but adding these objects back to the hash table can cause problems, because there is no guarantee that classes that derived from the hash table have been deserialized. Calling methods on a hash table at this stage is therefore not advisable.  \n  \n## See Also  \n [Binary Serialization](../../../docs/framework/serialization/binary-serialization.md)   \n [XML and SOAP Serialization](../../../docs/framework/serialization/xml-and-soap-serialization.md)   \n [Security and Serialization](../../../docs/framework/misc/security-and-serialization.md)\n","nodes":[{"pos":[4,917],"nodes":[{"content":"Custom Serialization | Microsoft Docs","nodes":[{"pos":[0,37],"content":"Custom Serialization | Microsoft Docs","nodes":[{"content":"Custom Serialization | Microsoft Docs","pos":[0,37]}]}],"pos":[6,46],"yaml":true}],"content":"title: \"Custom Serialization | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"binary serialization, custom serialization\"\n  - \"custom serialization\"\n  - \"binary serialization, controlling\"\n  - \"OptionalFieldAttribute class, custom serialization\"\n  - \"ISerializable interface, custom serialization\"\n  - \"OnDeserializingAttribute class, custom serialization\"\n  - \"OnSerializedAttribute class, custom serialization\"\n  - \"serialization, custom serialization\"\n  - \"serialization, controlling\"\n  - \"OnDeserializedAttribute class, custom serialization\"\n  - \"OnSerializingAttribute class, custom serialization\"\nms.assetid: 12ed422d-5280-49b8-9b71-a2ed129c0384\ncaps.latest.revision: 11\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"","yamlblock":true},{"pos":[924,944],"content":"Custom Serialization","linkify":"Custom Serialization","nodes":[{"content":"Custom Serialization","pos":[0,20]}]},{"content":"Custom serialization is the process of controlling the serialization and deserialization of a type.","pos":[945,1044]},{"content":"By controlling serialization, it is possible to ensure serialization compatibility, which is the ability to serialize and deserialize between versions of a type without breaking the core functionality of the type.","pos":[1045,1258]},{"content":"For example, in the first version of a type, there may be only two fields.","pos":[1259,1333]},{"content":"In the next version of a type, several more fields are added.","pos":[1334,1395]},{"content":"Yet the second version of an application must be able to serialize and deserialize both types.","pos":[1396,1490]},{"content":"The following sections describe how to control serialization.","pos":[1491,1552]},{"pos":[1560,2016],"content":"[!IMPORTANT]\n In versions previous to.NET Framework 4.0, serialization of custom user data in a partially trusted assembly was accomplished using the GetObjectData. Starting with version 4.0, that method is marked with the <xref:System.Security.SecurityCriticalAttribute> attribute which prevents execution in partially trusted assemblies. To work around this condition, implement the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.","leadings":["","> "],"nodes":[{"content":"In versions previous to.NET Framework 4.0, serialization of custom user data in a partially trusted assembly was accomplished using the GetObjectData. Starting with version 4.0, that method is marked with the <xref:System.Security.SecurityCriticalAttribute> attribute which prevents execution in partially trusted assemblies. To work around this condition, implement the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.","pos":[14,454],"nodes":[{"content":"In versions previous to.NET Framework 4.0, serialization of custom user data in a partially trusted assembly was accomplished using the GetObjectData.","pos":[0,150]},{"content":"Starting with version 4.0, that method is marked with the <ph id=\"ph1\">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attribute which prevents execution in partially trusted assemblies.","pos":[151,325],"source":" Starting with version 4.0, that method is marked with the <xref:System.Security.SecurityCriticalAttribute> attribute which prevents execution in partially trusted assemblies."},{"content":"To work around this condition, implement the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interface.","pos":[326,440],"source":" To work around this condition, implement the <xref:System.Runtime.Serialization.ISafeSerializationData> interface."}]}]},{"pos":[2025,2078],"content":"Running Custom Methods During and After Serialization","linkify":"Running Custom Methods During and After Serialization","nodes":[{"content":"Running Custom Methods During and After Serialization","pos":[0,53]}]},{"content":"The best practice and easiest way (introduced in version 2.0 of the .NET Framework) is to apply the following attributes to methods that are used to correct data during and after serialization:","pos":[2082,2275]},{"content":"These attributes allow the type to participate in any one of, or all four of the phases, of the serialization and deserialization processes.","pos":[2556,2696]},{"content":"The attributes specify the methods of the type that should be invoked during each phase.","pos":[2697,2785]},{"content":"The methods do not access the serialization stream but instead allow you to alter the object before and after serialization, or before and after deserialization.","pos":[2786,2947]},{"content":"The attributes can be applied at all levels of the type inheritance hierarchy, and each method is called in the hierarchy from the base to the most derived.","pos":[2948,3104]},{"content":"This mechanism avoids the complexity and any resulting issues of implementing the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface by giving the responsibility for serialization and deserialization to the most derived implementation.","pos":[3105,3349],"source":" This mechanism avoids the complexity and any resulting issues of implementing the <xref:System.Runtime.Serialization.ISerializable> interface by giving the responsibility for serialization and deserialization to the most derived implementation."},{"content":"Additionally, this mechanism allows the formatters to ignore the population of fields and retrieval from the serialization stream.","pos":[3350,3480]},{"content":"For details and examples of controlling serialization and deserialization, click any of the previous links.","pos":[3481,3588]},{"content":"In addition, when adding a new field to an existing serializable type, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.OptionalFieldAttribute&gt;</ph> attribute to the field.","pos":[3595,3758],"source":"In addition, when adding a new field to an existing serializable type, apply the <xref:System.Runtime.Serialization.OptionalFieldAttribute> attribute to the field."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter&gt;</ph> ignores the absence of the field when a stream that is missing the new field is processed.","pos":[3759,3997],"source":" The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> ignores the absence of the field when a stream that is missing the new field is processed."},{"pos":[4006,4046],"content":"Implementing the ISerializable Interface","linkify":"Implementing the ISerializable Interface","nodes":[{"content":"Implementing the ISerializable Interface","pos":[0,40]}]},{"content":"The other way to control serialization is achieved by implementing the <ph id=\"ph1\">`ISerializable`</ph> interface on an object.","pos":[4050,4160],"source":"The other way to control serialization is achieved by implementing the `ISerializable` interface on an object."},{"content":"Note, however, that the method in the previous section supersedes this method to control serialization.","pos":[4161,4264]},{"content":"In addition, you should not use default serialization on a class that is marked with the <ph id=\"ph1\">`Serializable`</ph> attribute and has declarative or imperative security at the class level or on its constructors.","pos":[4271,4470],"source":"In addition, you should not use default serialization on a class that is marked with the `Serializable` attribute and has declarative or imperative security at the class level or on its constructors."},{"content":"Instead, these classes should always implement the <bpt id=\"p1\">**</bpt>ISerializable<ept id=\"p1\">**</ept> interface.","pos":[4471,4550],"source":" Instead, these classes should always implement the **ISerializable** interface."},{"content":"Implementing <bpt id=\"p1\">**</bpt>ISerializable<ept id=\"p1\">**</ept> involves implementing the <ph id=\"ph1\">`GetObjectData`</ph> method and a special constructor that is used when the object is deserialized.","pos":[4557,4708],"source":"Implementing **ISerializable** involves implementing the `GetObjectData` method and a special constructor that is used when the object is deserialized."},{"content":"The following sample code shows how to implement <bpt id=\"p1\">**</bpt>ISerializable<ept id=\"p1\">**</ept> on the <ph id=\"ph1\">`MyObject`</ph> class from a previous section.","pos":[4709,4824],"source":" The following sample code shows how to implement **ISerializable** on the `MyObject` class from a previous section."},{"content":"When <bpt id=\"p1\">**</bpt>GetObjectData<ept id=\"p1\">**</ept> is called during serialization, you are responsible for populating the <ph id=\"ph1\">`SerializationInfo`</ph> provided with the method call.","pos":[6267,6411],"source":"When **GetObjectData** is called during serialization, you are responsible for populating the `SerializationInfo` provided with the method call."},{"content":"Add the variables to be serialized as name and value pairs.","pos":[6412,6471]},{"content":"Any text can be used as the name.","pos":[6472,6505]},{"content":"You have the freedom to decide which member variables are added to the <bpt id=\"p1\">**</bpt>SerializationInfo<ept id=\"p1\">**</ept>, provided that sufficient data is serialized to restore the object during deserialization.","pos":[6506,6689],"source":" You have the freedom to decide which member variables are added to the **SerializationInfo**, provided that sufficient data is serialized to restore the object during deserialization."},{"content":"Derived classes should call the <bpt id=\"p1\">**</bpt>GetObjectData<ept id=\"p1\">**</ept> method on the base object if the latter implements <bpt id=\"p2\">**</bpt>ISerializable.<ept id=\"p2\">**</ept>","pos":[6690,6809],"source":" Derived classes should call the **GetObjectData** method on the base object if the latter implements **ISerializable.**"},{"content":"Note that serialization can allow other code to see or modify object instance data that is otherwise inaccessible.","pos":[6816,6930]},{"content":"Therefore, code that performs serialization requires the <ph id=\"ph1\">`SecurityPermission`</ph> with the <ph id=\"ph2\">`SerializationFormatter`</ph> flag specified.","pos":[6931,7058],"source":" Therefore, code that performs serialization requires the `SecurityPermission` with the `SerializationFormatter` flag specified."},{"content":"Under default policy, this permission is not given to Internet-downloaded or intranet code; only code on the local computer is granted this permission.","pos":[7059,7210]},{"content":"The <bpt id=\"p1\">**</bpt>GetObjectData<ept id=\"p1\">**</ept> method must be explicitly protected either by demanding the <bpt id=\"p2\">**</bpt>SecurityPermission<ept id=\"p2\">**</ept>with the<bpt id=\"p3\">**</bpt>SerializationFormatter<ept id=\"p3\">**</ept> flag specified or by demanding other permissions that specifically help protect private data.","pos":[7211,7443],"source":" The **GetObjectData** method must be explicitly protected either by demanding the **SecurityPermission**with the**SerializationFormatter** flag specified or by demanding other permissions that specifically help protect private data."},{"content":"If a private field stores sensitive information, you should demand the appropriate permissions on <bpt id=\"p1\">**</bpt>GetObjectData<ept id=\"p1\">**</ept> to protect the data.","pos":[7450,7586],"source":"If a private field stores sensitive information, you should demand the appropriate permissions on **GetObjectData** to protect the data."},{"content":"Remember that code that has been granted <bpt id=\"p1\">**</bpt>SecurityPermission<ept id=\"p1\">**</ept>with the<bpt id=\"p2\">**</bpt>SerializationFormatter<ept id=\"p2\">**</ept> flag specified can view and modify the data stored in private fields.","pos":[7587,7754],"source":" Remember that code that has been granted **SecurityPermission**with the**SerializationFormatter** flag specified can view and modify the data stored in private fields."},{"content":"A malicious caller granted this <bpt id=\"p1\">**</bpt>SecurityPermission<ept id=\"p1\">**</ept> can view data such as hidden directory locations or granted permissions and use the data to exploit a security vulnerability on the computer.","pos":[7755,7951],"source":" A malicious caller granted this **SecurityPermission** can view data such as hidden directory locations or granted permissions and use the data to exploit a security vulnerability on the computer."},{"content":"For a complete list of the security permission flags you can specify, see the <ph id=\"ph1\">`SecurityPermissionFlag Enumeration`</ph>.","pos":[7952,8067],"source":" For a complete list of the security permission flags you can specify, see the `SecurityPermissionFlag Enumeration`."},{"content":"It is important to stress that when <bpt id=\"p1\">**</bpt>ISerializable<ept id=\"p1\">**</ept> is added to a class you must implement both <bpt id=\"p2\">**</bpt>GetObjectData<ept id=\"p2\">**</ept> and the special constructor.","pos":[8074,8218],"source":"It is important to stress that when **ISerializable** is added to a class you must implement both **GetObjectData** and the special constructor."},{"content":"The compiler warns you if <bpt id=\"p1\">**</bpt>GetObjectData<ept id=\"p1\">**</ept> is missing.","pos":[8219,8274],"source":" The compiler warns you if **GetObjectData** is missing."},{"content":"However, because it is impossible to enforce the implementation of a constructor, no warning is provided if the constructor is absent, and an exception is thrown when an attempt is made to deserialize a class without the constructor.","pos":[8275,8508]},{"content":"The current design was favored above a <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializationSurrogate.SetObjectData%2A&gt;</ph> method to get around potential security and versioning problems.","pos":[8515,8695],"source":"The current design was favored above a <xref:System.Runtime.Serialization.ISerializationSurrogate.SetObjectData%2A> method to get around potential security and versioning problems."},{"content":"For example, a <ph id=\"ph1\">`SetObjectData`</ph> method must be public if it is defined as part of an interface; thus users must write code to defend against having the <bpt id=\"p1\">**</bpt>SetObjectData<ept id=\"p1\">**</ept> method called multiple times.","pos":[8696,8894],"source":" For example, a `SetObjectData` method must be public if it is defined as part of an interface; thus users must write code to defend against having the **SetObjectData** method called multiple times."},{"content":"Otherwise, a malicious application that calls the <bpt id=\"p1\">**</bpt>SetObjectData<ept id=\"p1\">**</ept> method on an object in the process of executing an operation can cause potential problems.","pos":[8895,9053],"source":" Otherwise, a malicious application that calls the **SetObjectData** method on an object in the process of executing an operation can cause potential problems."},{"content":"During deserialization, <bpt id=\"p1\">**</bpt>SerializationInfo<ept id=\"p1\">**</ept> is passed to the class using the constructor provided for this purpose.","pos":[9060,9177],"source":"During deserialization, **SerializationInfo** is passed to the class using the constructor provided for this purpose."},{"content":"Any visibility constraints placed on the constructor are ignored when the object is deserialized; so you can mark the class as public, protected, internal, or private.","pos":[9178,9345]},{"content":"However, it is a best practice to make the constructor protected unless the class is sealed, in which case the constructor should be marked private.","pos":[9346,9494]},{"content":"The constructor should also perform thorough input validation.","pos":[9495,9557]},{"content":"To avoid misuse by malicious code, the constructor should enforce the same security checks and permissions required to obtain an instance of the class using any other constructor.","pos":[9558,9737]},{"content":"If you do not follow this recommendation, malicious code can preserialize an object, obtain control with the <bpt id=\"p1\">**</bpt>SecurityPermission<ept id=\"p1\">**</ept>with the<bpt id=\"p2\">**</bpt>SerializationFormatter<ept id=\"p2\">**</ept> flag specified and deserialize the object on a client computer bypassing any security that would have been applied during standard instance construction using a public constructor.","pos":[9738,10084],"source":" If you do not follow this recommendation, malicious code can preserialize an object, obtain control with the **SecurityPermission**with the**SerializationFormatter** flag specified and deserialize the object on a client computer bypassing any security that would have been applied during standard instance construction using a public constructor."},{"content":"To restore the state of the object, simply retrieve the values of the variables from <bpt id=\"p1\">**</bpt>SerializationInfo<ept id=\"p1\">**</ept> using the names used during serialization.","pos":[10091,10240],"source":"To restore the state of the object, simply retrieve the values of the variables from **SerializationInfo** using the names used during serialization."},{"content":"If the base class implements <bpt id=\"p1\">**</bpt>ISerializable<ept id=\"p1\">**</ept>, the base constructor should be called to allow the base object to restore its variables.","pos":[10241,10377],"source":" If the base class implements **ISerializable**, the base constructor should be called to allow the base object to restore its variables."},{"content":"When you derive a new class from one that implements <bpt id=\"p1\">**</bpt>ISerializable,<ept id=\"p1\">**</ept> the derived class must implement both the constructor as well as the <bpt id=\"p2\">**</bpt>GetObjectData<ept id=\"p2\">**</ept> method if it has variables that need to be serialized.","pos":[10384,10597],"source":"When you derive a new class from one that implements **ISerializable,** the derived class must implement both the constructor as well as the **GetObjectData** method if it has variables that need to be serialized."},{"content":"The following code example shows how this is done using the <ph id=\"ph1\">`MyObject`</ph> class shown previously.","pos":[10598,10692],"source":" The following code example shows how this is done using the `MyObject` class shown previously."},{"content":"Do not forget to call the base class in the deserialization constructor.","pos":[11973,12045]},{"content":"If this is not done, the constructor on the base class is never called, and the object is not fully constructed after deserialization.","pos":[12046,12180]},{"content":"Objects are reconstructed from the inside out; and calling methods during deserialization can have undesirable side effects, because the methods called might refer to object references that have not been deserialized by the time the call is made.","pos":[12187,12433]},{"content":"If the class being deserialized implements the IDeserializationCallback<ph id=\"ph1\">`, the `</ph>OnDeserialization` method is automatically called when the entire object graph has been deserialized.","pos":[12434,12614],"source":" If the class being deserialized implements the IDeserializationCallback`, the `OnDeserialization` method is automatically called when the entire object graph has been deserialized."},{"content":"At this point, all the child objects referenced have been fully restored.","pos":[12615,12688]},{"content":"A hash table is a typical example of a class that is difficult to deserialize without using the event listener.","pos":[12689,12800]},{"content":"It is easy to retrieve the key and value pairs during deserialization, but adding these objects back to the hash table can cause problems, because there is no guarantee that classes that derived from the hash table have been deserialized.","pos":[12801,13039]},{"content":"Calling methods on a hash table at this stage is therefore not advisable.","pos":[13040,13113]},{"pos":[13122,13130],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Binary Serialization<ept id=\"p1\">](../../../docs/framework/serialization/binary-serialization.md)</ept><ph id=\"ph1\"> </ph>","pos":[13134,13220],"source":"[Binary Serialization](../../../docs/framework/serialization/binary-serialization.md) "},{"content":"<bpt id=\"p1\">[</bpt>XML and SOAP Serialization<ept id=\"p1\">](../../../docs/framework/serialization/xml-and-soap-serialization.md)</ept><ph id=\"ph1\"> </ph>","pos":[13224,13322],"source":"[XML and SOAP Serialization](../../../docs/framework/serialization/xml-and-soap-serialization.md) "},{"content":"<bpt id=\"p1\">[</bpt>Security and Serialization<ept id=\"p1\">](../../../docs/framework/misc/security-and-serialization.md)</ept>","pos":[13326,13414],"source":"[Security and Serialization](../../../docs/framework/misc/security-and-serialization.md)"}]}