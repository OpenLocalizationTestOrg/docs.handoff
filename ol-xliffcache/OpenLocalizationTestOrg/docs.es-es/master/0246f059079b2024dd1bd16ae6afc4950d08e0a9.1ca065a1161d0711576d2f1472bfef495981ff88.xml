{"content":"---\ntitle: \"Grouping Queued Messages in a Session\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"queues [WCF]. grouping messages\"\nms.assetid: 63b23b36-261f-4c37-99a2-cc323cd72a1a\n---\n# Grouping Queued Messages in a Session\nWindows Communication Foundation (WCF) provides a session that allows you to group a set of related messages together for processing by a single receiving application. Messages that are part of a session must be part of the same transaction. Because all messages are part of the same transaction, if one message fails to be processed the entire session is rolled back. Sessions have similar behaviors with regard to dead-letter queues and poison queues. The Time to Live (TTL) property set on a queued binding configured for sessions is applied to the session as a whole. If only some of the messages in the session are sent before the TTL expires, the entire session is placed in the dead-letter queue. Similarly, when messages in a session fail to be sent to an application from the application queue, the entire session is placed in the poison queue (if available).  \n  \n## Message Grouping Example  \n One example where grouping messages is helpful is when implementing an order-processing application as a WCF service. For instance, a client submits an order to this application that contains a number of items. For each item, the client makes a call to the service, which results in a separate message being sent. It is possible for serve A to receive the first item, and server B to receive the second item. Each time an item is added, the server processing that item has to find the appropriate order and add the item to it, which is highly inefficient. You still run into such inefficiencies with only a single server handling all requests, because the server must keep track of all orders currently being processed and determine which one the new item belongs to. Grouping all requests for a single order greatly simplifies implementation of such an application. The client application sends all items for a single order in a session, so when the service processes the order, it processes the entire session at once. \\  \n  \n## Procedures  \n  \n#### To set up a service contract to use sessions  \n  \n1.  Define a service contract that requires a session. Do this with the <xref:System.ServiceModel.OperationContractAttribute> attribute and by specifying:  \n  \n    ```  \n    SessionMode=SessionMode.Required  \n    ```  \n  \n2.  Mark the operations in the contract as one-way, because these methods do not return anything. This is done with the <xref:System.ServiceModel.OperationContractAttribute> attribute and by specifying:  \n  \n    ```  \n    [OperationContract(IsOneWay = true)]  \n    ```  \n  \n3.  Implement the service contract and specify an `InstanceContextMode` of `PerSession`. This instantiates the service only once for each session.  \n  \n    ```  \n    [ServiceBehavior(InstanceContextMode=InstanceContextMode.PerSession)]  \n    ```  \n  \n4.  Each service operation requires a transaction. Specify this with the <xref:System.ServiceModel.OperationBehaviorAttribute> attribute. The operation that completes the transaction should also set `TransactionAutoComplete` to `true`.  \n  \n    ```  \n    [OperationBehavior(TransactionScopeRequired = true, TransactionAutoComplete = true)]   \n    ```  \n  \n5.  Configure an endpoint that uses the system-provided `NetMsmqBinding` binding.  \n  \n6.  Create a transactional queue using <xref:System.Messaging>. You can also create the queue by using Message Queuing (MSMQ) or MMC. If you do, create a transactional queue.  \n  \n7.  Create a service host for the service by using <xref:System.ServiceModel.ServiceHost>.  \n  \n8.  Open the service host to make the service available.  \n  \n9. Close the service host.  \n  \n#### To set up a client  \n  \n1.  Create a transaction scope to write to the transactional queue.  \n  \n2.  Create the WCF client using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.  \n  \n3.  Place the order.  \n  \n4.  Close the WCF client.  \n  \n## Example  \n  \n### Description  \n The following example provides the code for the `IProcessOrder` service and for a client that uses this service. It shows how WCF uses queued sessions to provide the grouping behavior.  \n  \n### Code for the Service  \n [!code-csharp[S_Msmq_Session#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_msmq_session/cs/service.cs#1)]\n [!code-vb[S_Msmq_Session#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_msmq_session/vb/service.vb#1)]  \n\n### Code for the Client  \n [!code-csharp[S_Msmq_Session#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_msmq_session/cs/client.cs#3)]\n [!code-vb[S_Msmq_Session#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_msmq_session/vb/client.vb#3)]  \n\n## See also\n\n- [Sessions and Queues](../../../../docs/framework/wcf/samples/sessions-and-queues.md)\n- [Queues Overview](../../../../docs/framework/wcf/feature-details/queues-overview.md)\n","nodes":[{"pos":[4,215],"embed":true,"restype":"x-metadata","content":"title: \"Grouping Queued Messages in a Session\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"queues [WCF]. grouping messages\"\nms.assetid: 63b23b36-261f-4c37-99a2-cc323cd72a1a","nodes":[{"content":"Grouping Queued Messages in a Session","nodes":[{"pos":[0,37],"content":"Grouping Queued Messages in a Session","nodes":[{"content":"Grouping Queued Messages in a Session","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[222,259],"content":"Grouping Queued Messages in a Session","linkify":"Grouping Queued Messages in a Session","nodes":[{"content":"Grouping Queued Messages in a Session","pos":[0,37]}]},{"content":"Windows Communication Foundation (WCF) provides a session that allows you to group a set of related messages together for processing by a single receiving application.","pos":[260,427]},{"content":"Messages that are part of a session must be part of the same transaction.","pos":[428,501]},{"content":"Because all messages are part of the same transaction, if one message fails to be processed the entire session is rolled back.","pos":[502,628]},{"content":"Sessions have similar behaviors with regard to dead-letter queues and poison queues.","pos":[629,713]},{"content":"The Time to Live (TTL) property set on a queued binding configured for sessions is applied to the session as a whole.","pos":[714,831]},{"content":"If only some of the messages in the session are sent before the TTL expires, the entire session is placed in the dead-letter queue.","pos":[832,963]},{"content":"Similarly, when messages in a session fail to be sent to an application from the application queue, the entire session is placed in the poison queue (if available).","pos":[964,1128]},{"pos":[1137,1161],"content":"Message Grouping Example","linkify":"Message Grouping Example","nodes":[{"content":"Message Grouping Example","pos":[0,24]}]},{"content":"One example where grouping messages is helpful is when implementing an order-processing application as a WCF service.","pos":[1165,1282]},{"content":"For instance, a client submits an order to this application that contains a number of items.","pos":[1283,1375]},{"content":"For each item, the client makes a call to the service, which results in a separate message being sent.","pos":[1376,1478]},{"content":"It is possible for serve A to receive the first item, and server B to receive the second item.","pos":[1479,1573]},{"content":"Each time an item is added, the server processing that item has to find the appropriate order and add the item to it, which is highly inefficient.","pos":[1574,1720]},{"content":"You still run into such inefficiencies with only a single server handling all requests, because the server must keep track of all orders currently being processed and determine which one the new item belongs to.","pos":[1721,1932]},{"content":"Grouping all requests for a single order greatly simplifies implementation of such an application.","pos":[1933,2031]},{"content":"The client application sends all items for a single order in a session, so when the service processes the order, it processes the entire session at once.","pos":[2032,2185]},{"pos":[2196,2206],"content":"Procedures","linkify":"Procedures","nodes":[{"content":"Procedures","pos":[0,10]}]},{"pos":[2217,2261],"content":"To set up a service contract to use sessions","linkify":"To set up a service contract to use sessions","nodes":[{"content":"To set up a service contract to use sessions","pos":[0,44]}]},{"content":"Define a service contract that requires a session.","pos":[2271,2321]},{"content":"Do this with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> attribute and by specifying:","pos":[2322,2421],"source":" Do this with the <xref:System.ServiceModel.OperationContractAttribute> attribute and by specifying:"},{"content":"Mark the operations in the contract as one-way, because these methods do not return anything.","pos":[2493,2586]},{"content":"This is done with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> attribute and by specifying:","pos":[2587,2691],"source":" This is done with the <xref:System.ServiceModel.OperationContractAttribute> attribute and by specifying:"},{"content":"Implement the service contract and specify an <ph id=\"ph1\">`InstanceContextMode`</ph> of <ph id=\"ph2\">`PerSession`</ph>.","pos":[2767,2851],"source":"Implement the service contract and specify an `InstanceContextMode` of `PerSession`."},{"content":"This instantiates the service only once for each session.","pos":[2852,2909]},{"content":"Each service operation requires a transaction.","pos":[3018,3064]},{"content":"Specify this with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationBehaviorAttribute&gt;</ph> attribute.","pos":[3065,3151],"source":" Specify this with the <xref:System.ServiceModel.OperationBehaviorAttribute> attribute."},{"content":"The operation that completes the transaction should also set <ph id=\"ph1\">`TransactionAutoComplete`</ph> to <ph id=\"ph2\">`true`</ph>.","pos":[3152,3249],"source":" The operation that completes the transaction should also set `TransactionAutoComplete` to `true`."},{"pos":[3374,3451],"content":"Configure an endpoint that uses the system-provided <ph id=\"ph1\">`NetMsmqBinding`</ph> binding.","source":"Configure an endpoint that uses the system-provided `NetMsmqBinding` binding."},{"content":"Create a transactional queue using <ph id=\"ph1\">&lt;xref:System.Messaging&gt;</ph>.","pos":[3461,3520],"source":"Create a transactional queue using <xref:System.Messaging>."},{"content":"You can also create the queue by using Message Queuing (MSMQ) or MMC.","pos":[3521,3590]},{"content":"If you do, create a transactional queue.","pos":[3591,3631]},{"pos":[3641,3727],"content":"Create a service host for the service by using <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph>.","source":"Create a service host for the service by using <xref:System.ServiceModel.ServiceHost>."},{"content":"Open the service host to make the service available.","pos":[3737,3789]},{"content":"Close the service host.","pos":[3798,3821]},{"pos":[3832,3850],"content":"To set up a client","linkify":"To set up a client","nodes":[{"content":"To set up a client","pos":[0,18]}]},{"content":"Create a transaction scope to write to the transactional queue.","pos":[3860,3923]},{"pos":[3933,4103],"content":"Create the WCF client using the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept> tool.","source":"Create the WCF client using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool."},{"content":"Place the order.","pos":[4113,4129]},{"content":"Close the WCF client.","pos":[4139,4160]},{"pos":[4169,4176],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4186,4197],"content":"Description","linkify":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"content":"The following example provides the code for the <ph id=\"ph1\">`IProcessOrder`</ph> service and for a client that uses this service.","pos":[4201,4313],"source":"The following example provides the code for the `IProcessOrder` service and for a client that uses this service."},{"content":"It shows how WCF uses queued sessions to provide the grouping behavior.","pos":[4314,4385]},{"pos":[4395,4415],"content":"Code for the Service","linkify":"Code for the Service","nodes":[{"content":"Code for the Service","pos":[0,20]}]},{"pos":[4662,4681],"content":"Code for the Client","linkify":"Code for the Client","nodes":[{"content":"Code for the Client","pos":[0,19]}]},{"pos":[4925,4933],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4937,5021],"content":"<bpt id=\"p1\">[</bpt>Sessions and Queues<ept id=\"p1\">](../../../../docs/framework/wcf/samples/sessions-and-queues.md)</ept>","source":"[Sessions and Queues](../../../../docs/framework/wcf/samples/sessions-and-queues.md)"},{"pos":[5024,5108],"content":"<bpt id=\"p1\">[</bpt>Queues Overview<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/queues-overview.md)</ept>","source":"[Queues Overview](../../../../docs/framework/wcf/feature-details/queues-overview.md)"}]}