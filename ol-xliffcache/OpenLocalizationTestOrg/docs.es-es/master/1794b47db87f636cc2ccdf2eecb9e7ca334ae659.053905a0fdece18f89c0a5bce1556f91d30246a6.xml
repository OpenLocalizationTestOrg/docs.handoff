{"content":"---\ntitle: \"How to: Listen for Cancellation Requests by Polling\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"cancellation, how to poll for requests\"\nms.assetid: c7f2f022-d08e-4e00-b4eb-ae84844cb1bc\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# How to: Listen for Cancellation Requests by Polling\nThe following example shows one way that user code can poll a cancellation token at regular intervals to see whether cancellation has been requested from the calling thread. This example uses the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, but the same pattern applies to asynchronous operations created directly by the <xref:System.Threading.ThreadPool?displayProperty=nameWithType> type or the <xref:System.Threading.Thread?displayProperty=nameWithType> type.  \n  \n## Example  \n Polling requires some kind of loop or recursive code that can periodically read the value of the Boolean <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property. If you are using the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type and you are waiting for the task to complete on the calling thread, you can use the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method to check the property and throw the exception. By using this method, you ensure that the correct exception is thrown in response to a request. If you are using a <xref:System.Threading.Tasks.Task>, then calling this method is better than manually throwing an <xref:System.OperationCanceledException>. If you do not have to throw the exception, then you can just check the property and return from the method if the property is `true`.  \n  \n [!code-csharp[Cancellation#11](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex11.cs#11)]\n [!code-vb[Cancellation#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex11.vb#11)]  \n  \n Calling <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> is extremely fast and does not introduce significant overhead in loops.  \n  \n If you are calling <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, you only have to explicitly check the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property if you have other work to do in response to the cancellation besides throwing the exception. In this example, you can see that the code actually accesses the property twice: once in the explicit access and again in the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method. But because the act of reading the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property involves only one volatile read instruction per access, the double access is not significant from a performance perspective. It is still preferable to call the method rather than manually throw the <xref:System.OperationCanceledException>.  \n  \n## See also\n\n- [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md)\n","nodes":[{"pos":[4,307],"embed":true,"restype":"x-metadata","content":"title: \"How to: Listen for Cancellation Requests by Polling\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"cancellation, how to poll for requests\"\nms.assetid: c7f2f022-d08e-4e00-b4eb-ae84844cb1bc\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"How to: Listen for Cancellation Requests by Polling","nodes":[{"pos":[0,51],"content":"How to: Listen for Cancellation Requests by Polling","nodes":[{"content":"How to: Listen for Cancellation Requests by Polling","pos":[0,51]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[314,365],"content":"How to: Listen for Cancellation Requests by Polling","linkify":"How to: Listen for Cancellation Requests by Polling","nodes":[{"content":"How to: Listen for Cancellation Requests by Polling","pos":[0,51]}]},{"content":"The following example shows one way that user code can poll a cancellation token at regular intervals to see whether cancellation has been requested from the calling thread.","pos":[366,539]},{"content":"This example uses the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> type, but the same pattern applies to asynchronous operations created directly by the <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool?displayProperty=nameWithType&gt;</ph> type or the <ph id=\"ph3\">&lt;xref:System.Threading.Thread?displayProperty=nameWithType&gt;</ph> type.","pos":[540,853],"source":" This example uses the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, but the same pattern applies to asynchronous operations created directly by the <xref:System.Threading.ThreadPool?displayProperty=nameWithType> type or the <xref:System.Threading.Thread?displayProperty=nameWithType> type."},{"pos":[862,869],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Polling requires some kind of loop or recursive code that can periodically read the value of the Boolean <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property.","pos":[873,1056],"source":"Polling requires some kind of loop or recursive code that can periodically read the value of the Boolean <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property."},{"content":"If you are using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> type and you are waiting for the task to complete on the calling thread, you can use the <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> method to check the property and throw the exception.","pos":[1057,1358],"source":" If you are using the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type and you are waiting for the task to complete on the calling thread, you can use the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method to check the property and throw the exception."},{"content":"By using this method, you ensure that the correct exception is thrown in response to a request.","pos":[1359,1454]},{"content":"If you are using a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, then calling this method is better than manually throwing an <ph id=\"ph2\">&lt;xref:System.OperationCanceledException&gt;</ph>.","pos":[1455,1612],"source":" If you are using a <xref:System.Threading.Tasks.Task>, then calling this method is better than manually throwing an <xref:System.OperationCanceledException>."},{"content":"If you do not have to throw the exception, then you can just check the property and return from the method if the property is <ph id=\"ph1\">`true`</ph>.","pos":[1613,1746],"source":" If you do not have to throw the exception, then you can just check the property and return from the method if the property is `true`."},{"pos":[2005,2158],"content":"Calling <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> is extremely fast and does not introduce significant overhead in loops.","source":"Calling <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> is extremely fast and does not introduce significant overhead in loops."},{"content":"If you are calling <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph>, you only have to explicitly check the <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property if you have other work to do in response to the cancellation besides throwing the exception.","pos":[2165,2467],"source":"If you are calling <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, you only have to explicitly check the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property if you have other work to do in response to the cancellation besides throwing the exception."},{"content":"In this example, you can see that the code actually accesses the property twice: once in the explicit access and again in the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> method.","pos":[2468,2675],"source":" In this example, you can see that the code actually accesses the property twice: once in the explicit access and again in the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method."},{"content":"But because the act of reading the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property involves only one volatile read instruction per access, the double access is not significant from a performance perspective.","pos":[2676,2913],"source":" But because the act of reading the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property involves only one volatile read instruction per access, the double access is not significant from a performance perspective."},{"content":"It is still preferable to call the method rather than manually throw the <ph id=\"ph1\">&lt;xref:System.OperationCanceledException&gt;</ph>.","pos":[2914,3028],"source":" It is still preferable to call the method rather than manually throw the <xref:System.OperationCanceledException>."},{"pos":[3037,3045],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3049,3151],"content":"<bpt id=\"p1\">[</bpt>Cancellation in Managed Threads<ept id=\"p1\">](../../../docs/standard/threading/cancellation-in-managed-threads.md)</ept>","source":"[Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md)"}]}