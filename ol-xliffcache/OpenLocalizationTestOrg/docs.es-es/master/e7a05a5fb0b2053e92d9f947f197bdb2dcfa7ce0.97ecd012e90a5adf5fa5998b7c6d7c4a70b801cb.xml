{"content":"---\ntitle: \"Overload Resolution (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Visual Basic code, procedures\"\n  - \"overload resolution\"\n  - \"procedures [Visual Basic], overloading\"\n  - \"procedures [Visual Basic], calling\"\n  - \"procedure overloading [Visual Basic], overload resolution\"\n  - \"signatures [Visual Basic], procedure\"\n  - \"overloads [Visual Basic], resolution\"\nms.assetid: 766115d1-4352-45fb-859f-6063e0de0ec0\n---\n# Overload Resolution (Visual Basic)\nWhen the Visual Basic compiler encounters a call to a procedure that is defined in several overloaded versions, the compiler must decide which of the overloads to call. It does this by performing the following steps:  \n  \n1.  **Accessibility.** It eliminates any overload with an access level that prevents the calling code from calling it.  \n  \n2.  **Number of Parameters.** It eliminates any overload that defines a different number of parameters than are supplied in the call.  \n  \n3.  **Parameter Data Types.** The compiler gives instance methods preference over extension methods. If any instance method is found that requires only widening conversions to match the procedure call, all extension methods are dropped and the compiler continues with only the instance method candidates. If no such instance method is found, it continues with both instance and extension methods.  \n  \n     In this step, it eliminates any overload for which the data types of the calling arguments cannot be converted to the parameter types defined in the overload.  \n  \n4.  **Narrowing Conversions.** It eliminates any overload that requires a narrowing conversion from the calling argument types to the defined parameter types. This is true whether the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On` or `Off`.  \n  \n5.  **Least Widening.** The compiler considers the remaining overloads in pairs. For each pair, it compares the data types of the defined parameters. If the types in one of the overloads all widen to the corresponding types in the other, the compiler eliminates the latter. That is, it retains the overload that requires the least amount of widening.  \n  \n6.  **Single Candidate.** It continues considering overloads in pairs until only one overload remains, and it resolves the call to that overload. If the compiler cannot reduce the overloads to a single candidate, it generates an error.  \n  \n The following illustration shows the process that determines which of a set of overloaded versions to call.  \n  \n ![Flow diagram of overload resolution process](./media/overload-resolution/determine-overloaded-version.gif \"Resolving among overloaded versions\")    \n  \n The following example illustrates this overload resolution process.  \n  \n [!code-vb[VbVbcnProcedures#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#62)]  \n  \n [!code-vb[VbVbcnProcedures#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#63)]  \n  \n In the first call, the compiler eliminates the first overload because the type of the first argument (`Short`) narrows to the type of the corresponding parameter (`Byte`). It then eliminates the third overload because each argument type in the second overload (`Short` and `Single`) widens to the corresponding type in the third overload (`Integer` and `Single`). The second overload requires less widening, so the compiler uses it for the call.  \n  \n In the second call, the compiler cannot eliminate any of the overloads on the basis of narrowing. It eliminates the third overload for the same reason as in the first call, because it can call the second overload with less widening of the argument types. However, the compiler cannot resolve between the first and second overloads. Each has one defined parameter type that widens to the corresponding type in the other (`Byte` to `Short`, but `Single` to `Double`). The compiler therefore generates an overload resolution error.  \n  \n## Overloaded Optional and ParamArray Arguments  \n If two overloads of a procedure have identical signatures except that the last parameter is declared [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) in one and [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) in the other, the compiler resolves a call to that procedure as follows:  \n  \n|If the call supplies the last argument as|The compiler resolves the call to the overload declaring the last argument as|  \n|---|---|  \n|No value (argument omitted)|`Optional`|  \n|A single value|`Optional`|  \n|Two or more values in a comma-separated list|`ParamArray`|  \n|An array of any length (including an empty array)|`ParamArray`|  \n  \n## See also\n\n- [Optional Parameters](./optional-parameters.md)\n- [Parameter Arrays](./parameter-arrays.md)\n- [Procedure Overloading](./procedure-overloading.md)\n- [Troubleshooting Procedures](./troubleshooting-procedures.md)\n- [How to: Define Multiple Versions of a Procedure](./how-to-define-multiple-versions-of-a-procedure.md)\n- [How to: Call an Overloaded Procedure](./how-to-call-an-overloaded-procedure.md)\n- [How to: Overload a Procedure that Takes Optional Parameters](./how-to-overload-a-procedure-that-takes-optional-parameters.md)\n- [How to: Overload a Procedure that Takes an Indefinite Number of Parameters](./how-to-overload-a-procedure-that-takes-an-indefinite-number-of-parameters.md)\n- [Considerations in Overloading Procedures](./considerations-in-overloading-procedures.md)\n- [Overloads](../../../../visual-basic/language-reference/modifiers/overloads.md)\n- [Extension Methods](./extension-methods.md)\n","nodes":[{"pos":[4,436],"embed":true,"restype":"x-metadata","content":"title: \"Overload Resolution (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Visual Basic code, procedures\"\n  - \"overload resolution\"\n  - \"procedures [Visual Basic], overloading\"\n  - \"procedures [Visual Basic], calling\"\n  - \"procedure overloading [Visual Basic], overload resolution\"\n  - \"signatures [Visual Basic], procedure\"\n  - \"overloads [Visual Basic], resolution\"\nms.assetid: 766115d1-4352-45fb-859f-6063e0de0ec0","nodes":[{"content":"Overload Resolution (Visual Basic)","nodes":[{"pos":[0,34],"content":"Overload Resolution (Visual Basic)","nodes":[{"content":"Overload Resolution (Visual Basic)","pos":[0,34]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[443,477],"content":"Overload Resolution (Visual Basic)","linkify":"Overload Resolution (Visual Basic)","nodes":[{"content":"Overload Resolution (Visual Basic)","pos":[0,34]}]},{"content":"When the Visual Basic compiler encounters a call to a procedure that is defined in several overloaded versions, the compiler must decide which of the overloads to call.","pos":[478,646]},{"content":"It does this by performing the following steps:","pos":[647,694]},{"content":"<bpt id=\"p1\">**</bpt>Accessibility.<ept id=\"p1\">**</ept>","pos":[704,722],"source":"**Accessibility.**"},{"content":"It eliminates any overload with an access level that prevents the calling code from calling it.","pos":[723,818]},{"content":"<bpt id=\"p1\">**</bpt>Number of Parameters.<ept id=\"p1\">**</ept>","pos":[828,853],"source":"**Number of Parameters.**"},{"content":"It eliminates any overload that defines a different number of parameters than are supplied in the call.","pos":[854,957]},{"content":"<bpt id=\"p1\">**</bpt>Parameter Data Types.<ept id=\"p1\">**</ept>","pos":[967,992],"source":"**Parameter Data Types.**"},{"content":"The compiler gives instance methods preference over extension methods.","pos":[993,1063]},{"content":"If any instance method is found that requires only widening conversions to match the procedure call, all extension methods are dropped and the compiler continues with only the instance method candidates.","pos":[1064,1267]},{"content":"If no such instance method is found, it continues with both instance and extension methods.","pos":[1268,1359]},{"content":"In this step, it eliminates any overload for which the data types of the calling arguments cannot be converted to the parameter types defined in the overload.","pos":[1370,1528]},{"content":"<bpt id=\"p1\">**</bpt>Narrowing Conversions.<ept id=\"p1\">**</ept>","pos":[1538,1564],"source":"**Narrowing Conversions.**"},{"content":"It eliminates any overload that requires a narrowing conversion from the calling argument types to the defined parameter types.","pos":[1565,1692]},{"content":"This is true whether the type checking switch (<bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>) is <ph id=\"ph1\">`On`</ph> or <ph id=\"ph2\">`Off`</ph>.","pos":[1693,1867],"source":" This is true whether the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On` or `Off`."},{"content":"<bpt id=\"p1\">**</bpt>Least Widening.<ept id=\"p1\">**</ept>","pos":[1877,1896],"source":"**Least Widening.**"},{"content":"The compiler considers the remaining overloads in pairs.","pos":[1897,1953]},{"content":"For each pair, it compares the data types of the defined parameters.","pos":[1954,2022]},{"content":"If the types in one of the overloads all widen to the corresponding types in the other, the compiler eliminates the latter.","pos":[2023,2146]},{"content":"That is, it retains the overload that requires the least amount of widening.","pos":[2147,2223]},{"content":"<bpt id=\"p1\">**</bpt>Single Candidate.<ept id=\"p1\">**</ept>","pos":[2233,2254],"source":"**Single Candidate.**"},{"content":"It continues considering overloads in pairs until only one overload remains, and it resolves the call to that overload.","pos":[2255,2374]},{"content":"If the compiler cannot reduce the overloads to a single candidate, it generates an error.","pos":[2375,2464]},{"content":"The following illustration shows the process that determines which of a set of overloaded versions to call.","pos":[2471,2578]},{"pos":[2585,2731],"content":"<bpt id=\"p1\">![</bpt>Flow diagram of overload resolution process<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/overload-resolution/determine-overloaded-version.gif \"</bpt>Resolving among overloaded versions<ept id=\"p2\">\")</ept>","source":"![Flow diagram of overload resolution process](./media/overload-resolution/determine-overloaded-version.gif \"Resolving among overloaded versions\")"},{"content":"The following example illustrates this overload resolution process.","pos":[2740,2807]},{"content":"In the first call, the compiler eliminates the first overload because the type of the first argument (<ph id=\"ph1\">`Short`</ph>) narrows to the type of the corresponding parameter (<ph id=\"ph2\">`Byte`</ph>).","pos":[3062,3233],"source":"In the first call, the compiler eliminates the first overload because the type of the first argument (`Short`) narrows to the type of the corresponding parameter (`Byte`)."},{"content":"It then eliminates the third overload because each argument type in the second overload (<ph id=\"ph1\">`Short`</ph> and <ph id=\"ph2\">`Single`</ph>) widens to the corresponding type in the third overload (<ph id=\"ph3\">`Integer`</ph> and <ph id=\"ph4\">`Single`</ph>).","pos":[3234,3425],"source":" It then eliminates the third overload because each argument type in the second overload (`Short` and `Single`) widens to the corresponding type in the third overload (`Integer` and `Single`)."},{"content":"The second overload requires less widening, so the compiler uses it for the call.","pos":[3426,3507]},{"content":"In the second call, the compiler cannot eliminate any of the overloads on the basis of narrowing.","pos":[3514,3611]},{"content":"It eliminates the third overload for the same reason as in the first call, because it can call the second overload with less widening of the argument types.","pos":[3612,3768]},{"content":"However, the compiler cannot resolve between the first and second overloads.","pos":[3769,3845]},{"content":"Each has one defined parameter type that widens to the corresponding type in the other (<ph id=\"ph1\">`Byte`</ph> to <ph id=\"ph2\">`Short`</ph>, but <ph id=\"ph3\">`Single`</ph> to <ph id=\"ph4\">`Double`</ph>).","pos":[3846,3979],"source":" Each has one defined parameter type that widens to the corresponding type in the other (`Byte` to `Short`, but `Single` to `Double`)."},{"content":"The compiler therefore generates an overload resolution error.","pos":[3980,4042]},{"pos":[4051,4095],"content":"Overloaded Optional and ParamArray Arguments","linkify":"Overloaded Optional and ParamArray Arguments","nodes":[{"content":"Overloaded Optional and ParamArray Arguments","pos":[0,44]}]},{"pos":[4099,4443],"content":"If two overloads of a procedure have identical signatures except that the last parameter is declared <bpt id=\"p1\">[</bpt>Optional<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/optional.md)</ept> in one and <bpt id=\"p2\">[</bpt>ParamArray<ept id=\"p2\">](../../../../visual-basic/language-reference/modifiers/paramarray.md)</ept> in the other, the compiler resolves a call to that procedure as follows:","source":"If two overloads of a procedure have identical signatures except that the last parameter is declared [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) in one and [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) in the other, the compiler resolves a call to that procedure as follows:"},{"content":"If the call supplies the last argument as","pos":[4450,4491]},{"content":"The compiler resolves the call to the overload declaring the last argument as","pos":[4492,4569]},{"content":"No value (argument omitted)","pos":[4586,4613]},{"content":"A single value","pos":[4629,4643]},{"content":"Two or more values in a comma-separated list","pos":[4659,4703]},{"content":"An array of any length (including an empty array)","pos":[4721,4770]},{"pos":[4793,4801],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4805,4852],"content":"<bpt id=\"p1\">[</bpt>Optional Parameters<ept id=\"p1\">](./optional-parameters.md)</ept>","source":"[Optional Parameters](./optional-parameters.md)"},{"pos":[4855,4896],"content":"<bpt id=\"p1\">[</bpt>Parameter Arrays<ept id=\"p1\">](./parameter-arrays.md)</ept>","source":"[Parameter Arrays](./parameter-arrays.md)"},{"pos":[4899,4950],"content":"<bpt id=\"p1\">[</bpt>Procedure Overloading<ept id=\"p1\">](./procedure-overloading.md)</ept>","source":"[Procedure Overloading](./procedure-overloading.md)"},{"pos":[4953,5014],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Procedures<ept id=\"p1\">](./troubleshooting-procedures.md)</ept>","source":"[Troubleshooting Procedures](./troubleshooting-procedures.md)"},{"pos":[5017,5119],"content":"<bpt id=\"p1\">[</bpt>How to: Define Multiple Versions of a Procedure<ept id=\"p1\">](./how-to-define-multiple-versions-of-a-procedure.md)</ept>","source":"[How to: Define Multiple Versions of a Procedure](./how-to-define-multiple-versions-of-a-procedure.md)"},{"pos":[5122,5202],"content":"<bpt id=\"p1\">[</bpt>How to: Call an Overloaded Procedure<ept id=\"p1\">](./how-to-call-an-overloaded-procedure.md)</ept>","source":"[How to: Call an Overloaded Procedure](./how-to-call-an-overloaded-procedure.md)"},{"pos":[5205,5331],"content":"<bpt id=\"p1\">[</bpt>How to: Overload a Procedure that Takes Optional Parameters<ept id=\"p1\">](./how-to-overload-a-procedure-that-takes-optional-parameters.md)</ept>","source":"[How to: Overload a Procedure that Takes Optional Parameters](./how-to-overload-a-procedure-that-takes-optional-parameters.md)"},{"pos":[5334,5490],"content":"<bpt id=\"p1\">[</bpt>How to: Overload a Procedure that Takes an Indefinite Number of Parameters<ept id=\"p1\">](./how-to-overload-a-procedure-that-takes-an-indefinite-number-of-parameters.md)</ept>","source":"[How to: Overload a Procedure that Takes an Indefinite Number of Parameters](./how-to-overload-a-procedure-that-takes-an-indefinite-number-of-parameters.md)"},{"pos":[5493,5582],"content":"<bpt id=\"p1\">[</bpt>Considerations in Overloading Procedures<ept id=\"p1\">](./considerations-in-overloading-procedures.md)</ept>","source":"[Considerations in Overloading Procedures](./considerations-in-overloading-procedures.md)"},{"pos":[5585,5664],"content":"<bpt id=\"p1\">[</bpt>Overloads<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/overloads.md)</ept>","source":"[Overloads](../../../../visual-basic/language-reference/modifiers/overloads.md)"},{"pos":[5667,5710],"content":"<bpt id=\"p1\">[</bpt>Extension Methods<ept id=\"p1\">](./extension-methods.md)</ept>","source":"[Extension Methods](./extension-methods.md)"}]}