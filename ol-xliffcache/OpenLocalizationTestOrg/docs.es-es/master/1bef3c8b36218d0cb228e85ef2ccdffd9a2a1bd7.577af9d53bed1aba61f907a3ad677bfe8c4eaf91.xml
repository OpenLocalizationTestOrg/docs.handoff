{"content":"---\ntitle: Unit Testing in .NET Core\ndescription: Unit Testing in .NET Core\nkeywords: .NET, .NET Core\nauthor: ardalis\nms.author: wiwagn\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.devlang: dotnet\nms.assetid: 815ac74c-4bd9-4a94-a87c-78288b27c0e2\n---\n\n# Unit Testing in .NET Core\n\n.NET Core has been designed with testability in mind, so that creating unit tests for your applications is easier than ever before. This article briefly introduces unit tests (and how they differ from other kinds of tests). Linked resources demonstrates how to add a test project to your solution and then run unit tests using either the command line or Visual Studio.\n\n## Getting Started with Testing\n \nHaving a suite of automated tests is one of the best ways to ensure a software application does what its authors intended it to do. There are many different kinds of tests for software applications, including integration tests, web tests, load tests, and many others. At the lowest level are unit tests, which test individual software components or methods. Unit tests should only test code within the developer’s control, and should not test infrastructure concerns, like databases, file systems, or network resources. Unit tests may be written using [Test Driven Development (TDD)](http://deviq.com/test-driven-development/), or they can be added to existing code to confirm its correctness. In either case, they should be small, well-named, and fast, since ideally you will want to be able to run hundreds of them before pushing your changes into the project’s shared code repository.\n\n> [!NOTE]\n> Developers often struggle with coming up with good names for their test classes and methods. As a starting point, the ASP.NET product team follows [these conventions](https://github.com/aspnet/Home/wiki/Engineering-guidelines#unit-tests-and-functional-tests).\n\nWhen writing unit tests, be careful you don’t accidentally introduce dependencies on infrastructure. These tend to make tests slower and more brittle, and thus should be reserved for integration tests. You can avoid these hidden dependencies in your application code by following the [Explicit Dependencies Principle](http://deviq.com/explicit-dependencies-principle/) and using [Dependency Injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection) to request your dependencies from the framework. You can also keep your unit tests in a separate project from your integration tests, and ensure your unit test project doesn’t have references to or dependencies on infrastructure packages.\n\nLearn more about unit testing in .NET Core projects:\n\n* Try this [walkthrough creating unit tests with xUnit and the .NET CLI](unit-testing-with-dotnet-test.md). \n* The XUnit team has written a tutorial that shows\n[how to use xUnit with .NET Core and Visual Studio](http://xunit.github.io/docs/getting-started-dotnet-core.html).\n* If you prefer using MSTest, try the [walkthrough creating unit tests with MSTest and the .NET CLI](unit-testing-with-mstest.md).\n* For a additional information and examples on how to use selective unit test filtering, see [Running selective unit tests](../testing/selective-unit-tests.md).\n","nodes":[{"pos":[11,36],"content":"Unit Testing in .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":"Unit Testing in .NET Core","pos":[0,25]}]},{"pos":[50,75],"content":"Unit Testing in .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":"Unit Testing in .NET Core","pos":[0,25]}]},{"pos":[86,101],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[268,293],"content":"Unit Testing in .NET Core","linkify":"Unit Testing in .NET Core","nodes":[{"content":"Unit Testing in .NET Core","pos":[0,25]}]},{"content":".NET Core has been designed with testability in mind, so that creating unit tests for your applications is easier than ever before.","pos":[295,426]},{"content":"This article briefly introduces unit tests (and how they differ from other kinds of tests).","pos":[427,518]},{"content":"Linked resources demonstrates how to add a test project to your solution and then run unit tests using either the command line or Visual Studio.","pos":[519,663]},{"pos":[668,696],"content":"Getting Started with Testing","linkify":"Getting Started with Testing","nodes":[{"content":"Getting Started with Testing","pos":[0,28]}]},{"content":"Having a suite of automated tests is one of the best ways to ensure a software application does what its authors intended it to do.","pos":[699,830]},{"content":"There are many different kinds of tests for software applications, including integration tests, web tests, load tests, and many others.","pos":[831,966]},{"content":"At the lowest level are unit tests, which test individual software components or methods.","pos":[967,1056]},{"content":"Unit tests should only test code within the developer’s control, and should not test infrastructure concerns, like databases, file systems, or network resources.","pos":[1057,1218]},{"content":"Unit tests may be written using <bpt id=\"p1\">[</bpt>Test Driven Development (TDD)<ept id=\"p1\">](http://deviq.com/test-driven-development/)</ept>, or they can be added to existing code to confirm its correctness.","pos":[1219,1392],"source":" Unit tests may be written using [Test Driven Development (TDD)](http://deviq.com/test-driven-development/), or they can be added to existing code to confirm its correctness."},{"content":"In either case, they should be small, well-named, and fast, since ideally you will want to be able to run hundreds of them before pushing your changes into the project’s shared code repository.","pos":[1393,1586]},{"pos":[1590,1859],"content":"[!NOTE]\nDevelopers often struggle with coming up with good names for their test classes and methods. As a starting point, the ASP.NET product team follows [these conventions](https://github.com/aspnet/Home/wiki/Engineering-guidelines#unit-tests-and-functional-tests).","leadings":["","> "],"nodes":[{"content":"Developers often struggle with coming up with good names for their test classes and methods. As a starting point, the ASP.NET product team follows [these conventions](https://github.com/aspnet/Home/wiki/Engineering-guidelines#unit-tests-and-functional-tests).","pos":[8,267],"nodes":[{"content":"Developers often struggle with coming up with good names for their test classes and methods.","pos":[0,92]},{"content":"As a starting point, the ASP.NET product team follows <bpt id=\"p1\">[</bpt>these conventions<ept id=\"p1\">](https://github.com/aspnet/Home/wiki/Engineering-guidelines#unit-tests-and-functional-tests)</ept>.","pos":[93,259],"source":" As a starting point, the ASP.NET product team follows [these conventions](https://github.com/aspnet/Home/wiki/Engineering-guidelines#unit-tests-and-functional-tests)."}]}]},{"content":"When writing unit tests, be careful you don’t accidentally introduce dependencies on infrastructure.","pos":[1861,1961]},{"content":"These tend to make tests slower and more brittle, and thus should be reserved for integration tests.","pos":[1962,2062]},{"content":"You can avoid these hidden dependencies in your application code by following the <bpt id=\"p1\">[</bpt>Explicit Dependencies Principle<ept id=\"p1\">](http://deviq.com/explicit-dependencies-principle/)</ept> and using <bpt id=\"p2\">[</bpt>Dependency Injection<ept id=\"p2\">](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)</ept> to request your dependencies from the framework.","pos":[2063,2391],"source":" You can avoid these hidden dependencies in your application code by following the [Explicit Dependencies Principle](http://deviq.com/explicit-dependencies-principle/) and using [Dependency Injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection) to request your dependencies from the framework."},{"content":"You can also keep your unit tests in a separate project from your integration tests, and ensure your unit test project doesn’t have references to or dependencies on infrastructure packages.","pos":[2392,2581]},{"content":"Learn more about unit testing in .NET Core projects:","pos":[2583,2635]},{"pos":[2639,2744],"content":"Try this <bpt id=\"p1\">[</bpt>walkthrough creating unit tests with xUnit and the .NET CLI<ept id=\"p1\">](unit-testing-with-dotnet-test.md)</ept>.","source":"Try this [walkthrough creating unit tests with xUnit and the .NET CLI](unit-testing-with-dotnet-test.md)."},{"pos":[2748,2911],"content":"The XUnit team has written a tutorial that shows <bpt id=\"p1\">[</bpt>how to use xUnit with .NET Core and Visual Studio<ept id=\"p1\">](http://xunit.github.io/docs/getting-started-dotnet-core.html)</ept>.","source":"The XUnit team has written a tutorial that shows\n[how to use xUnit with .NET Core and Visual Studio](http://xunit.github.io/docs/getting-started-dotnet-core.html)."},{"pos":[2914,3042],"content":"If you prefer using MSTest, try the <bpt id=\"p1\">[</bpt>walkthrough creating unit tests with MSTest and the .NET CLI<ept id=\"p1\">](unit-testing-with-mstest.md)</ept>.","source":"If you prefer using MSTest, try the [walkthrough creating unit tests with MSTest and the .NET CLI](unit-testing-with-mstest.md)."},{"pos":[3045,3203],"content":"For a additional information and examples on how to use selective unit test filtering, see <bpt id=\"p1\">[</bpt>Running selective unit tests<ept id=\"p1\">](../testing/selective-unit-tests.md)</ept>.","source":"For a additional information and examples on how to use selective unit test filtering, see [Running selective unit tests](../testing/selective-unit-tests.md)."}]}