{"content":"---\ntitle: Translating Expression Trees\ndescription: Learn how to visit each node in an expression tree while building a modified copy of that expression tree.\nms.date: 06/20/2016\nms.assetid: b453c591-acc6-4e08-8175-97e5bc65958e\n---\n\n# Translating Expression Trees\n\n[Previous -- Building Expressions](expression-trees-building.md)\n\nIn this final section, you'll learn how to visit each node\nin an expression tree while building a modified copy of that\nexpression tree. These are the techniques that you will use in two\nimportant scenarios. The first is to understand the algorithms\nexpressed by an expression tree so that it can be translated\ninto another environment. The second is when you want to change\nthe algorithm that has been created. This might be to add logging,\nintercept method calls and track them, or other purposes.\n\n## Translating is Visiting\n\nThe code you build to translate an expression tree is an extension\nof what you've already seen to visit all the nodes in a tree. When\nyou translate an expression tree, you visit all the nodes, and while\nvisiting them, build the new tree. The new tree may contain references\nto the original nodes, or new nodes that you have placed in the tree.\n\nLet's see this in action by visiting an expression tree, and\ncreating a new tree with some replacement nodes. In this example,\nlet's replace any constant with a constant that is ten times larger.\nOtherwise, we'll leave the expression tree intact. Rather than\nreading the value of the constant, and replacing it with a new\nconstant, we'll make this replacement by replacing the constant\nnode with a new node that performs the multiplication.\n\nHere, once you find a constant node, you create a new multiplication\nnode whose children are the original constant, and the constant\n`10`:\n\n```csharp\nprivate static Expression ReplaceNodes(Expression original)\n{\n    if (original.NodeType == ExpressionType.Constant)\n    {\n        return Expression.Multiply(original, Expression.Constant(10));\n    }\n    else if (original.NodeType == ExpressionType.Add)\n    {\n        var binaryExpression = (BinaryExpression)original;\n        return Expression.Add(\n            ReplaceNodes(binaryExpression.Left),\n            ReplaceNodes(binaryExpression.Right));\n    }\n    return original;\n}\n```\n\nBy replacing the original node with the substitute, a new tree\nis formed that contains our modifications. We can verify that by\ncompiling and executing the replaced tree.\n\n```csharp\nvar one = Expression.Constant(1, typeof(int));\nvar two = Expression.Constant(2, typeof(int));\nvar addition = Expression.Add(one, two);\nvar sum = ReplaceNodes(addition);\nvar executableFunc = Expression.Lambda(sum);\n\nvar func = (Func<int>)executableFunc.Compile();\nvar answer = func();\nConsole.WriteLine(answer);\n```\n\nBuilding a new tree is a combination of visiting the nodes in\nthe existing tree, and creating new nodes and inserting them\ninto the tree.\n\nThis example shows the importance of expression trees being\nimmutable. Notice that the new tree created above contains a\nmixture of newly created nodes, and nodes from the existing\ntree. That's safe, because the nodes in the existing tree cannot be\nmodified. This can result in significant memory efficiencies.\nThe same nodes can be used throughout a tree, or in multiple\nexpression trees. Since nodes can't be modified, the\nsame node can be reused whenever its needed.\n\n## Traversing and Executing an Addition\n\nLet's verify this by building a second visitor that walks the tree\nof addition nodes and computes the result. You can do this by\nmaking a couple modifications to the visitor that you've seen so\nfar. In this new version, the visitor will return the partial sum\nof the addition operation up to this point. For a constant expression,\nthat is simply the value of the constant expression. For an addition\nexpression, the result is the sum of the left and right operands, once\nthose trees have been traversed.\n\n```csharp\nvar one = Expression.Constant(1, typeof(int));\nvar two = Expression.Constant(2, typeof(int));\nvar three= Expression.Constant(3, typeof(int));\nvar four = Expression.Constant(4, typeof(int));\nvar addition = Expression.Add(one, two);\nvar add2 = Expression.Add(three, four);\nvar sum = Expression.Add(addition, add2);\n\n// Declare the delegate, so we can call it\n// from itself recursively:\nFunc<Expression, int> aggregate = null;\n// Aggregate, return constants, or the sum of the left and right operand.\n// Major simplification: Assume every binary expression is an addition.\naggregate = (exp) =>\n    exp.NodeType == ExpressionType.Constant ?\n    (int)((ConstantExpression)exp).Value :\n    aggregate(((BinaryExpression)exp).Left) + aggregate(((BinaryExpression)exp).Right);\n\nvar theSum = aggregate(sum);\nConsole.WriteLine(theSum);\n```\n\nThere's quite a bit of code here, but the concepts are very approachable.\nThis code visits children in a depth first search. When it encounters a\nconstant node, the visitor returns the value of the constant. After the\nvisitor has visited both children, those children will have computed the sum\ncomputed for that sub-tree. The addition node can now compute its sum.\nOnce all the nodes in the expression tree have been visited, the sum\nwill have been computed. You can trace the execution by running the sample\nin the debugger and tracing the execution.\n\nLet's make it easier to trace how the nodes are analyzed and how the sum\nis computed by traversing the tree. Here's an updated version of the\nAggregate method that includes quite a bit of tracing information:\n\n```csharp\nprivate static int Aggregate(Expression exp)\n{\n    if (exp.NodeType == ExpressionType.Constant)\n    {\n        var constantExp = (ConstantExpression)exp;\n        Console.Error.WriteLine($\"Found Constant: {constantExp.Value}\");\n        return (int)constantExp.Value;\n    }\n    else if (exp.NodeType == ExpressionType.Add)\n    {\n        var addExp = (BinaryExpression)exp;\n        Console.Error.WriteLine(\"Found Addition Expression\");\n        Console.Error.WriteLine(\"Computing Left node\");\n        var leftOperand = Aggregate(addExp.Left);\n        Console.Error.WriteLine($\"Left is: {leftOperand}\");\n        Console.Error.WriteLine(\"Computing Right node\");\n        var rightOperand = Aggregate(addExp.Right);\n        Console.Error.WriteLine($\"Right is: {rightOperand}\");\n        var sum = leftOperand + rightOperand;\n        Console.Error.WriteLine($\"Computed sum: {sum}\");\n        return sum;\n    }\n    else throw new NotSupportedException(\"Haven't written this yet\");\n}\n```\n\nRunning it on the same expression yields the following output:\n\n```\n10\nFound Addition Expression\nComputing Left node\nFound Addition Expression\nComputing Left node\nFound Constant: 1\nLeft is: 1\nComputing Right node\nFound Constant: 2\nRight is: 2\nComputed sum: 3\nLeft is: 3\nComputing Right node\nFound Addition Expression\nComputing Left node\nFound Constant: 3\nLeft is: 3\nComputing Right node\nFound Constant: 4\nRight is: 4\nComputed sum: 7\nRight is: 7\nComputed sum: 10\n10\n```\n\nTrace the output and follow along in the code above. You should be able\nto work out how the code visits each node and computes the sum as it goes\nthrough the tree and finds the sum.\n\nNow, let's look at a different run, with the expression given by `sum1`:\n\n```csharp\nExpression<Func<int> sum1 = () => 1 + (2 + (3 + 4));\n```\n\nHere's the output from examining this expression:\n\n```\nFound Addition Expression\nComputing Left node\nFound Constant: 1\nLeft is: 1\nComputing Right node\nFound Addition Expression\nComputing Left node\nFound Constant: 2\nLeft is: 2\nComputing Right node\nFound Addition Expression\nComputing Left node\nFound Constant: 3\nLeft is: 3\nComputing Right node\nFound Constant: 4\nRight is: 4\nComputed sum: 7\nRight is: 7\nComputed sum: 9\nRight is: 9\nComputed sum: 10\n10\n```\n\nWhile the final answer is the same, the tree traversal is completely\ndifferent. The nodes are traveled in a different order, because the\ntree was constructed with different operations occurring first.\n\n## Learning More\n\nThis sample shows a small subset of the code you would build to traverse\nand interpret the algorithms represented by an expression tree. For a complete\ndiscussion of all the work necessary to build a general purpose library that\ntranslates expression trees into another language, please read\n[this series](https://blogs.msdn.com/b/mattwar/archive/2008/11/18/linq-links.aspx)\nby Matt Warren. It goes into great detail on how to translate any of the code\nyou might find in an expression tree.\n\nI hope you've now seen the true power of expression trees.\nYou can examine a set of code, make any changes you'd like to\nthat code, and execute the changed version. Because the\nexpression trees are immutable, you can create new trees by\nusing the components of existing trees. This minimizes the\namount of memory needed to create modified expression trees.\n\n[Next -- Summing up](expression-trees-summary.md)\n","nodes":[{"pos":[4,228],"embed":true,"restype":"x-metadata","content":"title: Translating Expression Trees\ndescription: Learn how to visit each node in an expression tree while building a modified copy of that expression tree.\nms.date: 06/20/2016\nms.assetid: b453c591-acc6-4e08-8175-97e5bc65958e","nodes":[{"content":"Translating Expression Trees","nodes":[{"pos":[0,28],"content":"Translating Expression Trees","nodes":[{"content":"Translating Expression Trees","pos":[0,28]}]}],"path":["title"],"nosxs":false},{"content":"Learn how to visit each node in an expression tree while building a modified copy of that expression tree.","nodes":[{"pos":[0,106],"content":"Learn how to visit each node in an expression tree while building a modified copy of that expression tree.","nodes":[{"content":"Learn how to visit each node in an expression tree while building a modified copy of that expression tree.","pos":[0,106]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[236,264],"content":"Translating Expression Trees","linkify":"Translating Expression Trees","nodes":[{"content":"Translating Expression Trees","pos":[0,28]}]},{"pos":[266,330],"content":"<bpt id=\"p1\">[</bpt>Previous -- Building Expressions<ept id=\"p1\">](expression-trees-building.md)</ept>","source":"[Previous -- Building Expressions](expression-trees-building.md)"},{"content":"In this final section, you'll learn how to visit each node in an expression tree while building a modified copy of that expression tree.","pos":[332,468],"source":"In this final section, you'll learn how to visit each node\nin an expression tree while building a modified copy of that\nexpression tree."},{"content":"These are the techniques that you will use in two important scenarios.","pos":[469,539],"source":" These are the techniques that you will use in two\nimportant scenarios."},{"content":"The first is to understand the algorithms expressed by an expression tree so that it can be translated into another environment.","pos":[540,668],"source":" The first is to understand the algorithms\nexpressed by an expression tree so that it can be translated\ninto another environment."},{"content":"The second is when you want to change the algorithm that has been created.","pos":[669,743],"source":" The second is when you want to change\nthe algorithm that has been created."},{"content":"This might be to add logging, intercept method calls and track them, or other purposes.","pos":[744,831],"source":" This might be to add logging,\nintercept method calls and track them, or other purposes."},{"pos":[836,859],"content":"Translating is Visiting","linkify":"Translating is Visiting","nodes":[{"content":"Translating is Visiting","pos":[0,23]}]},{"content":"The code you build to translate an expression tree is an extension of what you've already seen to visit all the nodes in a tree.","pos":[861,989],"source":"The code you build to translate an expression tree is an extension\nof what you've already seen to visit all the nodes in a tree."},{"content":"When you translate an expression tree, you visit all the nodes, and while visiting them, build the new tree.","pos":[990,1098],"source":" When\nyou translate an expression tree, you visit all the nodes, and while\nvisiting them, build the new tree."},{"content":"The new tree may contain references to the original nodes, or new nodes that you have placed in the tree.","pos":[1099,1204],"source":" The new tree may contain references\nto the original nodes, or new nodes that you have placed in the tree."},{"content":"Let's see this in action by visiting an expression tree, and creating a new tree with some replacement nodes.","pos":[1206,1315],"source":"Let's see this in action by visiting an expression tree, and\ncreating a new tree with some replacement nodes."},{"content":"In this example, let's replace any constant with a constant that is ten times larger.","pos":[1316,1401],"source":" In this example,\nlet's replace any constant with a constant that is ten times larger."},{"content":"Otherwise, we'll leave the expression tree intact.","pos":[1402,1452],"source":"\nOtherwise, we'll leave the expression tree intact."},{"content":"Rather than reading the value of the constant, and replacing it with a new constant, we'll make this replacement by replacing the constant node with a new node that performs the multiplication.","pos":[1453,1646],"source":" Rather than\nreading the value of the constant, and replacing it with a new\nconstant, we'll make this replacement by replacing the constant\nnode with a new node that performs the multiplication."},{"pos":[1648,1786],"content":"Here, once you find a constant node, you create a new multiplication node whose children are the original constant, and the constant <ph id=\"ph1\">`10`</ph>:","source":"Here, once you find a constant node, you create a new multiplication\nnode whose children are the original constant, and the constant\n`10`:"},{"content":"By replacing the original node with the substitute, a new tree is formed that contains our modifications.","pos":[2281,2386],"source":"By replacing the original node with the substitute, a new tree\nis formed that contains our modifications."},{"content":"We can verify that by compiling and executing the replaced tree.","pos":[2387,2451],"source":" We can verify that by\ncompiling and executing the replaced tree."},{"pos":[2779,2916],"content":"Building a new tree is a combination of visiting the nodes in the existing tree, and creating new nodes and inserting them into the tree.","source":"Building a new tree is a combination of visiting the nodes in\nthe existing tree, and creating new nodes and inserting them\ninto the tree."},{"content":"This example shows the importance of expression trees being immutable.","pos":[2918,2988],"source":"This example shows the importance of expression trees being\nimmutable."},{"content":"Notice that the new tree created above contains a mixture of newly created nodes, and nodes from the existing tree.","pos":[2989,3104],"source":" Notice that the new tree created above contains a\nmixture of newly created nodes, and nodes from the existing\ntree."},{"content":"That's safe, because the nodes in the existing tree cannot be modified.","pos":[3105,3176],"source":" That's safe, because the nodes in the existing tree cannot be\nmodified."},{"content":"This can result in significant memory efficiencies.","pos":[3177,3228]},{"content":"The same nodes can be used throughout a tree, or in multiple expression trees.","pos":[3229,3307],"source":"\nThe same nodes can be used throughout a tree, or in multiple\nexpression trees."},{"content":"Since nodes can't be modified, the same node can be reused whenever its needed.","pos":[3308,3387],"source":" Since nodes can't be modified, the\nsame node can be reused whenever its needed."},{"pos":[3392,3428],"content":"Traversing and Executing an Addition","linkify":"Traversing and Executing an Addition","nodes":[{"content":"Traversing and Executing an Addition","pos":[0,36]}]},{"content":"Let's verify this by building a second visitor that walks the tree of addition nodes and computes the result.","pos":[3430,3539],"source":"Let's verify this by building a second visitor that walks the tree\nof addition nodes and computes the result."},{"content":"You can do this by making a couple modifications to the visitor that you've seen so far.","pos":[3540,3628],"source":" You can do this by\nmaking a couple modifications to the visitor that you've seen so\nfar."},{"content":"In this new version, the visitor will return the partial sum of the addition operation up to this point.","pos":[3629,3733],"source":" In this new version, the visitor will return the partial sum\nof the addition operation up to this point."},{"content":"For a constant expression, that is simply the value of the constant expression.","pos":[3734,3813],"source":" For a constant expression,\nthat is simply the value of the constant expression."},{"content":"For an addition expression, the result is the sum of the left and right operands, once those trees have been traversed.","pos":[3814,3933],"source":" For an addition\nexpression, the result is the sum of the left and right operands, once\nthose trees have been traversed."},{"content":"There's quite a bit of code here, but the concepts are very approachable.","pos":[4776,4849]},{"content":"This code visits children in a depth first search.","pos":[4850,4900],"source":"\nThis code visits children in a depth first search."},{"content":"When it encounters a constant node, the visitor returns the value of the constant.","pos":[4901,4983],"source":" When it encounters a\nconstant node, the visitor returns the value of the constant."},{"content":"After the visitor has visited both children, those children will have computed the sum computed for that sub-tree.","pos":[4984,5098],"source":" After the\nvisitor has visited both children, those children will have computed the sum\ncomputed for that sub-tree."},{"content":"The addition node can now compute its sum.","pos":[5099,5141]},{"content":"Once all the nodes in the expression tree have been visited, the sum will have been computed.","pos":[5142,5235],"source":"\nOnce all the nodes in the expression tree have been visited, the sum\nwill have been computed."},{"content":"You can trace the execution by running the sample in the debugger and tracing the execution.","pos":[5236,5328],"source":" You can trace the execution by running the sample\nin the debugger and tracing the execution."},{"content":"Let's make it easier to trace how the nodes are analyzed and how the sum is computed by traversing the tree.","pos":[5330,5438],"source":"Let's make it easier to trace how the nodes are analyzed and how the sum\nis computed by traversing the tree."},{"content":"Here's an updated version of the Aggregate method that includes quite a bit of tracing information:","pos":[5439,5538],"source":" Here's an updated version of the\nAggregate method that includes quite a bit of tracing information:"},{"content":"Running it on the same expression yields the following output:","pos":[6525,6587]},{"content":"Trace the output and follow along in the code above.","pos":[6995,7047]},{"content":"You should be able to work out how the code visits each node and computes the sum as it goes through the tree and finds the sum.","pos":[7048,7176],"source":" You should be able\nto work out how the code visits each node and computes the sum as it goes\nthrough the tree and finds the sum."},{"pos":[7178,7250],"content":"Now, let's look at a different run, with the expression given by <ph id=\"ph1\">`sum1`</ph>:","source":"Now, let's look at a different run, with the expression given by `sum1`:"},{"content":"Here's the output from examining this expression:","pos":[7320,7369]},{"content":"While the final answer is the same, the tree traversal is completely different.","pos":[7774,7853],"source":"While the final answer is the same, the tree traversal is completely\ndifferent."},{"content":"The nodes are traveled in a different order, because the tree was constructed with different operations occurring first.","pos":[7854,7974],"source":" The nodes are traveled in a different order, because the\ntree was constructed with different operations occurring first."},{"pos":[7979,7992],"content":"Learning More","linkify":"Learning More","nodes":[{"content":"Learning More","pos":[0,13]}]},{"content":"This sample shows a small subset of the code you would build to traverse and interpret the algorithms represented by an expression tree.","pos":[7994,8130],"source":"This sample shows a small subset of the code you would build to traverse\nand interpret the algorithms represented by an expression tree."},{"content":"For a complete discussion of all the work necessary to build a general purpose library that translates expression trees into another language, please read <bpt id=\"p1\">[</bpt>this series<ept id=\"p1\">](https://blogs.msdn.com/b/mattwar/archive/2008/11/18/linq-links.aspx)</ept> by Matt Warren.","pos":[8131,8384],"source":" For a complete\ndiscussion of all the work necessary to build a general purpose library that\ntranslates expression trees into another language, please read\n[this series](https://blogs.msdn.com/b/mattwar/archive/2008/11/18/linq-links.aspx)\nby Matt Warren."},{"content":"It goes into great detail on how to translate any of the code you might find in an expression tree.","pos":[8385,8484],"source":" It goes into great detail on how to translate any of the code\nyou might find in an expression tree."},{"content":"I hope you've now seen the true power of expression trees.","pos":[8486,8544]},{"content":"You can examine a set of code, make any changes you'd like to that code, and execute the changed version.","pos":[8545,8650],"source":"\nYou can examine a set of code, make any changes you'd like to\nthat code, and execute the changed version."},{"content":"Because the expression trees are immutable, you can create new trees by using the components of existing trees.","pos":[8651,8762],"source":" Because the\nexpression trees are immutable, you can create new trees by\nusing the components of existing trees."},{"content":"This minimizes the amount of memory needed to create modified expression trees.","pos":[8763,8842],"source":" This minimizes the\namount of memory needed to create modified expression trees."},{"pos":[8844,8893],"content":"<bpt id=\"p1\">[</bpt>Next -- Summing up<ept id=\"p1\">](expression-trees-summary.md)</ept>","source":"[Next -- Summing up](expression-trees-summary.md)"}]}