{"content":"---\ntitle: \"LINQ to SQL N-Tier with Web Services\"\nms.date: \"03/30/2017\"\nms.assetid: 9cb10eb8-957f-4beb-a271-5f682016fed2\n---\n# LINQ to SQL N-Tier with Web Services\n[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is designed especially for use on the middle tier in a loosely-coupled data access layer (DAL) such as a Web service. If the presentation tier is an ASP.NET Web page, then you use the <xref:System.Web.UI.WebControls.LinqDataSource> Web server control to manage the data transfer between the user interface and [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] on the middle-tier. If the presentation tier is not an ASP.NET page, then both the middle-tier and the presentation tier must do some additional work to manage the serialization and deserialization of data.  \n  \n## Setting up LINQ to SQL on the Middle Tier  \n In a Web service or n-tier application, the middle tier contains the data context and the entity classes. You can create these classes manually, or by using either SQLMetal.exe or the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] as described elsewhere in the documentation. At design time, you have the option to make the entity classes serializable. For more information, see [How to: Make Entities Serializable](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md). Another option is to create a separate set of classes that encapsulate the data to be serialized, and then project into those serializable types when you return data in your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries.  \n  \n You then define the interface with the methods that the clients will call to retrieve, insert and update data. The interface methods wrap your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries. You can use any kind of serialization mechanism to handle the remote method calls and the serialization of data. The only requirement is that if you have cyclic or bi-directional relationships in your object model, such as that between Customers and Orders in the standard Northwind object model, then you must use a serializer that supports it. The Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> supports bi-directional relationships but the XmlSerializer that is used with non-WCF Web services does not. If you select to use the XmlSerializer, then you must make sure that your object model has no cyclic relationships.  \n  \n For more information about Windows Communication Foundation, see [Windows Communication Foundation Services and WCF Data Services in Visual Studio](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio).  \n  \n Implement your business rules or other domain-specific logic by using the partial classes and methods on the <xref:System.Data.Linq.DataContext> and entity classes to hook into [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime events. For more information, see [Implementing N-Tier Business Logic](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md).  \n  \n## Defining the Serializable Types  \n The client or presentation tier must have type definitions for the classes that it will be receiving from the middle tier. Those types may be the entity classes themselves, or special classes that wrap only certain fields from the entity classes for remoting. In any case, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is completely unconcerned about how the presentation tier acquires those type definitions. For example, the presentation tier could use WCF to generate the types automatically, or it could have a copy of a DLL in which those types are defined, or it could just define its own versions of the types.  \n  \n## Retrieving and Inserting Data  \n The middle tier defines an interface that specifies how the presentation tier accesses the data. For example `GetProductByID(int productID)`, or `GetCustomers()`. On the middle tier, the method body typically creates a new instance of the <xref:System.Data.Linq.DataContext>, executes a query against one or more of its table. The middle tier then returns the result as an <xref:System.Collections.Generic.IEnumerable%601>, where `T` is either an entity class or another type that is used for serialization. The presentation tier never sends or receives query variables directly to or from the middle tier. The two tiers exchange values, objects, and collections of concrete data. After it has received a collection, the presentation tier can use [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects to query it if necessary.  \n  \n When inserting data, the presentation tier can construct a new object and send it to the middle tier, or it can have the middle tier construct the object based on values that it provides. In general, retrieving and inserting data in n-tier applications does not differ much from the process in 2-tier applications. For more information, see [Querying the Database](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md) and [Making and Submitting Data Changes](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md).  \n  \n## Tracking Changes for Updates and Deletes  \n [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] supports optimistic concurrency based on timestamps (also named RowVersions) and on original values. If the database tables have timestamps, then updates and deletions require little extra work on either the middle-tier or presentation tier. However, if you must use original values for optimistic concurrency checks, then the presentation tier is responsible for tracking those values and sending them back when it makes updates. This is because changes that were made to entities on the presentation tier are not tracked on the middle tier. In fact, the original retrieval of an entity, and the eventual update made to it are typically performed by two completely separate instances of the <xref:System.Data.Linq.DataContext>.  \n  \n The greater the number of changes that the presentation tier makes, the more complex it becomes to track those changes and package them back to the middle tier. The implementation of a mechanism for communicating changes is completely up to the application. The only requirement is that [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] must be given those original values that are required for optimistic concurrency checks.  \n  \n For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  \n  \n## See also\n\n- [N-Tier and Remote Applications with LINQ to SQL](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)\n- [LinqDataSource Web Server Control Overview](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))\n","nodes":[{"pos":[4,120],"embed":true,"restype":"x-metadata","content":"title: \"LINQ to SQL N-Tier with Web Services\"\nms.date: \"03/30/2017\"\nms.assetid: 9cb10eb8-957f-4beb-a271-5f682016fed2","nodes":[{"content":"LINQ to SQL N-Tier with Web Services","nodes":[{"pos":[0,36],"content":"LINQ to SQL N-Tier with Web Services","nodes":[{"content":"LINQ to SQL N-Tier with Web Services","pos":[0,36]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[127,163],"content":"LINQ to SQL N-Tier with Web Services","linkify":"LINQ to SQL N-Tier with Web Services","nodes":[{"content":"LINQ to SQL N-Tier with Web Services","pos":[0,36]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> is designed especially for use on the middle tier in a loosely-coupled data access layer (DAL) such as a Web service.","pos":[164,349],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is designed especially for use on the middle tier in a loosely-coupled data access layer (DAL) such as a Web service."},{"content":"If the presentation tier is an ASP.NET Web page, then you use the <ph id=\"ph1\">&lt;xref:System.Web.UI.WebControls.LinqDataSource&gt;</ph> Web server control to manage the data transfer between the user interface and <ph id=\"ph2\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> on the middle-tier.","pos":[350,629],"source":" If the presentation tier is an ASP.NET Web page, then you use the <xref:System.Web.UI.WebControls.LinqDataSource> Web server control to manage the data transfer between the user interface and [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] on the middle-tier."},{"content":"If the presentation tier is not an ASP.NET page, then both the middle-tier and the presentation tier must do some additional work to manage the serialization and deserialization of data.","pos":[630,816]},{"pos":[825,866],"content":"Setting up LINQ to SQL on the Middle Tier","linkify":"Setting up LINQ to SQL on the Middle Tier","nodes":[{"content":"Setting up LINQ to SQL on the Middle Tier","pos":[0,41]}]},{"content":"In a Web service or n-tier application, the middle tier contains the data context and the entity classes.","pos":[870,975]},{"content":"You can create these classes manually, or by using either SQLMetal.exe or the <ph id=\"ph1\">[!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)]</ph> as described elsewhere in the documentation.","pos":[976,1182],"source":" You can create these classes manually, or by using either SQLMetal.exe or the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] as described elsewhere in the documentation."},{"content":"At design time, you have the option to make the entity classes serializable.","pos":[1183,1259]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Make Entities Serializable<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md)</ept>.","pos":[1260,1415],"source":" For more information, see [How to: Make Entities Serializable](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md)."},{"content":"Another option is to create a separate set of classes that encapsulate the data to be serialized, and then project into those serializable types when you return data in your <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)]</ph> queries.","pos":[1416,1664],"source":" Another option is to create a separate set of classes that encapsulate the data to be serialized, and then project into those serializable types when you return data in your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries."},{"content":"You then define the interface with the methods that the clients will call to retrieve, insert and update data.","pos":[1671,1781]},{"content":"The interface methods wrap your <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)]</ph> queries.","pos":[1782,1888],"source":" The interface methods wrap your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries."},{"content":"You can use any kind of serialization mechanism to handle the remote method calls and the serialization of data.","pos":[1889,2001]},{"content":"The only requirement is that if you have cyclic or bi-directional relationships in your object model, such as that between Customers and Orders in the standard Northwind object model, then you must use a serializer that supports it.","pos":[2002,2234]},{"content":"The Windows Communication Foundation (WCF) <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> supports bi-directional relationships but the XmlSerializer that is used with non-WCF Web services does not.","pos":[2235,2445],"source":" The Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> supports bi-directional relationships but the XmlSerializer that is used with non-WCF Web services does not."},{"content":"If you select to use the XmlSerializer, then you must make sure that your object model has no cyclic relationships.","pos":[2446,2561]},{"pos":[2568,2823],"content":"For more information about Windows Communication Foundation, see <bpt id=\"p1\">[</bpt>Windows Communication Foundation Services and WCF Data Services in Visual Studio<ept id=\"p1\">](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio)</ept>.","source":"For more information about Windows Communication Foundation, see [Windows Communication Foundation Services and WCF Data Services in Visual Studio](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio)."},{"content":"Implement your business rules or other domain-specific logic by using the partial classes and methods on the <ph id=\"ph1\">&lt;xref:System.Data.Linq.DataContext&gt;</ph> and entity classes to hook into <ph id=\"ph2\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> runtime events.","pos":[2830,3090],"source":"Implement your business rules or other domain-specific logic by using the partial classes and methods on the <xref:System.Data.Linq.DataContext> and entity classes to hook into [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime events."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Implementing N-Tier Business Logic<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md)</ept>.","pos":[3091,3252],"source":" For more information, see [Implementing N-Tier Business Logic](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md)."},{"pos":[3261,3292],"content":"Defining the Serializable Types","linkify":"Defining the Serializable Types","nodes":[{"content":"Defining the Serializable Types","pos":[0,31]}]},{"content":"The client or presentation tier must have type definitions for the classes that it will be receiving from the middle tier.","pos":[3296,3418]},{"content":"Those types may be the entity classes themselves, or special classes that wrap only certain fields from the entity classes for remoting.","pos":[3419,3555]},{"content":"In any case, <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> is completely unconcerned about how the presentation tier acquires those type definitions.","pos":[3556,3727],"source":" In any case, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is completely unconcerned about how the presentation tier acquires those type definitions."},{"content":"For example, the presentation tier could use WCF to generate the types automatically, or it could have a copy of a DLL in which those types are defined, or it could just define its own versions of the types.","pos":[3728,3935]},{"pos":[3944,3973],"content":"Retrieving and Inserting Data","linkify":"Retrieving and Inserting Data","nodes":[{"content":"Retrieving and Inserting Data","pos":[0,29]}]},{"content":"The middle tier defines an interface that specifies how the presentation tier accesses the data.","pos":[3977,4073]},{"content":"For example <ph id=\"ph1\">`GetProductByID(int productID)`</ph>, or <ph id=\"ph2\">`GetCustomers()`</ph>.","pos":[4074,4139],"source":" For example `GetProductByID(int productID)`, or `GetCustomers()`."},{"content":"On the middle tier, the method body typically creates a new instance of the <ph id=\"ph1\">&lt;xref:System.Data.Linq.DataContext&gt;</ph>, executes a query against one or more of its table.","pos":[4140,4303],"source":" On the middle tier, the method body typically creates a new instance of the <xref:System.Data.Linq.DataContext>, executes a query against one or more of its table."},{"content":"The middle tier then returns the result as an <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, where <ph id=\"ph2\">`T`</ph> is either an entity class or another type that is used for serialization.","pos":[4304,4484],"source":" The middle tier then returns the result as an <xref:System.Collections.Generic.IEnumerable%601>, where `T` is either an entity class or another type that is used for serialization."},{"content":"The presentation tier never sends or receives query variables directly to or from the middle tier.","pos":[4485,4583]},{"content":"The two tiers exchange values, objects, and collections of concrete data.","pos":[4584,4657]},{"content":"After it has received a collection, the presentation tier can use <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)]</ph> to Objects to query it if necessary.","pos":[4658,4826],"source":" After it has received a collection, the presentation tier can use [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects to query it if necessary."},{"content":"When inserting data, the presentation tier can construct a new object and send it to the middle tier, or it can have the middle tier construct the object based on values that it provides.","pos":[4833,5020]},{"content":"In general, retrieving and inserting data in n-tier applications does not differ much from the process in 2-tier applications.","pos":[5021,5147]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Querying the Database<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md)</ept> and <bpt id=\"p2\">[</bpt>Making and Submitting Data Changes<ept id=\"p2\">](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md)</ept>.","pos":[5148,5412],"source":" For more information, see [Querying the Database](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md) and [Making and Submitting Data Changes](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md)."},{"pos":[5421,5461],"content":"Tracking Changes for Updates and Deletes","linkify":"Tracking Changes for Updates and Deletes","nodes":[{"content":"Tracking Changes for Updates and Deletes","pos":[0,40]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> supports optimistic concurrency based on timestamps (also named RowVersions) and on original values.","pos":[5465,5633],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] supports optimistic concurrency based on timestamps (also named RowVersions) and on original values."},{"content":"If the database tables have timestamps, then updates and deletions require little extra work on either the middle-tier or presentation tier.","pos":[5634,5774]},{"content":"However, if you must use original values for optimistic concurrency checks, then the presentation tier is responsible for tracking those values and sending them back when it makes updates.","pos":[5775,5963]},{"content":"This is because changes that were made to entities on the presentation tier are not tracked on the middle tier.","pos":[5964,6075]},{"content":"In fact, the original retrieval of an entity, and the eventual update made to it are typically performed by two completely separate instances of the <ph id=\"ph1\">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.","pos":[6076,6261],"source":" In fact, the original retrieval of an entity, and the eventual update made to it are typically performed by two completely separate instances of the <xref:System.Data.Linq.DataContext>."},{"content":"The greater the number of changes that the presentation tier makes, the more complex it becomes to track those changes and package them back to the middle tier.","pos":[6268,6428]},{"content":"The implementation of a mechanism for communicating changes is completely up to the application.","pos":[6429,6525]},{"content":"The only requirement is that <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> must be given those original values that are required for optimistic concurrency checks.","pos":[6526,6711],"source":" The only requirement is that [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] must be given those original values that are required for optimistic concurrency checks."},{"pos":[6718,6932],"content":"For more information, see <bpt id=\"p1\">[</bpt>Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md)</ept>.","source":"For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md)."},{"pos":[6941,6949],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6953,7108],"content":"<bpt id=\"p1\">[</bpt>N-Tier and Remote Applications with LINQ to SQL<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)</ept>","source":"[N-Tier and Remote Applications with LINQ to SQL](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)"},{"pos":[7111,7227],"content":"<bpt id=\"p1\">[</bpt>LinqDataSource Web Server Control Overview<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))</ept>","source":"[LinqDataSource Web Server Control Overview](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))"}]}