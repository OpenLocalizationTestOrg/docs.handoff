{"content":"---\ntitle: \"join clause - C# Reference\"\nms.custom: seodec18\n\nms.date: 07/20/2015\nf1_keywords: \n  - \"join\"\n  - \"join_CSharpKeyword\"\nhelpviewer_keywords: \n  - \"join clause [C#]\"\n  - \"join keyword [C#]\"\nms.assetid: 76e9df84-092c-41a6-9537-c3f1cbd7f0fb\n---\n# join clause (C# Reference)\n\nThe `join` clause is useful for associating elements from different source sequences that have no direct relationship in the object model. The only requirement is that the elements in each source share some value that can be compared for equality. For example, a food distributor might have a list of suppliers of a certain product, and a list of buyers. A `join` clause can be used, for example, to create a list of the suppliers and buyers of that product who are all in the same specified region.\n\nA `join` clause takes two source sequences as input. The elements in each sequence must either be or contain a property that can be compared to a corresponding property in the other sequence. The `join` clause compares the specified keys for equality by using the special `equals` keyword. All joins performed by the `join` clause are equijoins. The shape of the output of a `join` clause depends on the specific type of join you are performing. The following are three most common join types:\n\n- Inner join\n\n- Group join\n\n- Left outer join\n\n## Inner join\n\nThe following example shows a simple inner equijoin. This query produces a flat sequence of \"product name / category\" pairs. The same category string will appear in multiple elements. If an element from `categories` has no matching `products`, that category will not appear in the results.\n\n[!code-csharp[cscsrefQueryKeywords#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#24)]\n\nFor more information, see [Perform inner joins](../../linq/perform-inner-joins.md).\n\n## Group join\n\nA `join` clause with an `into` expression is called a group join.\n\n[!code-csharp[cscsrefQueryKeywords#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#25)]\n\nA group join produces a hierarchical result sequence, which associates elements in the left source sequence with one or more matching elements in the right side source sequence. A group join has no equivalent in relational terms; it is essentially a sequence of object arrays.\n\nIf no elements from the right source sequence are found to match an element in the left source, the `join` clause will produce an empty array for that item. Therefore, the group join is still basically an inner-equijoin except that the result sequence is organized into groups.\n\nIf you just select the results of a group join, you can access the items, but you cannot identify the key that they match on. Therefore, it is generally more useful to select the results of the group join into a new type that also has the key name, as shown in the previous example.\n\nYou can also, of course, use the result of a group join as the generator of another subquery:\n\n[!code-csharp[cscsrefQueryKeywords#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#26)]\n\nFor more information, see [Perform grouped joins](../../linq/perform-grouped-joins.md).\n\n## Left outer join\n\nIn a left outer join, all the elements in the left source sequence are returned, even if no matching elements are in the right sequence. To perform a left outer join in [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], use the `DefaultIfEmpty` method in combination with a group join to specify a default right-side element to produce if a left-side element has no matches. You can use `null` as the default value for any reference type, or you can specify a user-defined default type. In the following example, a user-defined default type is shown:\n\n[!code-csharp[cscsrefQueryKeywords#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#27)]\n\nFor more information, see [Perform left outer joins](../../linq/perform-left-outer-joins.md).\n\n## The equals operator\n\nA `join` clause performs an equijoin. In other words, you can only base matches on the equality of two keys. Other types of comparisons such as \"greater than\" or \"not equals\" are not supported. To make clear that all joins are equijoins, the `join` clause uses the `equals` keyword instead of the `==` operator. The `equals` keyword can only be used in a `join` clause and it differs from the `==` operator in one important way. With `equals`, the left key consumes the outer source sequence, and the right key consumes the inner source. The outer source is only in scope on the left side of `equals` and the inner source sequence is only in scope on the right side.\n\n## Non-equijoins\n\nYou can perform non-equijoins, cross joins, and other custom join operations by using multiple `from` clauses to introduce new sequences independently into a query. For more information, see [Perform custom join operations](../../linq/perform-custom-join-operations.md).\n\n## Joins on object collections vs. relational tables\n\nIn a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query expression, join operations are performed on object collections. Object collections cannot be \"joined\" in exactly the same way as two relational tables. In [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], explicit `join` clauses are only required when two source sequences are not tied by any relationship. When working with [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], foreign key tables are represented in the object model as properties of the primary table. For example, in the Northwind database, the Customer table has a foreign key relationship with the Orders table. When you map the tables to the object model, the Customer class has an Orders property that contains the collection of Orders associated with that Customer. In effect, the join has already been done for you.\n\nFor more information about querying across related tables in the context of [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], see [How to: Map Database Relationships](../../../framework/data/adonet/sql/linq/how-to-map-database-relationships.md).\n\n## Composite keys\n\nYou can test for equality of multiple values by using a composite key. For more information, see [Join by using composite keys](../../linq/join-by-using-composite-keys.md). Composite keys can be also used in a `group` clause.\n\n## Example\n\nThe following example compares the results of an inner join, a group join, and a left outer join on the same data sources by using the same matching keys. Some extra code is added to these examples to clarify the results in the console display.\n\n[!code-csharp[cscsrefQueryKeywords#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#23)]\n\n## Remarks\n\nA `join` clause that is not followed by `into` is translated into a <xref:System.Linq.Enumerable.Join%2A> method call. A `join` clause that is followed by `into` is translated to a <xref:System.Linq.Enumerable.GroupJoin%2A> method call.\n\n## See also\n\n- [Query Keywords (LINQ)](query-keywords.md)\n- [Language Integrated Query (LINQ)](../../linq/index.md)\n- [Join Operations](../../programming-guide/concepts/linq/join-operations.md)\n- [group clause](group-clause.md)\n- [Perform left outer joins](../../linq/perform-left-outer-joins.md)\n- [Perform inner joins](../../linq/perform-inner-joins.md)\n- [Perform grouped joins](../../linq/perform-grouped-joins.md)\n- [Order the results of a join clause](../../linq/order-the-results-of-a-join-clause.md)\n- [Join by using composite keys](../../linq/join-by-using-composite-keys.md)\n- [Compatible database systems for Visual Studio](/visualstudio/data-tools/installing-database-systems-tools-and-samples)","nodes":[{"pos":[4,248],"embed":true,"restype":"x-metadata","content":"title: \"join clause - C# Reference\"\nms.custom: seodec18\n\nms.date: 07/20/2015\nf1_keywords: \n  - \"join\"\n  - \"join_CSharpKeyword\"\nhelpviewer_keywords: \n  - \"join clause [C#]\"\n  - \"join keyword [C#]\"\nms.assetid: 76e9df84-092c-41a6-9537-c3f1cbd7f0fb","nodes":[{"content":"join clause - C# Reference","nodes":[{"pos":[0,26],"content":"join clause - C# Reference","nodes":[{"content":"join clause - C# Reference","pos":[0,26]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[255,281],"content":"join clause (C# Reference)","linkify":"join clause (C# Reference)","nodes":[{"content":"join clause (C# Reference)","pos":[0,26]}]},{"content":"The <ph id=\"ph1\">`join`</ph> clause is useful for associating elements from different source sequences that have no direct relationship in the object model.","pos":[283,421],"source":"The `join` clause is useful for associating elements from different source sequences that have no direct relationship in the object model."},{"content":"The only requirement is that the elements in each source share some value that can be compared for equality.","pos":[422,530]},{"content":"For example, a food distributor might have a list of suppliers of a certain product, and a list of buyers.","pos":[531,637]},{"content":"A <ph id=\"ph1\">`join`</ph> clause can be used, for example, to create a list of the suppliers and buyers of that product who are all in the same specified region.","pos":[638,782],"source":" A `join` clause can be used, for example, to create a list of the suppliers and buyers of that product who are all in the same specified region."},{"content":"A <ph id=\"ph1\">`join`</ph> clause takes two source sequences as input.","pos":[784,836],"source":"A `join` clause takes two source sequences as input."},{"content":"The elements in each sequence must either be or contain a property that can be compared to a corresponding property in the other sequence.","pos":[837,975]},{"content":"The <ph id=\"ph1\">`join`</ph> clause compares the specified keys for equality by using the special <ph id=\"ph2\">`equals`</ph> keyword.","pos":[976,1073],"source":" The `join` clause compares the specified keys for equality by using the special `equals` keyword."},{"content":"All joins performed by the <ph id=\"ph1\">`join`</ph> clause are equijoins.","pos":[1074,1129],"source":" All joins performed by the `join` clause are equijoins."},{"content":"The shape of the output of a <ph id=\"ph1\">`join`</ph> clause depends on the specific type of join you are performing.","pos":[1130,1229],"source":" The shape of the output of a `join` clause depends on the specific type of join you are performing."},{"content":"The following are three most common join types:","pos":[1230,1277]},{"content":"Inner join","pos":[1281,1291]},{"content":"Group join","pos":[1295,1305]},{"content":"Left outer join","pos":[1309,1324]},{"pos":[1329,1339],"content":"Inner join","linkify":"Inner join","nodes":[{"content":"Inner join","pos":[0,10]}]},{"content":"The following example shows a simple inner equijoin.","pos":[1341,1393]},{"content":"This query produces a flat sequence of \"product name / category\" pairs.","pos":[1394,1465]},{"content":"The same category string will appear in multiple elements.","pos":[1466,1524]},{"content":"If an element from <ph id=\"ph1\">`categories`</ph> has no matching <ph id=\"ph2\">`products`</ph>, that category will not appear in the results.","pos":[1525,1630],"source":" If an element from `categories` has no matching `products`, that category will not appear in the results."},{"pos":[1756,1839],"content":"For more information, see <bpt id=\"p1\">[</bpt>Perform inner joins<ept id=\"p1\">](../../linq/perform-inner-joins.md)</ept>.","source":"For more information, see [Perform inner joins](../../linq/perform-inner-joins.md)."},{"pos":[1844,1854],"content":"Group join","linkify":"Group join","nodes":[{"content":"Group join","pos":[0,10]}]},{"pos":[1856,1921],"content":"A <ph id=\"ph1\">`join`</ph> clause with an <ph id=\"ph2\">`into`</ph> expression is called a group join.","source":"A `join` clause with an `into` expression is called a group join."},{"content":"A group join produces a hierarchical result sequence, which associates elements in the left source sequence with one or more matching elements in the right side source sequence.","pos":[2047,2224]},{"content":"A group join has no equivalent in relational terms; it is essentially a sequence of object arrays.","pos":[2225,2323]},{"content":"If no elements from the right source sequence are found to match an element in the left source, the <ph id=\"ph1\">`join`</ph> clause will produce an empty array for that item.","pos":[2325,2481],"source":"If no elements from the right source sequence are found to match an element in the left source, the `join` clause will produce an empty array for that item."},{"content":"Therefore, the group join is still basically an inner-equijoin except that the result sequence is organized into groups.","pos":[2482,2602]},{"content":"If you just select the results of a group join, you can access the items, but you cannot identify the key that they match on.","pos":[2604,2729]},{"content":"Therefore, it is generally more useful to select the results of the group join into a new type that also has the key name, as shown in the previous example.","pos":[2730,2886]},{"content":"You can also, of course, use the result of a group join as the generator of another subquery:","pos":[2888,2981]},{"pos":[3107,3194],"content":"For more information, see <bpt id=\"p1\">[</bpt>Perform grouped joins<ept id=\"p1\">](../../linq/perform-grouped-joins.md)</ept>.","source":"For more information, see [Perform grouped joins](../../linq/perform-grouped-joins.md)."},{"pos":[3199,3214],"content":"Left outer join","linkify":"Left outer join","nodes":[{"content":"Left outer join","pos":[0,15]}]},{"content":"In a left outer join, all the elements in the left source sequence are returned, even if no matching elements are in the right sequence.","pos":[3216,3352]},{"content":"To perform a left outer join in <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph>, use the <ph id=\"ph2\">`DefaultIfEmpty`</ph> method in combination with a group join to specify a default right-side element to produce if a left-side element has no matches.","pos":[3353,3590],"source":" To perform a left outer join in [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], use the `DefaultIfEmpty` method in combination with a group join to specify a default right-side element to produce if a left-side element has no matches."},{"content":"You can use <ph id=\"ph1\">`null`</ph> as the default value for any reference type, or you can specify a user-defined default type.","pos":[3591,3702],"source":" You can use `null` as the default value for any reference type, or you can specify a user-defined default type."},{"content":"In the following example, a user-defined default type is shown:","pos":[3703,3766]},{"pos":[3892,3985],"content":"For more information, see <bpt id=\"p1\">[</bpt>Perform left outer joins<ept id=\"p1\">](../../linq/perform-left-outer-joins.md)</ept>.","source":"For more information, see [Perform left outer joins](../../linq/perform-left-outer-joins.md)."},{"pos":[3990,4009],"content":"The equals operator","linkify":"The equals operator","nodes":[{"content":"The equals operator","pos":[0,19]}]},{"content":"A <ph id=\"ph1\">`join`</ph> clause performs an equijoin.","pos":[4011,4048],"source":"A `join` clause performs an equijoin."},{"content":"In other words, you can only base matches on the equality of two keys.","pos":[4049,4119]},{"content":"Other types of comparisons such as \"greater than\" or \"not equals\" are not supported.","pos":[4120,4204]},{"content":"To make clear that all joins are equijoins, the <ph id=\"ph1\">`join`</ph> clause uses the <ph id=\"ph2\">`equals`</ph> keyword instead of the <ph id=\"ph3\">`==`</ph> operator.","pos":[4205,4322],"source":" To make clear that all joins are equijoins, the `join` clause uses the `equals` keyword instead of the `==` operator."},{"content":"The <ph id=\"ph1\">`equals`</ph> keyword can only be used in a <ph id=\"ph2\">`join`</ph> clause and it differs from the <ph id=\"ph3\">`==`</ph> operator in one important way.","pos":[4323,4439],"source":" The `equals` keyword can only be used in a `join` clause and it differs from the `==` operator in one important way."},{"content":"With <ph id=\"ph1\">`equals`</ph>, the left key consumes the outer source sequence, and the right key consumes the inner source.","pos":[4440,4548],"source":" With `equals`, the left key consumes the outer source sequence, and the right key consumes the inner source."},{"content":"The outer source is only in scope on the left side of <ph id=\"ph1\">`equals`</ph> and the inner source sequence is only in scope on the right side.","pos":[4549,4677],"source":" The outer source is only in scope on the left side of `equals` and the inner source sequence is only in scope on the right side."},{"pos":[4682,4695],"content":"Non-equijoins","linkify":"Non-equijoins","nodes":[{"content":"Non-equijoins","pos":[0,13]}]},{"content":"You can perform non-equijoins, cross joins, and other custom join operations by using multiple <ph id=\"ph1\">`from`</ph> clauses to introduce new sequences independently into a query.","pos":[4697,4861],"source":"You can perform non-equijoins, cross joins, and other custom join operations by using multiple `from` clauses to introduce new sequences independently into a query."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Perform custom join operations<ept id=\"p1\">](../../linq/perform-custom-join-operations.md)</ept>.","pos":[4862,4967],"source":" For more information, see [Perform custom join operations](../../linq/perform-custom-join-operations.md)."},{"pos":[4972,5021],"content":"Joins on object collections vs. relational tables","linkify":"Joins on object collections vs. relational tables","nodes":[{"content":"Joins on object collections vs. relational tables","pos":[0,49]}]},{"content":"In a <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query expression, join operations are performed on object collections.","pos":[5023,5148],"source":"In a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query expression, join operations are performed on object collections."},{"content":"Object collections cannot be \"joined\" in exactly the same way as two relational tables.","pos":[5149,5236]},{"content":"In <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph>, explicit <ph id=\"ph2\">`join`</ph> clauses are only required when two source sequences are not tied by any relationship.","pos":[5237,5392],"source":" In [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], explicit `join` clauses are only required when two source sequences are not tied by any relationship."},{"content":"When working with <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph>, foreign key tables are represented in the object model as properties of the primary table.","pos":[5393,5554],"source":" When working with [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], foreign key tables are represented in the object model as properties of the primary table."},{"content":"For example, in the Northwind database, the Customer table has a foreign key relationship with the Orders table.","pos":[5555,5667]},{"content":"When you map the tables to the object model, the Customer class has an Orders property that contains the collection of Orders associated with that Customer.","pos":[5668,5824]},{"content":"In effect, the join has already been done for you.","pos":[5825,5875]},{"pos":[5877,6125],"content":"For more information about querying across related tables in the context of <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>How to: Map Database Relationships<ept id=\"p1\">](../../../framework/data/adonet/sql/linq/how-to-map-database-relationships.md)</ept>.","source":"For more information about querying across related tables in the context of [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], see [How to: Map Database Relationships](../../../framework/data/adonet/sql/linq/how-to-map-database-relationships.md)."},{"pos":[6130,6144],"content":"Composite keys","linkify":"Composite keys","nodes":[{"content":"Composite keys","pos":[0,14]}]},{"content":"You can test for equality of multiple values by using a composite key.","pos":[6146,6216]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Join by using composite keys<ept id=\"p1\">](../../linq/join-by-using-composite-keys.md)</ept>.","pos":[6217,6318],"source":" For more information, see [Join by using composite keys](../../linq/join-by-using-composite-keys.md)."},{"content":"Composite keys can be also used in a <ph id=\"ph1\">`group`</ph> clause.","pos":[6319,6371],"source":" Composite keys can be also used in a `group` clause."},{"pos":[6376,6383],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example compares the results of an inner join, a group join, and a left outer join on the same data sources by using the same matching keys.","pos":[6385,6539]},{"content":"Some extra code is added to these examples to clarify the results in the console display.","pos":[6540,6629]},{"pos":[6758,6765],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A <ph id=\"ph1\">`join`</ph> clause that is not followed by <ph id=\"ph2\">`into`</ph> is translated into a <ph id=\"ph3\">&lt;xref:System.Linq.Enumerable.Join%2A&gt;</ph> method call.","pos":[6767,6885],"source":"A `join` clause that is not followed by `into` is translated into a <xref:System.Linq.Enumerable.Join%2A> method call."},{"content":"A <ph id=\"ph1\">`join`</ph> clause that is followed by <ph id=\"ph2\">`into`</ph> is translated to a <ph id=\"ph3\">&lt;xref:System.Linq.Enumerable.GroupJoin%2A&gt;</ph> method call.","pos":[6886,7003],"source":" A `join` clause that is followed by `into` is translated to a <xref:System.Linq.Enumerable.GroupJoin%2A> method call."},{"pos":[7008,7016],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7020,7062],"content":"<bpt id=\"p1\">[</bpt>Query Keywords (LINQ)<ept id=\"p1\">](query-keywords.md)</ept>","source":"[Query Keywords (LINQ)](query-keywords.md)"},{"pos":[7065,7120],"content":"<bpt id=\"p1\">[</bpt>Language Integrated Query (LINQ)<ept id=\"p1\">](../../linq/index.md)</ept>","source":"[Language Integrated Query (LINQ)](../../linq/index.md)"},{"pos":[7123,7198],"content":"<bpt id=\"p1\">[</bpt>Join Operations<ept id=\"p1\">](../../programming-guide/concepts/linq/join-operations.md)</ept>","source":"[Join Operations](../../programming-guide/concepts/linq/join-operations.md)"},{"pos":[7201,7232],"content":"<bpt id=\"p1\">[</bpt>group clause<ept id=\"p1\">](group-clause.md)</ept>","source":"[group clause](group-clause.md)"},{"pos":[7235,7301],"content":"<bpt id=\"p1\">[</bpt>Perform left outer joins<ept id=\"p1\">](../../linq/perform-left-outer-joins.md)</ept>","source":"[Perform left outer joins](../../linq/perform-left-outer-joins.md)"},{"pos":[7304,7360],"content":"<bpt id=\"p1\">[</bpt>Perform inner joins<ept id=\"p1\">](../../linq/perform-inner-joins.md)</ept>","source":"[Perform inner joins](../../linq/perform-inner-joins.md)"},{"pos":[7363,7423],"content":"<bpt id=\"p1\">[</bpt>Perform grouped joins<ept id=\"p1\">](../../linq/perform-grouped-joins.md)</ept>","source":"[Perform grouped joins](../../linq/perform-grouped-joins.md)"},{"pos":[7426,7512],"content":"<bpt id=\"p1\">[</bpt>Order the results of a join clause<ept id=\"p1\">](../../linq/order-the-results-of-a-join-clause.md)</ept>","source":"[Order the results of a join clause](../../linq/order-the-results-of-a-join-clause.md)"},{"pos":[7515,7589],"content":"<bpt id=\"p1\">[</bpt>Join by using composite keys<ept id=\"p1\">](../../linq/join-by-using-composite-keys.md)</ept>","source":"[Join by using composite keys](../../linq/join-by-using-composite-keys.md)"},{"pos":[7592,7711],"content":"<bpt id=\"p1\">[</bpt>Compatible database systems for Visual Studio<ept id=\"p1\">](/visualstudio/data-tools/installing-database-systems-tools-and-samples)</ept>","source":"[Compatible database systems for Visual Studio](/visualstudio/data-tools/installing-database-systems-tools-and-samples)"}]}