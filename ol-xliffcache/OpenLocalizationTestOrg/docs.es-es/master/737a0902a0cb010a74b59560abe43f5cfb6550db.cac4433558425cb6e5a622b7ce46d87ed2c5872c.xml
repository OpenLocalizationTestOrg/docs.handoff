{"content":"---\ntitle: \"string (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"string\"\n  - \"string_CSharpKeyword\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"strings [C#], reference\"\n  - \"@ string literal\"\n  - \"string literals [C#]\"\n  - \"string keyword [C#]\"\nms.assetid: 3037e558-fb22-494d-bca1-a15ade11b11a\ncaps.latest.revision: 31\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# string (C# Reference)\nThe `string` type represents a sequence of zero or more Unicode characters. `string` is an alias for <xref:System.String> in the .NET Framework.  \n  \n Although `string` is a reference type, the equality operators (`==` and `!=`) are defined to compare the values of `string` objects, not references. This makes testing for string equality more intuitive. For example:  \n  \n```csharp  \nstring a = \"hello\";  \nstring b = \"h\";  \n// Append to contents of 'b'  \nb += \"ello\";  \nConsole.WriteLine(a == b);  \nConsole.WriteLine((object)a == (object)b);  \n```  \n  \n This displays \"True\" and then \"False\" because the content of the strings are equivalent, but `a` and `b` do not refer to the same string instance.  \n  \n The + operator concatenates strings:  \n  \n```csharp  \nstring a = \"good \" + \"morning\";  \n```  \n  \n This creates a string object that contains \"good morning\".  \n  \n Strings are *immutable*--the contents of a string object cannot be changed after the object is created, although the syntax makes it appear as if you can do this. For example, when you write this code, the compiler actually creates a new string object to hold the new sequence of characters, and that new object is assigned to b. The string \"h\" is then eligible for garbage collection.  \n  \n```csharp\nstring b = \"h\";  \nb += \"ello\";  \n```  \n  \n The [] operator can be used for readonly access to individual characters of a `string`:  \n  \n```csharp  \nstring str = \"test\";  \nchar x = str[2];  // x = 's';  \n```  \n  \n String literals are of type `string` and can be written in two forms, quoted and @-quoted. Quoted string literals are enclosed in double quotation marks (\"):  \n  \n```csharp  \n\"good morning\"  // a string literal  \n```  \n  \n String literals can contain any character literal. Escape sequences are included. The following example uses escape sequence `\\\\` for backslash, `\\u0066` for the letter f, and `\\n` for newline.  \n  \n```  \nstring a = \"\\\\\\u0066\\n\";  \nConsole.WriteLine(a);  \n```  \n  \n> [!NOTE]\n>  The escape code `\\`u`dddd` (where `dddd` is a four-digit number) represents the Unicode character U+`dddd`. Eight-digit Unicode escape codes are also recognized: `\\Udddddddd`.  \n  \n Verbatim string literals start with @ and are also enclosed in double quotation marks. For example:  \n  \n```csharp  \n@\"good morning\"  // a string literal  \n```  \n  \n The advantage of verbatim strings is that escape sequences are *not* processed, which makes it easy to write, for example, a fully qualified file name:  \n  \n```csharp  \n@\"c:\\Docs\\Source\\a.txt\"  // rather than \"c:\\\\Docs\\\\Source\\\\a.txt\"  \n```  \n  \n To include a double quotation mark in an @-quoted string, double it:  \n  \n```csharp  \n@\"\"\"Ahoy!\"\" cried the captain.\" // \"Ahoy!\" cried the captain.  \n```  \n  \n Another use of the @ symbol is to use referenced ([/reference](../../../csharp/language-reference/compiler-options/reference-compiler-option.md)) identifiers that are C# keywords.  \n  \n For more information about strings in C#, see [Strings](../../../csharp/programming-guide/strings/index.md).  \n  \n## Example  \n [!code-cs[csrefKeywordsTypes#17](../../../csharp/language-reference/keywords/codesnippet/CSharp/string_1.cs)]  \n  \n## C# Language Specification  \n [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n## See Also  \n [C# Reference](../../../csharp/language-reference/index.md)   \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Best Practices for Using Strings](../../../standard/base-types/best-practices-strings.md)   \n [C# Keywords](../../../csharp/language-reference/keywords/index.md)   \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Reference Types](../../../csharp/language-reference/keywords/reference-types.md)   \n [Value Types](../../../csharp/language-reference/keywords/value-types.md)   \n [Basic String Operations](../../../standard/base-types/basic-string-operations.md)   \n [Creating New Strings](../../../standard/base-types/creating-new.md)   \n [Formatting Numeric Results Table](../../../csharp/language-reference/keywords/formatting-numeric-results-table.md)\n","nodes":[{"pos":[4,674],"nodes":[{"content":"string (C# Reference) | Microsoft Docs","nodes":[{"pos":[0,38],"content":"string (C# Reference) | Microsoft Docs","nodes":[{"content":"string (C# Reference) | Microsoft Docs","pos":[0,38]}]}],"pos":[6,47],"yaml":true}],"content":"title: \"string (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"string\"\n  - \"string_CSharpKeyword\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"strings [C#], reference\"\n  - \"@ string literal\"\n  - \"string literals [C#]\"\n  - \"string keyword [C#]\"\nms.assetid: 3037e558-fb22-494d-bca1-a15ade11b11a\ncaps.latest.revision: 31\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","yamlblock":true},{"pos":[681,702],"content":"string (C# Reference)","linkify":"string (C# Reference)","nodes":[{"content":"string (C# Reference)","pos":[0,21]}]},{"content":"The <ph id=\"ph1\">`string`</ph> type represents a sequence of zero or more Unicode characters.","pos":[703,778],"source":"The `string` type represents a sequence of zero or more Unicode characters."},{"content":"<ph id=\"ph1\">`string`</ph> is an alias for <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> in the .NET Framework.","pos":[779,847],"source":"`string` is an alias for <xref:System.String> in the .NET Framework."},{"content":"Although <ph id=\"ph1\">`string`</ph> is a reference type, the equality operators (<ph id=\"ph2\">`==`</ph> and <ph id=\"ph3\">`!=`</ph>) are defined to compare the values of <ph id=\"ph4\">`string`</ph> objects, not references.","pos":[854,1002],"source":"Although `string` is a reference type, the equality operators (`==` and `!=`) are defined to compare the values of `string` objects, not references."},{"content":"This makes testing for string equality more intuitive.","pos":[1003,1057]},{"content":"For example:","pos":[1058,1070]},{"pos":[1258,1404],"content":"This displays \"True\" and then \"False\" because the content of the strings are equivalent, but <ph id=\"ph1\">`a`</ph> and <ph id=\"ph2\">`b`</ph> do not refer to the same string instance.","source":"This displays \"True\" and then \"False\" because the content of the strings are equivalent, but `a` and `b` do not refer to the same string instance."},{"content":"The + operator concatenates strings:","pos":[1411,1447]},{"content":"This creates a string object that contains \"good morning\".","pos":[1509,1567]},{"content":"Strings are <bpt id=\"p1\">*</bpt>immutable<ept id=\"p1\">*</ept>--the contents of a string object cannot be changed after the object is created, although the syntax makes it appear as if you can do this.","pos":[1574,1736],"source":"Strings are *immutable*--the contents of a string object cannot be changed after the object is created, although the syntax makes it appear as if you can do this."},{"content":"For example, when you write this code, the compiler actually creates a new string object to hold the new sequence of characters, and that new object is assigned to b.","pos":[1737,1903]},{"content":"The string \"h\" is then eligible for garbage collection.","pos":[1904,1959]},{"pos":[2018,2105],"content":"The [] operator can be used for readonly access to individual characters of a <ph id=\"ph1\">`string`</ph>:","source":"The [] operator can be used for readonly access to individual characters of a `string`:"},{"content":"String literals are of type <ph id=\"ph1\">`string`</ph> and can be written in two forms, quoted and <ph id=\"ph2\">@-quoted</ph>.","pos":[2188,2278],"source":"String literals are of type `string` and can be written in two forms, quoted and @-quoted."},{"content":"Quoted string literals are enclosed in double quotation marks (\"):","pos":[2279,2345]},{"content":"String literals can contain any character literal.","pos":[2411,2461]},{"content":"Escape sequences are included.","pos":[2462,2492]},{"content":"The following example uses escape sequence <ph id=\"ph1\">`\\\\`</ph> for backslash, <ph id=\"ph2\">`\\u0066`</ph> for the letter f, and <ph id=\"ph3\">`\\n`</ph> for newline.","pos":[2493,2604],"source":" The following example uses escape sequence `\\\\` for backslash, `\\u0066` for the letter f, and `\\n` for newline."},{"pos":[2678,2864],"content":"[!NOTE]\n The escape code `\\`u`dddd` (where `dddd` is a four-digit number) represents the Unicode character U+`dddd`. Eight-digit Unicode escape codes are also recognized: `\\Udddddddd`.","leadings":["","> "],"nodes":[{"content":"The escape code `\\`u`dddd` (where `dddd` is a four-digit number) represents the Unicode character U+`dddd`. Eight-digit Unicode escape codes are also recognized: `\\Udddddddd`.","pos":[9,184],"nodes":[{"content":"The escape code <ph id=\"ph1\">`\\`</ph>u<ph id=\"ph2\">`dddd`</ph> (where <ph id=\"ph3\">`dddd`</ph> is a four-digit number) represents the Unicode character U+<ph id=\"ph4\">`dddd`</ph>.","pos":[0,107],"source":"The escape code `\\`u`dddd` (where `dddd` is a four-digit number) represents the Unicode character U+`dddd`."},{"content":"Eight-digit Unicode escape codes are also recognized: <ph id=\"ph1\">`\\Udddddddd`</ph>.","pos":[108,175],"source":" Eight-digit Unicode escape codes are also recognized: `\\Udddddddd`."}]}]},{"content":"Verbatim string literals start with @ and are also enclosed in double quotation marks.","pos":[2871,2957]},{"content":"For example:","pos":[2958,2970]},{"pos":[3037,3188],"content":"The advantage of verbatim strings is that escape sequences are <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> processed, which makes it easy to write, for example, a fully qualified file name:","source":"The advantage of verbatim strings is that escape sequences are *not* processed, which makes it easy to write, for example, a fully qualified file name:"},{"content":"To include a double quotation mark in an <ph id=\"ph1\">@-quoted</ph> string, double it:","pos":[3284,3352],"source":"To include a double quotation mark in an @-quoted string, double it:"},{"pos":[3444,3623],"content":"Another use of the @ symbol is to use referenced (<bpt id=\"p1\">[</bpt>/reference<ept id=\"p1\">](../../../csharp/language-reference/compiler-options/reference-compiler-option.md)</ept>) identifiers that are C# keywords.","source":"Another use of the @ symbol is to use referenced ([/reference](../../../csharp/language-reference/compiler-options/reference-compiler-option.md)) identifiers that are C# keywords."},{"pos":[3630,3738],"content":"For more information about strings in C#, see <bpt id=\"p1\">[</bpt>Strings<ept id=\"p1\">](../../../csharp/programming-guide/strings/index.md)</ept>.","source":"For more information about strings in C#, see [Strings](../../../csharp/programming-guide/strings/index.md)."},{"pos":[3747,3754],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[3758,3867],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefKeywordsTypes#17<ept id=\"p2\">](../../../csharp/language-reference/keywords/codesnippet/CSharp/string_1.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefKeywordsTypes#17](../../../csharp/language-reference/keywords/codesnippet/CSharp/string_1.cs)]"},{"pos":[3876,3901],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[4015,4023],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[4027,4087],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[4091,4158],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Best Practices for Using Strings<ept id=\"p1\">](../../../standard/base-types/best-practices-strings.md)</ept><ph id=\"ph1\"> </ph>","pos":[4162,4253],"source":"[Best Practices for Using Strings](../../../standard/base-types/best-practices-strings.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[4257,4325],"source":"[C# Keywords](../../../csharp/language-reference/keywords/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[4329,4396],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Reference Types<ept id=\"p1\">](../../../csharp/language-reference/keywords/reference-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[4400,4482],"source":"[Reference Types](../../../csharp/language-reference/keywords/reference-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Value Types<ept id=\"p1\">](../../../csharp/language-reference/keywords/value-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[4486,4560],"source":"[Value Types](../../../csharp/language-reference/keywords/value-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Basic String Operations<ept id=\"p1\">](../../../standard/base-types/basic-string-operations.md)</ept><ph id=\"ph1\"> </ph>","pos":[4564,4647],"source":"[Basic String Operations](../../../standard/base-types/basic-string-operations.md) "},{"content":"<bpt id=\"p1\">[</bpt>Creating New Strings<ept id=\"p1\">](../../../standard/base-types/creating-new.md)</ept><ph id=\"ph1\"> </ph>","pos":[4651,4720],"source":"[Creating New Strings](../../../standard/base-types/creating-new.md) "},{"content":"<bpt id=\"p1\">[</bpt>Formatting Numeric Results Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/formatting-numeric-results-table.md)</ept>","pos":[4724,4839],"source":"[Formatting Numeric Results Table](../../../csharp/language-reference/keywords/formatting-numeric-results-table.md)"}]}