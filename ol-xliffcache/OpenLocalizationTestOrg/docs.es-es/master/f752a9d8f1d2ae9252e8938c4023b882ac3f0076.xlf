<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="lambda-expressions.md" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f752a9d8f1d2ae9252e8938c4023b882ac3f0076</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\procedures\lambda-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3dbd47aa91ea79750c67bc010194391d01970478</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f3cd5e6f3d420f3183ab18520968ab1139668797</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Lambda Expressions (Visual Basic) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>lambda expression<ept id="p1">*</ept> is a function or subroutine without a name that can be used wherever a delegate is valid.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be functions or subroutines and can be single-line or multi-line.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can pass values from the current scope to a lambda expression.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`RemoveHandler`</ph> statement is an exception.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You cannot pass a lambda expression in for the delegate parameter of <ph id="ph1">`RemoveHandler`</ph>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You create lambda expressions by using the <ph id="ph1">`Function`</ph> or <ph id="ph2">`Sub`</ph> keyword, just as you create a standard function or subroutine.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, lambda expressions are included in a statement.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that increments its argument and returns the value.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a function.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that writes a value to the console.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a subroutine.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Notice that in the previous examples the lambda expressions are assigned to a variable name.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Whenever you refer to the variable, you invoke the lambda expression.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can also declare and invoke a lambda expression at the same time, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A lambda expression can be returned as the value of a function call (as is shown in the example in the <bpt id="p1">[</bpt>Context<ept id="p1">](#context)</ept> section later in this topic), or passed in as an argument to a parameter that takes a delegate type, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Lambda Expression Syntax</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The syntax of a lambda expression resembles that of a standard function or subroutine.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The differences are as follows:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A lambda expression does not have a name.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Lambda expressions cannot have modifiers, such as <ph id="ph1">`Overloads`</ph> or <ph id="ph2">`Overrides`</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Single-line lambda functions do not use an <ph id="ph1">`As`</ph> clause to designate the return type.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Instead, the type is inferred from the value that the body of the lambda expression evaluates to.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For example, if the body of the lambda expression is <ph id="ph1">`cust.City = "London"`</ph>, its return type is <ph id="ph2">`Boolean`</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In multi-line lambda functions, you can either specify a return type by using an <ph id="ph1">`As`</ph> clause, or omit the <ph id="ph2">`As`</ph> clause so that the return type is inferred.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`As`</ph> clause is omitted for a multi-line lambda function, the return type is inferred to be the dominant type from all the <ph id="ph2">`Return`</ph> statements in the multi-line lambda function.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>dominant type<ept id="p1">*</ept> is a unique type that all other types can widen to.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If this unique type cannot be determined, the dominant type is the unique type that all other types in the array can narrow to.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If neither of these unique types can be determined, the dominant type is <ph id="ph1">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In this case, if <ph id="ph1">`Option Strict`</ph> is set to <ph id="ph2">`On`</ph>, a compiler error occurs.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, if the expressions supplied to the <ph id="ph1">`Return`</ph> statement contain values of type <ph id="ph2">`Integer`</ph>, <ph id="ph3">`Long`</ph>, and <ph id="ph4">`Double`</ph>, the resulting array is of type <ph id="ph5">`Double`</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`Integer`</ph> and <ph id="ph2">`Long`</ph> widen to <ph id="ph3">`Double`</ph> and only <ph id="ph4">`Double`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`Double`</ph> is the dominant type.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The body of a single-line function must be an expression that returns a value, not a statement.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>There is no <ph id="ph1">`Return`</ph> statement for single-line functions.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The value returned by the single-line function is the value of the expression in the body of the function.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The body of a single-line subroutine must be single-line statement.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Single-line functions and subroutines do not include an <ph id="ph1">`End Function`</ph> or <ph id="ph2">`End Sub`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You can specify the data type of a lambda expression parameter by using the <ph id="ph1">`As`</ph> keyword, or the data type of the parameter can be inferred.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Either all parameters must have specified data types or all must be inferred.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Optional`</ph> and <ph id="ph2">`Paramarray`</ph> parameters are not permitted.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Generic parameters are not permitted.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Async Lambdas</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id="p1">[</bpt>Async<ept id="p1">](../../../../visual-basic/language-reference/modifiers/async.md)</ept> and <bpt id="p2">[</bpt>Await Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/await-operator.md)</ept> keywords.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <ph id="ph1">`ExampleMethodAsync`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can add the same event handler by using an async lambda in an <bpt id="p1">[</bpt>AddHandler Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/addhandler-statement.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To add this handler, add an <ph id="ph1">`Async`</ph> modifier before the lambda parameter list, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information about how to create and use async methods, see <bpt id="p1">[</bpt>Asynchronous Programming with Async and Await<ept id="p1">](../../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="context"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Context</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A lambda expression shares its context with the scope within which it is defined.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>It has the same access rights as any code written in the containing scope.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This includes access to member variables, functions and subs, <ph id="ph1">`Me`</ph>, and parameters and local variables in the containing scope.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Access to local variables and parameters in the containing scope can extend beyond the lifetime of that scope.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>As long as a delegate referring to a lambda expression is not available to garbage collection, access to the variables in the original environment is retained.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the following example, variable <ph id="ph1">`target`</ph> is local to <ph id="ph2">`makeTheGame`</ph>, the method in which the lambda expression <ph id="ph3">`playTheGame`</ph> is defined.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Note that the returned lambda expression, assigned to <ph id="ph1">`takeAGuess`</ph> in <ph id="ph2">`Main`</ph>, still has access to the local variable <ph id="ph3">`target`</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the wide range of access rights of the nested lambda expression.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When the returned lambda expression is executed from <ph id="ph1">`Main`</ph> as <ph id="ph2">`aDel`</ph>, it accesses these elements:</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A field of the class in which it is defined: <ph id="ph1">`aField`</ph></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A property of the class in which it is defined: <ph id="ph1">`aProp`</ph></source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A parameter of method <ph id="ph1">`functionWithNestedLambda`</ph>, in which it is defined: <ph id="ph2">`level1`</ph></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>A local variable of <ph id="ph1">`functionWithNestedLambda`</ph>: <ph id="ph2">`localVar`</ph></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A parameter of the lambda expression in which it is nested: <ph id="ph1">`level2`</ph></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Converting to a Delegate Type</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A lambda expression can be implicitly converted to a compatible delegate type.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For information about the general requirements for compatibility, see <bpt id="p1">[</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Func(Of Integer, Boolean)`</ph> or a matching delegate signature.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Sub(Of Double, String, Double)`</ph> or a matching delegate signature.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When you assign lambda expressions to delegates or pass them as arguments to procedures, you can specify the parameter names but omit their data types, letting the types be taken from the delegate.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Examples</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns <ph id="ph1">`True`</ph> if the nullable argument has an assigned value, and <ph id="ph2">`False`</ph> if its value is <ph id="ph3">`Nothing`</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns the index of the last element in an array.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Procedures<ept id="p1">](./index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Function Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/function-statement.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Sub Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/sub-statement.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nullable Value Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/nullable-value-types.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Pass Procedures to Another Procedure in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/how-to-pass-procedures-to-another-procedure.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Create a Lambda Expression<ept id="p1">](./how-to-create-a-lambda-expression.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>