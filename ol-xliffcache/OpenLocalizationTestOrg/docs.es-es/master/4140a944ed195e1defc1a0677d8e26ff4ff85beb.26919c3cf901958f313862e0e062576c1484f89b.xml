{"content":"---\ntitle: \"Custom Filters\"\nms.date: \"03/30/2017\"\nms.assetid: 97cf247d-be0a-4057-bba9-3be5c45029d5\n---\n# Custom Filters\nCustom filters allow you to define matching logic that cannot be accomplished using the system-provided message filters. For example, you might create a custom filter that hashes a particular message element and then examines the value to determine whether the filter should return true or false.  \n  \n## Implementation  \n A custom filter is an implementation of the <xref:System.ServiceModel.Dispatcher.MessageFilter> abstract base class. When implementing your custom filter, the constructor can optionally accept a single string parameter. This parameter contains the configuration information that is passed to the MessageFilter constructor in order to provide any values or configuration that the filter needs at runtime in order to perform matches. For example, this might be used to provide a value that the filter looks for within the message being evaluated. The following example demonstrates a basic implementation of a custom message filter that accepts a string parameter:  \n  \n```csharp  \npublic class MyMessageFilter: MessageFilter  \n{  \n    string filterData;  \n    public MyMessageFilter(string filterData)  \n    {  \n        if(string.IsNullOrEmpty(filterData)  \n            throw new ArgumentNullException(\"filterData\");  \n        this.filterData=filterData;  \n    }  \n    public override bool Match(System.ServiceModel.Channels.Message message)  \n    {  \n        ...  \n        return retValue;  \n    }  \n    public override bool Match(System.ServiceModel.Channels.MessageBuffer buffer)  \n    {  \n        ...  \n        return retValue;  \n    }  \n}  \n```  \n  \n> [!NOTE]\n>  In an actual implementation, the Match method(s) contains logic that will examine the message to determine if this message filter should return **true** or **false**.  \n  \n### Performance  \n When implementing a custom filter, it is important to take into consideration the maximum length of time required for the filter to complete the evaluation of a message. Since a message may be evaluated against multiple filters before a match is found, it is important to ensure that the client request does not time out before all filters can be evaluated. Therefore a custom filter should contain only the code necessary to evaluate the contents or attributes of a message in order to determine if it matches the filter criteria.  \n  \n In general, you should avoid the following when implementing a custom filter:  \n  \n-   IO, such as saving data to disk or to a database.  \n  \n-   Unnecessary processing, such as looping over multiple records in a document.  \n  \n-   Blocking operations, such as calls that involve obtaining a lock on shared resources or performing lookups against a database.  \n  \n Before using a custom filter in a production environment, you should run performance tests to determine the average length of time that the filter takes to evaluate a message. When combined with the average processing time of the other filters used in the filter table, this will allow you to accurately determine the maximum timeout value that should be specified by the client application.  \n  \n## Usage  \n In order to use your custom filter with the Routing Service, you must add it to the filter table by specifying a new filter entry of type \"Custom,\" the fully qualified type name of the message filter, and the name of your assembly.  As with other MessageFilters, you can specify the string filterData that will be passed to your custom filter’s constructor.  \n  \n The following examples demonstrate using a custom filter with the Routing Service:  \n  \n```xml  \n<!--ROUTING SECTION -->  \n<routing>  \n  <filters>  \n    <filter name=\"CustomFilter1\" filterType=\"Custom\"   \n            customType=\"CustomAssembly.MyMessageFilter,   \n            CustomAssembly\" filterData=\"custom data\" />  \n  </filters>  \n  <filterTables>  \n    <table name=\"routingTable1\">  \n      <filters>  \n        <add filterName=\"CustomFilter1\" endpointName=\"CalculatorService\" />  \n      </filters>  \n    </table>  \n  </filterTables>  \n</routing>  \n```  \n  \n```csharp  \nRoutingConfiguration rc = new RoutingConfiguration();  \nList<ServiceEndpoint> endpointList = new List<ServiceEndpoint>();  \nendpointList.Add(client);  \nrc.FilterTable.Add(new MyMessageFilter(\"CustomData\"), endpointList);  \n```\n","nodes":[{"pos":[4,98],"embed":true,"restype":"x-metadata","content":"title: \"Custom Filters\"\nms.date: \"03/30/2017\"\nms.assetid: 97cf247d-be0a-4057-bba9-3be5c45029d5","nodes":[{"content":"Custom Filters","nodes":[{"pos":[0,14],"content":"Custom Filters","nodes":[{"content":"Custom Filters","pos":[0,14]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[105,119],"content":"Custom Filters","linkify":"Custom Filters","nodes":[{"content":"Custom Filters","pos":[0,14]}]},{"content":"Custom filters allow you to define matching logic that cannot be accomplished using the system-provided message filters.","pos":[120,240]},{"content":"For example, you might create a custom filter that hashes a particular message element and then examines the value to determine whether the filter should return true or false.","pos":[241,416]},{"pos":[425,439],"content":"Implementation","linkify":"Implementation","nodes":[{"content":"Implementation","pos":[0,14]}]},{"content":"A custom filter is an implementation of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph> abstract base class.","pos":[443,559],"source":"A custom filter is an implementation of the <xref:System.ServiceModel.Dispatcher.MessageFilter> abstract base class."},{"content":"When implementing your custom filter, the constructor can optionally accept a single string parameter.","pos":[560,662]},{"content":"This parameter contains the configuration information that is passed to the MessageFilter constructor in order to provide any values or configuration that the filter needs at runtime in order to perform matches.","pos":[663,874]},{"content":"For example, this might be used to provide a value that the filter looks for within the message being evaluated.","pos":[875,987]},{"content":"The following example demonstrates a basic implementation of a custom message filter that accepts a string parameter:","pos":[988,1105]},{"pos":[1699,1876],"content":"[!NOTE]\n In an actual implementation, the Match method(s) contains logic that will examine the message to determine if this message filter should return **true** or **false**.","leadings":["","> "],"nodes":[{"content":"In an actual implementation, the Match method(s) contains logic that will examine the message to determine if this message filter should return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","pos":[9,175],"source":"In an actual implementation, the Match method(s) contains logic that will examine the message to determine if this message filter should return **true** or **false**."}]},{"pos":[1886,1897],"content":"Performance","linkify":"Performance","nodes":[{"content":"Performance","pos":[0,11]}]},{"content":"When implementing a custom filter, it is important to take into consideration the maximum length of time required for the filter to complete the evaluation of a message.","pos":[1901,2070]},{"content":"Since a message may be evaluated against multiple filters before a match is found, it is important to ensure that the client request does not time out before all filters can be evaluated.","pos":[2071,2258]},{"content":"Therefore a custom filter should contain only the code necessary to evaluate the contents or attributes of a message in order to determine if it matches the filter criteria.","pos":[2259,2432]},{"content":"In general, you should avoid the following when implementing a custom filter:","pos":[2439,2516]},{"content":"IO, such as saving data to disk or to a database.","pos":[2526,2575]},{"content":"Unnecessary processing, such as looping over multiple records in a document.","pos":[2585,2661]},{"content":"Blocking operations, such as calls that involve obtaining a lock on shared resources or performing lookups against a database.","pos":[2671,2797]},{"content":"Before using a custom filter in a production environment, you should run performance tests to determine the average length of time that the filter takes to evaluate a message.","pos":[2804,2979]},{"content":"When combined with the average processing time of the other filters used in the filter table, this will allow you to accurately determine the maximum timeout value that should be specified by the client application.","pos":[2980,3195]},{"pos":[3204,3209],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"In order to use your custom filter with the Routing Service, you must add it to the filter table by specifying a new filter entry of type \"Custom,\" the fully qualified type name of the message filter, and the name of your assembly.","pos":[3213,3444]},{"content":"As with other MessageFilters, you can specify the string filterData that will be passed to your custom filter’s constructor.","pos":[3446,3570]},{"content":"The following examples demonstrate using a custom filter with the Routing Service:","pos":[3577,3659]}]}