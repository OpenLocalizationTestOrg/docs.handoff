{"content":"---\ntitle: \"Implementing an Implicit Transaction using Transaction Scope\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9\n---\n# Implementing an Implicit Transaction using Transaction Scope\nThe <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself. A transaction scope can select and manage the ambient transaction automatically. Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.  \n  \n In addition, you do not need to enlist resources explicitly with the transaction. Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.  \n  \n## Creating a transaction scope  \n The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.  \n  \n [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]\n [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  \n  \n The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.  As illustrated in the code sample, it is recommended that you create scopes with a **using** statement. The **using** statement is available both in C# and in Visual Basic, and works like a **try...finally** block to ensure that the scope is disposed of properly.  \n  \n When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in. Once determined, the scope always participates in that transaction. The decision is based on two factors: whether an ambient transaction is present and the value of the **TransactionScopeOption** parameter in the constructor. The ambient transaction is the transaction within which your code executes. You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class. For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.  \n  \n## Completing a transaction scope  \n When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> method only once to inform the transaction manager that it is acceptable to commit the transaction. It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the **using** block.  \n  \n Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction. However, calling this method does not guarantee that the transaction wil be committed. It is merely a way of informing the transaction manager of your status. After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.  \n  \n If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the **using** block. If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object. At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.  \n  \n The **using** statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs. The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope. Exceptions that occur after calling this method may not affect the transaction. This method also restores the ambient transaction to it previous state.  \n  \n A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted. A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision. No exception is thrown if the transaction is committed.  \n  \n## Rolling back a transaction  \n If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope. For example, you can throw an exception within the scope. The transaction in which it participates in will be rolled back.  \n  \n## <a name=\"ManageTxFlow\"></a> Managing transaction flow using TransactionScopeOption  \n Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,  \n  \n```csharp  \nvoid RootMethod()  \n{  \n     using(TransactionScope scope = new TransactionScope())  \n     {  \n          /* Perform transactional work here */  \n          SomeMethod();  \n          scope.Complete();  \n     }  \n}  \n  \nvoid SomeMethod()  \n{  \n     using(TransactionScope scope = new TransactionScope())  \n     {  \n          /* Perform transactional work here */  \n          scope.Complete();  \n     }  \n}  \n```  \n  \n The top-most transaction scope is referred to as the root scope.  \n  \n The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.  \n  \n A <xref:System.Transactions.TransactionScope> object has three options:  \n  \n-   Join the ambient transaction, or create a new one if one does not exist.  \n  \n-   Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.  \n  \n-   Not take part in a transaction at all. There is no ambient transaction as a result.  \n  \n If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction. If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope. This is the default value. When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction. It should operate identically in both cases.  \n  \n If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope. It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.  \n  \n If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present. A scope instantiated with this value always have **null** as its ambient transaction.  \n  \n The above options are summarized in the following table.  \n  \n|TransactionScopeOption|Ambient Transaction|The scope takes part in|  \n|----------------------------|-------------------------|-----------------------------|  \n|Required|No|New Transaction (will be the root)|  \n|Requires New|No|New Transaction (will be the root)|  \n|Suppress|No|No Transaction|  \n|Required|Yes|Ambient  Transaction|  \n|Requires New|Yes|New Transaction (will be the root)|  \n|Suppress|Yes|No Transaction|  \n  \n When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction. If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction. If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.  \n  \n The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.  \n  \n```csharp  \nusing(TransactionScope scope1 = new TransactionScope())   \n//Default is Required   \n{   \n     using(TransactionScope scope2 = new   \n      TransactionScope(TransactionScopeOption.Required))   \n     {  \n     ...  \n     }   \n  \n     using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))   \n     {  \n     ...  \n     }   \n  \n     using(TransactionScope scope4 = new   \n        TransactionScope(TransactionScopeOption.Suppress))   \n    {  \n     ...  \n    }   \n}  \n```  \n  \n The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>. The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction. `Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value. For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`. Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.  \n  \n Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.  \n  \n <xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail. For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts. This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.  \n  \n```csharp  \nusing(TransactionScope scope1 = new TransactionScope())  \n{  \n     try  \n     {  \n          //Start of non-transactional section   \n          using(TransactionScope scope2 = new  \n             TransactionScope(TransactionScopeOption.Suppress))  \n          {  \n               //Do non-transactional work here  \n          }  \n          //Restores ambient transaction here  \n   }  \n     catch  \n     {}  \n   //Rest of scope1  \n}  \n```  \n  \n### Voting inside a nested scope  \n Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope. Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed. Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.  \n  \n## Setting the TransactionScope timeout  \n Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction. A timeout set to zero means an infinite timeout. Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem. Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.  \n  \n You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases. The first is during development, when you want to test the way your application handles aborted transactions. By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code. The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks. In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.  \n  \n When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted. If the nested scope's timeout is more than that of the ambient transaction, it has no effect.  \n  \n## Setting the TransactionScope isolation level  \n Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value. By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>. Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems. This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.  \n  \n In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.  \n  \n Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information. The difference between the different isolation levels is in the way read and write locks are used. A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted. The former is better for throughput, the latter for consistency. The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels. See <xref:System.Transactions.IsolationLevel> for more information.  \n  \n When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction. If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.  \n  \n## Interop with COM+  \n When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+. For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](../../../../docs/framework/data/transactions/interoperability-with-enterprise-services-and-com-transactions.md).  \n  \n## See also\n\n- <xref:System.Transactions.Transaction.Clone%2A>\n- <xref:System.Transactions.TransactionScope>\n","nodes":[{"pos":[4,178],"embed":true,"restype":"x-metadata","content":"title: \"Implementing an Implicit Transaction using Transaction Scope\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9","nodes":[{"content":"Implementing an Implicit Transaction using Transaction Scope","nodes":[{"pos":[0,60],"content":"Implementing an Implicit Transaction using Transaction Scope","nodes":[{"content":"Implementing an Implicit Transaction using Transaction Scope","pos":[0,60]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[185,245],"content":"Implementing an Implicit Transaction using Transaction Scope","linkify":"Implementing an Implicit Transaction using Transaction Scope","nodes":[{"content":"Implementing an Implicit Transaction using Transaction Scope","pos":[0,60]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.","pos":[246,443],"source":"The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself."},{"content":"A transaction scope can select and manage the ambient transaction automatically.","pos":[444,524]},{"content":"Due to its ease of use and efficiency, it is recommended that you use the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> class when developing a transaction application.","pos":[525,691],"source":" Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application."},{"content":"In addition, you do not need to enlist resources explicitly with the transaction.","pos":[698,779]},{"content":"Any <ph id=\"ph1\">&lt;xref:System.Transactions&gt;</ph> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.","pos":[780,951],"source":" Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist."},{"pos":[960,988],"content":"Creating a transaction scope","linkify":"Creating a transaction scope","nodes":[{"content":"Creating a transaction scope","pos":[0,28]}]},{"pos":[992,1091],"content":"The following sample shows a simple usage of the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> class.","source":"The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class."},{"content":"The transaction scope is started once you create a new <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object.","pos":[1368,1474],"source":"The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object."},{"content":"As illustrated in the code sample, it is recommended that you create scopes with a <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement.","pos":[1476,1579],"source":"  As illustrated in the code sample, it is recommended that you create scopes with a **using** statement."},{"content":"The <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement is available both in C# and in Visual Basic, and works like a <bpt id=\"p2\">**</bpt>try...finally<ept id=\"p2\">**</ept> block to ensure that the scope is disposed of properly.","pos":[1580,1739],"source":" The **using** statement is available both in C# and in Visual Basic, and works like a **try...finally** block to ensure that the scope is disposed of properly."},{"content":"When you instantiate <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph>, the transaction manager determines which transaction to participate in.","pos":[1746,1883],"source":"When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in."},{"content":"Once determined, the scope always participates in that transaction.","pos":[1884,1951]},{"content":"The decision is based on two factors: whether an ambient transaction is present and the value of the <bpt id=\"p1\">**</bpt>TransactionScopeOption<ept id=\"p1\">**</ept> parameter in the constructor.","pos":[1952,2109],"source":" The decision is based on two factors: whether an ambient transaction is present and the value of the **TransactionScopeOption** parameter in the constructor."},{"content":"The ambient transaction is the transaction within which your code executes.","pos":[2110,2185]},{"content":"You can obtain a reference to the ambient transaction by calling the static <ph id=\"ph1\">&lt;xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Transactions.Transaction&gt;</ph> class.","pos":[2186,2402],"source":" You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class."},{"content":"For more information on how this parameter is used, see the <bpt id=\"p1\">[</bpt>Managing transaction flow using TransactionScopeOption<ept id=\"p1\">](#ManageTxFlow)</ept> section of this topic.","pos":[2403,2557],"source":" For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic."},{"pos":[2566,2596],"content":"Completing a transaction scope","linkify":"Completing a transaction scope","nodes":[{"content":"Completing a transaction scope","pos":[0,30]}]},{"content":"When your application completes all the work it wants to perform in a transaction, you should call the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType&gt;</ph> method only once to inform the transaction manager that it is acceptable to commit the transaction.","pos":[2600,2887],"source":"When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> method only once to inform the transaction manager that it is acceptable to commit the transaction."},{"content":"It is very good practice to put the call to <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A&gt;</ph> as the last statement in the <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> block.","pos":[2888,3033],"source":" It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the **using** block."},{"content":"Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.","pos":[3040,3234]},{"content":"However, calling this method does not guarantee that the transaction wil be committed.","pos":[3235,3321]},{"content":"It is merely a way of informing the transaction manager of your status.","pos":[3322,3393]},{"content":"After calling the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A&gt;</ph> method, you can no longer access the ambient transaction by using the <ph id=\"ph2\">&lt;xref:System.Transactions.Transaction.Current%2A&gt;</ph> property, and attempting to do so will result in an exception being thrown.","pos":[3394,3663],"source":" After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> block.","pos":[3670,3894],"source":"If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the **using** block."},{"content":"If it did not create the transaction, the commit occurs whenever <ph id=\"ph1\">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> is called by the owner of the <ph id=\"ph2\">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> object.","pos":[3895,4107],"source":" If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object."},{"content":"At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A&gt;</ph> method was called on the <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object.","pos":[4108,4374],"source":" At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object."},{"content":"The <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement ensures that the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Dispose%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object is called even if an exception occurs.","pos":[4381,4580],"source":"The **using** statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Dispose%2A&gt;</ph> method marks the end of the transaction scope.","pos":[4581,4686],"source":" The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope."},{"content":"Exceptions that occur after calling this method may not affect the transaction.","pos":[4687,4766]},{"content":"This method also restores the ambient transaction to it previous state.","pos":[4767,4838]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionAbortedException&gt;</ph> is thrown if the scope creates the transaction, and the transaction is aborted.","pos":[4845,4981],"source":"A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionInDoubtException&gt;</ph> is thrown if the transaction manager cannot reach a Commit decision.","pos":[4982,5107],"source":" A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision."},{"content":"No exception is thrown if the transaction is committed.","pos":[5108,5163]},{"pos":[5172,5198],"content":"Rolling back a transaction","linkify":"Rolling back a transaction","nodes":[{"content":"Rolling back a transaction","pos":[0,26]}]},{"content":"If you want to rollback a transaction, you should not call the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A&gt;</ph> method within the transaction scope.","pos":[5202,5357],"source":"If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope."},{"content":"For example, you can throw an exception within the scope.","pos":[5358,5415]},{"content":"The transaction in which it participates in will be rolled back.","pos":[5416,5480]},{"pos":[5489,5571],"content":"<bpt id=\"p1\">&lt;a name=\"ManageTxFlow\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Managing transaction flow using TransactionScopeOption","linkify":"<a name=\"ManageTxFlow\"></a> Managing transaction flow using TransactionScopeOption","source":"<a name=\"ManageTxFlow\"></a> Managing transaction flow using TransactionScopeOption"},{"pos":[5575,5798],"content":"Transaction scope can be nested by calling a method that uses a <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> from within a method that uses its own scope, as is the case with the <ph id=\"ph2\">`RootMethod`</ph> method in the following example,","source":"Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,"},{"content":"The top-most transaction scope is referred to as the root scope.","pos":[6231,6295]},{"pos":[6302,6541],"content":"The <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> class provides several overloaded constructors that accept an enumeration of the type <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScopeOption&gt;</ph>, which defines the transactional behavior of the scope.","source":"The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope."},{"pos":[6548,6619],"content":"A <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object has three options:","source":"A <xref:System.Transactions.TransactionScope> object has three options:"},{"content":"Join the ambient transaction, or create a new one if one does not exist.","pos":[6629,6701]},{"content":"Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.","pos":[6711,6843]},{"content":"Not take part in a transaction at all.","pos":[6853,6891]},{"content":"There is no ambient transaction as a result.","pos":[6892,6936]},{"content":"If the scope is instantiated with <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScopeOption.Required&gt;</ph>, and an ambient transaction is present, the scope joins that transaction.","pos":[6943,7109],"source":"If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction."},{"content":"If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.","pos":[7110,7234]},{"content":"This is the default value.","pos":[7235,7261]},{"content":"When <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScopeOption.Required&gt;</ph> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.","pos":[7262,7460],"source":" When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction."},{"content":"It should operate identically in both cases.","pos":[7461,7505]},{"content":"If the scope is instantiated with <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScopeOption.RequiresNew&gt;</ph>, it is always the root scope.","pos":[7512,7637],"source":"If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope."},{"content":"It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.","pos":[7638,7740]},{"content":"If the scope is instantiated with <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScopeOption.Suppress&gt;</ph>, it never takes part in a transaction, regardless of whether an ambient transaction is present.","pos":[7747,7935],"source":"If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present."},{"content":"A scope instantiated with this value always have <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> as its ambient transaction.","pos":[7936,8021],"source":" A scope instantiated with this value always have **null** as its ambient transaction."},{"content":"The above options are summarized in the following table.","pos":[8028,8084]},{"content":"TransactionScopeOption","pos":[8091,8113]},{"content":"Ambient Transaction","pos":[8114,8133]},{"content":"The scope takes part in","pos":[8134,8157]},{"content":"Required","pos":[8251,8259]},{"content":"No","pos":[8260,8262]},{"content":"New Transaction (will be the root)","pos":[8263,8297]},{"content":"Requires New","pos":[8302,8314]},{"content":"No","pos":[8315,8317]},{"content":"New Transaction (will be the root)","pos":[8318,8352]},{"content":"Suppress","pos":[8357,8365]},{"content":"No","pos":[8366,8368]},{"content":"No Transaction","pos":[8369,8383]},{"content":"Required","pos":[8388,8396]},{"content":"Yes","pos":[8397,8400]},{"content":"Ambient  Transaction","pos":[8401,8421]},{"content":"Requires New","pos":[8426,8438]},{"content":"Yes","pos":[8439,8442]},{"content":"New Transaction (will be the root)","pos":[8443,8477]},{"content":"Suppress","pos":[8482,8490]},{"content":"Yes","pos":[8491,8494]},{"content":"No Transaction","pos":[8495,8509]},{"content":"When a <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.","pos":[8517,8713],"source":"When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction."},{"content":"If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <ph id=\"ph1\">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> get called on the transaction.","pos":[8714,8906],"source":" If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction."},{"content":"If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.","pos":[8907,9024]},{"pos":[9031,9244],"content":"The following example shows a <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object that creates three nested scope objects, each instantiated with a different <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScopeOption&gt;</ph> value.","source":"The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value."},{"content":"The example shows a code block without any ambient transaction creating a new scope (<ph id=\"ph1\">`scope1`</ph>) with <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScopeOption.Required&gt;</ph>.","pos":[9767,9926],"source":"The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>."},{"content":"The scope <ph id=\"ph1\">`scope1`</ph> is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.","pos":[9927,10058],"source":" The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction."},{"content":"<ph id=\"ph1\">`Scope1`</ph> then creates three more objects, each with a different <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScopeOption&gt;</ph> value.","pos":[10059,10179],"source":"`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value."},{"content":"For example, <ph id=\"ph1\">`scope2`</ph> is created with <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScopeOption.Required&gt;</ph>, and since there is an ambient transaction, it joins the first transaction created by <ph id=\"ph3\">`scope1`</ph>.","pos":[10180,10372],"source":" For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`."},{"content":"Note that <ph id=\"ph1\">`scope3`</ph> is the root scope of a new transaction, and that <ph id=\"ph2\">`scope4`</ph> has no ambient transaction.","pos":[10373,10477],"source":" Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction."},{"pos":[10484,10698],"content":"Although the default and most commonly used value of <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScopeOption&gt;</ph> is <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionScopeOption.Required&gt;</ph>, each of the other values has its unique purpose.","source":"Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose."},{"content":"<ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScopeOption.Suppress&gt;</ph> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.","pos":[10705,10918],"source":"<xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail."},{"content":"For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.","pos":[10919,11101]},{"content":"This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.","pos":[11102,11227]},{"pos":[11686,11714],"content":"Voting inside a nested scope","linkify":"Voting inside a nested scope","nodes":[{"content":"Voting inside a nested scope","pos":[0,28]}]},{"content":"Although a nested scope can join the ambient transaction of the root scope, calling <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A&gt;</ph> in the nested scope has no affect on the root scope.","pos":[11718,11910],"source":"Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope."},{"content":"Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.","pos":[11911,12050]},{"content":"Not calling <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope.Complete%2A&gt;</ph> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.","pos":[12051,12219],"source":" Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted."},{"pos":[12228,12264],"content":"Setting the TransactionScope timeout","linkify":"Setting the TransactionScope timeout","nodes":[{"content":"Setting the TransactionScope timeout","pos":[0,36]}]},{"content":"Some of the overloaded constructors of <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> accept a value of type <ph id=\"ph2\">&lt;xref:System.TimeSpan&gt;</ph>, which is used to control the timeout of the transaction.","pos":[12268,12454],"source":"Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction."},{"content":"A timeout set to zero means an infinite timeout.","pos":[12455,12503]},{"content":"Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.","pos":[12504,12740]},{"content":"Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.","pos":[12741,12881]},{"content":"You typically set the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> timeout to values other than default in two cases.","pos":[12888,13004],"source":"You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases."},{"content":"The first is during development, when you want to test the way your application handles aborted transactions.","pos":[13005,13114]},{"content":"By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.","pos":[13115,13263]},{"content":"The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.","pos":[13264,13437]},{"content":"In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.","pos":[13438,13553]},{"content":"When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.","pos":[13560,13879],"source":"When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted."},{"content":"If the nested scope's timeout is more than that of the ambient transaction, it has no effect.","pos":[13880,13973]},{"pos":[13982,14026],"content":"Setting the TransactionScope isolation level","linkify":"Setting the TransactionScope isolation level","nodes":[{"content":"Setting the TransactionScope isolation level","pos":[0,44]}]},{"content":"Some of the overloaded constructors of <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> accept a structure of type <ph id=\"ph2\">&lt;xref:System.Transactions.TransactionOptions&gt;</ph> to specify an isolation level, in addition to a timeout value.","pos":[14030,14248],"source":"Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value."},{"content":"By default, the transaction executes with isolation level set to <ph id=\"ph1\">&lt;xref:System.Transactions.IsolationLevel.Serializable&gt;</ph>.","pos":[14249,14369],"source":" By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>."},{"content":"Selecting an isolation level other than <ph id=\"ph1\">&lt;xref:System.Transactions.IsolationLevel.Serializable&gt;</ph> is commonly used for read-intensive systems.","pos":[14370,14509],"source":" Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems."},{"content":"This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.","pos":[14510,14701]},{"content":"In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.","pos":[14708,14873]},{"content":"Every isolation level besides <ph id=\"ph1\">&lt;xref:System.Transactions.IsolationLevel.Serializable&gt;</ph> is susceptible to inconsistency resulting from other transactions accessing the same information.","pos":[14880,15062],"source":"Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information."},{"content":"The difference between the different isolation levels is in the way read and write locks are used.","pos":[15063,15161]},{"content":"A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.","pos":[15162,15314]},{"content":"The former is better for throughput, the latter for consistency.","pos":[15315,15379]},{"content":"The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.","pos":[15380,15481]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Transactions.IsolationLevel&gt;</ph> for more information.","pos":[15482,15549],"source":" See <xref:System.Transactions.IsolationLevel> for more information."},{"content":"When using nested <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.","pos":[15556,15749],"source":"When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction."},{"content":"If a nested <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> object tries to join the ambient transaction yet it specifies a different isolation level, an <ph id=\"ph2\">&lt;xref:System.ArgumentException&gt;</ph> is thrown.","pos":[15750,15942],"source":" If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown."},{"pos":[15951,15968],"content":"Interop with COM+","linkify":"Interop with COM+","nodes":[{"content":"Interop with COM+","pos":[0,17]}]},{"content":"When you create a new <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionScope&gt;</ph> instance, you can use the <ph id=\"ph2\">&lt;xref:System.Transactions.EnterpriseServicesInteropOption&gt;</ph> enumeration in one of the constructors to specify how to interact with COM+.","pos":[15972,16199],"source":"When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+."},{"content":"For more information on this, see <bpt id=\"p1\">[</bpt>Interoperability with Enterprise Services and COM+ Transactions<ept id=\"p1\">](../../../../docs/framework/data/transactions/interoperability-with-enterprise-services-and-com-transactions.md)</ept>.","pos":[16200,16412],"source":" For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](../../../../docs/framework/data/transactions/interoperability-with-enterprise-services-and-com-transactions.md)."},{"pos":[16421,16429],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]}]}