{"content":"---\ntitle: Use pattern matching features to extend data types\ndescription: This advanced tutorial demonstrates how to use pattern matching techniques to create functionality using data and algorithms that are created separately.\nms.date: 03/13/2019\nms.custom: mvc\n---\n# Tutorial: Using pattern matching features to extend data types\n\nC# 7 introduced basic pattern matching features. Those features are extended in C# 8 with new expressions and patterns. You can write functionality that behaves as though you extended types that may be in other libraries. Another use for patterns is to create functionality your application requires that isn't a fundamental feature of the type being extended.\n\nIn this tutorial, you'll learn how to:\n\n> [!div class=\"checklist\"]\n> * Recognize situations where pattern matching should be used.\n> * Use pattern matching expressions to implement behavior based on types and property values.\n> * Combine pattern matching with other techniques to create complete algorithms.\n\n## Prerequisites\n\nYou'll need to set up your machine to run .NET Core, including the C# 8.0 preview compiler. The C# 8 preview compiler is available with the latest [Visual Studio 2019 preview](https://visualstudio.microsoft.com/vs/preview/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019+preview), or the latest [.NET Core 3.0 preview](https://dotnet.microsoft.com/download/dotnet-core/3.0).\n\nThis tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.\n\n## Scenarios for pattern matching\n\nModern development often includes integrating data from multiple sources and presenting information and insights from that data in a single cohesive application. You and your team won't have control or access for all the types that represent the incoming data.\n\nThe classic object-oriented design would call for creating types in your application that represent each data type from those multiple data sources. Then, your application would work with those new types, build inheritance hierarchies, create virtual methods, and implement abstractions. Those techniques work, and sometimes they are the best tools. Other times you can write less code. You can write more clear code using techniques that separate the data from the operations that manipulate that data.\n\nIn this tutorial, you'll create and explore an application that takes incoming data from several external sources for a single scenario. You'll see how **pattern matching** provides an efficient way to consume and process that data in ways that weren't part of the original system.\n\nConsider a major metro area that is using tolls and peak time pricing to manage traffic. You write an application that calculates tolls for a vehicle based on its type. Later enhancements incorporate pricing based on the number of occupants in the vehicle. Further enhancements add pricing based on the time and the day of the week.\n\nFrom that brief description, you may have quickly sketched out an object hierarchy to model this system. However, your data is coming from multiple sources like other vehicle registration management systems. These systems provide different classes to model that data and you don't have a single object model you can use. In this tutorial, you'll use these simplified classes to model for the vehicle data from these external systems, as shown in the following code:\n\n[!code-csharp[ExternalSystems](~/samples/csharp/tutorials/patterns/start/toll-calculator/ExternalSystems.cs)]\n\nYou can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/start) GitHub repository. You can see that the vehicle classes are from different systems, and are in different namespaces. No common base class, other than `System.Object` can be leveraged.\n\n## Pattern matching designs\n\nThe scenario used in this tutorial highlights the kinds of problems that pattern matching is well-suited to solve:\n\n- The objects you need to work with aren't in an object hierarchy that matches your goals. You may be working with classes that are part of unrelated systems.\n- The functionality you're adding isn't part of the core abstraction for these classes. The toll paid by a vehicle *changes* for different types of vehicles, but the toll isn't a core function of the vehicle.\n\nWhen the *shape* of the data and the *operations* on that data are not described together, the pattern matching features in C# make it easier to work with.\n\n## Implement the basic toll calculations\n\nThe most basic toll calculation relies only on the vehicle type:\n\n- A `Car` is $2.00.\n- A `Taxi` is $3.50.\n- A `Bus` is $5.00.\n- A `DeliveryTruck` is $10.00\n\nCreate a new `TollCalculator` class, and implement pattern matching on the vehicle type to get the toll amount. The following code shows the initial implementation of the `TollCalculator`.\n\n```csharp\nusing System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nnamespace toll_calculator\n{\n    public class TollCalculator\n    {\n        public decimal CalculateToll(object vehicle) =>\n            vehicle switch\n        {\n            Car c           => 2.00m,\n            Taxi t          => 3.50m,\n            Bus b           => 5.00m,\n            DeliveryTruck t => 10.00m,\n            { }             => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n            null            => throw new ArgumentNullException(nameof(vehicle))\n        };\n    }\n}\n```\n\nThe preceding code uses a **switch expression** (not the same as a [`switch`](../language-reference/keywords/switch.md) statement) that tests the **type pattern**. A **switch expression** begins with the variable, `vehicle` in the preceding code, followed by the `switch` keyword. Next comes all the **switch arms** inside curly braces. The `switch` expression makes other refinements to the syntax that surrounds the `switch` statement. The `case` keyword is omitted, and the result of each arm is an expression. The last two arms show a new language feature. The `{ }` case matches any non-null object that didn't match an earlier arm. This arm catches any incorrect types passed to this method.  The `{ }` case must follow the cases for each vehicle type. If the order were reversed, the `{ }` case would take precedence. Finally, the `null` pattern detects when a `null` is passed to this method. The `null` pattern can be last because the other type patterns match only a non-null object of the correct type.\n\nYou can test this code using the following code in `Program.cs`:\n\n```csharp\nusing System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nnamespace toll_calculator\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var tollCalc = new TollCalculator();\n\n            var car = new Car();\n            var taxi = new Taxi();\n            var bus = new Bus();\n            var truck = new DeliveryTruck();\n\n            Console.WriteLine($\"The toll for a car is {tollCalc.CalculateToll(car)}\");\n            Console.WriteLine($\"The toll for a taxi is {tollCalc.CalculateToll(taxi)}\");\n            Console.WriteLine($\"The toll for a bus is {tollCalc.CalculateToll(bus)}\");\n            Console.WriteLine($\"The toll for a truck is {tollCalc.CalculateToll(truck)}\");\n\n            try\n            {\n                tollCalc.CalculateToll(\"this will fail\");\n            }\n            catch (ArgumentException e)\n            {\n                Console.WriteLine(\"Caught an argument exception when using the wrong type\");\n            }\n            try\n            {\n                tollCalc.CalculateToll(null);\n            }\n            catch (ArgumentNullException e)\n            {\n                Console.WriteLine(\"Caught an argument exception when using null\");\n            }\n        }\n    }\n}\n```\n\nThat code is included in the starter project, but is commented out. Remove the comments, and you can test what you've written.\n\nYou're starting to see how patterns can help you create algorithms where the code and the data are separate. The `switch` expression tests the type and produces different values based on the results. That's only the beginning.\n\n## Add occupancy pricing\n\nThe toll authority wants to encourage vehicles to travel at maximum capacity. They've decided to charge more when vehicles have fewer passengers, and encourage full vehicles by offering lower pricing:\n\n- Cars and taxis with no passengers pay an extra $0.50.\n- Cars and taxis with two passengers get a 0.50 discount.\n- Cars and taxis with three or more passengers get a $1.00 discount.\n- Buses that are less than 50% full pay an extra $2.00.\n- Buses that are more than 90% full get a $1.00 discount.\n\nThese rules can be implemented using the **property pattern** in the same switch expression. The property pattern examines properties of the object once the type has been determined. The single case for a `Car` expands to four different cases:\n\n```csharp\nvehicle switch\n{\n    Car { Passengers: 0}        => 2.00m + 0.50m,\n    Car { Passengers: 1 }       => 2.0m,\n    Car { Passengers: 2}        => 2.0m - 0.50m,\n    Car c                       => 2.00m - 1.0m,\n\n    // ...\n};\n```\n\nThe first three cases test the type as a `Car`, then check the value of the `Passengers` property. If both match, that expression is evaluated and returned.\n\nYou would also expand the cases for taxis in a similar manner:\n\n```csharp\nvehicle switch\n{\n    // ...\n\n    Taxi { Fares: 0}  => 3.50m + 1.00m,\n    Taxi { Fares: 1 } => 3.50m,\n    Taxi { Fares: 2}  => 3.50m - 0.50m,\n    Taxi t            => 3.50m - 1.00m,\n\n    // ...\n};\n```\n\nIn the preceding example, the `when` clause was omitted on the final case.\n\nNext, implement the occupancy rules by expanding the cases for buses, as shown in the following example:\n\n```csharp\nvehicle switch\n{\n    // ...\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus b => 5.00m,\n\n    // ...\n};\n```\n\nThe toll authority isn't concerned with the number of passengers in the delivery trucks. Instead, they charge more based on the weight class of the trucks. Trucks over 5000 lbs are charged an extra $5.00. Light trucks under 3000 lbs are given a $2.00 discount. That rule is implemented with the following code:\n\n```csharp\nvehicle switch\n{\n    // ...\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck t => 10.00m,\n};\n```\n\nThe preceding code shows the `when` clause of a switch arm. You use the `when` clause to test conditions other than equality on a property. When you've finished, you'll have a method that looks much like the following:\n\n```csharp\nvehicle switch\n{\n    Car { Passengers: 0}        => 2.00m + 0.50m,\n    Car { Passengers: 1}        => 2.0m,\n    Car { Passengers: 2}        => 2.0m - 0.50m,\n    Car c                       => 2.00m - 1.0m,\n\n    Taxi { Fares: 0}  => 3.50m + 1.00m,\n    Taxi { Fares: 1 } => 3.50m,\n    Taxi { Fares: 2}  => 3.50m - 0.50m,\n    Taxi t            => 3.50m - 1.00m,\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus b => 5.00m,\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck t => 10.00m,\n};\n```\n\nMany of these switch arms are examples of **recursive patterns**. For example, `Car { Passengers: 1}` shows a constant pattern inside a property pattern.\n\nYou can make this code less repetitive by using nested switches. The `Car` and `Taxi` both have four different arms in the preceding examples. In both cases, you can create a type pattern that feeds into a property pattern. This technique is shown in the following code:\n\n```csharp\npublic decimal CalculateToll(object vehicle) =>\n    vehicle switch\n    {\n        Car c => c.Passengers switch\n        {\n            0 => 2.00m + 0.5m,\n            1 => 2.0m,\n            2 => 2.0m - 0.5m,\n            _ => 2.00m - 1.0m\n        },\n\n        Taxi t => t.Fares switch\n        {\n            0 => 3.50m + 1.00m,\n            1 => 3.50m,\n            2 => 3.50m - 0.50m,\n            _ => 3.50m - 1.00m\n        },\n\n        Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n        Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n        Bus b => 5.00m,\n\n        DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n        DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n        DeliveryTruck t => 10.00m,\n\n        { }  => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n        null => throw new ArgumentNullException(nameof(vehicle))\n    };\n```\n\nIn the preceding sample, using a recursive expression means you don't repeat the `Car` and `Taxi` arms containing child arms that test the property value. This technique isn't used for the `Bus` and `DeliveryTruck` arms because those arms are testing ranges for the property, not discrete values.\n\n## Add peak pricing\n\nFor the final feature, the toll authority wants to add time sensitive peak pricing. During the morning and evening rush hours, the tolls are doubled. That rule only affects traffic in one direction: inbound to the city in the morning, and outbound in the evening rush hour. During other times during the workday, tolls increase by 50%. Late night and early morning, tolls are reduced by 25%. During the weekend, it's the normal rate, regardless of the time.\n\nYou'll use pattern matching for this feature, but you'll integrate it with other techniques. You could build a single pattern match expression that would account for all the combinations of direction, day of the week, and time. The result would be a complicated expression. It would be hard to read and difficult to understand. That makes it hard to ensure correctness. Instead, combine those methods to build a tuple of values that concisely describes all those states. Then use pattern matching to calculate a multiplier for the toll. The tuple contains three discrete conditions:\n\n- The day is either a weekday or a weekend.\n- The band of time when the toll is collected.\n- The direction is into the city or out of the city\n\nThe following table shows the combinations of input values and the peak pricing multiplier:\n\n| Day        | Time         | Direction | Premium |\n| ---------- | ------------ | --------- |--------:|\n| Weekday    | morning rush | inbound   | x 2.00  |\n| Weekday    | morning rush | outbound  | x 1.00  |\n| Weekday    | daytime      | inbound   | x 1.50  |\n| Weekday    | daytime      | outbound  | x 1.50  |\n| Weekday    | evening rush | inbound   | x 1.00  |\n| Weekday    | evening rush | outbound  | x 2.00  |\n| Weekday    | overnight    | inbound   | x 0.75  |\n| Weekday    | overnight    | outbound  | x 0.75  |\n| Weekend    | morning rush | inbound   | x 1.00  |\n| Weekend    | morning rush | outbound  | x 1.00  |\n| Weekend    | daytime      | inbound   | x 1.00  |\n| Weekend    | daytime      | outbound  | x 1.00  |\n| Weekend    | evening rush | inbound   | x 1.00  |\n| Weekend    | evening rush | outbound  | x 1.00  |\n| Weekend    | overnight    | inbound   | x 1.00  |\n| Weekend    | overnight    | outbound  | x 1.00  |\n\nThere are 16 different combinations of the three variables. By combining some of the conditions, you'll simplify the final switch expression.\n\nThe system that collects the tolls uses a <xref:System.DateTime> structure for the time when the toll was collected. Build member methods that create the variables from the preceding table. The following function uses a pattern matching switch expression to express whether a <xref:System.DateTime> represents a weekend or a weekday:\n\n```csharp\nprivate static bool IsWeekDay(DateTime timeOfToll) =>\n    timeOfToll.DayOfWeek switch\n    {\n        DayOfWeek.Monday    => true,\n        DayOfWeek.Tuesday   => true,\n        DayOfWeek.Wednesday => true,\n        DayOfWeek.Thursday  => true,\n        DayOfWeek.Friday    => true,\n        DayOfWeek.Saturday  => false,\n        DayOfWeek.Sunday    => false\n    };\n```\n\nThat method works, but it's repetitious. You can simplify it, as shown in the following code:\n\n[!code-csharp[IsWeekDay](~/samples/csharp/tutorials/patterns/finished/toll-calculator/TollCalculator.cs#IsWeekDay)]\n\nNext, add a similar function to categorize the time into the blocks:\n\n[!code-csharp[GetTimeBand](~/samples/csharp/tutorials/patterns/finished/toll-calculator/TollCalculator.cs#GetTimeBand)]\n\nThe previous method doesn't use pattern matching. It's clearer using a familiar cascade of `if` statements. You do add a private `enum` to convert each range of time to a discrete value.\n\nAfter you create those methods, you can use another `switch` expression with the **tuple pattern** to calculate the pricing premium. You could build a `switch` expression with all 16 arms:\n\n[!code-csharp[FullTuplePattern](~/samples/csharp/tutorials/patterns/finished/toll-calculator/TollCalculator.cs#TuplePatternOne)]\n\nThe above code works, but it can be simplified. All eight combinations for the weekend have the same toll. You can replace all eight with the following line:\n\n```csharp\n(false, _, _) => 1.0m,\n```\n\nBoth inbound and outbound traffic have the same multiplier during the weekday daytime and overnight hours. Those four switch arms can be replaced with the following two lines:\n\n```csharp\n(true, TimeBand.Overnight, _) => 0.75m,\n(true, TimeBand.Daytime, _)   => 1.5m,\n```\n\nThe code should look like the following code after those two changes:\n\n```csharp\npublic decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.MorningRush, true)  => 2.00m,\n        (true, TimeBand.MorningRush, false) => 1.00m,\n        (true, TimeBand.Daytime,     _)     => 1.50m,\n        (true, TimeBand.EveningRush, true)  => 1.00m,\n        (true, TimeBand.EveningRush, false) => 2.00m,\n        (true, TimeBand.Overnight,   _)     => 0.75m,\n        (false, _,                   _)     => 1.00m,\n    };\n```\n\nFinally, you can remove the two rush hour times that pay the regular price. Once you remove those arms, you can replace the `false` with a discard (`_`) in the final switch arm. You'll have the following finished method:\n\n[!code-csharp[SimplifiedTuplePattern](../../../samples/csharp/tutorials/patterns/finished/toll-calculator/TollCalculator.cs#FinalTuplePattern)]\n\nThis example highlights one of the advantages of pattern matching: the pattern branches are evaluated in order. If you rearrange them so that an earlier branch handles one of your later cases, the compiler warns you about the unreachable code. Those language rules made it easier to do the preceding simplifications with confidence that the code didn't change.\n\nPattern matching makes some types of code more readable and offers an alternative to object-oriented techniques when you can't add code to your classes. The cloud is causing data and functionality to live apart. The *shape* of the data and the *operations* on it aren't necessarily described together. In this tutorial, you consumed existing data in entirely different ways from its original function. Pattern matching gave you the ability to write functionality that overrode those types, even though you couldn't extend them.\n\n## Next steps\n\nYou can download the finished code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/finished) GitHub repository. Explore patterns on your own and add this technique into your regular coding activities. Learning these techniques gives you another way to approach problems and create new functionality.\n","nodes":[{"pos":[4,263],"embed":true,"restype":"x-metadata","content":"title: Use pattern matching features to extend data types\ndescription: This advanced tutorial demonstrates how to use pattern matching techniques to create functionality using data and algorithms that are created separately.\nms.date: 03/13/2019\nms.custom: mvc","nodes":[{"content":"Use pattern matching features to extend data types","nodes":[{"pos":[0,50],"content":"Use pattern matching features to extend data types","nodes":[{"content":"Use pattern matching features to extend data types","pos":[0,50]}]}],"path":["title"],"nosxs":false},{"content":"This advanced tutorial demonstrates how to use pattern matching techniques to create functionality using data and algorithms that are created separately.","nodes":[{"pos":[0,153],"content":"This advanced tutorial demonstrates how to use pattern matching techniques to create functionality using data and algorithms that are created separately.","nodes":[{"content":"This advanced tutorial demonstrates how to use pattern matching techniques to create functionality using data and algorithms that are created separately.","pos":[0,153]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[270,332],"content":"Tutorial: Using pattern matching features to extend data types","linkify":"Tutorial: Using pattern matching features to extend data types","nodes":[{"content":"Tutorial: Using pattern matching features to extend data types","pos":[0,62]}]},{"content":"C# 7 introduced basic pattern matching features.","pos":[334,382]},{"content":"Those features are extended in C# 8 with new expressions and patterns.","pos":[383,453]},{"content":"You can write functionality that behaves as though you extended types that may be in other libraries.","pos":[454,555]},{"content":"Another use for patterns is to create functionality your application requires that isn't a fundamental feature of the type being extended.","pos":[556,694]},{"content":"In this tutorial, you'll learn how to:","pos":[696,734]},{"content":"Recognize situations where pattern matching should be used.","pos":[767,826]},{"content":"Use pattern matching expressions to implement behavior based on types and property values.","pos":[831,921]},{"content":"Combine pattern matching with other techniques to create complete algorithms.","pos":[926,1003]},{"pos":[1008,1021],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"You'll need to set up your machine to run .NET Core, including the C# 8.0 preview compiler.","pos":[1023,1114]},{"content":"The C# 8 preview compiler is available with the latest <bpt id=\"p1\">[</bpt>Visual Studio 2019 preview<ept id=\"p1\">](https://visualstudio.microsoft.com/vs/preview/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019+preview)</ept>, or the latest <bpt id=\"p2\">[</bpt>.NET Core 3.0 preview<ept id=\"p2\">](https://dotnet.microsoft.com/download/dotnet-core/3.0)</ept>.","pos":[1115,1453],"source":" The C# 8 preview compiler is available with the latest [Visual Studio 2019 preview](https://visualstudio.microsoft.com/vs/preview/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019+preview), or the latest [.NET Core 3.0 preview](https://dotnet.microsoft.com/download/dotnet-core/3.0)."},{"content":"This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.","pos":[1455,1563]},{"pos":[1568,1598],"content":"Scenarios for pattern matching","linkify":"Scenarios for pattern matching","nodes":[{"content":"Scenarios for pattern matching","pos":[0,30]}]},{"content":"Modern development often includes integrating data from multiple sources and presenting information and insights from that data in a single cohesive application.","pos":[1600,1761]},{"content":"You and your team won't have control or access for all the types that represent the incoming data.","pos":[1762,1860]},{"content":"The classic object-oriented design would call for creating types in your application that represent each data type from those multiple data sources.","pos":[1862,2010]},{"content":"Then, your application would work with those new types, build inheritance hierarchies, create virtual methods, and implement abstractions.","pos":[2011,2149]},{"content":"Those techniques work, and sometimes they are the best tools.","pos":[2150,2211]},{"content":"Other times you can write less code.","pos":[2212,2248]},{"content":"You can write more clear code using techniques that separate the data from the operations that manipulate that data.","pos":[2249,2365]},{"content":"In this tutorial, you'll create and explore an application that takes incoming data from several external sources for a single scenario.","pos":[2367,2503]},{"content":"You'll see how <bpt id=\"p1\">**</bpt>pattern matching<ept id=\"p1\">**</ept> provides an efficient way to consume and process that data in ways that weren't part of the original system.","pos":[2504,2648],"source":" You'll see how **pattern matching** provides an efficient way to consume and process that data in ways that weren't part of the original system."},{"content":"Consider a major metro area that is using tolls and peak time pricing to manage traffic.","pos":[2650,2738]},{"content":"You write an application that calculates tolls for a vehicle based on its type.","pos":[2739,2818]},{"content":"Later enhancements incorporate pricing based on the number of occupants in the vehicle.","pos":[2819,2906]},{"content":"Further enhancements add pricing based on the time and the day of the week.","pos":[2907,2982]},{"content":"From that brief description, you may have quickly sketched out an object hierarchy to model this system.","pos":[2984,3088]},{"content":"However, your data is coming from multiple sources like other vehicle registration management systems.","pos":[3089,3191]},{"content":"These systems provide different classes to model that data and you don't have a single object model you can use.","pos":[3192,3304]},{"content":"In this tutorial, you'll use these simplified classes to model for the vehicle data from these external systems, as shown in the following code:","pos":[3305,3449]},{"content":"You can download the starter code from the <bpt id=\"p1\">[</bpt>dotnet/samples<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/start)</ept> GitHub repository.","pos":[3562,3719],"source":"You can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/start) GitHub repository."},{"content":"You can see that the vehicle classes are from different systems, and are in different namespaces.","pos":[3720,3817]},{"content":"No common base class, other than <ph id=\"ph1\">`System.Object`</ph> can be leveraged.","pos":[3818,3884],"source":" No common base class, other than `System.Object` can be leveraged."},{"pos":[3889,3913],"content":"Pattern matching designs","linkify":"Pattern matching designs","nodes":[{"content":"Pattern matching designs","pos":[0,24]}]},{"content":"The scenario used in this tutorial highlights the kinds of problems that pattern matching is well-suited to solve:","pos":[3915,4029]},{"content":"The objects you need to work with aren't in an object hierarchy that matches your goals.","pos":[4033,4121]},{"content":"You may be working with classes that are part of unrelated systems.","pos":[4122,4189]},{"content":"The functionality you're adding isn't part of the core abstraction for these classes.","pos":[4192,4277]},{"content":"The toll paid by a vehicle <bpt id=\"p1\">*</bpt>changes<ept id=\"p1\">*</ept> for different types of vehicles, but the toll isn't a core function of the vehicle.","pos":[4278,4398],"source":" The toll paid by a vehicle *changes* for different types of vehicles, but the toll isn't a core function of the vehicle."},{"pos":[4400,4555],"content":"When the <bpt id=\"p1\">*</bpt>shape<ept id=\"p1\">*</ept> of the data and the <bpt id=\"p2\">*</bpt>operations<ept id=\"p2\">*</ept> on that data are not described together, the pattern matching features in C# make it easier to work with.","source":"When the *shape* of the data and the *operations* on that data are not described together, the pattern matching features in C# make it easier to work with."},{"pos":[4560,4597],"content":"Implement the basic toll calculations","linkify":"Implement the basic toll calculations","nodes":[{"content":"Implement the basic toll calculations","pos":[0,37]}]},{"content":"The most basic toll calculation relies only on the vehicle type:","pos":[4599,4663]},{"pos":[4667,4684],"content":"A <ph id=\"ph1\">`Car`</ph> is $2.00.","source":"A `Car` is $2.00."},{"pos":[4687,4705],"content":"A <ph id=\"ph1\">`Taxi`</ph> is $3.50.","source":"A `Taxi` is $3.50."},{"pos":[4708,4725],"content":"A <ph id=\"ph1\">`Bus`</ph> is $5.00.","source":"A `Bus` is $5.00."},{"pos":[4728,4755],"content":"A <ph id=\"ph1\">`DeliveryTruck`</ph> is $10.00","source":"A `DeliveryTruck` is $10.00"},{"content":"Create a new <ph id=\"ph1\">`TollCalculator`</ph> class, and implement pattern matching on the vehicle type to get the toll amount.","pos":[4757,4868],"source":"Create a new `TollCalculator` class, and implement pattern matching on the vehicle type to get the toll amount."},{"content":"The following code shows the initial implementation of the <ph id=\"ph1\">`TollCalculator`</ph>.","pos":[4869,4945],"source":" The following code shows the initial implementation of the `TollCalculator`."},{"content":"The preceding code uses a <bpt id=\"p1\">**</bpt>switch expression<ept id=\"p1\">**</ept> (not the same as a <bpt id=\"p2\">[</bpt><ph id=\"ph1\">`switch`</ph><ept id=\"p2\">](../language-reference/keywords/switch.md)</ept> statement) that tests the <bpt id=\"p3\">**</bpt>type pattern<ept id=\"p3\">**</ept>.","pos":[5604,5767],"source":"The preceding code uses a **switch expression** (not the same as a [`switch`](../language-reference/keywords/switch.md) statement) that tests the **type pattern**."},{"content":"A <bpt id=\"p1\">**</bpt>switch expression<ept id=\"p1\">**</ept> begins with the variable, <ph id=\"ph1\">`vehicle`</ph> in the preceding code, followed by the <ph id=\"ph2\">`switch`</ph> keyword.","pos":[5768,5884],"source":" A **switch expression** begins with the variable, `vehicle` in the preceding code, followed by the `switch` keyword."},{"content":"Next comes all the <bpt id=\"p1\">**</bpt>switch arms<ept id=\"p1\">**</ept> inside curly braces.","pos":[5885,5940],"source":" Next comes all the **switch arms** inside curly braces."},{"content":"The <ph id=\"ph1\">`switch`</ph> expression makes other refinements to the syntax that surrounds the <ph id=\"ph2\">`switch`</ph> statement.","pos":[5941,6041],"source":" The `switch` expression makes other refinements to the syntax that surrounds the `switch` statement."},{"content":"The <ph id=\"ph1\">`case`</ph> keyword is omitted, and the result of each arm is an expression.","pos":[6042,6117],"source":" The `case` keyword is omitted, and the result of each arm is an expression."},{"content":"The last two arms show a new language feature.","pos":[6118,6164]},{"content":"The <ph id=\"ph1\">`{ }`</ph> case matches any non-null object that didn't match an earlier arm.","pos":[6165,6241],"source":" The `{ }` case matches any non-null object that didn't match an earlier arm."},{"content":"This arm catches any incorrect types passed to this method.","pos":[6242,6301]},{"content":"The <ph id=\"ph1\">`{ }`</ph> case must follow the cases for each vehicle type.","pos":[6303,6362],"source":"  The `{ }` case must follow the cases for each vehicle type."},{"content":"If the order were reversed, the <ph id=\"ph1\">`{ }`</ph> case would take precedence.","pos":[6363,6428],"source":" If the order were reversed, the `{ }` case would take precedence."},{"content":"Finally, the <ph id=\"ph1\">`null`</ph> pattern detects when a <ph id=\"ph2\">`null`</ph> is passed to this method.","pos":[6429,6504],"source":" Finally, the `null` pattern detects when a `null` is passed to this method."},{"content":"The <ph id=\"ph1\">`null`</ph> pattern can be last because the other type patterns match only a non-null object of the correct type.","pos":[6505,6617],"source":" The `null` pattern can be last because the other type patterns match only a non-null object of the correct type."},{"pos":[6619,6683],"content":"You can test this code using the following code in <ph id=\"ph1\">`Program.cs`</ph>:","source":"You can test this code using the following code in `Program.cs`:"},{"content":"That code is included in the starter project, but is commented out. Remove the comments, and you can test what you've written.","pos":[7986,8112]},{"content":"You're starting to see how patterns can help you create algorithms where the code and the data are separate.","pos":[8114,8222]},{"content":"The <ph id=\"ph1\">`switch`</ph> expression tests the type and produces different values based on the results.","pos":[8223,8313],"source":" The `switch` expression tests the type and produces different values based on the results."},{"content":"That's only the beginning.","pos":[8314,8340]},{"pos":[8345,8366],"content":"Add occupancy pricing","linkify":"Add occupancy pricing","nodes":[{"content":"Add occupancy pricing","pos":[0,21]}]},{"content":"The toll authority wants to encourage vehicles to travel at maximum capacity.","pos":[8368,8445]},{"content":"They've decided to charge more when vehicles have fewer passengers, and encourage full vehicles by offering lower pricing:","pos":[8446,8568]},{"content":"Cars and taxis with no passengers pay an extra $0.50.","pos":[8572,8625]},{"content":"Cars and taxis with two passengers get a 0.50 discount.","pos":[8628,8683]},{"content":"Cars and taxis with three or more passengers get a $1.00 discount.","pos":[8686,8752]},{"content":"Buses that are less than 50% full pay an extra $2.00.","pos":[8755,8808]},{"content":"Buses that are more than 90% full get a $1.00 discount.","pos":[8811,8866]},{"content":"These rules can be implemented using the <bpt id=\"p1\">**</bpt>property pattern<ept id=\"p1\">**</ept> in the same switch expression.","pos":[8868,8960],"source":"These rules can be implemented using the **property pattern** in the same switch expression."},{"content":"The property pattern examines properties of the object once the type has been determined.","pos":[8961,9050]},{"content":"The single case for a <ph id=\"ph1\">`Car`</ph> expands to four different cases:","pos":[9051,9111],"source":" The single case for a `Car` expands to four different cases:"},{"content":"The first three cases test the type as a <ph id=\"ph1\">`Car`</ph>, then check the value of the <ph id=\"ph2\">`Passengers`</ph> property.","pos":[9349,9447],"source":"The first three cases test the type as a `Car`, then check the value of the `Passengers` property."},{"content":"If both match, that expression is evaluated and returned.","pos":[9448,9505]},{"content":"You would also expand the cases for taxis in a similar manner:","pos":[9507,9569]},{"pos":[9782,9856],"content":"In the preceding example, the <ph id=\"ph1\">`when`</ph> clause was omitted on the final case.","source":"In the preceding example, the `when` clause was omitted on the final case."},{"content":"Next, implement the occupancy rules by expanding the cases for buses, as shown in the following example:","pos":[9858,9962]},{"content":"The toll authority isn't concerned with the number of passengers in the delivery trucks.","pos":[10203,10291]},{"content":"Instead, they charge more based on the weight class of the trucks.","pos":[10292,10358]},{"content":"Trucks over 5000 lbs are charged an extra $5.00.","pos":[10359,10407]},{"content":"Light trucks under 3000 lbs are given a $2.00 discount.","pos":[10408,10463]},{"content":"That rule is implemented with the following code:","pos":[10464,10513]},{"content":"The preceding code shows the <ph id=\"ph1\">`when`</ph> clause of a switch arm.","pos":[10737,10796],"source":"The preceding code shows the `when` clause of a switch arm."},{"content":"You use the <ph id=\"ph1\">`when`</ph> clause to test conditions other than equality on a property.","pos":[10797,10876],"source":" You use the `when` clause to test conditions other than equality on a property."},{"content":"When you've finished, you'll have a method that looks much like the following:","pos":[10877,10955]},{"content":"Many of these switch arms are examples of <bpt id=\"p1\">**</bpt>recursive patterns<ept id=\"p1\">**</ept>.","pos":[11691,11756],"source":"Many of these switch arms are examples of **recursive patterns**."},{"content":"For example, <ph id=\"ph1\">`Car { Passengers: 1}`</ph> shows a constant pattern inside a property pattern.","pos":[11757,11844],"source":" For example, `Car { Passengers: 1}` shows a constant pattern inside a property pattern."},{"content":"You can make this code less repetitive by using nested switches.","pos":[11846,11910]},{"content":"The <ph id=\"ph1\">`Car`</ph> and <ph id=\"ph2\">`Taxi`</ph> both have four different arms in the preceding examples.","pos":[11911,11988],"source":" The `Car` and `Taxi` both have four different arms in the preceding examples."},{"content":"In both cases, you can create a type pattern that feeds into a property pattern.","pos":[11989,12069]},{"content":"This technique is shown in the following code:","pos":[12070,12116]},{"content":"In the preceding sample, using a recursive expression means you don't repeat the <ph id=\"ph1\">`Car`</ph> and <ph id=\"ph2\">`Taxi`</ph> arms containing child arms that test the property value.","pos":[13116,13270],"source":"In the preceding sample, using a recursive expression means you don't repeat the `Car` and `Taxi` arms containing child arms that test the property value."},{"content":"This technique isn't used for the <ph id=\"ph1\">`Bus`</ph> and <ph id=\"ph2\">`DeliveryTruck`</ph> arms because those arms are testing ranges for the property, not discrete values.","pos":[13271,13412],"source":" This technique isn't used for the `Bus` and `DeliveryTruck` arms because those arms are testing ranges for the property, not discrete values."},{"pos":[13417,13433],"content":"Add peak pricing","linkify":"Add peak pricing","nodes":[{"content":"Add peak pricing","pos":[0,16]}]},{"content":"For the final feature, the toll authority wants to add time sensitive peak pricing.","pos":[13435,13518]},{"content":"During the morning and evening rush hours, the tolls are doubled.","pos":[13519,13584]},{"content":"That rule only affects traffic in one direction: inbound to the city in the morning, and outbound in the evening rush hour.","pos":[13585,13708]},{"content":"During other times during the workday, tolls increase by 50%.","pos":[13709,13770]},{"content":"Late night and early morning, tolls are reduced by 25%.","pos":[13771,13826]},{"content":"During the weekend, it's the normal rate, regardless of the time.","pos":[13827,13892]},{"content":"You'll use pattern matching for this feature, but you'll integrate it with other techniques.","pos":[13894,13986]},{"content":"You could build a single pattern match expression that would account for all the combinations of direction, day of the week, and time.","pos":[13987,14121]},{"content":"The result would be a complicated expression.","pos":[14122,14167]},{"content":"It would be hard to read and difficult to understand.","pos":[14168,14221]},{"content":"That makes it hard to ensure correctness.","pos":[14222,14263]},{"content":"Instead, combine those methods to build a tuple of values that concisely describes all those states.","pos":[14264,14364]},{"content":"Then use pattern matching to calculate a multiplier for the toll.","pos":[14365,14430]},{"content":"The tuple contains three discrete conditions:","pos":[14431,14476]},{"content":"The day is either a weekday or a weekend.","pos":[14480,14521]},{"content":"The band of time when the toll is collected.","pos":[14524,14568]},{"content":"The direction is into the city or out of the city","pos":[14571,14620]},{"content":"The following table shows the combinations of input values and the peak pricing multiplier:","pos":[14622,14713]},{"content":"Day","pos":[14717,14720]},{"content":"Time","pos":[14730,14734]},{"content":"Direction","pos":[14745,14754]},{"content":"Premium","pos":[14757,14764]},{"content":"Weekday","pos":[14821,14828]},{"content":"morning rush","pos":[14834,14846]},{"content":"inbound","pos":[14849,14856]},{"content":"x 2.00","pos":[14861,14867]},{"content":"Weekday","pos":[14873,14880]},{"content":"morning rush","pos":[14886,14898]},{"content":"outbound","pos":[14901,14909]},{"content":"x 1.00","pos":[14913,14919]},{"content":"Weekday","pos":[14925,14932]},{"content":"daytime","pos":[14938,14945]},{"content":"inbound","pos":[14953,14960]},{"content":"x 1.50","pos":[14965,14971]},{"content":"Weekday","pos":[14977,14984]},{"content":"daytime","pos":[14990,14997]},{"content":"outbound","pos":[15005,15013]},{"content":"x 1.50","pos":[15017,15023]},{"content":"Weekday","pos":[15029,15036]},{"content":"evening rush","pos":[15042,15054]},{"content":"inbound","pos":[15057,15064]},{"content":"x 1.00","pos":[15069,15075]},{"content":"Weekday","pos":[15081,15088]},{"content":"evening rush","pos":[15094,15106]},{"content":"outbound","pos":[15109,15117]},{"content":"x 2.00","pos":[15121,15127]},{"content":"Weekday","pos":[15133,15140]},{"content":"overnight","pos":[15146,15155]},{"content":"inbound","pos":[15161,15168]},{"content":"x 0.75","pos":[15173,15179]},{"content":"Weekday","pos":[15185,15192]},{"content":"overnight","pos":[15198,15207]},{"content":"outbound","pos":[15213,15221]},{"content":"x 0.75","pos":[15225,15231]},{"content":"Weekend","pos":[15237,15244]},{"content":"morning rush","pos":[15250,15262]},{"content":"inbound","pos":[15265,15272]},{"content":"x 1.00","pos":[15277,15283]},{"content":"Weekend","pos":[15289,15296]},{"content":"morning rush","pos":[15302,15314]},{"content":"outbound","pos":[15317,15325]},{"content":"x 1.00","pos":[15329,15335]},{"content":"Weekend","pos":[15341,15348]},{"content":"daytime","pos":[15354,15361]},{"content":"inbound","pos":[15369,15376]},{"content":"x 1.00","pos":[15381,15387]},{"content":"Weekend","pos":[15393,15400]},{"content":"daytime","pos":[15406,15413]},{"content":"outbound","pos":[15421,15429]},{"content":"x 1.00","pos":[15433,15439]},{"content":"Weekend","pos":[15445,15452]},{"content":"evening rush","pos":[15458,15470]},{"content":"inbound","pos":[15473,15480]},{"content":"x 1.00","pos":[15485,15491]},{"content":"Weekend","pos":[15497,15504]},{"content":"evening rush","pos":[15510,15522]},{"content":"outbound","pos":[15525,15533]},{"content":"x 1.00","pos":[15537,15543]},{"content":"Weekend","pos":[15549,15556]},{"content":"overnight","pos":[15562,15571]},{"content":"inbound","pos":[15577,15584]},{"content":"x 1.00","pos":[15589,15595]},{"content":"Weekend","pos":[15601,15608]},{"content":"overnight","pos":[15614,15623]},{"content":"outbound","pos":[15629,15637]},{"content":"x 1.00","pos":[15641,15647]},{"content":"There are 16 different combinations of the three variables.","pos":[15652,15711]},{"content":"By combining some of the conditions, you'll simplify the final switch expression.","pos":[15712,15793]},{"content":"The system that collects the tolls uses a <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> structure for the time when the toll was collected.","pos":[15795,15911],"source":"The system that collects the tolls uses a <xref:System.DateTime> structure for the time when the toll was collected."},{"content":"Build member methods that create the variables from the preceding table.","pos":[15912,15984]},{"content":"The following function uses a pattern matching switch expression to express whether a <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> represents a weekend or a weekday:","pos":[15985,16128],"source":" The following function uses a pattern matching switch expression to express whether a <xref:System.DateTime> represents a weekend or a weekday:"},{"content":"That method works, but it's repetitious.","pos":[16504,16544]},{"content":"You can simplify it, as shown in the following code:","pos":[16545,16597]},{"content":"Next, add a similar function to categorize the time into the blocks:","pos":[16716,16784]},{"content":"The previous method doesn't use pattern matching.","pos":[16907,16956]},{"content":"It's clearer using a familiar cascade of <ph id=\"ph1\">`if`</ph> statements.","pos":[16957,17014],"source":" It's clearer using a familiar cascade of `if` statements."},{"content":"You do add a private <ph id=\"ph1\">`enum`</ph> to convert each range of time to a discrete value.","pos":[17015,17093],"source":" You do add a private `enum` to convert each range of time to a discrete value."},{"content":"After you create those methods, you can use another <ph id=\"ph1\">`switch`</ph> expression with the <bpt id=\"p1\">**</bpt>tuple pattern<ept id=\"p1\">**</ept> to calculate the pricing premium.","pos":[17095,17227],"source":"After you create those methods, you can use another `switch` expression with the **tuple pattern** to calculate the pricing premium."},{"content":"You could build a <ph id=\"ph1\">`switch`</ph> expression with all 16 arms:","pos":[17228,17283],"source":" You could build a `switch` expression with all 16 arms:"},{"content":"The above code works, but it can be simplified.","pos":[17415,17462]},{"content":"All eight combinations for the weekend have the same toll.","pos":[17463,17521]},{"content":"You can replace all eight with the following line:","pos":[17522,17572]},{"content":"Both inbound and outbound traffic have the same multiplier during the weekday daytime and overnight hours.","pos":[17612,17718]},{"content":"Those four switch arms can be replaced with the following two lines:","pos":[17719,17787]},{"content":"The code should look like the following code after those two changes:","pos":[17883,17952]},{"content":"Finally, you can remove the two rush hour times that pay the regular price.","pos":[18498,18573]},{"content":"Once you remove those arms, you can replace the <ph id=\"ph1\">`false`</ph> with a discard (<ph id=\"ph2\">`_`</ph>) in the final switch arm.","pos":[18574,18675],"source":" Once you remove those arms, you can replace the `false` with a discard (`_`) in the final switch arm."},{"content":"You'll have the following finished method:","pos":[18676,18718]},{"content":"This example highlights one of the advantages of pattern matching: the pattern branches are evaluated in order.","pos":[18865,18976]},{"content":"If you rearrange them so that an earlier branch handles one of your later cases, the compiler warns you about the unreachable code.","pos":[18977,19108]},{"content":"Those language rules made it easier to do the preceding simplifications with confidence that the code didn't change.","pos":[19109,19225]},{"content":"Pattern matching makes some types of code more readable and offers an alternative to object-oriented techniques when you can't add code to your classes.","pos":[19227,19379]},{"content":"The cloud is causing data and functionality to live apart.","pos":[19380,19438]},{"content":"The <bpt id=\"p1\">*</bpt>shape<ept id=\"p1\">*</ept> of the data and the <bpt id=\"p2\">*</bpt>operations<ept id=\"p2\">*</ept> on it aren't necessarily described together.","pos":[19439,19528],"source":" The *shape* of the data and the *operations* on it aren't necessarily described together."},{"content":"In this tutorial, you consumed existing data in entirely different ways from its original function.","pos":[19529,19628]},{"content":"Pattern matching gave you the ability to write functionality that overrode those types, even though you couldn't extend them.","pos":[19629,19754]},{"pos":[19759,19769],"content":"Next steps","linkify":"Next steps","nodes":[{"content":"Next steps","pos":[0,10]}]},{"content":"You can download the finished code from the <bpt id=\"p1\">[</bpt>dotnet/samples<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/finished)</ept> GitHub repository.","pos":[19771,19932],"source":"You can download the finished code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/finished) GitHub repository."},{"content":"Explore patterns on your own and add this technique into your regular coding activities.","pos":[19933,20021]},{"content":"Learning these techniques gives you another way to approach problems and create new functionality.","pos":[20022,20120]}]}