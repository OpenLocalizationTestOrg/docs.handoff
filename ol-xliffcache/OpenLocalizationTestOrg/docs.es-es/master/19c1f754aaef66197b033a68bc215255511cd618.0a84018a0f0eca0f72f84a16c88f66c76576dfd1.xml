{"content":"---\ntitle: \"Finalizers - C# Programming Guide\"\nms.custom: seodec18\nms.date: 10/08/2018\nhelpviewer_keywords: \n  - \"~ [C#], in finalizers\"\n  - \"C# language, finalizers\"\n  - \"finalizers [C#]\"\nms.assetid: 1ae6e46d-a4b1-4a49-abe5-b97f53d9e049\n---\n# Finalizers (C# Programming Guide)\nFinalizers (which are also called **destructors**) are used to perform any necessary final clean-up when a class instance is being collected by the garbage collector.  \n  \n## Remarks  \n  \n-   Finalizers cannot be defined in structs. They are only used with classes.  \n  \n-   A class can only have one finalizer.  \n  \n-   Finalizers cannot be inherited or overloaded.  \n  \n-   Finalizers cannot be called. They are invoked automatically.  \n  \n-   A finalizer does not take modifiers or have parameters.  \n  \n For example, the following is a declaration of a finalizer for the `Car` class.\n  \n [!code-csharp[csProgGuideObjects#86](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#86)]  \n\nA finalizer can also be implemented as an expression body definition, as the following example shows.\n\n[!code-csharp[expression-bodied-finalizer](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/expr-bodied-destructor.cs#1)]  \n  \n The finalizer implicitly calls <xref:System.Object.Finalize%2A> on the base class of the object. Therefore, a call to a finalizer is implicitly translated to the following code:  \n  \n```csharp  \nprotected override void Finalize()  \n{  \n    try  \n    {  \n        // Cleanup statements...  \n    }  \n    finally  \n    {  \n        base.Finalize();  \n    }  \n}  \n```  \n  \n This means that the `Finalize` method is called recursively for all instances in the inheritance chain, from the most-derived to the least-derived.  \n  \n> [!NOTE]\n>  Empty finalizers should not be used. When a class contains a finalizer, an entry is created in the `Finalize` queue. When the finalizer is called, the garbage collector is invoked to process the queue. An empty finalizer just causes a needless loss of performance.  \n  \n The programmer has no control over when the finalizer is called because this is determined by the garbage collector. The garbage collector checks for objects that are no longer being used by the application. If it considers an object eligible for finalization, it calls the finalizer (if any) and reclaims the memory used to store the object. \n \n In .NET Framework applications (but not in .NET Core applications), finalizers are also called when the program exits. \n  \n It is possible to force garbage collection by calling <xref:System.GC.Collect%2A>, but most of the time, this should be avoided because it may create performance issues.  \n  \n## Using finalizers to release resources  \n In general, C# does not require as much memory management as is needed when you develop with a language that does not target a runtime with garbage collection. This is because the .NET Framework garbage collector implicitly manages the allocation and release of memory for your objects. However, when your application encapsulates unmanaged resources such as windows, files, and network connections, you should use finalizers to free those resources. When the object is eligible for finalization, the garbage collector runs the `Finalize` method of the object.  \n  \n## Explicit release of resources  \n If your application is using an expensive external resource, we also recommend that you provide a way to explicitly release the resource before the garbage collector frees the object. You do this by implementing a `Dispose` method from the <xref:System.IDisposable> interface that performs the necessary cleanup for the object. This can considerably improve the performance of the application. Even with this explicit control over resources, the finalizer becomes a safeguard to clean up resources if the call to the `Dispose` method failed.  \n  \n For more details about cleaning up resources, see the following topics:  \n  \n-   [Cleaning Up Unmanaged Resources](../../../standard/garbage-collection/unmanaged.md)  \n  \n-   [Implementing a Dispose Method](../../../standard/garbage-collection/implementing-dispose.md)  \n  \n-   [using Statement](../../../csharp/language-reference/keywords/using-statement.md)  \n  \n## Example  \n The following example creates three classes that make a chain of inheritance. The class `First` is the base class, `Second` is derived from `First`, and `Third` is derived from `Second`. All three have finalizers. In `Main`, an instance of the most-derived class is created. When the program runs, notice that the finalizers for the three classes are called automatically, and in order, from the most-derived to the least-derived.  \n  \n [!code-csharp[csProgGuideObjects#85](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#85)]  \n  \n## C# language specification  \n\nFor more information, see the [Destructors](~/_csharplang/spec/classes.md#destructors) section of the [C# language specification](../../language-reference/language-specification/index.md).\n  \n## See also\n\n- <xref:System.IDisposable>\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Constructors](../../../csharp/programming-guide/classes-and-structs/constructors.md)\n- [Garbage Collection](../../../standard/garbage-collection/index.md)\n","nodes":[{"pos":[4,237],"embed":true,"restype":"x-metadata","content":"title: \"Finalizers - C# Programming Guide\"\nms.custom: seodec18\nms.date: 10/08/2018\nhelpviewer_keywords: \n  - \"~ [C#], in finalizers\"\n  - \"C# language, finalizers\"\n  - \"finalizers [C#]\"\nms.assetid: 1ae6e46d-a4b1-4a49-abe5-b97f53d9e049","nodes":[{"content":"Finalizers - C# Programming Guide","nodes":[{"pos":[0,33],"content":"Finalizers - C# Programming Guide","nodes":[{"content":"Finalizers - C# Programming Guide","pos":[0,33]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[244,277],"content":"Finalizers (C# Programming Guide)","linkify":"Finalizers (C# Programming Guide)","nodes":[{"content":"Finalizers (C# Programming Guide)","pos":[0,33]}]},{"pos":[278,444],"content":"Finalizers (which are also called <bpt id=\"p1\">**</bpt>destructors<ept id=\"p1\">**</ept>) are used to perform any necessary final clean-up when a class instance is being collected by the garbage collector.","source":"Finalizers (which are also called **destructors**) are used to perform any necessary final clean-up when a class instance is being collected by the garbage collector."},{"pos":[453,460],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Finalizers cannot be defined in structs.","pos":[470,510]},{"content":"They are only used with classes.","pos":[511,543]},{"content":"A class can only have one finalizer.","pos":[553,589]},{"content":"Finalizers cannot be inherited or overloaded.","pos":[599,644]},{"content":"Finalizers cannot be called.","pos":[654,682]},{"content":"They are invoked automatically.","pos":[683,714]},{"content":"A finalizer does not take modifiers or have parameters.","pos":[724,779]},{"pos":[786,865],"content":"For example, the following is a declaration of a finalizer for the <ph id=\"ph1\">`Car`</ph> class.","source":"For example, the following is a declaration of a finalizer for the `Car` class."},{"content":"A finalizer can also be implemented as an expression body definition, as the following example shows.","pos":[995,1096]},{"content":"The finalizer implicitly calls <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> on the base class of the object.","pos":[1251,1347],"source":"The finalizer implicitly calls <xref:System.Object.Finalize%2A> on the base class of the object."},{"content":"Therefore, a call to a finalizer is implicitly translated to the following code:","pos":[1348,1428]},{"pos":[1619,1766],"content":"This means that the <ph id=\"ph1\">`Finalize`</ph> method is called recursively for all instances in the inheritance chain, from the most-derived to the least-derived.","source":"This means that the `Finalize` method is called recursively for all instances in the inheritance chain, from the most-derived to the least-derived."},{"pos":[1774,2049],"content":"[!NOTE]\n Empty finalizers should not be used. When a class contains a finalizer, an entry is created in the `Finalize` queue. When the finalizer is called, the garbage collector is invoked to process the queue. An empty finalizer just causes a needless loss of performance.","leadings":["","> "],"nodes":[{"content":"Empty finalizers should not be used. When a class contains a finalizer, an entry is created in the `Finalize` queue. When the finalizer is called, the garbage collector is invoked to process the queue. An empty finalizer just causes a needless loss of performance.","pos":[9,273],"nodes":[{"content":"Empty finalizers should not be used.","pos":[0,36]},{"content":"When a class contains a finalizer, an entry is created in the <ph id=\"ph1\">`Finalize`</ph> queue.","pos":[37,116],"source":" When a class contains a finalizer, an entry is created in the `Finalize` queue."},{"content":"When the finalizer is called, the garbage collector is invoked to process the queue.","pos":[117,201]},{"content":"An empty finalizer just causes a needless loss of performance.","pos":[202,264]}]}]},{"content":"The programmer has no control over when the finalizer is called because this is determined by the garbage collector.","pos":[2056,2172]},{"content":"The garbage collector checks for objects that are no longer being used by the application.","pos":[2173,2263]},{"content":"If it considers an object eligible for finalization, it calls the finalizer (if any) and reclaims the memory used to store the object.","pos":[2264,2398]},{"content":"In .NET Framework applications (but not in .NET Core applications), finalizers are also called when the program exits.","pos":[2403,2521]},{"pos":[2527,2696],"content":"It is possible to force garbage collection by calling <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph>, but most of the time, this should be avoided because it may create performance issues.","source":"It is possible to force garbage collection by calling <xref:System.GC.Collect%2A>, but most of the time, this should be avoided because it may create performance issues."},{"pos":[2705,2742],"content":"Using finalizers to release resources","linkify":"Using finalizers to release resources","nodes":[{"content":"Using finalizers to release resources","pos":[0,37]}]},{"content":"In general, C# does not require as much memory management as is needed when you develop with a language that does not target a runtime with garbage collection.","pos":[2746,2905]},{"content":"This is because the .NET Framework garbage collector implicitly manages the allocation and release of memory for your objects.","pos":[2906,3032]},{"content":"However, when your application encapsulates unmanaged resources such as windows, files, and network connections, you should use finalizers to free those resources.","pos":[3033,3196]},{"content":"When the object is eligible for finalization, the garbage collector runs the <ph id=\"ph1\">`Finalize`</ph> method of the object.","pos":[3197,3306],"source":" When the object is eligible for finalization, the garbage collector runs the `Finalize` method of the object."},{"pos":[3315,3344],"content":"Explicit release of resources","linkify":"Explicit release of resources","nodes":[{"content":"Explicit release of resources","pos":[0,29]}]},{"content":"If your application is using an expensive external resource, we also recommend that you provide a way to explicitly release the resource before the garbage collector frees the object.","pos":[3348,3531]},{"content":"You do this by implementing a <ph id=\"ph1\">`Dispose`</ph> method from the <ph id=\"ph2\">&lt;xref:System.IDisposable&gt;</ph> interface that performs the necessary cleanup for the object.","pos":[3532,3675],"source":" You do this by implementing a `Dispose` method from the <xref:System.IDisposable> interface that performs the necessary cleanup for the object."},{"content":"This can considerably improve the performance of the application.","pos":[3676,3741]},{"content":"Even with this explicit control over resources, the finalizer becomes a safeguard to clean up resources if the call to the <ph id=\"ph1\">`Dispose`</ph> method failed.","pos":[3742,3889],"source":" Even with this explicit control over resources, the finalizer becomes a safeguard to clean up resources if the call to the `Dispose` method failed."},{"content":"For more details about cleaning up resources, see the following topics:","pos":[3896,3967]},{"pos":[3977,4061],"content":"<bpt id=\"p1\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](../../../standard/garbage-collection/unmanaged.md)</ept>","source":"[Cleaning Up Unmanaged Resources](../../../standard/garbage-collection/unmanaged.md)"},{"pos":[4071,4164],"content":"<bpt id=\"p1\">[</bpt>Implementing a Dispose Method<ept id=\"p1\">](../../../standard/garbage-collection/implementing-dispose.md)</ept>","source":"[Implementing a Dispose Method](../../../standard/garbage-collection/implementing-dispose.md)"},{"pos":[4174,4255],"content":"<bpt id=\"p1\">[</bpt>using Statement<ept id=\"p1\">](../../../csharp/language-reference/keywords/using-statement.md)</ept>","source":"[using Statement](../../../csharp/language-reference/keywords/using-statement.md)"},{"pos":[4264,4271],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example creates three classes that make a chain of inheritance.","pos":[4275,4352]},{"content":"The class <ph id=\"ph1\">`First`</ph> is the base class, <ph id=\"ph2\">`Second`</ph> is derived from <ph id=\"ph3\">`First`</ph>, and <ph id=\"ph4\">`Third`</ph> is derived from <ph id=\"ph5\">`Second`</ph>.","pos":[4353,4461],"source":" The class `First` is the base class, `Second` is derived from `First`, and `Third` is derived from `Second`."},{"content":"All three have finalizers.","pos":[4462,4488]},{"content":"In <ph id=\"ph1\">`Main`</ph>, an instance of the most-derived class is created.","pos":[4489,4549],"source":" In `Main`, an instance of the most-derived class is created."},{"content":"When the program runs, notice that the finalizers for the three classes are called automatically, and in order, from the most-derived to the least-derived.","pos":[4550,4705]},{"pos":[4842,4867],"content":"C# language specification","linkify":"C# language specification","nodes":[{"content":"C# language specification","pos":[0,25]}]},{"pos":[4871,5059],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Destructors<ept id=\"p1\">](~/_csharplang/spec/classes.md#destructors)</ept> section of the <bpt id=\"p2\">[</bpt>C# language specification<ept id=\"p2\">](../../language-reference/language-specification/index.md)</ept>.","source":"For more information, see the [Destructors](~/_csharplang/spec/classes.md#destructors) section of the [C# language specification](../../language-reference/language-specification/index.md)."},{"pos":[5066,5074],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5106,5172],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[5175,5260],"content":"<bpt id=\"p1\">[</bpt>Constructors<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/constructors.md)</ept>","source":"[Constructors](../../../csharp/programming-guide/classes-and-structs/constructors.md)"},{"pos":[5263,5330],"content":"<bpt id=\"p1\">[</bpt>Garbage Collection<ept id=\"p1\">](../../../standard/garbage-collection/index.md)</ept>","source":"[Garbage Collection](../../../standard/garbage-collection/index.md)"}]}