{"content":"---\ntitle: \"Snapshot Isolation in SQL Server\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176\n---\n# Snapshot Isolation in SQL Server\nSnapshot isolation enhances concurrency for OLTP applications.  \n  \n## Understanding Snapshot Isolation and Row Versioning  \n Once snapshot isolation is enabled, updated row versions for each transaction are maintained in **tempdb**. A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version. The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction. Newer row versions created after the transaction has begun are ignored by the transaction.  \n  \n The term \"snapshot\" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins. No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction. Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server. This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.  \n  \n Snapshot isolation uses an optimistic concurrency model. If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised. You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified. See \"Locking Hints\" in SQL Server Books Online for more information.  \n  \n Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions. This activates the mechanism for storing row versions in the temporary database (**tempdb**). You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement. In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration. The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:  \n  \n```sql  \nALTER DATABASE MyDatabase  \nSET ALLOW_SNAPSHOT_ISOLATION ON  \n  \nALTER DATABASE MyDatabase  \nSET READ_COMMITTED_SNAPSHOT ON  \n```  \n  \n Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level. If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.  \n  \n## Managing Concurrency with Isolation Levels  \n The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior. An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set. When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained. Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.  \n  \n Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection. Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.  \n  \n Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:  \n  \n-   READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions. Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called \"dirty\" reads.  \n  \n-   READ COMMITTED is the default isolation level for SQL Server. It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions. Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or \"phantom\" data.  \n  \n-   REPEATABLE READ is a more restrictive isolation level than READ COMMITTED. It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits. Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.  \n  \n-   SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete. It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.  \n  \n For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).  \n  \n### Snapshot Isolation Level Extensions  \n SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED. The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.  \n  \n-   SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions. The transaction uses the data row versions that exist when the transaction begins. No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data. Transactions that write data do not block snapshot transactions from reading data. You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.  \n  \n-   The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database. If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions. This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default). When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level. If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.  \n  \n## How Snapshot Isolation and Row Versioning Work  \n When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row. The following is the sequence of events that occurs:  \n  \n-   A new transaction is initiated, and it is assigned a transaction sequence number.  \n  \n-   The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.  \n  \n-   The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.  \n  \n-   The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction. It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.  \n  \n-   The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.  \n  \n The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables. This can result in performance improvements in situations where there is contention.  \n  \n A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows. If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.  \n  \n## Working with Snapshot Isolation in ADO.NET  \n Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class. If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method. This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.  \n  \n```vb  \nDim sqlTran As SqlTransaction = _  \n  connection.BeginTransaction(IsolationLevel.Snapshot)  \n```  \n  \n```csharp  \nSqlTransaction sqlTran =   \n  connection.BeginTransaction(IsolationLevel.Snapshot);  \n```  \n  \n### Example  \n The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.  \n  \n The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data. The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect. The code then performs the following actions:  \n  \n-   It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction. This has the effect of locking the table.  \n  \n-   It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table. Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.  \n  \n-   It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table. In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.  \n  \n-   It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1. This value may never actually exist in the database if the first transaction is not committed.  \n  \n-   It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.  \n  \n> [!NOTE]\n>  The following examples use the same connection string with connection pooling turned off. If a connection is pooled, resetting its isolation level does not reset the isolation level at the server. As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection. An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.  \n  \n [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]\n [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  \n  \n### Example  \n The following example demonstrates the behavior of snapshot isolation when data is being modified. The code performs the following actions:  \n  \n-   Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.  \n  \n-   Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.  \n  \n-   Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation. Three rows of data are selected in the transaction.  \n  \n-   Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.  \n  \n-   Commits sqlTransaction2.  \n  \n-   Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed. Error 3960 is raised, and sqlTransaction1 is rolled back automatically. The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.  \n  \n-   Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.  \n  \n [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]\n [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  \n  \n### Using Lock Hints with Snapshot Isolation  \n In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row. You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction. The following SELECT statement uses the UPDLOCK hint to lock the selected rows:  \n  \n```sql  \nSELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   \n  WHERE PriKey BETWEEN 1 AND 3  \n```  \n  \n Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes. This guarantees that the selected rows have no conflicts when they are updated later in the transaction. See \"Locking Hints\" in SQL Server Books Online.  \n  \n If your application has many conflicts, snapshot isolation may not be the best choice. Hints should only be used when really needed. Your application should not be designed so that it constantly relies on lock hints for its operation.  \n  \n## See also\n\n- [SQL Server and ADO.NET](../../../../../docs/framework/data/adonet/sql/index.md)\n- [ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)\n- [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)\n","nodes":[{"pos":[4,150],"embed":true,"restype":"x-metadata","content":"title: \"Snapshot Isolation in SQL Server\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176","nodes":[{"content":"Snapshot Isolation in SQL Server","nodes":[{"pos":[0,32],"content":"Snapshot Isolation in SQL Server","nodes":[{"content":"Snapshot Isolation in SQL Server","pos":[0,32]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[157,189],"content":"Snapshot Isolation in SQL Server","linkify":"Snapshot Isolation in SQL Server","nodes":[{"content":"Snapshot Isolation in SQL Server","pos":[0,32]}]},{"content":"Snapshot isolation enhances concurrency for OLTP applications.","pos":[190,252]},{"pos":[261,312],"content":"Understanding Snapshot Isolation and Row Versioning","linkify":"Understanding Snapshot Isolation and Row Versioning","nodes":[{"content":"Understanding Snapshot Isolation and Row Versioning","pos":[0,51]}]},{"content":"Once snapshot isolation is enabled, updated row versions for each transaction are maintained in <bpt id=\"p1\">**</bpt>tempdb<ept id=\"p1\">**</ept>.","pos":[316,423],"source":"Once snapshot isolation is enabled, updated row versions for each transaction are maintained in **tempdb**."},{"content":"A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.","pos":[424,549]},{"content":"The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.","pos":[550,677]},{"content":"Newer row versions created after the transaction has begun are ignored by the transaction.","pos":[678,768]},{"content":"The term \"snapshot\" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.","pos":[775,986]},{"content":"No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.","pos":[987,1179]},{"content":"Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.","pos":[1180,1413]},{"content":"This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.","pos":[1414,1521]},{"content":"Snapshot isolation uses an optimistic concurrency model.","pos":[1528,1584]},{"content":"If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.","pos":[1585,1757]},{"content":"You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.","pos":[1758,1854]},{"content":"See \"Locking Hints\" in SQL Server Books Online for more information.","pos":[1855,1923]},{"content":"Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.","pos":[1930,2058]},{"content":"This activates the mechanism for storing row versions in the temporary database (<bpt id=\"p1\">**</bpt>tempdb<ept id=\"p1\">**</ept>).","pos":[2059,2152],"source":" This activates the mechanism for storing row versions in the temporary database (**tempdb**)."},{"content":"You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.","pos":[2153,2265]},{"content":"In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.","pos":[2266,2451]},{"content":"The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:","pos":[2452,2567]},{"content":"Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.","pos":[2718,2845]},{"content":"If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.","pos":[2846,3003]},{"pos":[3012,3054],"content":"Managing Concurrency with Isolation Levels","linkify":"Managing Concurrency with Isolation Levels","nodes":[{"content":"Managing Concurrency with Isolation Levels","pos":[0,42]}]},{"content":"The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.","pos":[3058,3175]},{"content":"An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.","pos":[3176,3390]},{"content":"When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.","pos":[3391,3533]},{"content":"Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.","pos":[3534,3665]},{"content":"Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.","pos":[3672,3861]},{"content":"Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.","pos":[3862,4080]},{"content":"Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:","pos":[4087,4187]},{"content":"READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.","pos":[4197,4309]},{"content":"Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called \"dirty\" reads.","pos":[4310,4473]},{"content":"READ COMMITTED is the default isolation level for SQL Server.","pos":[4483,4544]},{"content":"It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.","pos":[4545,4691]},{"content":"Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or \"phantom\" data.","pos":[4692,4881]},{"content":"REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.","pos":[4891,4965]},{"content":"It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.","pos":[4966,5160]},{"content":"Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.","pos":[5161,5340]},{"content":"SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.","pos":[5350,5497]},{"content":"It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.","pos":[5498,5686]},{"pos":[5693,5858],"content":"For more information, refer to the <bpt id=\"p1\">[</bpt>Transaction Locking and Row Versioning Guide<ept id=\"p1\">](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)</ept>.","source":"For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)."},{"pos":[5868,5903],"content":"Snapshot Isolation Level Extensions","linkify":"Snapshot Isolation Level Extensions","nodes":[{"content":"Snapshot Isolation Level Extensions","pos":[0,35]}]},{"content":"SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.","pos":[5907,6076]},{"content":"The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.","pos":[6077,6183]},{"content":"SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.","pos":[6193,6325]},{"content":"The transaction uses the data row versions that exist when the transaction begins.","pos":[6326,6408]},{"content":"No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.","pos":[6409,6533]},{"content":"Transactions that write data do not block snapshot transactions from reading data.","pos":[6534,6616]},{"content":"You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.","pos":[6617,6730]},{"content":"The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.","pos":[6740,6903]},{"content":"If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.","pos":[6904,7020]},{"content":"This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).","pos":[7021,7106]},{"content":"When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.","pos":[7107,7231]},{"content":"If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.","pos":[7232,7416]},{"pos":[7425,7471],"content":"How Snapshot Isolation and Row Versioning Work","linkify":"How Snapshot Isolation and Row Versioning Work","nodes":[{"content":"How Snapshot Isolation and Row Versioning Work","pos":[0,46]}]},{"content":"When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in <bpt id=\"p1\">**</bpt>tempdb<ept id=\"p1\">**</ept>, and adds a transaction sequence number to the row.","pos":[7475,7679],"source":"When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row."},{"content":"The following is the sequence of events that occurs:","pos":[7680,7732]},{"content":"A new transaction is initiated, and it is assigned a transaction sequence number.","pos":[7742,7823]},{"pos":[7833,8019],"content":"The Database Engine reads a row within the transaction and retrieves the row version from <bpt id=\"p1\">**</bpt>tempdb<ept id=\"p1\">**</ept> whose sequence number is closest to, and lower than, the transaction sequence number.","source":"The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number."},{"content":"The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.","pos":[8029,8226]},{"content":"The transaction reads the version of the row from <bpt id=\"p1\">**</bpt>tempdb<ept id=\"p1\">**</ept> that was current as of the start of the transaction.","pos":[8236,8349],"source":"The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction."},{"content":"It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.","pos":[8350,8520]},{"pos":[8530,8700],"content":"The current transaction will see rows that were deleted after the transaction began, because there will be a row version in <bpt id=\"p1\">**</bpt>tempdb<ept id=\"p1\">**</ept> with a lower sequence number value.","source":"The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value."},{"content":"The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.","pos":[8707,8899]},{"content":"This can result in performance improvements in situations where there is contention.","pos":[8900,8984]},{"content":"A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.","pos":[8991,9137]},{"content":"If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.","pos":[9138,9303]},{"pos":[9312,9354],"content":"Working with Snapshot Isolation in ADO.NET","linkify":"Working with Snapshot Isolation in ADO.NET","nodes":[{"content":"Working with Snapshot Isolation in ADO.NET","pos":[0,42]}]},{"content":"Snapshot isolation is supported in ADO.NET by the <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlTransaction&gt;</ph> class.","pos":[9358,9458],"source":"Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class."},{"content":"If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlTransaction&gt;</ph> using the <bpt id=\"p1\">**</bpt>IsolationLevel.Snapshot<ept id=\"p1\">**</ept> enumeration value when calling the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A&gt;</ph> method.","pos":[9459,9774],"source":" If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method."},{"content":"This code fragment assumes that connection is an open <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlConnection&gt;</ph> object.","pos":[9775,9879],"source":" This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object."},{"pos":[10106,10113],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.","pos":[10117,10284]},{"content":"The code connects to the <bpt id=\"p1\">**</bpt>AdventureWorks<ept id=\"p1\">**</ept> sample database in SQL Server and creates a table named <bpt id=\"p2\">**</bpt>TestSnapshot<ept id=\"p2\">**</ept> and inserts one row of data.","pos":[10291,10436],"source":"The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data."},{"content":"The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.","pos":[10437,10667]},{"content":"The code then performs the following actions:","pos":[10668,10713]},{"content":"It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.","pos":[10723,10849]},{"content":"This has the effect of locking the table.","pos":[10850,10891]},{"content":"It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the <bpt id=\"p1\">**</bpt>TestSnapshot<ept id=\"p1\">**</ept> table.","pos":[10901,11047],"source":"It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table."},{"content":"Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.","pos":[11048,11166]},{"content":"It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.","pos":[11176,11314]},{"content":"In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.","pos":[11315,11647]},{"content":"It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.","pos":[11657,11830]},{"content":"This value may never actually exist in the database if the first transaction is not committed.","pos":[11831,11925]},{"pos":[11935,12095],"content":"It rolls back the first transaction and cleans up by deleting the <bpt id=\"p1\">**</bpt>TestSnapshot<ept id=\"p1\">**</ept> table and turning off snapshot isolation for the <bpt id=\"p2\">**</bpt>AdventureWorks<ept id=\"p2\">**</ept> database.","source":"It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database."},{"pos":[12103,12571],"content":"[!NOTE]\n The following examples use the same connection string with connection pooling turned off. If a connection is pooled, resetting its isolation level does not reset the isolation level at the server. As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection. An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.","leadings":["","> "],"nodes":[{"content":"The following examples use the same connection string with connection pooling turned off. If a connection is pooled, resetting its isolation level does not reset the isolation level at the server. As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection. An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.","pos":[9,466],"nodes":[{"content":"The following examples use the same connection string with connection pooling turned off.","pos":[0,89]},{"content":"If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.","pos":[90,196]},{"content":"As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.","pos":[197,346]},{"content":"An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.","pos":[347,457]}]}]},{"pos":[12907,12914],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example demonstrates the behavior of snapshot isolation when data is being modified.","pos":[12918,13016]},{"content":"The code performs the following actions:","pos":[13017,13057]},{"pos":[13067,13149],"content":"Connects to the <bpt id=\"p1\">**</bpt>AdventureWorks<ept id=\"p1\">**</ept> sample database and enables SNAPSHOT isolation.","source":"Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation."},{"pos":[13159,13242],"content":"Creates a table named <bpt id=\"p1\">**</bpt>TestSnapshotUpdate<ept id=\"p1\">**</ept> and inserts three rows of sample data.","source":"Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data."},{"content":"Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.","pos":[13252,13324]},{"content":"Three rows of data are selected in the transaction.","pos":[13325,13376]},{"pos":[13386,13585],"content":"Creates a second <bpt id=\"p1\">**</bpt>SqlConnection<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>AdventureWorks<ept id=\"p2\">**</ept> and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.","source":"Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1."},{"content":"Commits sqlTransaction2.","pos":[13595,13619]},{"content":"Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.","pos":[13629,13731]},{"content":"Error 3960 is raised, and sqlTransaction1 is rolled back automatically.","pos":[13732,13803]},{"content":"The <bpt id=\"p1\">**</bpt>SqlException.Number<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>SqlException.Message<ept id=\"p2\">**</ept> are displayed in the Console window.","pos":[13804,13897],"source":" The **SqlException.Number** and **SqlException.Message** are displayed in the Console window."},{"pos":[13907,14027],"content":"Executes clean-up code to turn off snapshot isolation in <bpt id=\"p1\">**</bpt>AdventureWorks<ept id=\"p1\">**</ept> and delete the <bpt id=\"p2\">**</bpt>TestSnapshotUpdate<ept id=\"p2\">**</ept> table.","source":"Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table."},{"pos":[14034,14377],"content":"[!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]\n[!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]","leadings":[""," "],"nodes":[]},{"pos":[14387,14427],"content":"Using Lock Hints with Snapshot Isolation","linkify":"Using Lock Hints with Snapshot Isolation","nodes":[{"content":"Using Lock Hints with Snapshot Isolation","pos":[0,40]}]},{"content":"In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.","pos":[14431,14667]},{"content":"You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.","pos":[14668,14812]},{"content":"The following SELECT statement uses the UPDLOCK hint to lock the selected rows:","pos":[14813,14892]},{"content":"Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.","pos":[15001,15114]},{"content":"This guarantees that the selected rows have no conflicts when they are updated later in the transaction.","pos":[15115,15219]},{"content":"See \"Locking Hints\" in SQL Server Books Online.","pos":[15220,15267]},{"content":"If your application has many conflicts, snapshot isolation may not be the best choice.","pos":[15274,15360]},{"content":"Hints should only be used when really needed.","pos":[15361,15406]},{"content":"Your application should not be designed so that it constantly relies on lock hints for its operation.","pos":[15407,15508]},{"pos":[15517,15525],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[15529,15609],"content":"<bpt id=\"p1\">[</bpt>SQL Server and ADO.NET<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/index.md)</ept>","source":"[SQL Server and ADO.NET](../../../../../docs/framework/data/adonet/sql/index.md)"},{"pos":[15612,15716],"content":"<bpt id=\"p1\">[</bpt>ADO.NET Managed Providers and DataSet Developer Center<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=217917)</ept>","source":"[ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)"},{"pos":[15719,15848],"content":"<bpt id=\"p1\">[</bpt>Transaction Locking and Row Versioning Guide<ept id=\"p1\">](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)</ept>","source":"[Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)"}]}