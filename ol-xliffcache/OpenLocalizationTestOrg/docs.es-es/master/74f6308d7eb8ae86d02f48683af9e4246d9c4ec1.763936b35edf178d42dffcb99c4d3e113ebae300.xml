{"content":"---\ntitle: \"Sharing Message Loops Between Win32 and WPF | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Win32 code, sharing message loops\"\n  - \"message loops [WPF]\"\n  - \"sharing message loops\"\n  - \"interoperability [WPF], Win32\"\nms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442\ncaps.latest.revision: 10\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Sharing Message Loops Between Win32 and WPF\nThis topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.  \n  \n## ComponentDispatcher and the Message Loop  \n A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>. However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries. To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.  \n  \n <xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members. The scope of each method is implicitly tied to the calling thread. A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).  \n  \n <xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for. The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence. If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.  \n  \n Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.  \n  \n## Writing Message Loops  \n The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event. <xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available. The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message. If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message. If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.  \n  \n## Using ComponentDispatcher and Existing Message Handling  \n The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed). <xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations. Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread). <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.  \n  \n-   <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.  \n  \n A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`. Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first. Event handlers to both events may modify the message. The dispatcher should dispatch the modified message and not the original unchanged message. <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.  \n  \n## How HwndSource Treats ComponentDispatcher Events  \n If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>. If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.  \n  \n If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling. Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.  \n  \n If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>. However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support. This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.  \n  \n A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method. The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.  \n  \n## See Also  \n <xref:System.Windows.Interop.ComponentDispatcher>   \n <xref:System.Windows.Interop.IKeyboardInputSink>   \n [WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)   \n [Threading Model](../../../../docs/framework/wpf/advanced/threading-model.md)   \n [Input Overview](../../../../docs/framework/wpf/advanced/input-overview.md)","nodes":[{"pos":[4,525],"embed":true,"restype":"x-metadata","content":"title: \"Sharing Message Loops Between Win32 and WPF | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Win32 code, sharing message loops\"\n  - \"message loops [WPF]\"\n  - \"sharing message loops\"\n  - \"interoperability [WPF], Win32\"\nms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442\ncaps.latest.revision: 10\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","nodes":[{"content":"Sharing Message Loops Between Win32 and WPF | Microsoft Docs","nodes":[{"pos":[0,60],"content":"Sharing Message Loops Between Win32 and WPF | Microsoft Docs","nodes":[{"content":"Sharing Message Loops Between Win32 and WPF | Microsoft Docs","pos":[0,60]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[532,575],"content":"Sharing Message Loops Between Win32 and WPF","linkify":"Sharing Message Loops Between Win32 and WPF","nodes":[{"content":"Sharing Message Loops Between Win32 and WPF","pos":[0,43]}]},{"pos":[576,978],"content":"This topic describes how to implement a message loop for interoperation with <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph>, either by using existing message loop exposure in <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> or by creating a separate message loop on the <ph id=\"ph3\">[!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)]</ph> side of your interoperation code.","source":"This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code."},{"pos":[987,1027],"content":"ComponentDispatcher and the Message Loop","linkify":"ComponentDispatcher and the Message Loop","nodes":[{"content":"ComponentDispatcher and the Message Loop","pos":[0,40]}]},{"content":"A normal scenario for interoperation and keyboard event support is to implement <ph id=\"ph1\">&lt;xref:System.Windows.Interop.IKeyboardInputSink&gt;</ph>, or to subclass from classes that already implement <ph id=\"ph2\">&lt;xref:System.Windows.Interop.IKeyboardInputSink&gt;</ph>, such as <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>.","pos":[1031,1353],"source":"A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>."},{"content":"However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.","pos":[1354,1523]},{"content":"To help formalize an application message loop architecture, <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> provides the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> class, which defines a simple protocol for a message loop to follow.","pos":[1524,1795],"source":" To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> is a static class that exposes several members.","pos":[1802,1899],"source":"<xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members."},{"content":"The scope of each method is implicitly tied to the calling thread.","pos":[1900,1966]},{"content":"A message loop must call some of those <ph id=\"ph1\">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph> at critical times (as defined in the next section).","pos":[1967,2145],"source":" A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section)."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> provides events that other components (such as the keyboard sink) can listen for.","pos":[2152,2283],"source":"<xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> class calls all the appropriate <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> methods in an appropriate sequence.","pos":[2284,2448],"source":" The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence."},{"content":"If you are implementing your own message loop, your code is responsible for calling <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> methods in a similar fashion.","pos":[2449,2612],"source":" If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion."},{"pos":[2619,2765],"content":"Calling <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> methods on a thread will only invoke event handlers that were registered on that thread.","source":"Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread."},{"pos":[2774,2795],"content":"Writing Message Loops","linkify":"Writing Message Loops","nodes":[{"content":"Writing Message Loops","pos":[0,21]}]},{"pos":[2799,2937],"content":"The following is a checklist of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> members you will use if you write your own message loop:","source":"The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:"},{"pos":[2947,3083],"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A&gt;</ph>: your message loop should call this to indicate that the thread is modal.","source":"<xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal."},{"pos":[3093,3243],"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A&gt;</ph>:your message loop should call this to indicate that the thread has reverted to nonmodal.","source":"<xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A&gt;</ph>: your message loop should call this to indicate that <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> should raise the <ph id=\"ph3\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle&gt;</ph> event.","pos":[3253,3503],"source":"<xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> will not raise <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle&gt;</ph> if <ph id=\"ph3\">&lt;xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A&gt;</ph> is <ph id=\"ph4\">`true`</ph>, but message loops may choose to call <ph id=\"ph5\">&lt;xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A&gt;</ph> even if <ph id=\"ph6\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> cannot respond to it while in modal state.","pos":[3504,3911],"source":"<xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A&gt;</ph>: your message loop should call this to indicate that a new message is available.","pos":[3921,4073],"source":"<xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available."},{"content":"The return value indicates whether a listener to a <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> event handled the message.","pos":[4074,4201],"source":" The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message."},{"content":"If <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A&gt;</ph> returns <ph id=\"ph2\">`true`</ph> (handled), the dispatcher should do nothing further with the message.","pos":[4202,4361],"source":" If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message."},{"content":"If the return value is <ph id=\"ph1\">`false`</ph>, the dispatcher is expected to call the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> function <ph id=\"ph3\">`TranslateMessage`</ph>, then call <ph id=\"ph4\">`DispatchMessage`</ph>.","pos":[4362,4564],"source":" If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`."},{"pos":[4573,4628],"content":"Using ComponentDispatcher and Existing Message Handling","linkify":"Using ComponentDispatcher and Existing Message Handling","nodes":[{"content":"Using ComponentDispatcher and Existing Message Handling","pos":[0,55]}]},{"pos":[4632,4858],"content":"The following is a checklist of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> members you will use if you rely on the inherent <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> message loop.","source":"The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A&gt;</ph>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).","pos":[4868,5028],"source":"<xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed)."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph> can track this state because the class maintains a count of <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A&gt;</ph> calls from the message loop.","pos":[5029,5296],"source":"<xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage&gt;</ph> events follow the standard rules for delegate invocations.","pos":[5306,5512],"source":"<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations."},{"content":"Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.","pos":[5513,5641]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle&gt;</ph>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).","pos":[5651,5832],"source":"<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread)."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle&gt;</ph> will not be raised if the thread is modal.","pos":[5833,5936],"source":"<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal."},{"pos":[5946,6073],"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage&gt;</ph>: raised for all messages that the message pump processes.","source":"<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes."},{"pos":[6083,6281],"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage&gt;</ph>: raised for all messages that were not handled during <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage&gt;</ph>.","source":"<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>."},{"content":"A message is considered handled if after the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage&gt;</ph> event or <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage&gt;</ph> event, the <ph id=\"ph3\">`handled`</ph> parameter passed by reference in event data is <ph id=\"ph4\">`true`</ph>.","pos":[6288,6561],"source":"A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`."},{"content":"Event handlers should ignore the message if <ph id=\"ph1\">`handled`</ph> is <ph id=\"ph2\">`true`</ph>, because that means the different handler handled the message first.","pos":[6562,6694],"source":" Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first."},{"content":"Event handlers to both events may modify the message.","pos":[6695,6748]},{"content":"The dispatcher should dispatch the modified message and not the original unchanged message.","pos":[6749,6840]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage&gt;</ph> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.","pos":[6841,7109],"source":"<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message."},{"pos":[7118,7166],"content":"How HwndSource Treats ComponentDispatcher Events","linkify":"How HwndSource Treats ComponentDispatcher Events","nodes":[{"content":"How HwndSource Treats ComponentDispatcher Events","pos":[0,48]}]},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> is a top-level window (no parent HWND), it will register with <ph id=\"ph2\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph>.","pos":[7170,7330],"source":"If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>."},{"content":"If <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage&gt;</ph> is raised, and if the message is intended for the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> or child windows, <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> calls its <ph id=\"ph4\">&lt;xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A&gt;</ph> keyboard sink sequence.","pos":[7331,7837],"source":" If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> is not a top-level window (has a parent HWND), there will be no handling.","pos":[7844,7965],"source":"If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling."},{"content":"Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.","pos":[7966,8137]},{"content":"If <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost.WndProc%2A&gt;</ph> on an <ph id=\"ph2\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <ph id=\"ph3\">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph>.","pos":[8144,8429],"source":"If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>."},{"content":"However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.","pos":[8430,8565]},{"content":"This might happen because the message loop did not properly notify the relevant thread on the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.ComponentDispatcher&gt;</ph>, or because the parent HWND did not invoke the proper keyboard sink responses.","pos":[8566,8788],"source":" This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses."},{"content":"A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource.AddHook%2A&gt;</ph> method.","pos":[8795,8974],"source":"A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method."},{"content":"The message might have been handled at the message pump level directly and not submitted to the <ph id=\"ph1\">`DispatchMessage`</ph> function.","pos":[8975,9098],"source":" The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function."},{"pos":[9107,9115],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>WPF and Win32 Interoperation<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)</ept><ph id=\"ph1\"> </ph>","pos":[9226,9330],"source":"[WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) "},{"content":"<bpt id=\"p1\">[</bpt>Threading Model<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/threading-model.md)</ept><ph id=\"ph1\"> </ph>","pos":[9334,9412],"source":"[Threading Model](../../../../docs/framework/wpf/advanced/threading-model.md) "},{"content":"<bpt id=\"p1\">[</bpt>Input Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/input-overview.md)</ept>","pos":[9416,9491],"source":"[Input Overview](../../../../docs/framework/wpf/advanced/input-overview.md)"}]}