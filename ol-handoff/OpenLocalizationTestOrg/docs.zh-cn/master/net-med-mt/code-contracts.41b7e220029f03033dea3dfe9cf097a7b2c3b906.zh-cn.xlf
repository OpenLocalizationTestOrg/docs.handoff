<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">52a7d383fc6833c6e069cf57084bdb4c056adef5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\debug-trace-profile\code-contracts.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ceff3dd20865bc478579383f83289060cebec71</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">364e123ef2d67b5b094a11b19d4ad33813eeca90</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Code Contracts | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Code Contracts</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Preconditions are requirements that must be met when entering a method or property.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Postconditions describe expectations at the time the method or property code exits.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Object invariants describe the expected state for a class that is in a good state.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The classes for code contracts can be found in the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The benefits of code contracts include the following:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Static verification: The static checker can decide whether there are any contract violations without running the program.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Reference documentation: The documentation generator augments existing XML documentation files with contract information.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>There are also style sheets that can be used with <bpt id="p1">[</bpt>Sandcastle<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=169253)</ept> so that the generated documentation pages have contract sections.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the <ph id="ph1">`#define`</ph> directive.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>CONTRACTS_FULL lets you write contracts in your code without using <ph id="ph1">`#ifdef`</ph> directives; you can produce different builds, some with contracts, and some without.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For tools and detailed instructions for using code contracts, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Preconditions</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You can express preconditions by using the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Preconditions specify state when a method is invoked.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>They are generally used to specify valid parameter values.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The condition must have no side-effects.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The run-time behavior of failed preconditions is determined by the runtime analyzer.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For example, the following precondition expresses that parameter <ph id="ph1">`x`</ph> must be non-null.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> as follows.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Legacy Requires Statements</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Most code contains some parameter validation in the form of <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> code.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The contract tools recognize these statements as preconditions in the following cases:</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The statements appear before any other statements in a method.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The entire set of such statements is followed by an explicit <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> method call, such as a call to the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> statements appear in this form, the tools recognize them as legacy <ph id="ph6">`requires`</ph> statements.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If no other contracts follow the <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> sequence, end the code with the <ph id="ph6">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Note that the condition in the preceding test is a negated precondition.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>(The actual precondition would be <ph id="ph1">`x != null`</ph>.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no <ph id="ph2">`else`</ph> clauses, and the body of the <ph id="ph3">`then`</ph> clause must be a single <ph id="ph4">`throw`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`if`</ph> test is subject to both purity and visibility rules (see <bpt id="p1">[</bpt>Usage Guidelines<ept id="p1">](#usage_guidelines)</ept>), but the <ph id="ph2">`throw`</ph> expression is subject only to purity rules.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>However, the type of the exception thrown must be as visible as the method in which the contract occurs.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Postconditions</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Postconditions are contracts for the state of a method when it terminates.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The postcondition is checked just before exiting a method.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The run-time behavior of failed postconditions is determined by the runtime analyzer.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Unlike preconditions, postconditions may reference members with less visibility.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Standard Postconditions</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can express standard postconditions by using the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Postconditions express a condition that must be <ph id="ph1">`true`</ph> upon normal termination of the method.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Exceptional Postconditions</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Exceptional postconditions are postconditions that should be <ph id="ph1">`true`</ph> when a particular exception is thrown by a method.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can specify these postconditions by using the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=fullName&gt;</ph> method, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The argument is the condition that must be <ph id="ph1">`true`</ph> whenever an exception that is a subtype of <ph id="ph2">`T`</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>There are some exception types that are difficult to use in an exceptional postcondition.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, using the type <ph id="ph1">&lt;xref:System.Exception&gt;</ph> for <ph id="ph2">`T`</ph> requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <ph id="ph1">&lt;xref:System.InvalidTimeZoneException&gt;</ph> is thrown for a <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> method call.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Special Postconditions</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following methods may be used only within postconditions:</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can refer to method return values in postconditions by using the expression <ph id="ph1">`Contract. Result&lt;T&gt;()`</ph>, where <ph id="ph2">`T`</ph> is replaced by the return type of the method.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>When the compiler is unable to infer the type, you must explicitly provide it.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: <ph id="ph1">`Contract.Ensures(0 &lt; Contract.Result&lt;int&gt;())`</ph> Methods with a return type of <ph id="ph2">`void`</ph> cannot refer to <ph id="ph3">`Contract. Result&lt;T&gt;()`</ph> in their postconditions.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It uses the expression <ph id="ph1">`Contract.OldValue&lt;T&gt;(e)`</ph>, where <ph id="ph2">`T`</ph> is the type of <ph id="ph3">`e`</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You can omit the generic type argument whenever the compiler is able to infer its type.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in <ph id="ph1">`e`</ph> and the contexts in which an old expression may appear.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>An old expression cannot contain another old expression.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Most importantly, an old expression must refer to a value that existed in the method's precondition state.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In other words, it must be an expression that can be evaluated as long as the method's precondition is <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Here are several instances of that rule.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The value must exist in the method's precondition state.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In order to reference a field on an object, the preconditions must guarantee that that object is always non-null.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You cannot refer to the method's return value in an old expression:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You cannot refer to <ph id="ph1">`out`</ph> parameters in an old expression.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>An old expression cannot refer to the parameter of the anonymous delegate in a <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.Exists%2A&gt;</ph> call unless it is used as an indexer or argument to a method call:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.Exists%2A&gt;</ph> method:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Out`</ph> parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to <ph id="ph2">`out`</ph> parameters in postconditions.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>To solve this problem, the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> class provides the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> method, which allows a postcondition based on an <ph id="ph3">`out`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>As with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The contract rewriter replaces the method call with the value of the <ph id="ph1">`out`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> method may appear only in postconditions.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The argument to the method must be an <ph id="ph1">`out`</ph> parameter or a field of a structure <ph id="ph2">`out`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The latter is also useful when referring to fields in the postcondition of a structure constructor.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Currently, the code contract analysis tools do not check whether <ph id="ph1">`out`</ph> parameters are initialized properly and disregard their mention in the postcondition.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Therefore, in the previous example, if the line after the contract had used the value of <ph id="ph1">`x`</ph> instead of assigning an integer to it, a compiler would not issue the correct error.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Invariants</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>They express the conditions under which the object is considered to be correct.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The invariant methods are identified by being marked with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The invariant methods must contain no code except for a sequence of calls to the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> method, each of which specifies an individual invariant, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>During run-time checking, invariants are checked at the end of each public method.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Instead, the check occurs only at the end of the outermost method call to that class.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This also happens if the class is re-entered because of a call to a method on another class.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Invariants are not checked for object finalizers or for any methods that implement the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Usage Guidelines</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Contract Ordering</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following table shows the order of elements you should use when you write method contracts.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Backward-compatible public preconditions</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>All public preconditions.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>All public (normal) postconditions.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>All public exceptional postconditions.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>All private/internal (normal) postconditions.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>All private/internal exceptional postconditions.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If using <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> style preconditions without any other contracts, place a call to <ph id="ph6">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> to indicate that all previous if checks are preconditions.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Purity</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>A pure method is allowed to modify objects that have been created after entry into the pure method.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Code contract tools currently assume that the following code elements are pure:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Methods that are marked with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.PureAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Types that are marked with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.PureAttribute&gt;</ph> (the attribute applies to all the type's methods).</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Property get accessors.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Any invoked delegate, provided that the delegate type itself is attributed with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.PureAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The delegate types <ph id="ph1">&lt;xref:System.Predicate%601?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Comparison%601?displayProperty=fullName&gt;</ph> are considered pure.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Visibility</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>All members mentioned in a contract must be at least as visible as the method in which they appear.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>However, if the field is marked with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute&gt;</ph>, it is exempt from these rules.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following example shows the use of code contracts.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ContractExample#1<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>ContractExample#1<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>