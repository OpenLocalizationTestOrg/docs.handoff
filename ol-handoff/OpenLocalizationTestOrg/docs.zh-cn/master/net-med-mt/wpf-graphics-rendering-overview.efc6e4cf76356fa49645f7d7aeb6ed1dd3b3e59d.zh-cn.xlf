<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dae53c34ba8175a55b2520740e8fe855396f2dcd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\graphics-multimedia\wpf-graphics-rendering-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2286b9b14d65a52efb5ebc3626e0f7bec7655e3f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3e8759b78aa5a15286e587e69950d86427a568d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>WPF Graphics Rendering Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>WPF Graphics Rendering Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic provides an overview of the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> visual layer.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It focuses on the role of the <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> class for rendering support in the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> model.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Role of the Visual Object</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> class is the basic abstraction from which every <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> object derives.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It also serves as the entry point for writing new controls in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, and in many ways can be thought of as the window handle (HWND) in the Win32 application model.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> object is a core <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> object, whose primary role is to provide rendering support.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>User interface controls, such as <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>, derive from the <ph id="ph3">&lt;xref:System.Windows.Media.Visual&gt;</ph> class, and use it for persisting their rendering data.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> object provides support for:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Output display: Rendering the persisted, serialized drawing content of a visual.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Transformations: Performing transformations on a visual.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Clipping: Providing clipping region support for a visual.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Hit testing: Determining whether a coordinate or geometry is contained within the bounds of a visual.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Bounding box calculations: Determining the bounding rectangle of a visual.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> object does not include support for non-rendering features, such as:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Event handling</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Layout</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Styles</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Data binding</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Globalization</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> is exposed as a public abstract class from which child classes must be derived.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following illustration shows the hierarchy of the visual objects that are exposed in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of classes derived from the Visual object<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visualclass01.png "VisualClass01")</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Visual class hierarchy</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>DrawingVisual Class</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> is a lightweight drawing class that is used to render shapes, images, or text.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This class is considered lightweight because it does not provide layout or event handling, which improves its runtime performance.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For this reason, drawings are ideal for backgrounds and clip art.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> can be used to create a custom visual object.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Using DrawingVisual Objects<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Viewport3DVisual Class</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual&gt;</ph> provides a bridge between 2D <ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Media.Media3D.Visual3D&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.Media3D.Visual3D&gt;</ph> class is the base class for all 3D visual elements.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual&gt;</ph> requires that you define a <ph id="ph2">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A&gt;</ph> value and a <ph id="ph3">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The camera allows you to view the scene.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The viewport establishes where the projection maps onto the 2D surface.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For more information on 3D in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, see <bpt id="p1">[</bpt>3-D Graphics Overview<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/3-d-graphics-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>ContainerVisual Class</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.ContainerVisual&gt;</ph> class is used as a container for a collection of <ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> class derives from the <ph id="ph2">&lt;xref:System.Windows.Media.ContainerVisual&gt;</ph> class, allowing it to contain a collection of visual objects.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Drawing Content in Visual Objects</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> object stores its render data as a <bpt id="p1">**</bpt>vector graphics instruction list<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Each item in the instruction list represents a low-level set of graphics data and associated resources in a serialized format.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>There are four different types of render data that can contain drawing content.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Drawing content type</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Vector graphics</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Represents vector graphics data, and any associated <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Media.Pen&gt;</ph> information.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Image</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Represents an image within a region defined by a <ph id="ph1">&lt;xref:System.Windows.Rect&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Glyph</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Represents a drawing that renders a <ph id="ph1">&lt;xref:System.Windows.Media.GlyphRun&gt;</ph>, which is a sequence of glyphs from a specified font resource.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This is how text is represented.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Video</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Represents a drawing that renders video.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> allows you to populate a <ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph> with visual content.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When you use a <ph id="ph1">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> object's draw commands, you are actually storing a set of render data that will later be used by the graphics system; you are not drawing to the screen in real-time.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When you create a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> control, such as a <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>, the control implicitly generates render data for drawing itself.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, setting the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> causes the control to store a rendering representation of a glyph.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> describes its content as one or more <ph id="ph2">&lt;xref:System.Windows.Media.Drawing&gt;</ph> objects contained within a <ph id="ph3">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> also describes opacity masks, transforms, bitmap effects, and other operations that are applied to its contents.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> operations are applied in the following order when content is rendered: <ph id="ph2">&lt;xref:System.Windows.Media.DrawingGroup.OpacityMask%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.DrawingGroup.Opacity%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A&gt;</ph>, and then <ph id="ph7">&lt;xref:System.Windows.Media.DrawingGroup.Transform%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following illustration shows the order in which <ph id="ph1">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> operations are applied during the rendering sequence.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>DrawingGroup order of operations<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/graphcismm-drawinggroup-order.png "graphcismm_drawinggroup_order")</ept></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Order of DrawingGroup operations</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Drawing Objects Overview<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/drawing-objects-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Drawing Content at the Visual Layer</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You never directly instantiate a <ph id="ph1">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph>; you can, however, acquire a drawing context from certain methods, such as <ph id="ph2">&lt;xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following example retrieves a <ph id="ph1">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> from a <ph id="ph2">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> and uses it to draw a rectangle.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>drawingvisualsample#101<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>drawingvisualsample#101<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Enumerating Drawing Content at the Visual Layer</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In addition to their other uses, <ph id="ph1">&lt;xref:System.Windows.Media.Drawing&gt;</ph> objects also provide an object model for enumerating the contents of a <ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>When you are enumerating the contents of the visual, you are retrieving <ph id="ph1">&lt;xref:System.Windows.Media.Drawing&gt;</ph> objects, and not the underlying representation of the render data as a vector graphics instruction list.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A&gt;</ph> method to retrieve the <ph id="ph2">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> value of a <ph id="ph3">&lt;xref:System.Windows.Media.Visual&gt;</ph> and enumerate it.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>DrawingMiscSnippets_snip#GraphicsMMRetrieveDrawings<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DrawingMiscSnippets_snip/CSharp/EnumerateDrawingsExample.xaml.cs#graphicsmmretrievedrawings)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>How Visual Objects are Used to Build Controls</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Many of the objects in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> are composed of other visual objects, meaning they can contain varying hierarchies of descendant objects.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Many of the user interface elements in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, such as controls, are composed of multiple visual objects, representing different types of rendering elements.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control can contain a number of other objects, including <ph id="ph2">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph>, and <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The following code shows a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control defined in markup.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VisualsOverview#VisualsOverviewSnippet1<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If you were to enumerate the visual objects that comprise the default <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control, you would find the hierarchy of visual objects illustrated below:</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of visual tree hierarchy<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visuallayeroverview03.gif "VisualLayerOverview03")</ept></source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Diagram of visual tree hierarchy</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control contains a <ph id="ph2">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element, which in turn, contains a <ph id="ph3">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element is responsible for drawing a border and a background for the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element is responsible for displaying the contents of the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In this case, since you are displaying text, the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element contains a <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> element.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The fact that the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control uses a <ph id="ph2">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> means that the content could be represented by other elements, such as an <ph id="ph3">&lt;xref:System.Windows.Controls.Image&gt;</ph> or a geometry, such as an <ph id="ph4">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Control Templates</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The key to the expansion of a control into a hierarchy of controls is the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A control template specifies the default visual hierarchy for a control.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>When you explicitly reference a control, you implicitly reference its visual hierarchy.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can override the default values for a control template to create a customized visual appearance for a control.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, you could modify the background color value of the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control so that it uses a linear gradient color value instead of a solid color value.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Button Styles and Templates<ept id="p1">](../../../../docs/framework/wpf/controls/button-styles-and-templates.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>A user interface element, such as a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control, contains several vector graphics instruction lists that describe the entire rendering definition of a control.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The following code shows a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control defined in markup.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VisualsOverview#VisualsOverviewSnippet2<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If you were to enumerate the visual objects and vector graphics instruction lists that comprise the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control, you would find the hierarchy of objects illustrated below:</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of visual tree and rendering data<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visuallayeroverview04.png "VisualLayerOverview04")</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Diagram of visual tree and rendering data</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control contains a <ph id="ph2">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element, which in turn, contains a <ph id="ph3">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element is responsible for drawing all the discrete graphic elements that make up the border and background of a button.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element is responsible for displaying the contents of the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In this case, since you are displaying an image, the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element contains a <ph id="ph2">&lt;xref:System.Windows.Controls.Image&gt;</ph> element.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>There are a number of points to note about the hierarchy of visual objects and vector graphics instruction lists:</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The ordering in the hierarchy represents the rendering order of the drawing information.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>From the root visual element, child elements are traversed, left to right, top to bottom.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If an element has visual child elements, they are traversed before the element’s siblings.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Non-leaf node elements in the hierarchy, such as <ph id="ph1">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph>, are used to contain child elements—they do not contain instruction lists.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If a visual element contains both a vector graphics instruction list and visual children, the instruction list in the parent visual element is rendered before drawings in any of the visual child objects.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The items in the vector graphics instruction list are rendered left to right.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Visual Tree</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The visual tree contains all visual elements used in an application's user interface.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Since a visual element contains persisted drawing information, you can think of the visual tree as a scene graph, containing all the rendering information needed to compose the output to the display device.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This tree is the accumulation of all visual elements created directly by the application, whether in code or in markup.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The visual tree also contains all visual elements created by the template expansion of elements such as controls and data objects.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following code shows a <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> element defined in markup.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VisualsOverview#VisualsOverviewSnippet3<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If you were to enumerate the visual objects that comprise the <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> element in the markup example, you would find the hierarchy of visual objects illustrated below:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of visual tree hierarchy<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visuallayeroverview05.gif "VisualLayerOverview05")</ept></source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Diagram of visual tree hierarchy</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Rendering Order</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The visual tree determines the rendering order of <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> visual and drawing objects.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The order of traversal starts with the root visual, which is the top-most node in the visual tree.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The root visual’s children are then traversed, left to right.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>If a visual has children, its children are traversed before the visual’s siblings.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>This means that the content of a child visual is rendered in front of the visual's own content.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of visual tree rendering order<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visuallayeroverview06.gif "VisualLayerOverview06")</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Diagram of visual tree rendering order</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Root Visual</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>root visual<ept id="p1">**</ept> is the top-most element in a visual tree hierarchy.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In most applications, the base class of the root visual is either <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Navigation.NavigationWindow&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>However, if you were hosting visual objects in a Win32 application, the root visual would be the top-most visual you were hosting in the Win32 window.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Tutorial: Hosting Visual Objects in a Win32 Application<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/tutorial-hosting-visual-objects-in-a-win32-application.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Relationship to the Logical Tree</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The logical tree in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> represents the elements of an application at run time.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Although you do not manipulate this tree directly, this view of the application is useful for understanding property inheritance and event routing.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Unlike the visual tree, the logical tree can represent non-visual data objects, such as <ph id="ph1">&lt;xref:System.Windows.Documents.ListItem&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>In many cases, the logical tree maps very closely to an application's markup definitions.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The following code shows a <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> element defined in markup.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VisualsOverview#VisualsOverviewSnippet5<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If you were to enumerate the logical objects that comprise the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> element in the markup example, you would find the hierarchy of logical objects illustrated below:</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Tree diagram<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/tree1-wcp.gif "Tree1_wcp")</ept></source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Diagram of logical tree</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Both the visual tree and logical tree are synchronized with the current set of application elements, reflecting any addition, deletion, or modification of elements.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>However, the trees present different views of the application.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Unlike the visual tree, the logical tree does not expand a control's <ph id="ph1">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This means there is not a direct one-to-one correspondence between a logical tree and a visual tree for the same set of objects.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>In fact, invoking the <bpt id="p1">**</bpt>LogicalTreeHelper<ept id="p1">**</ept> object's <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.GetChildren%2A&gt;</ph> method and the <bpt id="p2">**</bpt>VisualTreeHelper<ept id="p2">**</ept> object's <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper.GetChild%2A&gt;</ph> method using the same element as a parameter yields differing results.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>For more information on the logical tree, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Viewing the Visual Tree with XamlPad</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> tool, XamlPad, provides an option for viewing and exploring the visual tree that corresponds to the currently defined <ph id="ph2">[!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)]</ph> content.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Click the <bpt id="p1">**</bpt>Show Visual Tree<ept id="p1">**</ept> button on the menu bar to display the visual tree.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following illustrates the expansion of <ph id="ph1">[!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)]</ph> content into visual tree nodes in the <bpt id="p1">**</bpt>Visual Tree Explorer<ept id="p1">**</ept> panel of XamlPad:</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Visual Tree Explorer panel in XamlPad<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visuallayeroverview08.png "VisualLayerOverview08")</ept></source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Visual Tree Explorer panel in XamlPad</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Notice how the <ph id="ph1">&lt;xref:System.Windows.Controls.Label&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> controls each display a separate visual object hierarchy in the <bpt id="p1">**</bpt>Visual Tree Explorer<ept id="p1">**</ept> panel of XamlPad.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>This is because <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> controls have a <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> that contains the visual tree of that control.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>When you explicitly reference a control, you implicitly reference its visual hierarchy.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Profiling Visual Performance</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> provides a suite of performance profiling tools that allow you to analyze the run-time behavior of your application and determine the types of performance optimizations you can apply.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The Visual Profiler tool provides a rich, graphical view of performance data by mapping directly to the application's visual tree.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>In this screenshot, the <bpt id="p1">**</bpt>CPU Usage<ept id="p1">**</ept> section of the Visual Profiler gives you a precise breakdown of an object's use of <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> services, such as rendering and layout.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Visual Profiler display output<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/wpfperf-visualprofiler-04.png "WPFPerf_VisualProfiler_04")</ept></source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Visual Profiler display output</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Visual Rendering Behavior</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> introduces several features that affect the rendering behavior of visual objects: retained mode graphics, vector graphics, and device independent graphics.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Retained Mode Graphics</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>One of the keys to understanding the role of the Visual object is to understand the difference between <bpt id="p1">**</bpt>immediate mode<ept id="p1">**</ept> and <bpt id="p2">**</bpt>retained mode<ept id="p2">**</ept> graphics systems.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A standard Win32 application based on GDI or GDI+ uses an immediate mode graphics system.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This means that the application is responsible for repainting the portion of the client area that is invalidated, due to an action such as a window being resized, or an object changing its visual appearance.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of Win32 rendering sequence<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visuallayeroverview01.png "VisualLayerOverview01")</ept></source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Diagram of Win32 rendering sequence</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>In contrast, <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> uses a retained mode system.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This means application objects that have a visual appearance define a set of serialized drawing data.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Once the drawing data is defined, the system is responsible thereafter for responding to all repaint requests for rendering the application objects.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Even at run time, you can modify or create application objects, and still rely on the system for responding to paint requests.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The power in a retained mode graphics system is that drawing information is always persisted in a serialized state by the application, but rendering responsibility left to the system.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The following diagram shows how the application relies on <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> for responding to paint requests.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of WPF rendering sequence<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/visuallayeroverview02.png "VisualLayerOverview02")</ept></source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Diagram of WPF rendering sequence</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Intelligent Redrawing</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>One of the biggest benefits in using retained mode graphics is that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> can efficiently optimize what needs to be redrawn in the application.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Even if you have a complex scene with varying levels of opacity, you generally do not need to write special-purpose code to optimize redrawing.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Compare this with Win32 programming in which you can spend a great deal of effort in optimizing your application by minimizing the amount of redrawing in the update region.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Redrawing in the Update Region<ept id="p1">](https://msdn.microsoft.com/library/dd162909.aspx)</ept> for an example of the type of complexity involved in optimizing redrawing in Win32 applications.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Vector Graphics</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> uses <bpt id="p1">**</bpt>vector graphics<ept id="p1">**</ept> as its rendering data format.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Vector graphics—which include Scalable Vector Graphics (SVG), Windows metafiles (.wmf), and TrueType fonts—store rendering data and transmit it as a list of instructions that describe how to recreate an image using graphics primitives.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For example, TrueType fonts are outline fonts that describe a set of lines, curves, and commands, rather than an array of pixels.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>One of the key benefits of vector graphics is the ability to scale to any size and resolution.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Unlike vector graphics, bitmap graphics store rendering data as a pixel-by-pixel representation of an image, pre-rendered for a specific resolution.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>One of the key differences between bitmap and vector graphic formats is fidelity to the original source image.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>For example, when the size of a source image is modified, bitmap graphics systems stretch the image, whereas vector graphics systems scale the image, preserving the image fidelity.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The following illustration shows a source image that has been resized by 300%.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Notice the distortions that appear when the source image is stretched as a bitmap graphics image rather than scaled as a vector graphics image.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Differences between raster and vector graphics<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/vectorgraphics01.png "VectorGraphics01")</ept></source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Differences between raster and vector graphics</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The following markup shows two <ph id="ph1">&lt;xref:System.Windows.Shapes.Path&gt;</ph> elements defined.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The second element uses a <ph id="ph1">&lt;xref:System.Windows.Media.ScaleTransform&gt;</ph> to resize the drawing instructions of the first element by 300%.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Notice that the drawing instructions in the <ph id="ph1">&lt;xref:System.Windows.Shapes.Path&gt;</ph> elements remain unchanged.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VectorGraphicsSnippets#VectorGraphicsSnippet1<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/VectorGraphicsSnippets/CS/PageOne.xaml#vectorgraphicssnippet1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>About Resolution and Device-Independent Graphics</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>There are two system factors that determine the size of text and graphics on your screen: resolution and DPI.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Resolution describes the number of pixels that appear on the screen.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>As the resolution gets higher, pixels get smaller, causing graphics and text to appear smaller.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>A graphic displayed on a monitor set to 1024 x 768 will appear much smaller when the resolution is changed to 1600 x 1200.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The other system setting, DPI, describes the size of a screen inch in pixels.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Most <ph id="ph1">[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]</ph> systems have a DPI of 96, which means a screen inch is 96 pixels.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Increasing the DPI setting makes the screen inch larger; decreasing the DPI makes the screen inch smaller.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>This means that a screen inch isn't the same size as a real-world inch; on most systems, it's probably not.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>As you increase the DPI, DPI-aware graphics and text become larger because you've increased the size of the screen inch.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Increasing the DPI can make text easier to read, especially at high resolutions.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Not all applications are DPI-aware: some use hardware pixels as the primary unit of measurement; changing the system DPI has no effect on these applications.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Many other applications use DPI-aware units to describe font sizes, but use pixels to describe everything else.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Making the DPI too small or too large can cause layout problems for these applications, because the applications' text scales with the system's DPI setting, but the applications' UI does not.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>This problem has been eliminated for applications developed using <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> supports automatic scaling by using the device independent pixel as its primary unit of measurement, instead of hardware pixels; graphics and text scale properly without any extra work from the application developer.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The following illustration shows an example of how <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> text and graphics are appear at different DPI settings.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Graphics and text at different DPI settings<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/media/graphicsmm-dpi-setting-examples.png "graphicsmm_dpi_setting_examples")</ept></source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Graphics and text at different DPI settings</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>VisualTreeHelper Class</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class is a static helper class that provides low-level functionality for programming at the visual object level, which is useful in very specific scenarios, such as developing high-performance custom controls.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>In most case, the higher-level <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> framework objects, such as <ph id="ph2">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, offer greater flexibility and ease of use.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Hit Testing</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class provides methods for hit testing on visual objects when the default hit test support does not meet your needs.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper.HitTest%2A&gt;</ph> methods in the <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class to determine whether a geometry or point coordinate value is within the boundary of a given object, such as a control or graphic element.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>For example, you could use hit testing to determine whether a mouse click within the bounding rectangle of an object falls within the geometry of a circle You can also choose to override the default implementation of hit testing to perform your own custom hit test calculations.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>For more information on hit testing, see <bpt id="p1">[</bpt>Hit Testing in the Visual Layer<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Enumerating the Visual Tree</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class provides functionality for enumerating the members of a visual tree.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>To retrieve a parent, call the <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper.GetParent%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>To retrieve a child, or direct descendant, of a visual object, call the <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper.GetChild%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This method returns a child <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> of the parent at the specified index.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The following example shows how to enumerate all the descendants of a visual object, which is a technique you might want to use if you were interested in serializing all the rendering information of a visual object hierarchy.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VisualsOverview#101<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#101)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>VisualsOverview#101<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#101)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>In most cases, the logical tree is a more useful representation of the elements in a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Although you do not modify the logical tree directly, this view of the application is useful for understanding property inheritance and event routing.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Unlike the visual tree, the logical tree can represent non-visual data objects, such as <ph id="ph1">&lt;xref:System.Windows.Documents.ListItem&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For more information on the logical tree, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class provides methods for returning the bounding rectangle of visual objects.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>You can return the bounding rectangle of a visual object by calling <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>You can return the bounding rectangle of all the descendants of a visual object, including the visual object itself, by calling <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The following code shows how you would calculate the bounding rectangle of a visual object and all its descendants.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VisualsOverview#102<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#102)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>VisualsOverview#102<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#102)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>2D Graphics and Imaging<ept id="p1">](../../../../docs/framework/wpf/advanced/optimizing-performance-2d-graphics-and-imaging.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Hit Testing in the Visual Layer<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Using DrawingVisual Objects<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Tutorial: Hosting Visual Objects in a Win32 Application<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/tutorial-hosting-visual-objects-in-a-win32-application.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Optimizing WPF Application Performance<ept id="p1">](../../../../docs/framework/wpf/advanced/optimizing-wpf-application-performance.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>