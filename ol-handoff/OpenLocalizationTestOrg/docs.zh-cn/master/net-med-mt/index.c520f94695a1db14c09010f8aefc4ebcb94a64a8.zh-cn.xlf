<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="index.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b2a8af3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4f3354f392b3f37d74c42f18facce710fcc222bd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\generics\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e43eb9caa2e16db40b1fadd5d3d3c3ca9333d96</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">282d2a480f28c613a5dae4206aa0571d28ace401</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Generics in the .NET Framework | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Generics in the .NET Framework</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Generics let you tailor a method, class, structure, or interface to the precise data type it acts upon.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For example, instead of using the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> class, which allows keys and values to be of any type, you can use the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> generic class and specify the type allowed for the key and the type allowed for the value.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Among the benefits of generics are increased code reusability and type safety.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic provides an overview of generics in the .NET Framework and a summary of generic types or methods.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Defining and Using Generics<ept id="p1">](#defining_and_using_generics)</ept></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generics Terminology<ept id="p1">](#generics_terminology)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Class Library and Language Support<ept id="p1">](#class_library_and_language_support)</ept></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nested Types and Generics<ept id="p1">](#nested_types_and_generics)</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Related Topics<ept id="p1">](#related_topics)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Reference<ept id="p1">](#reference)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Defining and Using Generics</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Generics are classes, structures, interfaces, and methods that have placeholders (type parameters) for one or more of the types that they store or use.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>A generic collection class might use a type parameter as a placeholder for the type of objects that it stores; the type parameters appear as the types of its fields and the parameter types of its methods.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A generic method might use its type parameter as the type of its return value or as the type of one of its formal parameters.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following code illustrates a simple generic class definition.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#2<ept id="p2">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#2<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#2<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>When you create an instance of a generic class, you specify the actual types to substitute for the type parameters.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This establishes a new generic class, referred to as a constructed generic class, with your chosen types substituted everywhere that the type parameters appear.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The result is a type-safe class that is tailored to your choice of types, as the following code illustrates.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#3<ept id="p2">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#3<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#3<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Generics terminology</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following terms are used to discuss generics in the .NET Framework:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>generic type definition<ept id="p1">*</ept> is a class, structure, or interface declaration that functions as a template, with placeholders for the types that it can contain or use.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName&gt;</ph> class can contain two types: keys and values.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because a generic type definition is only a template, you cannot create instances of a class, structure, or interface that is a generic type definition.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Generic type parameters<ept id="p1">*</ept>, or <bpt id="p2">*</bpt>type parameters<ept id="p2">*</ept>, are the placeholders in a generic type or method definition.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName&gt;</ph> generic type has two type parameters, <ph id="ph2">`TKey`</ph> and <ph id="ph3">`TValue`</ph>, that represent the types of its keys and values.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>constructed generic type<ept id="p1">*</ept>, or <bpt id="p2">*</bpt>constructed type<ept id="p2">*</ept>, is the result of specifying types for the generic type parameters of a generic type definition.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>generic type argument<ept id="p1">*</ept> is any type that is substituted for a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The general term <bpt id="p1">*</bpt>generic type<ept id="p1">*</ept> includes both constructed types and generic type definitions.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Covariance<ept id="p1">*</ept> and <bpt id="p2">*</bpt>contravariance<ept id="p2">*</ept> of generic type parameters enable you to use constructed generic types whose type arguments are more derived (covariance) or less derived (contravariance) than a target constructed type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Covariance and contravariance are collectively referred to as <bpt id="p1">*</bpt>variance<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](../../../docs/standard/generics/covariance-and-contravariance.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Constraints<ept id="p1">*</ept> are limits placed on generic type parameters.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For example, you might limit a type parameter to types that implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=fullName&gt;</ph> generic interface, to ensure that instances of the type can be ordered.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can also constrain type parameters to types that have a particular base class, that have a default constructor, or that are reference types or value types.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Users of the generic type cannot substitute type arguments that do not satisfy the constraints.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>generic method definition<ept id="p1">*</ept> is a method with two parameter lists: a list of generic type parameters and a list of formal parameters.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Type parameters can appear as the return type or as the types of the formal parameters, as the following code shows.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#4<ept id="p2">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#4<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#4<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Generic methods can appear on generic or nongeneric types.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>It is important to note that a method is not generic just because it belongs to a generic type, or even because it has formal parameters whose types are the generic parameters of the enclosing type.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A method is generic only if it has its own list of type parameters.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In the following code, only method <ph id="ph1">`G`</ph> is generic.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#5<ept id="p2">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Generics.Overview#5<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Advantages and disadvantages of generics</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>There are many advantages to using generic collections and delegates:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Type safety.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Generics shift the burden of type safety from you to the compiler.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>There is no need to write code to test for the correct data type because it is enforced at compile time.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The need for type casting and the possibility of run-time errors are reduced.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Less code and code is more easily reused.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from a base type and override members.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Collections.Generic.LinkedList%601&gt;</ph> is ready for immediate use.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, you can create a linked list of strings with the following variable declaration:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>HowToGeneric#24<ept id="p2">](../../../samples/snippets/cpp/VS_Snippets_CLR/HowToGeneric/cpp/source2.cpp#24)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>HowToGeneric#24<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToGeneric/CS/source2.cs#24)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>HowToGeneric#24<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToGeneric/VB/source2.vb#24)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Better performance.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Generic collection types generally perform better for storing and manipulating value types because there is no need to box the value types.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Generic delegates enable type-safe callbacks without the need to create multiple delegate classes.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> generic delegate allows you to create a method that implements your own search criteria for a particular type and to use your method with methods of the <ph id="ph2">&lt;xref:System.Array&gt;</ph> type such as <ph id="ph3">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.FindAll%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Generics streamline dynamically generated code.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When you use generics with dynamically generated code you do not need to generate the type.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This increases the number of scenarios in which you can use lightweight dynamic methods instead of generating entire assemblies.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For more information, see How to: Define and Execute Dynamic Methods and DynamicMethod.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following are some limitations of generics:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Generic types can be derived from most base classes, such as <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> (and constraints can be used to require that generic type parameters derive from base classes like <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> does not support context-bound generic types.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A generic type can be derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, but trying to create an instance of that type causes a <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Enumerations cannot have generic type parameters.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>An enumeration can be generic only incidentally (for example, because it is nested in a generic type that is defined using Visual Basic, C#, or C++).</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For more information, see "Enumerations" in <bpt id="p1">[</bpt>Common Type System<ept id="p1">](../../../docs/standard/base-types/common-type-system.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Lightweight dynamic methods cannot be generic.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In Visual Basic, C#, and C++, a nested type that is enclosed in a generic type cannot be instantiated unless types have been assigned to the type parameters of all enclosing types.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Another way of saying this is that in reflection, a nested type that is defined using these languages includes the type parameters of all its enclosing types.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This allows the type parameters of enclosing types to be used in the member definitions of a nested type.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see "Nested Types" in <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A nested type that is defined by emitting code in a dynamic assembly or by using the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](../../../docs/framework/tools/ilasm-exe-il-assembler.md)</ept> is not required to include the type parameters of its enclosing types; however, if it does not include them, the type parameters are not in scope in the nested class.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For more information, see "Nested Types" in <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Class Library and Language Support</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The .NET Framework provides a number of generic collection classes in the following namespaces:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic&gt;</ph> namespace catalogs most of the generic collection types provided by the .NET Framework, such as the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> generic classes.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ObjectModel&gt;</ph> namespace catalogs additional generic collection types, such as the <ph id="ph2">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph> generic class, that are useful for exposing object models to users of your classes.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Generic interfaces for implementing sort and equality comparisons are provided in the <ph id="ph1">&lt;xref:System&gt;</ph> namespace, along with generic delegate types for event handlers, conversions, and search predicates.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Support for generics has been added to the <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> namespace for examining generic types and generic methods, to <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> for emitting dynamic assemblies that contain generic types and methods, and to <ph id="ph3">&lt;xref:System.CodeDom&gt;</ph> for generating source graphs that include generics.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The common language runtime provides new opcodes and prefixes to support generic types in Microsoft intermediate language (MSIL), including <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Stelem&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldelem&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unbox_Any&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph>, and <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Readonly&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Visual C++, C#, and Visual Basic all provide full support for defining and using generics.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>For more information about language support, see <bpt id="p1">[</bpt>Generic Types in Visual Basic<ept id="p1">](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md)</ept>, <bpt id="p2">[</bpt>Introduction to Generics<ept id="p2">](~/docs/csharp/programming-guide/generics/introduction-to-generics.md)</ept>, and <bpt id="p3">[</bpt>Overview of Generics in Visual C++<ept id="p3">](/cpp/windows/overview-of-generics-in-visual-cpp)</ept>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Nested Types and Generics</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>A type that is nested in a generic type can depend on the type parameters of the enclosing generic type.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The common language runtime considers nested types to be generic, even if they do not have generic type parameters of their own.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>When you create an instance of a nested type, you must specify type arguments for all enclosing generic types.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Title</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic Collections in the .NET Framework<ept id="p1">](../../../docs/standard/generics/collections.md)</ept></source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Describes generic collection classes and other generic types in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic Delegates for Manipulating Arrays and Lists<ept id="p1">](../../../docs/standard/generics/delegates-for-manipulating-arrays-and-lists.md)</ept></source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Describes generic delegates for conversions, search predicates, and actions to be taken on elements of an array or collection.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic Interfaces<ept id="p1">](../../../docs/standard/generics/interfaces.md)</ept></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Describes generic interfaces that provide common functionality across families of generic types.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](../../../docs/standard/generics/covariance-and-contravariance.md)</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Describes covariance and contravariance in generic type parameters.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Commonly Used Collection Types<ept id="p1">](../../../docs/standard/collections/commonly-used-collection-types.md)</ept></source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Provides summary information about the characteristics and usage scenarios of the collection types in the .NET Framework, including generic types.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>When to Use Generic Collections<ept id="p1">](../../../docs/standard/collections/when-to-use-generic-collections.md)</ept></source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Describes general rules for determining when to use generic collection types.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Define a Generic Type with Reflection Emit<ept id="p1">](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept></source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Explains how to generate dynamic assemblies that include generic types and methods.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic Types in Visual Basic<ept id="p1">](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md)</ept></source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Describes the generics feature for Visual Basic users, including how-to topics for using and defining generic types.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Introduction to Generics<ept id="p1">](~/docs/csharp/programming-guide/generics/introduction-to-generics.md)</ept></source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Provides an overview of defining and using generic types for C# users.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overview of Generics in Visual C++<ept id="p1">](/cpp/windows/overview-of-generics-in-visual-cpp)</ept></source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Describes the generics feature for C++ users, including the differences between generics and templates.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Reference</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>