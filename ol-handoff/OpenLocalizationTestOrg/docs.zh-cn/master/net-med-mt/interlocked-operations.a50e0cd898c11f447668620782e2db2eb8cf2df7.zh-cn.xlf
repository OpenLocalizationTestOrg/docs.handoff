<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">30a89d72bd44d5af7dd78b8fbd20fd685aed6e55</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\threading\interlocked-operations.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">871d72ab8ac9ec6954965ce8f29a3e6cf193e7cf</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6216821ad3702f8b916026c2d9c21d8350da2e1c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Interlocked Operations | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Interlocked Operations</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph>class provides methods that synchronize access to a variable that is shared by multiple threads.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The threads of different processes can use this mechanism if the variable is in shared memory.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Interlocked operations are atomic — that is, the entire operation is a unit that cannot be interrupted by another interlocked operation on the same variable.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This is important in operating systems with preemptive multithreading, where a thread can be suspended after loading a value from a memory address, but before having the chance to alter it and store it.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class provides the following operations:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In the .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> method adds an integer value to a variable and returns the new value of the variable.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In the .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method reads a 64-bit integer value as an atomic operation.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This is useful on 32-bit operating systems, where reading a 64-bit integer is not ordinarily an atomic operation.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> methods increment or decrement a variable and return the resulting value.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method performs an atomic exchange of the value in a specified variable, returning that value and replacing it with a new value.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In the .NET Framework version 2.0, a generic overload of this method can be used to perform this exchange on a variable of any reference type.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>See <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method also exchanges two values, but contingent on the result of a comparison.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the .NET Framework version 2.0, a generic overload of this method can be used to perform this exchange on a variable of any reference type.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>See <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>On modern processors, the methods of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class can often be implemented by a single instruction.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Thus, they provide very high-performance synchronization and can be used to build higher-level synchronization mechanisms, like spin locks.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For an example that uses the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked&gt;</ph> classes in combination, see <bpt id="p1">[</bpt>Monitors<ept id="p1">](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>CompareExchange Example</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method can be used to protect computations that are more complicated than simple increment and decrement.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a thread-safe method that adds to a running total stored as a floating point number.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>(For integers, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> method is a simpler solution.) For complete code examples, see the overloads of <ph id="ph2">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> that take single-precision and double-precision floating-point arguments (<ph id="ph3">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Single%40%2CSystem.Single%2CSystem.Single%29&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Double%40%2CSystem.Double%2CSystem.Double%29&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Conceptual.Interlocked#1<ept id="p2">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.interlocked/cpp/source1.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>Conceptual.Interlocked#1<ept id="p4">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.interlocked/cs/source1.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Conceptual.Interlocked#1<ept id="p6">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.interlocked/vb/source1.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Untyped Overloads of Exchange and CompareExchange</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> methods have overloads that take arguments of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The first argument of each of these overloads is <ph id="ph1">`ref Object`</ph> (<ph id="ph2">`ByRef … As Object`</ph> in Visual Basic), and type safety requires the variable passed to this argument to be typed strictly as <ph id="ph3">&lt;xref:System.Object&gt;</ph>; you cannot simply cast the first argument to type <ph id="ph4">&lt;xref:System.Object&gt;</ph> when calling these methods.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the .NET Framework version 2.0, use the generic overloads of the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> methods to exchange strongly typed variables.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following code example shows a property of type <ph id="ph1">`ClassA`</ph> that can be set only once, as it might be implemented in the .NET Framework version 1.0 or 1.1.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Conceptual.Interlocked#2<ept id="p2">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.interlocked/cpp/source2.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>Conceptual.Interlocked#2<ept id="p4">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.interlocked/cs/source2.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Conceptual.Interlocked#2<ept id="p6">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.interlocked/vb/source2.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Threading<ept id="p1">](../../../docs/standard/threading/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Threading Objects and Features<ept id="p1">](../../../docs/standard/threading/threading-objects-and-features.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>