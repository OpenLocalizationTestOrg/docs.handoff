<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="collection-types-in-data-contracts.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b2a8af3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">03bd52cc6d7d1626e34805458530c3f79492cbbf</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\collection-types-in-data-contracts.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ed0e85dfc46897ff7396f827b538b43e34cf9449</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">43d3c7f09319b706fab93588a87f3adf6e18a285</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Collection Types in Data Contracts | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Collection Types in Data Contracts</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>collection<ept id="p1">*</ept> is a list of items of a certain type.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph>, such lists can be represented using arrays or a variety of other types (Generic List, Generic <ph id="ph2">&lt;xref:System.ComponentModel.BindingList%601&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Specialized.StringCollection&gt;</ph>, or <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For example, a collection may hold a list of Addresses for a given Customer.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>These collections are called <bpt id="p1">*</bpt>list collections<ept id="p1">*</ept>, regardless of their actual type.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A special form of collection exists that represents an association between one item (the "key") and another (the "value").</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph>, these are represented by types such as <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> and the generic dictionary.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For example, an association collection may map a city ("key") to its population ("value").</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>These collections are called <bpt id="p1">*</bpt>dictionary collections<ept id="p1">*</ept>, regardless of their actual type.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Collections receive special treatment in the data contract model.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Types that implement the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface, including arrays and generic collections, are recognized as collections.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Of those, types that implement the <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> or Generic <ph id="ph2">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> interfaces are dictionary collections; all others are list collections.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Additional requirements on collection types, such as having a method called <ph id="ph1">`Add`</ph> and a default constructor, are discussed in detail in the following sections.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This ensures that collection types can be both serialized and deserialized.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This means that some collections are not directly supported, such as the Generic <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph> (because it has no default constructor).</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The types contained in collections must be data contract types, or be otherwise serializable.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Types Supported by the Data Contract Serializer<ept id="p1">](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Interchangeable Collections</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>All list collections of the same type are considered to have the same data contract (unless they are customized using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute, as discussed later in this topic).</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Thus, for example, the following data contracts are equivalent.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#0<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#0<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Both data contracts result in XML similar to the following code.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute).</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Non-generic collections are considered to have the same data contract as generic collections of type <ph id="ph1">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>(For example, the data contracts for <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and Generic <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph3">`Object`</ph> are the same.)</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Using Collection Interface Types and Read-Only Collections</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Collection interface types (<ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph>, generic <ph id="ph3">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, the following data contracts are equivalent.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#1<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#1<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Restrictions discussed previously (having a default constructor and an <ph id="ph1">`Add`</ph> method) do not apply.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, you can set addresses in Customer2 to an instance of Generic <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph> of Address, even though you cannot directly declare a data member of type Generic <ph id="ph2">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The known types mechanism (described in <bpt id="p1">[</bpt>Data Contract Known Types<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</ept>) has no effect here; the choice of type is built into <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Customizing Collection Types</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can customize collection types by using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute, which has several uses.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> this issue, see the "Advanced Collection Rules" section later in this topic.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Collection Data Contract Naming</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The rules for naming collection types are similar to those for naming regular data contract types, as described in <bpt id="p1">[</bpt>Data Contract Names<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-names.md)</ept>, although some important differences exist:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute is used to customize the name, instead of the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute also has <ph id="ph2">`Name`</ph> and <ph id="ph3">`Namespace`</ph> properties.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>They are not affected by the name and namespace of the collection type itself.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For an example, see the following types.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This means that serializing any one of these types at the root level yields XML similar to the following code.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This makes collection interchangeability possible.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In this example, CustomerList1 and StringList1 are completely interchangeable.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>However, when the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The name and namespace of the collection data contract then depend on the collection type itself.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For an example, see the following type.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#2<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#2<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When serialized, the resulting XML is similar to the following.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Notice that this is no longer equivalent to the XML representation of the non-customized types.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`Name`</ph> and <ph id="ph2">`Namespace`</ph> properties to further customize the naming.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>See the following class.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#3<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#3<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The resulting XML is similar to the following.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph> the "Advanced Collection Rules" section later in this topic.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Customizing the Repeating Element Name in List Collections</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>List collections contain repeating entries.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`CustomerList`</ph> examples, the collections contained strings.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The data contract name for the string primitive type is "string", so the repeating element was "<ph id="ph1">\&lt;</ph>string&gt;".</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>However, using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute, this repeating element name can be customized.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For an example, see the following type.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#4<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#4<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The resulting XML is similar to the following.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the <ph id="ph1">`Namespace`</ph> property, as described previously.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Customizing Dictionary Collections</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Additionally, you can change the element names that represent the key and the value by using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The namespaces for these elements are the same as the namespace of the collection data contract.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For an example, see the following type.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#5<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#5<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When serialized, the resulting XML is similar to the following.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> dictionary collections, see the "Advanced Collection Rules" section later in this topic.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Collections and Known Types</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, if you declare a data member of type <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> and use it to send an instance of <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, you do not need to add <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> to known types.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>When you use collections polymorphically in place of non-collection types, they must be added to known types.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For example, if you declare a data member of type <ph id="ph1">`Object`</ph> and use it to send an instance of <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, add <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> to known types.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This does not allow you to serialize any equivalent collection polymorphically.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, when you add <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> to the list of known types in the preceding example, this does not let you assign the <ph id="ph2">`Array of Object`</ph> class, even though it has an equivalent data contract.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This means that, in the previous example, you cannot add both <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id="ph2">`Array of Object`</ph> to known types at the same scope.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Known types may also be required for contents of collections.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For example, if an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> actually contains instances of <ph id="ph2">`Type1`</ph> and <ph id="ph3">`Type2`</ph>, both of these types should be added to known types.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following example shows a properly constructed object graph using collections and known types.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The example is somewhat contrived, because in an actual application you would normally not define the following data members as <ph id="ph1">`Object`</ph>, and thus do not have any known type/polymorphism issues.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#6<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#6<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>It is possible to add collection interface types to the list of known types on deserialization.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In this case, the deserialization engine again picks a type to be instantiated.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Collections and the NetDataContractSerializer Class</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> class is in use, non-customized collection types (without the <ph id="ph2">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute) that are not arrays lose their special meaning.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Non-customized collection types marked with the <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> attribute can still be serialized by the <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> class according to the <ph id="ph3">&lt;xref:System.SerializableAttribute&gt;</ph> attribute or the <ph id="ph4">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface rules.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> class is in use.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Collections and Schema</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For example, the server may use a data contract with a Generic <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of Integer data member, but in the generated client code the same data member may become an array of integers.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Dictionary collections are marked with a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For an exact description of how collections are represented in data contract schema, see <bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>By default, types are not generated for non-customized collections in imported code.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>However, for customized collections, separate types are generated, marked with the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> for list types and Generic Dictionary for dictionary types.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For example, you may have the following types on the server.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#7<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#7<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#8<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#8<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>You may want to use different types in generated code than the default ones.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For example, you may want to use Generic <ph id="ph1">&lt;xref:System.ComponentModel.BindingList%601&gt;</ph> instead of regular arrays for your data members to make it easier to bind them to user interface components.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>To choose collection types to generate, pass a list of collection types you want to use into the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ImportOptions&gt;</ph> object when importing schema.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>These types are called <bpt id="p1">*</bpt>referenced collection types<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When using the Svcutil.exe tool, this reference can be accomplished by using the <bpt id="p1">**</bpt>/collectionType<ept id="p1">**</ept> command-line switch (short form: <bpt id="p2">**</bpt>/ct<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Keep in mind that you must also specify the assembly for the referenced collection types using the <bpt id="p1">**</bpt>/reference<ept id="p1">**</ept> switch (short form: <bpt id="p2">**</bpt>/r<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>If the type is generic, it must be followed by a back quote and the number of generic parameters.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The back quote (`) is not to be confused with the single quote (‘) character.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>You can specify multiple referenced collection types by using the <bpt id="p1">**</bpt>/collectionType<ept id="p1">**</ept> switch more than once.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For example, to cause all lists to be imported as Generic <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Dictionaries are only matched against dictionaries, while lists are matched against lists.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>For example, if you add the Generic <ph id="ph1">&lt;xref:System.ComponentModel.BindingList%601&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> to the list of referenced types, the generated client code for the preceding example is similar to the following.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#9<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#9<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no <ph id="ph1">`Add`</ph> method or public constructor).</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>A closed generic is considered to be the best match.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>(Non-generic types are considered equivalent to closed generics of <ph id="ph1">`Object`</ph>).</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>For example, if the types Generic <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>, Generic <ph id="ph3">&lt;xref:System.ComponentModel.BindingList%601&gt;</ph> (open generic), and <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> are the referenced collection types, the following is generated.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#10<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#10<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For list collections, only the cases in the following table are supported.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Referenced type</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Interface implemented by referenced type</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Type treated as:</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Non-generic or closed generic (any number of parameters)</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Non-generic</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>where T= <ph id="ph1">`int`</ph></source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Closed generic of <ph id="ph1">`Object`</ph> (for example, <ph id="ph2">`IList&lt;object&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Closed generic</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType&lt;T&gt; : IList&lt;string&gt;`</ph> where T=<ph id="ph2">`int`</ph></source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Closed generic (for example, <ph id="ph1">`IList&lt;string&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Closed generic with any number of parameters</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Open generic using any one of the type’s parameters</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>where T=<ph id="ph1">`int`</ph>, U=<ph id="ph2">`string`</ph>, V=<ph id="ph3">`bool`</ph></source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Closed generic (for example, <ph id="ph1">`IList&lt;string&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Open generic with one parameter</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Open generic using the type’s parameter</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType&lt;T&gt; : IList&lt;T&gt;`</ph>, T is open</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Open generic (for example, <ph id="ph1">`IList&lt;T&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>If a type implements more than one list collection interface, the following restrictions apply:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If the type implements Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>This is true even if some implementations are invalid or use open generics.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>For example, a type that implements Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">`int`</ph> and Generic <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of T would never be used as a referenced collection of <ph id="ph4">`int`</ph> or any other type, regardless of whether the type has an <ph id="ph5">`Add`</ph> method accepting <ph id="ph6">`int`</ph> or an <ph id="ph7">`Add`</ph> method accepting a parameter of type T, or both.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If the type implements a generic collection interface as well as <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>For dictionary collections, only the cases in the following table are supported.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Referenced type</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Interface implemented by referenced type</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Type treated as</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Non-generic or closed generic (any number of parameters)</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType&lt;T&gt; : IDictionary`</ph> where T=<ph id="ph2">`int`</ph></source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Closed generic <ph id="ph1">`IDictionary&lt;object,object&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Closed generic (any number of parameters)</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>, closed</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType&lt;T&gt; : IDictionary\&lt;string, bool&gt;`</ph> where T=<ph id="ph2">`int`</ph></source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Closed generic (for example, <ph id="ph1">`IDIctionary\&lt;string,bool&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Closed generic (any number of parameters)</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>, one of either key or value is closed, the other is open and uses one of type’s parameters</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType\&lt;T,U,V&gt; : IDictionary\&lt;string,V&gt;`</ph> where T=<ph id="ph2">`int`</ph>, U=<ph id="ph3">`float`</ph>,V=<ph id="ph4">`bool`</ph></source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType&lt;Z&gt; : IDictionary\&lt;Z,bool&gt;`</ph> where Z=<ph id="ph2">`string`</ph></source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Closed generic (For example, <ph id="ph1">`IDictionary\&lt;string,bool&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Closed generic (any number of parameters)</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>, both key and value are open and each uses one of the type’s parameters</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType\&lt;T,U,V&gt; : IDictionary\&lt;V,U&gt;`</ph> where T=<ph id="ph2">`int`</ph>, U=<ph id="ph3">`bool`</ph>, V=<ph id="ph4">`string`</ph></source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Closed generic (for example, <ph id="ph1">`IDictionary\&lt;string,bool&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Open generic (two parameters)</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>, open, uses both of the type’s generic parameters in the order they appear</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MyType\&lt;K,V&gt; : IDictionary\&lt;K,V&gt;`</ph>, K and V both open</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Open generic (for example, <ph id="ph1">`IDictionary\&lt;K,V&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>If the type implements both <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> and Generic <ph id="ph2">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>, only Generic <ph id="ph3">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> is considered.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Referencing partial generic types is not supported.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Duplicates are not allowed, for example, you cannot add both the Generic <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph2">`Integer`</ph> and the Generic Collection of <ph id="ph3">`Integer`</ph> to <ph id="ph4">&lt;xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A&gt;</ph>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph2">`Integer`</ph> and the Generic Collection of <ph id="ph3">`Integer`</ph> in the <ph id="ph4">&lt;xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A&gt;</ph>, but neither has any effect.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Advanced Collection Rules</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Serializing Collections</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The following is a list of collection rules for serialization:</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Combining collection types (having collections of collections) is allowed.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Jagged arrays are treated as collections of collections.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays are not supported.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Arrays of byte and arrays of <ph id="ph1">&lt;xref:System.Xml.XmlNode&gt;</ph> are special array types that are treated as primitives, not collections.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> how an array of <ph id="ph2">&lt;xref:System.Xml.XmlNode&gt;</ph> is treated, see <bpt id="p1">[</bpt>XML and ADO.NET Types in Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>If a collection type implements the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface, the following rules apply, given a type <ph id="ph2">`myType:IList&lt;string&gt;, IXmlSerializable`</ph>:</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>If the declared type is <ph id="ph1">`IList&lt;string&gt;`</ph>, the type is serialized as a list.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>If the declared type is <ph id="ph1">`myType`</ph>, it is serialized as <ph id="ph2">`IXmlSerializable`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>If the declared type is <ph id="ph1">`IXmlSerializable`</ph>, it is serialized as <ph id="ph2">`IXmlSerializable`</ph>, but only if you add <ph id="ph3">`myType`</ph> to the list of known types.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Collections are serialized and deserialized using the methods shown in the following table.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Collection type implements</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Method(s) called on serialization</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Method(s) called on deserialization</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph></source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`get_Keys`</ph>, <ph id="ph2">`get_Values`</ph></source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Generic Add</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`get_Keys`</ph>, <ph id="ph2">`get_Values`</ph></source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph></source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> indexer</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Generic Add</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.ICollection%601&gt;</ph></source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Enumerator</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Generic Add</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> Indexer</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph></source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>A non-static method called <ph id="ph1">`Add`</ph> that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> (and thus <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>, which derives from it)</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>A non-static method called <ph id="ph1">`Add`</ph> that takes one parameter of type <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The preceding table lists collection interfaces in descending order of precedence.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>This means, for example, that if a type implements both <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> and Generic <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, the collection is serialized and deserialized according to the <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> rules:</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <ph id="ph1">&lt;xref:System.Collections.Generic.ICollection%601&gt;</ph> of <ph id="ph2">`Integer`</ph> and Generic <ph id="ph3">&lt;xref:System.Collections.Generic.ICollection%601&gt;</ph> of <ph id="ph4">&lt;xref:System.String&gt;</ph>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Collection types can have the <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> attribute applied to them and can implement the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Both of these are ignored.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>However, if the type does not fully meet collection type requirements (for example, the <ph id="ph1">`Add`</ph> method is missing), the type is not considered a collection type, and thus the <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> attribute and the <ph id="ph3">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface are used to determine whether the type can be serialized.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Applying the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute to a collection to customize it removes the <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> preceding fallback mechanism.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Instead, if a customized collection does not meet collection type requirements, an <ph id="ph1">&lt;xref:System.Runtime.Serialization.InvalidDataContractException&gt;</ph> exception is thrown.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The exception string often contains information that explains why a given type is not considered a valid collection (no <ph id="ph1">`Add`</ph> method, no default constructor, and so on), so it is often useful to apply the <ph id="ph2">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute for debugging purposes.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Collection Naming</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The following is a list of collection naming rules:</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is http://schemas.microsoft.com/2003/10/Serialization/Arrays unless overridden using Namespace.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Types that map to built-in XSD types, as well as <ph id="ph1">`char`</ph>, <ph id="ph2">`Timespan`</ph>, and <ph id="ph3">`Guid`</ph> types, are considered primitives for this purpose.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>For example, the data contract name for a Generic List of Integers is "ArrayOfint".</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Keep in mind that the data contract name of <ph id="ph1">`Object`</ph> is "anyType", so the data contract name of non-generic lists like <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is "ArrayOfanyType".</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The default name for dictionary collection data contracts, unless overridden using <ph id="ph1">`Name`</ph>, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> namespace hashes, see <bpt id="p1">[</bpt>Data Contract Names<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-names.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>You can customize the name of this data contract by using the <ph id="ph1">`ItemName`</ph> property, as described in the next section.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Generic type naming rules, as described in <bpt id="p1">[</bpt>Data Contract Names<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-names.md)</ept>, fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>However, numbers within the braces refer to generic parameters and not types contained within the collection.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Collection Customization</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>The following uses of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute are forbidden and result in an <ph id="ph2">&lt;xref:System.Runtime.Serialization.InvalidDataContractException&gt;</ph> exception:</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Applying the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute to a type to which the <ph id="ph2">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute has been applied, or to one of its derived types.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Applying the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute to a type that implements the <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Applying the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute to a non-collection type.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A&gt;</ph> on a <ph id="ph3">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute applied to a non-dictionary type.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Polymorphism Rules</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>As previously mentioned, customizing collections by using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> attribute may interfere with collection interchangeability.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>This should be avoided.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>See the following types.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#11<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>c_collection_types_in_data_contracts#11<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>In this case, an instance of <ph id="ph1">`Marks1`</ph> can be assigned to <ph id="ph2">`testMarks`</ph>.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`Marks2`</ph> should not be used because its data contract is not considered equivalent to the <ph id="ph2">`IList&lt;int&gt;`</ph> data contract.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "<ph id="ph1">\&lt;</ph>mark&gt;" and not "<ph id="ph2">\&lt;</ph>int&gt;".</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The rules in the following table apply to polymorphic assignment of collections.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Declared type</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Assigning a non-customized collection</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Assigning a customized collection</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Object</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Contract name is serialized.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Contract name is serialized.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Customization is used.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Collection interface</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Contract name is not serialized.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Contract name is not serialized.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Customization is not used.*</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Non-customized collection</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Contract name is not serialized.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Contract name is serialized.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Customization is used.**</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>Customized collection</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Contract name is serialized.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Customization is not used.**</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Contract name is serialized.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Customization of the assigned type is used.**</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>*With the <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> class, customization is used in this case.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> class also serializes the actual type name in this case, so deserialization works as expected.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>**These cases result in schema-invalid instances and thus should be avoided.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>An array of a derived type can be assigned to an array of a base type.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>In this case, the contract name for the derived type is serialized for each repeating element.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>For example, if a type <ph id="ph1">`Book`</ph> derives from the type <ph id="ph2">`LibraryItem`</ph>, you can assign an array of <ph id="ph3">`Book`</ph> to an array of <ph id="ph4">`LibraryItem`</ph>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>This does not apply to other collection types.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>For example, you cannot assign a <ph id="ph1">`Generic List of Book`</ph> to a <ph id="ph2">`Generic List of LibraryItem`</ph>.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>You can, however, assign a <ph id="ph1">`Generic List of LibraryItem`</ph> that contains <ph id="ph2">`Book`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>In both the array and the non-array case, <ph id="ph1">`Book`</ph> should be in the known types list.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Collections and Object Reference Preservation</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Specifically, object identity is preserved for both entire collections and individual items contained in collections.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>