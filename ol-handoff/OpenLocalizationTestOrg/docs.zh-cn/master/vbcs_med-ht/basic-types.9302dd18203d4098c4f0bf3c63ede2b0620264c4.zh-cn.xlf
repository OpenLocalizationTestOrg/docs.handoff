<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4762266380b3defab17951fdc4dd5c99d59935c6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\basic-types.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5360c659535689328755ad2e93d1fda91f6be320</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">49fba6b38c968296e039b53f1a9ec3e6cbbba037</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Basic Types | C# Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn about the core types (numerics, strings, and object) in all C# programs</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, C#</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Types, variables, and values</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>C# is a strongly-typed language.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Every variable and constant has a type, as does every expression that evaluates to a value.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Every method signature specifies a type for each input parameter and for the return value.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The information stored in a type can include the following:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The storage space that a variable of the type requires.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The maximum and minimum values that it can represent.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The members (methods, fields, events, and so on) that it contains.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The base type it inherits from.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The location where the memory for variables will be allocated at run time.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The kinds of operations that are permitted.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The compiler uses type information to make sure that all operations that are performed in your code are <bpt id="p1">*</bpt>type safe<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, if you declare a variable of type <bpt id="p1">[</bpt>int<ept id="p1">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept>, the compiler allows you to use the variable in addition and subtraction operations.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If you try to perform those same operations on a variable of type <bpt id="p1">[</bpt>bool<ept id="p1">](https://msdn.microsoft.com/library/c8f5xwh7.aspx)</ept>, the compiler generates an error, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Type Safety<ept id="p2">](../../samples/snippets/csharp/concepts/basic-types/type-safety.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>C and C++ developers, notice that in C#, <bpt id="p1">[</bpt>bool<ept id="p1">](https://msdn.microsoft.com/library/c8f5xwh7.aspx)</ept> is not convertible to <bpt id="p2">[</bpt>int<ept id="p2">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The compiler embeds the type information into the executable file as metadata.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Specifying types in variable declarations</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When you declare a variable or constant in a program, you must either specify its type or use the <bpt id="p1">[</bpt>var<ept id="p1">](https://msdn.microsoft.com/library/bb383973.aspx)</ept> keyword to let the compiler infer the type.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Variable Declaration<ept id="p2">](../../samples/snippets/csharp/concepts/basic-types/variable-declaration.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The types of method parameters and return values are specified in the method signature.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following signature shows a method that requires an <bpt id="p1">[</bpt>int<ept id="p1">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept> as an input argument and returns a string:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Method Signature<ept id="p2">](../../samples/snippets/csharp/concepts/basic-types/method-signature.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, you cannot declare an <bpt id="p1">[</bpt>int<ept id="p1">](https://msdn.microsoft.com/library/5kzh1b5w.aspx)</ept> and then assign it a Boolean value of <bpt id="p2">[</bpt>true<ept id="p2">](https://msdn.microsoft.com/library/06d3w013.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>type conversion<ept id="p1">*</ept> that does not cause data loss is performed automatically by the compiler.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A conversion that might cause data loss requires a <bpt id="p1">*</bpt>cast<ept id="p1">*</ept> in the source code.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Casting and type conversions<ept id="p1">](https://msdn.microsoft.com/library/ms173105.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Built-in types</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>There are also built-in <bpt id="p1">**</bpt>string<ept id="p1">**</ept> and <bpt id="p2">**</bpt>object<ept id="p2">**</ept> types.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>These are available for you to use in any C# program.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For a more information about the built-in types, see <bpt id="p1">[</bpt>Types reference tables<ept id="p1">](https://msdn.microsoft.com/library/1dhd7f2x.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Custom types</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You use the <bpt id="p1">[</bpt>struct<ept id="p1">](https://msdn.microsoft.com/library/ah19swz4.aspx)</ept>, <bpt id="p2">[</bpt>class<ept id="p2">](https://msdn.microsoft.com/library/0b0thckt.aspx)</ept>, <bpt id="p3">[</bpt>interface<ept id="p3">](https://msdn.microsoft.com/library/87d83y5b.aspx)</ept>, and <bpt id="p4">[</bpt>enum<ept id="p4">](https://msdn.microsoft.com/library/sbbt4032.aspx)</ept> constructs to create your own custom types.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By default, the most frequently used types in the class library are available in any C# program.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Others become available only when you explicitly add a project reference to the assembly in which they are defined.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Framework class library<ept id="p1">](https://msdn.microsoft.com/library/gg145045(v=vs.110).aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Generic types</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>A type can be declared with one or more <bpt id="p1">*</bpt>type parameters<ept id="p1">*</ept> that serve as a placeholder for the actual type (the <bpt id="p2">*</bpt>concrete type<ept id="p2">*</ept>) that client code will provide when it creates an instance of the type.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Such types are called <bpt id="p1">*</bpt>generic types<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For example, the .NET Framework type <ph id="ph1">@System.Collections.Generic.List</ph>%601 has one type parameter that by convention is given the name <bpt id="p1">*</bpt>T<ept id="p1">*</ept>. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Generic types<ept id="p2">](../../samples/snippets/csharp/concepts/basic-types/generic-type.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to <bpt id="p1">[</bpt>object<ept id="p1">](https://msdn.microsoft.com/library/9kkx3h3c.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Generic collection classes are called <bpt id="p1">*</bpt>strongly-typed collections<ept id="p1">*</ept> because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the <ph id="ph1">`strings`</ph> object in the previous example.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Generics<ept id="p1">](programming-guide/generics/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Implicit types, anonymous types, and tuple types</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>As stated previously, you can implicitly type a local variable (but not class members) by using the <bpt id="p1">[</bpt>var<ept id="p1">](https://msdn.microsoft.com/library/bb383973.aspx)</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The variable still receives a type at compile time, but the type is provided by the compiler.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Implicitly typed local variables<ept id="p1">](https://msdn.microsoft.com/library/bb384061.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You can create <bpt id="p1">*</bpt>anonymous types<ept id="p1">*</ept> for this purpose.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Anonymous types<ept id="p1">](https://msdn.microsoft.com/library/bb397696.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It's common to want to return more than one value from a method.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can create <bpt id="p1">*</bpt>tuple types<ept id="p1">*</ept> that return multiple values in a single method call.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Tuples<ept id="p1">](tuples.md)</ept></source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The Common type system</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>It is important to understand two fundamental points about the type system in the .NET Framework:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It supports the principle of inheritance.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Types can derive from other types, called <bpt id="p1">*</bpt>base types<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>All types, including built-in numeric types such as <ph id="ph1">@System.Int32</ph> (C# keyword: <ph id="ph2">`int`</ph>), derive ultimately from a single base type, which is <ph id="ph3">@System.Object</ph> (C# keyword: <ph id="ph4">`object`</ph>).</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This unified type hierarchy is called the <bpt id="p1">[</bpt>Common type system<ept id="p1">](../standard/common-type-system.md)</ept> (CTS).</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For more information about inheritance in C#, see <bpt id="p1">[</bpt>Inheritance<ept id="p1">](https://msdn.microsoft.com/library/ms173149.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Each type in the CTS is defined as either a <bpt id="p1">*</bpt>value type<ept id="p1">*</ept> or a <bpt id="p2">*</bpt>reference type<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This includes all custom types in the .NET Framework class library and also your own user-defined types.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Types that you define by using the <bpt id="p1">[</bpt>struct<ept id="p1">](https://msdn.microsoft.com/library/ah19swz4.aspx)</ept> keyword are value types; all the built-in numeric types are <bpt id="p2">**</bpt>structs<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For more information about value types, see <bpt id="p1">[</bpt>Structs<ept id="p1">](structs.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Types that you define by using the <bpt id="p1">[</bpt>class<ept id="p1">](https://msdn.microsoft.com/library/0b0thckt.aspx)</ept> keyword are reference types.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For more information about reference types, see <bpt id="p1">[</bpt>Classes<ept id="p1">](classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Reference types and value types have different compile-time rules, and different run-time behavior.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Structs<ept id="p1">](structs.md)</ept></source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes<ept id="p1">](classes.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>