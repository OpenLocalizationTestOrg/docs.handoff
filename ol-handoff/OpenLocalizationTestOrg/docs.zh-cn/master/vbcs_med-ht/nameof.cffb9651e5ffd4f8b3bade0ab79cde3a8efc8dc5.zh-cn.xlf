<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da3fef282ac71de07057131069bf58d4f761ad2d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\language-reference\keywords\nameof.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9df59c0c885d368dd5e98965bf652b096662d310</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d13a89259cb3477584167bb82dba03937b0f3116</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>nameof (C# and Visual Basic Reference) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>nameof (C# and Visual Basic Reference)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Used to obtain the simple (unqualified) string name of a variable, type, or member.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When reporting errors in code, hooking up model-view-controller (MVC) links, firing property changed events, etc., you often want to capture the string name of a method.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`nameof`</ph> helps keep your code valid when renaming definitions.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Before, you had to use string literals to refer to definitions, which is brittle when renaming code elements because tools do not know to check these string literals.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`nameof`</ph> expression has this form:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Key Use Cases</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>These examples show the key use cases for <ph id="ph1">`nameof`</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Validate parameters:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>MVC Action links:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>INotifyPropertyChanged:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>XAML dependency property:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Logging:</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Examples</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Some C# examples:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Many of the above samples apply to Visual Basic.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Here are some specific Visual Basic examples:</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The argument to <ph id="ph1">`nameof`</ph> must be a simple name, qualified name, member access, base access with a specified member, or this access with a specified member.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The argument expression identifies a code definition, but it is never evaluated.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Because the argument needs to be an expression syntactically, there are many things disallowed that are not useful to list.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following are worth mentioning that produce errors: predefined types (for example, <ph id="ph1">`int`</ph> or <ph id="ph2">`void`</ph>), nullable types (<ph id="ph3">`Point?`</ph>), array types (<ph id="ph4">`Customer[,]`</ph>), pointer types (<ph id="ph5">`Buffer*`</ph>), qualified alias (<ph id="ph6">`A::B`</ph>), and unbound generic types (<ph id="ph7">`Dictionary&lt;,&gt;`</ph>), preprocessing symbols (<ph id="ph8">`DEBUG`</ph>), and labels (<ph id="ph9">`loop:`</ph>).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If you need to get the fully-qualified name, you can use the <ph id="ph1">`typeof`</ph> expression along with <ph id="ph2">`nameof`</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Unfortunately <ph id="ph1">`typeof`</ph> is not a constant expression like <ph id="ph2">`nameof`</ph>, so <ph id="ph3">`typeof`</ph> cannot be used in conjunction with <ph id="ph4">`nameof`</ph> in all the same places as <ph id="ph5">`nameof`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, the following would cause a CS0182 compile error:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the examples you see that you can use a type name and access an instance method name.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You do not need to have an instance of the type, as required in evaluated expressions.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Using the type name can be very convenient in some situations, and since you are just referring to the name and not using instance data, you do not need to contrive an instance variable or expression.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can reference the members of a class in attribute expressions on the class.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>There is no way to get a signatures information such as "<ph id="ph1">`Method1 (str, str)`</ph>".</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>One way to do that is to use an Expression, <ph id="ph1">`Expression e = () =&gt; A.B.Method1("s1", "s2")`</ph>, and pull the MemberInfo from the resulting expression tree.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Language Specifications</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Visual Basic Language Reference<ept id="p1">](../../../visual-basic/language-reference/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Reference<ept id="p1">](../../../csharp/language-reference/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>typeof<ept id="p1">](../../../csharp/language-reference/keywords/typeof.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Visual Basic Language Reference<ept id="p1">](../../../visual-basic/language-reference/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Visual Basic Programming Guide<ept id="p1">](../../../visual-basic/programming-guide/index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>