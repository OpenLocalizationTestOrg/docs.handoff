<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">883745ca26a9c0d4bd1db805da603aa6e2c41972</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\porting\libraries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">446fd7f05ddd2ead2050fd2ade79d9e60e2347f8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c720f2db777798dc473b269864ac2500cc512fd</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>With the release of .NET Core 1.0, there is an opportunity to port existing library code so that it can run cross-platform.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article discusses the .NET Standard Library, unavailable technologies, how to account for the smaller number of APIs available on .NET Core 1.0, how to use the tooling that ships with .NET Core SDK Preview 2, and recommended approaches to porting your code.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Porting is a task that may take time, especially if you have a large codebase.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You should also be prepared to adapt the guidance here as needed to best fit your code.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Every codebase is different, so this article attempts to frame things in a flexible way, but you may find yourself needing to diverge from the prescribed guidance.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article assumes you are using Visual Studio 2017 or later on Windows.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The bits required for building .NET Core code are not available on previous versions of Visual Studio.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This article also assumes that you understand the <bpt id="p1">[</bpt>recommended porting process<ept id="p1">](index.md)</ept> and that you have resolved any issues with <bpt id="p2">[</bpt>third-party dependencies<ept id="p2">](third-party-deps.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Targeting the .NET Standard Library</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The best way to build a cross-platform library for .NET Core is to target the <bpt id="p1">[</bpt>.NET Standard Library<ept id="p1">](../../standard/library.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The .NET Standard Library is the formal specification of .NET APIs that are intended to be available on all .NET runtimes.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>It is supported by the .NET Core runtime.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>What this means is that you'll have to make a tradeoff between APIs you can use and platforms you can support, and pick the version of the .NET Platform Standard that best suits the tradeoff you wish to make.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>As of right now, there are 7 different versions to consider: .NET Standard 1.0 through 1.6.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If you pick a higher version, you get access to more APIs at the cost of running on fewer targets.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you pick a lower version, your code can run on more targets but at the cost of fewer APIs available to you.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For your convenience, here is a matrix of each .NET Standard version and each specific area it runs on:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Platform Name</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Alias</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET Standard</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>netstandard</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>1.0</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>1.1</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>1.2</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>1.3</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1.4</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>1.5</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>1.6</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>.NET Core</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>netcoreapp</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>1.0</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>.NET Framework</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>net</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>4.5</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>4.6</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>4.6.2</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>4.6.3</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Mono/Xamarin Platforms</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>uap</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>10.0</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Windows</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>win</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>8.0</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>8.1</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Windows Phone</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>wpa</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>8.1</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Windows Phone Silverlight</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>wp</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>8.0</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A key thing to understand is that <bpt id="p1">**</bpt>a project targeting a lower version cannot reference a project targeting a higher version<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, a project targeting the .NET Platform Standard version 1.2 cannot reference projects that target .NET Platform Standard version 1.3 or higher.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Projects <bpt id="p1">**</bpt>can<ept id="p1">**</ept> reference lower versions, though, so a project targeting .NET Platform Standard 1.3 can reference a project targeting .NET Platform Standard 1.2 or lower.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It's recommended that you pick the lowest possible .NET Standard version and use that throughout your project.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Read more in <bpt id="p1">[</bpt>.NET Platform Standard Library<ept id="p1">](../../standard/library.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Key Technologies Not Yet Available on the .NET Standard or .NET Core</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You may be using some technologies available for the .NET Framework that are not currently available for .NET Core.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Each of the following sub-sections corresponds to one of those technologies.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Alternative options are listed if it is feasible for you to adopt them.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>App Domains</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>AppDomains can be used for different purposes on the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For code isolation, we recommend separate processes and/or containers as an alternative.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For dynamic loading of assemblies, we recommend the new <ph id="ph1">@System.Runtime.Loader.AssemblyLoadContext</ph> class.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Remoting</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For communication across processes, inter-process communication (IPC) mechanisms can be used as an alternative to Remoting, such as <bpt id="p1">[</bpt>Pipes<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/system.io.pipes)</ept> or <bpt id="p2">[</bpt>Memory Mapped Files<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/system.io.memorymappedfiles.memorymappedfile)</ept>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Across machines, you can use a network based solution as an alternative, preferably a low-overhead plain text protocol such as HTTP.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>KestrelHttpServer<ept id="p1">](https://github.com/aspnet/KestrelHttpServer)</ept>, the web server used by ASP.NET Core, is an option here.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Remote proxy generation via <bpt id="p1">[</bpt>Castle.Core<ept id="p1">](https://github.com/castleproject/Core)</ept> is also an option to consider.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Binary Serialization</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As an alternative to Binary Serialization, there are multiple different serialization technologies to choose.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You should choose one that fits your goals for formatting and footprint.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Popular choices include:</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json)</ept> for JSON</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Runtime.Serialization.DataContractSerializer</ph> for both XML and JSON</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Xml.Serialization.XmlSerializer</ph> for XML</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>protobuf-net<ept id="p1">](https://github.com/mgravell/protobuf-net)</ept> for Protocol Buffers</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Refer to the linked resources to learn about their benefits and choose the ones for your needs.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>There are many other serialization formats and technologies out there, many of which are open source.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Sandboxes</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>As an alternative to Sandboxing, you can use operating system provided security boundaries, such as user accounts for running processes with the least set of privileges.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Overview of <ph id="ph1">`project.json`</ph></source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>project.json project model<ept id="p1">](../tools/project-json.md)</ept> is a project model that ships with .NET Core SDK 1.0 Preview 2.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>It offers some benefits you may wish to take advantage of today:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Simple multitargeting where target-specific assemblies can be generated from a single build.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The ability to easily generate a NuGet package with a build of the project.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>No need to list files in your project file.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Unification of NuGet package dependencies and project-to-project dependencies.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>While <ph id="ph1">`project.json`</ph> is eventually going to be deprecated, it can be used to build libraries on the .NET Standard today.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The Project File: <ph id="ph1">`project.json`</ph></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>.NET Core projects are defined by a directory containing a <ph id="ph1">`project.json`</ph> file.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This file is where aspects of the project are declared, such as package dependencies, compiler configuration, runtime configuration, and more.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dotnet restore`</ph> command reads this project file, restores all dependencies of the project, and generates a <ph id="ph2">`project.lock.json`</ph> file.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This file contains all the necessary information the build system needs to build the project.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>To learn more about the <ph id="ph1">`project.json`</ph> file, read the <bpt id="p1">[</bpt>project.json reference<ept id="p1">](../tools/project-json.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The Solution File: <ph id="ph1">`global.json`</ph></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`global.json`</ph> file is an optional file to include in a solution which contains multiple projects.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It typically resides in the root directory of a set of projects.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It can be used to inform the build system of different subdirectories which can contain projects.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This is for larger systems composed of several projects.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For example, you can organize your code into top-level <ph id="ph1">`/src`</ph> and <ph id="ph2">`/test`</ph> folder as such:</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You can then have multiple <ph id="ph1">`project.json`</ph> files under their own sub-folders inside <ph id="ph2">`/src`</ph> and <ph id="ph3">`/test`</ph>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>How to Multitarget with <ph id="ph1">`project.json`</ph></source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Many libraries multitarget to have as wide of a reach as possible.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>With .NET Core, multitargeting is a "first class citizen", meaning that you can easily generate platform-specific assemblies with a single build.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Multitargeting is as simple as adding the correct Target Framework Moniker (TFM) to your <ph id="ph1">`project.json`</ph> file, using the correct dependencies for each target (<ph id="ph2">`dependencies`</ph> for .NET Core and <ph id="ph3">`frameworkAssemblies`</ph> for .NET Framework), and potentially using <ph id="ph4">`#if`</ph> directives to conditionally compile the source code for platform-specific API usage.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>For example, imagine you are building a library where you wanted to perform some network operations, and you wanted that library to run on all .NET Framework versions, a Portable Class Library (PCL) Profile, and .NET Core.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For .NET Core and .NET Framework 4.5+ targets, you may use <ph id="ph1">`System.Net.Http`</ph> library and <ph id="ph2">`async`</ph><ph id="ph3">/</ph><ph id="ph4">`await`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>However, for earlier versions of .NET Framework, those APIs aren't available.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Here's a sample <ph id="ph1">`frameworks`</ph> section for a <ph id="ph2">`project.json`</ph> that targets the .NET Framework versions 2.0, 3.5, 4.0, 4.5, and .NET Standard 1.6:</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Note that PCL targets are special: they require you to specify a build definition for the compiler to recognize, and they require you to specify all of the assemblies you use, including <ph id="ph1">`mscorlib`</ph>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Your source code could then use the dependencies like this:</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that all of the .NET Framework and .NET Standard targets have names recognized by the compiler:</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As mentioned above, if you are targeting a PCL, then you will have to specify a build definition for the compiler to understand.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>There is no default definition that the compiler can use.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`project.json`</ph> in Visual Studio</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You have two options for using <ph id="ph1">`project.json`</ph> in Visual Studio:</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A new xproj project type.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>A retargeted PCL project which supports .NET Standard.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>There are different benefits and drawbacks for each.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When to Pick an Xproj Project</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The new Xproj project system in Visual Studio utilizes the capabilities of the <ph id="ph1">`project.json`</ph>-based project model to offer two major features over existing project types: seamless multitargeting by building multiple assemblies and the ability to directly generate a NuGet package on build.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However, it comes at the cost of lacking certain features you may use, such as:</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Support for F# or Visual Basic</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Generating satellite assemblies with localized resource strings</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Directly referencing a <ph id="ph1">`.dll`</ph> file on the filesystem</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The ability to reference a csproj-based project in the Reference Manager (depending on the <ph id="ph1">`.dll`</ph> file directly is supported, though)</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If your project needs are relatively minimal and you can take advantage of the new features of xproj, you should pick it as your project system.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This can be done in Visual Studio as such:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Ensure you are using Visual Studio 2015 or later.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Select File | New Project.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Select ".NET Core" under Visual C#.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Select the "Class Library (.NET Core)" template.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When to Pick a PCL project</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>You can target .NET Core with the traditional project system in Visual Studio, by creating a Portable Class Library (PCL) and selecting ".NET Core" in the project configuration dialog.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Then you'll need to retarget the project to be based on the .NET Standard:</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Right-click on the project file in Visual Studio and select Properties.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Under Build, select "Convert to .NET Standard".</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If you have more advanced project system needs, this should be your choice.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Note that if you wish to multitarget by generating platform-specific assemblies like with the <ph id="ph1">`xproj`</ph> project system, you'll need to create a "Bait and Switch" PCL, as described in <bpt id="p1">[</bpt>How to Make Portable Class Libraries Work for You<ept id="p1">](https://blogs.msdn.microsoft.com/dsplaisted/2012/08/27/how-to-make-portable-class-libraries-work-for-you/)</ept>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Retargeting your .NET Framework Code to .NET Framework 4.6.2</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If your code is not targeting .NET Framework 4.6.2, it's recommended that you retarget.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This ensures that you can use the latest API alternatives for cases where the .NET Standard can't support existing APIs.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For each of your projects in Visual Studio you wish to port, do the following:</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Right-click on the project and select Properties</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In the "Target Framework" dropdown, select ".NET Framework 4.6.2".</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Recompile your projects.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Because your projects now target .NET Framework 4.6.2, you can use that version of .NET Framework as your base for porting code.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Determining the Portability of Your Code</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The next step is to run the API Portability Analyzer (ApiPort) to generate a portability report that you can begin to analyze.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>You'll need to make sure you understand the <bpt id="p1">[</bpt>API Portability tool (ApiPort)<ept id="p1">](https://github.com/Microsoft/dotnet-apiport/blob/master/docs/HowTo/)</ept> and can generate portability reports for targeting .NET Core.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>How you do this will likely vary based on your needs and personal tastes.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>What follows are a few different approaches - you may find yourself mixing each approach depending on how your code is structured.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Dealing Primarily with the Compiler</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This approach may be the best for small projects or projects which don't use many .NET Framework APIs.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The approach is very simple:</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Optionally run ApiPort on your project.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>If ApiPort was ran, take a quick glance at the report.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Copy all of your code over into a new .NET Core project.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Work out compiler errors until it compiles, referring to the portability report if needed.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Repeat as needed.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Although this approach is very unstructured, the code-focused approach can lead to resolving any issues quickly, and may be the best approach for smaller projects or libraries.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>A project that contains only data models may be an ideal candidate here.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Staying on the .NET Framework until Portability Issues are Resolved</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This approach may be the best if you prefer to have code that compiles during the entire process.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Address issues by using different APIs which are portable.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Keep note of any areas where you can't use a direct alternative.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Repeat steps 1-3 for all projects you're porting until you're confident each is ready to be copied over into a .NET Core project.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Copy the code into a new .NET Core projects.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Work out any issues that you've kept note of.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>This careful approach is more structured than simply working out compiler errors, but it is still relatively code-focused and has the benefit of always having code that can compile.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The way you resolve certain issues that couldn't be addressed by just using another API can vary greatly.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>You may find that you need to develop a more comprehensive plan for certain projects, which is covered as the next approach.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Developing a Comprehensive Plan of Attack</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>This approach may be best for larger and more complex projects, where restructuring of code or rewriting certain areas may be necessary to support .NET Core.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Understand where in your code each non-portable type is being used and how that affects overall portability.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>a.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Understand the nature of those types.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Are they small in number, but used frequently?</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Are they large in number, but used infrequently?</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Is their use concentrated, or is it spread throughout your code?</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>b.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Is it easy to isolate code that isn't portable so you can deal with it more easily?</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>c.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Would you need to refactor your code?</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>d.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>For those types which aren't portable, are there alternative APIs that accomplish the same task?</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>For example, if you're using the <ph id="ph1">`WebClient`</ph> class, you may be able to use the <ph id="ph2">`HttpClient`</ph> class instead.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>e.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Are there different portable APIs you can use to accomplish a task, even if it's not a drop-in replacement?</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For example, if you're using <ph id="ph1">`XmlSchema`</ph> to help parse XML, but you don't require XML schema discovery, you could use <ph id="ph2">`System.Linq.Xml`</ph> APIs and hand-parse the data.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If you have assemblies that are difficult to port, is it worth leaving them on .NET Framework for now?</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Here are some things to consider:</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>a.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>You may have some functionality in your library that's incompatible with .NET Core because it relies too heavily on .NET Framework- or Windows-specific functionality.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Is it worth leaving that functionality behind for now and releasing a .NET Core version of your library with less features for the time being?</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>b.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Would a refactor help here?</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Is it reasonable to write your own implementation of an unavailable .NET Framework API?</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>You could consider instead copying, modifying, and using code from the <bpt id="p1">[</bpt>.NET Framework Reference Source<ept id="p1">](https://github.com/Microsoft/referencesource)</ept>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>It's licensed under the <bpt id="p1">[</bpt>MIT License<ept id="p1">](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)</ept>, so you have significant freedom in doing this.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Just be sure to properly attribute Microsoft in your code!</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Repeat this process as needed for different projects.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Once you have a plan, execute that plan.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The analysis phase could take some time depending on how large your codebase is.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Spending time in this phase to thoroughly understand the scope of changes needed and to develop a plan can save you a lot of time in the long run, particularly if you have a more complex codebase.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Your plan could involve making significant changes to your codebase while still targeting .NET Framework 4.6.2, making this a more structured version of the previous approach.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>How you go about executing your plan will be dependent on your codebase.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Mixing Approaches</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>It's likely that you'll mix the above approaches on a per-project basis.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>You should do what makes the most sense to you and for your codebase.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Porting your Tests</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The best way to make sure everything works when you've ported your code is to test your code as you port it to .NET Core.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>To do this, you'll need to use a testing framework that will build and run tests for .NET Core.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Currently, you have three options:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>xUnit<ept id="p1">](https://xunit.github.io/)</ept></source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started<ept id="p1">](http://xunit.github.io/docs/getting-started-dotnet-core.html)</ept></source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tool to convert an MSTest project to xUnit<ept id="p1">](https://github.com/dotnet/codeformatter/tree/master/src/XUnitConverter)</ept></source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>NUnit<ept id="p1">](http://www.nunit.org/)</ept></source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started<ept id="p1">](https://github.com/nunit/docs/wiki/Installation)</ept></source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Blog post about migrating from MSTest to NUnit<ept id="p1">](http://www.florian-rappl.de/News/Page/275/convert-mstest-to-nunit)</ept></source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>MSTest<ept id="p1">](https://msdn.microsoft.com/library/ms243147.aspx)</ept></source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Recommended Approach to Porting</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Finally, porting the code itself!</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Ultimately, the actual porting effort will depend heavily on how your .NET Framework code is structured.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>That being said, here is a recommended approach which may work well with your codebase.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A good way to port your code is to begin with the "base" of your library.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>This may be data models or some other foundational classes and methods that everything else uses directly or indirectly.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Port the test project which tests the layer of your library that you're currently porting.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Copy over the "base" of your library into a new .NET Core project and select the version of the .NET Standard you wish to support.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Make any changes needed to get the code to compile.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Much of this may require adding NuGet package dependencies to your <ph id="ph1">`project.json`</ph> file.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Run tests and make any needed adjustments.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Pick the next layer of code to port over and repeat steps 2 and 3!</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>If you methodically move outward from the base of your library and test each layer as needed, porting will be a systematic process where problems are isolated to one layer of code at a time.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>