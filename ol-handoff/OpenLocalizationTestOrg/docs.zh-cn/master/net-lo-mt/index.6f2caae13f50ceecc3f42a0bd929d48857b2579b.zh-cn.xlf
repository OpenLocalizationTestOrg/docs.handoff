<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-401ea83" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">edea467acd97ef036a028e2afad5c99d2f268b1c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\mef\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0124cd374bb7d351259e001facca77fc781972c2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">081796db267816d0cad05ce201c40912c2bbb95f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Managed Extensibility Framework (MEF) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Managed Extensibility Framework (MEF)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic provides an overview of the Managed Extensibility Framework introduced in the .NET Framework 4.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>What is MEF?</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The Managed Extensibility Framework or MEF is a library for creating lightweight, extensible applications.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It allows application developers to discover and use extensions with no configuration required.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It also lets extension developers easily encapsulate code and avoid fragile hard dependencies.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>MEF not only allows extensions to be reused within applications, but across applications as well.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Problem of Extensibility</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Imagine that you are the architect of a large application that must provide support for extensibility.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Your application has to include a potentially large number of smaller components, and is responsible for creating and running them.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The simplest approach to the problem is to include the components as source code in your application, and call them directly from your code.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This has a number of obvious drawbacks.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Most importantly, you cannot add new components without modifying the source code, a restriction that might be acceptable in, for example, a Web application, but is unworkable in a client application.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Equally problematic, you may not have access to the source code for the components, because they might be developed by third parties, and for the same reason you cannot allow them to access yours.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>A slightly more sophisticated approach would be to provide an extension point or interface, to permit decoupling between the application and its components.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Under this model, you might provide an interface that a component can implement, and an API to enable it to interact with your application.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This solves the problem of requiring source code access, but it still has its own difficulties.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Because the application lacks any capacity for discovering components on its own, it must still be explicitly told which components are available and should be loaded.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This is typically accomplished by explicitly registering the available components in a configuration file.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This means that assuring that the components are correct becomes a maintenance issue, particularly if it is the end user and not the developer who is expected to do the updating.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In addition, components are incapable of communicating with one another, except through the rigidly defined channels of the application itself.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If the application architect has not anticipated the need for a particular communication, it is usually impossible.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Finally, the component developers must accept a hard dependency on what assembly contains the interface they implement.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This makes it difficult for a component to be used in more than one application, and can also create problems when you create a test framework for components.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>What MEF Provides</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Instead of this explicit registration of available components, MEF provides a way to discover them implicitly, via <bpt id="p1">*</bpt>composition<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A MEF component, called a <bpt id="p1">*</bpt>part<ept id="p1">*</ept>, declaratively specifies both its dependencies (known as <bpt id="p2">*</bpt>imports<ept id="p2">*</ept>) and what capabilities (known as <bpt id="p3">*</bpt>exports<ept id="p3">*</ept>) it makes available.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When a part is created, the MEF composition engine satisfies its imports with what is available from other parts.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This approach solves the problems discussed in the previous section.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Because MEF parts declaratively specify their capabilities, they are discoverable at runtime, which means an application can make use of parts without either hard-coded references or fragile configuration files.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>MEF allows applications to discover and examine parts by their metadata, without instantiating them or even loading their assemblies.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>As a result, there is no need to carefully specify when and how extensions should be loaded.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In addition to its provided exports, a part can specify its imports, which will be filled by other parts.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This makes communication among parts not only possible, but easy, and allows for good factoring of code.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, services common to many components can be factored into a separate part and easily modified or replaced.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Because the MEF model requires no hard dependency on a particular application assembly, it allows extensions to be reused from application to application.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This also makes it easy to develop a test harness, independent of the application, to test extension components.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>An extensible application written by using MEF declares an import that can be filled by extension components, and may also declare exports in order to expose application services to extensions.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Each extension component declares an export, and may also declare imports.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In this way, extension components themselves are automatically extensible.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Where Is MEF Available?</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>MEF is an integral part of the <ph id="ph1">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, and is available wherever the .NET Framework is used.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can use MEF in your client applications, whether they use Windows Forms, WPF, or any other technology, or in server applications that use ASP.NET.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>MEF and MAF</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Previous versions of the .NET Framework introduced the Managed Add-in Framework (MAF), designed to allow applications to isolate and manage extensions.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The focus of MAF is slightly higher-level than MEF, concentrating on extension isolation and assembly loading and unloading, while MEF's focus is on discoverability, extensibility, and portability.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The two frameworks interoperate smoothly, and a single application can take advantage of both.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>SimpleCalculator: An Example Application</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The simplest way to see what MEF can do is to build a simple MEF application.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In this example, you build a very simple calculator named SimpleCalculator.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The goal of SimpleCalculator is to create a console application that accepts basic arithmetic commands, in the form "5+3" or "6-2", and returns the correct answers.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Using MEF, you will be able to add new operators without changing the application code.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>To download the complete code for this example, see the <bpt id="p1">[</bpt>SimpleCalculator sample<ept id="p1">](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e)</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The purpose of SimpleCalculator is to demonstrate the concepts and syntax of MEF, rather than to necessarily provide a realistic scenario for its use.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Many of the applications that would benefit most from the power of MEF are more complex than SimpleCalculator.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more extensive examples, see the <bpt id="p1">[</bpt>Managed Extensibility Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=144282)</ept> on Codeplex.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To start, in <ph id="ph1">[!INCLUDE[vs_dev10_long](../../../includes/vs-dev10-long-md.md)]</ph>, create a new Console Application project named <ph id="ph2">`SimpleCalculator`</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Add a reference to the System.ComponentModel.Composition assembly, where MEF resides.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Open Module1.vb or Program.cs and add <ph id="ph1">`Imports`</ph> or <ph id="ph2">`using`</ph> statements for System.ComponentModel.Composition and System.ComponentModel.Composition.Hosting.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These two namespaces contain MEF types you will need to develop an extensible application.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In Visual Basic, add the <ph id="ph1">`Public`</ph> keyword to the line that declares the <ph id="ph2">`Module1`</ph> module.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Composition Container and Catalogs</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The core of the MEF composition model is the <bpt id="p1">*</bpt>composition container<ept id="p1">*</ept>, which contains all the parts available and performs composition.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>(That is, the matching up of imports to exports.)  The most common type of composition container is <ph id="ph1">&lt;xref:System.ComponentModel.Composition.Hosting.CompositionContainer&gt;</ph>, and you will use this for SimpleCalculator.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In Visual Basic, in Module1.vb, add a public class named <ph id="ph1">`Program`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Then add the following line to the <ph id="ph1">`Program`</ph> class in Module1.vb or Program.cs:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In order to discover the parts available to it, the composition containers makes use of a <bpt id="p1">*</bpt>catalog<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A catalog is an object that makes available parts discovered from some source.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>MEF provides catalogs to discover parts from a provided type, an assembly, or a directory.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Application developers can easily create new catalogs to discover parts from other sources, such as a Web service.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Add the following constructor to the <ph id="ph1">`Program`</ph> class:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The call to <ph id="ph1">&lt;xref:System.ComponentModel.Composition.AttributedModelServices.ComposeParts%2A&gt;</ph> tells the composition container to compose a specific set of parts, in this case the current instance of <ph id="ph2">`Program`</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>At this point, however, nothing will happen, since <ph id="ph1">`Program`</ph> has no imports to fill.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Imports and Exports with Attributes</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>First, you have <ph id="ph1">`Program`</ph> import a calculator.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This allows the separation of user interface concerns, such as the console input and output that will go into <ph id="ph1">`Program`</ph>, from the logic of the calculator.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Add the following code to the <ph id="ph1">`Program`</ph> class:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Notice that the declaration of the <ph id="ph1">`calculator`</ph> object is not unusual, but that it is decorated with the <ph id="ph2">&lt;xref:System.ComponentModel.Composition.ImportAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This attribute declares something to be an import; that is, it will be filled by the composition engine when the object is composed.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Every import has a <bpt id="p1">*</bpt>contract<ept id="p1">*</ept>, which determines what exports it will be matched with.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The contract can be an explicitly specified string, or it can be automatically generated by MEF from a given type, in this case the interface <ph id="ph1">`ICalculator`</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Any export declared with a matching contract will fulfill this import.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Note that while the type of the <ph id="ph1">`calculator`</ph> object is in fact <ph id="ph2">`ICalculator`</ph>, this is not required.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The contract is independent from the type of the importing object.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>(In this case, you could leave out the <ph id="ph1">`typeof(ICalculator)`</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>MEF will automatically assume the contract to be based on the type of the import unless you specify it explicitly.)</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Add this very simple interface to the module or <ph id="ph1">`SimpleCalculator`</ph> namespace:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Now that you have defined <ph id="ph1">`ICalculator`</ph>, you need a class that implements it.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Add the following class to the module or <ph id="ph1">`SimpleCalculator`</ph> namespace:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Here is the export that will match the import in <ph id="ph1">`Program`</ph>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In order for the export to match the import, the export must have the same contract.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Exporting under a contract based on <ph id="ph1">`typeof(MySimpleCalculator)`</ph> would produce a mismatch, and the import would not be filled; the contract needs to match exactly.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Since the composition container will be populated with all the parts available in this assembly, the <ph id="ph1">`MySimpleCalculator`</ph> part will be available.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>When the constructor for <ph id="ph1">`Program`</ph> performs composition on the <ph id="ph2">`Program`</ph> object, its import will be filled with a <ph id="ph3">`MySimpleCalculator`</ph> object, which will be created for that purpose.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The user interface layer (<ph id="ph1">`Program`</ph>) does not need to know anything else.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You can therefore fill in the rest of the user interface logic in the <ph id="ph1">`Main`</ph> method.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Add the following code to the <ph id="ph1">`Main`</ph> method:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This code simply reads a line of input and calls the <ph id="ph1">`Calculate`</ph> function of <ph id="ph2">`ICalculator`</ph> on the result, which it writes back to the console.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>That is all the code you need in <ph id="ph1">`Program`</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>All the rest of the work will happen in the parts.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Further Imports and ImportMany</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In order for SimpleCalculator to be extensible, it needs to import a list of operations.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>An ordinary <ph id="ph1">&lt;xref:System.ComponentModel.Composition.ImportAttribute&gt;</ph> attribute is filled by one and only one <ph id="ph2">&lt;xref:System.ComponentModel.Composition.ExportAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If more than one is available, the composition engine produces an error.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>To create an import that can be filled by any number of exports, you can use the <ph id="ph1">&lt;xref:System.ComponentModel.Composition.ImportManyAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Add the following operations property to the <ph id="ph1">`MySimpleCalculator`</ph> class:</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Lazy%602&gt;</ph> is a type provided by MEF to hold indirect references to exports.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Here, in addition to the exported object itself, you also get <bpt id="p1">*</bpt>export metadata<ept id="p1">*</ept>, or information that describes the exported object.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Each <ph id="ph1">&lt;xref:System.Lazy%602&gt;</ph> contains an <ph id="ph2">`IOperation`</ph> object, representing an actual operation, and an <ph id="ph3">`IOperationData`</ph> object, representing its metadata.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Add the following simple interfaces to the module or <ph id="ph1">`SimpleCalculator`</ph> namespace:</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In this case, the metadata for each operation is the symbol that represents that operation, such as +, -, *, and so on.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>To make the addition operation available, add the following class to the module or <ph id="ph1">`SimpleCalculator`</ph> namespace:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ComponentModel.Composition.ExportAttribute&gt;</ph> attribute functions as it did before.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ComponentModel.Composition.ExportMetadataAttribute&gt;</ph> attribute attaches metadata, in the form of a name-value pair, to that export.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>While the <ph id="ph1">`Add`</ph> class implements <ph id="ph2">`IOperation`</ph>, a class that implements <ph id="ph3">`IOperationData`</ph> is not explicitly defined.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Instead, a class is implicitly created by MEF with properties based on the names of the metadata provided.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>(This is one of several ways to access metadata in MEF.)</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Composition in MEF is <bpt id="p1">*</bpt>recursive<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>You explicitly composed the <ph id="ph1">`Program`</ph> object, which imported an <ph id="ph2">`ICalculator`</ph> that turned out to be of type <ph id="ph3">`MySimpleCalculator`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MySimpleCalculator`</ph>, in turn, imports a collection of <ph id="ph2">`IOperation`</ph> objects, and that import will be filled when <ph id="ph3">`MySimpleCalculator`</ph> is created, at the same time as the imports of <ph id="ph4">`Program`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Add`</ph> class declared a further import, that too would have to be filled, and so on.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Any import left unfilled results in a composition error.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>(It is possible, however, to declare imports to be optional or to assign them default values.)</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Calculator Logic</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>With these parts in place, all that remains is the calculator logic itself.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Add the following code in the <ph id="ph1">`MySimpleCalculator`</ph> class to implement the <ph id="ph2">`Calculate`</ph> method:</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The initial steps parse the input string into left and right operands and an operator character.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`foreach`</ph> loop, every member of the <ph id="ph2">`operations`</ph> collection is examined.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>These objects are of type <ph id="ph1">&lt;xref:System.Lazy%602&gt;</ph>, and their metadata values and exported object can be accessed with the <ph id="ph2">&lt;xref:System.Lazy%602.Metadata%2A&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Lazy%601.Value%2A&gt;</ph>property respectively.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>In this case, if the <ph id="ph1">`Symbol`</ph> property of the <ph id="ph2">`IOperationData`</ph> object is discovered to be a match, the calculator calls the <ph id="ph3">`Operate`</ph> method of the <ph id="ph4">`IOperation`</ph> object and returns the result.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>To complete the calculator, you also need a helper method that returns the position of the first non-digit character in a string.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Add the following helper method to the <ph id="ph1">`MySimpleCalculator`</ph> class:</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>You should now be able to compile and run the project.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In Visual Basic, make sure that you added the <ph id="ph1">`Public`</ph> keyword to <ph id="ph2">`Module1`</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In the console window, type an addition operation, such as "5+3", and the calculator will return the results.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Any other operator will result in the "Operation Not Found!"</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>message.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Extending SimpleCalculator Using A New Class</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Now that the calculator works, adding a new operation is easy.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Add the following class to the module or <ph id="ph1">`SimpleCalculator`</ph> namespace:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Compile and run the project.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Type a subtraction operation, such as "5-3".</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The calculator now supports subtraction as well as addition.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Extending SimpleCalculator Using A New Assembly</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Adding classes to the source code is simple enough, but MEF provides the ability to look outside an applicationâ€™s own source for parts.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>To demonstrate this, you will need to modify SimpleCalculator to search a directory, as well as its own assembly, for parts, by adding a <ph id="ph1">&lt;xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Add a new directory named <ph id="ph1">`Extensions`</ph> to the SimpleCalculator project.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Make sure to add it at the project level, and not at the solution level.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Then add a new Class Library project to the solution, named <ph id="ph1">`ExtendedOperations`</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The new project will compile into a separate assembly.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Open the Project Properties Designer for the ExtendedOperations project and click the <bpt id="p1">**</bpt>Compile<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Build<ept id="p2">**</ept> tab. Change the <bpt id="p3">**</bpt>Build output path<ept id="p3">**</ept> or <bpt id="p4">**</bpt>Output path<ept id="p4">**</ept> to point to the Extensions directory in the SimpleCalculator project directory (..\SimpleCalculator\Extensions<ph id="ph1">\\</ph>).</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In Module1.vb or Program.cs, add the following line to the <ph id="ph1">`Program`</ph> constructor:</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Replace the example path with the path to your Extensions directory.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>(This absolute path is for debugging purposes only.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>In a production application, you would use a relative path.) The <ph id="ph1">&lt;xref:System.ComponentModel.Composition.Hosting.DirectoryCatalog&gt;</ph> will now add any parts found in any assemblies in the Extensions directory to the composition container.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>In the ExtendedOperations project, add references to SimpleCalculator and System.ComponentModel.Composition.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>In the ExtendedOperations class file, add an <ph id="ph1">`Imports`</ph> or a <ph id="ph2">`using`</ph> statement for System.ComponentModel.Composition.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>In Visual Basic, also add an <ph id="ph1">`Imports`</ph> statement for SimpleCalculator.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Then add the following class to the ExtendedOperations class file:</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Note that in order for the contract to match, the <ph id="ph1">&lt;xref:System.ComponentModel.Composition.ExportAttribute&gt;</ph> attribute must have the same type as the <ph id="ph2">&lt;xref:System.ComponentModel.Composition.ImportAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Compile and run the project.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Test the new Mod (%) operator.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>This topic covered the basic concepts of MEF.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Parts, catalogs, and the composition container</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Parts and the composition container are the basic building blocks of a MEF application.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>A part is any object that imports or exports a value, up to and including itself.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>A catalog provides a collection of parts from a particular source.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The composition container uses the parts provided by a catalog to perform composition, the binding of imports to exports.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Imports and exports</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Imports and exports are the way by which components communicate.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>With an import, the component specifies a need for a particular value or object, and with an export it specifies the availability of a value.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Each import is matched with a list of exports by way of its contract.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Where Do I Go Now?</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>To download the complete code for this example, see the <bpt id="p1">[</bpt>SimpleCalculator sample<ept id="p1">](http://code.msdn.microsoft.com/windowsdesktop/Simple-Calculator-MEF-1152654e)</ept>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For more information and code examples, see <bpt id="p1">[</bpt>Managed Extensibility Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=144282)</ept>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For a list of the MEF types, see the <ph id="ph1">&lt;xref:System.ComponentModel.Composition?displayProperty=fullName&gt;</ph> namespace.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>