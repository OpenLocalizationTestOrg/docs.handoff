<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">74604c2dfe16e6f90d5c0534fad3d72906dc07cc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\types\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">p1-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">670e7490d39127a91d50e9cdcb6812bf802bcbfe</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9f55fa620beed394a1794e5684c884a723767e23</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Types (C# Programming Guide) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Types (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Types, Variables, and Values</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>C# is a strongly-typed language.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Every variable and constant has a type, as does every expression that evaluates to a value.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Every method signature specifies a type for each input parameter and for the return value.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The information stored in a type can include the following:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The storage space that a variable of the type requires.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The maximum and minimum values that it can represent.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The members (methods, fields, events, and so on) that it contains.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The base type it inherits from.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The location where the memory for variables will be allocated at run time.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The kinds of operations that are permitted.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The compiler uses type information to make sure that all operations that are performed in your code are <bpt id="p1">*</bpt>type safe<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, if you declare a variable of type <bpt id="p1">[</bpt>int<ept id="p1">](../../../csharp/language-reference/keywords/int.md)</ept>, the compiler allows you to use the variable in addition and subtraction operations.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you try to perform those same operations on a variable of type <bpt id="p1">[</bpt>bool<ept id="p1">](../../../csharp/language-reference/keywords/bool.md)</ept>, the compiler generates an error, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideTypes#42<ept id="p2">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_1.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>C and C++ developers, notice that in C#, <bpt id="p1">[</bpt>bool<ept id="p1">](../../../csharp/language-reference/keywords/bool.md)</ept> is not convertible to <bpt id="p2">[</bpt>int<ept id="p2">](../../../csharp/language-reference/keywords/int.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The compiler embeds the type information into the executable file as metadata.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Specifying Types in Variable Declarations</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When you declare a variable or constant in a program, you must either specify its type or use the <bpt id="p1">[</bpt>var<ept id="p1">](../../../csharp/language-reference/keywords/var.md)</ept> keyword to let the compiler infer the type.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideTypes#36<ept id="p2">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_2.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The types of method parameters and return values are specified in the method signature.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following signature shows a method that requires an <bpt id="p1">[</bpt>int<ept id="p1">](../../../csharp/language-reference/keywords/int.md)</ept> as an input argument and returns a string:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideTypes#35<ept id="p2">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_3.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, you cannot declare an <bpt id="p1">[</bpt>int<ept id="p1">](../../../csharp/language-reference/keywords/int.md)</ept> and then assign it a Boolean value of <bpt id="p2">[</bpt>true<ept id="p2">](../../../csharp/language-reference/keywords/true-literal.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>type conversion<ept id="p1">*</ept> that does not cause data loss is performed automatically by the compiler.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A conversion that might cause data loss requires a <bpt id="p1">*</bpt>cast<ept id="p1">*</ept> in the source code.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Casting and Type Conversions<ept id="p1">](../../../csharp/programming-guide/types/casting-and-type-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Built-in Types</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>There are also built-in <ph id="ph1">`string`</ph> and <ph id="ph2">`object`</ph> types.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>These are available for you to use in any C# program.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For a more information about the built-in types, see <bpt id="p1">[</bpt>Reference Tables for Types<ept id="p1">](../../../csharp/language-reference/keywords/reference-tables-for-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Custom Types</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You use the <bpt id="p1">[</bpt>struct<ept id="p1">](../../../csharp/language-reference/keywords/struct.md)</ept>, <bpt id="p2">[</bpt>class<ept id="p2">](../../../csharp/language-reference/keywords/class.md)</ept>, <bpt id="p3">[</bpt>interface<ept id="p3">](../../../csharp/language-reference/keywords/interface.md)</ept>, and <bpt id="p4">[</bpt>enum<ept id="p4">](../../../csharp/language-reference/keywords/enum.md)</ept> constructs to create your own custom types.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>By default, the most frequently used types in the class library are available in any C# program.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Others become available only when you explicitly add a project reference to the assembly in which they are defined.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Framework Class Library<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=217856)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Common Type System</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>It is important to understand two fundamental points about the type system in the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It supports the principle of inheritance.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Types can derive from other types, called <bpt id="p1">*</bpt>base types<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All types, including built-in numeric types such as <ph id="ph1">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph> (C# keyword: <bpt id="p1">[</bpt>int<ept id="p1">](../../../csharp/language-reference/keywords/int.md)</ept>), derive ultimately from a single base type, which is <ph id="ph2">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> (C# keyword: <bpt id="p2">[</bpt>object<ept id="p2">](../../../csharp/language-reference/keywords/object.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This unified type hierarchy is called the <bpt id="p1">[</bpt>Common Type System<ept id="p1">](../../../standard/base-types/common-type-system.md)</ept> (CTS).</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For more information about inheritance in C#, see <bpt id="p1">[</bpt>Inheritance<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/inheritance.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Each type in the CTS is defined as either a <bpt id="p1">*</bpt>value type<ept id="p1">*</ept> or a <bpt id="p2">*</bpt>reference type<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This includes all custom types in the .NET Framework class library and also your own user-defined types.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Types that you define by using the <bpt id="p1">[</bpt>struct<ept id="p1">](../../../csharp/language-reference/keywords/struct.md)</ept> keyword are value types; all the built-in numeric types are <ph id="ph1">`structs`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Types that you define by using the <bpt id="p1">[</bpt>class<ept id="p1">](../../../csharp/language-reference/keywords/class.md)</ept> keyword are reference types.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Reference types and value types have different compile-time rules, and different run-time behavior.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following illustration shows the relationship between value types and reference types in the CTS.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Value Types and Reference Types<ept id="p1">](../../../csharp/programming-guide/types/media/valuetypescts.png "ValueTypesCTS")</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Value types and reference types in the CTS</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can see that the most commonly used types are all organized in the <ph id="ph1">&lt;xref:System&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Value Types</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Value types derive from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>, which derives from <ph id="ph2">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Types that derive from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph> have special behavior in the CLR.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>There is no separate heap allocation or garbage collection overhead for value-type variables.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>There are two categories of value types: <bpt id="p1">[</bpt>struct<ept id="p1">](../../../csharp/language-reference/keywords/struct.md)</ept> and <bpt id="p2">[</bpt>enum<ept id="p2">](../../../csharp/language-reference/keywords/enum.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The built-in numeric types are structs, and they have properties and methods that you can access:</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>But you declare and assign values to them as if they were simple non-aggregate types:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Value types are <bpt id="p1">*</bpt>sealed<ept id="p1">*</ept>, which means, for example, that you cannot derive a type from <ph id="ph1">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <ph id="ph2">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>However, a struct can implement one or more interfaces.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can cast a struct type to an interface type; this causes a <bpt id="p1">*</bpt>boxing<ept id="p1">*</ept> operation to wrap the struct inside a reference type object on the managed heap.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Boxing operations occur when you pass a value type to a method that takes a <ph id="ph1">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> as an input parameter.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](../../../csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You use the <bpt id="p1">[</bpt>struct<ept id="p1">](../../../csharp/language-reference/keywords/struct.md)</ept> keyword to create your own custom value types.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Typically, a struct is used as a container for a small set of related variables, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#1<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/index_4.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For more information about structs, see <bpt id="p1">[</bpt>Structs<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/structs.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For more information about value types in the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>, see <bpt id="p1">[</bpt>Common Type System<ept id="p1">](../../../standard/base-types/common-type-system.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The other category of value types is <bpt id="p1">[</bpt>enum<ept id="p1">](../../../csharp/language-reference/keywords/enum.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>An enum defines a set of named integral constants.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.IO.FileMode?displayProperty=fullName&gt;</ph> enumeration in the .NET Framework class library contains a set of named constant integers that specify how a file should be opened.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideTypes#44<ept id="p2">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_5.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`System.IO.FileMode.Create`</ph> constant has a value of 2.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>However, the name is much more meaningful for humans reading the source code, and for that reason it is better to use enumerations instead of constant literal numbers.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.IO.FileMode?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>All enums inherit from <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph>, which inherits from <ph id="ph2">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>All the rules that apply to structs also apply to enums.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For more information about enums, see <bpt id="p1">[</bpt>Enumeration Types<ept id="p1">](../../../csharp/programming-guide/enumeration-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Reference Types</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A type that is defined as a <bpt id="p1">[</bpt>class<ept id="p1">](../../../csharp/language-reference/keywords/class.md)</ept>, <bpt id="p2">[</bpt>delegate<ept id="p2">](../../../csharp/language-reference/keywords/delegate.md)</ept>, array, or <bpt id="p3">[</bpt>interface<ept id="p3">](../../../csharp/language-reference/keywords/interface.md)</ept> is a <bpt id="p4">*</bpt>reference type<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>At run time, when you declare a variable of a reference type, the variable contains the value <bpt id="p1">[</bpt>null<ept id="p1">](../../../csharp/language-reference/keywords/null.md)</ept> until you explicitly create an instance of the object by using the <bpt id="p2">[</bpt>new<ept id="p2">](../../../csharp/language-reference/keywords/new.md)</ept> operator, or assign it an object that has been created elsewhere by using <ph id="ph1">`new, as shown in the following example:`</ph></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>An interface must be initialized together with a class object that implements it.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`MyClass`</ph> implements <ph id="ph2">`IMyInterface`</ph>, you create an instance of <ph id="ph3">`IMyInterface`</ph> as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>When the object is created, the memory is allocated on the managed heap, and the variable holds only a reference to the location of the object.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Types on the managed heap require overhead both when they are allocated and when they are reclaimed by the automatic memory management functionality of the CLR, which is known as <bpt id="p1">*</bpt>garbage collection<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>However, garbage collection is also highly optimized, and in most scenarios it does not create a performance issue.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For more information about garbage collection, see <bpt id="p1">[</bpt>Automatic Memory Management<ept id="p1">](../../../standard/automatic-memory-management.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>All arrays are reference types, even if their elements are value types.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Arrays implicitly derive from the <ph id="ph1">&lt;xref:System.Array?displayProperty=fullName&gt;</ph> class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideTypes#45<ept id="p2">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_6.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Reference types fully support inheritance.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>When you create a class, you can inherit from any other interface or class that is not defined as <bpt id="p1">[</bpt>sealed<ept id="p1">](../../../csharp/language-reference/keywords/sealed.md)</ept>, and other classes can inherit from your class and override your virtual methods.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>For more information about how to create your own classes, see <bpt id="p1">[</bpt>Classes and Structs<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For more information about inheritance and virtual methods, see <bpt id="p1">[</bpt>Inheritance<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/inheritance.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Types of Literal Values</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In C#, literal values receive a type from the compiler.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You can specify how a numeric literal should be typed by appending a letter to the end of the number.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: <ph id="ph1">`4.56f`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>If no letter is appended, the compiler will infer a type for the literal.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For more information about which types can be specified with letter suffixes, see the reference pages for individual types in <bpt id="p1">[</bpt>Value Types<ept id="p1">](../../../csharp/language-reference/keywords/value-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because literals are typed, and all types derive ultimately from <ph id="ph1">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>, you can write and compile code such as the following:</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideTypes#37<ept id="p2">](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_7.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>A type can be declared with one or more <bpt id="p1">*</bpt>type parameters<ept id="p1">*</ept> that serve as a placeholder for the actual type (the <bpt id="p2">*</bpt>concrete type<ept id="p2">*</ept>) that client code will provide when it creates an instance of the type.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Such types are called <bpt id="p1">*</bpt>generic types<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For example, the .NET Framework type <ph id="ph1">&lt;xref:System.Collections.Generic.List%601?displayProperty=fullName&gt;</ph> has one type parameter that by convention is given the name <bpt id="p1">*</bpt>T<ept id="p1">*</ept>. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to <bpt id="p1">[</bpt>object<ept id="p1">](../../../csharp/language-reference/keywords/object.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Generic collection classes are called <bpt id="p1">*</bpt>strongly-typed collections<ept id="p1">*</ept> because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the <ph id="ph1">`strings`</ph> object in the previous example.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Generics<ept id="p1">](../../../csharp/programming-guide/generics/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Implicit Types, Anonymous Types, and Nullable Types</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>As stated previously, you can implicitly type a local variable (but not class members) by using the <bpt id="p1">[</bpt>var<ept id="p1">](../../../csharp/language-reference/keywords/var.md)</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The variable still receives a type at compile time, but the type is provided by the compiler.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Implicitly Typed Local Variables<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>You can create <bpt id="p1">*</bpt>anonymous types<ept id="p1">*</ept> for this purpose.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Ordinary value types cannot have a value of <bpt id="p1">[</bpt>null<ept id="p1">](../../../csharp/language-reference/keywords/null.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>However, you can create nullable value types by affixing a <ph id="ph1">`?`</ph> after the type.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`int?`</ph> is an <ph id="ph2">`int`</ph> type that can also have the value <bpt id="p1">[</bpt>null<ept id="p1">](../../../csharp/language-reference/keywords/null.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>In the CTS, nullable types are instances of the generic struct type <ph id="ph1">&lt;xref:System.Nullable%601?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Nullable Types<ept id="p1">](../../../csharp/programming-guide/nullable-types/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Related Sections</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For more information, see the following topics:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Casting and Type Conversions<ept id="p1">](../../../csharp/programming-guide/types/casting-and-type-conversions.md)</ept></source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](../../../csharp/programming-guide/types/boxing-and-unboxing.md)</ept></source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Type dynamic<ept id="p1">](../../../csharp/programming-guide/types/using-type-dynamic.md)</ept></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Value Types<ept id="p1">](../../../csharp/language-reference/keywords/value-types.md)</ept></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Reference Types<ept id="p1">](../../../csharp/language-reference/keywords/reference-types.md)</ept></source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes and Structs<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept></source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generics<ept id="p1">](../../../csharp/programming-guide/generics/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>C# Language Specification</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Reference<ept id="p1">](../../../csharp/language-reference/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Conversion of XML Data Types<ept id="p1">](../../../standard/data/xml/conversion-of-xml-data-types.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Integral Types Table<ept id="p1">](../../../csharp/language-reference/keywords/integral-types-table.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>