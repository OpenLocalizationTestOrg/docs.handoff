<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-ffc129d" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ab7fd46168c8108e76c063f6c9384c28527c4dd5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\using-the-xmlserializer-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3df5b870be7309009e3795f587a84523b186851d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1439be6439d3bf1fd46df7235f51d2f77bbfb089</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Using the XmlSerializer Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Using the XmlSerializer Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>DataContractSerializer as the Default</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>By default <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> uses the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class to serialize data types.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This serializer supports the following types:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <ph id="ph1">&lt;xref:System.Xml.XmlElement&gt;</ph> and <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>, which are treated as primitives.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Data contract types (types marked with the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute).</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Types marked with the <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> attribute, which include types that implement the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Types that implement the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Many common collection types, which include many generic collection types.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Many <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> types fall into the latter two categories and are thus serializable.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Arrays of serializable types are also serializable.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For a complete list, see <bpt id="p1">[</bpt>Specifying Data Transfer in Service Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, used together with data contract types, is the recommended way to write new <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Using Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When to Use the XmlSerializer Class</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> also supports the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class is not unique to <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is the same serialization engine that <ph id="ph1">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> Web services use.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class supports a much narrower set of types than the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It also does not require any declarative attributes on the serializable types.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph> the XML Serialization topic in the <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> documentation.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class does not support data contract types.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When using Svcutil.exe or the <bpt id="p1">**</bpt>Add Service Reference<ept id="p1">**</ept> feature in <ph id="ph1">[!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)]</ph> to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If the schema is not compatible with the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is selected.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Manually Switching to the XmlSerializer</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>At times, you may have to manually switch to the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This happens, for example, in the following cases:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When migrating an application from <ph id="ph1">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> Web services to <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>, you may want to reuse existing, <ph id="ph3">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>-compatible types instead of creating new data contract types.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>When creating services that follow the legacy SOAP Encoding standard.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can manually switch to the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class by applying the <ph id="ph2">`XmlSerializerFormatAttribute`</ph> attribute to your service, as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_XmlSerializer#1<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_XmlSerializer#1<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It is important to be careful when switching serialization engines.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The same type can serialize to XML differently depending on the serializer being used.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class only serializes members marked with the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attribute when serializing data contract types.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class serializes any public member.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>See the type in the following code.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_XmlSerializer#2<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_XmlSerializer#2<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If the type is inadvertently used in a service contract where the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class is selected, the <ph id="ph2">`creditCardNumber`</ph> member is serialized, which is probably not intended.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Even though the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <ph id="ph2">&lt;xref:System.ServiceModel.DataContractFormatAttribute&gt;</ph> attribute to the service contract type.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Other important security considerations apply to the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>First, it is strongly recommended that any <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> application that uses the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class is signed with a key that is safeguarded from disclosure.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This recommendation applies both when a manual switch to the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This is because the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> serialization engine supports the loading of <bpt id="p1">*</bpt>pre-generated serialization assemblies<ept id="p1">*</ept> as long as they are signed with the same key as the application.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Of course, an attacker must first gain write access to one of these two locations to attempt this action.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Another threat that exists whenever you use <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is related to write access to the system temporary folder.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> serialization engine creates and uses temporary <bpt id="p1">*</bpt>serialization assemblies<ept id="p1">*</ept> in this folder.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Rules for XmlSerializer support</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You cannot directly apply <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>-compatible attributes to contract operation parameters or return values.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>However, they can be applied to typed messages (message contract body parts), as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_XmlSerializer#3<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_XmlSerializer#3<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, in the following code, <ph id="ph1">`ElementName`</ph> overrides <ph id="ph2">`Name`</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_XmlSerializer#4<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_XmlSerializer#4<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> attribute is not supported when using the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> throws the following exception, which is released prior to <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>: "An element declared at the top level of a schema cannot have <ph id="ph3">`maxOccurs`</ph> &gt; 1.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Provide a wrapper element for 'more' by using <ph id="ph1">`XmlArray`</ph> or <ph id="ph2">`XmlArrayItem`</ph> instead of <ph id="ph3">`XmlElementAttribute`</ph>, or by using the Wrapped parameter style."</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If you receive such an exception, investigate whether this situation applies.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> does not support the <ph id="ph2">&lt;xref:System.Xml.Serialization.SoapIncludeAttribute&gt;</ph> and <ph id="ph3">&lt;xref:System.Xml.Serialization.XmlIncludeAttribute&gt;</ph> attributes in message contracts and operation contracts; use the <ph id="ph4">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attribute instead.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Types that Implement the IXmlSerializable Interface</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Types that implement the <ph id="ph1">`IXmlSerializable`</ph> interface are fully supported by the <ph id="ph2">`DataContractSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute should always be applied to these types to control their schema.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you are serializing polymorphic types you must apply the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> to the type to ensure the correct type is serialized.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>There are three varieties of types that implement <ph id="ph1">`IXmlSerializable`</ph>: types that represent arbitrary content, types that represent a single element, and legacy <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> types.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Content types use a schema provider method specified by the <ph id="ph1">`XmlSchemaProviderAttribute`</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The method does not return <ph id="ph1">`null`</ph> and the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the attribute is left at its default value of <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This is the most common usage of <ph id="ph1">`IXmlSerializable`</ph> types.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Element types are used when an <ph id="ph1">`IXmlSerializable`</ph> type must control its own root element name.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>To mark a type as an element type, either set the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute to <ph id="ph3">`true`</ph> or return <ph id="ph4">`null`</ph> from the schema provider method.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Having a schema provider method is optional for element types – you may specify <ph id="ph1">`null`</ph> instead of the method name in the <ph id="ph2">`XmlSchemaProviderAttribute`</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>However, if <ph id="ph1">`IsAny`</ph> is <ph id="ph2">`true`</ph> and a schema provider method is specified, the method must return <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Legacy <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> types are <ph id="ph2">`IXmlSerializable`</ph> types that are not marked with the <ph id="ph3">`XmlSchemaProviderAttribute`</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Instead, they rely on the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A&gt;</ph> method for schema generation.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This pattern is used for the <ph id="ph1">`DataSet`</ph> type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Do not rely on this pattern and always apply the <ph id="ph1">`XmlSchemaProviderAttribute`</ph> to your <ph id="ph2">`IXmlSerializable`</ph> types.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>IXmlSerializable Content Types</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>When serializing a data member of a type that implements <ph id="ph1">`IXmlSerializable`</ph> and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> implementation can write any XML, which includes adding attributes to the wrapper element.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>After <ph id="ph1">`WriteXml`</ph> is done, the serializer closes the element.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When deserializing a data member of a type that implements <ph id="ph1">`IXmlSerializable`</ph> and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The method must read the entire element, including the start and end tags.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Make sure your <ph id="ph1">`ReadXml`</ph> code handles the case where the element is empty.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Additionally, your <ph id="ph1">`ReadXml`</ph> implementation should not rely on the wrapper element being named a particular way.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The name is chosen by the serializer can vary.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>It is permitted to assign <ph id="ph1">`IXmlSerializable`</ph> content types polymorphically, for example, to data members of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>It is also permitted for the type instances to be null.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Finally, it is possible to use <ph id="ph1">`IXmlSerializable`</ph> types with object graph preservation enabled and with the <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>All these features require the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>-specific namespace).</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Attributes to Ignore when Implementing ReadXml</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Before passing control to your <ph id="ph1">`ReadXml`</ph> code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For example, if "nil" is <ph id="ph1">`true`</ph>, a null value is deserialized and <ph id="ph2">`ReadXml`</ph> is not called.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The polymorphically-assigned type’s implementation of <ph id="ph1">`ReadXml`</ph> is called.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In any case, a <ph id="ph1">`ReadXml`</ph> implementation should ignore these special attributes because they are handled by the deserializer.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Schema Considerations for IXmlSerializable Content Types</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>When exporting schema and an <ph id="ph1">`IXmlSerializable`</ph> content type, the schema provider method is called.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> is passed to the schema provider method.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The method can add any valid schema to the schema set.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The schema set contains the schema that is already known at the time when schema export occurs.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>When the schema provider method must add an item to the schema set, it must determine whether an <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchema&gt;</ph> with the appropriate namespace already exists in the set.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If it does, the schema provider method must add the new item to the existing <ph id="ph1">`XmlSchema`</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Otherwise, it must create a new <ph id="ph1">`XmlSchema`</ph> instance.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This is important if arrays of <ph id="ph1">`IXmlSerializable`</ph> types are being used.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, if you have an <ph id="ph1">`IXmlSerializable`</ph> type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In addition to adding types to the <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph>, the schema provider method for content types must return a non-null value.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>It can return an <ph id="ph1">&lt;xref:System.Xml.XmlQualifiedName&gt;</ph> that specifies the name of the schema type to use for the given <ph id="ph2">`IXmlSerializable`</ph> type.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>This qualified name also serves as the data contract name and namespace for the type.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>However, it is expected that by the time all related types are exported (the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A&gt;</ph> method is called for all relevant types on the <ph id="ph2">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter&gt;</ph> and the <ph id="ph3">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A&gt;</ph> property is accessed), the type exists in the schema set.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Accessing the <ph id="ph1">`Schemas`</ph> property before all relevant <ph id="ph2">`Export`</ph> calls have been made can result in an <ph id="ph3">&lt;xref:System.Xml.Schema.XmlSchemaException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> the export process, see <bpt id="p1">[</bpt>Exporting Schemas from Classes<ept id="p1">](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The schema provider method can also return the <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaType&gt;</ph> to use.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The type may or may not be anonymous.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If it is anonymous, the schema for the <ph id="ph1">`IXmlSerializable`</ph> type is exported as an anonymous type every time the <ph id="ph2">`IXmlSerializable`</ph> type is used as a data member.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IXmlSerializable`</ph> type still has a data contract name and namespace.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>(This is determined as described in <bpt id="p1">[</bpt>Data Contract Names<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-names.md)</ept> except that the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the <ph id="ph2">`XmlSchemaSet`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>This case is equivalent to returning the <ph id="ph1">`XmlQualifiedName`</ph> of the type.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Additionally, a global element declaration is exported for the type.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If the type does not have the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlRootAttribute&gt;</ph> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the type has the <ph id="ph1">`XmlRootAttribute`</ph> attribute applied to it, the global element declaration is exported using the following: <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The defaults with <ph id="ph1">`XmlRootAttribute`</ph> applied are the data contract name, a blank namespace and "nillable" being <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The same global element declaration rules apply to legacy dataset types.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`XmlRootAttribute`</ph> cannot override global element declarations added through custom code, either added to the <ph id="ph2">`XmlSchemaSet`</ph> using the schema provider method or through <ph id="ph3">`GetSchema`</ph> for legacy dataset types.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>IXmlSerializable Element Types</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IXmlSerializable`</ph> element types have either the <ph id="ph2">`IsAny`</ph> property set to <ph id="ph3">`true`</ph> or have their schema provider method return <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>However, there are some important differences:</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`WriteXml`</ph> implementation is expected to write exactly one element (which could of course contain multiple child elements).</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The element may be empty.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ReadXml`</ph> implementation should not read the wrapper element.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>It is expected to read the one element that <ph id="ph1">`WriteXml`</ph> produces.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling <ph id="ph1">`WriteXml`</ph>, as with content types.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that <ph id="ph1">`WriteXml`</ph> writes, unless a root name and namespace are explicitly specified when constructing the serializer in the <ph id="ph2">`DataContractSerializer`</ph> or <ph id="ph3">`NetDataContractSerializer`</ph> constructors.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Serialization and Deserialization<ept id="p1">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>When serializing an element type at the top level without specifying the root name and namespace at construction time, <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A&gt;</ph> essentially do nothing and <ph id="ph3">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A&gt;</ph> calls <ph id="ph4">`WriteXml`</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>In this mode, the object being serialized cannot be <ph id="ph1">`null`</ph> and cannot be polymorphically assigned.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Also, object graph preservation cannot enabled and the <ph id="ph1">`NetDataContractSerializer`</ph> cannot be used.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>When deserializing an element type at the top level without specifying the root name and namespace at construction time, <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A&gt;</ph> returns <ph id="ph2">`true`</ph> if it can find the start of any element.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> with the <ph id="ph2">`verifyObjectName`</ph> parameter set to <ph id="ph3">`true`</ph> behaves in the same way as <ph id="ph4">`IsStartObject`</ph> before actually reading the object.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ReadObject`</ph> then passes control to <ph id="ph2">`ReadXml`</ph> method.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The schema exported for element types is the same as for the <ph id="ph1">`XmlElement`</ph> type as described in an earlier section, except that the schema provider method can add any additional schema to the <ph id="ph2">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> as with content types.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`XmlRootAttribute`</ph> attribute with element types is not allowed, and global element declarations are never emitted for these types.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Differences from the XmlSerializer</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IXmlSerializable`</ph> interface and the <ph id="ph2">`XmlSchemaProviderAttribute`</ph> and <ph id="ph3">`XmlRootAttribute`</ph> attributes are also understood by the <ph id="ph4">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> .</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>However, there are some differences in how these are treated in the data contract model.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The important differences are summarized in the following list:</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The schema provider method must be public to be used in the <ph id="ph1">`XmlSerializer`</ph>, but does not have to be public to be used in the data contract model.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The schema provider method is called when <ph id="ph1">`IsAny`</ph> is <ph id="ph2">`true`</ph> in the data contract model but not with the <ph id="ph3">`XmlSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`XmlRootAttribute`</ph> attribute is not present for content or legacy dataset types, the <ph id="ph2">`XmlSerializer`</ph> exports a global element declaration in the blank namespace.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>In the data contract model, the namespace used is normally the data contract namespace as described earlier.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Be aware of these differences when creating types that are used with both serialization technologies.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Importing IXmlSerializable Schema</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>When importing a schema generated from <ph id="ph1">`IXmlSerializable`</ph> types, there are a few possibilities:</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The generated schema may be a valid data contract schema as described in <bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>In this case, schema can be imported as usual and regular data contract types are generated.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The generated schema may not be a valid data contract schema.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>In this case, you can import the schema as <ph id="ph1">`IXmlSerializable`</ph> types.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>This import mode is not on by default but can easily be enabled – for example, with the <ph id="ph1">`/importXmlTypes`</ph> command-line switch to the <bpt id="p1">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id="p1">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>This is described in detail in the <bpt id="p1">[</bpt>Importing Schema to Generate Classes<ept id="p1">](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Note that you must work directly with the XML for your type instances.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the <ph id="ph1">`XmlSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You may want to reuse your existing <ph id="ph1">`IXmlSerializable`</ph> types in the proxy instead of generating new ones.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This corresponds to using the <ph id="ph1">`/reference`</ph> switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>XmlSerializer Legacy Behavior</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The file was then compiled into an assembly.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This behavior had some undesirable consequences like slowing the startup time for the serializer.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Some developers may wish to see the generated C# code.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>You can specify to use this legacy behavior by the following configuration:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If you run into compatibility issues,  such as the <ph id="ph1">`XmlSerializer`</ph> failing to serialize a derived class with a non-public new override, you can switch back to the  <ph id="ph2">`XMLSerializer`</ph> legacy behavior by using the following configuration:</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`&lt;xmlSerializer useLegacySerializerGeneration="true"/&gt;`</ph> switch only works on a machine running .NET Framework 4.5 or later version.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The above <ph id="ph1">`appSettings`</ph> approach works on all .NET Framework versions.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.DataContractFormatAttribute&gt;</ph></source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph></source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph></source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph></source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Specifying Data Transfer in Service Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Using Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer<ept id="p1">](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>