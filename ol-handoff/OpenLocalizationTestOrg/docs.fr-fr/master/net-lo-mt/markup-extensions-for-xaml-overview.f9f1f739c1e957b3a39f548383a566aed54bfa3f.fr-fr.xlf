<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-ffc129d" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6394d71ae420bf4557d5fcfdb9a0e50b6feb5c23</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\xaml-services\markup-extensions-for-xaml-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">26b2b7cce84e7072782960e1a1c6b03c7abeb3a9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6e273e21450722962211936483592b83679015e6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Markup Extensions for XAML Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Markup Extensions for XAML Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Markup extensions are a XAML technique for obtaining a value that is neither a primitive nor a specific XAML type.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For attribute usage, markup extensions use the known character sequence of an opening curly brace <ph id="ph1">`{`</ph> to enter the markup extension scope, and a closing curly brace <ph id="ph2">`}`</ph> to exit.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When using .NET Framework XAML Services, you can use some of the predefined XAML language markup extensions from the System.Xaml assembly.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can also subclass from the <ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph> class, defined in System.Xaml, and define your own markup extensions.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Or you can use markup extensions defined by a particular framework if you are already referencing that framework .</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When a markup extension usage is accessed, the XAML object writer can provide services to a custom <ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph> class through a service connection point in the <ph id="ph2">&lt;xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=fullName&gt;</ph> override.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The services can be used to obtain context about the usage, specific capabilities of the object writer, XAML schema context, and so on.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>XAML-Defined Markup Extensions</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Several markup extensions are implemented by .NET Framework XAML Services for XAML language support.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>These markup extensions correspond to parts of the specification of XAML as a language.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These are typically identifiable by the <ph id="ph1">`x:`</ph> prefix in the syntax as seen in common usage.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The .NET Framework XAML Services implementations for these XAML language elements all derive from the  <ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph> base class .</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`x:`</ph> prefix is used for the typical XAML namespace mapping of the XAML language namespace, in the root element of a XAML production.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">[!INCLUDE[vs_current_short](../../../includes/vs-current-short-md.md)]</ph> project and page templates for various specific frameworks initiate a XAML file using this <ph id="ph2">`x:`</ph> mapping.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default <ph id="ph1">`x:`</ph> mapping as a means of identifying those entities that are a defined part of the XAML language XAML namespace, as opposed to a specific framework's default XAML namespace or other arbitrary CLR or XML namespaces.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>x:Type</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`x:Type`</ph> supplies the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for the named type.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This functionality is used most frequently in deferral mechanisms that use underlying CLR type and type derivation as a grouping moniker or identifier.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>WPF styles and templates, and their usage of <ph id="ph1">`TargetType`</ph> properties, are a specific example.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>x:Type Markup Extension<ept id="p1">](../../../docs/framework/xaml-services/x-type-markup-extension.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>x:Static</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`x:Static`</ph> produces static values from value-type code entities that are not directly the type of a property's value, but can be evaluated to that type.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This is useful for specifying values that already exist as well-known constants in a type definition.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>x:Static Markup Extension<ept id="p1">](../../../docs/framework/xaml-services/x-static-markup-extension.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>x:Null</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`x:Null`</ph> specifies <ph id="ph2">`null`</ph> as a value for a XAML member.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Depending on the design of specific types or on larger framework concepts, <ph id="ph1">`null`</ph> is not always a default value for a property, or the implied value of an empty string attribute.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>x:Null Markup Extension<ept id="p1">](../../../docs/framework/xaml-services/x-null-markup-extension.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>x:Array</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`x:Array`</ph> supports creation of general arrays in XAML syntax in cases where the collection support that is provided by base elements and control models is deliberately not used.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>x:Array Markup Extension<ept id="p1">](../../../docs/framework/xaml-services/x-array-markup-extension.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In XAML 2009 specifically, arrays are accessed as language primitives instead of as an extension.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>XAML 2009 Language Features<ept id="p1">](../../../docs/framework/xaml-services/xaml-2009-language-features.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>x:Reference</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`x:Reference`</ph> is part of XAML 2009, an extension of the original (2006) language set.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`x:Reference`</ph> represents a reference to another existing object in an object graph.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>That object is identified by its <ph id="ph1">`x:Name`</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>x:Reference Markup Extension<ept id="p1">](../../../docs/framework/xaml-services/x-reference-markup-extension.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Other x: Constructs</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Other <ph id="ph1">`x:`</ph> constructs to support XAML language features exist, but these are not implemented as markup extensions.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>XAML Namespace (x:) Language Features<ept id="p1">](../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The MarkupExtension Base Class</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To define a custom markup extension that can interact with the default implementations of XAML readers and XAML writers in System.Xaml, you derive a class from the abstract <ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>That class has one method to override, which is <ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You might also need to define additional constructors to support arguments to the markup extension usage, and matching settable properties.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Through <ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A&gt;</ph>, a custom markup extension has access to a service context that reports the environment where the markup extension is actually invoked by a XAML processor.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In the load path this is typically a <ph id="ph1">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In the save path this is typically a <ph id="ph1">&lt;xref:System.Xaml.XamlXmlWriter&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Each report the service context as an internal XAML service provider context class that implements a service provider pattern.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information about the available services and what they represent, see <bpt id="p1">[</bpt>Type Converters and Markup Extensions for XAML<ept id="p1">](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Your markup extension class must use a public access level; XAML processors must always be able to instantiate the markup extension's support class in order to use its services.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Defining the Support Type for a Custom Markup Extension</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>When you use .NET Framework XAML Services or frameworks that build on .NET Framework XAML Services, you have two choices for how to name the markup extension support type.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The type name is relevant to how XAML object writers attempt to access and invoke a markup extension support type when they encounter a markup extension usage in XAML.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Use one of the following naming strategies:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Name the type name to be an exact match to the XAML markup usage token.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, to support a <ph id="ph1">`{Collate ...}`</ph> extension usage, name the support type <ph id="ph2">`Collate`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Name the type name to be the usage string token plus the suffix <ph id="ph1">`Extension`</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For example, to support a <ph id="ph1">`{Collate ...}`</ph> extension usage, name the support type <ph id="ph2">`CollateExtension`</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The order of lookup is to look for the <ph id="ph1">`Extension`</ph>-suffixed class name first and then look for the class name without the <ph id="ph2">`Extension`</ph> suffix.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>From the markup usage perspective, including the <ph id="ph1">`Extension`</ph> suffix as part of the usage is valid.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>However, this behaves as if <ph id="ph1">`Extension`</ph> is truly part of the class name, and XAML object writers would fail to resolve a markup extension support class for that usage if the support class did not have the <ph id="ph2">`Extension`</ph> suffix.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The Default Constructor</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For all markup extension support types, you should expose a public default constructor.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A default constructor is required for any case where a XAML object writer instantiates the markup extension from an object element usage.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Supporting object element usage is a fair expectation for a markup extension, particularly for serialization.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, you can implement a markup extension without a public constructor if you only intend to support attribute usages of the markup extension.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If your markup extension usage has no arguments, the default constructor is required to support usage.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Constructor Patterns and Positional Arguments for a Custom Markup Extension</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For a markup extension with intended argument usage, the public constructors must correspond to the modes of the intended usage.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In other words, if your markup extension is designed to require one positional argument as a valid usage, you should support a public constructor with one input parameter that takes the positional argument.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, suppose the <ph id="ph1">`Collate`</ph> markup extension is intended to support only a mode where there is one positional argument that represents its mode, specified as a <ph id="ph2">`CollationMode`</ph> enumeration constant.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In this case, there should be a constructor with the following form:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>At a basic level, the arguments passed to a markup extension are a string because they are being forwarded from the markup's attribute values.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can make all of your arguments strings and work with input at that level.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>However, you do have access to certain processing that occurs before the markup extension arguments are passed to the support class.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The processing works conceptually as if the markup extension is an object to be created, and then its member values are set.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Each specified property to set is evaluated similar to how a specified member can be set on a created object when XAML is parsed.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>There are two important differences:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>As noted previously, a markup extension support type does not need to have a default constructor in order to be instantiated in XAML.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Its object construction is deferred until its possible arguments in the text syntax are tokenized and evaluated as either positional or named arguments, and the appropriate constructor is called at that time.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Markup extensions usages can be nested.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The innermost markup extension is evaluated first.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Therefore, you can assume such a usage and declare one of the construction parameters to be a type that requires a value converter (such as a markup extension) to produce.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A reliance on such processing was shown in the previous example.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The .NET Framework XAML Services XAML object writer processes enumeration constant names into enumerated values at a native level.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Processing text syntax of a markup extension positional parameter can also rely on a type converter that is associated with the type that is in the construction argument.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The arguments are called positional arguments because the order in which the tokens in the usage is encountered corresponds to the positional order of the constructor parameter to which they are assigned.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, consider the following constructor signature:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A XAML processor expects two positional arguments for this markup extension.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>If there was a usage <ph id="ph1">`{Collate AlphaUp,{x:Reference circularFile}}`</ph>, the <ph id="ph2">`AlphaUp`</ph> token is sent to the first parameter and evaluated as a <ph id="ph3">`CollationMode`</ph> enumeration named constant.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The result of the inner <ph id="ph1">`x:Reference`</ph> is sent to the second parameter and evaluated as an object.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In the XAML specified rules for markup extension syntax and processing, the comma is the delimiter between arguments, whether those arguments are positional arguments or named arguments.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Duplicate Arity of Positional Arguments</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If a XAML object writer encounters a markup extension usage with positional arguments, and there are multiple constructor arguments that take that number of arguments (a duplicate arity), that is not necessarily an error.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The behavior depends on a customizable XAML schema context setting, <ph id="ph1">&lt;xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">&lt;xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A&gt;</ph> is <ph id="ph2">`true`</ph>, a XAML object writer should not throw an exception only for reasons of duplicate arity.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Behavior beyond that point is not strictly defined.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The basic design assumption is that the schema context has type information available for the specific parameters and can attempt explicit casts that match the duplicate candidates to see which signature might be the best match.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An exception might still be thrown if no signatures can pass the tests that are imposed by that particular schema context that is running on a XAML object writer.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">&lt;xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A&gt;</ph> is <ph id="ph2">`false`</ph> in the CLR-based <ph id="ph3">&lt;xref:System.Xaml.XamlSchemaContext&gt;</ph> for .NET Framework XAML Services.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Thus, the default <ph id="ph1">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph> throws exceptions if it encounters a markup extension usage where there is duplicate arity in the backing type's constructors.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Named Arguments for a Custom Markup Extension</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Markup extensions as specified by XAML can also use a named arguments form for usage.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>At the first level of tokenization, the text syntax is divided into arguments.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The presence of an equals sign (=) within any argument identifies an argument as a named argument.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Such an argument is also tokenized into a name/value pair.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The name in this case names a public settable property of the markup extension's support type.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you intend to support named argument usage, you should provide these public settable properties.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The properties can be inherited properties as long as they remain public.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Accessing Service Provider Context from a Markup Extension Implementation</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The services available are the same for any value converter.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The difference is in how each value converter receives the service context.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Accessing services and the services available are documented in the topic <bpt id="p1">[</bpt>Type Converters and Markup Extensions for XAML<ept id="p1">](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Property Element Usage of a Markup Extension</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The scenarios for markup extension usages are often designed around using the markup extension in attribute usage.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, it is also potentially possible to define the backing class to support property element usage.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>To support property element usage of your markup extension, define a public default constructor.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This should be an instance constructor not a static constructor.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This is required because a XAML processor must generally invoke the default constructor on any object element it processes from markup, and this includes markup extension classes as object elements.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For advanced scenarios, you can define non-default construction paths for classes.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>x:FactoryMethod Directive<ept id="p1">](../../../docs/framework/xaml-services/x-factorymethod-directive.md)</ept>.) However, you should not use these patterns for markup extension purposes because this makes discovery of the usage pattern much more difficult, both for designers and for users of raw markup.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Attributing for a Custom Markup Extension</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>To support both design environments and certain XAML object writer scenarios, you should attribute a markup extension support type with several CLR attributes.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>These attributes report the intended markup extension usage.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute&gt;</ph> reports the <ph id="ph2">&lt;xref:System.Type&gt;</ph> information for the object type that <ph id="ph3">&lt;xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>By its pure signature, <ph id="ph1">&lt;xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>But various consumers might want more precise return type information.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This includes:</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Designers and IDEs, who might be able to provide type-aware support for markup extension usages.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Advanced implementations of <ph id="ph1">`SetMarkupExtension`</ph> handlers on target classes, which might rely on reflection to determine a markup extension's return type instead of branching on specific known <ph id="ph2">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph> implementations by name.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Serialization of Markup Extension Usages</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>When a XAML object writer processes a markup extension usage and calls <ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A&gt;</ph>, the context for it previously being a markup extension usage persists in the XAML node stream but not in the object graph.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In the object graph, only the value is preserved.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>If you have design scenarios or other reasons for persisting the original markup extension usage into the serialized output, you must design your own infrastructure for tracking the markup extension usages from the load path XAML node stream.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>You can implement behavior to recreate the elements of the node stream from the load path and play them back to XAML writers for serialization in the save path, substituting for the value in the appropriate position of the node stream.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Markup Extensions in the XAML Node Stream</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>If you are working with a XAML node stream on the load path, a markup extension usage appears in the node stream as an object.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If the markup extension usage uses positional arguments, it is represented as a start object with an initialization value.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>As a rough text representation, the node stream resembles the following:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`StartObject`</ph> (<ph id="ph2">&lt;xref:System.Xaml.XamlType&gt;</ph> is the markup extension's definition type, not its return type)</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`StartMember`</ph> (name of the <ph id="ph2">&lt;xref:System.Xaml.XamlMember&gt;</ph> is <ph id="ph3">`_InitializationText`</ph>)</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Value`</ph> (value is the positional arguments as a string including the intervening delimiters)</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>A markup extension usage with named arguments is represented as an object with members of the relevant names, each set with text string values.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Actually invoking the <ph id="ph1">`ProvideValue`</ph> implementation of a markup extension requires the XAML schema context because that requires type-mapping and creating a markup extension support type instance.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This is one reason why markup extension usages are preserved this way in the default .NET Framework XAML Services node streams -  the reader part of a load path often does not have the necessary XAML schema context available.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If you are working with a XAML node stream on the save path, there generally is nothing present in an object graph representation that can inform you that the object to serialize was originally provided by a markup extension usage and a <ph id="ph1">`ProvideValue`</ph> result.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Scenarios that need to persist markup extension usages for round-tripping while also capturing other changes in the object graph must devise their own techniques for preserving the knowledge of a markup extension usage from the original XAML input.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For example, to restore the markup extension usages, you may need to work with the node stream on the save path in order to restore markup extension usages, or perform some type of merge between the original XAML and the round-tripped XAML.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Some XAML-implementing frameworks such as WPF use intermediate types (expressions) to help represent cases where markup extension usages provided the values.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.MarkupExtension&gt;</ph></source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Type Converters and Markup Extensions for XAML<ept id="p1">](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Markup Extensions and WPF XAML<ept id="p1">](../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>