<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f653dd83c9778dddfe0e52db27065f7d73866e37</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\language-reference\operators\operator-precedence.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f32fd09710cb4da853cc8cb42fc474228ce7ed49</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">675a2a0e130d669e88f703ec4bd8bdede471be1a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Operator Precedence in Visual Basic | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Operator Precedence in Visual Basic</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>When several operations occur in an expression, each part is evaluated and resolved in a predetermined order called <bpt id="p1">*</bpt>operator precedence<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Precedence Rules</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When expressions contain operators from more than one category, they are evaluated according to the following rules:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The arithmetic and concatenation operators have the order of precedence described in the following section, and all have greater precedence than the comparison, logical, and bitwise operators.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>All comparison operators have equal precedence, and all have greater precedence than the logical and bitwise operators, but lower precedence than the arithmetic and concatenation operators.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The logical and bitwise operators have the order of precedence described in the following section, and all have lower precedence than the arithmetic, concatenation, and comparison operators.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Operators with equal precedence are evaluated left to right in the order in which they appear in the expression.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Precedence Order</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Operators are evaluated in the following order of precedence:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Await Operator</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Await</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Arithmetic and Concatenation Operators</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Exponentiation (<ph id="ph1">`^`</ph>)</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Unary identity and negation (<ph id="ph1">`+`</ph>, <ph id="ph2">`–`</ph>)</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Multiplication and floating-point division (<ph id="ph1">`*`</ph>, <ph id="ph2">`/`</ph>)</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Integer division (<ph id="ph1">`\`</ph>)</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Modulus arithmetic (<ph id="ph1">`Mod`</ph>)</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Addition and subtraction (<ph id="ph1">`+`</ph>, <ph id="ph2">`–`</ph>)</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>String concatenation (<ph id="ph1">`&amp;`</ph>)</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Arithmetic bit shift (<ph id="ph1">`&lt;&lt;`</ph>, <ph id="ph2">`&gt;&gt;`</ph>)</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Comparison Operators</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>All comparison operators (<ph id="ph1">`=`</ph>, <ph id="ph2">`&lt;&gt;`</ph>, <ph id="ph3">`&lt;`</ph>, <ph id="ph4">`&lt;=`</ph>, <ph id="ph5">`&gt;`</ph>, <ph id="ph6">`&gt;=`</ph>, <ph id="ph7">`Is`</ph>, <ph id="ph8">`IsNot`</ph>, <ph id="ph9">`Like`</ph>, <ph id="ph10">`TypeOf`</ph>...<ph id="ph11">`Is`</ph>)</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Logical and Bitwise Operators</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Negation (<ph id="ph1">`Not`</ph>)</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Conjunction (<ph id="ph1">`And`</ph>, <ph id="ph2">`AndAlso`</ph>)</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Inclusive disjunction (<ph id="ph1">`Or`</ph>, <ph id="ph2">`OrElse`</ph>)</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Exclusive disjunction (<ph id="ph1">`Xor`</ph>)</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`=`</ph> operator is only the equality comparison operator, not the assignment operator.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The string concatenation operator (<ph id="ph1">`&amp;`</ph>) is not an arithmetic operator, but in precedence it is grouped with the arithmetic operators.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Is`</ph> and <ph id="ph2">`IsNot`</ph> operators are object reference comparison operators.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>They do not compare the values of two objects; they check only to determine whether two object variables refer to the same object instance.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Associativity</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When operators of equal precedence appear together in an expression, for example multiplication and division, the compiler evaluates each operation as it encounters it from left to right.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The first expression evaluates the division 96 / 8 (which results in 12) and then the division 12 / 4, which results in three.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Because the compiler evaluates the operations for <ph id="ph1">`n1`</ph> from left to right, the evaluation is the same when that order is explicitly indicated for <ph id="ph2">`n2`</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`n1`</ph> and <ph id="ph2">`n2`</ph> have a result of three.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>By contrast, <ph id="ph1">`n3`</ph> has a result of 48, because the parentheses force the compiler to evaluate 8 / 4 first.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Because of this behavior, operators are said to be <bpt id="p1">*</bpt>left associative<ept id="p1">*</ept> in <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Overriding Precedence and Associativity</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can use parentheses to force some parts of an expression to be evaluated before others.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This can override both the order of precedence and the left associativity.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> always performs operations that are enclosed in parentheses before those outside.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>However, within parentheses, it maintains ordinary precedence and associativity, unless you use parentheses within the parentheses.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>= Operator<ept id="p1">](../../../visual-basic/language-reference/operators/assignment-operator.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Is Operator<ept id="p1">](../../../visual-basic/language-reference/operators/is-operator.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IsNot Operator<ept id="p1">](../../../visual-basic/language-reference/operators/isnot-operator.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Like Operator<ept id="p1">](../../../visual-basic/language-reference/operators/like-operator.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>TypeOf Operator<ept id="p1">](../../../visual-basic/language-reference/operators/typeof-operator.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Await Operator<ept id="p1">](../../../visual-basic/language-reference/operators/await-operator.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Operators Listed by Functionality<ept id="p1">](../../../visual-basic/language-reference/operators/operators-listed-by-functionality.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Operators and Expressions<ept id="p1">](../../../visual-basic/programming-guide/language-features/operators-and-expressions/index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>