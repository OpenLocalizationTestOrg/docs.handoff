<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b2ce10b3c079ff2c881f6dbe297ead33b8254476</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\tutorials\microservices.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_hi-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2e0607fce20d24f5aaa9d99c1bf2dc5a86eab394</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c05b7ae1cbe0edd8021511cb24037f2ff709bfb7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Microservices hosted in Docker | C#</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn to create asp.net core services that run in Docker containers</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, Docker, C#, ASP.NET, Microservice</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Microservices hosted in Docker</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Introduction</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This tutorial details the tasks necessary to build and deploy an ASP.NET Core microservice in a Docker container.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>During the course of this tutorial, you'll learn:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to generate an ASP.NET Core application using Yeoman</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How to create a development Docker environment</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>How to build a Docker image based on an existing image.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>How to deploy your service into a Docker container.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Along the way, you'll also see some C# language features:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>How to convert C# objects into JSON payloads.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>How to build immutable Data Transfer Objects</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>How to process incoming HTTP Requests and generate the HTTP Response</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>How to work with nullable value types</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can <bpt id="p1">[</bpt>view or download the sample app<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/WeatherMicroservice)</ept> for this topic.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For download instructions, see <bpt id="p1">[</bpt>Samples and Tutorials<ept id="p1">](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Why Docker?</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Docker makes it easy to create standard machine images to host your services in a data center, or the public cloud.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Docker enables you to configure the image, and replicate it as needed to scale the installation of your application.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>All the code in this tutorial will work in any .NET Core environment.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The additional tasks for a Docker installation will work for an ASP.NET Core application.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You’ll need to setup your machine to run .NET core.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can find the installation instructions on the <bpt id="p1">[</bpt>.NET Core<ept id="p1">](https://www.microsoft.com/net/core)</ept> page.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can run this application on Windows, Ubuntu Linux, macOS or in a Docker container.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You’ll need to install your favorite code editor.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The descriptions below use <bpt id="p1">[</bpt>Visual Studio Code<ept id="p1">](https://code.visualstudio.com/)</ept> which is an open source, cross platform editor.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, you can use whatever tools you are comfortable with.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You'll also need to install the Docker engine.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>Docker Installation page<ept id="p1">](http://www.docker.com/products/docker)</ept> for instructions for your platform.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Docker can be installed in many Linux distributions, macOS, or Windows.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The page referenced above contains sections to each of the available installations.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Most components to be installed are done by a package manager.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If you have node.js's package manager <ph id="ph1">`npm`</ph> installed you can skip this step.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Otherwise install the latest NodeJs from <bpt id="p1">[</bpt>nodejs.org<ept id="p1">](https://nodejs.org)</ept> which will install the npm package manager.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>At this point you will need to install a number of command line tools that support ASP.NET core development.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The command line templates use Yeoman, Bower, Grunt, and Gulp.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you have them installed that is good, otherwise type the following into your favorite shell:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-g`</ph> option indicates that it is a global install, and those tools are available system wide.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>(A local install scopes the package to a single project).</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Once you've installed those core tools, you need to install the yeoman asp.net template generators:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Create the Application</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Now that you've installed all the tools, create a new asp.net core application.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>To use the command line generator, execute the following yeoman command in your favorite shell:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This command prompts you to select what Type of application you want to create.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For this microservice, you want the simplest, most lightweight web application possible, so select 'Empty Web Application'.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The template will prompt you for a name.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Select 'WeatherMicroservice'.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The template creates eight files for you:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A .gitignore, customized for asp.net core applications.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A Startup.cs file.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This contains the basis of the application.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A Program.cs file.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This contains the entry point of the application.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A WeatherMicroservice.csproj file.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This is the build file for the application.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A Dockerfile.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This script creates a Docker image for the application.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A README.md.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This contains links to other asp.net core resources.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A web.config file.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This contains basic configuration information.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A runtimeconfig.template.json file.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This contains debugging settings used by IDEs.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Now you can run the template generated application.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>That's done using a series of tools from the command line.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dotnet`</ph> command runs the tools necessary for .NET development.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Each verb executes a different command</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The first step is to restore all the dependencies:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Dotnet restore uses the NuGet package manager to install all the necessary packages into the application directory.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It also generates a project.json.lock file.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This file contains information about each package that is referenced.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>After restoring all the dependencies, you build the application:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>And once you build the application, you run it from the command line:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The default configuration listens to http://localhost:5000.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can open a browser and navigate to that page and see a "Hello World!"</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>message.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Anatomy of an ASP.NET Core application</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Now that you've built the application, let's look at how this functionality is implemented.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>There are two of the generated files that are particularly interesting at this point: project.json and Startup.cs.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Project.json contains information about the project.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The two nodes you'll often work with are 'dependencies' and 'frameworks'.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The dependencies node lists all the packages that are needed for this application.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>At the moment, this is a small node, needing only the packages that run the web server.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The 'frameworks' node specifies the versions and configurations of the .NET framework that will run this application.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The application is implemented in Startup.cs.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This file contains the startup class.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The two methods are called by the asp.net core infrastructure to configure and run the application.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ConfigureServices`</ph> method describes the services that are necessary for this application.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>You're building a lean microservice, so it doesn't need to configure any dependencies.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Configure`</ph> method configures the handlers for incoming HTTP Requests.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The template generates a simple handler that responds to any request with the text 'Hello World!'.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Build a microservice</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The service you're going to build will deliver weather reports from anywhere around the globe.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In a production application, you'd call some service to retrieve weather data.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For our sample, we'll generate a random weather forecast.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>There are a number of tasks you'll need to perform in order to implement our random weather service:</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Parse the incoming request to read the latitude and longitude.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Generate some random forecast data.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Convert that random forecast data from C# objects into JSON packets.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Set the response header to indicate that your service sends back JSON.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Write the response.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The next sections walk you through each of these steps.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Parsing the Query String.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>You'll begin by parsing the query string.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The service will accept 'lat' and 'long' arguments on the query string in this form:</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>All the changes you need to make are in the lambda expression defined as the argument to <ph id="ph1">`app.Run`</ph> in your startup class.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The argument on the lambda expression is the <ph id="ph1">`HttpContext`</ph> for the request.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>One of its properties is the <ph id="ph1">`Request`</ph> object.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Request`</ph> object has a <ph id="ph2">`Query`</ph> property that contains a dictionary of all the values on the query string for the request.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The first addition is to find the latitude and longitude values:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ReadQueryString<ept id="p2">]</ept><bpt id="p3">(../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#ReadQueryString "</bpt>read variables from the query string<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The Query dictionary values are <ph id="ph1">`StringValue`</ph> type.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>That type can contain a collection of strings.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For your weather service, each value is a single string.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>That's why there's the call to <ph id="ph1">`FirstOrDefault()`</ph> in the code above.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Next, you need to convert the strings to doubles.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The method you'll use to convert the string to a double is <ph id="ph1">`double.TryParse()`</ph>:</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This method leverages C# out parameters to indicate if the input string can be converted to a double.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If the string does represent a valid representation for a double, the method returns true, and the <ph id="ph1">`result`</ph> argument contains the value.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If the string does not represent a valid double, the method returns false.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You can adapt that API with the use of an <bpt id="p1">*</bpt>extension method<ept id="p1">*</ept> that returns a <bpt id="p2">*</bpt>nullable double<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>nullable value type<ept id="p1">*</ept> is a type that represents some value type, and can also hold a missing, or null value.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>A nullable type is represented by appending the <ph id="ph1">`?`</ph> character to the type declaration.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Extension methods are methods that are defined as static methods, but by adding the <ph id="ph1">`this`</ph> modifier on the first parameter, can be called as though they are members of that class.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Extension methods may only be defined in static classes.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Here's the definition of the class containing the extension method for parse:</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TryParseExtension<ept id="p2">]</ept><bpt id="p3">(../../../samples/csharp/getting-started/WeatherMicroservice/Extensions.cs#TryParseExtension "</bpt>try parse to a nullable<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`default(double?)`</ph> expression returns the default value for the <ph id="ph2">`double?`</ph> type.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>That default value is the null (or missing) value.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>You can use this extension method to convert the query string arguments into the double type:</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UseTryParse<ept id="p2">]</ept><bpt id="p3">(../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#UseTryParse "</bpt>Use the try parse extension method<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>To easily test the parsing code, update the response to include the values of the arguments:</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>WriteResponse<ept id="p2">]</ept><bpt id="p3">(../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#WriteResponse "</bpt>Write the output response<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>At this point, you can run the web application and see if your parsing code is working.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Add values to the web request in a browser, and you should see the updated results.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Build a random weather forecast</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Your next task is to build a random weather forecast.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Let's start with a data container that holds the values you'd want for a weather forecast:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Next, build a constructor that randomly sets those values.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This constructor uses the values for the latitude and longitude to seed the Random number generator.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>That means the forecast for the same location is the same.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If you change the arguments for the latitude and longitude, you'll get a different forecast (because you start with a different seed.)</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>WeatherReportConstructor<ept id="p2">]</ept><bpt id="p3">(../../../samples/csharp/getting-started/WeatherMicroservice/WeatherReport.cs#WeatherReportConstructor "</bpt>Weather Report Constructor<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>You can now generate the 5-day forecast in your response method:</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenerateRandomReport<ept id="p2">]</ept><bpt id="p3">(../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#GenerateRandomReport "</bpt>Generate a random weather report<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Build the JSON response.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The final code task on the server is to convert the WeatherReport array into a JSON packet, and send that back to the client.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Let's start by creating the JSON packet.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>You'll add the NewtonSoft JSON Serializer to the list of dependencies.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>You can do that using the <ph id="ph1">`dotnet`</ph> CLI:</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Then, you can use the <ph id="ph1">`JsonConvert`</ph> class to write the object to a string:</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ConvertToJson<ept id="p2">]</ept><bpt id="p3">(../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#ConvertToJSON "</bpt>Convert objects to JSON<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The code above converts the forecast object (a list of <ph id="ph1">`WeatherForecast`</ph> objects) into a JSON packet.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>After you've constructed the response packet, you set the content type to <ph id="ph1">`application/json`</ph>, and write the string.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The application now runs and returns random forecasts.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Build a Docker image</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Our final task is to run the application in Docker.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>We'll create a Docker container that runs a Docker image that represents our application.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">***</bpt>Docker Image<ept id="p1">***</ept> is a file that defines the environment for running the application.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">***</bpt>Docker Container<ept id="p1">***</ept> represents a running instance of a Docker image.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>By analogy, you can think of the <bpt id="p1">*</bpt>Docker Image<ept id="p1">*</ept> as a <bpt id="p2">*</bpt>class<ept id="p2">*</ept>, and the <bpt id="p3">*</bpt>Docker Container<ept id="p3">*</ept> as an object, or an instance of that class.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The Dockerfile created by the asp.net template will serve for our purposes.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Let's go over its contents.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The first line specifies the source image:</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Docker allows you to configure a machine image based on a source template.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>That means you don't have to supply all the machine parameters when you start, you only need to supply any changes.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The changes here will be to include our application.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>In this first sample, we'll use the <ph id="ph1">`1.1-sdk-msbuild`</ph> version of the dotnet image.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This is the easiest way to create a working Docker environment.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This image include the dotnet core runtime, and the dotnet SDK.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>That makes it easier to get started and build, but does create a larger image.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The next five lines setup and build your application:</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This will copy the project file from the  current directory to the docker VM, and restore all the packages.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Using the dotnet CLI means that the Docker image must include the .NET Core SDK.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>After that, the rest of your application gets copied, and the dotnet publish command builds and packages your application.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The final line of the file runs the application:</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>This configured port is referenced in the <ph id="ph1">`--server.urls`</ph> argument to <ph id="ph2">`dotnet`</ph> on the last  line of the Dockerfile.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ENTRYPOINT`</ph> command informs Docker  what command and command line options start the service.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Building and running the image in a container.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Let's build an image and run the service inside a Docker container.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>You don't want all the files from your local directory copied into the image.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Instead, you'll build the application in the container.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>You'll create a <ph id="ph1">`.dockerignore`</ph> file to specify the directories that are not copied into the image.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>You don't want any of the build assets copied.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Specify the build and publish directories in the <ph id="ph1">`.dockerignore`</ph> file:</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You build the image using the docker build command.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Run the following command from the directory containing your code.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>This command builds the container image based on all the information in your Dockerfile.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-t`</ph> argument provides a tag, or name, for this container image.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In the command line above, the tag used for the Docker container is <ph id="ph1">`weather-microservice`</ph>.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>When this command completes, you have a container ready to run your new service.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Run the following command to start the container and launch your service:</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-d`</ph> option means to run the container detached from the current terminal.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>That means you won't see the command output in your terminal.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-p`</ph> option indicates the port mapping between the service and the host.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Here it says that any incoming request on port 80 should be forwarded to port 5000 on the container.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Using 5000 matches the port your service is listening on from the command line arguments specified in the Dockerfile above.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`--name`</ph> argument names your running container.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>It's a convenient name you can use to work with that container.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>You can see if the image is running by checking the command:</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If your container is running, you'll see a line that lists it in the running processes.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>(It may be the only one).</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>You can test your service by opening a browser and navigating to localhost, and specifying a latitude and longitude:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Attaching to a running container</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>When you ran your sevice in a command window, you could see diagnostic information printed for each request.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>You don't see that information when your container is running in detached mode.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The Docker attach command enables you to attach to a running container so that you can see the log information.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Run this command from a command window:</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`--sig-proxy=false`</ph> argument means that <ph id="ph2">`Ctrl-C`</ph> commands do not get sent to the container process, but rather stop the <ph id="ph3">`docker attach`</ph> command.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The final argument is the name given to the container in the <ph id="ph1">`docker run`</ph> command.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>You can also use the docker assigned container ID to refer to any container.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>If you didn't specify a name for your container in <ph id="ph1">`docker run`</ph> you must use the container id.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Open a browser and navigate to your service.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>You'll see the diagnostic messages in the command windows from the attached running container.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Press <ph id="ph1">`Ctrl-C`</ph> to stop the attach process.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>When you are done working with your container, you can stop it:</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The container and image is still available for you to restart.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>If you want to remove the container from your machine, you use this command:</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>If you want to remove unused images from your machine, you use this command:</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>In this tutorial, you built an asp.net core microservice, and added a few simple features.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>You built a docker container image for that service, and ran that container on your machine.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>You attached a terminal window to the service, and saw the diagnostic messages from your service.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Along the way, you saw several features of the C# language in action.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>