<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">11895d695f28bcd2467705d27c50ba8451a7ecb4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\data\adonet\sql\linq\sql-clr-type-mapping.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">27d469c4536bd7d8fc3b63efa30766a3605b5201</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a9c83b7ffb61683ae7b0cb7131bc32e66a564fd7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>SQL-CLR Type Mapping | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>SQL-CLR Type Mapping</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>In LINQ to SQL, the data model of a relational database maps to an object model that is expressed in the programming language of your choice.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When the application runs, LINQ to SQL translates the language-integrated queries in the object model into SQL and sends them to the database for execution.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When the database returns the results, LINQ to SQL translates the results back to objects that you can work with in your own programming language.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In order to translate data between the object model and the database, a <bpt id="p1">*</bpt>type mapping<ept id="p1">*</ept> must be defined.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>LINQ to SQL uses a type mapping to match each common language runtime (CLR) type with a particular SQL Server type.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can define type mappings and other mapping information, such as database structure and table relationships, inside the object model with attribute-based mapping.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify the mapping information outside the object model with an external mapping file.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Attribute-Based Mapping<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/attribute-based-mapping.md)</ept> and <bpt id="p2">[</bpt>External Mapping<ept id="p2">](../../../../../../docs/framework/data/adonet/sql/linq/external-mapping.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This topic discusses the following points:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Default Type Mapping<ept id="p1">](#DefaultTypeMapping)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type Mapping Run-time Behavior Matrix<ept id="p1">](#BehaviorMatrix)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Behavior Differences Between CLR and SQL Execution<ept id="p1">](#BehaviorDiffs)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enum Mapping<ept id="p1">](#EnumMapping)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Numeric Mapping<ept id="p1">](#NumericMapping)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Text and XML Mapping<ept id="p1">](#TextMapping)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Date and Time Mapping<ept id="p1">](#DateMapping)</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Binary Mapping<ept id="p1">](#BinaryMapping)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Miscellaneous Mapping<ept id="p1">](#MiscMapping)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Default Type Mapping</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can create the object model or external mapping file automatically with the Object Relational Designer (O/R Designer) or the SQLMetal command-line tool.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The default type mappings for these tools define which CLR types are chosen to map to columns inside the SQL Server database.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information about using these tools, see <bpt id="p1">[</bpt>Creating the Object Model<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/creating-the-object-model.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A&gt;</ph> method to create a SQL Server database based on the mapping information in the object model or external mapping file.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The default type mappings for the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A&gt;</ph> method define which type of SQL Server columns are created to map to the CLR types in the object model.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Dynamically Create a Database<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/how-to-dynamically-create-a-database.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Type Mapping Run-time Behavior Matrix</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following diagram shows the expected run-time behavior of specific type mappings when data is retrieved from or saved to the database.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>With the exception of serialization, LINQ to SQL does not support mapping between any CLR or SQL Server data types that are not specified in this matrix.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information on serialization support, see <bpt id="p1">[</bpt>Binary Serialization<ept id="p1">](#BinarySerialization)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Some type mappings may result in overflow or data loss exceptions while translating to or from the database.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Custom Type Mapping</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>With LINQ to SQL, you are not limited to the default type mappings used by the O/R Designer, SQLMetal, and the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can create custom type mappings by explicitly specifying them in a DBML file.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Then you can use that DBML file to create the object model code and mapping file.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>SQL-CLR Custom Type Mappings<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-custom-type-mappings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Behavior Differences Between CLR and SQL Execution</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Because of differences in precision and execution between the CLR and SQL Server, you may receive different results or experience different behavior depending on where you perform your calculations.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Calculations performed in LINQ to SQL queries are actually translated to Transact-SQL and then executed on the SQL Server database.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Calculations performed outside LINQ to SQL queries are executed within the context of the CLR.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For example, the following are some differences in behavior between the CLR and SQL Server:</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>SQL Server orders some data types differently than data of equivalent type in the CLR.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example, SQL Server data of type <ph id="ph1">`UNIQUEIDENTIFIER`</ph> is ordered differently than CLR data of type <ph id="ph2">&lt;xref:System.Guid?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>SQL Server handles some string comparison operations differently than the CLR.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In SQL Server, string comparison behavior depends on the collation settings on the server.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Working with Collations<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=115330)</ept> in the Microsoft SQL Server Books Online.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>SQL Server may return different values for some mapped functions than the CLR.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For example, equality functions will differ because SQL Server considers two strings to be equal if they only differ in trailing white space; whereas the CLR considers them to be not equal.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Enum Mapping</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>LINQ to SQL supports mapping the CLR <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> type to SQL Server types in two ways:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Mapping to SQL numeric types (<ph id="ph1">`TINYINT`</ph>, <ph id="ph2">`SMALLINT`</ph>, <ph id="ph3">`INT`</ph>, <ph id="ph4">`BIGINT`</ph>)</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>When you map a CLR <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> type to a SQL numeric type, you map the underlying integer value of the CLR <ph id="ph2">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> to the value of the SQL Server database column.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, if a <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> named <ph id="ph2">`DaysOfWeek`</ph> contains a member named <ph id="ph3">`Tue`</ph> with an underlying integer value of 3, that member maps to a database value of 3.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Mapping to SQL text types (<ph id="ph1">`CHAR`</ph>, <ph id="ph2">`NCHAR`</ph>, <ph id="ph3">`VARCHAR`</ph>, <ph id="ph4">`NVARCHAR`</ph>)</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>When you map a CLR <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> type to a SQL text type, the SQL database value is mapped to the names of the CLR <ph id="ph2">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> members.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, if a <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> named <ph id="ph2">`DaysOfWeek`</ph> contains a member named <ph id="ph3">`Tue`</ph> with an underlying integer value of 3, that member maps to a database value of <ph id="ph4">`Tue`</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When mapping SQL text types to a CLR <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph>, include only the names of the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> members in the mapped SQL column.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Other values are not supported in the <ph id="ph1">&lt;xref:System.Enum&gt;</ph>-mapped SQL column.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The O/R Designer and SQLMetal command-line tool cannot automatically map a SQL type to a CLR <ph id="ph1">&lt;xref:System.Enum&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You must explicitly configure this mapping by customizing a DBML file for use by the O/R Designer and SQLMetal.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For more information about custom type mapping, see <bpt id="p1">[</bpt>SQL-CLR Custom Type Mappings<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-custom-type-mappings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Because a SQL column intended for enumeration will be of the same type as other numeric and text columns; these tools will not recognize your intent and default to mapping as described in the following <bpt id="p1">[</bpt>Numeric Mapping<ept id="p1">](#NumericMapping)</ept> and <bpt id="p2">[</bpt>Text and XML Mapping<ept id="p2">](#TextMapping)</ept> sections.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information about generating code with the DBML file, see <bpt id="p1">[</bpt>Code Generation in LINQ to SQL<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/code-generation-in-linq-to-sql.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method creates a SQL column of numeric type to map a CLR <ph id="ph2">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Numeric Mapping</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>LINQ to SQL lets you map many CLR and SQL Server numeric types.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>SQL Server Type</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Default CLR Type mapping used by O/R Designer and SQLMetal</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The next table shows the default type mappings used by the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>CLR Type</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Default SQL Server Type used by <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>There are many other numeric mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Mapping Run Time Behavior Matrix<ept id="p1">](#BehaviorMatrix)</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Decimal and Money Types</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The default precision of SQL Server <ph id="ph1">`DECIMAL`</ph> type (18 decimal digits to the left and right of the decimal point) is much smaller than the precision of the CLR <ph id="ph2">&lt;!--zz &lt;xref:System.Decima?displayProperty=fullName&gt;l --&gt;</ph> <ph id="ph3">`Decimal`</ph> type that it is paired with by default.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This can result in precision loss when you save data to the database.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>However, just the opposite can happen if the SQL Server <ph id="ph1">`DECIMAL`</ph> type is configured with greater than 29 digits of precision.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>When a SQL Server <ph id="ph1">`DECIMAL`</ph> type has been configured with a greater precision than the CLR <ph id="ph2">&lt;xref:System.Decimal?displayProperty=fullName&gt;</ph>, precision loss can occur when retrieving data from the database.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The SQL Server <ph id="ph1">`MONEY`</ph> and <ph id="ph2">`SMALLMONEY`</ph> types, which are also paired with the CLR <ph id="ph3">&lt;xref:System.Decimal?displayProperty=fullName&gt;</ph> type by default, have a much smaller precision, which can result in overflow or data loss exceptions when saving data to the database.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Text and XML Mapping</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>There are also many text-based and XML types that you can map with LINQ to SQL.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>SQL Server Type</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Default CLR Type mapping used by O/R Designer and SQLMetal</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The next table shows the default type mappings used by the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>CLR Type</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Default SQL Server Type used by <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Char?displayProperty=fullName&gt;</ph>[]</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Custom type implementing <ph id="ph1">`Parse()`</ph> and <ph id="ph2">`ToString()`</ph></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>There are many other text-based and XML mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Mapping Run Time Behavior Matrix<ept id="p1">](#BehaviorMatrix)</ept>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>XML Types</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The SQL Server <ph id="ph1">`XML`</ph> data type is available starting in Microsoft SQL Server 2005.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can map the SQL Server <ph id="ph1">`XML`</ph> data type to <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, <ph id="ph3">&lt;xref:System.Xml.Linq.XDocument&gt;</ph>, or <ph id="ph4">&lt;xref:System.String&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If the column stores XML fragments that cannot be read into <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, the column must be mapped to <ph id="ph2">&lt;xref:System.String&gt;</ph> to avoid run-time errors.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>XML fragments that must be mapped to <ph id="ph1">&lt;xref:System.String&gt;</ph> include the following:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>A sequence of XML elements</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Attributes</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Public Identifiers (PI)</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Although you can map <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> to SQL Server as shown in the <bpt id="p1">[</bpt>Type Mapping Run Time Behavior Matrix<ept id="p1">](#BehaviorMatrix)</ept>, the <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method has no default SQL Server type mapping for these types.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Custom Types</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If a class implements <ph id="ph1">`Parse()`</ph> and <ph id="ph2">`ToString()`</ph>, you can map the object to any SQL text type (<ph id="ph3">`CHAR`</ph>, <ph id="ph4">`NCHAR`</ph>, <ph id="ph5">`VARCHAR`</ph>, <ph id="ph6">`NVARCHAR`</ph>, <ph id="ph7">`TEXT`</ph>, <ph id="ph8">`NTEXT`</ph>, <ph id="ph9">`XML`</ph>).</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The object is stored in the database by sending the value returned by <ph id="ph1">`ToString()`</ph> to the mapped database column.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The object is reconstructed by invoking <ph id="ph1">`Parse()`</ph> on the string returned by the database.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>LINQ to SQL does not support serialization by using <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Date and Time Mapping</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>With LINQ to SQL, you can map many SQL Server date and time types.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>SQL Server Type</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Default CLR Type mapping used by O/R Designer and SQLMetal</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The next table shows the default type mappings used by the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>CLR Type</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Default SQL Server Type used by <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>There are many other date and time mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Mapping Run Time Behavior Matrix<ept id="p1">](#BehaviorMatrix)</ept>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The SQL Server types <ph id="ph1">`DATETIME2`</ph>, <ph id="ph2">`DATETIMEOFFSET`</ph>, <ph id="ph3">`DATE`</ph>, and <ph id="ph4">`TIME`</ph> are available starting with Microsoft SQL Server 2008.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>LINQ to SQL supports mapping to these new types starting with the .NET Framework version 3.5 SP1.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>System.Datetime</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The range and precision of the CLR <ph id="ph1">&lt;xref:System.DateTime?displayProperty=fullName&gt;</ph> type is greater than the range and precision of the SQL Server <ph id="ph2">`DATETIME`</ph> type, which is the default type mapping for the <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>To help avoid exceptions related to dates outside the range of <ph id="ph1">`DATETIME`</ph>, use <ph id="ph2">`DATETIME2`</ph>, which is available starting with Microsoft SQL Server 2008.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DATETIME2`</ph> can match the range and precision of the CLR <ph id="ph2">&lt;xref:System.DateTime?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>SQL Server dates have no concept of <ph id="ph1">&lt;xref:System.TimeZone&gt;</ph>, a feature that is richly supported in the CLR.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.TimeZone&gt;</ph> values are saved as is to the database without <ph id="ph2">&lt;xref:System.TimeZone&gt;</ph> conversion, regardless of the original <ph id="ph3">&lt;xref:System.DateTimeKind&gt;</ph> information.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> values are retrieved from the database, their value is loaded as is into a <ph id="ph2">&lt;xref:System.DateTime&gt;</ph> with a <ph id="ph3">&lt;xref:System.DateTimeKind&gt;</ph> of <ph id="ph4">&lt;xref:System.DateTimeKind&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For more information about supported <ph id="ph1">&lt;xref:System.DateTime?displayProperty=fullName&gt;</ph> methods, see <bpt id="p1">[</bpt>System.DateTime Methods<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/system-datetime-methods.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>System.TimeSpan</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Microsoft SQL Server 2008 and the .NET Framework 3.5 SP1 let you map the CLR <ph id="ph1">&lt;xref:System.TimeSpan?displayProperty=fullName&gt;</ph> type to the SQL Server <ph id="ph2">`TIME`</ph> type.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>However, there is a large difference between the range that the CLR <ph id="ph1">&lt;xref:System.TimeSpan?displayProperty=fullName&gt;</ph> supports and what the SQL Server <ph id="ph2">`TIME`</ph> type supports.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Mapping values less than 0 or greater than 23:59:59.9999999 hours to the SQL <ph id="ph1">`TIME`</ph> will result in overflow exceptions.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>System.TimeSpan Methods<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/system-timespan-methods.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In Microsoft SQL Server 2000 and SQL Server 2005, you cannot map database fields to <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>However, operations on <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> are supported because <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> values can be returned from <ph id="ph3">&lt;xref:System.DateTime&gt;</ph> subtraction or introduced into an expression as a literal or bound variable.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Binary Mapping</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>There are many SQL Server types that can map to the CLR type <ph id="ph1">&lt;xref:System.Data.Linq.Binary?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The following table shows the SQL Server types that cause O/R Designer and SQLMetal to define a CLR <ph id="ph1">&lt;xref:System.Data.Linq.Binary?displayProperty=fullName&gt;</ph> type when building an object model or external mapping file based on your database.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>SQL Server Type</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Default CLR Type mapping used by O/R Designer and SQLMetal</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`VARBINARY(MAX)`</ph> with the <ph id="ph2">`FILESTREAM`</ph> attribute</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The next table shows the default type mappings used by the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>CLR Type</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Default SQL Server Type used by <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>There are many other binary mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Mapping Run Time Behavior Matrix<ept id="p1">](#BehaviorMatrix)</ept>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>SQL Server FILESTREAM</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FILESTREAM`</ph> attribute for <ph id="ph2">`VARBINARY(MAX)`</ph> columns is available starting with Microsoft SQL Server 2008; you can map to it with LINQ to SQL starting with the .NET Framework version 3.5 SP1.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Although you can map <ph id="ph1">`VARBINARY(MAX)`</ph> columns with the <ph id="ph2">`FILESTREAM`</ph> attribute to <ph id="ph3">&lt;xref:System.Data.Linq.Binary&gt;</ph> objects, the <ph id="ph4">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method is unable to automatically create columns with the <ph id="ph5">`FILESTREAM`</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`FILESTREAM`</ph>, see <bpt id="p1">[</bpt>FILESTREAM Overview<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=115291)</ept> on Microsoft SQL Server Books Online.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Binary Serialization</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If a class implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface, you can serialize an object to any SQL binary field (<ph id="ph2">`BINARY`</ph>, <ph id="ph3">`VARBINARY`</ph>, <ph id="ph4">`IMAGE`</ph>).</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The object is serialized and deserialized according to how the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface is implemented.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Binary Serialization<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=115581)</ept>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Miscellaneous Mapping</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The following table shows the default type mappings for some miscellaneous types that have not yet been mentioned.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>SQL Server Type</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Default CLR Type mapping used by O/R Designer and SQLMetal</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The next table shows the default type mappings used by the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>CLR Type</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Default SQL Server Type used by <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>LINQ to SQL does not support any other type mappings for these miscellaneous types.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Mapping Run Time Behavior Matrix<ept id="p1">](#BehaviorMatrix)</ept>.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attribute-Based Mapping<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/attribute-based-mapping.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>External Mapping<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/external-mapping.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data Types and Functions<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/data-types-and-functions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SQL-CLR Type Mismatches<ept id="p1">](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mismatches.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>