<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="comparing-aspnet-web-services-to-wcf-based-on-development.md" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-3be5d15" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e3a7b2b58558dcfd8bcc3d4bbc3b7f50642a521</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\comparing-aspnet-web-services-to-wcf-based-on-development.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f482b6d639fbe98f6c63661f3b106d92abe933f4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7ef094ac41b4d727180209577fa5cf3f548e497c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Comparing ASP.NET Web Services to WCF Based on Development | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Comparing ASP.NET Web Services to WCF Based on Development</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> has an ASP.NET compatibility mode option to enable <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications to be programmed and configured like ASP.NET Web services, and mimic their behavior.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The following sections compare ASP.NET Web services and <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> based on what is required to develop applications using both technologies.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Data Representation</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The development of a Web service with ASP.NET typically begins with defining any complex data types the service is to use.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ASP.NET relies on the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> to translate data represented by .NET Framework types to XML for transmission to or from a service and to translate data received as XML into .NET Framework objects.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Defining the complex data types that an ASP.NET service is to use requires the definition of .NET Framework classes that the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> can serialize to and from XML.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Such classes can be written manually, or generated from definitions of the types in XML Schema using the command-line XML Schemas/Data Types Support Utility, xsd.exe.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following is a list of key issues to know when defining .NET Framework classes that the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> can serialize to and from XML:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Only the public fields and properties of .NET Framework objects are translated into XML.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Instances of collection classes can be serialized into XML only if the classes implement either the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Classes that implement the <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> interface, such as <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, cannot be serialized into XML.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The great many attribute types in the <ph id="ph1">&lt;xref:System.Xml.Serialization&gt;</ph> namespace can be added to a .NET Framework class and its members to control how instances of the class are represented in XML.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> application development usually also begins with the definition of complex types.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> can be made to use the same .NET Framework types as ASP.NET Web services.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph><ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> can be added to .NET Framework types to indicate that instances of the type are to be serialized into XML, and which particular fields or properties of the type are to be serialized, as shown in the following sample code.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> signifies that zero or more of a type’s fields or properties are to be serialized, while the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> indicates that a particular field or property is to be serialized.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> can be applied to a class or structure.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> can be applied to a field or a property, and the fields and properties to which the attribute is applied can be either public or private.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Instances of types that have the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> applied to them are referred to as data contracts in <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>They are serialized into XML using <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following is a list of the important differences between using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and using the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> and the various attributes of the <ph id="ph3">&lt;xref:System.Xml.Serialization&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> and the attributes of the <ph id="ph2">&lt;xref:System.Xml.Serialization&gt;</ph> namespace are designed to allow you to map .NET Framework types to any valid type defined in XML Schema, and so they provide for very precise control over how a type is represented in XML.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> provide very little control over how a type is represented in XML.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can only specify the namespaces and names used to represent the type and its fields or properties in the XML, and the sequence in which the fields and properties appear in the XML:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Everything else about the structure of the XML used to represent the .NET type is determined by the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>By not permitting much control over how a type is to be represented in XML, the serialization process becomes highly predictable for the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, and, thereby, easier to optimize.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A practical benefit of the design of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is better performance, approximately ten percent better performance.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The attributes for use with the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> do not indicate which fields or properties of the type are serialized into XML, whereas the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> for use with the <ph id="ph3">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> shows explicitly which fields or properties are serialized.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Therefore, data contracts are explicit contracts about the structure of the data that an application is to send and receive.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> can only translate the public members of a .NET object into XML, the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> can translate the members of objects into XML regardless of the access modifiers of those members.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>As a consequence of being able to serialize the non-public members of types into XML, the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> has fewer restrictions on the variety of .NET types that it can serialize into XML.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In particular, it can translate into XML types like <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> that implement the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is much more likely to be able to serialize the instances of any pre-existing .NET type into XML without having to either modify the definition of the type or develop a wrapper for it.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Another consequence of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> being able to access the non-public members of a type is that it requires full trust, whereas the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> does not.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The Full Trust code access permission give complete access to all resources on a machine that can be access using the credentials under which the code is executing.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This options should be used with care as fully trusted code accesses all resources on your machine.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> incorporates some support for versioning:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> has an <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A&gt;</ph> property that can be assigned a value of false for members that are added to new versions of a data contract that were not present in earlier versions, thereby allowing applications with the newer version of the contract to be able to process earlier versions.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>By having a data contract implement the <ph id="ph1">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface, one can allow the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> to pass members defined in newer versions of a data contract through applications with earlier versions of the contract.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Despite all of the differences, the XML into which the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> serializes a type by default is semantically identical to the XML into which the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> serializes a type, provided the namespace for the XML is explicitly defined.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following class, which has attributes for use with both of the serializers, are translated into semantically identical XML by the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> and by the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The Windows software development kit (SDK) includes a command-line tool called the <bpt id="p1">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id="p1">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.Like the xsd.exe tool used with ASP.NET Web services, Svcutil.exe can generate definitions of .NET data types from XML Schema.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The types are data contracts if the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> can emit XML in the format defined by the XML Schema; otherwise, they are intended for serialization using the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The tool, Svcutil.exe, can also be made to generate XML Schema from data contracts using its <ph id="ph1">`/dataContractOnly`</ph> switch.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Although ASP.NET Web services use the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>, and <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> ASP.NET compatibility mode makes <ph id="ph3">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services mimic the behavior of ASP.NET Web services, the ASP.NET compatibility option does not restrict one to using the <ph id="ph4">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>One can still use the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> with services running in the ASP.NET compatibility mode.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Service Development</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>To develop a service using ASP.NET, it has been customary to add the <ph id="ph1">&lt;xref:System.Web.Services.WebService&gt;</ph> attribute to a class, and the <ph id="ph2">&lt;xref:System.Web.Services.WebMethodAttribute&gt;</ph> to any of that class’ methods that are to be operations of the service:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>ASP.NET 2.0 introduced the option of adding the attribute <ph id="ph1">&lt;xref:System.Web.Services.WebService&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.Services.WebMethodAttribute&gt;</ph> to an interface rather than to a class, and writing a class to implement the interface:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Using this option is to be preferred, because the interface with the <ph id="ph1">&lt;xref:System.Web.Services.WebService&gt;</ph> attribute constitutes a contract for the operations performed by the service that can be reused with various classes that might implement that same contract in different ways.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service is provided by defining one or more <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> endpoints.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>An endpoint is defined by an address, a binding and a service contract.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The address defines where the service is located.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The binding specifies how to communicate with the service.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The service contract defines the operations that the service can perform.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The service contract is usually defined first, by adding <ph id="ph1">&lt;xref:System.ServiceModel.ServiceContractAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> to an interface:</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.ServiceContractAttribute&gt;</ph> specifies that the interface defines a <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service contract, and the <ph id="ph3">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> indicates which, if any, of the methods of the interface define operations of the service contract.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Once a service contract has been defined, it is implemented in a class, by having the class implement the interface by which the service contract is defined:</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A class that implements a service contract is referred to as a service type in <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The next step is to associate an address and a binding with a service type.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>That is typically done in a configuration file, either by editing the file directly, or by using a configuration editor provided with <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration file.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The binding specifies the set of protocols for communicating with the application.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The following table lists the system-provided bindings that represent common options.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Purpose</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>BasicHttpBinding</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Interoperability with Web services and clients supporting the WS-BasicProfile 1.1 and Basic Security Profile 1.0.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>WSHttpBinding</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Interoperability with Web services and clients that support the WS-* protocols over HTTP.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>WSDualHttpBinding</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Duplex HTTP communication, by which the receiver of an initial message does not reply directly to the initial sender, but may transmit any number of responses over a period of time by using HTTP in conformity with WS-* protocols.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>WSFederationBinding</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>HTTP communication, in which access to the resources of a service can be controlled based on credentials issued by an explicitly-identified credential provider.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>NetTcpBinding</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Secure, reliable, high-performance communication between <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> software entities across a network.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>NetNamedPipeBinding</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Secure, reliable, high-performance communication between <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> software entities on the same machine.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>NetMsmqBinding</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Communication between <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> software entities by using MSMQ.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>MsmqIntegrationBinding</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Communication between a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> software entity and another software entity by using MSMQ.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>NetPeerTcpBinding</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Communication between <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> software entities by using Windows Peer-to-Peer Networking.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The system-provided binding, <ph id="ph1">&lt;xref:System.ServiceModel.BasicHttpBinding&gt;</ph>, incorporates the set of protocols supported by ASP.NET Web services.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Custom bindings for <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications are easily defined as collections of the binding element classes that <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> uses to implement individual protocols.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>New binding elements can be written to represent additional protocols.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The internal behavior of service types can be adjusted using the properties of a family of classes called behaviors.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Here, the <ph id="ph1">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute&gt;</ph> class is used to specify that the service type is to be multithreaded.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Some behaviors, like <ph id="ph1">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute&gt;</ph>, are attributes.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Others, the ones with properties that administrators would want to set, can be modified in the configuration of an application.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In programming service types, frequent use is made of the <ph id="ph1">&lt;xref:System.ServiceModel.OperationContext&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Its static <ph id="ph1">&lt;xref:System.ServiceModel.OperationContext.Current%2A&gt;</ph> property provides access to information about the context in which an operation is running.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.OperationContext&gt;</ph> is similar to both the <ph id="ph2">&lt;xref:System.Web.HttpContext&gt;</ph> and <ph id="ph3">&lt;xref:System.EnterpriseServices.ContextUtil&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Hosting</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>ASP.NET Web services are compiled into a class library assembly.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>A file called the service file is provided that has the extension .asmx and contains an <ph id="ph1">`@ WebService`</ph> directive that identifies the class that contains the code for the service and the assembly in which it is located.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The service file is copied into an ASP.NET application root in Internet Information Services (IIS), and the assembly is copied into the \bin subdirectory of that application root.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The application is then accessible by using the uniform resource locator (URL) of the service file in the application root.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services can readily be hosted within IIS 5.1 or 6.0, the Windows Process Activation Service (WAS) that is provided as part of IIS 7.0, and within any .NET application.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>To host a service in IIS 5.1 or 6.0, the service must use HTTP as the communications transport protocol.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>To host a service within IIS 5.1, 6.0 or within WAS, use the follows steps:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Compile the service type into a class library assembly.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Create a service file with a .svc extension with an <ph id="ph1">`@ ServiceHost`</ph> directive to identify the service type:</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Copy the service file into a virtual directory, and the assembly into the \bin subdirectory of that virtual directory.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Copy the configuration file into the virtual directory, and name it Web.config.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The application is then accessible by using the URL of the service file in the application root.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>To host a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service within a .NET application, compile the service type into a class library assembly referenced by the application, and program the application to host the service using the <ph id="ph2">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The following is an example of the basic programming required:</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This example shows how addresses for one or more transport protocols are specified in the construction of a <ph id="ph1">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>These addresses are referred to as base addresses.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The address provided for any endpoint of a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service is an address relative to a base address of the endpoint’s host.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The host can have one base address for each communication transport protocol.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>In the sample configuration in the preceding configuration file, the <ph id="ph1">&lt;xref:System.ServiceModel.BasicHttpBinding&gt;</ph> selected for the endpoint uses HTTP as the transport protocol, so the address of the endpoint, <ph id="ph2">`EchoService`</ph>, is relative to the host’s HTTP base address.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>In the case of the host in the preceding example, the HTTP base address is http://www.contoso.com:8000/.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For a service hosted within IIS or WAS, the base address is the URL of the service’s service file.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Only services hosted in IIS or WAS, and which are configured with HTTP as the transport protocol exclusively, can be made to use <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> ASP.NET compatibility mode option.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Turning that option on requires the following steps.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The programmer must add the <ph id="ph1">&lt;xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute&gt;</ph> attribute to the service type and specify that ASP.NET compatibility mode is either allowed or required.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The administrator must configure the application to use the ASP.NET compatibility mode.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications can also be configured to use .asmx as the extension for their service files rather than .svc.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>That option can save you from having to modify clients that are configured to use the URLs of .asmx service files when modifying a service to use <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Client Development</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Clients for ASP.NET Web services are generated using the command-line tool, WSDL.exe, which provides the URL of the .asmx file as input.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The corresponding tool provided by <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> is <bpt id="p1">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id="p1">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It generates a code module with the definition of the service contract and the definition of a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> client class.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>It also generates a configuration file with the address and binding of the service.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In programming a client of a remote service it is generally advisable to program according to an asynchronous pattern.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The code generated by the WSDL.exe tool always provides for both a synchronous and an asynchronous pattern by default.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The code generated by the <bpt id="p1">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id="p1">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept> can provide for either pattern.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>It provides for the synchronous pattern by default.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>If the tool is executed with the <ph id="ph1">`/async`</ph> switch, then the generated code provides for the asynchronous pattern.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>There is no guarantee that names in the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> client classes generated by ASP.NET’s WSDL.exe tool, by default, match the names in <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> client classes generated by the Svcutil.exe tool.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In particular, the names of the properties of classes that have to be serialized using the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> are, by default, given the suffix Property in the code generated by the Svcutil.exe tool, which is not the case with the WSDL.exe tool.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Message Representation</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The headers of the SOAP messages sent and received by ASP.NET Web services can be customized.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A class is derived from <ph id="ph1">&lt;xref:System.Web.Services.Protocols.SoapHeader&gt;</ph> to define the structure of the header, and then the <ph id="ph2">&lt;xref:System.Web.Services.Protocols.SoapHeaderAttribute&gt;</ph> is used to indicate the presence of the header.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> provides the attributes, <ph id="ph2">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph>, <ph id="ph3">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>, and <ph id="ph4">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> to describe the structure of the SOAP messages sent and received by a service.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This syntax yields an explicit representation of the structure of the messages, whereas the structure of messages is implied by the code of an ASP.NET Web service.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Also, in the ASP.NET syntax, message headers are represented as properties of the service, such as the <ph id="ph1">`ProtocolHeader`</ph> property in the previous example, whereas in <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> syntax, they are more accurately represented as properties of messages.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Also, <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> allows message headers to be added to the configuration of endpoints.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>That option allows you to avoid any reference to infrastructural protocol headers in the code for a client or service: the headers are added to messages because of how the endpoint is configured.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Service Description</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Issuing an HTTP GET request for the .asmx file of an ASP.NET Web service with the query WSDL causes ASP.NET to generate WSDL to describe the service.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It returns that WSDL as the response to the request.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>ASP.NET 2.0 made it possible to validate that a service is compliant with the Basic Profile 1.1 of the Web Services-Interoperability Organization (WS-I), and to insert a claim that the service is compliant into its WSDL.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>That is done using the <ph id="ph1">`ConformsTo`</ph> and <ph id="ph2">`EmitConformanceClaims`</ph> parameters of the <ph id="ph3">&lt;xref:System.Web.Services.WebServiceBindingAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The WSDL that ASP.NET generates for a service can be customized.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Customizations are made by creating a derived class of <ph id="ph1">&lt;xref:System.Web.Services.Description.ServiceDescriptionFormatExtension&gt;</ph> to add items to the WSDL.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Issuing an HTTP GET request with the query WSDL for the .svc file of a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service with an HTTP endpoint hosted within IIS 51, 6.0 or WAS causes <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> to respond with WSDL to describe the service.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Issuing an HTTP GET request with the query WSDL to the HTTP base address of a service hosted within a .NET application has the same effect if httpGetEnabled is set to true.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> also responds to WS-MetadataExchange requests with WSDL that it generates to describe a service.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>ASP.NET Web services do not have built-in support for WS-MetadataExchange requests.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The WSDL that <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> generates can be extensively customized.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.Description.ServiceMetadataBehavior&gt;</ph> class provides some facilities for customizing the WSDL.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> can also be configured to not generate WSDL, but rather to use a static WSDL file at a given URL.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In ASP.NET Web services, unhandled exceptions are returned to clients as SOAP faults.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>You can also explicitly throw instances of the <ph id="ph1">&lt;xref:System.Web.Services.Protocols.SoapException&gt;</ph> class and have more control over the content of the SOAP fault that gets transmitted to the client.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services, unhandled exceptions are not returned to clients as SOAP faults to prevent sensitive information being inadvertently exposed through the exceptions.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A configuration setting is provided to have unhandled exceptions returned to clients for the purpose of debugging.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>To return SOAP faults to clients, you can throw instances of the generic type, <ph id="ph1">&lt;xref:System.ServiceModel.FaultException%601&gt;</ph>, using the data contract type as the generic type.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>You can also add <ph id="ph1">&lt;xref:System.ServiceModel.FaultContractAttribute&gt;</ph> attributes to operations to specify the faults that an operation might yield.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Doing so results in the possible faults being advertised in the WSDL for the service, allowing client programmers to anticipate which faults can result from an operation, and write the appropriate catch statements.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>State Management</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The class used to implement an ASP.NET Web service may be derived from <ph id="ph1">&lt;xref:System.Web.Services.WebService&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In that case, the class can be programmed to use the <ph id="ph1">&lt;xref:System.Web.Services.WebService&gt;</ph> base class’ Context property to access a <ph id="ph2">&lt;xref:System.Web.HttpContext&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Web.HttpContext&gt;</ph> object can be used to update and retrieve application state information by using its Application property, and can be used to update and retrieve session state information by using its Session property.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>ASP.NET provides considerable control over where the session state information accessed by using the Session property of the <ph id="ph1">&lt;xref:System.Web.HttpContext&gt;</ph> is actually stored.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>It may be stored in cookies, in a database, in the memory of the current server, or in the memory of a designated server.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The choice is made in the service’s configuration file.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> provides extensible objects for state management.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Extensible objects are objects that implement <ph id="ph1">&lt;xref:System.ServiceModel.IExtensibleObject%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The most important extensible objects are <ph id="ph1">&lt;xref:System.ServiceModel.ServiceHostBase&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.InstanceContext&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ServiceHostBase`</ph> allows you to maintain state that all of the instances of all of the service types on the same host can access, while <ph id="ph2">`InstanceContext`</ph> allows you to maintain state that can be accessed by any code running within the same instance of a service type.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Here, the service type, <ph id="ph1">`TradingSystem`</ph>, has a <ph id="ph2">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute&gt;</ph> that specifies that all calls from the same <ph id="ph3">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> client instance are routed to the same instance of the service type.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The class, <ph id="ph1">`DealData`</ph>, defines state that can be accessed by any code running in the same instance of a service type.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>In the code of the service type that implements one of the operations of the service contract, a <ph id="ph1">`DealData`</ph> state object is added to the state of the current instance of the service type.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>That state object can then be retrieved and modified by the code that implements another of the service contract’s operations.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Whereas ASP.NET provides control over where state information in the <ph id="ph1">&lt;xref:System.Web.HttpContext&gt;</ph> class is actually stored, <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>, at least in its initial version, provides no control over where extensible objects are stored.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>That constitutes the very best reason for selecting the ASP.NET compatibility mode for a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>If configurable state management is imperative, then opting for the ASP.NET compatibility mode allows you to use the facilities of the <ph id="ph1">&lt;xref:System.Web.HttpContext&gt;</ph> class exactly as they are used in ASP.NET, and also to configure where state information managed by using the <ph id="ph2">&lt;xref:System.Web.HttpContext&gt;</ph> class is stored.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Security</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The options for securing ASP.NET Web services are those for securing any IIS application.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications can be hosted not only within IIS but also within any .NET executable, the options for securing <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications must be made independent from the facilities of IIS.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>However, the facilities provided for ASP.NET Web services are also available for <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services running in ASP.NET compatibility mode.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Security: Authentication</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>IIS provides facilities for controlling access to applications by which you can select either anonymous access or a variety of modes of authentication: Windows Authentication, Digest Authentication, Basic Authentication, and .NET Passport Authentication.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The Windows Authentication option can be used to control access to ASP.NET Web services.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>However, when <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications are hosted within IIS, IIS must be configured to permit anonymous access to the application, so that authentication can be managed by <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> itself, which does support Windows authentication among various other options.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The other options that are built-in include username tokens, X.509 certificates, SAML tokens, and CardSpace card, but custom authentication mechanisms can also be defined.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Security: Impersonation</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>ASP.NET provides an identity element by which an ASP.NET Web service can be made to impersonate a particular user or whichever user’s credentials are provided with the current request.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>That element can be used to configure impersonation in <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications running in ASP.NET compatibility mode.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> configuration system provides its own identity element for designating a particular user to impersonate.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Also, <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> clients and services can be independently configured for impersonation.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Clients can be configured to impersonate the current user when they transmit requests.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Service operations can be configured to impersonate whichever user’s credentials are provided with the current request.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Security: Authorization using Access Control Lists</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Access Control Lists (ACLs) can be used to restrict access to .asmx files.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>However, ACLs on <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> .svc files are ignored except in ASP.NET compatibility mode.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Security: Role-based Authorization</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The IIS Windows Authentication option can be used in conjunction with the authorization element provided by the ASP.NET configuration language to facilitate role-based authorization for ASP.NET Web services based on the Windows groups to which users are assigned.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>ASP.NET 2.0 introduced a more general role-based authorization mechanism: role providers.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Role providers are classes that all implement a basic interface for enquiring about the roles to which a user is assigned, but each role provider knows how to retrieve that information from a different source.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>ASP.NET 2.0 provides a role provider that can retrieve role assignments from a Microsoft SQL Server database, and another that can retrieve role assignments from the Windows Server 2003 Authorization Manager.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The role provider mechanism can actually be used independently of ASP.NET in any .NET application, including a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> application.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The following sample configuration for a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> application shows how the use of an ASP.NET role provider is an option selected by means of the <ph id="ph2">&lt;xref:System.ServiceModel.Description.ServiceAuthorizationBehavior&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Security: Claims-based Authorization</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>One of the most important innovations of <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> is its thorough support for authorizing access to protected resources based on claims.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Claims consist of a type, a right and a value, a drivers’ license, for example.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It makes a set of claims about the bearer, one of which is the bearer’s date of birth.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The type of that claim is date of birth, while the value of the claim is the driver’s birth date.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The right that a claim confers on the bearer specifies what the bearer can do with the claim’s value.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>In the case of the claim of the driver’s date of birth, the right is possession: the driver possesses that date of birth but cannot, for example, alter it.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Claims-based authorization encloses role-based authorization, because roles are a type of claim.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Authorization based on claims is accomplished by comparing a set of claims to the access requirements of the operation and, depending on the outcome of that comparison, granting or denying access to the operation.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>, you can specify a class to use to run claims-based authorization, once again by assigning a value to the <ph id="ph2">`ServiceAuthorizationManager`</ph> property of <ph id="ph3">&lt;xref:System.ServiceModel.Description.ServiceAuthorizationBehavior&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Classes used to run claims-based authorization must derive from <ph id="ph1">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph>, which has just one method to override, <ph id="ph2">`AccessCheck()`</ph>.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> calls that method whenever an operation of the service is invoked and provides a <ph id="ph2">&lt;xref:System.ServiceModel.OperationContext&gt;</ph> object, which has the claims for the user in its <ph id="ph3">`ServiceSecurityContext.AuthorizationContext`</ph> property.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> does the work of assembling claims about the user from whatever security token the user provided for authentication, which leaves the of task of evaluating whether those claims suffice for the operation in question.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>That <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> automatically assembles claims from any kind of security token is a highly significant innovation, because it makes the code for authorization based on the claims entirely independent of the authentication mechanism.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>By contrast, authorization using ACLs or roles in ASP.NET is closely tied to Windows authentication.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Security: Confidentiality</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The confidentiality of messages exchanged with ASP.NET Web services can be ensured at the transport level by configuring the application within IIS to use the Secure Hypertext Transfer Protocol (HTTPS).</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The same can be done for <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications hosted within IIS.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications hosted outside of IIS can also be configured to use a secure transport protocol.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>More important, <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications can also be configured to secure the messages before they are transported, using the WS-Security protocol.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Securing just the body of a message using WS-Security allows it to be transmitted confidentially across intermediaries before reaching its final destination.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Globalization</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The ASP.NET configuration language allows you to specify the culture for individual services.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> does not support that configuration setting except in ASP.NET compatibility mode.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>To localize a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service that does not use ASP.NET compatibility mode, compile the service type into culture-specific assemblies, and have separate culture-specific endpoints for each culture-specific assembly.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Comparing ASP.NET Web Services to WCF Based on Purpose and Standards Used<ept id="p1">](../../../../docs/framework/wcf/feature-details/comparing-aspnet-web-services-to-wcf-based-on-purpose-and-standards-used.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>