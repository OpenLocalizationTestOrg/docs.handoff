<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="collectible-assemblies.md" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b26da264b2da40e19db4bc5e3b3575505f5c979c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\reflection-and-codedom\collectible-assemblies.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7e80d24675d73f036f5437cf34bc00a507295458</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a00eef7b99b6927cbe72c4e3f07863bf6ba0cb4b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Collectible assemblies for dynamic type generation</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Collectible assemblies for dynamic type generation</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Collectible assemblies<ept id="p1">*</ept> are dynamic assemblies that can be unloaded without unloading the application domain in which they were created.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>All managed and unmanaged memory used by a collectible assembly and the types it contains can be reclaimed.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Information such as the assembly name is removed from internal tables.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To enable unloading, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType&gt;</ph> flag when you create a dynamic assembly.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The assembly is transient (that is, it cannot be saved) and is subject to limitations described in the <bpt id="p1">[</bpt>Restrictions on Collectible Assemblies<ept id="p1">](#restrictions-on-collectible-assemblies)</ept> section.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The common language runtime (CLR) unloads a collectible assembly automatically when you release all objects associated with the assembly.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In all other respects, collectible assemblies are created and used in the same way as other dynamic assemblies.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Lifetime of collectible assemblies</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The lifetime of a collectible assembly is controlled by the existence of references to the types it contains and the objects that are created from those types.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The common language runtime does not unload an assembly as long as one or more of the following exist (<ph id="ph1">`T`</ph> is any type that is defined in the assembly):</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>An instance of <ph id="ph1">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>An instance of an array of <ph id="ph1">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>An instance of a generic type that has <ph id="ph1">`T`</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This includes generic collections of <ph id="ph1">`T`</ph>, even if that collection is empty.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>An instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents <ph id="ph3">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You must release all objects that represent parts of the assembly.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> that defines <ph id="ph2">`T`</ph> keeps a reference to the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, and the <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> object keeps a reference to the <ph id="ph5">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>, so references to these objects must be released.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Even the existence of a <ph id="ph1">&lt;xref:System.Reflection.Emit.LocalBuilder&gt;</ph> or an <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> used in the construction of <ph id="ph3">`T`</ph> prevents unloading.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A static reference to <ph id="ph1">`T`</ph> by another dynamically defined type <ph id="ph2">`T1`</ph> that is still reachable by executing code.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`T1`</ph> might derive from <ph id="ph2">`T`</ph>, or <ph id="ph3">`T`</ph> might be the type of a parameter in a method of <ph id="ph4">`T1`</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>ByRef<ept id="p1">**</ept> to a static field that belongs to <ph id="ph1">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, or <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph> that refers to <ph id="ph4">`T`</ph> or to a component of <ph id="ph5">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>An instance of any reflection object that could be used indirectly or directly to access the <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents <ph id="ph2">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Type&gt;</ph> object for <ph id="ph2">`T`</ph> can be obtained from an array type whose element type is <ph id="ph3">`T`</ph>, or from a generic type that has <ph id="ph4">`T`</ph> as a type argument.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A method <ph id="ph1">`M`</ph> on the call stack of any thread, where <ph id="ph2">`M`</ph> is a method of <ph id="ph3">`T`</ph> or a module-level method that is defined in the assembly.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A delegate to a static method that is defined in a module of the assembly.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If only one item from this list exists for only one type or one method in the assembly, the runtime cannot unload the assembly.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The runtime does not actually unload the assembly until finalizers have run for all items in the list.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For purposes of tracking lifetime, a constructed generic type such as <ph id="ph1">`List&lt;int&gt;`</ph> (in C#) or <ph id="ph2">`List(Of Integer)`</ph> (in Visual Basic) that is created and used in the generation of a collectible assembly is considered to have been defined either in the assembly that contains the generic type definition or in an assembly that contains the definition of one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The exact assembly that is used is an implementation detail and subject to change.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Restrictions on collectible assemblies</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to collectible assemblies:</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Static references<ept id="p1">**</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Types in an ordinary dynamic assembly cannot have static references to types that are defined in a collectible assembly.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, if you define an ordinary type that inherits from a type in a collectible assembly, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> exception is thrown.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A type in a collectible assembly can have static references to a type in another collectible assembly, but this extends the lifetime of the referenced assembly to the lifetime of the referencing assembly.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>COM interop<ept id="p1">**</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>No COM interfaces can be defined within a collectible assembly, and no instances of types within a collectible assembly can be converted into COM objects.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A type in a collectible assembly cannot serve as a COM callable wrapper (CCW) or runtime callable wrapper (RCW).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>However, types in collectible assemblies can use objects that implement COM interfaces.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Platform invoke<ept id="p1">**</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Methods that have the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> attribute will not compile when they are declared in a collectible assembly.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType&gt;</ph> instruction cannot be used in the implementation of a type in a collectible assembly, and such types cannot be marshaled to unmanaged code.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>However, you can call into native code by using an entry point that is declared in a non-collectible assembly.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Marshaling<ept id="p1">**</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Objects (in particular, delegates) that are defined in collectible assemblies cannot be marshaled.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This is a restriction on all transient emitted types.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Assembly loading<ept id="p1">**</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Reflection emit is the only mechanism that is supported for loading collectible assemblies.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Assemblies that are loaded by using any other form of assembly loading cannot be unloaded.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Context-bound objects<ept id="p1">**</ept><ph id="ph1">  </ph></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Context-static variables are not supported.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Types in a collectible assembly cannot extend <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>However, code in collectible assemblies can use context-bound objects that are defined elsewhere.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Thread-static data<ept id="p1">**</ept><ph id="ph1">     </ph></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Thread-static variables are not supported.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Emitting Dynamic Methods and Assemblies<ept id="p1">](emitting-dynamic-methods-and-assemblies.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>