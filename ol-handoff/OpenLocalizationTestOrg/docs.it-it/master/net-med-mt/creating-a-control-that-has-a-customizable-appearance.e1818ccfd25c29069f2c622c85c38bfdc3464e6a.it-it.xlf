<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="creating-a-control-that-has-a-customizable-appearance.md" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b2a8af3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3c7384c7c7dc65d0e53654832bfc78705f43fb21</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\controls\creating-a-control-that-has-a-customizable-appearance.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25e6fc744c4c2947ee0322064e609c237f4c37fe</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b1888e57d7aacfbaced94c40f1821e6c8697e77e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Creating a Control That Has a Customizable Appearance | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Creating a Control That Has a Customizable Appearance</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="introduction"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> gives you the ability to create a control whose appearance can be customized.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For example, you can change the appearance of a <ph id="ph1">&lt;xref:System.Windows.Controls.CheckBox&gt;</ph> beyond what setting properties will do by creating a new <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The following illustration shows a <ph id="ph1">&lt;xref:System.Windows.Controls.CheckBox&gt;</ph> that uses a default <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> and a <ph id="ph3">&lt;xref:System.Windows.Controls.CheckBox&gt;</ph> that uses a custom <ph id="ph4">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>A checkbox with the default control template.<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wpf/controls/media/ndp-checkboxdefault.png "</bpt>NDP_CheckBoxDefault<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A CheckBox that uses the default control template</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>A checkbox with a custom control template.<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wpf/controls/media/ndp-checkboxcustom.png "</bpt>NDP_CheckBoxCustom<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A CheckBox that uses a custom control template</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>If you follow the parts and states model when you create a control, your control's appearance will be customizable.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Designer tools such as Microsoft Expression Blend support the parts and states model, so when you follow this model your control will be customizable in those types of applications.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic discusses the parts and states model and how to follow it when you create your own control.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This topic uses an example of a custom control, <ph id="ph1">`NumericUpDown`</ph>, to illustrate the philosophy of this model.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`NumericUpDown`</ph> control displays a numeric value, which a user can increase or decrease by clicking on the control's buttons.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The following illustration shows the <ph id="ph1">`NumericUpDown`</ph> control that is discussed in this topic.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>NumericUpDown custom control.<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wpf/controls/media/ndp-numericupdown.png "</bpt>NDP_NumericUPDown<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A custom NumericUpDown control</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Parts and States Model<ept id="p1">](#parts_and_states_model)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Defining the Visual Structure and Visual Behavior of a Control in a ControlTemplate<ept id="p1">](#defining_the_visual_structure_and_visual_behavior_of_a_control_in_a_controltemplate)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Parts of the ControlTemplate in Code<ept id="p1">](#using_parts_of_the_controltemplate_in_code)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Providing the Control Contract<ept id="p1">](#providing_the_control_contract)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Complete Example<ept id="p1">](#complete_example)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This topic assumes that you know how to create a new <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> for an existing control, are familiar with what the elements on a control contract are, and understand the concepts discussed in <bpt id="p1">[</bpt>Customizing the Appearance of an Existing Control by Creating a ControlTemplate<ept id="p1">](../../../../docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To create a control that can have its appearance customized, you must create a control that inherits from the <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> class or one of its subclasses other than <ph id="ph2">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A control that inherits from <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> is a control that can be quickly created, but it does not use a <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> and you cannot customize its appearance.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Parts and States Model</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The parts and states model specifies how to define the visual structure and visual behavior of a control.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To follow the parts and states model, you should do the following:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Define the visual structure and visual behavior in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> of a control.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Follow certain best practices when your control's logic interacts with parts of the control template.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Provide a control contract to specify what should be included in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When you define the visual structure and visual behavior in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> of a control, application authors can change the visual structure and visual behavior of your control by creating a new <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> instead of writing code.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You must provide a control contract that tells application authors which <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects and states should be defined in the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You should follow some best practices when you interact with the parts in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> so that your control properly handles an incomplete <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If you follow these three principles, application authors will be able to create a <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> for your control just as easily as they can for the controls that ship with <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The following section explains each of these recommendations in detail.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Defining the Visual Structure and Visual Behavior of a Control in a ControlTemplate</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When you create your custom control by using the parts and states model, you define the control's visual structure and visual behavior in its <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> instead of in its logic.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The visual structure of a control is the composite of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects that make up the control.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The visual behavior is the way the control appears when it is in a certain state.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information about creating a <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> that specifies the visual structure and visual behavior of a control, see <bpt id="p1">[</bpt>Customizing the Appearance of an Existing Control by Creating a ControlTemplate<ept id="p1">](../../../../docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In the example of the <ph id="ph1">`NumericUpDown`</ph> control, the visual structure includes two <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph> controls and a <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If you add these controls in the code of the <ph id="ph1">`NumericUpDown`</ph> control--in its constructor, for example--the positions of those controls would be unalterable.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Instead of defining the control's visual structure and visual behavior in its code, you should define it in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Then an application developer to customize the position of the buttons and <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> and specify what behavior occurs when <ph id="ph2">`Value`</ph> is negative because the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> can be replaced.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The following example shows the visual structure of the <ph id="ph1">`NumericUpDown`</ph> control, which includes a <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph> to increase <ph id="ph3">`Value`</ph>, a <ph id="ph4">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph> to decrease <ph id="ph5">`Value`</ph>, and a <ph id="ph6">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> to display <ph id="ph7">`Value`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VSMCustomControl#VisualStructure<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#visualstructure)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A visual behavior of the <ph id="ph1">`NumericUpDown`</ph> control is that the value is in a red font if it is negative.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you change the <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock.Foreground%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> in code when the <ph id="ph3">`Value`</ph> is negative, the <ph id="ph4">`NumericUpDown`</ph> will always show a red negative value.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You specify the visual behavior of the control in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> by adding <ph id="ph2">&lt;xref:System.Windows.VisualState&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The following example shows the <ph id="ph1">&lt;xref:System.Windows.VisualState&gt;</ph> objects for the <ph id="ph2">`Positive`</ph> and <ph id="ph3">`Negative`</ph> states.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Positive`</ph> and <ph id="ph2">`Negative`</ph> are mutually exclusive (the control is always in exactly one of the two), so the example puts the <ph id="ph3">&lt;xref:System.Windows.VisualState&gt;</ph> objects into a single <ph id="ph4">&lt;xref:System.Windows.VisualStateGroup&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>When the control goes into the <ph id="ph1">`Negative`</ph> state, the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock.Foreground%2A&gt;</ph> of the <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> turns red.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When the control is in the <ph id="ph1">`Positive`</ph> state, the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock.Foreground%2A&gt;</ph> returns to it original value.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Defining <ph id="ph1">&lt;xref:System.Windows.VisualState&gt;</ph> objects in a <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is further discussed in <bpt id="p1">[</bpt>Customizing the Appearance of an Existing Control by Creating a ControlTemplate<ept id="p1">](../../../../docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Be sure to set the <ph id="ph1">&lt;xref:System.Windows.VisualStateManager.VisualStateGroups%2A?displayProperty=fullName&gt;</ph> attached property on the root <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> of the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VSMCustomControl#ValueStates<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#valuestates)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Using Parts of the ControlTemplate in Code</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> author might omit <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.VisualState&gt;</ph> objects, either purposefully or by mistake, but your control's logic might need those parts to function properly.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The parts and states model specifies that your control should be resilient to a <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> that is missing <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.VisualState&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Your control should not throw an exception or report an error if a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.VisualState&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> is missing from the <ph id="ph4">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This section describes the recommended practices for interacting with <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects and managing states.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Anticipate Missing FrameworkElement Objects</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When you define <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects in the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>, your control's logic might need to interact with some of them.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`NumericUpDown`</ph> control subscribes to the buttons' <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event to increase or decrease <ph id="ph3">`Value`</ph> and sets the <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock.Text%2A&gt;</ph> property of the <ph id="ph5">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> to <ph id="ph6">`Value`</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If a custom <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> omits the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> or buttons, it is acceptable that the control loses some of its functionality, but you should be sure that your control does not cause an error.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, if a <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> does not contain the buttons to change <ph id="ph2">`Value`</ph>, the <ph id="ph3">`NumericUpDown`</ph> loses that functionality, but an application that uses the <ph id="ph4">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> will continue to run.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following practices will ensure that your control responds properly to missing <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Set the <ph id="ph1">`x:Name`</ph> attribute for each <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that you need to reference in code.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Define private properties for each <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that you need to interact with.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Subscribe to and unsubscribe from any events that your control handles in the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property's set accessor.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Set the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> properties that you defined in step 2 in the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This is the earliest that the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> in the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is available to the control.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`x:Name`</ph> of the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> to get it from the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Check that the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is not <ph id="ph2">`null`</ph> before accessing its members.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If it is <ph id="ph1">`null`</ph>, do not report an error.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following examples show how the <ph id="ph1">`NumericUpDown`</ph> control interacts with <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects in accordance with the recommendations in the preceding list.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In the example that defines the visual structure of the <ph id="ph1">`NumericUpDown`</ph> control in the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>, the <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph> that increases <ph id="ph4">`Value`</ph> has its <ph id="ph5">`x:Name`</ph> attribute set to <ph id="ph6">`UpButton`</ph>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following example declares a property called <ph id="ph1">`UpButtonElement`</ph> that represents the <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph> that is declared in the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`set`</ph> accessor first unsubscribes to the button's <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event if <ph id="ph3">`UpDownElement`</ph> is not <ph id="ph4">`null`</ph>, then it sets the property, and then it subscribes to the <ph id="ph5">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>There is also a property defined, but not shown here, for the other <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph>, called <ph id="ph2">`DownButtonElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#UpButtonProperty<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#upbuttonproperty)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#UpButtonProperty<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#upbuttonproperty)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The following example shows the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> for the <ph id="ph2">`NumericUpDown`</ph> control.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetTemplateChild%2A&gt;</ph> method to get the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects from the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Notice that the example guards against cases where <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetTemplateChild%2A&gt;</ph> finds a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> with the specified name that is not of the expected type.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>It is also a best practice to ignore elements that have the specified <ph id="ph1">`x:Name`</ph> but are of the wrong type.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#ApplyTemplate<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#applytemplate)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#ApplyTemplate<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#applytemplate)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By following the practices that are shown in the previous examples, you ensure that your control will continue to run when the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is missing a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Use the VisualStateManager to Manage States</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The<ph id="ph1">&lt;xref:System.Windows.VisualStateManager&gt;</ph> keeps track of the states of a control and performs the logic necessary to transition between states.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When you add <ph id="ph1">&lt;xref:System.Windows.VisualState&gt;</ph> objects to the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>, you add them to a <ph id="ph3">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> and add the <ph id="ph4">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> to the <ph id="ph5">&lt;xref:System.Windows.VisualStateManager.VisualStateGroups%2A?displayProperty=fullName&gt;</ph> attached property so that the <ph id="ph6">&lt;xref:System.Windows.VisualStateManager&gt;</ph> has access to them.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example repeats the previous example that shows the <ph id="ph1">&lt;xref:System.Windows.VisualState&gt;</ph> objects that corresponds to the <ph id="ph2">`Positive`</ph> and <ph id="ph3">`Negative`</ph> states of the control.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> in the <ph id="ph2">`Negative`</ph><ph id="ph3">&lt;xref:System.Windows.VisualState&gt;</ph> turns the <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock.Foreground%2A&gt;</ph> of the <ph id="ph5">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> red.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`NumericUpDown`</ph> control is in the <ph id="ph2">`Negative`</ph> state, the storyboard in the <ph id="ph3">`Negative`</ph> state begins.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> in the <ph id="ph2">`Negative`</ph> state stops when the control returns to the <ph id="ph3">`Positive`</ph> state.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Positive`</ph><ph id="ph2">&lt;xref:System.Windows.VisualState&gt;</ph> does not need to contain a <ph id="ph3">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> because when the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> for the <ph id="ph5">`Negative`</ph> stops, the <ph id="ph6">&lt;xref:System.Windows.Controls.TextBlock.Foreground%2A&gt;</ph> returns to its original color.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VSMCustomControl#ValueStates<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#valuestates)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> is given a name, but the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> is not in the control contract for <ph id="ph3">`NumericUpDown`</ph> because the control's logic never references the <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Elements that are referenced in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> have names, but do not need to be part of the control contract because a new <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> for the control might not need to reference that element.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For example, someone who creates a new <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> for <ph id="ph2">`NumericUpDown`</ph> might decide to not indicate that <ph id="ph3">`Value`</ph> is negative by changing the <ph id="ph4">&lt;xref:System.Windows.Controls.Control.Foreground%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>In that case, neither the code nor the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> references the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> by name.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The control's logic is responsible for changing the control's state.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following example shows that the <ph id="ph1">`NumericUpDown`</ph> control calls the <ph id="ph2">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph> method to go into the <ph id="ph3">`Positive`</ph> state when <ph id="ph4">`Value`</ph> is 0 or greater, and the <ph id="ph5">`Negative`</ph> state when <ph id="ph6">`Value`</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#ValueStateChange<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#valuestatechange)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#ValueStateChange<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#valuestatechange)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph> method performs the logic necessary to start and stop the storyboards appropriately.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>When a control calls <ph id="ph1">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph> to change its state, the <ph id="ph2">&lt;xref:System.Windows.VisualStateManager&gt;</ph> does the following:</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.VisualState&gt;</ph> that the control is going to has a <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, the storyboard begins.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Then, if the <ph id="ph1">&lt;xref:System.Windows.VisualState&gt;</ph> that the control is coming from has a <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, the storyboard ends.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>If the control is already in the state that is specified, <ph id="ph1">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph> takes no action and returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>If state that is specified doesn't exist in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> of <ph id="ph2">`control`</ph>, <ph id="ph3">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph> takes no action and returns <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Best Practices for Working with the VisualStateManager</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>It is recommended that you do the following to maintain your control's states:</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Use properties to track its state.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Create a helper method to transition between states.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`NumericUpDown`</ph> control uses its <ph id="ph2">`Value`</ph> property to track whether it is in the <ph id="ph3">`Positive`</ph> or <ph id="ph4">`Negative`</ph> state.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`NumericUpDown`</ph> control also defines the <ph id="ph2">`Focused`</ph> and <ph id="ph3">`UnFocused`</ph> states, which tracks the <ph id="ph4">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If you use states that do not naturally correspond to a property of the control, you can define a private property to track the state.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A single method that updates all the states centralizes calls to the <ph id="ph1">&lt;xref:System.Windows.VisualStateManager&gt;</ph> and keeps your code manageable.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The following example shows the <ph id="ph1">`NumericUpDown`</ph> control's helper method, <ph id="ph2">`UpdateStates`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`Value`</ph> is greater than or equal to 0, the <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> is in the <ph id="ph3">`Positive`</ph> state.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`Value`</ph> is less than 0, the control is in the <ph id="ph2">`Negative`</ph> state.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the control is in the <ph id="ph3">`Focused`</ph> state; otherwise, it is in the <ph id="ph4">`Unfocused`</ph> state.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The control can call <ph id="ph1">`UpdateStates`</ph> whenever it needs to change its state, regardless of what state changes.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#UpdateStates<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#UpdateStates<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>If you pass a state name to <ph id="ph1">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph> when the control is already in that state, <ph id="ph2">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph> does nothing, so you don't need to check for the control's current state.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>For example, if <ph id="ph1">`Value`</ph> changes from one negative number to another negative number, the storyboard for the <ph id="ph2">`Negative`</ph> state is not interrupted and the user will not see a change in the control.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.VisualStateManager&gt;</ph> uses <ph id="ph2">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> objects to determine which state to exit when you call <ph id="ph3">&lt;xref:System.Windows.VisualStateManager.GoToState%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The control is always in one state for each <ph id="ph1">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> that is defined in its <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> and only leaves a state when it goes into another state from the same <ph id="ph3">&lt;xref:System.Windows.VisualStateGroup&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> of the <ph id="ph2">`NumericUpDown`</ph> control defines the <ph id="ph3">`Positive`</ph> and <ph id="ph4">`Negative`</ph><ph id="ph5">&lt;xref:System.Windows.VisualState&gt;</ph> objects in one <ph id="ph6">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> and the <ph id="ph7">`Focused`</ph> and <ph id="ph8">`Unfocused`</ph><ph id="ph9">&lt;xref:System.Windows.VisualState&gt;</ph> objects in another.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>(You can see the <ph id="ph1">`Focused`</ph> and <ph id="ph2">`Unfocused`</ph><ph id="ph3">&lt;xref:System.Windows.VisualState&gt;</ph> defined in the <bpt id="p1">[</bpt>Complete Example<ept id="p1">](#complete_example)</ept> section in this topic When the control goes from the <ph id="ph4">`Positive`</ph> state to the <ph id="ph5">`Negative`</ph> state, or vice versa, the control remains in either the <ph id="ph6">`Focused`</ph> or <ph id="ph7">`Unfocused`</ph> state.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>There are three typical places where the state of a control might change:</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is applied to the <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>When a property changes.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When an event occurs.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The following examples demonstrate updating the state of the <ph id="ph1">`NumericUpDown`</ph> control in these cases.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>You should update the state of the control in the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> method so that the control appears in the correct state when the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is applied.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The following example calls <ph id="ph1">`UpdateStates`</ph> in <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> to ensure that the control is in the appropriate states.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For example, suppose that you create a <ph id="ph1">`NumericUpDown`</ph> control, and then set its <ph id="ph2">&lt;xref:System.Windows.Controls.Control.Foreground%2A&gt;</ph> to green and <ph id="ph3">`Value`</ph> to -5.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If you do not call <ph id="ph1">`UpdateStates`</ph> when the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is applied to the <ph id="ph3">`NumericUpDown`</ph> control, the control is not in the <ph id="ph4">`Negative`</ph> state and the value is green instead of red.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>You must call <ph id="ph1">`UpdateStates`</ph> to put the control in the <ph id="ph2">`Negative`</ph> state.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#ApplyTemplate<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#applytemplate)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#ApplyTemplate<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#applytemplate)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>You often need to update the states of a control when a property changes.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example shows the entire <ph id="ph1">`ValueChangedCallback`</ph> method.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`ValueChangedCallback`</ph> is called when <ph id="ph2">`Value`</ph> changes, the method calls <ph id="ph3">`UpdateStates`</ph> in case <ph id="ph4">`Value`</ph> changed from positive to negative or vice versa.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It is acceptable to call <ph id="ph1">`UpdateStates`</ph> when <ph id="ph2">`Value`</ph> changes but remains positive or negative because in that case, the control will not change states.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#EntireValueChangedCallback<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#entirevaluechangedcallback)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#EntireValueChangedCallback<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#entirevaluechangedcallback)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>You might also need to update states when an event occurs.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following example shows that the <ph id="ph1">`NumericUpDown`</ph> calls <ph id="ph2">`UpdateStates`</ph> on the <ph id="ph3">&lt;xref:System.Windows.Controls.Control&gt;</ph> to handle the <ph id="ph4">&lt;xref:System.Windows.UIElement.GotFocus&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#OnGotFocus<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#ongotfocus)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#OnGotFocus<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#ongotfocus)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.VisualStateManager&gt;</ph> helps you manage your control's states.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>By using the <ph id="ph1">&lt;xref:System.Windows.VisualStateManager&gt;</ph>, you ensure that your control correctly transitions between states.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If you follow the recommendations described in this section for working with the <ph id="ph1">&lt;xref:System.Windows.VisualStateManager&gt;</ph>, your control's code will remain readable and maintainable.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Providing the Control Contract</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>You provide a control contract so that <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> authors will know what to put in the template.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>A control contract has three elements:</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The visual elements that the control's logic uses.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The states of the control and the group each state belongs to.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The public properties that visually affect the control.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Someone that creates a new <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> needs to know what <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects the control's logic uses, what type each object is, and what its name is.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> author also needs to know the name of each possible state the control can be in, and which <ph id="ph2">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> the state is in.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Returning to the <ph id="ph1">`NumericUpDown`</ph> example, the control expects the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to have the following <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects:</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph> called <ph id="ph2">`UpButton`</ph>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.RepeatButton&gt;</ph> called <ph id="ph2">`DownButton.`</ph></source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The control can be in the following states:</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`ValueStates`</ph><ph id="ph2">&lt;xref:System.Windows.VisualStateGroup&gt;</ph></source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`FocusStates`</ph><ph id="ph2">&lt;xref:System.Windows.VisualStateGroup&gt;</ph></source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>To specify what <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> objects the control expects, you use the <ph id="ph2">&lt;xref:System.Windows.TemplatePartAttribute&gt;</ph>, which specifies the name and type of the expected elements.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>To specify the possible states of a control, you use the <ph id="ph1">&lt;xref:System.Windows.TemplateVisualStateAttribute&gt;</ph>, which specifies the state's name and which <ph id="ph2">&lt;xref:System.Windows.VisualStateGroup&gt;</ph> it belongs to.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Put the <ph id="ph1">&lt;xref:System.Windows.TemplatePartAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.TemplateVisualStateAttribute&gt;</ph> on the class definition of the control.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Any public property that affects the appearance of your control is also a part of the control contract.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example specifies the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> object and states for the <ph id="ph2">`NumericUpDown`</ph> control.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#ControlContract<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#controlcontract)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#ControlContract<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#controlcontract)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Complete Example</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The following example is the entire <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> for the <ph id="ph2">`NumericUpDown`</ph> control.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>VSMCustomControl#NUDTemplate<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/themes/generic.xaml#nudtemplate)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The following example shows the logic for the <ph id="ph1">`NumericUpDown`</ph>.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>VSMCustomControl#ControlLogic<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#controllogic)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VSMCustomControl#ControlLogic<ept id="p2">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#controllogic)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Customizing the Appearance of an Existing Control by Creating a ControlTemplate<ept id="p1">](../../../../docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Control Customization<ept id="p1">](../../../../docs/framework/wpf/controls/control-customization.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>