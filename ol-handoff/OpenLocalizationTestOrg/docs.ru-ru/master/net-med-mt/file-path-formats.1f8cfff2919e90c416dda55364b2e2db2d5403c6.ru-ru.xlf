<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="file-path-formats.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ecaae9e1af359ead1c15a9e431eac21e41040efe</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\io\file-path-formats.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8871b72dede1c8a8651bb7fff8b9e516199651fc</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">07df19e54b162cbf1b961553be49a071243b39e8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>File path formats on Windows systems</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>File path formats on Windows systems</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Members of many of the types in the <ph id="ph1">&lt;xref:System.IO&gt;</ph> namespace include a <ph id="ph2">`path`</ph> parameter that lets you specify an absolute or relative path to a file system resource.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This path is then passed to <bpt id="p1">[</bpt>Windows file system APIs<ept id="p1">](/windows/desktop/fileio/file-systems)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic discusses the formats for file paths that you can use on Windows systems.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Traditional DOS paths</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A standard DOS path can consist of three components:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A volume or drive letter followed by the volume separator (<ph id="ph1">`:`</ph>).</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A directory name.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>directory separator character<ept id="p1">](&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;)</ept> separates subdirectories within the nested directory hierarchy.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>An optional filename.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>directory separator character<ept id="p1">](&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;)</ept> separates the file path and the filename.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If all three components are present, the path is absolute.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If no volume or drive letter is specified and the directory names begins with the <bpt id="p1">[</bpt>directory separator character<ept id="p1">](&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;)</ept>, the path is relative from the root of the current drive.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Otherwise, the path is relative to the current directory.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following table shows some possible directory and file paths.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Path</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>An absolute file path from the root of drive C:</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>An absolute path from the root of the current drive.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A relative path to a file in a subdirectory of the current directory.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A relative path to file in a directory that is a peer of the current directory.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>An absolute path to a file from the root of drive C:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A relative path from the current directory of the C: drive.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Note the difference between the last two paths.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <ph id="ph1">&lt;xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Note that such a path can include relative directory segments (<ph id="ph1">`.`</ph> and <ph id="ph2">`..`</ph>) and still be fully qualified if the resolved path always points to the same location.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between absolute and relative paths.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>It assumes that the directory D:\FY2018\ exists, and that you haven't set any curent directory for D:\ from the command prompt before running the example.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>UNC paths</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A server or host name, which is prefaced by <ph id="ph1">\\</ph><ph id="ph2">\\</ph>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A share name, which is separated from the host name by <ph id="ph1">\\</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Together, the server and share name make up the volume.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A directory name.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>directory separator character<ept id="p1">](&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;)</ept> separates subdirectories within the nested directory hierarchy.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>An optional filename.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>directory separator character<ept id="p1">](&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;)</ept> separates the file path and the filename.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following are some examples of UNC paths:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Path</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The root directory of the C: drive on <ph id="ph1">`system07`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The Foo.txt file in the Test directory of the <ph id="ph1">\\</ph><ph id="ph2">\\</ph>Server2<ph id="ph3">\\</ph>Share volume.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>UNC paths must always be fully qualified.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>They can include relative directory segments (<ph id="ph1">`.`</ph> and <ph id="ph2">`..`</ph>), but these must be part of a fully qualified path.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can use relative paths only by mapping a UNC path to a drive letter.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>DOS device paths</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The Windows operating system has a unified object model that points to all resources, including files.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This special folder is accessed via the DOS device path syntax, which is one of:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The DOS device path consists of the following components:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The device path specifier (<ph id="ph1">`\\.\`</ph> or <ph id="ph2">`\\?\`</ph>), which identifies the path as a DOS device path.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\\?\`</ph> is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A symbolic link to the "real" device object (C: in this case).</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The first segment of the DOS device path after the device path specifier identifies the volume or drive.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>(For example, <ph id="ph1">`\\?\C:\`</ph> and <ph id="ph2">`\\.\BootPartition\`</ph>.)</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>There is a specific link for UNCs that is called, not surprisingly, <ph id="ph1">`UNC`</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For device UNCs, the server/share portion is forms the volume.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For example, in <ph id="ph1">`\\?\server1\e:\utilities\\filecomparer\`</ph>, the server/share portion is server1\utilities.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is significant when calling a method such as <ph id="ph1">&lt;xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType&gt;</ph> with relative directory segments; it is never possible to navigate past the volume.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>DOS device paths are fully qualified by definition.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Relative directory segments (<ph id="ph1">`.`</ph> and <ph id="ph2">`..`</ph>) are not allowed.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Current directories never enter into their usage.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Example: Ways to refer to the same file</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <ph id="ph1">&lt;xref:System.IO&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The example instantiates a <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> object and uses its <ph id="ph2">&lt;xref:System.IO.FileInfo.Name&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.FileInfo.Length&gt;</ph> properties to display the filename and the length of the file.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Path normalization</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Almost all paths passed to Windows APIs are normalized.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>During normalization, Windows performs the following steps:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Identifies the path.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Applies the current directory to partially qualified (relative) paths.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Canonicalizes component and directory separators.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Evaluates relative directory components (<ph id="ph1">`.`</ph> for the current directory and <ph id="ph2">`..`</ph> for the parent directory).</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Trims certain characters.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This normalization happens implicitly, but you can do it explicitly by calling the <ph id="ph1">&lt;xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType&gt;</ph> method, which wraps a call to the  <bpt id="p1">[</bpt>GetFullPathName() function<ept id="p1">](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)</ept>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You can also call the Windows <bpt id="p1">[</bpt>GetFullPathName() function<ept id="p1">](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)</ept> directly using P/Invoke.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Identifying the path</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The first step in path normalization is identifying the type of path.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Paths fall into one of a few categories:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>They are device paths; that is, they begin with two separators and a question mark or period (<ph id="ph1">`\\?`</ph> or <ph id="ph2">`\\.`</ph>).</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>They are UNC paths; that is, they begin with two separators without a question mark or period.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (<ph id="ph1">`C:\`</ph>).</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>They designate a legacy device (<ph id="ph1">`CON`</ph>, <ph id="ph2">`LPT1`</ph>).</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>They are relative to the root of the current drive; that is, they begin with a single component separator (<ph id="ph1">`\`</ph>).</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (<ph id="ph1">`C:`</ph>).</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>They are relative to the current directory; that is, they begin with anything else (<ph id="ph1">`temp\testfile.txt`</ph>).</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The type of the path determines whether or not a current directory is applied in some way.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It also determines what the "root" of the path is.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Handling legacy devices</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If the path is a legacy DOS device such as <ph id="ph1">`CON`</ph>, <ph id="ph2">`COM1`</ph>, or <ph id="ph3">`LPT1`</ph>, it is converted into a device path by prepending <ph id="ph4">`\\.\`</ph> and returned.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A path that begins with a legacy device name is always interpreted as a legacy device by the <ph id="ph1">&lt;xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For example, the DOS device path for <ph id="ph1">`CON.TXT`</ph> is <ph id="ph2">`\\.\CON`</ph>, and the DOS device path for <ph id="ph3">`COM1.TXT\file1.txt`</ph> is <ph id="ph4">`\\.\COM1`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Applying the current directory</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If a path isn't fully qualified, Windows applies the current directory to it.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>UNCs and device paths do not have the current directory applied.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Neither does a full drive with separator C:<ph id="ph1">\\</ph>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If the path starts with a single component separator, the drive from the current directory is applied.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For example, if the file path is <ph id="ph1">`\utilities`</ph> and the current directory is <ph id="ph2">`C:\temp\`</ph>, normalization produces <ph id="ph3">`C:\utilities`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If the last current directory was not set, the drive alone is applied.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>For example, if the file path is <ph id="ph1">`D:sources`</ph>, the current directory is <ph id="ph2">`C:\Documents\`</ph>, and the last current directory on drive D: was <ph id="ph3">`D:\sources\`</ph>, the result is <ph id="ph4">`D:\sources\sources`</ph>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>These "drive relative" paths are a common source of program and script logic errors.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If the path starts with something other than a separator, the current drive and current directory are applied.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, if the path is <ph id="ph1">`filecompare`</ph> and the current directory is <ph id="ph2">`C:\utilities\`</ph>, the result is <ph id="ph3">`C:\utilities\filecompare\`</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Any thread can change the current directory at any time.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Starting with .NET Core 2.1, you can call the <ph id="ph1">&lt;xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType&gt;</ph> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Canonicalizing separators</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>All forward slashes (<ph id="ph1">`/`</ph>) are converted into the standard Windows separator, the back slash (<ph id="ph2">`\`</ph>).</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Evaluating relative components</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>As the path is processed, any components or segments that are composed of a single or a double period (<ph id="ph1">`.`</ph> or <ph id="ph2">`..`</ph>) are evaluated:</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For a single period, the current segment is removed, since it refers to the current directory.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Parent directories are only removed if they aren't past the root of the path.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The root of the path depends on the type of path.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It is the drive (<ph id="ph1">`C:\`</ph>) for DOS paths, the server/share for UNCs (<ph id="ph2">`\\Server\Share`</ph>), and the device path prefix for device paths (<ph id="ph3">`\\?\`</ph> or <ph id="ph4">`\\.\`</ph>).</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Trimming characters</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If a segment ends in a single period, that period is removed.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>(A segment of a single or double period is normalized in the previous step.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>A segment of three or more periods is not normalized and is actually a valid file/directory name.)</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>If the last segment is simply a single or double period, it falls under the relative components rule above.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>You should <bpt id="p1">**</bpt>never<ept id="p1">**</ept> create a directory or filename with a trailing space.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Skipping normalization</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Normally, any path passed to a Windows API is (effectively) passed to the <bpt id="p1">[</bpt>GetFullPathName function<ept id="p1">](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)</ept> and normalized.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>There is one important exception: a device path that begins with a question mark instead of a period.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Unless the path starts exactly with <ph id="ph1">`\\?\`</ph> (note the use of the canonical backslash), it is normalized.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Why would you want to skip normalization?</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>There are three major reasons:</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>To get access to paths that are normally unavailable but are legal.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>A file or directory called <ph id="ph1">`hidden.`</ph>, for example, is impossible to access in any other way.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>To improve performance by skipping normalization if you've already normalized.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>On the .NET Framework only, to skip the <ph id="ph1">`MAX_PATH`</ph> check for path length to allow for paths that are greater than 259 characters.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Most APIs allow this, with some exceptions.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>.NET Core handles long paths implicitly and does not perform a <ph id="ph1">`MAX_PATH`</ph> check.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MAX_PATH`</ph> check applies only to the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Paths that start with <ph id="ph1">`\\?\`</ph> are still normalized if you explicitly pass them to the <bpt id="p1">[</bpt>GetFullPathName function<ept id="p1">](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)</ept>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Note that you can paths of more than <ph id="ph1">`MAX_PATH`</ph> characters to <bpt id="p1">[</bpt>GetFullPathName<ept id="p1">](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)</ept> without <ph id="ph2">`\\?\`</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>It supports arbitrary length paths up to the maximum string size that Windows can handle.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Case and the Windows file system</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>That is, directory and file names reflect the casing of the strings used when they are created.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For example, the method call</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>creates a directory named TeStDiReCtOrY.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For example, the following code renames a file named test.txt to Test.txt:</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>However, directory and file name comparisons are case-insensitive.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>