<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ad79b5b914e6e55587f8af08d616856420ac5ebc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\character-classes-in-regular-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">78acd6e7612563c954920c68f9f580391fd8e178</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da6159639b9fa5437cc5329e80aecc84913fcbd9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Character Classes in Regular Expressions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Character Classes in Regular Expressions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> A character class defines a set of characters, any one of which can occur in an input string for a match to succeed.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The regular expression language in .NET supports the following character classes:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Positive character groups.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A character in the input string must match one of a specified set of characters.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Positive Character Group<ept id="p1">](#PositiveGroup)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Negative character groups.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A character in the input string must not match one of a specified set of characters.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Negative Character Group<ept id="p1">](#NegativeGroup)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Any character.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`.`</ph> (dot or period) character in a regular expression is a wildcard character that matches any character except <ph id="ph2">`\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Any Character<ept id="p1">](#AnyCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A general Unicode category or named block.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A character in the input string must be a member of a particular Unicode category or must fall within a contiguous range of Unicode characters for a match to succeed.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Unicode Category or Unicode Block<ept id="p1">](#CategoryOrBlock)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A negative general Unicode category or named block.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A character in the input string must not be a member of a particular Unicode category or must not fall within a contiguous range of Unicode characters for a match to succeed.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Negative Unicode Category or Unicode Block<ept id="p1">](#NegativeCategoryOrBlock)</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A word character.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A character in the input string can belong to any of the Unicode categories that are appropriate for characters in words.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Word Character<ept id="p1">](#WordCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A non-word character.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A character in the input string can belong to any Unicode category that is not a word character.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Non-Word Character<ept id="p1">](#NonWordCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>A white-space character.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A character in the input string can be any Unicode separator character, as well as any one of a number of control characters.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>White-Space Character<ept id="p1">](#WhitespaceCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A non-white-space character.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A character in the input string can be any character that is not a white-space character.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Non-White-Space Character<ept id="p1">](#NonWhitespaceCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A decimal digit.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A character in the input string can be any of a number of characters classified as Unicode decimal digits.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Decimal Digit Character<ept id="p1">](#DigitCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A non-decimal digit.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A character in the input string can be anything other than a Unicode decimal digit.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Decimal Digit Character<ept id="p1">](#NonDigitCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>.NET supports character class subtraction expressions, which enables you to define a set of characters as the result of excluding one character class from another character class.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character Class Subtraction<ept id="p1">](#CharacterClassSubtraction)</ept>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Character classes that match characters by category, such as <bpt id="p1">[</bpt>\w<ept id="p1">](#WordCharacter)</ept> to match word characters or <bpt id="p2">[</bpt>\p{}<ept id="p2">](#CategoryOrBlock)</ept> to match a Unicode category, rely on the <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo&gt;</ph> class to provide information about character categories.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v462](../../../includes/net-v462-md.md)]</ph>, character categories are based on <bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph> through the <ph id="ph2">[!INCLUDE[net_v461](../../../includes/net-v461-md.md)]</ph>, they are based on <bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Positive Character Group: [ ]</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This list of characters may be specified individually, as a range, or both.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The syntax for specifying a list of individual characters is as follows:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">*</bpt>character_group<ept id="p1">*</ept>]</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>character_group<ept id="p1">*</ept> is a list of the individual characters that can appear in the input string for a match to succeed.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>character_group<ept id="p1">*</ept> can consist of any combination of one or more literal characters, <bpt id="p2">[</bpt>escape characters<ept id="p2">](../../../docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, or character classes.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The syntax for specifying a range of characters is as follows:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>firstCharacter<ept id="p1">*</ept> is the character that begins the range and <bpt id="p2">*</bpt>lastCharacter<ept id="p2">*</ept> is the character that ends the range.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Two characters are contiguous if they have adjacent Unicode code points.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Some common regular expression patterns that contain positive character classes are listed in the following table.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Match all vowels.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Match all punctuation and decimal digit characters.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Match all white-space and punctuation.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following example defines a positive character group that contains the characters "a" and "e" so that the input string must contain the words "grey" or "gray" followed by another word for a match to occur.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#1<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/positivecharclasses.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#1<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/positivecharclasses.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`gr[ae]y\s\S+?[\s|\p{P}]`</ph> is defined as follows:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Match the literal characters "gr".</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Match either an "a" or an "e".</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Match the literal character "y" followed by a white-space character.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Match one or more non-white-space characters, but as few as possible.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Match either a white-space character or a punctuation mark.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following example matches words that begin with any capital letter.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>It uses the subexpression <ph id="ph1">`[A-Z]`</ph> to represent the range of capital letters from A to Z.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#3<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/range.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#3<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/range.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b[A-Z]\w*\b`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Match any uppercase character from A to Z.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Negative Character Group: [^]</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The list of characters may be specified individually, as a range, or both.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The syntax for specifying a list of individual characters is as follows:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">*</bpt>^character_group<ept id="p1">*</ept>]</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>character_group<ept id="p1">*</ept> is a list of the individual characters that cannot appear in the input string for a match to succeed.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>character_group<ept id="p1">*</ept> can consist of any combination of one or more literal characters, <bpt id="p2">[</bpt>escape characters<ept id="p2">](../../../docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, or character classes.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The syntax for specifying a range of characters is as follows:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>[^<bpt id="p1">*</bpt>firstCharacter<ept id="p1">*</ept><ph id="ph1">-</ph><bpt id="p2">*</bpt>lastCharacter<ept id="p2">*</ept>]</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>firstCharacter<ept id="p1">*</ept> is the character that begins the range, and <bpt id="p2">*</bpt>lastCharacter<ept id="p2">*</ept> is the character that ends the range.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Two characters are contiguous if they have adjacent Unicode code points.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Two or more character ranges can be concatenated.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use <ph id="ph1">`[0-9a-fA-F]`</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The leading carat character (<ph id="ph1">`^`</ph>) in a negative character group is mandatory and indicates the character group is a negative character group instead of a positive character group.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>A negative character group in a larger regular expression pattern is not a zero-width assertion.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>That is, after evaluating the negative character group, the regular expression engine advances one character in the input string.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Some common regular expression patterns that contain negative character groups are listed in the following table.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Match all characters except vowels.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Match all characters except punctuation and decimal digit characters.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following example matches any word that begins with the characters "th" and is not followed by an "o".</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#2<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/negativecharclasses.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#2<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/negativecharclasses.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\bth[^o]\w+\b`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Match the literal characters "th".</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Match any character that is not an "o".</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>End at a word boundary.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Any Character: .</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The period character (.) matches any character except <ph id="ph1">`\n`</ph> (the newline character, \u000A), with the following two qualifications:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern is modified by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option, or if the portion of the pattern that contains the <ph id="ph2">`.`</ph> character class is modified by the <ph id="ph3">`s`</ph> option, <ph id="ph4">`.`</ph> matches any character.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example illustrates the different behavior of the <ph id="ph1">`.`</ph> character class by default and with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^.+`</ph> starts at the beginning of the string and matches every character.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, <ph id="ph1">`\r`</ph> or \u000D, but it does not match <ph id="ph2">`\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option interprets the entire input string as a single line, it matches every character in the input string, including <ph id="ph2">`\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Regex.Language.CharacterClasses#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Regex.Language.CharacterClasses#5<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Because it matches any character except <ph id="ph1">`\n`</ph>, the <ph id="ph2">`.`</ph> character class also matches <ph id="ph3">`\r`</ph> (the carriage return character, \u000D).</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In a positive or negative character group, a period is treated as a literal period character, and not as a character class.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Positive Character Group<ept id="p1">](#PositiveGroup)</ept> and <bpt id="p2">[</bpt>Negative Character Group<ept id="p2">](#NegativeGroup)</ept> earlier in this topic.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration by defining a regular expression that includes the period character (<ph id="ph1">`.`</ph>) both as a character class and as a member of a positive character group.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b.*[.?!;:](\s|\z)`</ph> begins at a word boundary, matches any character until it encounters one of four punctuation marks, including a period, and then matches either a white-space character or the end of the string.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#4<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any1.cs#4)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#4<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any1.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Because it matches any character, the <ph id="ph1">`.`</ph> language element is often used with a lazy quantifier if a regular expression pattern attempts to match any character multiple times.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Quantifiers<ept id="p1">](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Unicode Category or Unicode Block: \p{}</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The Unicode standard assigns each character a general category.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, a particular character can be an uppercase letter (represented by the <ph id="ph1">`Lu`</ph> category), a decimal digit (the <ph id="ph2">`Nd`</ph> category), a math symbol (the <ph id="ph3">`Sm`</ph> category), or a paragraph separator (the <ph id="ph4">`Zl`</ph> category).</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For example, the basic Latin character set is found from \u0000 through \u007F, while the Arabic character set is found from \u0600 through \u06FF.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The regular expression construct</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\p{`</ph> <bpt id="p1">*</bpt>name<ept id="p1">*</ept> <ph id="ph2">`}`</ph></source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>matches any character that belongs to a Unicode general category or named block, where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the category abbreviation or named block name.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For a list of category abbreviations, see the <bpt id="p1">[</bpt>Supported Unicode General Categories<ept id="p1">](#SupportedUnicodeGeneralCategories)</ept> section later in this topic.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For a list of named blocks, see the <bpt id="p1">[</bpt>Supported Named Blocks<ept id="p1">](#SupportedNamedBlocks)</ept> section later in this topic.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`\p{`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`}`</ph> construct to match both a Unicode general category (in this case, the <ph id="ph3">`Pd`</ph>, or Punctuation,Dash category) and a named block (the <ph id="ph4">`IsGreek`</ph> and <ph id="ph5">`IsBasicLatin`</ph> named blocks).</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#6<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/category1.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#6<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/category1.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b(\p{IsGreek}+(\s)?)+\p{Pd}\s(\p{IsBasicLatin}+(\s)?)+`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Match one or more Greek characters.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space character.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more Greek characters followed by zero or one white-space characters one or more times.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Match a Punctuation, Dash character.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Match one or more basic Latin characters.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space character.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more basic Latin characters followed by zero or one white-space characters one or more times.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Negative Unicode Category or Unicode Block: \P{}</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The Unicode standard assigns each character a general category.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For example, a particular character can be an uppercase letter (represented by the <ph id="ph1">`Lu`</ph> category), a decimal digit (the <ph id="ph2">`Nd`</ph> category), a math symbol (the <ph id="ph3">`Sm`</ph> category), or a paragraph separator (the <ph id="ph4">`Zl`</ph> category).</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, the basic Latin character set is found from \u0000 through \u007F, while the Arabic character set is found from \u0600 through \u06FF.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The regular expression construct</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\P{`</ph> <bpt id="p1">*</bpt>name<ept id="p1">*</ept> <ph id="ph2">`}`</ph></source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>matches any character that does not belong to a Unicode general category or named block, where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the category abbreviation or named block name.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>For a list of category abbreviations, see the <bpt id="p1">[</bpt>Supported Unicode General Categories<ept id="p1">](#SupportedUnicodeGeneralCategories)</ept> section later in this topic.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For a list of named blocks, see the <bpt id="p1">[</bpt>Supported Named Blocks<ept id="p1">](#SupportedNamedBlocks)</ept> section later in this topic.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`\P{`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`}`</ph> construct to remove any currency symbols (in this case, the <ph id="ph3">`Sc`</ph>, or Symbol, Currency category) from numeric strings.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#7<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/notcategory1.cs#7)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#7<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/notcategory1.vb#7)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(\P{Sc})+`</ph> matches one or more characters that are not currency symbols; it effectively strips any currency symbol from the result string.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Word Character: \w</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\w`</ph> matches any word character.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A word character is a member of any of the Unicode categories listed in the following table.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Ll</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Letter, Lowercase</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Lu</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Letter, Uppercase</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Lt</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Letter, Titlecase</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Lo</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Letter, Other</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Lm</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Letter, Modifier</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Mn</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Mark, Nonspacing</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Nd</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Number, Decimal Digit</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Pc</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Punctuation, Connector.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>This category includes ten characters, the most commonly used of which is the LOWLINE character (_), u+005F.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>If ECMAScript-compliant behavior is specified, <ph id="ph1">`\w`</ph> is equivalent to <ph id="ph2">`[a-zA-Z_0-9]`</ph>.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>For information on ECMAScript regular expressions, see the "ECMAScript Matching Behavior" section in <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Because it matches any word character, the <ph id="ph1">`\w`</ph> language element is often used with a lazy quantifier if a regular expression pattern attempts to match any word character multiple times, followed by a specific word character.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Quantifiers<ept id="p1">](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`\w`</ph> language element to match duplicate characters in a word.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The example defines a regular expression pattern, <ph id="ph1">`(\w)\1`</ph>, which can be interpreted as follows.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>(\w)</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Match a word character.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>\1</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Match the value of the first capture.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#8<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/wordchar1.cs#8)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#8<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/wordchar1.vb#8)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Non-Word Character: \W</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\W`</ph> matches any non-word character.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The \W language element is equivalent to the following character class:</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>In other words, it matches any character except for those in the Unicode categories listed in the following table.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Ll</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Letter, Lowercase</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Lu</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Letter, Uppercase</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Lt</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Letter, Titlecase</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Lo</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Letter, Other</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Lm</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Letter, Modifier</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Mn</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Mark, Nonspacing</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Nd</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Number, Decimal Digit</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Pc</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Punctuation, Connector.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>This category includes ten characters, the most commonly used of which is the LOWLINE character (_), u+005F.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>If ECMAScript-compliant behavior is specified, <ph id="ph1">`\W`</ph> is equivalent to <ph id="ph2">`[^a-zA-Z_0-9]`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>For information on ECMAScript regular expressions, see the "ECMAScript Matching Behavior" section in <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Because it matches any non-word character, the <ph id="ph1">`\W`</ph> language element is often used with a lazy quantifier if a regular expression pattern attempts to match any non-word character multiple times followed by a specific non-word character.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Quantifiers<ept id="p1">](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The following example illustrates the <ph id="ph1">`\W`</ph> character class.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>It defines a regular expression pattern, <ph id="ph1">`\b(\w+)(\W){1,2}`</ph>, that matches a word followed by one or two non-word characters, such as white space or punctuation.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>\b</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>(\w+)</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>(\W){1,2}</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Match a non-word character either one or two times.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#9<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/nonwordchar1.cs#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#9<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/nonwordchar1.vb#9)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object for the second capturing group contains only a single captured non-word character, the example retrieves all captured non-word characters from the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection&gt;</ph> object that is returned by the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>White-Space Character: \s</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\s`</ph> matches any white-space character.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>It is equivalent to the escape sequences and Unicode categories listed in the following table.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The form feed character, \u000C.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The newline character, \u000A.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The carriage return character, \u000D.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The tab character, \u0009.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The vertical tab character, \u000B.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The ellipsis or NEXT LINE (NEL) character (), \u0085.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Matches any separator character.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>If ECMAScript-compliant behavior is specified, <ph id="ph1">`\s`</ph> is equivalent to <ph id="ph2">`[ \f\n\r\t\v]`</ph>.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For information on ECMAScript regular expressions, see the "ECMAScript Matching Behavior" section in <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The following example illustrates the <ph id="ph1">`\s`</ph> character class.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>It defines a regular expression pattern, <ph id="ph1">`\b\w+(e)?s(\s|$)`</ph>, that matches a word ending in either "s" or "es" followed by either a white-space character or the end of the input string.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>\b</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>\w+</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>(e)?</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Match an "e" either zero or one time.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>s</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Match an "s".</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>(\s&amp;#124;$)</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Match either a whitespace character or the end of the input string.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#10<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/whitespace1.cs#10)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#10<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/whitespace1.vb#10)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Non-White-Space Character: \S</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\S`</ph> matches any non-white-space character.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>It is equivalent to the <ph id="ph1">`[^\f\n\r\t\v\x85\p{Z}]`</ph> regular expression pattern, or the opposite of the regular expression pattern that is equivalent to <ph id="ph2">`\s`</ph>, which matches white-space characters.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>White-Space Character: \s<ept id="p1">](#WhitespaceCharacter)</ept>.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>If ECMAScript-compliant behavior is specified, <ph id="ph1">`\S`</ph> is equivalent to  <ph id="ph2">`[^ \f\n\r\t\v]`</ph>.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>For information on ECMAScript regular expressions, see the "ECMAScript Matching Behavior" section in <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>The following example illustrates the <ph id="ph1">`\S`</ph> language element.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\S+)\s?`</ph> matches strings that are delimited by white-space characters.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The second element in the match's <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object contains the matched string.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>The regular expression can be interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Match one or more non-white-space characters.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space character.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#11<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/nonwhitespace1.cs#11)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#11<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/nonwhitespace1.vb#11)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Decimal Digit Character: \d</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\d`</ph> matches any decimal digit.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>It is equivalent to the <ph id="ph1">`\p{Nd}`</ph> regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>If ECMAScript-compliant behavior is specified, <ph id="ph1">`\d`</ph> is equivalent to  <ph id="ph2">`[0-9]`</ph>.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>For information on ECMAScript regular expressions, see the "ECMAScript Matching Behavior" section in <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The following example illustrates the <ph id="ph1">`\d`</ph> language element.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>It tests whether an input string represents a valid telephone number in the United States and Canada.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(\(?\d{3}\)?[\s-])?\d{3}-\d{4}$`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Match zero or one literal "(" character.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Match three decimal digits.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Match zero or one literal ")" character.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Match a hyphen or a white-space character.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>Match an optional opening parenthesis followed by three decimal digits, an optional closing parenthesis, and either a white-space character or a hyphen zero or one time.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Match three decimal digits followed by a hyphen and four more decimal digits.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#12<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/digit1.cs#12)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#12<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/digit1.vb#12)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Non-Digit Character: \D</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\D`</ph> matches any non-digit character.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>It is equivalent to the <ph id="ph1">`\P{Nd}`</ph> regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>If ECMAScript-compliant behavior is specified, <ph id="ph1">`\D`</ph> is equivalent to  <ph id="ph2">`[^0-9]`</ph>.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>For information on ECMAScript regular expressions, see the "ECMAScript Matching Behavior" section in <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The following example illustrates the \D language element.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>It tests whether a string such as a part number consists of the appropriate combination of decimal and non-decimal characters.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^\D\d{1,5}\D*$`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Match a non-digit character.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Match from one to five decimal digits.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Match zero, one, or more non-decimal characters.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#13<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/nondigit1.cs#13)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#13<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/nondigit1.vb#13)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Supported Unicode General Categories</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Unicode defines the general categories listed in the following table.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>For more information, see the "UCD File Format" and "General Category Values" subtopics at the <bpt id="p1">[</bpt>Unicode Character Database<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=57650)</ept>.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Letter, Uppercase</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Letter, Lowercase</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Letter, Titlecase</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Letter, Modifier</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Letter, Other</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>All letter characters.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>This includes the <ph id="ph1">`Lu`</ph>, <ph id="ph2">`Ll`</ph>, <ph id="ph3">`Lt`</ph>, <ph id="ph4">`Lm`</ph>, and <ph id="ph5">`Lo`</ph> characters.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Mark, Nonspacing</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Mark, Spacing Combining</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Mark, Enclosing</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>All diacritic marks.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>This includes the <ph id="ph1">`Mn`</ph>, <ph id="ph2">`Mc`</ph>, and <ph id="ph3">`Me`</ph> categories.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Number, Decimal Digit</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Number, Letter</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Number, Other</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>All numbers.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>This includes the <ph id="ph1">`Nd`</ph>, <ph id="ph2">`Nl`</ph>, and <ph id="ph3">`No`</ph> categories.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Punctuation, Connector</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Punctuation, Dash</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Punctuation, Open</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Punctuation, Close</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Punctuation, Initial quote (may behave like Ps or Pe depending on usage)</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Punctuation, Final quote (may behave like Ps or Pe depending on usage)</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Punctuation, Other</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>All punctuation characters.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>This includes the <ph id="ph1">`Pc`</ph>, <ph id="ph2">`Pd`</ph>, <ph id="ph3">`Ps`</ph>, <ph id="ph4">`Pe`</ph>, <ph id="ph5">`Pi`</ph>, <ph id="ph6">`Pf`</ph>, and <ph id="ph7">`Po`</ph> categories.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Symbol, Math</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>Symbol, Currency</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Symbol, Modifier</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Symbol, Other</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>All symbols.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>This includes the <ph id="ph1">`Sm`</ph>, <ph id="ph2">`Sc`</ph>, <ph id="ph3">`Sk`</ph>, and <ph id="ph4">`So`</ph> categories.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Separator, Space</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Separator, Line</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>Separator, Paragraph</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>All separator characters.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>This includes the <ph id="ph1">`Zs`</ph>, <ph id="ph2">`Zl`</ph>, and <ph id="ph3">`Zp`</ph> categories.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Other, Control</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Other, Format</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>Other, Surrogate</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Other, Private Use</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Other, Not Assigned (no characters have this property)</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>All control characters.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>This includes the <ph id="ph1">`Cc`</ph>, <ph id="ph2">`Cf`</ph>, <ph id="ph3">`Cs`</ph>, <ph id="ph4">`Co`</ph>, and <ph id="ph5">`Cn`</ph> categories.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>You can determine the Unicode category of any particular character by passing that character to the <ph id="ph1">&lt;xref:System.Char.GetUnicodeCategory%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Char.GetUnicodeCategory%2A&gt;</ph> method to determine the category of each element in an array that contains selected Latin characters.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#14<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/getunicodecategory1.cs#14)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#14<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/getunicodecategory1.vb#14)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Supported Named Blocks</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>.NET provides the named blocks listed in the following table.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>The set of supported named blocks is based on Unicode 4.0 and Perl 5.6.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Code point range</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Block name</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>0000 - 007F</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>0080 - 00FF</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>0100 - 017F</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>0180 - 024F</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>0250 - 02AF</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>02B0 - 02FF</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>0300 - 036F</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>0370 - 03FF</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>0400 - 04FF</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>0500 - 052F</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>0530 - 058F</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>0590 - 05FF</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>0600 - 06FF</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>0700 - 074F</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>0780 - 07BF</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>0900 - 097F</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>0980 - 09FF</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>0A00 - 0A7F</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>0A80 - 0AFF</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>0B00 - 0B7F</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>0B80 - 0BFF</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>0C00 - 0C7F</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>0C80 - 0CFF</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>0D00 - 0D7F</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>0D80 - 0DFF</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>0E00 - 0E7F</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>0E80 - 0EFF</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>0F00 - 0FFF</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>1000 - 109F</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>10A0 - 10FF</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>1100 - 11FF</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>1200 - 137F</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>13A0 - 13FF</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>1400 - 167F</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>1680 - 169F</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>16A0 - 16FF</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>1700 - 171F</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>1720 - 173F</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>1740 - 175F</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>1760 - 177F</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>1780 - 17FF</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>1800 - 18AF</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>1900 - 194F</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>1950 - 197F</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>19E0 - 19FF</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>1D00 - 1D7F</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>1E00 - 1EFF</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>1F00 - 1FFF</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>2000 - 206F</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>2070 - 209F</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>20A0 - 20CF</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>20D0 - 20FF</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>2100 - 214F</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>2150 - 218F</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>2190 - 21FF</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>2200 - 22FF</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>2300 - 23FF</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>2400 - 243F</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>2440 - 245F</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>2460 - 24FF</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>2500 - 257F</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>2580 - 259F</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>25A0 - 25FF</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>2600 - 26FF</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>2700 - 27BF</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>27C0 - 27EF</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>27F0 - 27FF</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>2800 - 28FF</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>2900 - 297F</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>2980 - 29FF</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>2A00 - 2AFF</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>2B00 - 2BFF</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>2E80 - 2EFF</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>2F00 - 2FDF</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>2FF0 - 2FFF</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>3000 - 303F</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>3040 - 309F</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>30A0 - 30FF</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>3100 - 312F</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>3130 - 318F</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>3190 - 319F</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>31A0 - 31BF</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>31F0 - 31FF</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>3200 - 32FF</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>3300 - 33FF</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>3400 - 4DBF</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>4DC0 - 4DFF</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>4E00 - 9FFF</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>A000 - A48F</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>A490 - A4CF</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>AC00 - D7AF</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>D800 - DB7F</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>DB80 - DBFF</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>DC00 - DFFF</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>E000 - F8FF</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IsPrivateUse`</ph> or <ph id="ph2">`IsPrivateUseArea`</ph></source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>F900 - FAFF</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>FB00 - FB4F</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>FB50 - FDFF</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>FE00 - FE0F</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>FE20 - FE2F</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>FE30 - FE4F</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>FE50 - FE6F</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>FE70 - FEFF</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>FF00 - FFEF</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>FFF0 - FFFF</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to Top<ept id="p1">](#Top)</ept></source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>Character Class Subtraction: [base_group - [excluded_group]]</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>A character class defines a set of characters.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>A character class subtraction expression has the following form:</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`[`</ph> <bpt id="p1">*</bpt>base_group<ept id="p1">*</ept> <ph id="ph2">`-[`</ph> <bpt id="p2">*</bpt>excluded_group<ept id="p2">*</ept> <ph id="ph3">`]]`</ph></source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The square brackets (<ph id="ph1">`[]`</ph>) and hyphen (<ph id="ph2">`-`</ph>) are mandatory.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>base_group<ept id="p1">*</ept> is a <bpt id="p2">[</bpt>positive character group<ept id="p2">](#PositiveGroup)</ept> or a <bpt id="p3">[</bpt>negative character group<ept id="p3">](#NegativeGroup)</ept>.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>excluded_group<ept id="p1">*</ept> component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a base group that consists of the character range from "a" through "z".</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>To define the set of characters that consists of the base group except for the character "m", use <ph id="ph1">`[a-z-[m]]`</ph>.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>To define the set of characters that consists of the base group except for the set of characters "d", "j", and "p", use <ph id="ph1">`[a-z-[djp]]`</ph>.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>To define the set of characters that consists of the base group except for the character range from "m" through "p", use <ph id="ph1">`[a-z-[m-p]]`</ph>.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>Consider the nested character class subtraction expression, <ph id="ph1">`[a-z-[d-w-[m-o]]]`</ph>.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>The expression is evaluated from the innermost character range outward.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>First, the character range from "m" through "o" is subtracted from the character range "d" through "w", which yields the set of characters from "d" through "l" and "p" through "w".</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>That set is then subtracted from the character range from "a" through "z", which yields the set of characters <ph id="ph1">`[abcmnoxyz]`</ph>.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>You can use any character class with character class subtraction.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>To define the set of characters that consists of all Unicode characters from \u0000 through \uFFFF except white-space characters (<ph id="ph1">`\s`</ph>), the characters in the punctuation general category (<ph id="ph2">`\p{P}`</ph>), the characters in the <ph id="ph3">`IsGreek`</ph> named block (<ph id="ph4">`\p{IsGreek}`</ph>), and the Unicode NEXT LINE control character (\x85), use <ph id="ph5">`[\u0000-\uFFFF-[\s\p{P}\p{IsGreek}\x85]]`</ph>.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>Choose character classes for a character class subtraction expression that will yield useful results.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Avoid an expression that yields an empty set of characters, which cannot match anything, or an expression that is equivalent to the original base group.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>For example, the empty set is the result of the expression <ph id="ph1">`[\p{IsBasicLatin}-[\x00-\x7F]]`</ph>, which subtracts all characters in the <ph id="ph2">`IsBasicLatin`</ph> character range from the <ph id="ph3">`IsBasicLatin`</ph> general category.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Similarly, the original base group is the result of the expression <ph id="ph1">`[a-z-[0-9]]`</ph>.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>This is because the base group, which is the character range of letters from "a" through "z", does not contain any characters in the excluded group, which is the character range of decimal digits from "0" through "9".</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression, <ph id="ph1">`^[0-9-[2468]]+$`</ph>, that matches zero and odd digits in an input string.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Begin the match at the start of the input string.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of any character from 0 to 9 except for 2, 4, 6, and 8.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>In other words, match one or more occurrences of zero or an odd digit.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegEx.Language.CharacterClasses#15<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/classsubtraction1.cs#15)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegEx.Language.CharacterClasses#15<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/classsubtraction1.vb#15)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Regular Expression Language - Quick Reference<ept id="p1">](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>