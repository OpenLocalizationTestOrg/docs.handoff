<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a7e35e02436f475ab71286244c8ea3a078d62206</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\advanced\inline-styles-and-templates.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2c2748ffd34dc04755367c7d11799461f680df7e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3b4a85061042826620af40d6f76f973f9ba6a39b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Inline Styles and Templates | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Inline Styles and Templates</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> provides <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> objects and template objects (<ph id="ph3">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> subclasses) as a way to define the visual appearance of an element in resources, so that they can be used multiple times.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For this reason, attributes in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> that take the types <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> almost always make resource references to existing styles and templates rather than define new ones inline.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Limitations of Inline Styles and Templates</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph>, style and template properties can technically be set in one of two ways.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can use attribute syntax to reference a style that was defined within a resource, for example <ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>object<ept id="p1">*</ept><ph id="ph2">`Style="{StaticResource`</ph><bpt id="p2">*</bpt>myResourceKey<ept id="p2">*</ept><ph id="ph3">`}" .../&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Or you can use property element syntax to define a style inline, for instance:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>object<ept id="p1">*</ept> <ph id="ph2">`&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>object<ept id="p1">*</ept> <ph id="ph2">`.Style&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`&lt;`</ph> <ph id="ph2">`Style`</ph>  <ph id="ph3">`.../&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`&lt;/`</ph> <bpt id="p1">*</bpt>object<ept id="p1">*</ept> <ph id="ph2">`.Style&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`&lt;/`</ph> <bpt id="p1">*</bpt>object<ept id="p1">*</ept> <ph id="ph2">`&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The attribute usage is much more common.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A style that is defined inline and not defined in resources is necessarily scoped to the containing element only, and cannot be re-used as easily because it has no resource key.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In general a resource-defined style is more versatile and useful, and is more in keeping with the general <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> programming model principle of separating program logic in code from design in markup.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Usually there is no reason to set a style or template inline, even if you only intend to use that style or template in that location.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Most elements that can take a style or template also support a content property and a content model.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If you are only using whatever logical tree you create through styling or templating once, it would be even easier to just fill that content property with the equivalent child elements in direct markup.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This would bypass the style and template mechanisms altogether.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Other syntaxes enabled by markup extensions that return an object are also possible for styles and templates.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Two such extensions that have possible scenarios include <bpt id="p1">[</bpt>TemplateBinding<ept id="p1">](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md)</ept> and <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](../../../../docs/framework/wpf/controls/styling-and-templating.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>