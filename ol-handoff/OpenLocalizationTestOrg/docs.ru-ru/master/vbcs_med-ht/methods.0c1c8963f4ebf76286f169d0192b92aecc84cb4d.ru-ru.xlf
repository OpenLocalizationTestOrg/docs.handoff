<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da1abda4faec540c115d93e14a757dae24c5ae78</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\classes-and-structs\methods.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2a442486f96f1ffeff7c4a692036490908b3515c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b9e88654efa5a1f03c25626b68c30195f000b6db</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Methods (C# Programming Guide) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Methods (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A method is a code block that contains a series of statements.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A program causes the statements to be executed by calling the method and specifying any required method arguments.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In C#, every executed instruction is performed in the context of a method.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The Main method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This topic discusses named methods.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For information about anonymous functions, see <bpt id="p1">[</bpt>Anonymous Functions<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Method Signatures</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Methods are declared in a <bpt id="p1">[</bpt>class<ept id="p1">](../../../csharp/language-reference/keywords/class.md)</ept> or <bpt id="p2">[</bpt>struct<ept id="p2">](../../../csharp/language-reference/keywords/struct.md)</ept> by specifying the access level such as <ph id="ph1">`public`</ph> or <ph id="ph2">`private`</ph>, optional modifiers such as <ph id="ph3">`abstract`</ph> or <ph id="ph4">`sealed`</ph>, the return value, the name of the method, and any method parameters.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>These parts together are the signature of the method.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A return type of a method is not part of the signature of the method for the purposes of method overloading.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Method parameters are enclosed in parentheses and are separated by commas.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Empty parentheses indicate that the method requires no parameters.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This class contains three methods:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#40<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_1.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Method Access</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Calling a method on an object is like accessing a field.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After the object name, add a period, the name of the method, and parentheses.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Arguments are listed within the parentheses, and are separated by commas.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The methods of the <ph id="ph1">`Motorcycle`</ph> class can therefore be called as in the following example:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#41<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_2.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Method Parameters vs. Arguments</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The method definition specifies the names and types of any parameters that are required.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>When calling code calls the method, it provides concrete values called arguments for each parameter.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The arguments must be compatible with the parameter type but the argument name (if any) used in the calling code does not have to be the same as the parameter named defined in the method.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#74<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_3.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Passing by Reference vs. Passing by Value</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>By default, when a value type is passed to a method, a copy is passed instead of the object itself.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Therefore, changes to the argument have no effect on the original copy in the calling method.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can pass a value-type by reference by using the ref keyword.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Passing Value-Type Parameters<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/passing-value-type-parameters.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For a list of built-in value types, see <bpt id="p1">[</bpt>Value Types Table<ept id="p1">](../../../csharp/language-reference/keywords/value-types-table.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When an object of a reference type is passed to a method, a reference to the object is passed.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>That is, the method receives not the object itself but an argument that indicates the location of the object.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If you change a member of the object by using this reference, the change is reflected in the argument in the calling method, even if you pass the object by value.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You create a reference type by using the <ph id="ph1">`class`</ph> keyword, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#42<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_4.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Now, if you pass an object that is based on this type to a method, a reference to the object is passed.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example passes an object of type <ph id="ph1">`SampleRefType`</ph> to method <ph id="ph2">`ModifyObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#75<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_5.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The example does essentially the same thing as the previous example in that it passes an argument by value to a method.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>But, because a reference type is used, the result is different.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The modification that is made in <ph id="ph1">`ModifyObject`</ph> to the <ph id="ph2">`value`</ph> field of the parameter, <ph id="ph3">`obj`</ph>, also changes the <ph id="ph4">`value`</ph> field of the argument, <ph id="ph5">`rt`</ph>, in the <ph id="ph6">`TestRefType`</ph> method.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`TestRefType`</ph> method displays 33 as the output.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information about how to pass reference types by reference and by value, see <bpt id="p1">[</bpt>Passing Reference-Type Parameters<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/passing-reference-type-parameters.md)</ept> and <bpt id="p2">[</bpt>Reference Types<ept id="p2">](../../../csharp/language-reference/keywords/reference-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Return Values</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Methods can return a value to the caller.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If the return type, the type listed before the method name, is not <ph id="ph1">`void`</ph>, the method can return the value by using the <ph id="ph2">`return`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A statement with the <ph id="ph1">`return`</ph> keyword followed by a value that matches the return type will return that value to the method caller.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`return`</ph> keyword also stops the execution of the method.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If the return type is <ph id="ph1">`void`</ph>, a <ph id="ph2">`return`</ph> statement without a value is still useful to stop the execution of the method.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Without the <ph id="ph1">`return`</ph> keyword, the method will stop executing when it reaches the end of the code block.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Methods with a non-void return type are required to use the <ph id="ph1">`return`</ph> keyword to return a value.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, these two methods use the <ph id="ph1">`return`</ph> keyword to return integers:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#44<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_6.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You can also assign the return value to a variable.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For example, the following two code examples accomplish the same goal:</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#45<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_7.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideObjects#46<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_8.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Using a local variable, in this case, <ph id="ph1">`result`</ph>, to store a value is optional.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Returning a multi-dimensional array from a method, M, that modifies the array's contents is not necessary if the calling function passed the array into M.  You may return the resulting array from M for good style or functional flow of values, but it is not necessary.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The reason you don't need to return the modified array is that C# passes all reference types by value, and the value of an array reference is the pointer to the array.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the method M, any changes to the array's contents are observable by any code that has a reference to the array, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>return<ept id="p1">](../../../csharp/language-reference/keywords/return.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Async Methods</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you mark a method with the <bpt id="p1">[</bpt>async<ept id="p1">](../../../csharp/language-reference/keywords/async.md)</ept> modifier, you can use the <bpt id="p2">[</bpt>await<ept id="p2">](../../../csharp/language-reference/keywords/await.md)</ept> operator in the method.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When control reaches an await expression in the async method, control returns to the caller, and progress in the method is suspended until the awaited task completes.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>When the task is complete, execution can resume in the method.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>An async method returns to the caller when either it encounters the first awaited object that’s not yet complete or it gets to the end of the async method, whichever occurs first.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An async method can have a return type of <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, or void.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The void return type is used primarily to define event handlers, where a void return type is required.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>An async method that returns void can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`DelayAsync`</ph> is an async method that has a return type of <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DelayAsync`</ph> has a <ph id="ph2">`return`</ph> statement that returns an integer.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Therefore the method declaration of <ph id="ph1">`DelayAsync`</ph> must have a return type of <ph id="ph2">`Task&lt;int&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Because the return type is <ph id="ph1">`Task&lt;int&gt;`</ph>, the evaluation of the <ph id="ph2">`await`</ph> expression in <ph id="ph3">`DoSomethingAsync`</ph> produces an integer as the following statement demonstrates: <ph id="ph4">`int result = await delayTask`</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`startButton_Click`</ph> method is an example of an async method that has a return type of void.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`DoSomethingAsync`</ph> is an async method, the task for the call to <ph id="ph2">`DoSomethingAsync`</ph> must be awaited, as the following statement shows: <ph id="ph3">`await DoSomethingAsync();`</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`startButton_Click`</ph> method must be defined with the <ph id="ph2">`async`</ph> modifier because the method has an <ph id="ph3">`await`</ph> expression.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csAsyncMethod#2<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/methods_9.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>An async method can't declare any <bpt id="p1">[</bpt>ref<ept id="p1">](../../../csharp/language-reference/keywords/ref.md)</ept> or <bpt id="p2">[</bpt>out<ept id="p2">](../../../csharp/language-reference/keywords/out.md)</ept> parameters, but it can call methods that have such parameters.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For more information about async methods, see <bpt id="p1">[</bpt>Asynchronous Programming with async and await<ept id="p1">](../../../csharp/programming-guide/concepts/async/index.md)</ept>, <bpt id="p2">[</bpt>Control Flow in Async Programs<ept id="p2">](../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)</ept>, and <bpt id="p3">[</bpt>Async Return Types<ept id="p3">](../../../csharp/programming-guide/concepts/async/async-return-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Expression Body Definitions</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>There is a syntax shortcut for defining such methods using <ph id="ph1">`=&gt;`</ph>:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>If the method returns <ph id="ph1">`void`</ph> or is an async method, then the body of the method must be a statement expression (same as with lambdas).</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For properties and indexers, they must be read only, and you don't use the <ph id="ph1">`get`</ph> accessor keyword.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Iterators</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>An iterator performs a custom iteration over a collection, such as a list or an array.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>An iterator uses the <bpt id="p1">[</bpt>yield return<ept id="p1">](../../../csharp/language-reference/keywords/yield.md)</ept> statement to return each element one at a time.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>When a <bpt id="p1">[</bpt>yield return<ept id="p1">](../../../csharp/language-reference/keywords/yield.md)</ept> statement is reached, the current location in code is remembered.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Execution is restarted from that location when the iterator is called the next time.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You call an iterator from client code by using a <bpt id="p1">[</bpt>foreach<ept id="p1">](../../../csharp/language-reference/keywords/foreach-in.md)</ept> statement.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The return type of an iterator can be <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator&gt;</ph>, or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Iterators<ept id="p1">](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)</ept>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>C# Language Specification</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Classes and Structs<ept id="p1">](index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Access Modifiers<ept id="p1">](access-modifiers.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Static Classes and Static Class Members<ept id="p1">](static-classes-and-static-class-members.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Inheritance<ept id="p1">](inheritance.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Abstract and Sealed Classes and Class Members<ept id="p1">](abstract-and-sealed-classes-and-class-members.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>params<ept id="p1">](../../../csharp/language-reference/keywords/params.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>return<ept id="p1">](../../../csharp/language-reference/keywords/return.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>out<ept id="p1">](../../../csharp/language-reference/keywords/out.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>ref<ept id="p1">](../../../csharp/language-reference/keywords/ref.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Passing Parameters<ept id="p1">](passing-parameters.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>