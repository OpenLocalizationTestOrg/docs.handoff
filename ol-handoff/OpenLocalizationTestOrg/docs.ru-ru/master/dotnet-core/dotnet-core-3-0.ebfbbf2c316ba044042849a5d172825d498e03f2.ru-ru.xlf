<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="dotnet-core-3-0.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3ce7bbc0dfccfda7a25dfecf32e93876ddde01f1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\whats-new\dotnet-core-3-0.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2807dd6f187d6554ac9404bca371a30d51a0553d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">540d1736ce9a8a8fa476b4436cac9f88e811106b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>What's new in .NET Core 3.0</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn about the new features found in .NET Core 3.0.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>What's new in .NET Core 3.0 (Preview 2)</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This article describes what is new in .NET Core 3.0 (preview 2).</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>One of the biggest enhancements is support for Windows desktop applications (Windows only).</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>By utilizing a .NET Core 3.0 SDK component called Windows Desktop, you can port your Windows Forms and Windows Presentation Foundation (WPF) applications.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>To be clear, the Windows Desktop component is only supported and included on Windows.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For more information, see the section <bpt id="p1">[</bpt>Windows desktop<ept id="p1">](#windows-desktop)</ept> below.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>.NET Core 3.0 adds support for C# 8.0.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Download and get started with .NET Core 3.0 Preview 2<ept id="p1">](https://aka.ms/netcore3download)</ept> right now on Windows, Mac and Linux.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can see complete details of the release in the <bpt id="p1">[</bpt>.NET Core 3.0 Preview 2 release notes<ept id="p1">](https://aka.ms/netcore3releasenotes)</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For more information about what was released with each version, see the following announcements:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET Core 3.0 Preview 1 announcement<ept id="p1">](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET Core 3.0 Preview 2 announcement<ept id="p1">](https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-2/)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>C# 8</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>.NET Core 3.0 supports C# 8, and as of .NET Core 3.0 Preview 2, supports these new features.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information about C# 8.0 features, see the following blog posts:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Do more with patterns in C# 8.0<ept id="p1">](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/)</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Take C# 8.0 for a spin<ept id="p1">](https://devblogs.microsoft.com/dotnet/take-c-8-0-for-a-spin/)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Building C# 8.0<ept id="p1">](https://devblogs.microsoft.com/dotnet/building-c-8-0/)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Ranges and indices</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">`Index`</ph> type can be used for indexing.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can create one from an <ph id="ph1">`int`</ph> that counts from the beginning, or with a prefix <ph id="ph2">`^`</ph> operator (C#) that counts from the end:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>There is also a <ph id="ph1">`Range`</ph> type, which consists of two <ph id="ph2">`Index`</ph> values, one for the start and one for the end, and can be written with a <ph id="ph3">`x..y`</ph> range expression (C#).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You can then index with a <ph id="ph1">`Range`</ph> in order to produce a slice:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Async streams</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IAsyncEnumerable&lt;T&gt;`</ph> type is a new asynchronous version of <ph id="ph2">`IEnumerable&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The language lets you <ph id="ph1">`await foreach`</ph> over <ph id="ph2">`IAsyncEnumerable&lt;T&gt;`</ph> to consume their elements, and use <ph id="ph3">`yield return`</ph> to them to produce elements.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following example demonstrates both production and consumption of async streams.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`foreach`</ph> statement is async and itself uses <ph id="ph2">`yield return`</ph> to produce an async stream for callers.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This pattern (using <ph id="ph1">`yield return`</ph>) is the recommended model for producing async streams.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In addition to being able to <ph id="ph1">`await foreach`</ph>, you can also create async iterators, for example, an iterator that returns an <ph id="ph2">`IAsyncEnumerable/IAsyncEnumerator`</ph> that you can both <ph id="ph3">`await`</ph> and <ph id="ph4">`yield`</ph> in.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For objects that need to be disposed, you can use <ph id="ph1">`IAsyncDisposable`</ph>, which various BCL types implement, such as <ph id="ph2">`Stream`</ph> and <ph id="ph3">`Timer`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You need .NET Core 3.0 Preview 2 to use async streams if you want to develop with either Visual Studio 2019 Preview 2 or the latest preview of the <bpt id="p1">[</bpt>C# extension for Visual Studio Code<ept id="p1">](https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta5)</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you are using .NET Core 3.0 Preview 2 at the command line, then everything will work as expected.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Using Declarations</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Using declarations<ept id="p1">*</ept> are a new way to ensure your object is properly disposed.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>using declaration<ept id="p1">*</ept> keeps the object alive while it is still in scope.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Once the object becomes out of scope, it is automatically disposed.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This will reduce nested <bpt id="p1">*</bpt>using statements<ept id="p1">*</ept> and make your code cleaner.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Switch Expressions</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Switch expressions<ept id="p1">*</ept> are a cleaner way of doing a <bpt id="p2">*</bpt>switch statement<ept id="p2">*</ept> but, since it's an expression, returns a value.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Switch expressions<ept id="p1">*</ept> are also fully integrated with pattern matching, and use the discard pattern, <ph id="ph1">`_`</ph>, to represent the <ph id="ph2">`default`</ph> value.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can see the syntax for <bpt id="p1">*</bpt>switch expressions<ept id="p1">*</ept> in the following example:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>There are two patterns at play in this example.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`o`</ph> first matches with the <ph id="ph2">`Point`</ph> <bpt id="p1">*</bpt>type pattern<ept id="p1">*</ept> and then with the <bpt id="p2">*</bpt>property pattern<ept id="p2">*</ept> inside the <bpt id="p3">*</bpt>{curly braces}<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`_`</ph> describes the <ph id="ph2">`discard pattern`</ph>, which is the same as <ph id="ph3">`default`</ph> for <bpt id="p1">*</bpt>switch statements<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Patterns enable you to write declarative code that captures your intent instead of procedural code that implements tests for it.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The compiler becomes responsible for implementing that boring procedural code and is guaranteed to always do it correctly.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>There will still be cases where <bpt id="p1">*</bpt>switch statements<ept id="p1">*</ept> will be a better choice than <bpt id="p2">*</bpt>switch expressions<ept id="p2">*</ept> and patterns can be used with both syntax styles.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Do more with patterns in C# 8.0<ept id="p1">](https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/)</ept>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>IEEE Floating-point improvements</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Floating point APIs are in the process of being updated to comply with <bpt id="p1">[</bpt>IEEE 754-2008 revision<ept id="p1">](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The goal of these changes is to expose all "required" operations and ensure that they are behaviorally compliant with the IEEE spec.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Parsing and formatting fixes:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Correctly parse and round inputs of any length.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Correctly parse and format negative zero.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Correctly parse Infinity and NaN by performing a case-insensitive check and allowing an optional preceding <ph id="ph1">`+`</ph> where applicable.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>New Math APIs have:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Corresponds to the <ph id="ph1">`nextUp`</ph> and <ph id="ph2">`nextDown`</ph> IEEE operations.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>They return the smallest floating-point number that compares greater or lesser than the input (respectively).</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`Math.BitIncrement(0.0)`</ph> would return <ph id="ph2">`double.Epsilon`</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Corresponds to the <ph id="ph1">`maxNumMag`</ph> and <ph id="ph2">`minNumMag`</ph> IEEE operations, they return the value that is greater or lesser in magnitude of the two inputs (respectively).</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`Math.MaxMagnitude(2.0, -3.0)`</ph> would return <ph id="ph2">`-3.0`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Corresponds to the <ph id="ph1">`logB`</ph> IEEE operation which returns an integral value, it returns the integral base-2 log of the input parameter.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is effectively the same as <ph id="ph1">`floor(log2(x))`</ph>, but done with minimal rounding error.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Corresponds to the <ph id="ph1">`scaleB`</ph> IEEE operation which takes an integral value, it returns effectively <ph id="ph2">`x * pow(2, n)`</ph>, but is done with minimal rounding error.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Corresponds to the <ph id="ph1">`log2`</ph> IEEE operation, it returns the base-2 logarithm.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It minimizes rounding error.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Corresponds to the <ph id="ph1">`fma`</ph> IEEE operation, it performs a fused multiply add.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>That is, it does <ph id="ph1">`(x * y) + z`</ph> as a single operation, there-by minimizing the rounding error.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>An example would be <ph id="ph1">`FusedMultiplyAdd(1e308, 2.0, -1e308)`</ph> which returns <ph id="ph2">`1e308`</ph>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The regular <ph id="ph1">`(1e308 * 2.0) - 1e308`</ph> returns <ph id="ph2">`double.PositiveInfinity`</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Corresponds to the <ph id="ph1">`copySign`</ph> IEEE operation, it returns the value of <ph id="ph2">`x`</ph>, but with the sign of <ph id="ph3">`y`</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>.NET Platform Dependent Intrinsics</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>APIs have been added that allow access to certain perf-oriented CPU instructions, such as the <bpt id="p1">**</bpt>SIMD<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Bit Manipulation instruction<ept id="p2">**</ept> sets.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>These instructions can help achieve big performance improvements in certain scenarios, such as processing data efficiently in parallel.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In addition to exposing the APIs for your programs to use, the .NET libraries have begun using these instructions to improve performance.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following CoreCLR PRs demonstrate a few of the intrinsics, either via implementation or use:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implement simple SSE2 hardware intrinsics<ept id="p1">](https://github.com/dotnet/coreclr/pull/15585)</ept></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implement the SSE hardware intrinsics<ept id="p1">](https://github.com/dotnet/coreclr/pull/15538)</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arm64 Base HW Intrinsics<ept id="p1">](https://github.com/dotnet/coreclr/pull/16822)</ept></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Use TZCNT and LZCNT for Locate{First|Last}Found{Byte|Char}<ept id="p1">](https://github.com/dotnet/coreclr/pull/21073)</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Platform Dependent Intrinsics<ept id="p1">](https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md)</ept>, which defines an approach for defining this hardware infrastructure, allowing Microsoft, chip vendors, or any other company or individual to define hardware/chip APIs that should be exposed to .NET code.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Default executables</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>.NET Core will now build <bpt id="p1">[</bpt>framework-dependent executables<ept id="p1">](../deploying/index.md#framework-dependent-executables-fde)</ept> by default.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is new for applications that use a globally installed version of .NET Core.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Until now, only <bpt id="p1">[</bpt>self-contained deployments<ept id="p1">](../deploying/index.md#self-contained-deployments-scd)</ept> would produce an executable.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>During <ph id="ph1">`dotnet build`</ph> or <ph id="ph2">`dotnet publish`</ph>, an executable is created provided that matches the environment and platform of the SDK you are using.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You can expect the same things with these executables as you would other native executables, such as:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can double-click on the executable.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>You can launch the application from a command prompt directly, such as <ph id="ph1">`myapp.exe`</ph> on Windows, and <ph id="ph2">`./myapp`</ph> on Linux and macOS.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Build copies dependencies</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet build`</ph> now copies NuGet dependencies for your application from the NuGet cache to the build output folder.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Previously, dependencies were only copied as part of <ph id="ph1">`dotnet publish`</ph>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>There are some operations, like linking and razor page publishing that will still require publishing.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Local dotnet tools</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>There was a change in .NET Core Local Tools between .NET Core 3.0 Preview 1 and .NET Core 3.0 Preview 2.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If you tried out local tools in Preview 1 by running a command like <ph id="ph1">`dotnet tool restore`</ph> or <ph id="ph2">`dotnet tool install`</ph>, you need to delete your local tools cache folder before local tools will work correctly in Preview 2.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This folder is located at:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>On mac, Linux: <ph id="ph1">`rm -r $HOME/.dotnet/toolResolverCache`</ph></source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>On Windows: <ph id="ph1">`rmdir /s %USERPROFILE%\.dotnet\toolResolverCache`</ph></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If you do not delete this folder, you will receive an error.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>While .NET Core 2.1 supported global tools, .NET Core 3.0 now has local tools.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Local tools are similar to global tools but are associated with a particular location on disk.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>This enables per-project and per-repository tooling.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Any tool installed locally isn't available globally.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Tools are distributed as NuGet packages.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Local tools rely on a manifest file name <ph id="ph1">`dotnet-tools.json`</ph> in your current directory.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This manifest file defines the tools to be available at that folder and below.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>By creating this manifest file at the root of your repository, you ensure anyone cloning your code can restore and use the tools that are needed to successfully work with your code.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>To create a <ph id="ph1">`dotnet-tools.json`</ph> manifest file, use:</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Add a new tool to the local manifest with:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You can also list the tools in the local manifest with:</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>To see what tools are installed globally, use:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>When the local tools manifest file is available, but the tools defined in the manifest have not been installed, use the following command to automatically download and install those tools:</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Run a local tool with the following command:</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>When a local tool is run, dotnet searches for a manifest up the current directory structure.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>When a tool manifest file is found, it is searched for the requested tool.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>If the tool is found in the manifest, but not the cache, the user receives an error and needs to run <ph id="ph1">`dotnet tool restore`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>To remove a tool from the local tool manifest file, run the following command:</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The tool manifest file is designed to allow hand editing – which you might do to update the required version for working with the repository.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Here is an example <ph id="ph1">`dotnet-tools.json`</ph> file:</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For both global and local tools, a compatible version of the runtime is required.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Many tools currently on NuGet.org target .NET Core Runtime 2.1.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>To install those globally or locally, you would still need to install the <bpt id="p1">[</bpt>NET Core 2.1 Runtime<ept id="p1">](https://dotnet.microsoft.com/download/dotnet-core/2.1)</ept>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Windows desktop</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Starting with .NET Core 3.0 Preview 1, you can build Windows desktop applications using WPF and Windows Forms.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>These frameworks also support using modern controls and Fluent styling from the Windows UI XAML Library (WinUI) via <bpt id="p1">[</bpt>XAML islands<ept id="p1">](/windows/uwp/xaml-platform/xaml-host-controls)</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The Windows Desktop component is part of the Windows .NET Core 3.0 SDK.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>You can create a new WPF or Windows Forms app with the following <ph id="ph1">`dotnet`</ph> commands:</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Visual Studio 2019 Preview 2 adds <bpt id="p1">**</bpt>New Project<ept id="p1">**</ept> templates for .NET Core 3.0 Windows Forms and WPF.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Designers are still not yet supported.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>And you can open, launch, and debug these projects in Visual Studio 2019.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 15.9 adds the ability to <bpt id="p1">[</bpt>enable .NET Core previews<ept id="p1">](https://devblogs.microsoft.com/dotnet/net-core-tooling-update-for-visual-studio-2017-version-15-9/)</ept>, but you need to turn that feature on, and it's not a supported scenario.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The new projects are the same as existing .NET Core projects, with a couple additions.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Here is the comparison of the basic .NET Core console project and a basic Windows Forms and WPF project.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>In a .NET Core console project, the project uses the <ph id="ph1">`Microsoft.NET.Sdk`</ph> SDK and declares a dependency on .NET Core 3.0 via the <ph id="ph2">`netcoreapp3.0`</ph> target framework.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>To create a Windows Desktop app, use the <ph id="ph1">`Microsoft.NET.Sdk.WindowsDesktop`</ph> SDK and choose which UI framework to use:</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>To choose Windows Forms over WPF, set <ph id="ph1">`UseWindowsForms`</ph> instead of <ph id="ph2">`UseWPF`</ph>:</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`UseWPF`</ph> and <ph id="ph2">`UseWindowsForms`</ph> can be set to <ph id="ph3">`true`</ph> if the app uses both frameworks, for example when a Windows Forms dialog is hosting a WPF control.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Please share your feedback on the <bpt id="p1">[</bpt>dotnet/winforms<ept id="p1">](https://github.com/dotnet/winforms/issues)</ept>,  <bpt id="p2">[</bpt>dotnet/wpf<ept id="p2">](https://github.com/dotnet/wpf/issues)</ept> and <bpt id="p3">[</bpt>dotnet/core<ept id="p3">](https://github.com/dotnet/core/issues)</ept> repos.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>MSIX Deployment for Windows Desktop</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>MSIX<ept id="p1">](https://docs.microsoft.com/windows/msix/)</ept> is a new Windows app package format.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>It can be used to deploy .NET Core 3.0 desktop applications to Windows 10.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Windows Application Packaging Project<ept id="p1">](https://docs.microsoft.com/windows/uwp/porting/desktop-to-uwp-packaging-dot-net)</ept>, available in Visual Studio 2019 Preview 2, allows you to create MSIX packages with <bpt id="p2">[</bpt>self-contained<ept id="p2">](../deploying/index.md#self-contained-deployments-scd)</ept> .NET Core applications.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Note: The .NET Core project file must specify the supported runtimes in the <ph id="ph1">`&lt;RuntimeIdentifiers&gt;`</ph> property:</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Fast built-in JSON support</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The .NET ecosystem has relied on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Json.NET<ept id="p2">**</ept><ept id="p1">](https://www.newtonsoft.com/json)</ept> and other popular JSON libraries, which continue to be good choices.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Json.NET<ept id="p1">**</ept> uses .NET strings as its base datatype, which are UTF-16 under the hood.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The new built-in JSON support is high-performance, low allocation, and based on <ph id="ph1">`Span&lt;byte&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Three new main JSON-related types have been added to .NET Core 3.0 the <ph id="ph1">`System.Text.Json`</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Utf8JsonReader</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.Text.Json.Utf8JsonReader`</ph> is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a <ph id="ph2">`ReadOnlySpan&lt;byte&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Utf8JsonReader`</ph> is a foundational, low-level type, that can be leveraged to build custom parsers and deserializers.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Reading through a JSON payload using the new <ph id="ph1">`Utf8JsonReader`</ph> is 2x faster than using the reader from <bpt id="p1">**</bpt>Json.NET<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>It does not allocate until you need to actualize JSON tokens as (UTF-16) strings.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>This new API will include the following components:</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>In Preview 1: JSON reader (sequential access)</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Coming next: JSON writer, DOM (random access), poco serializer, poco deserializer</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Here is the basic reader loop for the <ph id="ph1">`Utf8JsonReader`</ph> that can be used as a starting point:</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Utf8JsonWriter</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.Text.Json.Utf8JsonWriter`</ph> provides a high-performance, non-cached, forward-only way to write UTF-8 encoded JSON text from common .NET types like <ph id="ph2">`String`</ph>, <ph id="ph3">`Int32`</ph>, and <ph id="ph4">`DateTime`</ph>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Like the reader, the writer is a foundational, low-level type, that can be leveraged to build custom serializers.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Writing a JSON payload using the new <ph id="ph1">`Utf8JsonWriter`</ph> is 30-80% faster than using the writer from <bpt id="p1">**</bpt>Json.NET<ept id="p1">**</ept> and does not allocate.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Here is a sample usage of the <ph id="ph1">`Utf8JsonWriter`</ph> that can be used as a starting point:</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Utf8JsonWriter`</ph> accepts <ph id="ph2">`IBufferWriter&lt;byte&gt;`</ph> as the output location to synchronously write the json data into, and you as the caller need to provide a concrete implementation.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The platform does not currently include an implementation of this interface.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>For an example of <ph id="ph1">`IBufferWriter&lt;byte&gt;`</ph>, see <bpt id="p1">[</bpt><ph id="ph2">https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35</ph><ept id="p1">](https://gist.github.com/ahsonkhan/c76a1cc4dc7107537c3fdc0079a68b35)</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>JsonDocument</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.Text.Json.JsonDocument`</ph> is built on top of the <ph id="ph2">`Utf8JsonReader`</ph>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`JsonDocument`</ph> provides the ability to parse JSON data and build a read-only Document Object Model (DOM) that can be queried to support random access and enumeration.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The JSON elements that compose the data can be accessed via the <ph id="ph1">`JsonElement`</ph> type which is exposed by the <ph id="ph2">`JsonDocument`</ph> as a property called <ph id="ph3">`RootElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`JsonElement`</ph> contains the JSON array and object enumerators along with APIs to convert JSON text to common .NET types.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Parsing a typical JSON payload and accessing all its members using the <ph id="ph1">`JsonDocument`</ph> is 2-3x faster than <bpt id="p1">**</bpt>Json.NET<ept id="p1">**</ept> with very little allocations for data that is reasonably sized (i.e. &lt; 1 MB).</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Here is a sample usage of the <ph id="ph1">`JsonDocument`</ph> and <ph id="ph2">`JsonElement`</ph> that can be used as a starting point:</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Assembly Unloadability</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Assembly unloadability is a new capability of <ph id="ph1">`AssemblyLoadContext`</ph>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>This new feature is largely transparent from an API perspective, exposed with just a few new APIs.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>It enables a loader context to be unloaded, releasing all memory for instantiated types, static fields and for the assembly itself.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>An application should be able to load and unload assemblies via this mechanism forever without experiencing a memory leak.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This new capability can be used for scenarios similar to:</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Plugin scenarios where dynamic plugin loading and unloading is required.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Dynamically compiling, running and then flushing code.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Useful for web sites, scripting engines, etc.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Loading assemblies for introspection (like ReflectionOnlyLoad), although <bpt id="p1">[</bpt>MetadataLoadContext<ept id="p1">](#type-metadataloadcontext)</ept> (released in Preview 1) will be a better choice in many cases.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Using Unloadability<ept id="p1">](https://github.com/dotnet/coreclr/pull/22221)</ept> document.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Assembly unloading requires significant care to ensure that all references to managed objects from outside a loader context are understood and managed.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>When the loader context is requested to be unloaded, any outside references need to have been unreferenced so that the loader context is self-consistent only to itself.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Assembly unloadability was provided in the .NET Framework by Application Domains (AppDomains), which are not supported with .NET Core.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>AppDomains had both benefits and limitations compared to this new model.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Consider this new loader model to be more flexible and higher performant when compared to AppDomains.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Windows Native Interop</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Windows offers a rich native API, in the form of flat C APIs, COM, and WinRT.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Since .NET Core 1.0, <bpt id="p1">**</bpt>P/Invoke<ept id="p1">**</ept> has been supported.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Now with .NET Core 3.0, support for the ability to <bpt id="p1">**</bpt>CoCreate COM APIs<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Activate WinRT APIs<ept id="p2">**</ept> has been added.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>You can see an example of using COM with the <bpt id="p1">[</bpt>Excel Demo source code<ept id="p1">](https://github.com/dotnet/samples/tree/master/core/extensions/ExcelDemo)</ept>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Type: SequenceReader</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>In .NET Core 3.0, <ph id="ph1">`System.Buffers.SequenceReader`</ph> has been added which can be used as a reader for <ph id="ph2">`ReadOnlySequence&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>This allows easy, high performance, low allocation parsing of <ph id="ph1">`System.IO.Pipelines`</ph> data that can cross multiple backing buffers.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The following example breaks an input <ph id="ph1">`Sequence`</ph> into valid <ph id="ph2">`CR/LF`</ph> delimited lines:</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Type: MetadataLoadContext</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MetadataLoadContext`</ph> type has been added that enables reading assembly metadata without affecting the caller’s application domain.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Assemblies are read as data, including assemblies built for different architectures and platforms than the current runtime environment.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MetadataLoadContext`</ph> overlaps with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad*&gt;</ph>, which is only available in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MetdataLoadContext`</ph> is available in the <bpt id="p1">[</bpt>System.Reflection.MetadataLoadContext package<ept id="p1">](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext)</ept>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>It is a .NET Standard 2.0 package.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MetadataLoadContext`</ph> exposes APIs similar to the <ph id="ph2">&lt;xref:System.Runtime.Loader.AssemblyLoadContext&gt;</ph> type, but is not based on that type.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Much like <ph id="ph1">&lt;xref:System.Runtime.Loader.AssemblyLoadContext&gt;</ph>, the <ph id="ph2">`MetadataLoadContext`</ph> enables loading assemblies within an isolated assembly loading universe.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MetdataLoadContext`</ph> APIs return <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> objects, enabling the use of familiar reflection APIs.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Execution-oriented APIs, such as <bpt id="p1">[</bpt>MethodBase.Invoke<ept id="p1">](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/src/System/Reflection/TypeLoading/Methods/RoMethod.cs#L127)</ept>, are not allowed and will throw InvalidOperationException.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The following sample demonstrates how to find concrete types in an assembly that implements a given interface:</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Scenarios for <ph id="ph1">`MetadataLoadContext`</ph> include design-time features, build-time tooling, and runtime light-up features that need to inspect a set of assemblies as data and have all file locks and memory freed after inspection is performed.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MetadataLoadContext`</ph> has a resolver class passed to its constructor.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The resolver's job is to load an <ph id="ph1">`Assembly`</ph> given its <ph id="ph2">`AssemblyName`</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The resolver class derives from the abstract <ph id="ph1">`MetadataAssemblyResolver`</ph> class.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>An implementation of the resolver for path-based scenarios is provided with <ph id="ph1">`PathAssemblyResolver`</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>MetadataLoadContext tests<ept id="p1">](https://github.com/dotnet/corefx/tree/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests)</ept> demonstrate many use cases.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Assembly tests<ept id="p1">](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.MetadataLoadContext/tests/src/Tests/Assembly/AssemblyTests.cs)</ept> are a good place to start.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>TLS 1.3 &amp; OpenSSL 1.1.1 on Linux</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>.NET Core will now take advantage of <bpt id="p1">[</bpt>TLS 1.3 support in OpenSSL 1.1.1<ept id="p1">](https://www.openssl.org/blog/blog/2018/09/11/release111/)</ept>, when it is available in a given environment.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>There are multiple benefits of TLS 1.3, per the <bpt id="p1">[</bpt>OpenSSL team<ept id="p1">](https://www.openssl.org/blog/blog/2018/09/11/release111/)</ept>:</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Improved connection times due to a reduction in the number of round trips required between the client and server.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Improved security due to the removal of various obsolete and insecure cryptographic algorithms and encryption of more of the connection handshake.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>.NET Core 3.0 Preview 1 is capable of utilizing <bpt id="p1">**</bpt>OpenSSL 1.1.1<ept id="p1">**</ept>, <bpt id="p2">**</bpt>OpenSSL 1.1.0<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>OpenSSL 1.0.2<ept id="p3">**</ept> (whatever the best version found is, on a Linux system).</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">**</bpt>OpenSSL 1.1.1<ept id="p1">**</ept> is available the SslStream and HttpClient types will use <bpt id="p2">**</bpt>TLS 1.3<ept id="p2">**</ept> when using <ph id="ph1">`SslProtocols.None`</ph> (system default protocols), assuming both the client and server support <bpt id="p3">**</bpt>TLS 1.3<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The following sample demonstrates .NET Core 3.0 Preview 1 on Ubuntu 18.10 connecting to <ph id="ph1">&lt;https://www.cloudflare.com&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Windows and macOS do not yet support <bpt id="p1">**</bpt>TLS 1.3<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>.NET Core 3.0 will support <bpt id="p1">**</bpt>TLS 1.3<ept id="p1">**</ept> on these operating systems when support becomes available.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Cryptography</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Support has been added for <bpt id="p1">**</bpt>AES-GCM<ept id="p1">**</ept> and <bpt id="p2">**</bpt>AES-CCM<ept id="p2">**</ept> ciphers, implemented via <ph id="ph1">`System.Security.Cryptography.AesGcm`</ph> and <ph id="ph2">`System.Security.Cryptography.AesCcm`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>These algorithms are both <bpt id="p1">[</bpt>Authenticated Encryption with Association Data (AEAD) algorithms<ept id="p1">](https://en.wikipedia.org/wiki/Authenticated_encryption)</ept>, and the first Authenticated Encryption (AE) algorithms added to .NET Core.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The following code demonstrates using <bpt id="p1">**</bpt>AesGcm<ept id="p1">**</ept> cipher to encrypt and decrypt random data.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The code for <bpt id="p1">**</bpt>AesCcm<ept id="p1">**</ept> would look almost identical (only the class variable names would be different).</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Cryptographic Key Import/Export</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>.NET Core 3.0 Preview 1 supports the import and export of asymmetric public and private keys from standard formats, without needing to use an X.509 certificate.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>All key types (RSA, DSA, ECDsa, ECDiffieHellman) support the <bpt id="p1">**</bpt>X.509 SubjectPublicKeyInfo<ept id="p1">**</ept> format for public keys, and the <bpt id="p2">**</bpt>PKCS#8 PrivateKeyInfo<ept id="p2">**</ept> and <bpt id="p3">**</bpt>PKCS#8 EncryptedPrivateKeyInfo<ept id="p3">**</ept> formats for private keys.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>RSA additionally supports <bpt id="p1">**</bpt>PKCS#1 RSAPublicKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>PKCS#1 RSAPrivateKey<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The export methods all produce DER-encoded binary data, and the import methods expect the same.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>If a key is stored in the text-friendly PEM format, the caller will need to base64-decode the content before calling an import method.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>PKCS#8 files can be inspected with the <ph id="ph1">`System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo`</ph> class.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>PFX/PKCS#12 files can be inspected and manipulated with <ph id="ph1">`System.Security.Cryptography.Pkcs.Pkcs12Info`</ph> and <ph id="ph2">`System.Security.Cryptography.Pkcs.Pkcs12Builder`</ph>, respectively.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>SerialPort for Linux</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>.NET Core 3.0 now supports <ph id="ph1">&lt;xref:System.IO.Ports.SerialPort?displayProperty=nameWithType&gt;</ph> on Linux.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Previously, .NET Core only supported using the <ph id="ph1">`SerialPort`</ph> type on Windows.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>More BCL Improvements</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Span&lt;T&gt;`</ph>, <ph id="ph2">`Memory&lt;T&gt;`</ph>, and related types that were introduced in .NET Core 2.1, have been optimized in .NET Core 3.0.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Common operations such as span construction, slicing, parsing, and formatting now perform better.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Additionally, types like <ph id="ph1">`String`</ph> have seen under-the-cover improvements to make them more efficient when used as keys with <ph id="ph2">`Dictionary&lt;TKey, TValue&gt;`</ph> and other collections.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>No code changes are required to benefit from these improvements.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The following improvements are also new in .NET Core 3 Preview 1:</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Brotli support built in to HttpClient</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>ThreadPool.UnsafeQueueWorkItem(IThreadPoolWorkItem)</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Unsafe.Unbox</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>CancellationToken.Unregister</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Complex arithmetic operators</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Socket APIs for TCP keep alive</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>StringBuilder.GetChunks</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>IPEndPoint parsing</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>RandomNumberGenerator.GetInt32</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Tiered compilation</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tiered compilation<ept id="p1">](https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/)</ept> is on by default with .NET Core 3.0.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>It is a feature that enables the runtime to more adaptively use the Just-In-Time (JIT) compiler to get better performance, both at startup and to maximize throughput.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>This feature was added as an opt-in feature in <bpt id="p1">[</bpt>.NET Core 2.1<ept id="p1">](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-1/)</ept> and then was enabled by default in <bpt id="p2">[</bpt>.NET Core 2.2 Preview 2<ept id="p2">](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-2-preview-2/)</ept>.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Subsequently, it has been reverted back to opt in with the .NET Core 2.2 release.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>ARM64 Linux support</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Support has been added for ARM64 for Linux.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The primary use case for ARM64 is currently with IoT scenarios.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Alpine, Debian and Ubuntu <bpt id="p1">[</bpt>Docker images are available for .NET Core for ARM64<ept id="p1">](https://hub.docker.com/r/microsoft/dotnet/)</ept>.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Please check <bpt id="p1">[</bpt>.NET Core ARM64 Status<ept id="p1">](https://github.com/dotnet/announcements/issues/82)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ARM64<ept id="p1">**</ept> Windows support isn't yet available.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Install .NET Core 3.0 Previews on Linux with Snap</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Snap is the preferred way to install and try .NET Core previews on <bpt id="p1">[</bpt>Linux distributions that support Snap<ept id="p1">](https://docs.snapcraft.io/installing-snapd/6735)</ept>.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>After configuring Snap on your system, run the following command to install the <bpt id="p1">[</bpt>.NET Core SDK 3.0 Preview SDK<ept id="p1">](https://snapcraft.io/dotnet-sdk)</ept>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>When .NET Core in installed using the Snap package, the default .NET Core command is <ph id="ph1">`dotnet-sdk.dotnet`</ph>, as opposed to just <ph id="ph2">`dotnet`</ph>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The benefit of the namespaced command is that it will not conflict with a globally installed .NET Core version you may have.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>This command can be aliased to <ph id="ph1">`dotnet`</ph> with:</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Some distros require an additional step to enable access to the SSL certificate.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>See our <bpt id="p1">[</bpt>Linux Setup<ept id="p1">](https://github.com/dotnet/core/blob/master/Documentation/linux-setup.md)</ept> for details.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>GPIO Support for Raspberry Pi</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Two new packages have been released to NuGet that you can use for GPIO programming.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Device.Gpio<ept id="p1">](https://www.nuget.org/packages/System.Device.Gpio/0.1.0-prerelease.19078.2)</ept></source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Iot.Device.Bindings<ept id="p1">](https://www.nuget.org/packages/Iot.Device.Bindings/0.1.0-prerelease.19078.2)</ept></source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The GPIO Packages includes APIs for GPIO, SPI, I2C and PWM devices.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>The IoT bindings package includes <bpt id="p1">[</bpt>device bindings<ept id="p1">](https://github.com/dotnet/iot/blob/master/src/devices/README.md)</ept> for various chips and sensors, the same ones available at <bpt id="p2">[</bpt>dotnet/iot - src/devices<ept id="p2">](https://github.com/dotnet/iot/tree/master/src/devices)</ept>.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>The updated serial port APIs that were announced as part of .NET Core 3.0 Preview 1 are not part of these packages but are available as part of the .NET Core platform.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Platform Support</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>.NET Core 3 will be supported on the following operating systems:</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Windows Client: 7, 8.1, 10 (1607+)</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Windows Server: 2012 R2 SP1+</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>macOS: 10.12+</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>RHEL: 6+</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Fedora: 26+</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Ubuntu: 16.04+</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Debian: 9+</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>SLES: 12+</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>openSUSE: 42.3+</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Alpine: 3.8+</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Chip support follows:</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>x64 on Windows, macOS, and Linux</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>x86 on Windows</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>ARM32 on Windows and Linux</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>ARM64 on Linux</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>For Linux, ARM32 is supported on Debian 9+ and Ubuntu 16.04+.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>For ARM64, it is the same as ARM32 with the addition of Alpine 3.8.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>These are the same versions of those distros as is supported for X64.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Docker images for .NET Core 3.0 are available at <bpt id="p1">[</bpt>microsoft/dotnet on Docker Hub<ept id="p1">](https://hub.docker.com/r/microsoft/dotnet/)</ept>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Microsoft is currently in the process of adopting <bpt id="p1">[</bpt>Microsoft Container Registry (MCR)<ept id="p1">](https://cloudblogs.microsoft.com/opensource/2019/01/17/improved-discovery-experience-microsoft-containers-docker-hub/)</ept> and it is expected that the final .NET Core 3.0 images will only be published to MCR.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>