<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="linq-to-xml-vs-other-xml-technologies.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-7148b53" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">57584d0f20e08201f6af9a481227ced950bff0f3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\linq-to-xml-vs-other-xml-technologies.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">79868dafb052332376eccba08d097353a56e409f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fd94f001445d4bc67fd8909866da8061741d63e9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>LINQ to XML vs. Other XML Technologies2 | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>LINQ to XML vs. Other XML Technologies</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic compares <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> to the following XML technologies: <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>, XSLT, MSXML, and XmlLite.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This information can help you decide which technology to use.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For a comparison of <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> to the Document Object Model (DOM), see <bpt id="p1">[</bpt>LINQ to XML vs. DOM (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/linq-to-xml-vs-dom.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>LINQ to XML vs. XmlReader</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> is a fast, forward-only, non-caching parser.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>is implemented on top of <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>, and they are tightly integrated.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, you can also use <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by itself.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, suppose you are building a Web service that will parse hundreds of XML documents per second, and the documents have the same structure, meaning that you only have to write one implementation of the code to parse the XML.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In this case, you would probably want to use <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by itself.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In contrast, if you are building a system that parses many smaller XML documents, and each one is different, you would want to take advantage of the productivity improvements that <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> provides.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>LINQ to XML vs. XSLT</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> and XSLT provide extensive XML document transformation capabilities.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>XSLT is a rule-based, declarative approach.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Advanced XSLT programmers write XSLT in a functional programming style that emphasizes a stateless approach.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Transformations can be written using pure functions that are implemented without side effects.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This rule-based or functional approach is unfamiliar to many developers, and can be difficult and time-consuming to learn.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>XSLT can be a very productive system that yields high-performance applications.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For example, some big Web companies use XSLT as a way to generate HTML from XML that has been pulled from a variety of data stores.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The managed XSLT engine compiles XSLT to CLR code, and performs even better in some scenarios than the native XSLT engine.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>However, XSLT does not take advantage of the C# and Visual Basic knowledge that many developers have.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It requires developers to write code in a different and complex programming language.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Using two non-integrated development systems such as C# (or Visual Basic) and XSLT results in software systems that are more difficult to develop and maintain.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>After you have mastered <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query expressions, <ph id="ph2">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> transformations are a powerful technology that is easy to use.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Basically, you form your XML document by using functional construction, pulling in data from various sources, constructing <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> objects dynamically, and assembling the whole into a new XML tree.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The transformation can generate a completely new document.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Constructing transformations in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> is relatively easy and intuitive, and the resulting code is readable.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This reduces development and maintenance costs.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>is not intended to replace XSLT.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>XSLT is still the tool of choice for complicated and document-centric XML transformations, especially if the structure of the document is not well defined.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>XSLT has the advantage of being a World Wide Web Consortium (W3C) standard.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If you have a requirement that you use only technologies that are standards, XSLT might be more appropriate.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>XSLT is XML, and therefore can be programmatically manipulated.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>LINQ to XML vs. MSXML</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>MSXML is the COM-based technology for processing XML that is included with Microsoft Windows.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>MSXML provides a native implementation of the DOM with support for XPath and XSLT.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It also contains the SAX2 non-caching, event-based parser.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>MSXML performs well, is secure by default in most scenarios, and can be accessed in Internet Explorer for performing client-side XML processing in AJAX-style applications.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>MSXML can be used from any programming language that supports COM, including C++, JavaScript, and <ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> 6.0.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>MSXML is not recommended for use in managed code based on the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>LINQ to XML vs. XmlLite</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>XmlLite is a non-caching, forward only, pull parser.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Developers primarily use XmlLite with C++.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>It is not recommended for developers to use XmlLite with managed code.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The main advantage of XmlLite is that it is a lightweight, fast XML parser that is secure in most scenarios.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Its threat surface area is very small.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If you have to parse untrusted documents and you want to protect against attacks such as denial of service or exposure of data, XmlLite might be a good option.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>XmlLite is not integrated with <ph id="ph1">[!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It does not yield the programmer productivity improvements that are the motivating force behind <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started (LINQ to XML)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-linq-to-xml.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>