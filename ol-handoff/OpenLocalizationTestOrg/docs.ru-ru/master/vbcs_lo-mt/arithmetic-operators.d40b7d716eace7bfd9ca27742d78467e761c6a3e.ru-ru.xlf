<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e80e7950abe035efe5294974937589a1af40f17c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\operators-and-expressions\arithmetic-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c36e32153dc290d0d2e38eeb00bcfe49aab8526a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3bc56e0c6a83bffe8d61a43910e2c19fd23dc5a2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators in Visual Basic | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators in Visual Basic</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are used to perform many of the familiar arithmetic operations that involve the calculation of numeric values represented by literals, variables, other expressions, function and property calls, and constants.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Also classified with arithmetic operators are the bit-shift operators, which act at the level of the individual bits of the operands and shift their bit patterns to the left or right.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Arithmetic Operations</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can add two values in an expression together with the <bpt id="p1">[</bpt>+ Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/addition-operator.md)</ept>, or subtract one from another with the <bpt id="p2">[</bpt>- Operator (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, as the following example demonstrates.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#57<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_1.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Negation also uses the <bpt id="p1">[</bpt>- Operator (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, but with only one operand, as the following example demonstrates.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#58<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_2.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Multiplication and division use the <bpt id="p1">[</bpt>* Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/multiplication-operator.md)</ept> and <bpt id="p2">[</bpt>/ Operator (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md)</ept>, respectively, as the following example demonstrates.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#59<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_3.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Exponentiation uses the <bpt id="p1">[</bpt>^ Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/exponentiation-operator.md)</ept>, as the following example demonstrates.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#60<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_4.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Integer division is carried out using the <bpt id="p1">[</bpt>\ Operator (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/integer-division-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Integer division returns the quotient, that is, the integer that represents the number of times the divisor can divide into the dividend without consideration of any remainder.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Both the divisor and the dividend must be integral types (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, and <ph id="ph8">`ULong`</ph>) for this operator.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All other types must be converted to an integral type first.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following example demonstrates integer division.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#61<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_5.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Modulus arithmetic is performed using the <bpt id="p1">[</bpt>Mod Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This operator returns the remainder after dividing the divisor into the dividend an integral number of times.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If both divisor and dividend are integral types, the returned value is integral.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If divisor and dividend are floating-point types, the returned value is also floating-point.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this behavior.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#62<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_6.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#63<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_7.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Attempted Division by Zero</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Division by zero has different results depending on the data types involved.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In integral divisions (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, <ph id="ph8">`ULong`</ph>), the <ph id="ph9">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> throws a <ph id="ph10">&lt;xref:System.DivideByZeroException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In division operations on the <ph id="ph1">`Decimal`</ph> or <ph id="ph2">`Single`</ph> data type, the <ph id="ph3">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> also throws a <ph id="ph4">&lt;xref:System.DivideByZeroException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In floating-point divisions involving the <ph id="ph1">`Double`</ph> data type, no exception is thrown, and the result is the class member representing <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph>, <ph id="ph3">&lt;xref:System.Double.PositiveInfinity&gt;</ph>, or <ph id="ph4">&lt;xref:System.Double.NegativeInfinity&gt;</ph>, depending on the dividend.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following table summarizes the various results of attempting to divide a <ph id="ph1">`Double`</ph> value by zero.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Dividend data type</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Divisor data type</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Dividend value</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Result</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> (not a mathematically defined number)</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>&gt; 0</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph> 0</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When you catch a <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> exception, you can use its members to help you handle it.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property holds the message text for the exception.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Try...Catch...Finally Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Bit-Shift Operations</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A bit-shift operation performs an arithmetic shift on a bit pattern.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The pattern is contained in the operand on the left, while the operand on the right specifies the number of positions to shift the pattern.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can shift the pattern to the right with the <bpt id="p1">[</bpt>&gt;&gt; Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/right-shift-operator.md)</ept> or to the left with the <bpt id="p2">[</bpt>&lt;&lt; Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/left-shift-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The data type of the pattern operand must be <ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, or <ph id="ph8">`ULong`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The data type of the shift amount operand must be <ph id="ph1">`Integer`</ph> or must widen to <ph id="ph2">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The bit positions vacated by a shift are set as follows:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic left shift</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic right shift of a positive number</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic right shift of an unsigned data type (<ph id="ph1">`Byte`</ph>, <ph id="ph2">`UShort`</ph>, <ph id="ph3">`UInteger`</ph>, <ph id="ph4">`ULong`</ph>)</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>1 for an arithmetic right shift of a negative number (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Short`</ph>, <ph id="ph3">`Integer`</ph>, or <ph id="ph4">`Long`</ph>)</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example shifts an <ph id="ph1">`Integer`</ph> value both left and right.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#64<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_8.vb)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Arithmetic shifts never generate overflow exceptions.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Bitwise Operations</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In addition to being logical operators, <ph id="ph1">`Not`</ph>, <ph id="ph2">`Or`</ph>, <ph id="ph3">`And`</ph>, and <ph id="ph4">`Xor`</ph> also perform bitwise arithmetic when used on numeric values.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For more information, see "Bitwise Operations" in <bpt id="p1">[</bpt>Logical and Bitwise Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Type Safety</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Operands should normally be of the same type.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, if you are doing addition with an <ph id="ph1">`Integer`</ph> variable, you should add it to another <ph id="ph2">`Integer`</ph> variable, and you should assign the result to a variable of type <ph id="ph3">`Integer`</ph> as well.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>One way to ensure good type-safe coding practice is to use the <bpt id="p1">[</bpt>Option Strict Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you set <ph id="ph1">`Option Strict On`</ph>, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> automatically performs <bpt id="p1">*</bpt>type-safe<ept id="p1">*</ept> conversions.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, if you try to add an <ph id="ph1">`Integer`</ph> variable to a <ph id="ph2">`Double`</ph> variable and assign the value to a <ph id="ph3">`Double`</ph> variable, the operation proceeds normally, because an <ph id="ph4">`Integer`</ph> value can be converted to <ph id="ph5">`Double`</ph> without loss of data.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Type-unsafe conversions, on the other hand, cause a compiler error with <ph id="ph1">`Option Strict On`</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, if you try to add an <ph id="ph1">`Integer`</ph> variable to a <ph id="ph2">`Double`</ph> variable and assign the value to an <ph id="ph3">`Integer`</ph> variable, a compiler error results, because a <ph id="ph4">`Double`</ph> variable cannot be implicitly converted to type <ph id="ph5">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you set <ph id="ph1">`Option Strict Off`</ph>, however, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> allows implicit narrowing conversions to take place, although they can result in the unexpected loss of data or precision.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For this reason, we recommend that you use <ph id="ph1">`Option Strict On`</ph> when writing production code.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arithmetic Operators<ept id="p1">](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Bit Shift Operators<ept id="p1">](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Comparison Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Concatenation Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Logical and Bitwise Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Efficient Combination of Operators<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>