<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">76f32fc4c8e26470c77e1415d96ed9035a4d9165</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\data-types\implicit-and-explicit-conversions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1f2e6bb2c07d96b6019d3a7ff43e4fc45cbb61aa</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5f91711147e1a660361dc27dd600e7b59e88f532</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Implicit and Explicit Conversions (Visual Basic) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Implicit and Explicit Conversions (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>implicit conversion<ept id="p1">*</ept> does not require any special syntax in the source code.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> implicitly converts the value of <ph id="ph2">`k`</ph> to a single-precision floating-point value before assigning it to <ph id="ph3">`q`</ph>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>explicit conversion<ept id="p1">*</ept> uses a type conversion keyword.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> provides several such keywords, which coerce an expression in parentheses to the desired data type.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These keywords act like functions, but the compiler generates the code inline, so execution is slightly faster than with a function call.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In the following extension of the preceding example, the <ph id="ph1">`CInt`</ph> keyword converts the value of <ph id="ph2">`q`</ph> back to an integer before assigning it to <ph id="ph3">`k`</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Conversion Keywords</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following table shows the available conversion keywords.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Type conversion keyword</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Converts an expression to data type</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Allowable data types of expression to be converted</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/boolean-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`String`</ph>, <ph id="ph4">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Byte Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/byte-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`SByte`</ph> and enumerated types), <ph id="ph2">`Boolean`</ph>, <ph id="ph3">`String`</ph>, <ph id="ph4">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Char Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/char-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`String`</ph>, <ph id="ph2">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Date Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/date-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`String`</ph>, <ph id="ph2">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Double Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/double-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Decimal Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Integer Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/integer-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Long Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/long-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Object Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/object-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Any type</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SByte Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph> and enumerated types), <ph id="ph2">`Boolean`</ph>, <ph id="ph3">`String`</ph>, <ph id="ph4">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Short Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/short-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Single Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/single-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/string-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`Char`</ph>, <ph id="ph5">`Char`</ph> array, <ph id="ph6">`Date`</ph>, <ph id="ph7">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Type specified following the comma (<ph id="ph1">`,`</ph>)</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When converting to an <bpt id="p1">*</bpt>elementary data type<ept id="p1">*</ept> (including an array of an elementary type), the same types as allowed for the corresponding conversion keyword</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>When converting to a <bpt id="p1">*</bpt>composite data type<ept id="p1">*</ept>, the interfaces it implements and the classes from which it inherits</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When converting to a class or structure on which you have overloaded <ph id="ph1">`CType`</ph>, that class or structure</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInteger Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ULong Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/ulong-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UShort Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/ushort-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Any numeric type (including <ph id="ph1">`Byte`</ph>, <ph id="ph2">`SByte`</ph>, and enumerated types), <ph id="ph3">`Boolean`</ph>, <ph id="ph4">`String`</ph>, <ph id="ph5">`Object`</ph></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The CType Function</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CType Function<ept id="p1">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept> operates on two arguments.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The first is the expression to be converted, and the second is the destination data type or object class.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Note that the first argument must be an expression, not a type.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CType`</ph> is an <bpt id="p1">*</bpt>inline function<ept id="p1">*</ept>, meaning the compiled code makes the conversion, often without generating a function call.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This improves performance.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For a comparison of <ph id="ph1">`CType`</ph> with the other type conversion keywords, see <bpt id="p1">[</bpt>DirectCast Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/directcast-operator.md)</ept> and <bpt id="p2">[</bpt>TryCast Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/trycast-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Elementary Types</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of <ph id="ph1">`CType`</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`CType`</ph> to convert values to composite data types as well as to elementary types.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can also use it to coerce an object class to the type of one of its interfaces, as in the following example.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Array Types</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CType`</ph> can also convert array data types, as in the following example.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Array Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/array-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Types Defining CType</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You can define <ph id="ph1">`CType`</ph> on a class or structure you have defined.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This allows you to convert values to and from the type of your class or structure.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to: Define a Conversion Operator<ept id="p1">](../../../../visual-basic/programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Values used with a conversion keyword must be valid for the destination data type, or an error occurs.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, if you attempt to convert a <ph id="ph1">`Long`</ph> to an <ph id="ph2">`Integer`</ph>, the value of the <ph id="ph3">`Long`</ph> must be within the valid range for the <ph id="ph4">`Integer`</ph> data type.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Specifying <ph id="ph1">`CType`</ph> to convert from one class type to another fails at run time if the source type does not derive from the destination type.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Such a failure throws an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>However, if one of the types is a structure or class you have defined, and if you have defined <ph id="ph1">`CType`</ph> on that structure or class, a conversion can succeed if it satisfies the requirements of your <ph id="ph2">`CType`</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>How to: Define a Conversion Operator<ept id="p1">](../../../../visual-basic/programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Performing an explicit conversion is also known as <bpt id="p1">*</bpt>casting<ept id="p1">*</ept> an expression to a given data type or object class.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type Conversions in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Conversions Between Strings and Other Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/conversions-between-strings-and-other-types.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Convert an Object to Another Type in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-convert-an-object-to-another-type.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Structures<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/structures.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data Types<ept id="p1">](../../../../visual-basic/language-reference/data-types/data-type-summary.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type Conversion Functions<ept id="p1">](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Troubleshooting Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>