<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">50172b8e94634d959d3cddf58bda3906d682edf0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\data\adonet\ef\architecture-and-design.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5a0097b3cca6ad7dff540a804c86f84d59e52200</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2f37b728305461169ab6d4d6a3c237d7e3e912cc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Architecture and Design | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Architecture and Design</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The SQL generation module in the <bpt id="p1">[</bpt>Sample Provider<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=180616)</ept> is implemented as a visitor on the expression tree that represents the command tree.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The generation is done in a single pass over the expression tree.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The nodes of the tree are processed from the bottom up.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>First, an intermediate structure is produced: SqlSelectStatement or SqlBuilder, both implementing ISqlFragment.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Next, the string SQL statement is produced from that structure.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>There are two reasons for the intermediate structure:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Logically, a SQL SELECT statement is populated out of order.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The nodes that participate in the FROM clause are visited before the nodes that participate in the WHERE, GROUP BY, and the ORDER BY clause.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>To rename aliases, you must identify all used aliases to avoid collisions during renaming.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>To defer the renaming choices in SqlBuilder, use Symbol objects to represent the columns that are candidates for renaming.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram<ept id="p1">]</ept><bpt id="p2">(../../../../../docs/framework/data/adonet/ef/media/de1ca705-4f7c-4d2d-ace5-afefc6d3cefa.gif "</bpt>de1ca705-4f7c-4d2d-ace5-afefc6d3cefa<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In the first phase, while visiting the expression tree, expressions are grouped into SqlSelectStatements, joins are flattened, and join aliases are flattened.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>During this pass, Symbol objects represent columns or input aliases that may be renamed.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the second phase, while producing the actual string, aliases are renamed.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Data Structures</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This section discusses the types used in the <bpt id="p1">[</bpt>Sample Provider<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=180616)</ept> that you use to build a SQL statement.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>ISqlFragment</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This section covers the classes that implement the ISqlFragment interface, which serves two purposes:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A common return type for all the visitor methods.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Gives a method to write the final SQL string.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>SqlBuilder</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>SqlBuilder is a gathering device for the final SQL string, similar to StringBuilder.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It consists of the strings that make up the final SQL, along with ISqlFragments that can be converted into strings.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>SqlSelectStatement</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>SqlSelectStatement represents a canonical SQL SELECT statement of the shape "SELECT …</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>FROM  ..</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>WHERE …</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>GROUP BY …</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>ORDER BY".</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Each of the SQL clauses is represented by a StringBuilder.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In addition, it tracks whether Distinct has been specified and whether the statement is topmost.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If the statement is not topmost, the ORDER BY clause is omitted unless the statement also has a TOP clause.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>FromExtents contains the list of inputs for the SELECT statement.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>There is usually just one element in this.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>SELECT statements for joins may temporarily have more than one element.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is created by a Join node, SqlSelectStatement maintains a list of all the extents that have been flattened in the join in AllJoinExtents.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>OuterExtents represents outer references of the SqlSelectStatement and is used for input alias renaming.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>TopClause</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>TopClause represents the TOP expression in a SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The TopCount property indicates how many TOP rows should be selected.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When WithTies is true, the TopClause was built from a DbLimitExpession.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Symbols</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The Symbol-related classes and the symbol table perform input alias renaming, join alias flattening, and column alias renaming.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The Symbol class represents an extent, a nested SELECT statement, or a column.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>It is used instead of an actual alias to allow for renaming after it has been used and it also carries additional information for the artifact it represents (like the type).</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Name stores the original alias for the represented extent, nested SELECT statement, or a column.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>NewName stores the alias that will be used in the SQL SELECT statement.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It is originally set to Name, and only renamed if needed when generating the final string query.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Type is only useful for symbols representing extents and nested SELECT statements.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>SymbolPair</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The SymbolPair class addresses record flattening.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Consider a property expression D(v, "j3.j2.j1.a.x") where v is a VarRef, j1, j2, j3 are joins, a is an extent, and x is a columns.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This has to be translated eventually into {j'}.{x'}.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The source field represents the outermost SqlStatement, representing a join expression (say j2); this is always a Join symbol.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The column field moves from one join symbol to the next until it stops at a non-join symbol.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This is returned when visiting a DbPropertyExpression but is never added to a SqlBuilder.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>JoinSymbol</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>A Join symbol is a Symbol that represents a nested SELECT statement with a join or a join input.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>ColumnList represents the list of columns in the SELECT clause if this symbol represents a SQL SELECT statement.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>ExtentList is the list of extents in the SELECT clause.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If the join has multiple extents flattened at the top level, FlattenedExtentList tracks the extents to ensure that extent aliases are renamed correctly.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>NameToExtent has all the extents in ExtentList as a dictionary.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>IsNestedJoin is used to determine whether a JoinSymbol is an ordinary join symbol or one that has a corresponding SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>All the lists are set exactly once and then used for lookups or enumeration.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>SymbolTable</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>SymbolTable is used to resolve variable names to Symbols.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>SymbolTable is implemented as a stack with a new entry for each scope.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Lookups search from the top of the stack to the bottom until an entry is found.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>There is only one SymbolTable per one instance of the Sql Generation module.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Scopes are entered and exited for each relational node.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>All symbols in earlier scopes are visible to later scopes unless hidden by other symbols with the same name.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Global State for the Visitor</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>To assist in renaming of aliases and columns, maintain a list of all the column names (AllColumnNames) and extent aliases (AllExtentNames) that have been used in the first pass over the query tree.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The symbol table resolves variable names to Symbols.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>IsVarRefSingle is only used for verification purposes, it is not strictly necessary.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The two stacks used via CurrentSelectStatement and IsParentAJoin are used to pass "parameters" from parent to child nodes, since the visitor pattern does not allow us to pass parameters.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Common Scenarios</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This section discusses common provider scenarios.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Grouping Expression Nodes into SQL Statements</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A SqlSelectStatement is created when the first relational node is encountered (typically a DbScanExpression extent) when visiting the tree from the bottom up.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>To produce a SQL SELECT statement with as few nested queries as possible, aggregate as many of its parent nodes as possible in that SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The decision of whether a given (relational) node can be added to the current SqlSelectStatement (the one returned when visiting the input) or if a new statement needs to be started is computed by the method IsCompatible and depends on what is already in the SqlSelectStatement, which depends on what nodes were below the given node.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Typically, if SQL statement clauses are evaluated after clauses where the nodes being considered for merging are not empty, the node cannot be added to the current statement.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For example, if the next node is a Filter, that node can be incorporated into the current SqlSelectStatement only if the following is true:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The SELECT list is empty.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If the SELECT list is not empty, the select list was produced by a node preceding the filter and the predicate may refer to columns produced by that SELECT list.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The GROUPBY is empty.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the GROUPBY is not empty, adding the filter would mean filtering before grouping, which is not correct.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The TOP clause is empty.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>If the TOP clause is not empty, adding the filter would mean filtering before doing TOP, which is not correct.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This does not apply to non-relational nodes like DbConstantExpression or arithmetic expressions, because these are always included as part of an existing SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Also, when encountering the root of join tree (a join node that does not have a join parent), a new SqlSelectStatement is started.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>All of its left spine join children are aggregated into that SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Whenever a new SqlSelectStatement is started, and the current one is added to the input, the current SqlSelectStatement may need to be completed by adding projection columns (a SELECT clause) if one does not exist.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is done with the method AddDefaultColumns, which looks at the FromExtents of the SqlSelectStatement and adds all the columns that the list of extents represented by FromExtents brings in scope to the list of projected columns.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This is done, because at that point, it is unknown which columns are referenced by the other nodes.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This can be optimized to only project the columns that can later be used.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Join Flattening</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The IsParentAJoin property helps determine whether a given join can be flattened.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In particular, IsParentAJoin returns <ph id="ph1">`true`</ph> only for the left child of a join and for each DbScanExpression that is an immediate input to a join, in which case that child node reuses the same SqlSelectStatement that the parent would later use.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For more information, see "Join Expressions".</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Input Alias Redirecting</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Input alias redirecting is accomplished with the symbol table.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>To explain input alias redirecting, refer to the first example in <bpt id="p1">[</bpt>Generating SQL from Command Trees - Best Practices<ept id="p1">](../../../../../docs/framework/data/adonet/ef/generating-sql-from-command-trees-best-practices.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>There "a" needed to be redirected to "b" in the projection.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>When a SqlSelectStatement object is created, the extent that is the input to the node is put in the From property of the SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>A Symbol (&lt;symbol_b&gt;) is created based on the input binding name ("b") to represent that extent and "AS  " +  &lt;symbol_b&gt; is appended to the From Clause.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The symbol is also added to the FromExtents property.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The symbol is also added to the symbol table to link the input binding name to it ("b", &lt;symbol_b&gt;).</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If a subsequent node reuses that SqlSelectStatement, it adds an entry to the symbol table to link its input binding name to that symbol.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In our example, the DbProjectExpression with the input binding name of "a" would reuse the SqlSelectStatement and add ("a", <ph id="ph1">\&lt;</ph> symbol_b&gt;) to the table.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>When expressions reference the input binding name of the node that is reusing the SqlSelectStatement, that reference is resolved using the symbol table to the correct redirected symbol.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>When "a" from "a.x" is resolved while visiting the DbVariableReferenceExpression representing "a" it will resolve to the Symbol &lt;symbol_b&gt;.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Join Alias Flattening</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Join alias flattening is achieved when visiting a DbPropertyExpression as described in the section titled DbPropertyExpression.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Column Name and Extent Alias Renaming</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The issue of column name and extent alias renaming is addressed by using symbols that only get substituted with aliases in the second phase of the generation described in the section titled Second Phase of SQL Generation: Generating the String Command.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>First Phase of the SQL Generation: Visiting the Expression Tree</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This section describes the first phase of SQL generation, when the expression representing the query is visited and an intermediate structure is produced, either a SqlSelectStatement or a SqlBuilder.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This section describes the principles of visiting different expression node categories, and details of visiting specific expression types.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Relational (Non-Join) Nodes</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The following expression types support non-join nodes:</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>DbDistinctExpression</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>DbFilterExpression</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>DbGroupByExpression</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>DbLimitExpession</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>DbProjectExpression</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>DbSkipExpression</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>DbSortExpression</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Visiting these nodes follows the following pattern:</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Visit the relational input and get the resulting SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The input to a relational node could be one of the following:</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>A relational node, including an extent (a DbScanExpression, for example).</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Visiting such a node returns a SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>A set operation expression (UNION ALL, for example).</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The result has to be wrapped in brackets and put in the FROM clause of a new SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Check whether the current node can be added to the SqlSelectStatement produced by the input.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The section titled Grouping Expressions into SQL Statements describes this.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If not,</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Pop the current SqlSelectStatement object.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Create a new SqlSelectStatement object and add the popped SqlSelectStatement as the FROM of the new SqlSelectStatement object.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Put the new object on top of the stack.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Redirect the input expression binding to the correct symbol from the input.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>This information is maintained in the SqlSelectStatement object.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Add a new SymbolTable scope.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Visit the non-input part of the expression (for example, Projection and Predicate).</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Pop all the objects added to the global stacks.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>DbSkipExpression not have a direct equivalent in SQL.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Logically, it is translated into:</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Join Expressions</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The following are considered join expressions and they are processed in a common way, by the VisitJoinExpression method:</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>DbApplyExpression</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>DbJoinExpression</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>DbCrossJoinExpression</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following are the visit steps:</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>First, before visiting the children, IsParentAJoin is invoked to check whether the join node is a child of a join along a left spine.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If it returns false, a new SqlSelectStatement is started.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In that sense, joins are visited differently from the rest of the nodes, as the parent (the join node) creates the SqlSelectStatement for the children to possibly use.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Second, process the inputs one at a time.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>For each input:</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Visit the input.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Post process the result of visiting the input by invoking ProcessJoinInputResult, which is responsible for maintaining the symbol table after visiting a child of a join expression and possibly finishing the SqlSelectStatement produced by the child.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The child's result could be one of the following:</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>A SqlSelectStatement different from the one to which the parent will be added.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>In such case, it may need to be completed by adding default columns.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>If the input was a Join, you need to create a new join symbol.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Otherwise, create a normal symbol.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>An extent (a DbScanExpression, for example), in which case it is simply added to the list of inputs of the parent’s SqlSelectStatement.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Not a SqlSelectStatement, in which case it is wrapped with brackets.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The same SqlSelectStatement to which the parent is added.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>In such case, the symbols in the FromExtents list need to be replaced with a single new JoinSymbol representing them all.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For the first three cases, AddFromSymbol is called to add the AS clause, and update the symbol table.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Third, the join condition (if any) is visited.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Set Operations</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The set operations DbUnionAllExpression, DbExceptExpression, and DbIntersectExpression are processed by the method VisitSetOpExpression.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>It creates a SqlBuilder of the shape</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Where <ph id="ph1">\&lt;</ph>leftSqlSelectStatement&gt; and <ph id="ph2">\&lt;</ph>rightSqlSelectStatement&gt; are SqlSelectStatements obtained by visiting each of the inputs, and <ph id="ph3">\&lt;</ph>setOp&gt; is the corresponding operation (UNION ALL for example).</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>DbScanExpression</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>If visited in a join context (as an input to a join that is a left child of another join), DbScanExpression returns a SqlBuilder with the target SQL for the corresponding target, which is either a defining query, table, or a view.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Otherwise, a new SqlSelectStatement is created with the FROM field set to correspond to the corresponding target.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>DbVariableReferenceExpression</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The visit of a DbVariableReferenceExpression returns the Symbol corresponding to that variable reference expression based on a look up in the symbol table.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>DbPropertyExpression</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Join alias flattening is identified and processed when visiting a DbPropertyExpression.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The Instance property is first visited and the result is a Symbol, a JoinSymbol, or a SymbolPair.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Here is how these three cases are handled:</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>If a JoinSymbol is returned, than its NameToExtent property contains a symbol for the needed property.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If the join symbol represents a nested join, a new Symbol pair is returned with the join symbol to track the symbol that would be used as the instance alias, and the symbol representing the actual property for further resolving.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>If a SymbolPair is returned and the Column part is a join symbol, a join symbol is again returned, but now the column property is updated to point to the property represented by the current property expression.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Otherwise a SqlBuilder is returned with the SymbolPair source as the alias, and the symbol for the current property as the column.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>If a Symbol is returned, the Visit method returns a SqlBuilder method with that instance as the alias, and the property name as column name.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>DbNewInstanceExpression</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>When used as the Projection property of DbProjectExpression, DbNewInstanceExpression produces a comma-separated list of the arguments to represent the projected columns.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>When DbNewInstanceExpression has a collection return type, and defines a new collection of the expressions provided as arguments, the following three cases are handled separately:</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>If DbNewInstanceExpression has DbElementExpression as the only argument, it is translated as follows:</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>If DbNewInstanceExpression has no arguments (represents an empty table), DbNewInstanceExpression is translated into:</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Otherwise DbNewInstanceExpression builds a union-all ladder of the arguments:</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>DbFunctionExpression</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Canonical and built-in functions are processed the same way: if they need special handling (TRIM(string) to  LTRIM(RTRIM(string), for example), the appropriate handler is invoked.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Otherwise they are translated to FunctionName(arg1, arg2, ..., argn).</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Dictionaries are used to keep track of which functions need special handling and their appropriate handlers.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>User-defined functions are tanslated to NamespaceName.FunctionName(arg1, arg2, ..., argn).</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>DbElementExpression</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The method that visits DbElementExpression is only invoked for visiting a DbElementExpression when used to represent a scalar subquery.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Therefore, DbElementExpression translates into a complete SqlSelectStatement and adds brackets around it.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>DbQuantifierExpression</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Depending on the expression type (Any or All), DbQuantifierExpression is translated it as:</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>DbNotExpression</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>In some cases it is possible to collapse the translation of DbNotExpression with its input expression.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The reason the second collapse is performed is because inefficiencies were introduced by the provider when translating DbQuantifierExpression of type All.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Thus the Entity Framework could not have done the simplification.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>DbIsEmptyExpression</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>DbIsEmptyExpression is translated as:</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Second Phase of SQL Generation: Generating the String Command</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>When generating a string SQL command, the SqlSelectStatement produces actual aliases for the symbols, which addresses the issue of column name and extent alias renaming.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Extent alias renaming occurs while writing the SqlSelectStatement object into a string.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>First create a list of all the aliases used by the outer extents.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Each symbol in the FromExtents (or AllJoinExtents if it is non-null), gets renamed if it collides with any of the outer extents.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>If renaming is needed, it will not conflict with any of the extents collected in AllExtentNames.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Column renaming occurs while writing a Symbol object to a string.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>AddDefaultColumns in the first phase has determined if a certain column symbol has to be renamed.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>In the second phase only the rename occurs making sure that the name produced does not conflict with any name used in AllColumnNames</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>To produce unique names both for extent aliases and for columns, use &lt;existing_name&gt;_n where n is the smallest alias that has not been used yet.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The global list of all aliases increases the need for cascading renames.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SQL Generation in the Sample Provider<ept id="p1">](../../../../../docs/framework/data/adonet/ef/sql-generation-in-the-sample-provider.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>