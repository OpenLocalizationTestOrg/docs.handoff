<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cfcd1ee67a5e1de8de743d47f9172d65544a1c7c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\data\adonet\ef\language-reference\from-entity-sql.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">142d468417066e48ef8a774b149aeb04fa449ac8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">048884798d0c8710b638d55cb39c352f59fde1a0</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>FROM (Entity SQL) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>FROM (Entity SQL)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Specifies the collection used in <bpt id="p1">[</bpt>SELECT<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/select-entity-sql.md)</ept> statements.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Arguments</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Any valid query expression that yields a collection to use as a source in a <ph id="ph1">`SELECT`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`FROM`</ph> clause is a comma-separated list of one or more <ph id="ph2">`FROM`</ph> clause items.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FROM`</ph> clause can be used to specify one or more sources for a <ph id="ph2">`SELECT`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The simplest form of a <ph id="ph1">`FROM`</ph> clause is a single query expression that identifies a collection and an alias used as the source in a <ph id="ph2">`SELECT`</ph> statement, as illustrated in the following example:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>FROM Clause Items</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Each <ph id="ph1">`FROM`</ph> clause item refers to a source collection in the <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> query.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports the following classes of <ph id="ph2">`FROM`</ph> clause items: simple <ph id="ph3">`FROM`</ph> clause items, <ph id="ph4">`JOIN FROM`</ph> clause items, and <ph id="ph5">`APPLY FROM`</ph> clause items.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Each of these <ph id="ph1">`FROM`</ph> clause items is described in more detail in the following sections.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Simple FROM Clause Item</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The simplest <ph id="ph1">`FROM`</ph> clause item is a single expression that identifies a collection and an alias.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The expression can simply be an entity set, or a subquery, or any other expression that is a collection type.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following is an example:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The alias specification is optional.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>An alternate specification of the above from clause item could be the following:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If no alias is specified, <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> attempts to generate an alias based on the collection expression.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>JOIN FROM Clause Item</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`JOIN FROM`</ph> clause item represents a join between two <ph id="ph2">`FROM`</ph> clause items.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports cross joins, inner joins, left and right outer joins, and full outer joins.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>All these joins are supported similar to the way that they are supported in <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As in <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>, the two <ph id="ph2">`FROM`</ph> clause items involved in the <ph id="ph3">`JOIN`</ph> must be independent.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>That is, they cannot be correlated.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CROSS APPLY`</ph> or <ph id="ph2">`OUTER APPLY`</ph> can be used for these cases.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Cross Joins</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CROSS JOIN`</ph> query expression produces the Cartesian product of the two collections, as illustrated in the following example:</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Inner Joins</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`INNER JOIN`</ph> produces a constrained Cartesian product of the two collections, as illustrated in the following example:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the <ph id="ph1">`ON`</ph> condition is true.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If no <ph id="ph1">`ON`</ph> condition is specified, an <ph id="ph2">`INNER JOIN`</ph> degenerates to a <ph id="ph3">`CROSS JOIN`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Left Outer Joins and Right Outer Joins</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`OUTER JOIN`</ph> query expression produces a constrained Cartesian product of the two collections, as illustrated in the following example:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the <ph id="ph1">`ON`</ph> condition is true.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`ON`</ph> condition is false, the expression still processes a single instance of the element on the left paired against the element on the right, with the value null.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`RIGHT OUTER JOIN`</ph> may be expressed in a similar manner.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Full Outer Joins</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>An explicit <ph id="ph1">`FULL OUTER JOIN`</ph> produces a constrained Cartesian product of the two collections as illustrated in the following example:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the <ph id="ph1">`ON`</ph> condition is true.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`ON`</ph> condition is false, the expression still processes one instance of the element on the left paired against the element on the right, with the value null.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>It also processes one instance of the element on the right paired against the element on the left, with the value null.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To preserve compatibility with SQL-92, in <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> the OUTER keyword is optional.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`LEFT JOIN`</ph>, <ph id="ph2">`RIGHT JOIN`</ph>, and <ph id="ph3">`FULL JOIN`</ph> are synonyms for <ph id="ph4">`LEFT OUTER JOIN`</ph>, <ph id="ph5">`RIGHT OUTER JOIN`</ph>, and <ph id="ph6">`FULL OUTER JOIN`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>APPLY Clause Item</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports two kinds of <ph id="ph2">`APPLY`</ph>: <ph id="ph3">`CROSS APPLY`</ph> and <ph id="ph4">`OUTER APPLY`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CROSS APPLY`</ph> produces a unique pairing of each element of the collection on the left with an element of the collection produced by evaluating the expression on the right.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>With a <ph id="ph1">`CROSS APPLY`</ph>, the expression on the right is functionally dependent on the element on the left, as illustrated in the following associated collection example:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The behavior of <ph id="ph1">`CROSS APPLY`</ph> is similar to the join list.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If the expression on the right evaluates to an empty collection, the <ph id="ph1">`CROSS APPLY`</ph> produces no pairings for that instance of the element on the left.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`OUTER APPLY`</ph> resembles a <ph id="ph2">`CROSS APPLY`</ph>, except a pairing is still produced even when the expression on the right evaluates to an empty collection.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The following is an example of an <ph id="ph1">`OUTER APPLY`</ph>:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Unlike in <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>, there is no need for an explicit unnest step in <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CROSS`</ph> and <ph id="ph2">`OUTER APPLY`</ph> operators were introduced in <ph id="ph3">[!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In some cases, the query pipeline might produce Transact-SQL that contains <ph id="ph1">`CROSS APPLY`</ph> and/or <ph id="ph2">`OUTER APPLY`</ph> operators.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Because some backend providers, including versions of <ph id="ph1">[!INCLUDE[ssNoVersion](../../../../../../includes/ssnoversion-md.md)]</ph> earlier than <ph id="ph2">[!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]</ph>, do not support these operators, such queries cannot be executed on these backend providers.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Some typical scenarios that might lead to the presence of <ph id="ph1">`CROSS APPLY`</ph> and/or <ph id="ph2">`OUTER APPLY`</ph> operators in the output query are the following: a correlated subquery with paging; AnyElement over a correlated subquery or over a collection produced by navigation; LINQ queries that use grouping methods that accept an element selector; a query in which a <ph id="ph3">`CROSS APPLY`</ph> or an <ph id="ph4">`OUTER APPLY`</ph> are explicitly specified; a query that has a <ph id="ph5">`DEREF`</ph> construct over a <ph id="ph6">`REF`</ph> construct.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Multiple Collections in the FROM Clause</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FROM`</ph> clause can contain more than one collection separated by commas.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In these cases, the collections are assumed to be joined together.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Think of these as an n-way CROSS JOIN.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`C`</ph> and <ph id="ph2">`D`</ph> are independent collections, but <ph id="ph3">`c.Names`</ph> is dependent on <ph id="ph4">`C`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The previous example is logically equivalent to the following example:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Left Correlation</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Items in the <ph id="ph1">`FROM`</ph> clause can refer to items specified in earlier clauses.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`C`</ph> and <ph id="ph2">`D`</ph> are independent collections, but <ph id="ph3">`c.Names`</ph> is dependent on <ph id="ph4">`C`</ph>:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This is logically equivalent to:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Semantics</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Logically, the collections in the <ph id="ph1">`FROM`</ph> clause are assumed to be part of an <ph id="ph2">`n`</ph>-way cross join (except in the case of a 1-way cross join).</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Aliases in the <ph id="ph1">`FROM`</ph> clause are processed left to right, and are added to the current scope for later reference.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FROM`</ph> clause is assumed to produce a multiset of rows.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>There will be one field for each item in the <ph id="ph1">`FROM`</ph> clause that represents a single element from that collection item.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FROM`</ph> clause logically produces a multiset of rows of type Row(c, d, e) where fields c, d, and e are assumed to be of the element type of <ph id="ph2">`C`</ph>, <ph id="ph3">`D`</ph>, and <ph id="ph4">`c.Names`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> introduces an alias for each simple <ph id="ph2">`FROM`</ph> clause item in scope.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For example, in the following FROM clause snippet, The names introduced into scope are c, d, and e.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> (unlike <ph id="ph2">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>), the <ph id="ph3">`FROM`</ph> clause only introduces the aliases into scope.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Any references to columns (properties) of these collections must be qualified with the alias.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Pulling Up Keys from Nested Queries</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Certain types of queries that require pulling up keys from a nested query are not supported.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, the following query is valid:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>However, the following query is not valid, because the nested query does not have any keys:</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Entity SQL Reference<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-reference.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Query Expressions<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/query-expressions-entity-sql.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nullable Structured Types<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/nullable-structured-types-entity-sql.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>