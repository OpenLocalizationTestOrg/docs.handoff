<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c12770e166212ce2745fd318bf25f6fb6289ae70</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\stand-alone-json-serialization.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ab156545738722dd8dc28ae2af095803154f655e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bfd44906a420bf6fcff2019c56bc3f98b5ac78d3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Stand-Alone JSON Serialization | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Stand-Alone JSON Serialization</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It is the default data format used by ASP.NET AJAX services created in <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Finally, if you require JSON support but are not creating an AJAX service, the <ph id="ph1">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For a description of how to do this, see <bpt id="p1">[</bpt>How to: Serialize and Deserialize JSON Data<ept id="p1">](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For a list of the types supported, see <bpt id="p1">[</bpt>Types Supported by the Data Contract Serializer<ept id="p1">](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This includes most primitive types, most array and collection types, as well as complex types that use the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Mapping .NET types to JSON Types</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>.NET Types</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>JSON/JavaScript</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Notes</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>All numeric types, for example <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> or <ph id="ph3">&lt;xref:System.Double&gt;</ph></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Number</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Special values such as  <ph id="ph1">`Double.NaN`</ph>, <ph id="ph2">`Double.PositiveInfinity`</ph> and <ph id="ph3">`Double.NegativeInfinity`</ph> are not supported and result in invalid JSON.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Number</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>See "Enumerations and JSON" later in this topic.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Boolean</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String&gt;</ph>, <ph id="ph2">&lt;xref:System.Char&gt;</ph></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>, <ph id="ph2">&lt;xref:System.Guid&gt;</ph>, <ph id="ph3">&lt;xref:System.Uri&gt;</ph></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For precise information, see <bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The format is "name:namespace" (anything before the first colon is the name).</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Either the name or the namespace can be missing.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If there is no namespace the colon can be omitted as well.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Byte&gt;</ph></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Array of numbers</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Each number represents the value of one byte.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>DateTime or String</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>See Dates/Times and JSON later in this topic.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Complex type</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>See Dates/Times and JSON later in this topic.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>XML and ADO.NET types (<ph id="ph1">&lt;xref:System.Xml.XmlElement&gt;</ph>,</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Arrays of <ph id="ph1">&lt;xref:System.Xml.XmlNode&gt;</ph>,</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>,</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>See the XML Types and JSON section of this topic.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Empty complex type</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Collections, dictionaries, and arrays</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Array</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>See the Collections, Dictionaries, and Arrays section of this topic.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Complex types (with the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> or <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> applied)</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Complex type</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Data members become members of the JavaScript complex type.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Complex types implementing the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface)</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Complex type</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Same as other complex types but some <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Null`</ph> value for any type</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Null</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Nullable types are also supported and map to JSON in the same way as non-nullable types.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Enumerations and JSON</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> the data contract treatment, see <bpt id="p1">[</bpt>Enumeration Types in Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, if you have <ph id="ph1">`public enum Color {red, green, blue, yellow, pink}`</ph>, serializing <ph id="ph2">`yellow`</ph> produces the number 3 and not the string "yellow".</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>All <ph id="ph1">`enum`</ph> members are serializable.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.EnumMemberAttribute&gt;</ph> and the <ph id="ph2">&lt;xref:System.NonSerializedAttribute&gt;</ph> attributes are ignored if used.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It is possible to deserialize a nonexistent <ph id="ph1">`enum`</ph> value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A flags <ph id="ph1">`enum`</ph> is not special and is treated the same as any other <ph id="ph2">`enum`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Dates/Times and JSON</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The JSON format does not directly support dates and times.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, they are very commonly used and ASP.NET AJAX provides special support for these types.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>When using ASP.NET AJAX proxies, the <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> type in .NET fully corresponds to the <ph id="ph2">`DateTime`</ph> type in JavaScript.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When not using ASP.NET, a <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.DateTimeOffset&gt;</ph> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`offsetMinutes`</ph> member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dateTime`</ph> member represents the instance in time when the event of interest occurred (again, it becomes a <ph id="ph2">`DateTime`</ph> in JavaScript when ASP.NET AJAX is in use and a string when it is not).</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>On serialization, the <ph id="ph1">`dateTime`</ph> member is always serialized in GMT.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>So, if describing 3:00 AM New York time, <ph id="ph1">`dateTime`</ph> has a time component of 8:00 AM and <ph id="ph2">`offsetMinutes`</ph> are 300 (minus 300 minutes or 5 hours from GMT).</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> and <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph> objects, when serialized to JSON, only preserve information to millisecond precision.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Sub-millisecond values (micro/nanoseconds) are lost during serialization.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>XML Types and JSON</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>XML types become JSON strings.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For example, if a data member "q" of type XElement contains <ph id="ph1">\&lt;</ph>abc/&gt;, the JSON is {"q":"<ph id="ph2">\&lt;</ph>abc/&gt;"}.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <ph id="ph1">&lt;xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A&gt;</ph> property to XML on <ph id="ph2">&lt;xref:System.ServiceModel.Web.WebGetAttribute&gt;</ph> or the <ph id="ph3">&lt;xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A&gt;</ph> property to XML on the <ph id="ph4">&lt;xref:System.ServiceModel.Web.WebInvokeAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Collections, Dictionaries and Arrays</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>All collections, dictionaries, and arrays are represented in JSON as arrays.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Any customization that uses the <ph id="ph1">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph> is ignored in the JSON representation.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Dictionaries are not a way to work directly with JSON.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Dictionary<ph id="ph1">\&lt;</ph>string,object&gt; may not be supported in the same way in <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> as expected from working with other JSON technologies.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Consider using the <bpt id="p1">[</bpt>Weakly-typed JSON Serialization (AJAX)<ept id="p1">](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)</ept> sample.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Consider working with the <bpt id="p1">[</bpt>Mapping Between JSON and XML<ept id="p1">](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)</ept> instead of using a serializer.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Polymorphism<ept id="p1">*</ept> in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This issue is more fully discussed in the Advanced Information section later in this topic.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Additional Details</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Order of Data Members</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Order of data members is not important when using JSON.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Specifically, even if <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A&gt;</ph> is set, JSON data can still be deserialized in any order.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>JSON Types</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The JSON type does not have to match the preceding table on deserialization.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example, an <ph id="ph1">`Int`</ph> normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>That is, both {"q":42} and {"q":"42"} are valid if there is an <ph id="ph1">`Int`</ph> data member called "q".</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Polymorphism</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This is supported for JSON serialization by <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> comparable to the way XML serialization is supported.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For example, you can serialize <ph id="ph1">`MyDerivedType`</ph> where <ph id="ph2">`MyBaseType`</ph> is expected, or serialize <ph id="ph3">`Int`</ph> where <ph id="ph4">`Object`</ph> is expected.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>For example, if <ph id="ph1">&lt;xref:System.Uri&gt;</ph> is serialized where <ph id="ph2">&lt;xref:System.Object&gt;</ph> is expected, it results in a JSON string.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If this string is then deserialized back into <ph id="ph1">&lt;xref:System.Object&gt;</ph>, a .NET <ph id="ph2">&lt;xref:System.String&gt;</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The deserializer does not know that the string was initially of type <ph id="ph1">&lt;xref:System.Uri&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Generally, when expecting <ph id="ph1">&lt;xref:System.Object&gt;</ph>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <ph id="ph2">&lt;xref:System.Array&gt;</ph> of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, regardless of what the actual original type had been.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A JSON boolean maps to a .NET <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>However when expecting an <ph id="ph1">&lt;xref:System.Object&gt;</ph>, JSON numbers are deserialized as either .NET <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> or <ph id="ph4">&lt;xref:System.Double&gt;</ph>, where the most appropriate type is automatically picked.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>When deserializing into an interface type, the <ph id="ph1">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> deserializes as if the declared type were object.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>When working with your own base and derived types, using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.ServiceModel.ServiceKnownTypeAttribute&gt;</ph> or an equivalent mechanism is normally required.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For example, if you have an operation that has an <ph id="ph1">`Animal`</ph> return value and it actually returns an instance of <ph id="ph2">`Cat`</ph> (derived from <ph id="ph3">`Animal`</ph>), you should either apply the <ph id="ph4">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph>, to the <ph id="ph5">`Animal`</ph> type or the <ph id="ph6">&lt;xref:System.ServiceModel.ServiceKnownTypeAttribute&gt;</ph> to the operation and specify the <ph id="ph7">`Cat`</ph> type in these attributes.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Data Contract Known Types<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Versioning</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The data contract versioning features, including the <ph id="ph1">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface, are fully supported in JSON.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <ph id="ph1">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Forward-Compatible Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Remember that JSON is unordered so any order information is lost.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Furthermore, JSON does not support multiple key/value pairs with the same key name.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Finally, all operations on <ph id="ph1">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> are inherently polymorphic - that is their derived type are assigned to <ph id="ph2">&lt;xref:System.Object&gt;</ph>, the base type for all types.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>JSON in URLs</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <ph id="ph1">&lt;xref:System.ServiceModel.Web.WebGetAttribute&gt;</ph> attribute), incoming parameters appear in the request URL instead of the message body.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>JSON is supported even in the request URL, so if you have an operation that takes an <ph id="ph1">`Int`</ph> called "number" and a <ph id="ph2">`Person`</ph> complex type called "p", the URL may resemble the following URL.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Advanced information</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>ISerializable Support</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Supported and Unsupported ISerializable Types</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In general, types that implement the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface are fully supported when serializing/deserializing JSON.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>, the type of individual data members is never known in advance.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>This leads to a polymorphic situation similar to deserializing types into an object.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>As mentioned before, this may lead to loss of type information in JSON.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For example, a type that serializes an <ph id="ph1">`enum`</ph> in its <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> implementation and attempts to deserialize back directly into an <ph id="ph3">`enum`</ph> (without proper casts) fails, because an <ph id="ph4">`enum`</ph> is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>So the fact that the number used to be an <ph id="ph1">`enum`</ph> value is lost.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Factory Types</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>While the <ph id="ph1">&lt;xref:System.Runtime.Serialization.IObjectReference&gt;</ph> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <ph id="ph2">&lt;xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29&gt;</ph> than the type that implements the interface) are not supported.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>DateTime Wire Format</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The number may be negative to represent earlier times.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The part that consists of "+0500" in the example is optional and indicates that the time is of the <ph id="ph1">&lt;xref:System.DateTimeKind&gt;</ph> kind - that is, should be converted to the local time zone on deserialization.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If it is absent, the time is deserialized as <ph id="ph1">&lt;xref:System.DateTimeKind&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The actual number ("0500" in this example) and its sign (+ or -) are ignored.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>When serializing <ph id="ph1">&lt;xref:System.DateTime&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTimeKind&gt;</ph> and <ph id="ph3">&lt;xref:System.DateTimeKind&gt;</ph> times are written with an offset, and <ph id="ph4">&lt;xref:System.DateTimeKind&gt;</ph> is written without.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript <ph id="ph1">`DateTime`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>If there are other strings that have a similar form that are not of type <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> in .NET, they are converted as well.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "<ph id="ph1">\\</ph>/Date(700000+0500)<ph id="ph2">\\</ph>/"), and for this reason <ph id="ph3">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>'s JSON encoder (enabled by the <ph id="ph4">&lt;xref:System.ServiceModel.WebHttpBinding&gt;</ph>) always escapes the "/" character.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>XML in JSON Strings</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>XmlElement</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlElement&gt;</ph> is serialized as is, with no wrapping.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For example, data member "x" of type <ph id="ph1">&lt;xref:System.Xml.XmlElement&gt;</ph> that contains <ph id="ph2">\&lt;</ph>abc/&gt; is as represented as follows.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Arrays of XmlNode</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> objects of type <ph id="ph2">&lt;xref:System.Xml.XmlNode&gt;</ph> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>IXmlSerializable Types including XElement and DataSet</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> types subdivide into "content types", "DataSet types" and "element types".</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For definitions of these types, see <bpt id="p1">[</bpt>XML and ADO.NET Types in Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>"Content" and "DataSet" types are serialized similar to <ph id="ph1">&lt;xref:System.Array&gt;</ph> objects of <ph id="ph2">&lt;xref:System.Xml.XmlNode&gt;</ph> discussed in the previous section.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>"Element" types such as <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> are serialized as is, similar to <ph id="ph2">&lt;xref:System.Xml.XmlElement&gt;</ph> previously discussed in this topic.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Polymorphism</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Preserving Type Information</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>As stated earlier, polymorphism is supported in JSON with some limitations.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>JavaScript is a weakly-typed language and type identity is normally not an issue.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The "type hint" is a JSON key/value pair with the key name of "__type" (two underscores followed by the word "type").</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Using the earlier example, "Circle" can be serialized as follows.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The type hint is very similar to the <ph id="ph1">`xsi:type`</ph> attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Data members called "__type" are forbidden due to potential conflict with the type hint.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Reducing the Size of Type Hints</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>To reduce the size of JSON messages, the default data contract namespace prefix (http://schemas.datacontract.org/2004/07/) is replaced with the "#" character.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "<ph id="ph1">\\</ph>" characters, they are appended with an extra "<ph id="ph2">\\</ph>" character).</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is http://schemas.datacontract.org/2004/07/MyApp.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Shapes and the JSON representation is as follows.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Type Hint Position in JSON Objects</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Note that the type hint must appear first in the JSON representation.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>This is the only case where order of key/value pairs is important in JSON processing.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>For example, the following is not a valid way to specify the type hint.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Both the <ph id="ph1">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> used by <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> and ASP.NET AJAX client pages always emit the type hint first.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Type Hints Apply Only to Complex Types</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>There is no way to emit a type hint for non-complex types.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For example, if an operation has an <ph id="ph1">&lt;xref:System.Object&gt;</ph> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This applies not only to primitive types but also to collections and arrays.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>When Are Type Hints Emitted</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Therefore, the following rules govern whether type hints are emitted:</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <ph id="ph1">&lt;xref:System.Object&gt;</ph> but not when assigned to Circle.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>When using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> type, the <ph id="ph2">`alwaysEmitTypeInformation`</ph> constructor parameter allows you to choose between the preceding two modes, with the default being "<ph id="ph3">`false`</ph>" (only emit type hints when required).</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Duplicate Data Member Names</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Derived type information is present in the same JSON object together with base type information, and can occur in any order.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`Shape`</ph> may be represented as follows.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Whereas Circle may be represented as follows.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If the base <ph id="ph1">`Shape`</ph> type also contained a data member called "<ph id="ph2">`radius`</ph>", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to <ph id="ph3">`Shape.radius`</ph> or <ph id="ph4">`Circle.radius`</ph>).</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Polymorphism and IXmlSerializable Types</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>However, serializing an <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> type in place of <ph id="ph2">&lt;xref:System.Object&gt;</ph> results in loss of type information as the result is a JSON string.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Polymorphism and Certain Interface Types</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>It is forbidden to serialize a collection type or a type that implements <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> where a non-collection type that is not <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> (except for <ph id="ph3">&lt;xref:System.Object&gt;</ph>) is expected.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For example, a custom interface called <ph id="ph1">`IMyInterface`</ph> and a type <ph id="ph2">`MyType`</ph> that implement both <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of type <ph id="ph4">`int`</ph> and <ph id="ph5">`IMyInterface`</ph>.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>It is forbidden to return <ph id="ph1">`MyType`</ph> from an operation whose return type is <ph id="ph2">`IMyInterface`</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>This is because <ph id="ph1">`MyType`</ph> must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Known Types and Configuration</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>All of the Known Type mechanisms used by the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> are also supported in the same way by the <ph id="ph2">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Both serializers read the same configuration element, <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>dataContractSerializer&gt;<ept id="p1">](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md)</ept> in <bpt id="p2">[</bpt><ph id="ph2">\&lt;</ph>system.runtime.serialization&gt;<ept id="p2">](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)</ept>, to discover known types added through a configuration file.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Collections Assigned to Object</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Collections assigned to Object are serialized as if they are collections that implement <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>: a JSON array with each entry that has a type hint if it is a complex type.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of type <ph id="ph2">`Shape`</ph> assigned to <ph id="ph3">&lt;xref:System.Object&gt;</ph> looks like the following.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>When deserialized back into <ph id="ph1">&lt;xref:System.Object&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Shape`</ph> must be in the Known Types list.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Having <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of type <ph id="ph2">`Shape`</ph> in known types has no effect.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Note that you do not have to add <ph id="ph1">`Shape`</ph> to known types on serialization in this case - this is done automatically.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The collection is deserialized as an <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> that contains <ph id="ph3">`Shape`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Derived Collections Assigned to Base Collections</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Type Hints and Dictionaries</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>When a dictionary is assigned to an <ph id="ph1">&lt;xref:System.Object&gt;</ph>, each Key and Value entry in the dictionary is treated as if it was assigned to <ph id="ph2">&lt;xref:System.Object&gt;</ph> and gets a type hint.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the <ph id="ph1">`alwaysEmitTypeInformation`</ph> setting and only contains a type hint when the preceding collection rules require it.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Valid JSON Key Names</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The serializer XML-encodes key names that are not valid XML names.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>For example, a data member with the name of "123" would have an encoded name such as "_x0031<ph id="ph1">\_</ph>_x0032<ph id="ph2">\_</ph>_x0033<ph id="ph3">\_</ph>" because "123" is an invalid XML element name (starts with a digit).</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>A similar situation may arise with some international character sets not valid in XML names.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For an explanation of this effect of XML on JSON processing, see <bpt id="p1">[</bpt>Mapping Between JSON and XML<ept id="p1">](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Support for JSON and Other Data Transfer Formats<ept id="p1">](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>