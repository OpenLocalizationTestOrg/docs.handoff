<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">624fd8b3f2d6453306267ac1bb27d45b8c98ae55</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\samples\custom-message-encoder-compression-encoder.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a7197b3b2c1aabd41e5884db988f79af02fa0546</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">543e6409bc65fd1623f38455c557372130fb4673</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Custom Message Encoder: Compression Encoder | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Custom Message Encoder: Compression Encoder</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This sample demonstrates how to implement a custom encoder using the <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> platform.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The samples may already be installed on your machine.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Check for the following (default) directory before continuing.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>If this directory does not exist, go to <bpt id="p1">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> and <ph id="ph2">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This sample is located in the following directory.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Sample Details</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This sample consists of a client console program (.exe), a self-hosted service console program (.exe) and a compression message encoder library (.dll).</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The service implements a contract that defines a request-reply communication pattern.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The contract is defined by the <ph id="ph1">`ISampleServer`</ph> interface, which exposes basic string echoing operations (<ph id="ph2">`Echo`</ph> and <ph id="ph3">`BigEcho`</ph>).</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The client makes synchronous requests to a given operation and the service replies by repeating the message back to the client.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Client and service activity is visible in the console windows.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The intent of this sample is to show how to write a custom encoder and demonstrate the impact of compression of a message on the wire.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can add instrumentation to the compression message encoder to calculate message size, processing time, or both.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the .NET Framework 4, automatic decompression has been enabled on a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> client if the server is sending a compressed response (created with an algorithm such as GZip or Deflate).</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If the service is Web-hosted in Internet Information Server (IIS), then IIS can be configured for the service to send a compressed response.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This sample can be used if the requirement is to do compression and decompression on both the client and the service or if the service is self-hosted.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The sample demonstrates how to build and integrate a custom message encoder into a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> application.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The library GZipEncoder.dll is deployed with both the client and the service.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This sample also demonstrates the impact of compressing messages.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The code in GZipEncoder.dll demonstrates the following:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Building a custom encoder and encoder factory.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Developing a binding element for a custom encoder.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Using the custom binding configuration for integrating custom binding elements.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Developing a custom configuration handler to allow file configuration of a custom binding element.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>As indicated previously, there are several layers that are implemented in a custom encoder.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>To better illustrate the relationship between each of these layers, a simplified order of events for service start-up is in the following list:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The server starts.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The configuration information is read.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The service configuration registers the custom configuration handler.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The service host is created and opened.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The custom configuration element creates and returns the custom binding element.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The custom binding element creates and returns a message encoder factory.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A message is received.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The message encoder factory returns a message encoder for reading in the message and writing out the response.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The encoder layer is implemented as a class factory.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Only the encoder class factory must be publicly exposed for the custom encoder.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The factory object is returned by the binding element when the <ph id="ph1">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph> or <ph id="ph2">&lt;xref:System.ServiceModel.ChannelFactory%601&gt;</ph> object is created.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Message encoders can operate in a buffered or streaming mode.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This sample demonstrates both buffered mode and streaming mode.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For each mode there is an accompanying <ph id="ph1">`ReadMessage`</ph> and <ph id="ph2">`WriteMessage`</ph> method on the abstract <ph id="ph3">`MessageEncoder`</ph> class.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A majority of the encoding work takes place in these methods.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The sample wraps the existing text and binary message encoders.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This allows the sample to delegate the reading and writing of the wire representation of messages to the inner encoder and allows the compression encoder to compress or decompress the results.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Because there is no pipeline for message encoding, this is the only model for using multiple encoders in <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Once the message has been decompressed, the resulting message is passed up the stack for the channel stack to handle.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>During compression, the resulting compressed message is written directly to the stream provided.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This sample uses helper methods (<ph id="ph1">`CompressBuffer`</ph> and <ph id="ph2">`DecompressBuffer`</ph>) to perform conversion from buffers to streams to use the <ph id="ph3">`GZipStream`</ph> class.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The buffered <ph id="ph1">`ReadMessage`</ph> and <ph id="ph2">`WriteMessage`</ph> classes make use of the <ph id="ph3">`BufferManager`</ph> class.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The encoder is accessible only through the encoder factory.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The abstract <ph id="ph1">`MessageEncoderFactory`</ph> class provides a property named <ph id="ph2">`Encoder`</ph> for accessing the current encoder and a method named <ph id="ph3">`CreateSessionEncoder`</ph> for creating an encoder that supports sessions.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Such an encoder can be used in the scenario where the channel supports sessions, is ordered and is reliable.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This scenario allows for optimization in each session of the data written to the wire.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If this is not desired, the base method should not be overloaded.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Encoder`</ph> property provides a mechanism for accessing the session-less encoder and the default implementation of the <ph id="ph2">`CreateSessionEncoder`</ph> method returns the value of the property.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Because the sample wraps an existing encoder to provide compression, the <ph id="ph1">`MessageEncoderFactory`</ph> implementation accepts a <ph id="ph2">`MessageEncoderFactory`</ph> that represents the inner encoder factory.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Now that the encoder and encoder factory are defined, they can be used with a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> client and service.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>However, these encoders must be added to the channel stack.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You can derive classes from the <ph id="ph1">&lt;xref:System.ServiceModel.ServiceHost&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.ChannelFactory%601&gt;</ph> classes and override the <ph id="ph3">`OnInitialize`</ph> methods to add this encoder factory manually.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can also expose the encoder factory through a custom binding element.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To create a new custom binding element, derive a class from the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.BindingElement&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>There are, however, several types of binding elements.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>To ensure that the custom binding element is recognized as a message encoding binding element, you also must implement the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement&gt;</ph> exposes a method for creating a new message encoder factory (<ph id="ph2">`CreateMessageEncoderFactory`</ph>), which is implemented to return an instance of the matching message encoder factory.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Additionally, the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageEncodingBindingElement&gt;</ph> has a property to indicate the addressing version.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Because this sample wraps the existing encoders, the sample implementation also wraps the existing encoder binding elements and takes an inner encoder binding element as a parameter to the constructor and exposes it through a property.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following sample code shows the implementation of the <ph id="ph1">`GZipMessageEncodingBindingElement`</ph> class.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`GZipMessageEncodingBindingElement`</ph> class implements the <ph id="ph2">`IPolicyExportExtension`</ph> interface, so that this binding element can be exported as a policy in metadata, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`GZipMessageEncodingBindingElementImporter`</ph> class implements the <ph id="ph2">`IPolicyImportExtension`</ph> interface, this class imports policy for <ph id="ph3">`GZipMessageEncodingBindingElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Svcutil.exe tool can be used to import policies to the configuration file, to handle <ph id="ph1">`GZipMessageEncodingBindingElement`</ph>, the following should be added to Svcutil.exe.config.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Now that there is a matching binding element for the compression encoder, it can be programmatically hooked into the service or client by constructing a new custom binding object and adding the custom binding element to it, as shown in the following sample code.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>While this may be sufficient for the majority of user scenarios, supporting a file configuration is critical if a service is to be Web-hosted.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>To support the Web-hosted scenario, you must develop a custom configuration handler to allow a custom binding element to be configurable in a file.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You can build a configuration handler for the binding element on top of the configuration system provided by the <ph id="ph1">[!INCLUDE[dnprdnlong](../../../../includes/dnprdnlong-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The configuration handler for the binding element must derive from the <ph id="ph1">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`BindingElementType`</ph> property is used to inform the configuration system of the type of binding element to create for this section.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>All aspects of the <ph id="ph1">`BindingElement`</ph> that can be set should be exposed as properties in the <ph id="ph2">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement&gt;</ph> derived class.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Configuration.ConfigurationPropertyAttribute&gt;</ph> is used to assist in mapping the configuration element attributes to the properties and setting default values if attributes are missing.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>After the values from configuration are loaded and applied to the properties, the <ph id="ph1">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement.CreateBindingElement%2A&gt;</ph> method is called, which converts the properties into a concrete instance of a binding element.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement.ApplyConfiguration%2A&gt;</ph> method is used to convert the properties on the <ph id="ph2">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement&gt;</ph> derived class into the values to be set on the newlycreated binding element.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following sample code shows the implementation of the <ph id="ph1">`GZipMessageEncodingElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This configuration handler maps to the following representation in the App.config or Web.config for the service or client.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>To use this configuration handler, it must be registered within the <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>system.serviceModel&gt;<ept id="p1">](../../../../docs/framework/configure-apps/file-schema/wcf/system-servicemodel.md)</ept> element, as shown in the following sample configuration.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When you run the server, the operation requests and responses are displayed in the console window.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Press ENTER in the window to shut down the server.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When you run the client, the operation requests and responses are displayed in the console window.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Press ENTER in the client window to shut down the client.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>To set up, build, and run the sample</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Install <ph id="ph1">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> 4.0 using the following command:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Ensure that you have performed the <bpt id="p1">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To build the solution, follow the instructions in <bpt id="p1">[</bpt>Building the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id="p1">[</bpt>Running the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The samples may already be installed on your machine.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Check for the following (default) directory before continuing.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If this directory does not exist, go to <bpt id="p1">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> and <ph id="ph2">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This sample is located in the following directory.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>