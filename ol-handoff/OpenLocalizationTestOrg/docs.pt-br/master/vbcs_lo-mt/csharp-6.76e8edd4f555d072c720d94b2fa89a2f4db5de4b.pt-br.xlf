<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c48b82f8f104d96fa6748c53b993a7f82687a6a9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\whats-new\csharp-6.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7dd398485876fac6fefac99fed81b402a105eda5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5c95eb4d15036ab8cdc102724092b880aa7aaaf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>What's New in C# 6 | C# Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn the new features in C# Version 6</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>What's New in C# 6</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The 6.0 release of C# contained many features that improve productivity for developers.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Features in this release include:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Read-only Auto-properties<ept id="p1">](#read-only-auto-properties)</ept>:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can create read-only auto-properties that can be set only in constructors.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Auto-Property Initializers<ept id="p1">](#auto-property-initializers)</ept>:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can write initialization expressions to set the initial value of an auto-property.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Expression-bodied function members<ept id="p1">](#expression-bodied-function-members)</ept>:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can author one-line methods using lambda expressions.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>using static<ept id="p1">](#using-static)</ept>:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can import all the methods of a single class into the current namespace.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Null - conditional operators<ept id="p1">](#null-conditional-operators)</ept>:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can concisely and safely access members of an object while still checking for null with the null conditional operator.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String Interpolation<ept id="p1">](#string-interpolation)</ept>:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can write string formatting expressions using inline expressions instead of positional arguments.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Exception filters<ept id="p1">](#exception-filters)</ept>:</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can catch expressions based on properties of the exception or other program state.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>nameof Expressions<ept id="p1">](#nameof-expressions)</ept>:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can let the compiler generate string representations of symbols.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>await in catch and finally blocks<ept id="p1">](#await-in-catch-and-finally-blocks)</ept>:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`await`</ph> expressions in locations that previously disallowed them.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>index initializers<ept id="p1">](#index-initializers)</ept>:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can author initialization expressions for associative containers as well as sequence containers.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Extension methods for collection initializers<ept id="p1">](#extension-add-methods-in-collection-initializers)</ept>:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Collection initializers can rely on accessible extension methods, in addition to member methods.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Improved overload resolution<ept id="p1">](#improved-overload-resolution)</ept>:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Some constructs that previously generated ambiguous method calls now resolve correctly.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The overall effect of these features is that you write more concise code that is also more readable.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The syntax contains less ceremony for many common practices.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>It's easier to see the design intent with less ceremony.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Learn these features well, and you'll be more productive, write more readable code, and concentrate more on your core features than on the constructs of the language.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The remainder of this topic provides details on each of these features.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Auto-Property enhancements</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The syntax for automatically implemented properties (usually referred to as 'auto-properties') made it very easy to create properties that had simple get and set accessors:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ClassicAutoProperty<ept id="p2">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicAutoProperty)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, this simple syntax limited the kinds of designs you could support using auto-properties.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>C# 6 improves the auto-properties capabilities so that you can use them in more scenarios.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You won't need to fall back on the more verbose syntax of declaring and manipulating the backing field by hand so often.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The new syntax addresses scenarios for read only properties, and for initializing the variable storage behind an auto-property.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Read-only auto-properties</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Read-only auto-properties<ept id="p1">*</ept> provide a more concise syntax to create immutable types.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The closest you could get to immutable types in earlier versions of C# was to declare private setters:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ClassicReadOnlyAutoProperty<ept id="p2">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicReadOnlyAutoProperty)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Using this syntax, the compiler doesn't ensure that the type really is immutable.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It only enforces that the <ph id="ph1">`FirstName`</ph> and <ph id="ph2">`LastName`</ph> properties are not modified from any code outside the class.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Read-only auto-properties enable true read-only behavior.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You declare the auto-property with only a get accessor:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ReadOnlyAutoProperty<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FirstName`</ph> and <ph id="ph2">`LastName`</ph> properties can be set only in the body of a constructor:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ReadOnlyAutoPropertyConstructor<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Trying to set <ph id="ph1">`LastName`</ph> in another method generates a <ph id="ph2">`CS0200`</ph> compilation error:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This feature enables true language support for creating immutable types and using the more concise and convenient auto-property syntax.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Auto-Property Initializers</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Auto-Property Initializers<ept id="p1">*</ept> let you declare the initial value for an auto-property as part of the property declaration.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In earlier versions, these properties would need to have setters and you would need to use that setter to initialize the data storage used by the backing field.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Consider this class for a student that contains the name and a list of the student's grades:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Construction<ept id="p2">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#Construction)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>As this class grows, you may include other constructors.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Each constructor needs to initialize this field, or you'll introduce errors.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>C# 6 enables you to assign an initial value for the storage used by an auto-property in the auto-property declaration:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Initialization<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Grades`</ph> member is initialized where it is declared.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>That makes it easier to perform the initialization exactly once.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The initialization is part of the property declaration, making it easier to equate the storage allocation with public interface for <ph id="ph1">`Student`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Property Initializers can be used with read/write properties as well as read only properties, as shown here.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ReadWriteInitialization<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadWriteInitialization)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Expression-bodied function members</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The body of a lot of members that we write consist of only one statement that can be represented as an expression.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can reduce that syntax by writing an expression-bodied member instead.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It works for methods and read-only properties."</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, an override of <ph id="ph1">`ToString()`</ph> is often a great candidate:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ToStringExpressionMember<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can also use expression-bodied members in read only properties as well:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>FullNameExpressionMember<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>using static</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>using static<ept id="p1">*</ept> enhancement enables you to import the static methods of a single class.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Previously, the <ph id="ph1">`using`</ph> statement imported all types in a namespace.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Often we use a class' static methods throughout our code.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Repeatedly typing the class name can obscure the meaning of your code.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>A common example is when you write classes that perform many numeric calculations.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Your code will be littered with <ph id="ph1">@System.Math.Sin</ph>, <ph id="ph2">@System.Math.Sqrt</ph> and other calls to different methods in the <ph id="ph3">@System.Math</ph> class.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">`using static`</ph> syntax can make these classes much cleaner to read.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You specify the class you're using:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UsingStaticMath<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>And now, you can use any static method in the <ph id="ph1">@System.Math</ph> class without qualifying the <ph id="ph2">@System.Math</ph> class.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.Math</ph> class is a great use case for this feature because it does not contain any instance methods.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You can also use <ph id="ph1">`using static`</ph> to import a class' static methods for a class that has both static and instance methods.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>One of the most useful examples is <ph id="ph1">@System.String:</ph></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UsingStatic<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You must use the fully qualified class name, <ph id="ph1">`System.String`</ph> in a static using statement.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You cannot use the <ph id="ph1">`string`</ph> keyword instead.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can now call static methods defined in the <ph id="ph1">@System.String</ph> class without qualifying those methods as members of that class:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UsingStaticString<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticString)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`static using`</ph> feature and extension methods interact in interesting ways, and the language design included some rules that specifically address those interactions.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The goal is to minimize any chances of breaking changes in existing codebases, including yours.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Extension methods are only in scope when called using the extension method invocation syntax, not when called as a static method.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You'll often see this in LINQ queries.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>You can import the LINQ pattern by importing <ph id="ph1">@System.Linq.Enumerable</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UsingStaticLinq<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This imports all the methods in the <ph id="ph1">@System.Linq.Enumerable</ph> class.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>However, the extension methods are only in scope when called as extension methods.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>They are not in scope if they are called using the static method syntax:</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UsingStaticLinqMethod<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticLinkMethod)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This decision is because extension methods are typically called using extension method invocation expressions.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>In the rare case where they are called using the static method call syntax it is to resolve ambiguity.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Requiring the class name as part of the invocation seems wise.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>There's one last feature of <ph id="ph1">`static using`</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`static using`</ph> directive also imports any nested types.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>That enables you to reference any nested types without qualification.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Null-conditional operators</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Null values complicate code.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You need to check every access of variables to ensure you are not dereferencing <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>null conditional operator<ept id="p1">*</ept> makes those checks much easier and fluid.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Simply replace the member access <ph id="ph1">`.`</ph> with <ph id="ph2">`?.`</ph>:</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>NullConditional<ept id="p2">](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In the preceding example, the variable <ph id="ph1">`first`</ph> is assigned <ph id="ph2">`null`</ph> if the person object is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Otherwise, it gets assigned the value of the <ph id="ph1">`FirstName`</ph> property.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Most importantly, the <ph id="ph1">`?.`</ph> means that this line of code does not generate a <ph id="ph2">`NullReferenceException`</ph> when the <ph id="ph3">`person`</ph> variable is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Instead, it short-circuits and produces <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Also, note that this expression returns a <ph id="ph1">`string`</ph>, regardless of the value of <ph id="ph2">`person`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In the case of short circuiting, the <ph id="ph1">`null`</ph> value returned is typed to match the full expression.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>You can often use this construct with the <bpt id="p1">*</bpt>null coalescing<ept id="p1">*</ept> operator to assign default values when one of the properties are <ph id="ph1">`null`</ph>:</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>NullCoalescing<ept id="p2">](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The right hand side operand of the <ph id="ph1">`?.`</ph> operator is not limited to properties or fields.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You can also use it to conditionally invoke methods.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The most common use of member functions with the null conditional operator is to safely invoke delegates (or event handlers) that may be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You'll do this by calling the delegate's <ph id="ph1">`Invoke`</ph> method using the <ph id="ph2">`?.`</ph> operator to access the member.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>You can see an example in the</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>delegate patterns<ept id="p1">](../delegates-patterns.md#handling-null-delegates)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The rules of the <ph id="ph1">`?.`</ph> operator ensure that the left-hand side of the operator is evaluated only once.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This is important and enables many idioms, including the example using event handlers.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Let's start with the event handler usage.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In previous versions of C#, you were encouraged to write code like this:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This was preferred over a simpler syntax:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The preceding example introduces a race condition.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SomethingHappened`</ph> event may have subscribers when checked against <ph id="ph2">`null`</ph>, and those subscribers may have been removed before the event is raised.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>That would cause a <ph id="ph1">@System.NullReferenceException</ph> to be thrown.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>In this second version, the <ph id="ph1">`SomethingHappened`</ph> event handler might be non-null when tested, but if other code removes a handler, it could still be null when the event handler was called.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The compiler generates code for the <ph id="ph1">`?.`</ph> operator that ensures the left side (<ph id="ph2">`this.SomethingHappened`</ph>) of the <ph id="ph3">`?.`</ph> expression is evaluated once, and the result is cached:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the <ph id="ph1">`?.`</ph> Even if these have side-effects, they are evaluated once, so the side effects occur only once.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>You can see an example in our content on <bpt id="p1">[</bpt>events<ept id="p1">](../events-overview.md#language-support-for-events)</ept>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>String Interpolation</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>C# 6 contains new syntax for composing strings from a format string and expressions that can be evaluated to produce other string values.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Traditionally, you needed to use positional parameters in a method like <ph id="ph1">`string.Format`</ph>:</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>stringFormat<ept id="p2">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#stringFormat)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>With C# 6, the new string interpolation feature enables you to embed the expressions in the format string.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Simple preface the string with <ph id="ph1">`$`</ph>:</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>stringInterpolation<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>This initial example used variable expressions for the substituted expressions.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>You can expand on this syntax to use any expression.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For example, you could compute a student's grade point average as part of the interpolation:</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>stringInterpolationExpression<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationExpression)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Running the preceding example, you would find that the output for <ph id="ph1">`Grades.Average()`</ph> might have more decimal places than you would like.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The string interpolation syntax supports all the format strings available using earlier formatting methods.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>You add the format strings inside the braces.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Add a <ph id="ph1">`:`</ph> following the expression to format:</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>stringInterpolationFormat<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The preceding line of code will format the value for <ph id="ph1">`Grades.Average()`</ph> as a floating-point number with two decimal places.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`:`</ph> is always interpreted as the separator between the expression being formatted and the format string.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This can introduce problems when your expression uses a <ph id="ph1">`:`</ph> in another way, such as a conditional operator:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>In the preceding example, the <ph id="ph1">`:`</ph> is parsed as the beginning of the format string, not part of the conditional operator.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>In all cases where this happens, you can surround the expression with parentheses to force the compiler to interpret the expression as you intend:</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>stringInterpolationConditional<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationConditional)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>There aren't any limitations on the expressions you can place between the braces.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>You can execute a complex LINQ query inside an interpolated string to perform computations and display the result:</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>stringInterpolationLinq<ept id="p2">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationLinq)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>You can see from this sample that you can even nest a string interpolation expression inside another string interpolation expression.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This example is very likely more complex than you would want in production code.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Rather, it is illustrative of the breadth of the feature.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Any C# expression can be placed between the curly braces of an interpolated string.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>String interpolation and specific cultures</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>All the examples shown in the preceding section will format the strings using the current culture and language on the machine where the code executes.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Often you may need to format the string produced using a specific culture.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The object produced from a string interpolation is a type that has an implicit conversion to either <ph id="ph1">@System.String</ph> or <ph id="ph2">@System.FormattableString</ph>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.FormattableString</ph> type contains the format string, and the results of evaluating the arguments before converting them to strings.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You can use public methods of <ph id="ph1">@System.FormattableString</ph> to specify the culture when formatting a string.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, the following will produce a string using German as the language and culture.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>(It will use the ',' character for the decimal separator, and the '.' character as the thousands separator.)</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The preceding example is not supported in .NET Core version 1.0.1.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>It is only supported in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>In general, string interpolation expressions produce strings as their output.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>However, when you want greater control over the culture used to format the string, you can specify a specific output.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If this is a capability you often need, you can create convenience methods, as extension methods, to enable easy formatting with specific cultures.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Exception Filters</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Another new feature in C# 6 is <bpt id="p1">*</bpt>exception filters<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Exception Filters are clauses that determine when a given catch clause should be applied.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If the expression used for an exception filter evaluates to <ph id="ph1">`true`</ph>, the catch clause performs its normal processing on an exception.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to <ph id="ph1">`false`</ph>, then the <ph id="ph2">`catch`</ph> clause is skipped.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>One use is to examine information about an exception to determine if a <ph id="ph1">`catch`</ph> clause can process the exception:</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ExceptionFilter<ept id="p2">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The code generated by exception filters provides better information about an exception that is thrown and not processed.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Before exception filters were added to the language, you would need to create code like the following:</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ExceptionFilterOld<ept id="p2">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilterOld)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The point where the exception is thrown changes between these two examples.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>In the previous code, where a <ph id="ph1">`throw`</ph> clause is used, any stack trace analysis or examination of crash dumps will show that the exception was thrown from the <ph id="ph2">`throw`</ph> statement in your catch clause.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The actual exception object will contain the original call stack, but all other information about any variables in the call stack between this throw point and the location of the original throw point has been lost.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Contrast that with how the code using an exception filter is processed: the exception filter expression evaluates to <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Therefore, execution never enters the <ph id="ph1">`catch`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`catch`</ph> clause does not execute, no stack unwinding takes place.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>That means the original throw location is preserved for any debugging activities that would take place later.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Whenever you need to evaluate fields or properties of an exception, instead of relying solely on the exception type, use an exception filter to preserve more debugging information.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Another recommended pattern with exception filters is to use them for logging routines.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>This usage also leverages the manner in which the exception throw point is preserved when an exception filter evaluates to <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>A logging method would be a method whose argument is the exception that unconditionally returns <ph id="ph1">`false`</ph>:</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ExceptionFilterLogging<ept id="p2">](../../../samples/snippets/csharp/new-in-6/ExceptionFilterHelpers.cs#ExceptionFilterLogging)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Whenever you want to log an exception, you can add a catch clause, and use this method as the exception filter:</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>LogException<ept id="p2">](../../../samples/snippets/csharp/new-in-6/program.cs#LogException)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The exceptions are never caught, because the <ph id="ph1">`LogException`</ph> method always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>That always false exception filter means that you can place this logging handler before any other exception handlers:</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>LogExceptionRecovery<ept id="p2">](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionRecovery)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The preceding example highlights a very important facet of exception filters.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The exception filters enable scenarios where a more general exception catch clause may appear before a more specific one.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>It's also possible to have the same exception type appear in multiple catch clauses:</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>HandleNotChanged<ept id="p2">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#HandleNotChanged)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Another recommended pattern helps prevent catch clauses from processing exceptions when a debugger is attached.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>This technique enables you to run an application with the debugger, and stop execution when an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>In your code, add an exception filter so that any recovery code executes only when a debugger is not attached:</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>LogExceptionDebugger<ept id="p2">](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionDebugger)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>After adding this in code, you set your debugger to break on all unhandled exceptions.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Run the program under the debugger, and the debugger breaks whenever <ph id="ph1">`PerformFailingOperation()`</ph> throws a <ph id="ph2">`RecoverableException`</ph>.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The debugger breaks your program, because the catch clause won't be executed due to the false-returning exception filter.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`nameof`</ph> Expressions</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`nameof`</ph> expression evaluates to the name of a symbol.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>One of the most common uses for <ph id="ph1">`nameof`</ph> is to provide the name of a symbol that caused an exception:</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>nameof<ept id="p2">](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Another use is with XAML based applications that implement the <ph id="ph1">`INotifyPropertyChanged`</ph> interface:</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>nameofNotify<ept id="p2">](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The advantage of using the <ph id="ph1">`nameof`</ph> operator over a constant string is that tools can understand the symbol.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>If you use refactoring tools to rename the symbol, it will rename it in the <ph id="ph1">`nameof`</ph> expression.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Constant strings don't have that advantage.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Try it yourself in your favorite editor: rename a variable, and any <ph id="ph1">`nameof`</ph> expressions will update as well.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`nameof`</ph> expression produces the unqualified name of its argument (<ph id="ph2">`LastName`</ph> in the previous examples) even if you use the fully qualified name for the argument:</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>QualifiedNameofNotify<ept id="p2">](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#QualifiedNameofNotify)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">`nameof`</ph> expression produces <ph id="ph2">`FirstName`</ph>, not <ph id="ph3">`UXComponents.ViewModel.FirstName`</ph>.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Await in Catch and Finally blocks</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>C# 5 had several limitations around where you could place <ph id="ph1">`await`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>One of those has been removed in C# 6.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>You can now use <ph id="ph1">`await`</ph> in <ph id="ph2">`catch`</ph> or <ph id="ph3">`finally`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The addition of await expressions in catch and finally blocks may appear to complicate how those are processed.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Let's add an example to discuss how this appears.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>In any async method, you can use an await expression in a finally clause.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>With C# 6, you can also await in catch expressions.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>This is most often used with logging scenarios:</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>AwaitFinally<ept id="p2">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The implementation details for adding <ph id="ph1">`await`</ph> support inside <ph id="ph2">`catch`</ph> and <ph id="ph3">`finally`</ph> clauses ensures that the behavior is consistent with the behavior for synchronous code.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>When code executed in a <ph id="ph1">`catch`</ph> or <ph id="ph2">`finally`</ph> clause throws, execution looks for a suitable <ph id="ph3">`catch`</ph> clause in the next surrounding block.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>If there was a current exception, that exception is lost.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The same happens with awaited expressions in <ph id="ph1">`catch`</ph> and <ph id="ph2">`finally`</ph> clauses: a suitable <ph id="ph3">`catch`</ph> is searched for, and the current exception, if any, is lost.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>This behavior is the reason it's recommended to write <ph id="ph1">`catch`</ph> and <ph id="ph2">`finally`</ph> clauses carefully, to avoid introducing new exceptions.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Index Initializers</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Index Initializers<ept id="p1">*</ept> is one of two features that make collection initializers more consistent.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>In earlier releases of C#, you could use <bpt id="p1">*</bpt>collection initializers<ept id="p1">*</ept> only with sequence style collections:</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ListInitializer<ept id="p2">](../../../samples/snippets/csharp/new-in-6/initializers.cs#ListInitializer)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Now, you can also use them with <ph id="ph1">@System.Collections.Generic.Dictionary</ph> collections and similar types:</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>DictionaryInitializer<ept id="p2">](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Extension <ph id="ph1">`Add`</ph> methods in collection initializers</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Another feature that makes collection initialization easier is the ability to use an <bpt id="p1">*</bpt>extension method<ept id="p1">*</ept> for the <ph id="ph1">`Add`</ph> method.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>This feature was added for parity with Visual Basic.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>For example, consider a collection of students like this:</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Enrollment<ept id="p2">](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Enroll`</ph> method adds a student.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>But it doesn't follow the <ph id="ph1">`Add`</ph> pattern.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>In previous versions of C#, you could not use collection initializers with an <ph id="ph1">`Enrollment`</ph> object:</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>InitializeEnrollment<ept id="p2">](../../../samples/snippets/csharp/new-in-6/classList.cs#InitializeEnrollment)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Now you can, but only if you create an extension method that maps <ph id="ph1">`Add`</ph> to <ph id="ph2">`Enroll`</ph>:</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ExtensionAdd<ept id="p2">](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAdd)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>What you are doing with this feature is to map whatever method adds items to a collection to a method named <ph id="ph1">`Add`</ph> by creating an extension method:</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Enrollment<ept id="p2">](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>ExtensionAddSample<ept id="p4">](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAddSample)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Improved overload resolution</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>This last feature is one you probably won't notice.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Consider this method:</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>AsyncMethod<ept id="p2">](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>In earlier versions of C#, calling that method using the method group syntax would fail:</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MethodGroup<ept id="p2">](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The earlier compiler could not distinguish correctly between <ph id="ph1">`Task.Run(Action)`</ph> and <ph id="ph2">`Task.Run(Func&lt;Task&gt;())`</ph>.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>In previous versions, you'd need to use a lambda expression as an argument:</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Lambda<ept id="p2">](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>The C# 6 compiler correctly determines that <ph id="ph1">`Task.Run(Func&lt;Task&gt;())`</ph> is a better choice.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>