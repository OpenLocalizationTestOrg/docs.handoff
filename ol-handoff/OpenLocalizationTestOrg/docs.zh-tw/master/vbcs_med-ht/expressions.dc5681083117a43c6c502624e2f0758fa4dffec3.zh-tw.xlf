<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="expressions.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">79efbca3d8d0b32c83dc3909e0a33839ecc0ef3e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\statements-expressions-operators\expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4d78b9521497820ce40b0aed4c216483acb9fa04</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">135f2a5719c0c2b0695fa3b7b7e196fdadf08636</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Expressions (C# Programming Guide) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Expressions (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> is a sequence of one or more operands and zero or more operators that can be evaluated to a single value, object, method, or namespace.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Expressions can consist of a literal value, a method invocation, an operator and its operands, or a <bpt id="p1">*</bpt>simple name<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Simple names can be the name of a variable, type member, method parameter, namespace or type.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Expressions can use operators that in turn use other expressions as parameters, or method calls whose parameters are in turn other method calls, so expressions can range from simple to very complex.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Following are two examples of expressions:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Expression values</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In most of the contexts in which expressions are used, for example in statements or method parameters, the expression is expected to evaluate to some value.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>If x and y are integers, the expression <ph id="ph1">`x + y`</ph> evaluates to a numeric value.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`new MyClass()`</ph> evaluates to a reference to a new instance of a <ph id="ph2">`MyClass`</ph> object.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`myClass.ToString()`</ph> evaluates to a string because that is the return type of the method.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, although a namespace name is classified as an expression, it does not evaluate to a value and therefore can never be the final result of any expression.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You cannot pass a namespace name to a method parameter, or use it in a new expression, or assign it to a variable.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can only use it as a sub-expression in a larger expression.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The same is true for types (as distinct from <ph id="ph1">&lt;xref:System.Type?displayProperty=fullName&gt;</ph> objects), method group names (as distinct from specific methods), and event <bpt id="p1">[</bpt>add<ept id="p1">](../../../csharp/language-reference/keywords/add.md)</ept> and <bpt id="p2">[</bpt>remove<ept id="p2">](../../../csharp/language-reference/keywords/remove.md)</ept> accessors.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Every value has an associated type.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, if x and y are both variables of type <ph id="ph1">`int`</ph>, the value of the expression <ph id="ph2">`x + y`</ph> is also typed as <ph id="ph3">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If the value is assigned to a variable of a different type, or if x and y are different types, the rules of type conversion are applied.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more information about how such conversions work, see <bpt id="p1">[</bpt>Casting and Type Conversions<ept id="p1">](../../../csharp/programming-guide/types/casting-and-type-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Overflows</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Numeric expressions may cause overflows if the value is larger than the maximum value of the value's type.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Checked and Unchecked<ept id="p1">](../../../csharp/language-reference/keywords/checked-and-unchecked.md)</ept> and <bpt id="p2">[</bpt>Explicit Numeric Conversions Table<ept id="p2">](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The manner in which an expression is evaluated is governed by the rules of associativity and operator precedence.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Operators<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/operators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Most expressions, except assignment expressions and method invocation expressions, must be embedded in a statement.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Statements<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/statements.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Literals and simple names</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The two simplest types of expressions are literals and simple names.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A literal is a constant value that has no name.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, in the following code example, both <ph id="ph1">`5`</ph> and <ph id="ph2">`"Hello World"`</ph> are literal values:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For more information on literals, see <bpt id="p1">[</bpt>Types<ept id="p1">](../../../csharp/language-reference/keywords/types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In the preceding example, both <ph id="ph1">`i`</ph> and <ph id="ph2">`s`</ph> are simple names that identify local variables.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When those variables are used in an expression, the variable name evaluates to the value that is currently stored in the variable's location in memory.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This is shown in the following example:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Invocation expressions</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In the following code example, the call to <ph id="ph1">`DoWork`</ph> is an invocation expression.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A method invocation requires the name of the method, either as a name as in the previous example, or as the result of another expression, followed by parenthesis and any method parameters.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Methods<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/methods.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A delegate invocation uses the name of a delegate and method parameters in parenthesis.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Delegates<ept id="p1">](../../../csharp/programming-guide/delegates/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Method invocations and delegate invocations evaluate to the return value of the method, if the method returns a value.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Methods that return void cannot be used in place of a value in an expression.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Query expressions</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The same rules for expressions in general apply to query expressions.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>LINQ Query Expressions<ept id="p1">](../../../csharp/programming-guide/linq-query-expressions/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Lambda expressions</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Lambda expressions represent "inline methods" that have no name but can have input parameters and multiple statements.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>They are used extensively in LINQ to pass arguments to methods.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Lambda expressions are compiled to either delegates or expression trees depending on the context in which they are used.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Lambda Expressions<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Expression trees</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Expression trees enable expressions to be represented as data structures.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>They are used extensively by LINQ providers to translate query expressions into code that is meaningful in some other context, such as a SQL database.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Expression Trees<ept id="p1">](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Expression body definitions</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>C# supports <bpt id="p1">*</bpt>expression-bodied members<ept id="p1">*</ept>, which allow you to supply a concise expression body definition for methods, constructors, finalizers, properties, and indexers.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Expression-bodied members<ept id="p1">](expression-bodied-members.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Whenever a variable, object property, or object indexer access is identified from an expression, the value of that item is used as the value of the expression.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>An expression can be placed anywhere in C# where a value or object is required, as long as the expression ultimately evaluates to the required type.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/methods.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](../../../csharp/programming-guide/delegates/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Operators<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types<ept id="p1">](../../../csharp/programming-guide/types/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ Query Expressions<ept id="p1">](../../../csharp/programming-guide/linq-query-expressions/index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>