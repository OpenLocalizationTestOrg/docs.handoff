<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="pattern-matching.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c064af5fdf85587d0c4fa1471894122d6fe0d2f7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\tutorials\pattern-matching.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_hi-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f4f5c0d2c0a142434cc55ae6b2bb41452dd585a2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b79917fa068df2ee81bfb17c4587573574b8b1c4</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Use pattern matching features to extend data types</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>This advanced tutorial demonstrates how to use pattern matching techniques to create functionality using data and algorithms that are created separately.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Tutorial: Using pattern matching features to extend data types</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>C# 7 introduced basic pattern matching features.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Those features are extended in C# 8 with new expressions and patterns.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can write functionality that behaves as though you extended types that may be in other libraries.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Another use for patterns is to create functionality your application requires that isn't a fundamental feature of the type being extended.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In this tutorial, you'll learn how to:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Recognize situations where pattern matching should be used.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Use pattern matching expressions to implement behavior based on types and property values.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Combine pattern matching with other techniques to create complete algorithms.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You'll need to set up your machine to run .NET Core, including the C# 8.0 preview compiler.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The C# 8 preview compiler is available with the latest <bpt id="p1">[</bpt>Visual Studio 2019 preview<ept id="p1">](https://visualstudio.microsoft.com/vs/preview/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019+preview)</ept>, or the latest <bpt id="p2">[</bpt>.NET Core 3.0 preview<ept id="p2">](https://dotnet.microsoft.com/download/dotnet-core/3.0)</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Scenarios for pattern matching</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Modern development often includes integrating data from multiple sources and presenting information and insights from that data in a single cohesive application.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You and your team won't have control or access for all the types that represent the incoming data.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The classic object-oriented design would call for creating types in your application that represent each data type from those multiple data sources.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Then, your application would work with those new types, build inheritance hierarchies, create virtual methods, and implement abstractions.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Those techniques work, and sometimes they are the best tools.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Other times you can write less code.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can write more clear code using techniques that separate the data from the operations that manipulate that data.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In this tutorial, you'll create and explore an application that takes incoming data from several external sources for a single scenario.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You'll see how <bpt id="p1">**</bpt>pattern matching<ept id="p1">**</ept> provides an efficient way to consume and process that data in ways that weren't part of the original system.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Consider a major metro area that is using tolls and peak time pricing to manage traffic.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You write an application that calculates tolls for a vehicle based on its type.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Later enhancements incorporate pricing based on the number of occupants in the vehicle.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Further enhancements add pricing based on the time and the day of the week.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>From that brief description, you may have quickly sketched out an object hierarchy to model this system.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>However, your data is coming from multiple sources like other vehicle registration management systems.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>These systems provide different classes to model that data and you don't have a single object model you can use.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In this tutorial, you'll use these simplified classes to model for the vehicle data from these external systems, as shown in the following code:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can download the starter code from the <bpt id="p1">[</bpt>dotnet/samples<ept id="p1">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/start)</ept> GitHub repository.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can see that the vehicle classes are from different systems, and are in different namespaces.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>No common base class, other than <ph id="ph1">`System.Object`</ph> can be leveraged.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Pattern matching designs</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The scenario used in this tutorial highlights the kinds of problems that pattern matching is well-suited to solve:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The objects you need to work with aren't in an object hierarchy that matches your goals.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You may be working with classes that are part of unrelated systems.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The functionality you're adding isn't part of the core abstraction for these classes.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The toll paid by a vehicle <bpt id="p1">*</bpt>changes<ept id="p1">*</ept> for different types of vehicles, but the toll isn't a core function of the vehicle.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">*</bpt>shape<ept id="p1">*</ept> of the data and the <bpt id="p2">*</bpt>operations<ept id="p2">*</ept> on that data are not described together, the pattern matching features in C# make it easier to work with.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Implement the basic toll calculations</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The most basic toll calculation relies only on the vehicle type:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Car`</ph> is $2.00.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Taxi`</ph> is $3.50.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Bus`</ph> is $5.00.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`DeliveryTruck`</ph> is $10.00</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Create a new <ph id="ph1">`TollCalculator`</ph> class, and implement pattern matching on the vehicle type to get the toll amount.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following code shows the initial implementation of the <ph id="ph1">`TollCalculator`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The preceding code uses a <bpt id="p1">**</bpt>switch expression<ept id="p1">**</ept> (not the same as a <bpt id="p2">[</bpt><ph id="ph1">`switch`</ph><ept id="p2">](../language-reference/keywords/switch.md)</ept> statement) that tests the <bpt id="p3">**</bpt>type pattern<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>switch expression<ept id="p1">**</ept> begins with the variable, <ph id="ph1">`vehicle`</ph> in the preceding code, followed by the <ph id="ph2">`switch`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Next comes all the <bpt id="p1">**</bpt>switch arms<ept id="p1">**</ept> inside curly braces.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`switch`</ph> expression makes other refinements to the syntax that surrounds the <ph id="ph2">`switch`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`case`</ph> keyword is omitted, and the result of each arm is an expression.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The last two arms show a new language feature.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`{ }`</ph> case matches any non-null object that didn't match an earlier arm.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This arm catches any incorrect types passed to this method.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`{ }`</ph> case must follow the cases for each vehicle type.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If the order were reversed, the <ph id="ph1">`{ }`</ph> case would take precedence.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Finally, the <ph id="ph1">`null`</ph> pattern detects when a <ph id="ph2">`null`</ph> is passed to this method.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`null`</ph> pattern can be last because the other type patterns match only a non-null object of the correct type.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You can test this code using the following code in <ph id="ph1">`Program.cs`</ph>:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>That code is included in the starter project, but is commented out. Remove the comments, and you can test what you've written.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You're starting to see how patterns can help you create algorithms where the code and the data are separate.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`switch`</ph> expression tests the type and produces different values based on the results.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>That's only the beginning.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Add occupancy pricing</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The toll authority wants to encourage vehicles to travel at maximum capacity.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>They've decided to charge more when vehicles have fewer passengers, and encourage full vehicles by offering lower pricing:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Cars and taxis with no passengers pay an extra $0.50.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Cars and taxis with two passengers get a 0.50 discount.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Cars and taxis with three or more passengers get a $1.00 discount.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Buses that are less than 50% full pay an extra $2.00.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Buses that are more than 90% full get a $1.00 discount.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>These rules can be implemented using the <bpt id="p1">**</bpt>property pattern<ept id="p1">**</ept> in the same switch expression.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The property pattern examines properties of the object once the type has been determined.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The single case for a <ph id="ph1">`Car`</ph> expands to four different cases:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The first three cases test the type as a <ph id="ph1">`Car`</ph>, then check the value of the <ph id="ph2">`Passengers`</ph> property.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If both match, that expression is evaluated and returned.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You would also expand the cases for taxis in a similar manner:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In the preceding example, the <ph id="ph1">`when`</ph> clause was omitted on the final case.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Next, implement the occupancy rules by expanding the cases for buses, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The toll authority isn't concerned with the number of passengers in the delivery trucks.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Instead, they charge more based on the weight class of the trucks.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Trucks over 5000 lbs are charged an extra $5.00.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Light trucks under 3000 lbs are given a $2.00 discount.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>That rule is implemented with the following code:</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The preceding code shows the <ph id="ph1">`when`</ph> clause of a switch arm.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You use the <ph id="ph1">`when`</ph> clause to test conditions other than equality on a property.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you've finished, you'll have a method that looks much like the following:</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Many of these switch arms are examples of <bpt id="p1">**</bpt>recursive patterns<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`Car { Passengers: 1}`</ph> shows a constant pattern inside a property pattern.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can make this code less repetitive by using nested switches.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Car`</ph> and <ph id="ph2">`Taxi`</ph> both have four different arms in the preceding examples.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In both cases, you can create a type pattern that feeds into a property pattern.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This technique is shown in the following code:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In the preceding sample, using a recursive expression means you don't repeat the <ph id="ph1">`Car`</ph> and <ph id="ph2">`Taxi`</ph> arms containing child arms that test the property value.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This technique isn't used for the <ph id="ph1">`Bus`</ph> and <ph id="ph2">`DeliveryTruck`</ph> arms because those arms are testing ranges for the property, not discrete values.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Add peak pricing</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>For the final feature, the toll authority wants to add time sensitive peak pricing.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>During the morning and evening rush hours, the tolls are doubled.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>That rule only affects traffic in one direction: inbound to the city in the morning, and outbound in the evening rush hour.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>During other times during the workday, tolls increase by 50%.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Late night and early morning, tolls are reduced by 25%.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>During the weekend, it's the normal rate, regardless of the time.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You'll use pattern matching for this feature, but you'll integrate it with other techniques.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You could build a single pattern match expression that would account for all the combinations of direction, day of the week, and time.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The result would be a complicated expression.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>It would be hard to read and difficult to understand.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>That makes it hard to ensure correctness.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Instead, combine those methods to build a tuple of values that concisely describes all those states.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Then use pattern matching to calculate a multiplier for the toll.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The tuple contains three discrete conditions:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The day is either a weekday or a weekend.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The band of time when the toll is collected.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The direction is into the city or out of the city</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The following table shows the combinations of input values and the peak pricing multiplier:</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Day</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Time</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Direction</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Premium</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>morning rush</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>x 2.00</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>morning rush</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>daytime</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>x 1.50</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>daytime</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>x 1.50</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>evening rush</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>evening rush</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>x 2.00</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>overnight</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>x 0.75</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Weekday</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>overnight</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>x 0.75</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>morning rush</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>morning rush</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>daytime</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>daytime</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>evening rush</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>evening rush</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>overnight</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>inbound</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Weekend</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>overnight</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>outbound</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>x 1.00</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>There are 16 different combinations of the three variables.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>By combining some of the conditions, you'll simplify the final switch expression.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The system that collects the tolls uses a <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> structure for the time when the toll was collected.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Build member methods that create the variables from the preceding table.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The following function uses a pattern matching switch expression to express whether a <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> represents a weekend or a weekday:</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>That method works, but it's repetitious.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can simplify it, as shown in the following code:</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Next, add a similar function to categorize the time into the blocks:</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The previous method doesn't use pattern matching.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>It's clearer using a familiar cascade of <ph id="ph1">`if`</ph> statements.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>You do add a private <ph id="ph1">`enum`</ph> to convert each range of time to a discrete value.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>After you create those methods, you can use another <ph id="ph1">`switch`</ph> expression with the <bpt id="p1">**</bpt>tuple pattern<ept id="p1">**</ept> to calculate the pricing premium.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>You could build a <ph id="ph1">`switch`</ph> expression with all 16 arms:</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The above code works, but it can be simplified.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>All eight combinations for the weekend have the same toll.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>You can replace all eight with the following line:</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Both inbound and outbound traffic have the same multiplier during the weekday daytime and overnight hours.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Those four switch arms can be replaced with the following two lines:</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The code should look like the following code after those two changes:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Finally, you can remove the two rush hour times that pay the regular price.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Once you remove those arms, you can replace the <ph id="ph1">`false`</ph> with a discard (<ph id="ph2">`_`</ph>) in the final switch arm.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>You'll have the following finished method:</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>This example highlights one of the advantages of pattern matching: the pattern branches are evaluated in order.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>If you rearrange them so that an earlier branch handles one of your later cases, the compiler warns you about the unreachable code.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Those language rules made it easier to do the preceding simplifications with confidence that the code didn't change.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Pattern matching makes some types of code more readable and offers an alternative to object-oriented techniques when you can't add code to your classes.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The cloud is causing data and functionality to live apart.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>shape<ept id="p1">*</ept> of the data and the <bpt id="p2">*</bpt>operations<ept id="p2">*</ept> on it aren't necessarily described together.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>In this tutorial, you consumed existing data in entirely different ways from its original function.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Pattern matching gave you the ability to write functionality that overrode those types, even though you couldn't extend them.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Next steps</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>You can download the finished code from the <bpt id="p1">[</bpt>dotnet/samples<ept id="p1">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/finished)</ept> GitHub repository.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Explore patterns on your own and add this technique into your regular coding activities.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Learning these techniques gives you another way to approach problems and create new functionality.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>