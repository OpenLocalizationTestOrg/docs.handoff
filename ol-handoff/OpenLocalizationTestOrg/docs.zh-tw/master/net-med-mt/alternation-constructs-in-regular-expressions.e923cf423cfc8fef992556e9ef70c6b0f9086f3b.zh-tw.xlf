<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="alternation-constructs-in-regular-expressions.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a784c699bff79fe6384f21b91fe7a34b8be56843</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\alternation-constructs-in-regular-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0caf612bbac8c87c021b09a1201a6f9b9226813f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c5b9d5922f1e2996ca7ff7dee8de2085c997a0d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Alternation Constructs in Regular Expressions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Alternation Constructs in Regular Expressions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Alternation constructs modify a regular expression to enable either/or or conditional matching.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET supports three alternation constructs:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Pattern matching with &amp;#124;<ept id="p1">](#Either_Or)</ept></source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Conditional matching with (?(expression)yes&amp;#124;no)<ept id="p1">](#Conditional_Expr)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Conditional matching based on a valid captured group<ept id="p1">](#Conditional_Group)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Pattern Matching with &amp;#124;</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can use the vertical bar (<ph id="ph1">`|`</ph>) character to match any one of a series of patterns, where the <ph id="ph2">`|`</ph> character separates each pattern.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Like the positive character class, the <ph id="ph1">`|`</ph> character can be used to match any one of a number of single characters.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The following example uses both a positive character class and either/or pattern matching with the <ph id="ph1">`|`</ph> character to locate occurrences of the words "gray" or "grey" in a string.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">`|`</ph> character produces a regular expression that is more verbose.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The regular expression that uses the <ph id="ph1">`|`</ph> character, <ph id="ph2">`\bgr(a|e)y\b`</ph>, is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Match the characters "gr".</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Match either an "a" or an "e".</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Match a "y" on a word boundary.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`|`</ph> character can also be used to perform an either/or match with multiple characters or subexpressions, which can include any combination of character literals and regular expression language elements.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>(The character class does not provide this functionality.) The following example uses the <ph id="ph1">`|`</ph> character to extract either a U.S. Social Security Number (SSN), which is a 9-digit number with the format <bpt id="p1">*</bpt>ddd<ept id="p1">*</ept><ph id="ph2">-</ph><bpt id="p2">*</bpt>dd<ept id="p2">*</ept><ph id="ph3">-</ph><bpt id="p3">*</bpt>dddd<ept id="p3">*</ept>, or a U.S. Employer Identification Number (EIN), which is a 9-digit number with the format <bpt id="p4">*</bpt>dd<ept id="p4">*</ept><ph id="ph4">-</ph><bpt id="p5">*</bpt>ddddddd<ept id="p5">*</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Match either of the following: two decimal digits followed by a hyphen followed by seven decimal digits; or three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Conditional Matching with an Expression</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Its syntax is:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?(`</ph> <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> <ph id="ph2">`)`</ph> <bpt id="p2">*</bpt>yes<ept id="p2">*</ept> <ph id="ph3">`|`</ph> <bpt id="p3">*</bpt>no<ept id="p3">*</ept> <ph id="ph4">`)`</ph></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> is the initial pattern to match, <bpt id="p2">*</bpt>yes<ept id="p2">*</ept> is the pattern to match if <bpt id="p3">*</bpt>expression<ept id="p3">*</ept> is matched, and <bpt id="p4">*</bpt>no<ept id="p4">*</ept> is the optional pattern to match if <bpt id="p5">*</bpt>expression<ept id="p5">*</ept> is not matched.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The regular expression engine treats <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> as a zero-width assertion; that is, the regular expression engine does not advance in the input stream after it evaluates <bpt id="p2">*</bpt>expression<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Therefore, this construct is equivalent to the following:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?(?=`</ph> <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> <ph id="ph2">`)`</ph> <bpt id="p2">*</bpt>yes<ept id="p2">*</ept> <ph id="ph3">`|`</ph> <bpt id="p3">*</bpt>no<ept id="p3">*</ept> <ph id="ph4">`)`</ph></source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>where <ph id="ph1">`(?=`</ph><bpt id="p1">*</bpt>expression<ept id="p1">*</ept><ph id="ph2">`)`</ph> is a zero-width assertion construct.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) Because the regular expression engine interprets <bpt id="p2">*</bpt>expression<ept id="p2">*</ept> as an anchor (a zero-width assertion), <bpt id="p3">*</bpt>expression<ept id="p3">*</ept> must either be a zero-width assertion (for more information, see <bpt id="p4">[</bpt>Anchors<ept id="p4">](../../../docs/standard/base-types/anchors-in-regular-expressions.md)</ept>) or a subexpression that is also contained in <bpt id="p5">*</bpt>yes<ept id="p5">*</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Otherwise, the <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> pattern cannot be matched.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>expression<ept id="p1">*</ept>is a named or numbered capturing group, the alternation construct is interpreted as a capture test; for more information, see the next section, <bpt id="p2">[</bpt>Conditional Matching Based on a Valid Capture Group<ept id="p2">](#Conditional_Group)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In other words, the regular expression engine does not attempt to match the captured substring, but instead tests for the presence or absence of the group.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example is a variation of the example that appears in the <bpt id="p1">[</bpt>Either/Or Pattern Matching with &amp;#124;<ept id="p1">](#Either_Or)</ept> section.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>It uses conditional matching to determine whether the first three characters after a word boundary are two digits followed by a hyphen.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If they are, it attempts to match a U.S. Employer Identification Number (EIN).</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If not, it attempts to match a U.S. Social Security Number (SSN).</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Determine whether the next three characters consist of two digits followed by a hyphen.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If the previous pattern matches, match two digits followed by a hyphen followed by seven digits.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If the previous pattern does not match, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Conditional Matching Based on a Valid Captured Group</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Its syntax is:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?(`</ph> <bpt id="p1">*</bpt>name<ept id="p1">*</ept> <ph id="ph2">`)`</ph> <bpt id="p2">*</bpt>yes<ept id="p2">*</ept> <ph id="ph3">`|`</ph> <bpt id="p3">*</bpt>no<ept id="p3">*</ept> <ph id="ph4">`)`</ph></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?(`</ph> <bpt id="p1">*</bpt>number<ept id="p1">*</ept> <ph id="ph2">`)`</ph> <bpt id="p2">*</bpt>yes<ept id="p2">*</ept> <ph id="ph3">`|`</ph> <bpt id="p3">*</bpt>no<ept id="p3">*</ept> <ph id="ph4">`)`</ph></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the name and <bpt id="p2">*</bpt>number<ept id="p2">*</ept> is the number of a capturing group, <bpt id="p3">*</bpt>yes<ept id="p3">*</ept> is the expression to match if <bpt id="p4">*</bpt>name<ept id="p4">*</ept> or <bpt id="p5">*</bpt>number<ept id="p5">*</ept> has a match, and <bpt id="p6">*</bpt>no<ept id="p6">*</ept> is the optional expression to match if it does not.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>name<ept id="p1">*</ept> does not correspond to the name of a capturing group that is used in the regular expression pattern, the alternation construct is interpreted as an expression test, as explained in the previous section.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Typically, this means that <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> evaluates to <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>number<ept id="p1">*</ept> does not correspond to a numbered capturing group that is used in the regular expression pattern, the regular expression engine throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following example is a variation of the example that appears in the <bpt id="p1">[</bpt>Either/Or Pattern Matching with &amp;#124;<ept id="p1">](#Either_Or)</ept> section.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses a capturing group named <ph id="ph1">`n2`</ph> that consists of two digits followed by a hyphen.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The alternation construct tests whether this capturing group has been matched in the input string.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If it has, the alternation construct attempts to match the last seven digits of a nine-digit U.S. Employer Identification Number (EIN).</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If it has not, it attempts to match a nine-digit U.S. Social Security Number (SSN).</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?&lt;n2&gt;\d{2}-)*(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of two digits followed by a hyphen.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`n2`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Test whether <ph id="ph1">`n2`</ph> was matched in the input string.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`n2`</ph> was matched, match seven decimal digits.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`n2`</ph> was not matched, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>A variation of this example that uses a numbered group instead of a named group is shown in the following example.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Its regular expression pattern is <ph id="ph1">`\b(\d{2}-)*(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>